[
 {
  "idx": "maxmin-1",
  "nl_tokens": [
   "Returns",
   "intermediary",
   "colors",
   "for",
   "given",
   "list",
   "of",
   "colors",
   "."
  ],
  "pl_tokens": [
   "def",
   "_interpolate",
   "(",
   "self",
   ",",
   "colors",
   ",",
   "n",
   "=",
   "100",
   ")",
   ":",
   "gradient",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "_range",
   "(",
   "n",
   ")",
   ":",
   "l",
   "=",
   "len",
   "(",
   "colors",
   ")",
   "-",
   "1",
   "x",
   "=",
   "int",
   "(",
   "1.0",
   "*",
   "i",
   "/",
   "n",
   "*",
   "l",
   ")",
   "x",
   "=",
   "<mask>",
   "(",
   "x",
   "+",
   "0",
   ",",
   "l",
   ")",
   "y",
   "=",
   "min",
   "(",
   "x",
   "+",
   "1",
   ",",
   "l",
   ")",
   "base",
   "=",
   "1.0",
   "*",
   "n",
   "/",
   "l",
   "*",
   "x",
   "d",
   "=",
   "(",
   "i",
   "-",
   "base",
   ")",
   "/",
   "(",
   "1.0",
   "*",
   "n",
   "/",
   "l",
   ")",
   "r",
   "=",
   "colors",
   "[",
   "x",
   "]",
   ".",
   "r",
   "*",
   "(",
   "1",
   "-",
   "d",
   ")",
   "+",
   "colors",
   "[",
   "y",
   "]",
   ".",
   "r",
   "*",
   "d",
   "g",
   "=",
   "colors",
   "[",
   "x",
   "]",
   ".",
   "g",
   "*",
   "(",
   "1",
   "-",
   "d",
   ")",
   "+",
   "colors",
   "[",
   "y",
   "]",
   ".",
   "g",
   "*",
   "d",
   "b",
   "=",
   "colors",
   "[",
   "x",
   "]",
   ".",
   "b",
   "*",
   "(",
   "1",
   "-",
   "d",
   ")",
   "+",
   "colors",
   "[",
   "y",
   "]",
   ".",
   "b",
   "*",
   "d",
   "a",
   "=",
   "colors",
   "[",
   "x",
   "]",
   ".",
   "a",
   "*",
   "(",
   "1",
   "-",
   "d",
   ")",
   "+",
   "colors",
   "[",
   "y",
   "]",
   ".",
   "a",
   "*",
   "d",
   "gradient",
   ".",
   "append",
   "(",
   "color",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ",",
   "a",
   ",",
   "mode",
   "=",
   "\"rgb\"",
   ")",
   ")",
   "gradient",
   ".",
   "append",
   "(",
   "colors",
   "[",
   "-",
   "1",
   "]",
   ")",
   "return",
   "gradient"
  ]
 },
 {
  "idx": "maxmin-2",
  "nl_tokens": [
   "Map",
   "-",
   "reduce",
   "with",
   "multile",
   "processes",
   "."
  ],
  "pl_tokens": [
   "def",
   "map",
   "(",
   "self",
   ",",
   "func",
   ",",
   "sequence",
   ",",
   "reduce",
   "=",
   "None",
   ",",
   "star",
   "=",
   "False",
   ",",
   "minlength",
   "=",
   "0",
   ")",
   ":",
   "def",
   "realreduce",
   "(",
   "r",
   ")",
   ":",
   "if",
   "reduce",
   ":",
   "if",
   "isinstance",
   "(",
   "r",
   ",",
   "tuple",
   ")",
   ":",
   "return",
   "reduce",
   "(",
   "*",
   "r",
   ")",
   "else",
   ":",
   "return",
   "reduce",
   "(",
   "r",
   ")",
   "return",
   "r",
   "def",
   "realfunc",
   "(",
   "i",
   ")",
   ":",
   "if",
   "star",
   ":",
   "return",
   "func",
   "(",
   "*",
   "i",
   ")",
   "else",
   ":",
   "return",
   "func",
   "(",
   "i",
   ")",
   "if",
   "len",
   "(",
   "sequence",
   ")",
   "<=",
   "0",
   "or",
   "self",
   ".",
   "np",
   "==",
   "0",
   "or",
   "get_debug",
   "(",
   ")",
   ":",
   "# Do this in serial",
   "self",
   ".",
   "local",
   "=",
   "lambda",
   ":",
   "None",
   "self",
   ".",
   "local",
   ".",
   "rank",
   "=",
   "0",
   "rt",
   "=",
   "[",
   "realreduce",
   "(",
   "realfunc",
   "(",
   "i",
   ")",
   ")",
   "for",
   "i",
   "in",
   "sequence",
   "]",
   "self",
   ".",
   "local",
   "=",
   "None",
   "return",
   "rt",
   "# never use more than len(sequence) processes",
   "np",
   "=",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "np",
   ",",
   "len",
   "(",
   "sequence",
   ")",
   "]",
   ")",
   "Q",
   "=",
   "self",
   ".",
   "backend",
   ".",
   "QueueFactory",
   "(",
   "64",
   ")",
   "R",
   "=",
   "self",
   ".",
   "backend",
   ".",
   "QueueFactory",
   "(",
   "64",
   ")",
   "self",
   ".",
   "ordered",
   ".",
   "reset",
   "(",
   ")",
   "pg",
   "=",
   "ProcessGroup",
   "(",
   "main",
   "=",
   "self",
   ".",
   "_main",
   ",",
   "np",
   "=",
   "np",
   ",",
   "backend",
   "=",
   "self",
   ".",
   "backend",
   ",",
   "args",
   "=",
   "(",
   "Q",
   ",",
   "R",
   ",",
   "sequence",
   ",",
   "realfunc",
   ")",
   ")",
   "pg",
   ".",
   "start",
   "(",
   ")",
   "L",
   "=",
   "[",
   "]",
   "N",
   "=",
   "[",
   "]",
   "def",
   "feeder",
   "(",
   "pg",
   ",",
   "Q",
   ",",
   "N",
   ")",
   ":",
   "#   will fail silently if any error occurs.",
   "j",
   "=",
   "0",
   "try",
   ":",
   "for",
   "i",
   ",",
   "work",
   "in",
   "enumerate",
   "(",
   "sequence",
   ")",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "sequence",
   ",",
   "'__getitem__'",
   ")",
   ":",
   "pg",
   ".",
   "put",
   "(",
   "Q",
   ",",
   "(",
   "i",
   ",",
   "work",
   ")",
   ")",
   "else",
   ":",
   "pg",
   ".",
   "put",
   "(",
   "Q",
   ",",
   "(",
   "i",
   ",",
   ")",
   ")",
   "j",
   "=",
   "j",
   "+",
   "1",
   "N",
   ".",
   "append",
   "(",
   "j",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "np",
   ")",
   ":",
   "pg",
   ".",
   "put",
   "(",
   "Q",
   ",",
   "None",
   ")",
   "except",
   "StopProcessGroup",
   ":",
   "return",
   "finally",
   ":",
   "pass",
   "feeder",
   "=",
   "threading",
   ".",
   "Thread",
   "(",
   "None",
   ",",
   "feeder",
   ",",
   "args",
   "=",
   "(",
   "pg",
   ",",
   "Q",
   ",",
   "N",
   ")",
   ")",
   "feeder",
   ".",
   "start",
   "(",
   ")",
   "# we run fetcher on main thread to catch exceptions",
   "# raised by reduce ",
   "count",
   "=",
   "0",
   "try",
   ":",
   "while",
   "True",
   ":",
   "try",
   ":",
   "capsule",
   "=",
   "pg",
   ".",
   "get",
   "(",
   "R",
   ")",
   "except",
   "queue",
   ".",
   "Empty",
   ":",
   "continue",
   "except",
   "StopProcessGroup",
   ":",
   "raise",
   "pg",
   ".",
   "get_exception",
   "(",
   ")",
   "capsule",
   "=",
   "capsule",
   "[",
   "0",
   "]",
   ",",
   "realreduce",
   "(",
   "capsule",
   "[",
   "1",
   "]",
   ")",
   "heapq",
   ".",
   "heappush",
   "(",
   "L",
   ",",
   "capsule",
   ")",
   "count",
   "=",
   "count",
   "+",
   "1",
   "if",
   "len",
   "(",
   "N",
   ")",
   ">",
   "0",
   "and",
   "count",
   "==",
   "N",
   "[",
   "0",
   "]",
   ":",
   "# if finished feeding see if all",
   "# results have been obtained",
   "break",
   "rt",
   "=",
   "[",
   "]",
   "#            R.close()",
   "#            R.join_thread()",
   "while",
   "len",
   "(",
   "L",
   ")",
   ">",
   "0",
   ":",
   "rt",
   ".",
   "append",
   "(",
   "heapq",
   ".",
   "heappop",
   "(",
   "L",
   ")",
   "[",
   "1",
   "]",
   ")",
   "pg",
   ".",
   "join",
   "(",
   ")",
   "feeder",
   ".",
   "join",
   "(",
   ")",
   "assert",
   "N",
   "[",
   "0",
   "]",
   "==",
   "len",
   "(",
   "rt",
   ")",
   "return",
   "rt",
   "except",
   "BaseException",
   "as",
   "e",
   ":",
   "pg",
   ".",
   "killall",
   "(",
   ")",
   "pg",
   ".",
   "join",
   "(",
   ")",
   "feeder",
   ".",
   "join",
   "(",
   ")",
   "raise"
  ]
 },
 {
  "idx": "maxmin-3",
  "nl_tokens": [
   "From",
   "http",
   ":",
   "//",
   "stackoverflow",
   ".",
   "com",
   "/",
   "a",
   "/",
   "8290508",
   "/",
   "270334",
   ":",
   "param",
   "n",
   ":",
   ":",
   "param",
   "iterable",
   ":"
  ],
  "pl_tokens": [
   "def",
   "batches",
   "(",
   "iterable",
   ",",
   "n",
   "=",
   "1",
   ")",
   ":",
   "l",
   "=",
   "len",
   "(",
   "iterable",
   ")",
   "for",
   "ndx",
   "in",
   "range",
   "(",
   "0",
   ",",
   "l",
   ",",
   "n",
   ")",
   ":",
   "yield",
   "iterable",
   "[",
   "ndx",
   ":",
   "<mask>",
   "(",
   "ndx",
   "+",
   "n",
   ",",
   "l",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-4",
  "nl_tokens": [
   "Plots",
   "an",
   "array",
   "of",
   "*",
   "images",
   "*",
   "to",
   "a",
   "single",
   "window",
   "of",
   "size",
   "*",
   "figsize",
   "*",
   "with",
   "*",
   "rows",
   "*",
   "and",
   "*",
   "columns",
   "*",
   "."
  ],
  "pl_tokens": [
   "def",
   "imshow_batch",
   "(",
   "images",
   ",",
   "cbar",
   "=",
   "True",
   ",",
   "show",
   "=",
   "True",
   ",",
   "pdf",
   "=",
   "None",
   ",",
   "figsize",
   "=",
   "(",
   "16",
   ",",
   "12",
   ")",
   ",",
   "rows",
   "=",
   "2",
   ",",
   "columns",
   "=",
   "2",
   ",",
   "cmap",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# ======================================",
   "# Set up grid",
   "# ======================================",
   "images",
   "=",
   "_np",
   ".",
   "array",
   "(",
   "images",
   ")",
   "gs",
   "=",
   "_gridspec",
   ".",
   "GridSpec",
   "(",
   "rows",
   ",",
   "columns",
   ")",
   "num_imgs",
   "=",
   "images",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "max_ind",
   "=",
   "num_imgs",
   "-",
   "1",
   "# ======================================",
   "# Split into pages",
   "# ======================================",
   "per_page",
   "=",
   "rows",
   "*",
   "columns",
   "num_pages",
   "=",
   "_np",
   ".",
   "int",
   "(",
   "_np",
   ".",
   "ceil",
   "(",
   "num_imgs",
   "/",
   "per_page",
   ")",
   ")",
   "fig_array",
   "=",
   "_np",
   ".",
   "empty",
   "(",
   "shape",
   "=",
   "num_pages",
   ",",
   "dtype",
   "=",
   "object",
   ")",
   "if",
   "num_pages",
   ">",
   "1",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "'Multiple pages necessary'",
   ")",
   "if",
   "pdf",
   "is",
   "not",
   "None",
   ":",
   "f",
   "=",
   "_PdfPages",
   "(",
   "pdf",
   ")",
   "for",
   "p",
   "in",
   "range",
   "(",
   "num_pages",
   ")",
   ":",
   "# ======================================",
   "# Make figure",
   "# ======================================",
   "fig_array",
   "[",
   "p",
   "]",
   "=",
   "_plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "figsize",
   ")",
   "# ======================================",
   "# Get number of rows on page",
   "# ======================================",
   "pg_max_ind",
   "=",
   "_np",
   ".",
   "<mask>",
   "(",
   "[",
   "(",
   "p",
   "+",
   "1",
   ")",
   "*",
   "per_page",
   "-",
   "1",
   ",",
   "max_ind",
   "]",
   ")",
   "num_rows",
   "=",
   "_np",
   ".",
   "int",
   "(",
   "_np",
   ".",
   "ceil",
   "(",
   "(",
   "pg_max_ind",
   "+",
   "1",
   "-",
   "p",
   "*",
   "per_page",
   ")",
   "/",
   "columns",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "num_rows",
   ")",
   ":",
   "# ======================================",
   "# Get images for column",
   "# ======================================",
   "i_min_ind",
   "=",
   "p",
   "*",
   "per_page",
   "+",
   "i",
   "*",
   "columns",
   "col_max_ind",
   "=",
   "_np",
   ".",
   "min",
   "(",
   "[",
   "i_min_ind",
   "+",
   "columns",
   "-",
   "1",
   ",",
   "max_ind",
   "]",
   ")",
   "for",
   "j",
   ",",
   "image",
   "in",
   "enumerate",
   "(",
   "images",
   "[",
   "i_min_ind",
   ":",
   "col_max_ind",
   "+",
   "1",
   "]",
   ")",
   ":",
   "ax",
   "=",
   "fig_array",
   "[",
   "p",
   "]",
   ".",
   "add_subplot",
   "(",
   "gs",
   "[",
   "i",
   ",",
   "j",
   "]",
   ")",
   "try",
   ":",
   "if",
   "_np",
   ".",
   "issubdtype",
   "(",
   "image",
   ".",
   "dtype",
   ",",
   "_np",
   ".",
   "integer",
   ")",
   ":",
   "image",
   "=",
   "_np",
   ".",
   "array",
   "(",
   "image",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "except",
   ":",
   "pass",
   "plot",
   "=",
   "ax",
   ".",
   "imshow",
   "(",
   "image",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "if",
   "cmap",
   "is",
   "not",
   "None",
   ":",
   "plot",
   ".",
   "set_cmap",
   "(",
   "cmap",
   ")",
   "if",
   "cbar",
   ":",
   "fig_array",
   "[",
   "p",
   "]",
   ".",
   "colorbar",
   "(",
   "plot",
   ")",
   "fig_array",
   "[",
   "p",
   "]",
   ".",
   "tight_layout",
   "(",
   ")",
   "if",
   "pdf",
   "is",
   "not",
   "None",
   ":",
   "f",
   ".",
   "savefig",
   "(",
   "fig_array",
   "[",
   "p",
   "]",
   ")",
   "if",
   "not",
   "show",
   ":",
   "_plt",
   ".",
   "close",
   "(",
   "fig_array",
   "[",
   "p",
   "]",
   ")",
   "if",
   "pdf",
   "is",
   "not",
   "None",
   ":",
   "f",
   ".",
   "close",
   "(",
   ")",
   "return",
   "fig_array"
  ]
 },
 {
  "idx": "maxmin-5",
  "nl_tokens": [
   "The",
   "minimum",
   "and",
   "maximum",
   "bounds",
   "of",
   "this",
   "layout",
   "."
  ],
  "pl_tokens": [
   "def",
   "bounding_box",
   "(",
   "self",
   ")",
   ":",
   "min_x",
   ",",
   "min_y",
   ",",
   "max_x",
   ",",
   "max_y",
   "=",
   "zip",
   "(",
   "*",
   "list",
   "(",
   "self",
   ".",
   "walk_rows",
   "(",
   "lambda",
   "row",
   ":",
   "row",
   ".",
   "bounding_box",
   ")",
   ")",
   ")",
   "return",
   "<mask>",
   "(",
   "min_x",
   ")",
   ",",
   "min",
   "(",
   "min_y",
   ")",
   ",",
   "max",
   "(",
   "max_x",
   ")",
   ",",
   "max",
   "(",
   "max_y",
   ")"
  ]
 },
 {
  "idx": "maxmin-6",
  "nl_tokens": [
   "Runs",
   "the",
   "Box",
   "Least",
   "Squares",
   "Fitting",
   "Search",
   "for",
   "transit",
   "-",
   "shaped",
   "signals",
   "."
  ],
  "pl_tokens": [
   "def",
   "bls_serial_pfind",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "startp",
   "=",
   "0.1",
   ",",
   "# search from 0.1 d to...",
   "endp",
   "=",
   "100.0",
   ",",
   "# ... 100.0 d -- don't search full timebase",
   "stepsize",
   "=",
   "5.0e-4",
   ",",
   "mintransitduration",
   "=",
   "0.01",
   ",",
   "# minimum transit length in phase",
   "maxtransitduration",
   "=",
   "0.4",
   ",",
   "# maximum transit length in phase",
   "ndurations",
   "=",
   "100",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "# figure out f0, nf, and df automatically",
   "blsobjective",
   "=",
   "'likelihood'",
   ",",
   "blsmethod",
   "=",
   "'fast'",
   ",",
   "blsoversample",
   "=",
   "10",
   ",",
   "blsmintransits",
   "=",
   "3",
   ",",
   "blsfreqfactor",
   "=",
   "10.0",
   ",",
   "periodepsilon",
   "=",
   "0.1",
   ",",
   "nbestpeaks",
   "=",
   "5",
   ",",
   "sigclip",
   "=",
   "10.0",
   ",",
   "verbose",
   "=",
   "True",
   ",",
   "raiseonfail",
   "=",
   "False",
   ")",
   ":",
   "# get rid of nans first and sigclip",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# if we're setting up everything automatically",
   "if",
   "isinstance",
   "(",
   "autofreq",
   ",",
   "bool",
   ")",
   "and",
   "autofreq",
   ":",
   "# use heuristic to figure out best timestep",
   "stepsize",
   "=",
   "0.25",
   "*",
   "mintransitduration",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# now figure out the frequencies to use",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = True: using AUTOMATIC values for '",
   "'freq stepsize: %s, ndurations: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "ndurations",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "use_autoperiod",
   "=",
   "False",
   "elif",
   "isinstance",
   "(",
   "autofreq",
   ",",
   "bool",
   ")",
   "and",
   "not",
   "autofreq",
   ":",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = False: using PROVIDED values for '",
   "'freq stepsize: %s, ndurations: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "ndurations",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "use_autoperiod",
   "=",
   "False",
   "elif",
   "isinstance",
   "(",
   "autofreq",
   ",",
   "str",
   ")",
   "and",
   "autofreq",
   "==",
   "'astropy'",
   ":",
   "use_autoperiod",
   "=",
   "True",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "else",
   ":",
   "LOGERROR",
   "(",
   "\"unknown autofreq kwarg encountered. can't continue...\"",
   ")",
   "return",
   "None",
   "# check the time-base vs. endp value",
   "if",
   "minfreq",
   "<",
   "(",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   ":",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'the requested max P = %.3f is larger than '",
   "'the time base of the observations = %.3f, '",
   "' will make minfreq = 2 x 1/timebase'",
   "%",
   "(",
   "endp",
   ",",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "minfreq",
   "=",
   "2.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'new minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "# run BLS",
   "try",
   ":",
   "# astropy's BLS requires durations in units of time",
   "durations",
   "=",
   "nplinspace",
   "(",
   "mintransitduration",
   "*",
   "startp",
   ",",
   "maxtransitduration",
   "*",
   "startp",
   ",",
   "ndurations",
   ")",
   "# set up the correct units for the BLS model",
   "if",
   "magsarefluxes",
   ":",
   "blsmodel",
   "=",
   "BoxLeastSquares",
   "(",
   "stimes",
   "*",
   "u",
   ".",
   "day",
   ",",
   "smags",
   "*",
   "u",
   ".",
   "dimensionless_unscaled",
   ",",
   "dy",
   "=",
   "serrs",
   "*",
   "u",
   ".",
   "dimensionless_unscaled",
   ")",
   "else",
   ":",
   "blsmodel",
   "=",
   "BoxLeastSquares",
   "(",
   "stimes",
   "*",
   "u",
   ".",
   "day",
   ",",
   "smags",
   "*",
   "u",
   ".",
   "mag",
   ",",
   "dy",
   "=",
   "serrs",
   "*",
   "u",
   ".",
   "mag",
   ")",
   "# use autoperiod if requested",
   "if",
   "use_autoperiod",
   ":",
   "periods",
   "=",
   "nparray",
   "(",
   "blsmodel",
   ".",
   "autoperiod",
   "(",
   "durations",
   ",",
   "minimum_period",
   "=",
   "startp",
   ",",
   "maximum_period",
   "=",
   "endp",
   ",",
   "minimum_n_transit",
   "=",
   "blsmintransits",
   ",",
   "frequency_factor",
   "=",
   "blsfreqfactor",
   ")",
   ")",
   "nfreq",
   "=",
   "periods",
   ".",
   "size",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "\"autofreq = 'astropy', used .autoperiod() with \"",
   "\"minimum_n_transit = %s, freq_factor = %s \"",
   "\"to generate the frequency grid\"",
   "%",
   "(",
   "blsmintransits",
   ",",
   "blsfreqfactor",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'stepsize = %.5f, nfreq = %s, minfreq = %.5f, '",
   "'maxfreq = %.5f, ndurations = %s'",
   "%",
   "(",
   "abs",
   "(",
   "1.0",
   "/",
   "periods",
   "[",
   "1",
   "]",
   "-",
   "1.0",
   "/",
   "periods",
   "[",
   "0",
   "]",
   ")",
   ",",
   "nfreq",
   ",",
   "1.0",
   "/",
   "periods",
   ".",
   "max",
   "(",
   ")",
   ",",
   "1.0",
   "/",
   "periods",
   ".",
   "min",
   "(",
   ")",
   ",",
   "durations",
   ".",
   "size",
   ")",
   ")",
   "# otherwise, use kbls method",
   "else",
   ":",
   "frequencies",
   "=",
   "minfreq",
   "+",
   "nparange",
   "(",
   "nfreq",
   ")",
   "*",
   "stepsize",
   "periods",
   "=",
   "1.0",
   "/",
   "frequencies",
   "if",
   "nfreq",
   ">",
   "5.0e5",
   ":",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'more than 5.0e5 frequencies to go through; '",
   "'this will take a while. '",
   "'you might want to use the '",
   "'abls.bls_parallel_pfind function instead'",
   ")",
   "# run the periodogram",
   "blsresult",
   "=",
   "blsmodel",
   ".",
   "power",
   "(",
   "periods",
   "*",
   "u",
   ".",
   "day",
   ",",
   "durations",
   "*",
   "u",
   ".",
   "day",
   ",",
   "objective",
   "=",
   "blsobjective",
   ",",
   "method",
   "=",
   "blsmethod",
   ",",
   "oversample",
   "=",
   "blsoversample",
   ")",
   "# get the peak values",
   "lsp",
   "=",
   "nparray",
   "(",
   "blsresult",
   ".",
   "power",
   ")",
   "# find the nbestpeaks for the periodogram: 1. sort the lsp array",
   "# by highest value first 2. go down the values until we find",
   "# five values that are separated by at least periodepsilon in",
   "# period",
   "# make sure to get only the finite peaks in the periodogram",
   "# this is needed because BLS may produce infs for some peaks",
   "finitepeakind",
   "=",
   "npisfinite",
   "(",
   "lsp",
   ")",
   "finlsp",
   "=",
   "lsp",
   "[",
   "finitepeakind",
   "]",
   "finperiods",
   "=",
   "periods",
   "[",
   "finitepeakind",
   "]",
   "# make sure that finlsp has finite values before we work on it",
   "try",
   ":",
   "bestperiodind",
   "=",
   "npargmax",
   "(",
   "finlsp",
   ")",
   "except",
   "ValueError",
   ":",
   "LOGERROR",
   "(",
   "'no finite periodogram values '",
   "'for this mag series, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestinds'",
   ":",
   "None",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'durations'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'blsmodel'",
   ":",
   "None",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'blsntransits'",
   ":",
   "blsmintransits",
   ",",
   "'blsfreqfactor'",
   ":",
   "blsfreqfactor",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "sortedlspind",
   "=",
   "npargsort",
   "(",
   "finlsp",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "sortedlspperiods",
   "=",
   "finperiods",
   "[",
   "sortedlspind",
   "]",
   "sortedlspvals",
   "=",
   "finlsp",
   "[",
   "sortedlspind",
   "]",
   "# now get the nbestpeaks",
   "nbestperiods",
   ",",
   "nbestlspvals",
   ",",
   "nbestinds",
   ",",
   "peakcount",
   "=",
   "(",
   "[",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "bestperiodind",
   "]",
   ",",
   "1",
   ")",
   "prevperiod",
   "=",
   "sortedlspperiods",
   "[",
   "0",
   "]",
   "# find the best nbestpeaks in the lsp and their periods",
   "for",
   "period",
   ",",
   "lspval",
   ",",
   "ind",
   "in",
   "zip",
   "(",
   "sortedlspperiods",
   ",",
   "sortedlspvals",
   ",",
   "sortedlspind",
   ")",
   ":",
   "if",
   "peakcount",
   "==",
   "nbestpeaks",
   ":",
   "break",
   "perioddiff",
   "=",
   "abs",
   "(",
   "period",
   "-",
   "prevperiod",
   ")",
   "bestperiodsdiff",
   "=",
   "[",
   "abs",
   "(",
   "period",
   "-",
   "x",
   ")",
   "for",
   "x",
   "in",
   "nbestperiods",
   "]",
   "# print('prevperiod = %s, thisperiod = %s, '",
   "#       'perioddiff = %s, peakcount = %s' %",
   "#       (prevperiod, period, perioddiff, peakcount))",
   "# this ensures that this period is different from the last",
   "# period and from all the other existing best periods by",
   "# periodepsilon to make sure we jump to an entire different",
   "# peak in the periodogram",
   "if",
   "(",
   "perioddiff",
   ">",
   "(",
   "periodepsilon",
   "*",
   "prevperiod",
   ")",
   "and",
   "all",
   "(",
   "x",
   ">",
   "(",
   "periodepsilon",
   "*",
   "period",
   ")",
   "for",
   "x",
   "in",
   "bestperiodsdiff",
   ")",
   ")",
   ":",
   "nbestperiods",
   ".",
   "append",
   "(",
   "period",
   ")",
   "nbestlspvals",
   ".",
   "append",
   "(",
   "lspval",
   ")",
   "nbestinds",
   ".",
   "append",
   "(",
   "ind",
   ")",
   "peakcount",
   "=",
   "peakcount",
   "+",
   "1",
   "prevperiod",
   "=",
   "period",
   "# generate the return dict",
   "resultdict",
   "=",
   "{",
   "'bestperiod'",
   ":",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'bestlspval'",
   ":",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestinds'",
   ":",
   "nbestinds",
   ",",
   "'nbestlspvals'",
   ":",
   "nbestlspvals",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'lspvals'",
   ":",
   "lsp",
   ",",
   "'frequencies'",
   ":",
   "frequencies",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'durations'",
   ":",
   "durations",
   ",",
   "'blsresult'",
   ":",
   "blsresult",
   ",",
   "'blsmodel'",
   ":",
   "blsmodel",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "nfreq",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'blsntransits'",
   ":",
   "blsmintransits",
   ",",
   "'blsfreqfactor'",
   ":",
   "blsfreqfactor",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "return",
   "resultdict",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "LOGEXCEPTION",
   "(",
   "'BLS failed!'",
   ")",
   "if",
   "raiseonfail",
   ":",
   "raise",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestinds'",
   ":",
   "None",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'durations'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'blsmodel'",
   ":",
   "None",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "nfreq",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'blsntransits'",
   ":",
   "blsmintransits",
   ",",
   "'blsfreqfactor'",
   ":",
   "blsfreqfactor",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestinds'",
   ":",
   "None",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'durations'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'blsmodel'",
   ":",
   "None",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "None",
   ",",
   "'nphasebins'",
   ":",
   "None",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'blsntransits'",
   ":",
   "blsmintransits",
   ",",
   "'blsfreqfactor'",
   ":",
   "blsfreqfactor",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}"
  ]
 },
 {
  "idx": "maxmin-7",
  "nl_tokens": [
   "Pretty",
   "-",
   "print",
   "the",
   "contents",
   "of",
   ":",
   "data",
   ":",
   "DEFAULTS"
  ],
  "pl_tokens": [
   "def",
   "print_defaults",
   "(",
   ")",
   ":",
   "maxlen",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "DEFAULTS",
   "]",
   ")",
   "for",
   "key",
   "in",
   "DEFAULTS",
   ":",
   "value",
   "=",
   "DEFAULTS",
   "[",
   "key",
   "]",
   "if",
   "isinstance",
   "(",
   "value",
   ",",
   "(",
   "list",
   ",",
   "set",
   ")",
   ")",
   ":",
   "value",
   "=",
   "', '",
   ".",
   "join",
   "(",
   "value",
   ")",
   "print",
   "\"%*s: %s\"",
   "%",
   "(",
   "maxlen",
   ",",
   "key",
   ",",
   "value",
   ")"
  ]
 },
 {
  "idx": "maxmin-8",
  "nl_tokens": [
   ":",
   "py",
   ":",
   "func",
   ":",
   "asyncio",
   ".",
   "coroutine"
  ],
  "pl_tokens": [
   "async",
   "def",
   "wait",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_limit",
   "is",
   "not",
   "None",
   "and",
   "self",
   ".",
   "_limit",
   ">",
   "0",
   "and",
   "self",
   ".",
   "_start",
   "is",
   "not",
   "None",
   ":",
   "now",
   "=",
   "_now",
   "(",
   ")",
   "end",
   "=",
   "self",
   ".",
   "_start",
   "+",
   "self",
   ".",
   "_sum",
   "/",
   "self",
   ".",
   "_limit",
   "await",
   "asyncio",
   ".",
   "sleep",
   "(",
   "<mask>",
   "(",
   "0",
   ",",
   "end",
   "-",
   "now",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-9",
  "nl_tokens": [
   "Accepts",
   "log",
   "-",
   "values",
   "as",
   "input",
   "exponentiates",
   "them",
   "normalizes",
   "and",
   "returns",
   "the",
   "result",
   ".",
   "Handles",
   "underflow",
   "by",
   "rescaling",
   "so",
   "that",
   "the",
   "largest",
   "values",
   "is",
   "exactly",
   "1",
   ".",
   "0",
   "."
  ],
  "pl_tokens": [
   "def",
   "normalize",
   "(",
   "lx",
   ")",
   ":",
   "lx",
   "=",
   "numpy",
   ".",
   "asarray",
   "(",
   "lx",
   ")",
   "base",
   "=",
   "lx",
   ".",
   "<mask>",
   "(",
   ")",
   "x",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   "-",
   "base",
   ")",
   "result",
   "=",
   "x",
   "/",
   "x",
   ".",
   "sum",
   "(",
   ")",
   "conventional",
   "=",
   "(",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   ")",
   "/",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   ")",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "assert",
   "similar",
   "(",
   "result",
   ",",
   "conventional",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-10",
  "nl_tokens": [
   "Manage",
   "the",
   "printing",
   "and",
   "in",
   "-",
   "place",
   "updating",
   "of",
   "a",
   "line",
   "of",
   "characters"
  ],
  "pl_tokens": [
   "def",
   "status_printer",
   "(",
   ")",
   ":",
   "last_len",
   "=",
   "[",
   "0",
   "]",
   "def",
   "p",
   "(",
   "s",
   ")",
   ":",
   "s",
   "=",
   "next",
   "(",
   "spinner",
   ")",
   "+",
   "' '",
   "+",
   "s",
   "len_s",
   "=",
   "len",
   "(",
   "s",
   ")",
   "output",
   "=",
   "'\\r'",
   "+",
   "s",
   "+",
   "(",
   "' '",
   "*",
   "<mask>",
   "(",
   "last_len",
   "[",
   "0",
   "]",
   "-",
   "len_s",
   ",",
   "0",
   ")",
   ")",
   "sys",
   ".",
   "stdout",
   ".",
   "write",
   "(",
   "output",
   ")",
   "sys",
   ".",
   "stdout",
   ".",
   "flush",
   "(",
   ")",
   "last_len",
   "[",
   "0",
   "]",
   "=",
   "len_s",
   "return",
   "p"
  ]
 },
 {
  "idx": "maxmin-11",
  "nl_tokens": [
   "Estimate",
   "the",
   "geometric",
   "median",
   "of",
   "points",
   "in",
   "2D",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_geometric_median",
   "(",
   "X",
   ",",
   "eps",
   "=",
   "1e-5",
   ")",
   ":",
   "y",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "X",
   ",",
   "0",
   ")",
   "while",
   "True",
   ":",
   "D",
   "=",
   "scipy",
   ".",
   "spatial",
   ".",
   "distance",
   ".",
   "cdist",
   "(",
   "X",
   ",",
   "[",
   "y",
   "]",
   ")",
   "nonzeros",
   "=",
   "(",
   "D",
   "!=",
   "0",
   ")",
   "[",
   ":",
   ",",
   "0",
   "]",
   "Dinv",
   "=",
   "1",
   "/",
   "D",
   "[",
   "nonzeros",
   "]",
   "Dinvs",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "Dinv",
   ")",
   "W",
   "=",
   "Dinv",
   "/",
   "Dinvs",
   "T",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "W",
   "*",
   "X",
   "[",
   "nonzeros",
   "]",
   ",",
   "0",
   ")",
   "num_zeros",
   "=",
   "len",
   "(",
   "X",
   ")",
   "-",
   "np",
   ".",
   "sum",
   "(",
   "nonzeros",
   ")",
   "if",
   "num_zeros",
   "==",
   "0",
   ":",
   "y1",
   "=",
   "T",
   "elif",
   "num_zeros",
   "==",
   "len",
   "(",
   "X",
   ")",
   ":",
   "return",
   "y",
   "else",
   ":",
   "R",
   "=",
   "(",
   "T",
   "-",
   "y",
   ")",
   "*",
   "Dinvs",
   "r",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "norm",
   "(",
   "R",
   ")",
   "rinv",
   "=",
   "0",
   "if",
   "r",
   "==",
   "0",
   "else",
   "num_zeros",
   "/",
   "r",
   "y1",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "1",
   "-",
   "rinv",
   ")",
   "*",
   "T",
   "+",
   "min",
   "(",
   "1",
   ",",
   "rinv",
   ")",
   "*",
   "y",
   "if",
   "scipy",
   ".",
   "spatial",
   ".",
   "distance",
   ".",
   "euclidean",
   "(",
   "y",
   ",",
   "y1",
   ")",
   "<",
   "eps",
   ":",
   "return",
   "y1",
   "y",
   "=",
   "y1"
  ]
 },
 {
  "idx": "maxmin-12",
  "nl_tokens": [
   "Synchronize",
   "the",
   "stack",
   "and",
   "register",
   "state",
   "(",
   "manticore",
   "-",
   ">",
   "qemu",
   ")"
  ],
  "pl_tokens": [
   "def",
   "initialize",
   "(",
   "state",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "f\"Copying {stack_top - state.cpu.SP} bytes in the stack..\"",
   ")",
   "stack_bottom",
   "=",
   "<mask>",
   "(",
   "state",
   ".",
   "cpu",
   ".",
   "SP",
   ",",
   "gdb",
   ".",
   "getR",
   "(",
   "'SP'",
   ")",
   ")",
   "for",
   "address",
   "in",
   "range",
   "(",
   "stack_bottom",
   ",",
   "stack_top",
   ")",
   ":",
   "b",
   "=",
   "state",
   ".",
   "cpu",
   ".",
   "read_int",
   "(",
   "address",
   ",",
   "8",
   ")",
   "gdb",
   ".",
   "setByte",
   "(",
   "address",
   ",",
   "chr",
   "(",
   "b",
   ")",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Done\"",
   ")",
   "# Qemu fd's start at 5, ours at 3. Add two filler fds",
   "mcore_stdout",
   "=",
   "state",
   ".",
   "platform",
   ".",
   "files",
   "[",
   "1",
   "]",
   "state",
   ".",
   "platform",
   ".",
   "files",
   ".",
   "append",
   "(",
   "mcore_stdout",
   ")",
   "state",
   ".",
   "platform",
   ".",
   "files",
   ".",
   "append",
   "(",
   "mcore_stdout",
   ")",
   "# Sync gdb's regs",
   "for",
   "gdb_reg",
   "in",
   "gdb",
   ".",
   "getCanonicalRegisters",
   "(",
   ")",
   ":",
   "if",
   "gdb_reg",
   ".",
   "endswith",
   "(",
   "'psr'",
   ")",
   ":",
   "mcore_reg",
   "=",
   "'APSR'",
   "else",
   ":",
   "mcore_reg",
   "=",
   "gdb_reg",
   ".",
   "upper",
   "(",
   ")",
   "value",
   "=",
   "state",
   ".",
   "cpu",
   ".",
   "read_register",
   "(",
   "mcore_reg",
   ")",
   "gdb",
   ".",
   "setR",
   "(",
   "gdb_reg",
   ",",
   "value",
   ")"
  ]
 },
 {
  "idx": "maxmin-13",
  "nl_tokens": [
   "Return",
   "the",
   "MLIPNS",
   "similarity",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "threshold",
   "=",
   "0.25",
   ",",
   "max_mismatches",
   "=",
   "2",
   ")",
   ":",
   "if",
   "tar",
   "==",
   "src",
   ":",
   "return",
   "1.0",
   "if",
   "not",
   "src",
   "or",
   "not",
   "tar",
   ":",
   "return",
   "0.0",
   "mismatches",
   "=",
   "0",
   "ham",
   "=",
   "Hamming",
   "(",
   ")",
   ".",
   "dist_abs",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "diff_lens",
   "=",
   "True",
   ")",
   "max_length",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   "while",
   "src",
   "and",
   "tar",
   "and",
   "mismatches",
   "<=",
   "max_mismatches",
   ":",
   "if",
   "(",
   "max_length",
   "<",
   "1",
   "or",
   "(",
   "1",
   "-",
   "(",
   "max_length",
   "-",
   "ham",
   ")",
   "/",
   "max_length",
   ")",
   "<=",
   "threshold",
   ")",
   ":",
   "return",
   "1.0",
   "else",
   ":",
   "mismatches",
   "+=",
   "1",
   "ham",
   "-=",
   "1",
   "max_length",
   "-=",
   "1",
   "if",
   "max_length",
   "<",
   "1",
   ":",
   "return",
   "1.0",
   "return",
   "0.0"
  ]
 },
 {
  "idx": "maxmin-14",
  "nl_tokens": [
   "When",
   "given",
   "a",
   "raw",
   "image",
   "and",
   "the",
   "scaled",
   "version",
   "of",
   "the",
   "same",
   "image",
   "it",
   "extracts",
   "the",
   "exposure",
   "parameters",
   "associated",
   "with",
   "those",
   "images",
   ".",
   "This",
   "is",
   "useful",
   "when"
  ],
  "pl_tokens": [
   "def",
   "get_scale_from_raw",
   "(",
   "raw",
   ",",
   "scaled",
   ")",
   ":",
   "t0",
   ",",
   "t1",
   "=",
   "scaled",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "scaled",
   ".",
   "max",
   "(",
   ")",
   "r0",
   ",",
   "r1",
   "=",
   "float",
   "(",
   "raw",
   ".",
   "min",
   "(",
   ")",
   ")",
   ",",
   "float",
   "(",
   "raw",
   ".",
   "max",
   "(",
   ")",
   ")",
   "rmin",
   "=",
   "(",
   "t1",
   "*",
   "r0",
   "-",
   "t0",
   "*",
   "r1",
   ")",
   "/",
   "(",
   "t1",
   "-",
   "t0",
   ")",
   "rmax",
   "=",
   "(",
   "r1",
   "-",
   "r0",
   ")",
   "/",
   "(",
   "t1",
   "-",
   "t0",
   ")",
   "+",
   "rmin",
   "return",
   "(",
   "rmin",
   ",",
   "rmax",
   ")"
  ]
 },
 {
  "idx": "maxmin-15",
  "nl_tokens": [
   "A",
   "subfunc",
   "of",
   "consensus_tree",
   "()",
   ".",
   "Removes",
   "clades",
   "that",
   "occur",
   "with",
   "freq",
   "<",
   "cutoff",
   "."
  ],
  "pl_tokens": [
   "def",
   "_filter_clades",
   "(",
   "clade_counts",
   ",",
   "cutoff",
   ")",
   ":",
   "## store clades that pass filter",
   "passed",
   "=",
   "[",
   "]",
   "clades",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "list",
   "(",
   "i",
   "[",
   "0",
   "]",
   ")",
   "for",
   "i",
   "in",
   "clade_counts",
   "]",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int8",
   ")",
   "counts",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "i",
   "[",
   "1",
   "]",
   "for",
   "i",
   "in",
   "clade_counts",
   "]",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   "for",
   "idx",
   "in",
   "xrange",
   "(",
   "clades",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "conflict",
   "=",
   "False",
   "if",
   "counts",
   "[",
   "idx",
   "]",
   "<",
   "cutoff",
   ":",
   "continue",
   "if",
   "np",
   ".",
   "sum",
   "(",
   "clades",
   "[",
   "idx",
   "]",
   ")",
   ">",
   "1",
   ":",
   "# check the current clade against all the accepted clades to see if",
   "# it conflicts. A conflict is defined as:",
   "# 1. the clades are not disjoint",
   "# 2. neither clade is a subset of the other",
   "# OR:",
   "# 1. it is inverse of clade (affects only <fake> root state)",
   "# because at root node it mirror images {0011 : 95}, {1100 : 5}.",
   "for",
   "aidx",
   "in",
   "passed",
   ":",
   "#intersect = clade.intersection(accepted_clade)",
   "summed",
   "=",
   "clades",
   "[",
   "idx",
   "]",
   "+",
   "clades",
   "[",
   "aidx",
   "]",
   "intersect",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "summed",
   ")",
   ">",
   "1",
   "subset_test0",
   "=",
   "np",
   ".",
   "all",
   "(",
   "clades",
   "[",
   "idx",
   "]",
   "-",
   "clades",
   "[",
   "aidx",
   "]",
   ">=",
   "0",
   ")",
   "subset_test1",
   "=",
   "np",
   ".",
   "all",
   "(",
   "clades",
   "[",
   "aidx",
   "]",
   "-",
   "clades",
   "[",
   "idx",
   "]",
   ">=",
   "0",
   ")",
   "invert_test",
   "=",
   "np",
   ".",
   "bool_",
   "(",
   "clades",
   "[",
   "aidx",
   "]",
   ")",
   "!=",
   "np",
   ".",
   "bool_",
   "(",
   "clades",
   "[",
   "idx",
   "]",
   ")",
   "if",
   "np",
   ".",
   "all",
   "(",
   "invert_test",
   ")",
   ":",
   "counts",
   "[",
   "aidx",
   "]",
   "+=",
   "counts",
   "[",
   "idx",
   "]",
   "conflict",
   "=",
   "True",
   "if",
   "intersect",
   ":",
   "if",
   "(",
   "not",
   "subset_test0",
   ")",
   "and",
   "(",
   "not",
   "subset_test1",
   ")",
   ":",
   "conflict",
   "=",
   "True",
   "if",
   "conflict",
   "==",
   "False",
   ":",
   "passed",
   ".",
   "append",
   "(",
   "idx",
   ")",
   "## rebuild the dict",
   "rclades",
   "=",
   "[",
   "]",
   "#j for i, j in enumerate(clade_counts) if i in passed]",
   "## set the counts to include mirrors",
   "for",
   "idx",
   "in",
   "passed",
   ":",
   "rclades",
   ".",
   "append",
   "(",
   "(",
   "clades",
   "[",
   "idx",
   "]",
   ",",
   "counts",
   "[",
   "idx",
   "]",
   ")",
   ")",
   "return",
   "rclades"
  ]
 },
 {
  "idx": "maxmin-16",
  "nl_tokens": [
   "Return",
   "the",
   "highest",
   "ranked",
   "edge",
   "from",
   "a",
   "multiedge",
   "."
  ],
  "pl_tokens": [
   "def",
   "rank_edges",
   "(",
   "edges",
   ",",
   "edge_ranking",
   "=",
   "None",
   ")",
   ":",
   "edge_ranking",
   "=",
   "default_edge_ranking",
   "if",
   "edge_ranking",
   "is",
   "None",
   "else",
   "edge_ranking",
   "edges_scores",
   "=",
   "[",
   "(",
   "edge_id",
   ",",
   "edge_data",
   "[",
   "RELATION",
   "]",
   ",",
   "edge_ranking",
   "[",
   "edge_data",
   "[",
   "RELATION",
   "]",
   "]",
   ")",
   "for",
   "edge_id",
   ",",
   "edge_data",
   "in",
   "edges",
   ".",
   "items",
   "(",
   ")",
   "]",
   "return",
   "<mask>",
   "(",
   "edges_scores",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "2",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-17",
  "nl_tokens": [
   "Return",
   "the",
   "simplest",
   "Sift4",
   "distance",
   "between",
   "two",
   "terms",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "max_offset",
   "=",
   "5",
   ")",
   ":",
   "if",
   "not",
   "src",
   ":",
   "return",
   "len",
   "(",
   "tar",
   ")",
   "if",
   "not",
   "tar",
   ":",
   "return",
   "len",
   "(",
   "src",
   ")",
   "src_len",
   "=",
   "len",
   "(",
   "src",
   ")",
   "tar_len",
   "=",
   "len",
   "(",
   "tar",
   ")",
   "src_cur",
   "=",
   "0",
   "tar_cur",
   "=",
   "0",
   "lcss",
   "=",
   "0",
   "local_cs",
   "=",
   "0",
   "while",
   "(",
   "src_cur",
   "<",
   "src_len",
   ")",
   "and",
   "(",
   "tar_cur",
   "<",
   "tar_len",
   ")",
   ":",
   "if",
   "src",
   "[",
   "src_cur",
   "]",
   "==",
   "tar",
   "[",
   "tar_cur",
   "]",
   ":",
   "local_cs",
   "+=",
   "1",
   "else",
   ":",
   "lcss",
   "+=",
   "local_cs",
   "local_cs",
   "=",
   "0",
   "if",
   "src_cur",
   "!=",
   "tar_cur",
   ":",
   "src_cur",
   "=",
   "tar_cur",
   "=",
   "<mask>",
   "(",
   "src_cur",
   ",",
   "tar_cur",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "max_offset",
   ")",
   ":",
   "if",
   "not",
   "(",
   "(",
   "src_cur",
   "+",
   "i",
   "<",
   "src_len",
   ")",
   "or",
   "(",
   "tar_cur",
   "+",
   "i",
   "<",
   "tar_len",
   ")",
   ")",
   ":",
   "break",
   "if",
   "(",
   "src_cur",
   "+",
   "i",
   "<",
   "src_len",
   ")",
   "and",
   "(",
   "src",
   "[",
   "src_cur",
   "+",
   "i",
   "]",
   "==",
   "tar",
   "[",
   "tar_cur",
   "]",
   ")",
   ":",
   "src_cur",
   "+=",
   "i",
   "local_cs",
   "+=",
   "1",
   "break",
   "if",
   "(",
   "tar_cur",
   "+",
   "i",
   "<",
   "tar_len",
   ")",
   "and",
   "(",
   "src",
   "[",
   "src_cur",
   "]",
   "==",
   "tar",
   "[",
   "tar_cur",
   "+",
   "i",
   "]",
   ")",
   ":",
   "tar_cur",
   "+=",
   "i",
   "local_cs",
   "+=",
   "1",
   "break",
   "src_cur",
   "+=",
   "1",
   "tar_cur",
   "+=",
   "1",
   "lcss",
   "+=",
   "local_cs",
   "return",
   "round",
   "(",
   "max",
   "(",
   "src_len",
   ",",
   "tar_len",
   ")",
   "-",
   "lcss",
   ")"
  ]
 },
 {
  "idx": "maxmin-18",
  "nl_tokens": [
   "Convert",
   "reflection",
   "coefficients",
   "to",
   "log",
   "area",
   "ratios",
   "."
  ],
  "pl_tokens": [
   "def",
   "rc2lar",
   "(",
   "k",
   ")",
   ":",
   "assert",
   "numpy",
   ".",
   "isrealobj",
   "(",
   "k",
   ")",
   ",",
   "'Log area ratios not defined for complex reflection coefficients.'",
   "if",
   "<mask>",
   "(",
   "numpy",
   ".",
   "abs",
   "(",
   "k",
   ")",
   ")",
   ">=",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "'All reflection coefficients should have magnitude less than unity.'",
   ")",
   "# Use the relation, atanh(x) = (1/2)*log((1+k)/(1-k))",
   "return",
   "-",
   "2",
   "*",
   "numpy",
   ".",
   "arctanh",
   "(",
   "-",
   "numpy",
   ".",
   "array",
   "(",
   "k",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-19",
  "nl_tokens": [
   "Optimal",
   "FIR",
   "(",
   "equal",
   "ripple",
   ")",
   "Bandpass",
   "Order",
   "Determination",
   "Text",
   "reference",
   ":",
   "Ifeachor",
   "Digital",
   "Signal",
   "Processing",
   "a",
   "Practical",
   "Approach",
   "second",
   "edition",
   "Prentice",
   "Hall",
   "2002",
   ".",
   "Journal",
   "paper",
   "reference",
   ":",
   "F",
   ".",
   "Mintzer",
   "&",
   "B",
   ".",
   "Liu",
   "Practical",
   "Design",
   "Rules",
   "for",
   "Optimum",
   "FIR",
   "Bandpass",
   "Digital",
   "Filters",
   "IEEE",
   "Transactions",
   "on",
   "Acoustics",
   "and",
   "Speech",
   "pp",
   ".",
   "204",
   "-",
   "206",
   "April",
   "1979",
   "."
  ],
  "pl_tokens": [
   "def",
   "bandpass_order",
   "(",
   "f_stop1",
   ",",
   "f_pass1",
   ",",
   "f_pass2",
   ",",
   "f_stop2",
   ",",
   "dpass_dB",
   ",",
   "dstop_dB",
   ",",
   "fsamp",
   "=",
   "1",
   ")",
   ":",
   "dpass",
   "=",
   "1",
   "-",
   "10",
   "**",
   "(",
   "-",
   "dpass_dB",
   "/",
   "20",
   ")",
   "dstop",
   "=",
   "10",
   "**",
   "(",
   "-",
   "dstop_dB",
   "/",
   "20",
   ")",
   "Df1",
   "=",
   "(",
   "f_pass1",
   "-",
   "f_stop1",
   ")",
   "/",
   "fsamp",
   "Df2",
   "=",
   "(",
   "f_stop2",
   "-",
   "f_pass2",
   ")",
   "/",
   "fsamp",
   "b1",
   "=",
   "0.01201",
   "b2",
   "=",
   "0.09664",
   "b3",
   "=",
   "-",
   "0.51325",
   "b4",
   "=",
   "0.00203",
   "b5",
   "=",
   "-",
   "0.5705",
   "b6",
   "=",
   "-",
   "0.44314",
   "Df",
   "=",
   "<mask>",
   "(",
   "Df1",
   ",",
   "Df2",
   ")",
   "Cinf",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "dstop",
   ")",
   "*",
   "(",
   "b1",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "dpass",
   ")",
   "**",
   "2",
   "+",
   "b2",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "dpass",
   ")",
   "+",
   "b3",
   ")",
   "+",
   "(",
   "b4",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "dpass",
   ")",
   "**",
   "2",
   "+",
   "b5",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "dpass",
   ")",
   "+",
   "b6",
   ")",
   "g",
   "=",
   "-",
   "14.6",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "dpass",
   "/",
   "dstop",
   ")",
   "-",
   "16.9",
   "N",
   "=",
   "Cinf",
   "/",
   "Df",
   "+",
   "g",
   "*",
   "Df",
   "+",
   "1",
   "ff",
   "=",
   "2",
   "*",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0",
   ",",
   "f_stop1",
   ",",
   "f_pass1",
   ",",
   "f_pass2",
   ",",
   "f_stop2",
   ",",
   "fsamp",
   "/",
   "2",
   "]",
   ")",
   "/",
   "fsamp",
   "aa",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0",
   ",",
   "0",
   ",",
   "1",
   ",",
   "1",
   ",",
   "0",
   ",",
   "0",
   "]",
   ")",
   "wts",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "dpass",
   "/",
   "dstop",
   ",",
   "1",
   ",",
   "dpass",
   "/",
   "dstop",
   "]",
   ")",
   "return",
   "int",
   "(",
   "N",
   ")",
   ",",
   "ff",
   ",",
   "aa",
   ",",
   "wts"
  ]
 },
 {
  "idx": "maxmin-20",
  "nl_tokens": [
   "filter",
   "for",
   "indels"
  ],
  "pl_tokens": [
   "def",
   "maxind_numba",
   "(",
   "block",
   ")",
   ":",
   "## remove terminal edges",
   "inds",
   "=",
   "0",
   "for",
   "row",
   "in",
   "xrange",
   "(",
   "block",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "where",
   "=",
   "np",
   ".",
   "where",
   "(",
   "block",
   "[",
   "row",
   "]",
   "!=",
   "45",
   ")",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "where",
   ")",
   "==",
   "0",
   ":",
   "obs",
   "=",
   "100",
   "else",
   ":",
   "left",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "where",
   ")",
   "right",
   "=",
   "np",
   ".",
   "max",
   "(",
   "where",
   ")",
   "obs",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "block",
   "[",
   "row",
   ",",
   "left",
   ":",
   "right",
   "]",
   "==",
   "45",
   ")",
   "if",
   "obs",
   ">",
   "inds",
   ":",
   "inds",
   "=",
   "obs",
   "return",
   "inds"
  ]
 },
 {
  "idx": "maxmin-21",
  "nl_tokens": [
   "Return",
   "the",
   "Fuzzy",
   "Soundex",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "5",
   ",",
   "zero_pad",
   "=",
   "True",
   ")",
   ":",
   "word",
   "=",
   "unicode_normalize",
   "(",
   "'NFKD'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "upper",
   "(",
   ")",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "# Clamp max_length to [4, 64]",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "4",
   ",",
   "max_length",
   ")",
   ",",
   "64",
   ")",
   "else",
   ":",
   "max_length",
   "=",
   "64",
   "if",
   "not",
   "word",
   ":",
   "if",
   "zero_pad",
   ":",
   "return",
   "'0'",
   "*",
   "max_length",
   "return",
   "'0'",
   "if",
   "word",
   "[",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'CS'",
   ",",
   "'CZ'",
   ",",
   "'TS'",
   ",",
   "'TZ'",
   "}",
   ":",
   "word",
   "=",
   "'SS'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'GN'",
   ":",
   "word",
   "=",
   "'NN'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'HR'",
   ",",
   "'WR'",
   "}",
   ":",
   "word",
   "=",
   "'RR'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'HW'",
   ":",
   "word",
   "=",
   "'WW'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'KN'",
   ",",
   "'NG'",
   "}",
   ":",
   "word",
   "=",
   "'NN'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "if",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'CH'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'KK'",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'NT'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'TT'",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'RT'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'RR'",
   "elif",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "==",
   "'RDT'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "+",
   "'RR'",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CA'",
   ",",
   "'KA'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CC'",
   ",",
   "'KK'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CK'",
   ",",
   "'KK'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CE'",
   ",",
   "'SE'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CHL'",
   ",",
   "'KL'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CL'",
   ",",
   "'KL'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CHR'",
   ",",
   "'KR'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CR'",
   ",",
   "'KR'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CI'",
   ",",
   "'SI'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CO'",
   ",",
   "'KO'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CU'",
   ",",
   "'KU'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'CY'",
   ",",
   "'SY'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'DG'",
   ",",
   "'GG'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'GH'",
   ",",
   "'HH'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'MAC'",
   ",",
   "'MK'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'MC'",
   ",",
   "'MK'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'NST'",
   ",",
   "'NSS'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'PF'",
   ",",
   "'FF'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'PH'",
   ",",
   "'FF'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'SCH'",
   ",",
   "'SSS'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'TIO'",
   ",",
   "'SIO'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'TIA'",
   ",",
   "'SIO'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'TCH'",
   ",",
   "'CHH'",
   ")",
   "sdx",
   "=",
   "word",
   ".",
   "translate",
   "(",
   "self",
   ".",
   "_trans",
   ")",
   "sdx",
   "=",
   "sdx",
   ".",
   "replace",
   "(",
   "'-'",
   ",",
   "''",
   ")",
   "# remove repeating characters",
   "sdx",
   "=",
   "self",
   ".",
   "_delete_consecutive_repeats",
   "(",
   "sdx",
   ")",
   "if",
   "word",
   "[",
   "0",
   "]",
   "in",
   "{",
   "'H'",
   ",",
   "'W'",
   ",",
   "'Y'",
   "}",
   ":",
   "sdx",
   "=",
   "word",
   "[",
   "0",
   "]",
   "+",
   "sdx",
   "else",
   ":",
   "sdx",
   "=",
   "word",
   "[",
   "0",
   "]",
   "+",
   "sdx",
   "[",
   "1",
   ":",
   "]",
   "sdx",
   "=",
   "sdx",
   ".",
   "replace",
   "(",
   "'0'",
   ",",
   "''",
   ")",
   "if",
   "zero_pad",
   ":",
   "sdx",
   "+=",
   "'0'",
   "*",
   "max_length",
   "return",
   "sdx",
   "[",
   ":",
   "max_length",
   "]"
  ]
 },
 {
  "idx": "maxmin-22",
  "nl_tokens": [
   "See",
   "the",
   "function",
   "description",
   "in",
   "base",
   ".",
   "py"
  ],
  "pl_tokens": [
   "def",
   "closenessScores",
   "(",
   "self",
   ",",
   "expValues",
   ",",
   "actValues",
   ",",
   "fractional",
   "=",
   "True",
   ")",
   ":",
   "# Compute the percent error in log space",
   "if",
   "expValues",
   "[",
   "0",
   "]",
   ">",
   "0",
   ":",
   "expValue",
   "=",
   "math",
   ".",
   "log10",
   "(",
   "expValues",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "expValue",
   "=",
   "self",
   ".",
   "minScaledValue",
   "if",
   "actValues",
   "[",
   "0",
   "]",
   ">",
   "0",
   ":",
   "actValue",
   "=",
   "math",
   ".",
   "log10",
   "(",
   "actValues",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "actValue",
   "=",
   "self",
   ".",
   "minScaledValue",
   "if",
   "fractional",
   ":",
   "err",
   "=",
   "abs",
   "(",
   "expValue",
   "-",
   "actValue",
   ")",
   "pctErr",
   "=",
   "err",
   "/",
   "(",
   "self",
   ".",
   "maxScaledValue",
   "-",
   "self",
   ".",
   "minScaledValue",
   ")",
   "pctErr",
   "=",
   "<mask>",
   "(",
   "1.0",
   ",",
   "pctErr",
   ")",
   "closeness",
   "=",
   "1.0",
   "-",
   "pctErr",
   "else",
   ":",
   "err",
   "=",
   "abs",
   "(",
   "expValue",
   "-",
   "actValue",
   ")",
   "closeness",
   "=",
   "err",
   "#print \"log::\", \"expValue:\", expValues[0], \"actValue:\", actValues[0], \\",
   "#      \"closeness\", closeness",
   "#import pdb; pdb.set_trace()",
   "return",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "closeness",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-23",
  "nl_tokens": [
   "Like",
   "itertools",
   ".",
   "groupby",
   "with",
   "the",
   "following",
   "additions",
   ":"
  ],
  "pl_tokens": [
   "def",
   "groupby2",
   "(",
   "*",
   "args",
   ")",
   ":",
   "generatorList",
   "=",
   "[",
   "]",
   "# list of each list's (k, group) tuples",
   "if",
   "len",
   "(",
   "args",
   ")",
   "%",
   "2",
   "==",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Must have a key function for every list.\"",
   ")",
   "advanceList",
   "=",
   "[",
   "]",
   "# populate above lists",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "args",
   ")",
   ",",
   "2",
   ")",
   ":",
   "listn",
   "=",
   "args",
   "[",
   "i",
   "]",
   "fn",
   "=",
   "args",
   "[",
   "i",
   "+",
   "1",
   "]",
   "if",
   "listn",
   "is",
   "not",
   "None",
   ":",
   "generatorList",
   ".",
   "append",
   "(",
   "groupby",
   "(",
   "listn",
   ",",
   "fn",
   ")",
   ")",
   "advanceList",
   ".",
   "append",
   "(",
   "True",
   ")",
   "# start by advancing everyone.",
   "else",
   ":",
   "generatorList",
   ".",
   "append",
   "(",
   "None",
   ")",
   "advanceList",
   ".",
   "append",
   "(",
   "False",
   ")",
   "n",
   "=",
   "len",
   "(",
   "generatorList",
   ")",
   "nextList",
   "=",
   "[",
   "None",
   "]",
   "*",
   "n",
   "# while all lists aren't exhausted walk through each group in order",
   "while",
   "True",
   ":",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "n",
   ")",
   ":",
   "if",
   "advanceList",
   "[",
   "i",
   "]",
   ":",
   "try",
   ":",
   "nextList",
   "[",
   "i",
   "]",
   "=",
   "generatorList",
   "[",
   "i",
   "]",
   ".",
   "next",
   "(",
   ")",
   "except",
   "StopIteration",
   ":",
   "nextList",
   "[",
   "i",
   "]",
   "=",
   "None",
   "# no more values to process in any of the generators",
   "if",
   "all",
   "(",
   "entry",
   "is",
   "None",
   "for",
   "entry",
   "in",
   "nextList",
   ")",
   ":",
   "break",
   "# the minimum key value in the nextList",
   "minKeyVal",
   "=",
   "<mask>",
   "(",
   "nextVal",
   "[",
   "0",
   "]",
   "for",
   "nextVal",
   "in",
   "nextList",
   "if",
   "nextVal",
   "is",
   "not",
   "None",
   ")",
   "# populate the tuple to return based on minKeyVal",
   "retGroups",
   "=",
   "[",
   "minKeyVal",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "n",
   ")",
   ":",
   "if",
   "nextList",
   "[",
   "i",
   "]",
   "is",
   "not",
   "None",
   "and",
   "nextList",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "==",
   "minKeyVal",
   ":",
   "retGroups",
   ".",
   "append",
   "(",
   "nextList",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   ")",
   "advanceList",
   "[",
   "i",
   "]",
   "=",
   "True",
   "else",
   ":",
   "advanceList",
   "[",
   "i",
   "]",
   "=",
   "False",
   "retGroups",
   ".",
   "append",
   "(",
   "None",
   ")",
   "yield",
   "tuple",
   "(",
   "retGroups",
   ")"
  ]
 },
 {
  "idx": "maxmin-24",
  "nl_tokens": [
   "Helper",
   "method",
   "that",
   "finds",
   "LCS",
   "by",
   "traversing",
   "the",
   "labeled",
   "GSD",
   "."
  ],
  "pl_tokens": [
   "def",
   "_find_lcs",
   "(",
   "self",
   ",",
   "node",
   ",",
   "stringIdxs",
   ")",
   ":",
   "nodes",
   "=",
   "[",
   "self",
   ".",
   "_find_lcs",
   "(",
   "n",
   ",",
   "stringIdxs",
   ")",
   "for",
   "(",
   "n",
   ",",
   "_",
   ")",
   "in",
   "node",
   ".",
   "transition_links",
   "if",
   "n",
   ".",
   "generalized_idxs",
   ".",
   "issuperset",
   "(",
   "stringIdxs",
   ")",
   "]",
   "if",
   "nodes",
   "==",
   "[",
   "]",
   ":",
   "return",
   "node",
   "deepestNode",
   "=",
   "<mask>",
   "(",
   "nodes",
   ",",
   "key",
   "=",
   "lambda",
   "n",
   ":",
   "n",
   ".",
   "depth",
   ")",
   "return",
   "deepestNode"
  ]
 },
 {
  "idx": "maxmin-25",
  "nl_tokens": [
   "Eigenvector",
   "centrality",
   "for",
   "nodes",
   "in",
   "the",
   "graph",
   "(",
   "like",
   "Google",
   "s",
   "PageRank",
   ")",
   ".",
   "Eigenvector",
   "centrality",
   "is",
   "a",
   "measure",
   "of",
   "the",
   "importance",
   "of",
   "a",
   "node",
   "in",
   "a",
   "directed",
   "network",
   ".",
   "It",
   "rewards",
   "nodes",
   "with",
   "a",
   "high",
   "potential",
   "of",
   "(",
   "indirectly",
   ")",
   "connecting",
   "to",
   "high",
   "-",
   "scoring",
   "nodes",
   ".",
   "Nodes",
   "with",
   "no",
   "incoming",
   "connections",
   "have",
   "a",
   "score",
   "of",
   "zero",
   ".",
   "If",
   "you",
   "want",
   "to",
   "measure",
   "outgoing",
   "connections",
   "reversed",
   "should",
   "be",
   "False",
   "."
  ],
  "pl_tokens": [
   "def",
   "eigenvector_centrality",
   "(",
   "graph",
   ",",
   "normalized",
   "=",
   "True",
   ",",
   "reversed",
   "=",
   "True",
   ",",
   "rating",
   "=",
   "{",
   "}",
   ",",
   "start",
   "=",
   "None",
   ",",
   "iterations",
   "=",
   "100",
   ",",
   "tolerance",
   "=",
   "0.0001",
   ")",
   ":",
   "G",
   "=",
   "graph",
   ".",
   "keys",
   "(",
   ")",
   "W",
   "=",
   "adjacency",
   "(",
   "graph",
   ",",
   "directed",
   "=",
   "True",
   ",",
   "reversed",
   "=",
   "reversed",
   ")",
   "def",
   "_normalize",
   "(",
   "x",
   ")",
   ":",
   "s",
   "=",
   "sum",
   "(",
   "x",
   ".",
   "values",
   "(",
   ")",
   ")",
   "if",
   "s",
   "!=",
   "0",
   ":",
   "s",
   "=",
   "1.0",
   "/",
   "s",
   "for",
   "k",
   "in",
   "x",
   ":",
   "x",
   "[",
   "k",
   "]",
   "*=",
   "s",
   "x",
   "=",
   "start",
   "if",
   "x",
   "is",
   "None",
   ":",
   "x",
   "=",
   "dict",
   "(",
   "[",
   "(",
   "n",
   ",",
   "random",
   "(",
   ")",
   ")",
   "for",
   "n",
   "in",
   "G",
   "]",
   ")",
   "_normalize",
   "(",
   "x",
   ")",
   "# Power method: y = Ax multiplication.",
   "for",
   "i",
   "in",
   "range",
   "(",
   "iterations",
   ")",
   ":",
   "x0",
   "=",
   "x",
   "x",
   "=",
   "dict",
   ".",
   "fromkeys",
   "(",
   "x0",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "0",
   ")",
   "for",
   "n",
   "in",
   "x",
   ":",
   "for",
   "nbr",
   "in",
   "W",
   "[",
   "n",
   "]",
   ":",
   "r",
   "=",
   "1",
   "if",
   "rating",
   ".",
   "has_key",
   "(",
   "n",
   ")",
   ":",
   "r",
   "=",
   "rating",
   "[",
   "n",
   "]",
   "x",
   "[",
   "n",
   "]",
   "+=",
   "0.01",
   "+",
   "x0",
   "[",
   "nbr",
   "]",
   "*",
   "W",
   "[",
   "n",
   "]",
   "[",
   "nbr",
   "]",
   "*",
   "r",
   "_normalize",
   "(",
   "x",
   ")",
   "e",
   "=",
   "sum",
   "(",
   "[",
   "abs",
   "(",
   "x",
   "[",
   "n",
   "]",
   "-",
   "x0",
   "[",
   "n",
   "]",
   ")",
   "for",
   "n",
   "in",
   "x",
   "]",
   ")",
   "if",
   "e",
   "<",
   "len",
   "(",
   "graph",
   ".",
   "nodes",
   ")",
   "*",
   "tolerance",
   ":",
   "if",
   "normalized",
   ":",
   "# Normalize between 0.0 and 1.0.",
   "m",
   "=",
   "<mask>",
   "(",
   "x",
   ".",
   "values",
   "(",
   ")",
   ")",
   "if",
   "m",
   "==",
   "0",
   ":",
   "m",
   "=",
   "1",
   "x",
   "=",
   "dict",
   "(",
   "[",
   "(",
   "id",
   ",",
   "w",
   "/",
   "m",
   ")",
   "for",
   "id",
   ",",
   "w",
   "in",
   "x",
   ".",
   "iteritems",
   "(",
   ")",
   "]",
   ")",
   "return",
   "x",
   "#raise NoConvergenceError",
   "warn",
   "(",
   "\"node weight is 0 because eigenvector_centrality() did not converge.\"",
   ",",
   "Warning",
   ")",
   "return",
   "dict",
   "(",
   "[",
   "(",
   "n",
   ",",
   "0",
   ")",
   "for",
   "n",
   "in",
   "G",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-26",
  "nl_tokens": [
   "Implementation",
   "of",
   "the",
   "Context",
   "Likelihood",
   "or",
   "Relatedness",
   "Network",
   "algorithm",
   "."
  ],
  "pl_tokens": [
   "def",
   "clr",
   "(",
   "M",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "R",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "M",
   ".",
   "shape",
   ")",
   "Id",
   "=",
   "[",
   "[",
   "0",
   ",",
   "0",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "M",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "M",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "mu_i",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "M",
   "[",
   "i",
   ",",
   ":",
   "]",
   ")",
   "sigma_i",
   "=",
   "np",
   ".",
   "std",
   "(",
   "M",
   "[",
   "i",
   ",",
   ":",
   "]",
   ")",
   "Id",
   "[",
   "i",
   "]",
   "=",
   "[",
   "mu_i",
   ",",
   "sigma_i",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "M",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "i",
   "+",
   "1",
   ",",
   "M",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "z_i",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "0",
   ",",
   "(",
   "M",
   "[",
   "i",
   ",",
   "j",
   "]",
   "-",
   "Id",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   ")",
   "/",
   "Id",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "]",
   ")",
   "z_j",
   "=",
   "np",
   ".",
   "max",
   "(",
   "[",
   "0",
   ",",
   "(",
   "M",
   "[",
   "i",
   ",",
   "j",
   "]",
   "-",
   "Id",
   "[",
   "j",
   "]",
   "[",
   "0",
   "]",
   ")",
   "/",
   "Id",
   "[",
   "j",
   "]",
   "[",
   "0",
   "]",
   "]",
   ")",
   "R",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "z_i",
   "**",
   "2",
   "+",
   "z_j",
   "**",
   "2",
   ")",
   "R",
   "[",
   "j",
   ",",
   "i",
   "]",
   "=",
   "R",
   "[",
   "i",
   ",",
   "j",
   "]",
   "# Symmetric",
   "return",
   "R"
  ]
 },
 {
  "idx": "maxmin-27",
  "nl_tokens": [
   "Given",
   "two",
   "intervals",
   "(",
   "min1",
   "max1",
   ")",
   "and",
   "(",
   "min2",
   "max2",
   ")",
   "return",
   "their",
   "intersecting",
   "interval",
   "or",
   "None",
   "if",
   "they",
   "do",
   "not",
   "overlap",
   "."
  ],
  "pl_tokens": [
   "def",
   "interval_intersection",
   "(",
   "min1",
   ",",
   "max1",
   ",",
   "min2",
   ",",
   "max2",
   ")",
   ":",
   "left",
   ",",
   "right",
   "=",
   "<mask>",
   "(",
   "min1",
   ",",
   "min2",
   ")",
   ",",
   "min",
   "(",
   "max1",
   ",",
   "max2",
   ")",
   "if",
   "left",
   "<",
   "right",
   ":",
   "return",
   "left",
   ",",
   "right",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-28",
  "nl_tokens": [
   "Normalize",
   "a",
   "field",
   "to",
   "a",
   "(",
   "min",
   "max",
   ")",
   "exposure",
   "range",
   "default",
   "is",
   "(",
   "0",
   "255",
   ")",
   ".",
   "(",
   "min",
   "max",
   ")",
   "exposure",
   "values",
   ".",
   "Invert",
   "the",
   "image",
   "if",
   "requested",
   "."
  ],
  "pl_tokens": [
   "def",
   "normalize",
   "(",
   "im",
   ",",
   "invert",
   "=",
   "False",
   ",",
   "scale",
   "=",
   "None",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   ":",
   "if",
   "dtype",
   "not",
   "in",
   "{",
   "np",
   ".",
   "float16",
   ",",
   "np",
   ".",
   "float32",
   ",",
   "np",
   ".",
   "float64",
   "}",
   ":",
   "raise",
   "ValueError",
   "(",
   "'dtype must be numpy.float16, float32, or float64.'",
   ")",
   "out",
   "=",
   "im",
   ".",
   "astype",
   "(",
   "'float'",
   ")",
   ".",
   "copy",
   "(",
   ")",
   "scale",
   "=",
   "scale",
   "or",
   "(",
   "0.0",
   ",",
   "255.0",
   ")",
   "l",
   ",",
   "u",
   "=",
   "(",
   "float",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "scale",
   ")",
   "out",
   "=",
   "(",
   "out",
   "-",
   "l",
   ")",
   "/",
   "(",
   "u",
   "-",
   "l",
   ")",
   "if",
   "invert",
   ":",
   "out",
   "=",
   "-",
   "out",
   "+",
   "(",
   "out",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "out",
   ".",
   "min",
   "(",
   ")",
   ")",
   "return",
   "out",
   ".",
   "astype",
   "(",
   "dtype",
   ")"
  ]
 },
 {
  "idx": "maxmin-29",
  "nl_tokens": [
   "Does",
   "photometry",
   "and",
   "estimates",
   "uncertainties",
   "by",
   "calculating",
   "the",
   "scatter",
   "around",
   "a",
   "linear",
   "fit",
   "to",
   "the",
   "data",
   "in",
   "each",
   "orientation",
   ".",
   "This",
   "function",
   "is",
   "called",
   "by",
   "other",
   "functions",
   "and",
   "generally",
   "the",
   "user",
   "will",
   "not",
   "need",
   "to",
   "interact",
   "with",
   "it",
   "directly",
   "."
  ],
  "pl_tokens": [
   "def",
   "do_photometry",
   "(",
   "self",
   ")",
   ":",
   "std_f",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "4",
   ")",
   "data_save",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "self",
   ".",
   "postcard",
   ")",
   "self",
   ".",
   "obs_flux",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "self",
   ".",
   "reference_flux",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "4",
   ")",
   ":",
   "g",
   "=",
   "np",
   ".",
   "where",
   "(",
   "self",
   ".",
   "qs",
   "==",
   "i",
   ")",
   "[",
   "0",
   "]",
   "wh",
   "=",
   "np",
   ".",
   "where",
   "(",
   "self",
   ".",
   "times",
   "[",
   "g",
   "]",
   ">",
   "54947",
   ")",
   "data_save",
   "[",
   "g",
   "]",
   "=",
   "np",
   ".",
   "roll",
   "(",
   "self",
   ".",
   "postcard",
   "[",
   "g",
   "]",
   ",",
   "int",
   "(",
   "self",
   ".",
   "roll_best",
   "[",
   "i",
   ",",
   "0",
   "]",
   ")",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "data_save",
   "[",
   "g",
   "]",
   "=",
   "np",
   ".",
   "roll",
   "(",
   "data_save",
   "[",
   "g",
   "]",
   ",",
   "int",
   "(",
   "self",
   ".",
   "roll_best",
   "[",
   "i",
   ",",
   "1",
   "]",
   ")",
   ",",
   "axis",
   "=",
   "2",
   ")",
   "self",
   ".",
   "target_flux_pixels",
   "=",
   "data_save",
   "[",
   ":",
   ",",
   "self",
   ".",
   "targets",
   "==",
   "1",
   "]",
   "self",
   ".",
   "target_flux",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "self",
   ".",
   "target_flux_pixels",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "self",
   ".",
   "obs_flux",
   "[",
   "g",
   "]",
   "=",
   "self",
   ".",
   "target_flux",
   "[",
   "g",
   "]",
   "/",
   "self",
   ".",
   "reference_flux",
   "[",
   "g",
   "]",
   "self",
   ".",
   "obs_flux",
   "[",
   "g",
   "]",
   "/=",
   "np",
   ".",
   "median",
   "(",
   "self",
   ".",
   "obs_flux",
   "[",
   "g",
   "[",
   "wh",
   "]",
   "]",
   ")",
   "fitline",
   "=",
   "np",
   ".",
   "polyfit",
   "(",
   "self",
   ".",
   "times",
   "[",
   "g",
   "]",
   "[",
   "wh",
   "]",
   ",",
   "self",
   ".",
   "obs_flux",
   "[",
   "g",
   "]",
   "[",
   "wh",
   "]",
   ",",
   "1",
   ")",
   "std_f",
   "[",
   "i",
   "]",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "np",
   ".",
   "std",
   "(",
   "self",
   ".",
   "obs_flux",
   "[",
   "g",
   "]",
   "[",
   "wh",
   "]",
   "/",
   "(",
   "fitline",
   "[",
   "0",
   "]",
   "*",
   "self",
   ".",
   "times",
   "[",
   "g",
   "]",
   "[",
   "wh",
   "]",
   "+",
   "fitline",
   "[",
   "1",
   "]",
   ")",
   ")",
   ",",
   "0.001",
   "]",
   ")",
   "self",
   ".",
   "flux_uncert",
   "=",
   "std_f"
  ]
 },
 {
  "idx": "maxmin-30",
  "nl_tokens": [
   "Sample",
   "a",
   "batch",
   "of",
   "experiences",
   "."
  ],
  "pl_tokens": [
   "def",
   "sample",
   "(",
   "self",
   ",",
   "batch_size",
   ",",
   "beta",
   ")",
   ":",
   "assert",
   "beta",
   ">",
   "0",
   "idxes",
   "=",
   "self",
   ".",
   "_sample_proportional",
   "(",
   "batch_size",
   ")",
   "weights",
   "=",
   "[",
   "]",
   "p_min",
   "=",
   "self",
   ".",
   "_it_min",
   ".",
   "<mask>",
   "(",
   ")",
   "/",
   "self",
   ".",
   "_it_sum",
   ".",
   "sum",
   "(",
   ")",
   "max_weight",
   "=",
   "(",
   "p_min",
   "*",
   "len",
   "(",
   "self",
   ".",
   "_storage",
   ")",
   ")",
   "**",
   "(",
   "-",
   "beta",
   ")",
   "for",
   "idx",
   "in",
   "idxes",
   ":",
   "p_sample",
   "=",
   "self",
   ".",
   "_it_sum",
   "[",
   "idx",
   "]",
   "/",
   "self",
   ".",
   "_it_sum",
   ".",
   "sum",
   "(",
   ")",
   "weight",
   "=",
   "(",
   "p_sample",
   "*",
   "len",
   "(",
   "self",
   ".",
   "_storage",
   ")",
   ")",
   "**",
   "(",
   "-",
   "beta",
   ")",
   "weights",
   ".",
   "append",
   "(",
   "weight",
   "/",
   "max_weight",
   ")",
   "weights",
   "=",
   "np",
   ".",
   "array",
   "(",
   "weights",
   ")",
   "encoded_sample",
   "=",
   "self",
   ".",
   "_encode_sample",
   "(",
   "idxes",
   ")",
   "return",
   "tuple",
   "(",
   "list",
   "(",
   "encoded_sample",
   ")",
   "+",
   "[",
   "weights",
   ",",
   "idxes",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-31",
  "nl_tokens": [
   "Use",
   "\\\\",
   "r",
   "to",
   "overdraw",
   "the",
   "current",
   "line",
   "with",
   "the",
   "given",
   "text",
   "."
  ],
  "pl_tokens": [
   "def",
   "write",
   "(",
   "self",
   ",",
   "text",
   ",",
   "newline",
   "=",
   "False",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "isatty",
   ":",
   "self",
   ".",
   "fobj",
   ".",
   "write",
   "(",
   "'%s\\n'",
   "%",
   "text",
   ")",
   "return",
   "msg_len",
   "=",
   "len",
   "(",
   "text",
   ")",
   "self",
   ".",
   "max_len",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "max_len",
   ",",
   "msg_len",
   ")",
   "self",
   ".",
   "fobj",
   ".",
   "write",
   "(",
   "\"\\r%-*s\"",
   "%",
   "(",
   "self",
   ".",
   "max_len",
   ",",
   "text",
   ")",
   ")",
   "if",
   "newline",
   "or",
   "not",
   "self",
   ".",
   "isatty",
   ":",
   "self",
   ".",
   "fobj",
   ".",
   "write",
   "(",
   "'\\n'",
   ")",
   "self",
   ".",
   "max_len",
   "=",
   "0"
  ]
 },
 {
  "idx": "maxmin-32",
  "nl_tokens": [
   "Like",
   "union",
   "but",
   "ignores",
   "whether",
   "the",
   "two",
   "intervals",
   "intersect",
   "or",
   "not"
  ],
  "pl_tokens": [
   "def",
   "union_fill_gap",
   "(",
   "self",
   ",",
   "i",
   ")",
   ":",
   "return",
   "Interval",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "start",
   ",",
   "i",
   ".",
   "start",
   ")",
   ",",
   "max",
   "(",
   "self",
   ".",
   "end",
   ",",
   "i",
   ".",
   "end",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-33",
  "nl_tokens": [
   "Returns",
   "a",
   "color",
   "for",
   "the",
   "queue",
   "."
  ],
  "pl_tokens": [
   "def",
   "_current_color",
   "(",
   "self",
   ",",
   "which",
   "=",
   "0",
   ")",
   ":",
   "if",
   "which",
   "==",
   "1",
   ":",
   "color",
   "=",
   "self",
   ".",
   "colors",
   "[",
   "'edge_loop_color'",
   "]",
   "elif",
   "which",
   "==",
   "2",
   ":",
   "color",
   "=",
   "self",
   ".",
   "colors",
   "[",
   "'vertex_color'",
   "]",
   "else",
   ":",
   "div",
   "=",
   "self",
   ".",
   "coloring_sensitivity",
   "*",
   "self",
   ".",
   "num_servers",
   "+",
   "1.",
   "tmp",
   "=",
   "1.",
   "-",
   "<mask>",
   "(",
   "self",
   ".",
   "num_system",
   "/",
   "div",
   ",",
   "1",
   ")",
   "if",
   "self",
   ".",
   "edge",
   "[",
   "0",
   "]",
   "==",
   "self",
   ".",
   "edge",
   "[",
   "1",
   "]",
   ":",
   "color",
   "=",
   "[",
   "i",
   "*",
   "tmp",
   "for",
   "i",
   "in",
   "self",
   ".",
   "colors",
   "[",
   "'vertex_fill_color'",
   "]",
   "]",
   "color",
   "[",
   "3",
   "]",
   "=",
   "1.0",
   "else",
   ":",
   "color",
   "=",
   "[",
   "i",
   "*",
   "tmp",
   "for",
   "i",
   "in",
   "self",
   ".",
   "colors",
   "[",
   "'edge_color'",
   "]",
   "]",
   "color",
   "[",
   "3",
   "]",
   "=",
   "1",
   "/",
   "2.",
   "return",
   "color"
  ]
 },
 {
  "idx": "maxmin-34",
  "nl_tokens": [
   "A",
   "time",
   "varying",
   "time",
   "delay",
   "which",
   "takes",
   "advantage",
   "of",
   "the",
   "Farrow",
   "structure",
   "for",
   "cubic",
   "interpolation",
   ":"
  ],
  "pl_tokens": [
   "def",
   "time_delay",
   "(",
   "x",
   ",",
   "D",
   ",",
   "N",
   "=",
   "4",
   ")",
   ":",
   "if",
   "type",
   "(",
   "D",
   ")",
   "==",
   "float",
   "or",
   "type",
   "(",
   "D",
   ")",
   "==",
   "int",
   ":",
   "#Make sure D stays with in the tapped delay line bounds",
   "if",
   "int",
   "(",
   "np",
   ".",
   "fix",
   "(",
   "D",
   ")",
   ")",
   "<",
   "1",
   ":",
   "print",
   "(",
   "'D has integer part less than one'",
   ")",
   "exit",
   "(",
   "1",
   ")",
   "if",
   "int",
   "(",
   "np",
   ".",
   "fix",
   "(",
   "D",
   ")",
   ")",
   ">",
   "N",
   "-",
   "2",
   ":",
   "print",
   "(",
   "'D has integer part greater than N - 2'",
   ")",
   "exit",
   "(",
   "1",
   ")",
   "# Filter 4-tap input with four Farrow FIR filters",
   "# Since the time delay is a constant, the LTI filter",
   "# function from scipy.signal is convenient.",
   "D_frac",
   "=",
   "D",
   "-",
   "np",
   ".",
   "fix",
   "(",
   "D",
   ")",
   "Nd",
   "=",
   "int",
   "(",
   "np",
   ".",
   "fix",
   "(",
   "D",
   ")",
   ")",
   "b",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "Nd",
   "+",
   "4",
   ")",
   "# Load Lagrange coefficients into the last four FIR taps",
   "b",
   "[",
   "Nd",
   "]",
   "=",
   "-",
   "(",
   "D_frac",
   "-",
   "1",
   ")",
   "*",
   "(",
   "D_frac",
   "-",
   "2",
   ")",
   "*",
   "(",
   "D_frac",
   "-",
   "3",
   ")",
   "/",
   "6.",
   "b",
   "[",
   "Nd",
   "+",
   "1",
   "]",
   "=",
   "D_frac",
   "*",
   "(",
   "D_frac",
   "-",
   "2",
   ")",
   "*",
   "(",
   "D_frac",
   "-",
   "3",
   ")",
   "/",
   "2.",
   "b",
   "[",
   "Nd",
   "+",
   "2",
   "]",
   "=",
   "-",
   "D_frac",
   "*",
   "(",
   "D_frac",
   "-",
   "1",
   ")",
   "*",
   "(",
   "D_frac",
   "-",
   "3",
   ")",
   "/",
   "2.",
   "b",
   "[",
   "Nd",
   "+",
   "3",
   "]",
   "=",
   "D_frac",
   "*",
   "(",
   "D_frac",
   "-",
   "1",
   ")",
   "*",
   "(",
   "D_frac",
   "-",
   "2",
   ")",
   "/",
   "6.",
   "# Do all of the filtering in one step for this special case",
   "# of a fixed delay.",
   "y",
   "=",
   "signal",
   ".",
   "lfilter",
   "(",
   "b",
   ",",
   "[",
   "1",
   "]",
   ",",
   "x",
   ")",
   "else",
   ":",
   "# Make sure D stays with in the tapped delay line bounds",
   "if",
   "np",
   ".",
   "fix",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "D",
   ")",
   ")",
   "<",
   "1",
   ":",
   "print",
   "(",
   "'D has integer part less than one'",
   ")",
   "exit",
   "(",
   "1",
   ")",
   "if",
   "np",
   ".",
   "fix",
   "(",
   "np",
   ".",
   "max",
   "(",
   "D",
   ")",
   ")",
   ">",
   "N",
   "-",
   "2",
   ":",
   "print",
   "(",
   "'D has integer part greater than N - 2'",
   ")",
   "exit",
   "(",
   "1",
   ")",
   "y",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "x",
   ")",
   ")",
   "X",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "N",
   "+",
   "1",
   ")",
   "# Farrow filter tap weights",
   "W3",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "1.",
   "/",
   "6",
   ",",
   "-",
   "1.",
   "/",
   "2",
   ",",
   "1.",
   "/",
   "2",
   ",",
   "-",
   "1.",
   "/",
   "6",
   "]",
   "]",
   ")",
   "W2",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "0",
   ",",
   "1.",
   "/",
   "2",
   ",",
   "-",
   "1.",
   ",",
   "1.",
   "/",
   "2",
   "]",
   "]",
   ")",
   "W1",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "-",
   "1.",
   "/",
   "6",
   ",",
   "1.",
   ",",
   "-",
   "1.",
   "/",
   "2",
   ",",
   "-",
   "1.",
   "/",
   "3",
   "]",
   "]",
   ")",
   "W0",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "0",
   ",",
   "0",
   ",",
   "1.",
   ",",
   "0",
   "]",
   "]",
   ")",
   "for",
   "k",
   "in",
   "range",
   "(",
   "len",
   "(",
   "x",
   ")",
   ")",
   ":",
   "Nd",
   "=",
   "int",
   "(",
   "np",
   ".",
   "fix",
   "(",
   "D",
   "[",
   "k",
   "]",
   ")",
   ")",
   "mu",
   "=",
   "1",
   "-",
   "(",
   "D",
   "[",
   "k",
   "]",
   "-",
   "np",
   ".",
   "fix",
   "(",
   "D",
   "[",
   "k",
   "]",
   ")",
   ")",
   "# Form a row vector of signal samples, present and past values",
   "X",
   "=",
   "np",
   ".",
   "hstack",
   "(",
   "(",
   "np",
   ".",
   "array",
   "(",
   "x",
   "[",
   "k",
   "]",
   ")",
   ",",
   "X",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   ")",
   "# Filter 4-tap input with four Farrow FIR filters",
   "# Here numpy dot(A,B) performs the matrix multiply",
   "# since the filter has time-varying coefficients",
   "v3",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "W3",
   ",",
   "np",
   ".",
   "array",
   "(",
   "X",
   "[",
   "Nd",
   "-",
   "1",
   ":",
   "Nd",
   "+",
   "3",
   "]",
   ")",
   ".",
   "T",
   ")",
   "v2",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "W2",
   ",",
   "np",
   ".",
   "array",
   "(",
   "X",
   "[",
   "Nd",
   "-",
   "1",
   ":",
   "Nd",
   "+",
   "3",
   "]",
   ")",
   ".",
   "T",
   ")",
   "v1",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "W1",
   ",",
   "np",
   ".",
   "array",
   "(",
   "X",
   "[",
   "Nd",
   "-",
   "1",
   ":",
   "Nd",
   "+",
   "3",
   "]",
   ")",
   ".",
   "T",
   ")",
   "v0",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "W0",
   ",",
   "np",
   ".",
   "array",
   "(",
   "X",
   "[",
   "Nd",
   "-",
   "1",
   ":",
   "Nd",
   "+",
   "3",
   "]",
   ")",
   ".",
   "T",
   ")",
   "#Combine sub-filter outputs using mu = 1 - d",
   "y",
   "[",
   "k",
   "]",
   "=",
   "(",
   "(",
   "v3",
   "[",
   "0",
   "]",
   "*",
   "mu",
   "+",
   "v2",
   "[",
   "0",
   "]",
   ")",
   "*",
   "mu",
   "+",
   "v1",
   "[",
   "0",
   "]",
   ")",
   "*",
   "mu",
   "+",
   "v0",
   "[",
   "0",
   "]",
   "return",
   "y"
  ]
 },
 {
  "idx": "maxmin-35",
  "nl_tokens": [
   "Returns",
   "a",
   "list",
   "of",
   "tuples",
   "of",
   "start",
   "/",
   "end",
   "datetimes",
   "for",
   "when",
   "the",
   "schedule",
   "is",
   "active",
   "during",
   "the",
   "provided",
   "range",
   "."
  ],
  "pl_tokens": [
   "def",
   "intervals",
   "(",
   "self",
   ",",
   "range_start",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "<mask>",
   ",",
   "range_end",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "max",
   ")",
   ":",
   "raise",
   "NotImplementedError"
  ]
 },
 {
  "idx": "maxmin-36",
  "nl_tokens": [
   "Returns",
   "the",
   "min",
   "and",
   "max",
   "possible",
   "values",
   "for",
   "x",
   "within",
   "given",
   "constraints"
  ],
  "pl_tokens": [
   "def",
   "minmax",
   "(",
   "self",
   ",",
   "constraints",
   ",",
   "x",
   ",",
   "iters",
   "=",
   "10000",
   ")",
   ":",
   "if",
   "issymbolic",
   "(",
   "x",
   ")",
   ":",
   "m",
   "=",
   "self",
   ".",
   "<mask>",
   "(",
   "constraints",
   ",",
   "x",
   ",",
   "iters",
   ")",
   "M",
   "=",
   "self",
   ".",
   "max",
   "(",
   "constraints",
   ",",
   "x",
   ",",
   "iters",
   ")",
   "return",
   "m",
   ",",
   "M",
   "else",
   ":",
   "return",
   "x",
   ",",
   "x"
  ]
 },
 {
  "idx": "maxmin-37",
  "nl_tokens": [
   "Fit",
   "empirical",
   "Bayes",
   "prior",
   "in",
   "the",
   "hierarchical",
   "model",
   "[",
   "Efron2014",
   "]",
   "_",
   "."
  ],
  "pl_tokens": [
   "def",
   "gfit",
   "(",
   "X",
   ",",
   "sigma",
   ",",
   "p",
   "=",
   "5",
   ",",
   "nbin",
   "=",
   "200",
   ",",
   "unif_fraction",
   "=",
   "0.1",
   ")",
   ":",
   "min_x",
   "=",
   "<mask>",
   "(",
   "min",
   "(",
   "X",
   ")",
   "-",
   "2",
   "*",
   "np",
   ".",
   "std",
   "(",
   "X",
   ",",
   "ddof",
   "=",
   "1",
   ")",
   ",",
   "0",
   ")",
   "max_x",
   "=",
   "max",
   "(",
   "max",
   "(",
   "X",
   ")",
   "+",
   "2",
   "*",
   "np",
   ".",
   "std",
   "(",
   "X",
   ",",
   "ddof",
   "=",
   "1",
   ")",
   ",",
   "np",
   ".",
   "std",
   "(",
   "X",
   ",",
   "ddof",
   "=",
   "1",
   ")",
   ")",
   "xvals",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "min_x",
   ",",
   "max_x",
   ",",
   "nbin",
   ")",
   "binw",
   "=",
   "(",
   "max_x",
   "-",
   "min_x",
   ")",
   "/",
   "(",
   "nbin",
   "-",
   "1",
   ")",
   "zero_idx",
   "=",
   "max",
   "(",
   "np",
   ".",
   "where",
   "(",
   "xvals",
   "<=",
   "0",
   ")",
   "[",
   "0",
   "]",
   ")",
   "noise_kernel",
   "=",
   "norm",
   "(",
   ")",
   ".",
   "pdf",
   "(",
   "xvals",
   "/",
   "sigma",
   ")",
   "*",
   "binw",
   "/",
   "sigma",
   "if",
   "zero_idx",
   ">",
   "0",
   ":",
   "noise_rotate",
   "=",
   "noise_kernel",
   "[",
   "list",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "zero_idx",
   ",",
   "len",
   "(",
   "xvals",
   ")",
   ")",
   ")",
   "+",
   "list",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "zero_idx",
   ")",
   ")",
   "]",
   "else",
   ":",
   "noise_rotate",
   "=",
   "noise_kernel",
   "XX",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "p",
   ",",
   "len",
   "(",
   "xvals",
   ")",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float",
   ")",
   "for",
   "ind",
   ",",
   "exp",
   "in",
   "enumerate",
   "(",
   "range",
   "(",
   "1",
   ",",
   "p",
   "+",
   "1",
   ")",
   ")",
   ":",
   "mask",
   "=",
   "np",
   ".",
   "ones_like",
   "(",
   "xvals",
   ")",
   "mask",
   "[",
   "np",
   ".",
   "where",
   "(",
   "xvals",
   "<=",
   "0",
   ")",
   "[",
   "0",
   "]",
   "]",
   "=",
   "0",
   "XX",
   "[",
   "ind",
   ",",
   ":",
   "]",
   "=",
   "pow",
   "(",
   "xvals",
   ",",
   "exp",
   ")",
   "*",
   "mask",
   "XX",
   "=",
   "XX",
   ".",
   "T",
   "def",
   "neg_loglik",
   "(",
   "eta",
   ")",
   ":",
   "mask",
   "=",
   "np",
   ".",
   "ones_like",
   "(",
   "xvals",
   ")",
   "mask",
   "[",
   "np",
   ".",
   "where",
   "(",
   "xvals",
   "<=",
   "0",
   ")",
   "[",
   "0",
   "]",
   "]",
   "=",
   "0",
   "g_eta_raw",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "np",
   ".",
   "dot",
   "(",
   "XX",
   ",",
   "eta",
   ")",
   ")",
   "*",
   "mask",
   "if",
   "(",
   "(",
   "np",
   ".",
   "sum",
   "(",
   "g_eta_raw",
   ")",
   "==",
   "np",
   ".",
   "inf",
   ")",
   "|",
   "(",
   "np",
   ".",
   "sum",
   "(",
   "g_eta_raw",
   ")",
   "<=",
   "100",
   "*",
   "np",
   ".",
   "finfo",
   "(",
   "np",
   ".",
   "double",
   ")",
   ".",
   "tiny",
   ")",
   ")",
   ":",
   "return",
   "(",
   "1000",
   "*",
   "(",
   "len",
   "(",
   "X",
   ")",
   "+",
   "sum",
   "(",
   "eta",
   "**",
   "2",
   ")",
   ")",
   ")",
   "g_eta_main",
   "=",
   "g_eta_raw",
   "/",
   "sum",
   "(",
   "g_eta_raw",
   ")",
   "g_eta",
   "=",
   "(",
   "(",
   "1",
   "-",
   "unif_fraction",
   ")",
   "*",
   "g_eta_main",
   "+",
   "unif_fraction",
   "*",
   "mask",
   "/",
   "sum",
   "(",
   "mask",
   ")",
   ")",
   "f_eta",
   "=",
   "fftconvolve",
   "(",
   "g_eta",
   ",",
   "noise_rotate",
   ",",
   "mode",
   "=",
   "'same'",
   ")",
   "return",
   "np",
   ".",
   "sum",
   "(",
   "np",
   ".",
   "interp",
   "(",
   "X",
   ",",
   "xvals",
   ",",
   "-",
   "np",
   ".",
   "log",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "f_eta",
   ",",
   "0.0000001",
   ")",
   ")",
   ")",
   ")",
   "eta_hat",
   "=",
   "minimize",
   "(",
   "neg_loglik",
   ",",
   "list",
   "(",
   "itertools",
   ".",
   "repeat",
   "(",
   "-",
   "1",
   ",",
   "p",
   ")",
   ")",
   ")",
   ".",
   "x",
   "g_eta_raw",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "np",
   ".",
   "dot",
   "(",
   "XX",
   ",",
   "eta_hat",
   ")",
   ")",
   "*",
   "mask",
   "g_eta_main",
   "=",
   "g_eta_raw",
   "/",
   "sum",
   "(",
   "g_eta_raw",
   ")",
   "g_eta",
   "=",
   "(",
   "(",
   "1",
   "-",
   "unif_fraction",
   ")",
   "*",
   "g_eta_main",
   "+",
   "unif_fraction",
   "*",
   "mask",
   ")",
   "/",
   "sum",
   "(",
   "mask",
   ")",
   "return",
   "xvals",
   ",",
   "g_eta"
  ]
 },
 {
  "idx": "maxmin-38",
  "nl_tokens": [
   "Return",
   "the",
   "NCD",
   "between",
   "two",
   "strings",
   "using",
   "LZMA",
   "compression",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "src",
   "=",
   "src",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   "tar",
   "=",
   "tar",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   "if",
   "lzma",
   "is",
   "not",
   "None",
   ":",
   "src_comp",
   "=",
   "lzma",
   ".",
   "compress",
   "(",
   "src",
   ")",
   "[",
   "14",
   ":",
   "]",
   "tar_comp",
   "=",
   "lzma",
   ".",
   "compress",
   "(",
   "tar",
   ")",
   "[",
   "14",
   ":",
   "]",
   "concat_comp",
   "=",
   "lzma",
   ".",
   "compress",
   "(",
   "src",
   "+",
   "tar",
   ")",
   "[",
   "14",
   ":",
   "]",
   "concat_comp2",
   "=",
   "lzma",
   ".",
   "compress",
   "(",
   "tar",
   "+",
   "src",
   ")",
   "[",
   "14",
   ":",
   "]",
   "else",
   ":",
   "# pragma: no cover",
   "raise",
   "ValueError",
   "(",
   "'Install the PylibLZMA module in order to use LZMA'",
   ")",
   "return",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "concat_comp",
   ")",
   ",",
   "len",
   "(",
   "concat_comp2",
   ")",
   ")",
   "-",
   "min",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")",
   ")",
   "/",
   "max",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-39",
  "nl_tokens": [
   "List",
   "bot",
   "variables",
   "and",
   "values"
  ],
  "pl_tokens": [
   "def",
   "do_vars",
   "(",
   "self",
   ",",
   "line",
   ")",
   ":",
   "if",
   "self",
   ".",
   "bot",
   ".",
   "_vars",
   ":",
   "max_name_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "name",
   ")",
   "for",
   "name",
   "in",
   "self",
   ".",
   "bot",
   ".",
   "_vars",
   "]",
   ")",
   "for",
   "i",
   ",",
   "(",
   "name",
   ",",
   "v",
   ")",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "bot",
   ".",
   "_vars",
   ".",
   "items",
   "(",
   ")",
   ")",
   ":",
   "keep",
   "=",
   "i",
   "<",
   "len",
   "(",
   "self",
   ".",
   "bot",
   ".",
   "_vars",
   ")",
   "-",
   "1",
   "self",
   ".",
   "print_response",
   "(",
   "\"%s = %s\"",
   "%",
   "(",
   "name",
   ".",
   "ljust",
   "(",
   "max_name_len",
   ")",
   ",",
   "v",
   ".",
   "value",
   ")",
   ",",
   "keep",
   "=",
   "keep",
   ")",
   "else",
   ":",
   "self",
   ".",
   "print_response",
   "(",
   "\"No vars\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-40",
  "nl_tokens": [
   "Format",
   "a",
   "list",
   "of",
   "environments",
   "and",
   "modules",
   "for",
   "terminal",
   "output"
  ],
  "pl_tokens": [
   "def",
   "format_objects",
   "(",
   "objects",
   ",",
   "children",
   "=",
   "False",
   ",",
   "columns",
   "=",
   "None",
   ",",
   "header",
   "=",
   "True",
   ")",
   ":",
   "columns",
   "=",
   "columns",
   "or",
   "(",
   "'NAME'",
   ",",
   "'TYPE'",
   ",",
   "'PATH'",
   ")",
   "objects",
   "=",
   "sorted",
   "(",
   "objects",
   ",",
   "key",
   "=",
   "_type_and_name",
   ")",
   "data",
   "=",
   "[",
   "]",
   "for",
   "obj",
   "in",
   "objects",
   ":",
   "if",
   "isinstance",
   "(",
   "obj",
   ",",
   "cpenv",
   ".",
   "VirtualEnvironment",
   ")",
   ":",
   "data",
   ".",
   "append",
   "(",
   "get_info",
   "(",
   "obj",
   ")",
   ")",
   "modules",
   "=",
   "obj",
   ".",
   "get_modules",
   "(",
   ")",
   "if",
   "children",
   "and",
   "modules",
   ":",
   "for",
   "mod",
   "in",
   "modules",
   ":",
   "data",
   ".",
   "append",
   "(",
   "get_info",
   "(",
   "mod",
   ",",
   "indent",
   "=",
   "2",
   ",",
   "root",
   "=",
   "obj",
   ".",
   "path",
   ")",
   ")",
   "else",
   ":",
   "data",
   ".",
   "append",
   "(",
   "get_info",
   "(",
   "obj",
   ")",
   ")",
   "maxes",
   "=",
   "[",
   "len",
   "(",
   "<mask>",
   "(",
   "col",
   ",",
   "key",
   "=",
   "len",
   ")",
   ")",
   "for",
   "col",
   "in",
   "zip",
   "(",
   "*",
   "data",
   ")",
   "]",
   "tmpl",
   "=",
   "'{:%d}  {:%d}  {:%d}'",
   "%",
   "tuple",
   "(",
   "maxes",
   ")",
   "lines",
   "=",
   "[",
   "]",
   "if",
   "header",
   ":",
   "lines",
   ".",
   "append",
   "(",
   "'\\n'",
   "+",
   "bold_blue",
   "(",
   "tmpl",
   ".",
   "format",
   "(",
   "*",
   "columns",
   ")",
   ")",
   ")",
   "for",
   "obj_data",
   "in",
   "data",
   ":",
   "lines",
   ".",
   "append",
   "(",
   "tmpl",
   ".",
   "format",
   "(",
   "*",
   "obj_data",
   ")",
   ")",
   "return",
   "'\\n'",
   ".",
   "join",
   "(",
   "lines",
   ")"
  ]
 },
 {
  "idx": "maxmin-41",
  "nl_tokens": [
   "An",
   "integer",
   "-",
   "valued",
   "dimension",
   "bounded",
   "between",
   "min",
   "<",
   "=",
   "x",
   "<",
   "=",
   "max",
   ".",
   "Note",
   "that",
   "the",
   "right",
   "endpoint",
   "of",
   "the",
   "interval",
   "includes",
   "max",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_int",
   "(",
   "self",
   ",",
   "name",
   ",",
   "<mask>",
   ",",
   "max",
   ",",
   "warp",
   "=",
   "None",
   ")",
   ":",
   "min",
   ",",
   "max",
   "=",
   "map",
   "(",
   "int",
   ",",
   "(",
   "min",
   ",",
   "max",
   ")",
   ")",
   "if",
   "max",
   "<",
   "min",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: max < min error'",
   "%",
   "name",
   ")",
   "if",
   "warp",
   "not",
   "in",
   "(",
   "None",
   ",",
   "'log'",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: warp=%s is not supported. use '",
   "'None or \"log\",'",
   "%",
   "(",
   "name",
   ",",
   "warp",
   ")",
   ")",
   "if",
   "min",
   "<=",
   "0",
   "and",
   "warp",
   "==",
   "'log'",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: log-warping requires min > 0'",
   ")",
   "self",
   ".",
   "variables",
   "[",
   "name",
   "]",
   "=",
   "IntVariable",
   "(",
   "name",
   ",",
   "min",
   ",",
   "max",
   ",",
   "warp",
   ")"
  ]
 },
 {
  "idx": "maxmin-42",
  "nl_tokens": [
   "Initializes",
   "internal",
   "filter",
   "variables",
   "for",
   "further",
   "processing",
   ".",
   "Returns",
   "a",
   "tuple",
   "(",
   "function",
   "to",
   "call",
   "parameters",
   "for",
   "the",
   "filter",
   "call",
   ")"
  ],
  "pl_tokens": [
   "def",
   "initFilter",
   "(",
   "input",
   ",",
   "filterInfo",
   "=",
   "None",
   ")",
   ":",
   "if",
   "filterInfo",
   "is",
   "None",
   ":",
   "return",
   "None",
   "# Build an array of index/func to call on record[index]",
   "filterList",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "fieldName",
   "in",
   "enumerate",
   "(",
   "input",
   ".",
   "getFieldNames",
   "(",
   ")",
   ")",
   ":",
   "fieldFilter",
   "=",
   "filterInfo",
   ".",
   "get",
   "(",
   "fieldName",
   ",",
   "None",
   ")",
   "if",
   "fieldFilter",
   "==",
   "None",
   ":",
   "continue",
   "var",
   "=",
   "dict",
   "(",
   ")",
   "var",
   "[",
   "'acceptValues'",
   "]",
   "=",
   "None",
   "<mask>",
   "=",
   "fieldFilter",
   ".",
   "get",
   "(",
   "'min'",
   ",",
   "None",
   ")",
   "max",
   "=",
   "fieldFilter",
   ".",
   "get",
   "(",
   "'max'",
   ",",
   "None",
   ")",
   "var",
   "[",
   "'min'",
   "]",
   "=",
   "min",
   "var",
   "[",
   "'max'",
   "]",
   "=",
   "max",
   "if",
   "fieldFilter",
   "[",
   "'type'",
   "]",
   "==",
   "'category'",
   ":",
   "var",
   "[",
   "'acceptValues'",
   "]",
   "=",
   "fieldFilter",
   "[",
   "'acceptValues'",
   "]",
   "fp",
   "=",
   "lambda",
   "x",
   ":",
   "(",
   "x",
   "[",
   "'value'",
   "]",
   "!=",
   "SENTINEL_VALUE_FOR_MISSING_DATA",
   "and",
   "x",
   "[",
   "'value'",
   "]",
   "in",
   "x",
   "[",
   "'acceptValues'",
   "]",
   ")",
   "elif",
   "fieldFilter",
   "[",
   "'type'",
   "]",
   "==",
   "'number'",
   ":",
   "if",
   "min",
   "!=",
   "None",
   "and",
   "max",
   "!=",
   "None",
   ":",
   "fp",
   "=",
   "lambda",
   "x",
   ":",
   "(",
   "x",
   "[",
   "'value'",
   "]",
   "!=",
   "SENTINEL_VALUE_FOR_MISSING_DATA",
   "and",
   "x",
   "[",
   "'value'",
   "]",
   ">=",
   "x",
   "[",
   "'min'",
   "]",
   "and",
   "x",
   "[",
   "'value'",
   "]",
   "<=",
   "x",
   "[",
   "'max'",
   "]",
   ")",
   "elif",
   "min",
   "!=",
   "None",
   ":",
   "fp",
   "=",
   "lambda",
   "x",
   ":",
   "(",
   "x",
   "[",
   "'value'",
   "]",
   "!=",
   "SENTINEL_VALUE_FOR_MISSING_DATA",
   "and",
   "x",
   "[",
   "'value'",
   "]",
   ">=",
   "x",
   "[",
   "'min'",
   "]",
   ")",
   "else",
   ":",
   "fp",
   "=",
   "lambda",
   "x",
   ":",
   "(",
   "x",
   "[",
   "'value'",
   "]",
   "!=",
   "SENTINEL_VALUE_FOR_MISSING_DATA",
   "and",
   "x",
   "[",
   "'value'",
   "]",
   "<=",
   "x",
   "[",
   "'max'",
   "]",
   ")",
   "filterList",
   ".",
   "append",
   "(",
   "(",
   "i",
   ",",
   "fp",
   ",",
   "var",
   ")",
   ")",
   "return",
   "(",
   "_filterRecord",
   ",",
   "filterList",
   ")"
  ]
 },
 {
  "idx": "maxmin-43",
  "nl_tokens": [
   "Modify",
   "a",
   "model",
   "so",
   "all",
   "feasible",
   "flux",
   "distributions",
   "are",
   "loopless",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_loopless",
   "(",
   "model",
   ",",
   "zero_cutoff",
   "=",
   "None",
   ")",
   ":",
   "zero_cutoff",
   "=",
   "normalize_cutoff",
   "(",
   "model",
   ",",
   "zero_cutoff",
   ")",
   "internal",
   "=",
   "[",
   "i",
   "for",
   "i",
   ",",
   "r",
   "in",
   "enumerate",
   "(",
   "model",
   ".",
   "reactions",
   ")",
   "if",
   "not",
   "r",
   ".",
   "boundary",
   "]",
   "s_int",
   "=",
   "create_stoichiometric_matrix",
   "(",
   "model",
   ")",
   "[",
   ":",
   ",",
   "numpy",
   ".",
   "array",
   "(",
   "internal",
   ")",
   "]",
   "n_int",
   "=",
   "nullspace",
   "(",
   "s_int",
   ")",
   ".",
   "T",
   "max_bound",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "abs",
   "(",
   "b",
   ")",
   "for",
   "b",
   "in",
   "r",
   ".",
   "bounds",
   ")",
   "for",
   "r",
   "in",
   "model",
   ".",
   "reactions",
   ")",
   "prob",
   "=",
   "model",
   ".",
   "problem",
   "# Add indicator variables and new constraints",
   "to_add",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "internal",
   ":",
   "rxn",
   "=",
   "model",
   ".",
   "reactions",
   "[",
   "i",
   "]",
   "# indicator variable a_i",
   "indicator",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "\"indicator_\"",
   "+",
   "rxn",
   ".",
   "id",
   ",",
   "type",
   "=",
   "\"binary\"",
   ")",
   "# -M*(1 - a_i) <= v_i <= M*a_i",
   "on_off_constraint",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "rxn",
   ".",
   "flux_expression",
   "-",
   "max_bound",
   "*",
   "indicator",
   ",",
   "lb",
   "=",
   "-",
   "max_bound",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "\"on_off_\"",
   "+",
   "rxn",
   ".",
   "id",
   ")",
   "# -(max_bound + 1) * a_i + 1 <= G_i <= -(max_bound + 1) * a_i + 1000",
   "delta_g",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "\"delta_g_\"",
   "+",
   "rxn",
   ".",
   "id",
   ")",
   "delta_g_range",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "delta_g",
   "+",
   "(",
   "max_bound",
   "+",
   "1",
   ")",
   "*",
   "indicator",
   ",",
   "lb",
   "=",
   "1",
   ",",
   "ub",
   "=",
   "max_bound",
   ",",
   "name",
   "=",
   "\"delta_g_range_\"",
   "+",
   "rxn",
   ".",
   "id",
   ")",
   "to_add",
   ".",
   "extend",
   "(",
   "[",
   "indicator",
   ",",
   "on_off_constraint",
   ",",
   "delta_g",
   ",",
   "delta_g_range",
   "]",
   ")",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "to_add",
   ")",
   "# Add nullspace constraints for G_i",
   "for",
   "i",
   ",",
   "row",
   "in",
   "enumerate",
   "(",
   "n_int",
   ")",
   ":",
   "name",
   "=",
   "\"nullspace_constraint_\"",
   "+",
   "str",
   "(",
   "i",
   ")",
   "nullspace_constraint",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "Zero",
   ",",
   "lb",
   "=",
   "0",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "name",
   ")",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "[",
   "nullspace_constraint",
   "]",
   ")",
   "coefs",
   "=",
   "{",
   "model",
   ".",
   "variables",
   "[",
   "\"delta_g_\"",
   "+",
   "model",
   ".",
   "reactions",
   "[",
   "ridx",
   "]",
   ".",
   "id",
   "]",
   ":",
   "row",
   "[",
   "i",
   "]",
   "for",
   "i",
   ",",
   "ridx",
   "in",
   "enumerate",
   "(",
   "internal",
   ")",
   "if",
   "abs",
   "(",
   "row",
   "[",
   "i",
   "]",
   ")",
   ">",
   "zero_cutoff",
   "}",
   "model",
   ".",
   "constraints",
   "[",
   "name",
   "]",
   ".",
   "set_linear_coefficients",
   "(",
   "coefs",
   ")"
  ]
 },
 {
  "idx": "maxmin-44",
  "nl_tokens": [
   "r",
   "Method",
   "which",
   "picks",
   "out",
   "coefficients",
   "for",
   "the",
   "specified",
   "chemical",
   "from",
   "the",
   "various",
   "dictionaries",
   "and",
   "DataFrames",
   "storing",
   "it",
   ".",
   "All",
   "data",
   "is",
   "stored",
   "as",
   "attributes",
   ".",
   "This",
   "method",
   "also",
   "sets",
   ":",
   "obj",
   ":",
   "Tmin",
   ":",
   "obj",
   ":",
   "Tmax",
   "and",
   ":",
   "obj",
   ":",
   "all_methods",
   "as",
   "a",
   "set",
   "of",
   "methods",
   "for",
   "which",
   "the",
   "data",
   "exists",
   "for",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "]",
   "Tmins",
   ",",
   "Tmaxs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "CRC_Permittivity_data",
   ".",
   "index",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "CRC_CONSTANT",
   ")",
   "_",
   ",",
   "self",
   ".",
   "CRC_CONSTANT_T",
   ",",
   "self",
   ".",
   "CRC_permittivity",
   ",",
   "A",
   ",",
   "B",
   ",",
   "C",
   ",",
   "D",
   ",",
   "Tmin",
   ",",
   "Tmax",
   "=",
   "_CRC_Permittivity_data_values",
   "[",
   "CRC_Permittivity_data",
   ".",
   "index",
   ".",
   "get_loc",
   "(",
   "self",
   ".",
   "CASRN",
   ")",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "self",
   ".",
   "CRC_Tmin",
   "=",
   "Tmin",
   "self",
   ".",
   "CRC_Tmax",
   "=",
   "Tmax",
   "self",
   ".",
   "CRC_coeffs",
   "=",
   "[",
   "0",
   "if",
   "np",
   ".",
   "isnan",
   "(",
   "x",
   ")",
   "else",
   "x",
   "for",
   "x",
   "in",
   "[",
   "A",
   ",",
   "B",
   ",",
   "C",
   ",",
   "D",
   "]",
   "]",
   "if",
   "not",
   "np",
   ".",
   "isnan",
   "(",
   "Tmin",
   ")",
   ":",
   "Tmins",
   ".",
   "append",
   "(",
   "Tmin",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "Tmax",
   ")",
   "if",
   "self",
   ".",
   "CRC_coeffs",
   "[",
   "0",
   "]",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "CRC",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "if",
   "Tmins",
   "and",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmin",
   "=",
   "<mask>",
   "(",
   "Tmins",
   ")",
   "self",
   ".",
   "Tmax",
   "=",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-45",
  "nl_tokens": [
   "Called",
   "after",
   "a",
   "deployment",
   "to",
   "record",
   "any",
   "data",
   "necessary",
   "to",
   "detect",
   "changes",
   "for",
   "a",
   "future",
   "deployment",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_media_timestamp",
   "(",
   "self",
   ")",
   ":",
   "from",
   "burlap",
   ".",
   "common",
   "import",
   "get_last_modified_timestamp",
   "data",
   "=",
   "0",
   "for",
   "path",
   "in",
   "self",
   ".",
   "sync_media",
   "(",
   "iter_local_paths",
   "=",
   "1",
   ")",
   ":",
   "data",
   "=",
   "<mask>",
   "(",
   "data",
   ",",
   "get_last_modified_timestamp",
   "(",
   "path",
   ")",
   "or",
   "data",
   ")",
   "#TODO:hash media names and content",
   "if",
   "self",
   ".",
   "verbose",
   ":",
   "print",
   "(",
   "'date:'",
   ",",
   "data",
   ")",
   "return",
   "data"
  ]
 },
 {
  "idx": "maxmin-46",
  "nl_tokens": [
   "Iterates",
   "the",
   "graph",
   "layout",
   "and",
   "updates",
   "node",
   "positions",
   "."
  ],
  "pl_tokens": [
   "def",
   "update",
   "(",
   "self",
   ",",
   "iterations",
   "=",
   "10",
   ")",
   ":",
   "# The graph fades in when initially constructed.",
   "self",
   ".",
   "alpha",
   "+=",
   "0.05",
   "self",
   ".",
   "alpha",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "alpha",
   ",",
   "1.0",
   ")",
   "# Iterates over the graph's layout.",
   "# Each step the graph's bounds are recalculated",
   "# and a number of iterations are processed,",
   "# more and more as the layout progresses.",
   "if",
   "self",
   ".",
   "layout",
   ".",
   "i",
   "==",
   "0",
   ":",
   "self",
   ".",
   "layout",
   ".",
   "prepare",
   "(",
   ")",
   "self",
   ".",
   "layout",
   ".",
   "i",
   "+=",
   "1",
   "elif",
   "self",
   ".",
   "layout",
   ".",
   "i",
   "==",
   "1",
   ":",
   "self",
   ".",
   "layout",
   ".",
   "iterate",
   "(",
   ")",
   "elif",
   "self",
   ".",
   "layout",
   ".",
   "i",
   "<",
   "self",
   ".",
   "layout",
   ".",
   "n",
   ":",
   "n",
   "=",
   "min",
   "(",
   "iterations",
   ",",
   "self",
   ".",
   "layout",
   ".",
   "i",
   "/",
   "10",
   "+",
   "1",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n",
   ")",
   ":",
   "self",
   ".",
   "layout",
   ".",
   "iterate",
   "(",
   ")",
   "# Calculate the absolute center of the graph.",
   "min_",
   ",",
   "max",
   "=",
   "self",
   ".",
   "layout",
   ".",
   "bounds",
   "self",
   ".",
   "x",
   "=",
   "_ctx",
   ".",
   "WIDTH",
   "-",
   "max",
   ".",
   "x",
   "*",
   "self",
   ".",
   "d",
   "-",
   "min_",
   ".",
   "x",
   "*",
   "self",
   ".",
   "d",
   "self",
   ".",
   "y",
   "=",
   "_ctx",
   ".",
   "HEIGHT",
   "-",
   "max",
   ".",
   "y",
   "*",
   "self",
   ".",
   "d",
   "-",
   "min_",
   ".",
   "y",
   "*",
   "self",
   ".",
   "d",
   "self",
   ".",
   "x",
   "/=",
   "2",
   "self",
   ".",
   "y",
   "/=",
   "2",
   "return",
   "not",
   "self",
   ".",
   "layout",
   ".",
   "done"
  ]
 },
 {
  "idx": "maxmin-47",
  "nl_tokens": [
   "Get",
   "a",
   "stop",
   "-",
   "to",
   "-",
   "stop",
   "network",
   "describing",
   "a",
   "single",
   "mode",
   "of",
   "travel",
   "."
  ],
  "pl_tokens": [
   "def",
   "stop_to_stop_network_for_route_type",
   "(",
   "gtfs",
   ",",
   "route_type",
   ",",
   "link_attributes",
   "=",
   "None",
   ",",
   "start_time_ut",
   "=",
   "None",
   ",",
   "end_time_ut",
   "=",
   "None",
   ")",
   ":",
   "if",
   "link_attributes",
   "is",
   "None",
   ":",
   "link_attributes",
   "=",
   "DEFAULT_STOP_TO_STOP_LINK_ATTRIBUTES",
   "assert",
   "(",
   "route_type",
   "in",
   "route_types",
   ".",
   "TRANSIT_ROUTE_TYPES",
   ")",
   "stops_dataframe",
   "=",
   "gtfs",
   ".",
   "get_stops_for_route_type",
   "(",
   "route_type",
   ")",
   "net",
   "=",
   "networkx",
   ".",
   "DiGraph",
   "(",
   ")",
   "_add_stops_to_net",
   "(",
   "net",
   ",",
   "stops_dataframe",
   ")",
   "events_df",
   "=",
   "gtfs",
   ".",
   "get_transit_events",
   "(",
   "start_time_ut",
   "=",
   "start_time_ut",
   ",",
   "end_time_ut",
   "=",
   "end_time_ut",
   ",",
   "route_type",
   "=",
   "route_type",
   ")",
   "if",
   "len",
   "(",
   "net",
   ".",
   "nodes",
   "(",
   ")",
   ")",
   "<",
   "2",
   ":",
   "assert",
   "events_df",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "==",
   "0",
   "# group events by links, and loop over them (i.e. each link):",
   "link_event_groups",
   "=",
   "events_df",
   ".",
   "groupby",
   "(",
   "[",
   "'from_stop_I'",
   ",",
   "'to_stop_I'",
   "]",
   ",",
   "sort",
   "=",
   "False",
   ")",
   "for",
   "key",
   ",",
   "link_events",
   "in",
   "link_event_groups",
   ":",
   "from_stop_I",
   ",",
   "to_stop_I",
   "=",
   "key",
   "assert",
   "isinstance",
   "(",
   "link_events",
   ",",
   "pd",
   ".",
   "DataFrame",
   ")",
   "# 'dep_time_ut' 'arr_time_ut' 'shape_id' 'route_type' 'trip_I' 'duration' 'from_seq' 'to_seq'",
   "if",
   "link_attributes",
   "is",
   "None",
   ":",
   "net",
   ".",
   "add_edge",
   "(",
   "from_stop_I",
   ",",
   "to_stop_I",
   ")",
   "else",
   ":",
   "link_data",
   "=",
   "{",
   "}",
   "if",
   "\"duration_min\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "'duration_min'",
   "]",
   "=",
   "float",
   "(",
   "link_events",
   "[",
   "'duration'",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "if",
   "\"duration_max\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "'duration_max'",
   "]",
   "=",
   "float",
   "(",
   "link_events",
   "[",
   "'duration'",
   "]",
   ".",
   "max",
   "(",
   ")",
   ")",
   "if",
   "\"duration_median\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "'duration_median'",
   "]",
   "=",
   "float",
   "(",
   "link_events",
   "[",
   "'duration'",
   "]",
   ".",
   "median",
   "(",
   ")",
   ")",
   "if",
   "\"duration_avg\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "'duration_avg'",
   "]",
   "=",
   "float",
   "(",
   "link_events",
   "[",
   "'duration'",
   "]",
   ".",
   "mean",
   "(",
   ")",
   ")",
   "# statistics on numbers of vehicles:",
   "if",
   "\"n_vehicles\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "'n_vehicles'",
   "]",
   "=",
   "int",
   "(",
   "link_events",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "if",
   "\"capacity_estimate\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "'capacity_estimate'",
   "]",
   "=",
   "route_types",
   ".",
   "ROUTE_TYPE_TO_APPROXIMATE_CAPACITY",
   "[",
   "route_type",
   "]",
   "*",
   "int",
   "(",
   "link_events",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "if",
   "\"d\"",
   "in",
   "link_attributes",
   ":",
   "from_lat",
   "=",
   "net",
   ".",
   "node",
   "[",
   "from_stop_I",
   "]",
   "[",
   "'lat'",
   "]",
   "from_lon",
   "=",
   "net",
   ".",
   "node",
   "[",
   "from_stop_I",
   "]",
   "[",
   "'lon'",
   "]",
   "to_lat",
   "=",
   "net",
   ".",
   "node",
   "[",
   "to_stop_I",
   "]",
   "[",
   "'lat'",
   "]",
   "to_lon",
   "=",
   "net",
   ".",
   "node",
   "[",
   "to_stop_I",
   "]",
   "[",
   "'lon'",
   "]",
   "distance",
   "=",
   "wgs84_distance",
   "(",
   "from_lat",
   ",",
   "from_lon",
   ",",
   "to_lat",
   ",",
   "to_lon",
   ")",
   "link_data",
   "[",
   "'d'",
   "]",
   "=",
   "int",
   "(",
   "distance",
   ")",
   "if",
   "\"distance_shape\"",
   "in",
   "link_attributes",
   ":",
   "assert",
   "\"shape_id\"",
   "in",
   "link_events",
   ".",
   "columns",
   ".",
   "values",
   "found",
   "=",
   "None",
   "for",
   "i",
   ",",
   "shape_id",
   "in",
   "enumerate",
   "(",
   "link_events",
   "[",
   "\"shape_id\"",
   "]",
   ".",
   "values",
   ")",
   ":",
   "if",
   "shape_id",
   "is",
   "not",
   "None",
   ":",
   "found",
   "=",
   "i",
   "break",
   "if",
   "found",
   "is",
   "None",
   ":",
   "link_data",
   "[",
   "\"distance_shape\"",
   "]",
   "=",
   "None",
   "else",
   ":",
   "link_event",
   "=",
   "link_events",
   ".",
   "iloc",
   "[",
   "found",
   "]",
   "distance",
   "=",
   "gtfs",
   ".",
   "get_shape_distance_between_stops",
   "(",
   "link_event",
   "[",
   "\"trip_I\"",
   "]",
   ",",
   "int",
   "(",
   "link_event",
   "[",
   "\"from_seq\"",
   "]",
   ")",
   ",",
   "int",
   "(",
   "link_event",
   "[",
   "\"to_seq\"",
   "]",
   ")",
   ")",
   "link_data",
   "[",
   "'distance_shape'",
   "]",
   "=",
   "distance",
   "if",
   "\"route_I_counts\"",
   "in",
   "link_attributes",
   ":",
   "link_data",
   "[",
   "\"route_I_counts\"",
   "]",
   "=",
   "link_events",
   ".",
   "groupby",
   "(",
   "\"route_I\"",
   ")",
   ".",
   "size",
   "(",
   ")",
   ".",
   "to_dict",
   "(",
   ")",
   "net",
   ".",
   "add_edge",
   "(",
   "from_stop_I",
   ",",
   "to_stop_I",
   ",",
   "attr_dict",
   "=",
   "link_data",
   ")",
   "return",
   "net"
  ]
 },
 {
  "idx": "maxmin-48",
  "nl_tokens": [
   "Renders",
   "the",
   "given",
   "edge",
   "(",
   "n1",
   "n2",
   ")",
   "to",
   "the",
   "plot",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw_edge",
   "(",
   "self",
   ",",
   "n1",
   ",",
   "n2",
   ",",
   "d",
   ",",
   "group",
   ")",
   ":",
   "start_radius",
   "=",
   "self",
   ".",
   "node_radius",
   "(",
   "n1",
   ")",
   "start_theta",
   "=",
   "self",
   ".",
   "node_theta",
   "(",
   "n1",
   ")",
   "end_radius",
   "=",
   "self",
   ".",
   "node_radius",
   "(",
   "n2",
   ")",
   "end_theta",
   "=",
   "self",
   ".",
   "node_theta",
   "(",
   "n2",
   ")",
   "start_theta",
   ",",
   "end_theta",
   "=",
   "self",
   ".",
   "correct_angles",
   "(",
   "start_theta",
   ",",
   "end_theta",
   ")",
   "start_theta",
   ",",
   "end_theta",
   "=",
   "self",
   ".",
   "adjust_angles",
   "(",
   "n1",
   ",",
   "start_theta",
   ",",
   "n2",
   ",",
   "end_theta",
   ")",
   "middle1_radius",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "start_radius",
   ",",
   "end_radius",
   "]",
   ")",
   "middle2_radius",
   "=",
   "np",
   ".",
   "max",
   "(",
   "[",
   "start_radius",
   ",",
   "end_radius",
   "]",
   ")",
   "if",
   "start_radius",
   ">",
   "end_radius",
   ":",
   "middle1_radius",
   ",",
   "middle2_radius",
   "=",
   "middle2_radius",
   ",",
   "middle1_radius",
   "middle1_theta",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "[",
   "start_theta",
   ",",
   "end_theta",
   "]",
   ")",
   "middle2_theta",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "[",
   "start_theta",
   ",",
   "end_theta",
   "]",
   ")",
   "startx",
   ",",
   "starty",
   "=",
   "get_cartesian",
   "(",
   "start_radius",
   ",",
   "start_theta",
   ")",
   "middle1x",
   ",",
   "middle1y",
   "=",
   "get_cartesian",
   "(",
   "middle1_radius",
   ",",
   "middle1_theta",
   ")",
   "middle2x",
   ",",
   "middle2y",
   "=",
   "get_cartesian",
   "(",
   "middle2_radius",
   ",",
   "middle2_theta",
   ")",
   "# middlex, middley = get_cartesian(middle_radius, middle_theta)",
   "endx",
   ",",
   "endy",
   "=",
   "get_cartesian",
   "(",
   "end_radius",
   ",",
   "end_theta",
   ")",
   "verts",
   "=",
   "[",
   "(",
   "startx",
   ",",
   "starty",
   ")",
   ",",
   "(",
   "middle1x",
   ",",
   "middle1y",
   ")",
   ",",
   "(",
   "middle2x",
   ",",
   "middle2y",
   ")",
   ",",
   "(",
   "endx",
   ",",
   "endy",
   ")",
   "]",
   "codes",
   "=",
   "[",
   "Path",
   ".",
   "MOVETO",
   ",",
   "Path",
   ".",
   "CURVE4",
   ",",
   "Path",
   ".",
   "CURVE4",
   ",",
   "Path",
   ".",
   "CURVE4",
   "]",
   "path",
   "=",
   "Path",
   "(",
   "verts",
   ",",
   "codes",
   ")",
   "if",
   "self",
   ".",
   "edge_colormap",
   "is",
   "None",
   ":",
   "edgecolor",
   "=",
   "'black'",
   "else",
   ":",
   "edgecolor",
   "=",
   "self",
   ".",
   "edge_colormap",
   "[",
   "group",
   "]",
   "patch",
   "=",
   "patches",
   ".",
   "PathPatch",
   "(",
   "path",
   ",",
   "lw",
   "=",
   "self",
   ".",
   "linewidth",
   ",",
   "facecolor",
   "=",
   "'none'",
   ",",
   "edgecolor",
   "=",
   "edgecolor",
   ",",
   "alpha",
   "=",
   "0.3",
   ")",
   "self",
   ".",
   "ax",
   ".",
   "add_patch",
   "(",
   "patch",
   ")"
  ]
 },
 {
  "idx": "maxmin-49",
  "nl_tokens": [
   "Get",
   "tuple",
   "(",
   "actually",
   "a",
   "generator",
   ")",
   "of",
   "indices",
   "where",
   "the",
   "max",
   "value",
   "of",
   "array",
   "x",
   "occurs",
   ".",
   "Requires",
   "that",
   "x",
   "have",
   "a",
   "max",
   "()",
   "method",
   "as",
   "x",
   ".",
   "max",
   "()",
   "(",
   "in",
   "the",
   "case",
   "of",
   "NumPy",
   ")",
   "is",
   "much",
   "faster",
   "than",
   "max",
   "(",
   "x",
   ")",
   ".",
   "For",
   "a",
   "simpler",
   "faster",
   "argmax",
   "when",
   "there",
   "is",
   "only",
   "a",
   "single",
   "maximum",
   "entry",
   "or",
   "when",
   "knowing",
   "only",
   "the",
   "first",
   "index",
   "where",
   "the",
   "maximum",
   "occurs",
   "call",
   "argmax",
   "()",
   "on",
   "a",
   "NumPy",
   "array",
   "."
  ],
  "pl_tokens": [
   "def",
   "MultiArgMax",
   "(",
   "x",
   ")",
   ":",
   "m",
   "=",
   "x",
   ".",
   "<mask>",
   "(",
   ")",
   "return",
   "(",
   "i",
   "for",
   "i",
   ",",
   "v",
   "in",
   "enumerate",
   "(",
   "x",
   ")",
   "if",
   "v",
   "==",
   "m",
   ")"
  ]
 },
 {
  "idx": "maxmin-50",
  "nl_tokens": [
   "Calculates",
   "kappa",
   "correlation",
   "between",
   "rater_a",
   "and",
   "rater_b",
   ".",
   "Kappa",
   "measures",
   "how",
   "well",
   "2",
   "quantities",
   "vary",
   "together",
   ".",
   "rater_a",
   "is",
   "a",
   "list",
   "of",
   "rater",
   "a",
   "scores",
   "rater_b",
   "is",
   "a",
   "list",
   "of",
   "rater",
   "b",
   "scores",
   "min_rating",
   "is",
   "an",
   "optional",
   "argument",
   "describing",
   "the",
   "minimum",
   "rating",
   "possible",
   "on",
   "the",
   "data",
   "set",
   "max_rating",
   "is",
   "an",
   "optional",
   "argument",
   "describing",
   "the",
   "maximum",
   "rating",
   "possible",
   "on",
   "the",
   "data",
   "set",
   "Returns",
   "a",
   "float",
   "corresponding",
   "to",
   "the",
   "kappa",
   "correlation"
  ],
  "pl_tokens": [
   "def",
   "quadratic_weighted_kappa",
   "(",
   "rater_a",
   ",",
   "rater_b",
   ",",
   "min_rating",
   "=",
   "None",
   ",",
   "max_rating",
   "=",
   "None",
   ")",
   ":",
   "assert",
   "(",
   "len",
   "(",
   "rater_a",
   ")",
   "==",
   "len",
   "(",
   "rater_b",
   ")",
   ")",
   "rater_a",
   "=",
   "[",
   "int",
   "(",
   "a",
   ")",
   "for",
   "a",
   "in",
   "rater_a",
   "]",
   "rater_b",
   "=",
   "[",
   "int",
   "(",
   "b",
   ")",
   "for",
   "b",
   "in",
   "rater_b",
   "]",
   "if",
   "min_rating",
   "is",
   "None",
   ":",
   "min_rating",
   "=",
   "<mask>",
   "(",
   "rater_a",
   "+",
   "rater_b",
   ")",
   "if",
   "max_rating",
   "is",
   "None",
   ":",
   "max_rating",
   "=",
   "max",
   "(",
   "rater_a",
   "+",
   "rater_b",
   ")",
   "conf_mat",
   "=",
   "confusion_matrix",
   "(",
   "rater_a",
   ",",
   "rater_b",
   ",",
   "min_rating",
   ",",
   "max_rating",
   ")",
   "num_ratings",
   "=",
   "len",
   "(",
   "conf_mat",
   ")",
   "num_scored_items",
   "=",
   "float",
   "(",
   "len",
   "(",
   "rater_a",
   ")",
   ")",
   "hist_rater_a",
   "=",
   "histogram",
   "(",
   "rater_a",
   ",",
   "min_rating",
   ",",
   "max_rating",
   ")",
   "hist_rater_b",
   "=",
   "histogram",
   "(",
   "rater_b",
   ",",
   "min_rating",
   ",",
   "max_rating",
   ")",
   "numerator",
   "=",
   "0.0",
   "denominator",
   "=",
   "0.0",
   "if",
   "(",
   "num_ratings",
   ">",
   "1",
   ")",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "num_ratings",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "num_ratings",
   ")",
   ":",
   "expected_count",
   "=",
   "(",
   "hist_rater_a",
   "[",
   "i",
   "]",
   "*",
   "hist_rater_b",
   "[",
   "j",
   "]",
   "/",
   "num_scored_items",
   ")",
   "d",
   "=",
   "pow",
   "(",
   "i",
   "-",
   "j",
   ",",
   "2.0",
   ")",
   "/",
   "pow",
   "(",
   "num_ratings",
   "-",
   "1",
   ",",
   "2.0",
   ")",
   "numerator",
   "+=",
   "d",
   "*",
   "conf_mat",
   "[",
   "i",
   "]",
   "[",
   "j",
   "]",
   "/",
   "num_scored_items",
   "denominator",
   "+=",
   "d",
   "*",
   "expected_count",
   "/",
   "num_scored_items",
   "return",
   "1.0",
   "-",
   "numerator",
   "/",
   "denominator",
   "else",
   ":",
   "return",
   "1.0"
  ]
 },
 {
  "idx": "maxmin-51",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "chebyshev_distance_numpy",
   "(",
   "object1",
   ",",
   "object2",
   ")",
   ":",
   "return",
   "numpy",
   ".",
   "<mask>",
   "(",
   "numpy",
   ".",
   "absolute",
   "(",
   "object1",
   "-",
   "object2",
   ")",
   ",",
   "axis",
   "=",
   "1",
   ")",
   ".",
   "T"
  ]
 },
 {
  "idx": "maxmin-52",
  "nl_tokens": [
   "Parameters",
   "----------",
   "g",
   ":",
   "A",
   "gtfspy",
   ".",
   "gtfs",
   ".",
   "GTFS",
   "object",
   "ax",
   ":",
   "matplotlib",
   ".",
   "Axes",
   "object",
   "optional",
   "If",
   "None",
   "a",
   "new",
   "figure",
   "and",
   "an",
   "axis",
   "is",
   "created",
   "otherwise",
   "results",
   "are",
   "plotted",
   "on",
   "the",
   "axis",
   ".",
   "scalebar",
   ":",
   "bool",
   "optional",
   "Whether",
   "to",
   "include",
   "a",
   "scalebar",
   "to",
   "the",
   "plot",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_all_stops",
   "(",
   "g",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "scalebar",
   "=",
   "False",
   ")",
   ":",
   "assert",
   "(",
   "isinstance",
   "(",
   "g",
   ",",
   "GTFS",
   ")",
   ")",
   "lon_min",
   ",",
   "lon_max",
   ",",
   "lat_min",
   ",",
   "lat_max",
   "=",
   "get_spatial_bounds",
   "(",
   "g",
   ")",
   "smopy_map",
   "=",
   "get_smopy_map",
   "(",
   "lon_min",
   ",",
   "lon_max",
   ",",
   "lat_min",
   ",",
   "lat_max",
   ")",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "111",
   ")",
   "ax",
   "=",
   "smopy_map",
   ".",
   "show_mpl",
   "(",
   "figsize",
   "=",
   "None",
   ",",
   "ax",
   "=",
   "ax",
   ",",
   "alpha",
   "=",
   "0.8",
   ")",
   "stops",
   "=",
   "g",
   ".",
   "stops",
   "(",
   ")",
   "lats",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "stops",
   "[",
   "'lat'",
   "]",
   ")",
   "lons",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "stops",
   "[",
   "'lon'",
   "]",
   ")",
   "xs",
   ",",
   "ys",
   "=",
   "smopy_map",
   ".",
   "to_pixels",
   "(",
   "lats",
   ",",
   "lons",
   ")",
   "ax",
   ".",
   "scatter",
   "(",
   "xs",
   ",",
   "ys",
   ",",
   "color",
   "=",
   "\"red\"",
   ",",
   "s",
   "=",
   "10",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "<mask>",
   "(",
   "xs",
   ")",
   ",",
   "max",
   "(",
   "xs",
   ")",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "max",
   "(",
   "ys",
   ")",
   ",",
   "min",
   "(",
   "ys",
   ")",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-53",
  "nl_tokens": [
   "See",
   "comments",
   "in",
   "base",
   "class",
   "."
  ],
  "pl_tokens": [
   "def",
   "newPosition",
   "(",
   "self",
   ",",
   "globalBestPosition",
   ",",
   "rng",
   ")",
   ":",
   "# First, update the velocity. The new velocity is given as:",
   "# v = (inertia * v)  + (cogRate * r1 * (localBest-pos))",
   "#                    + (socRate * r2 * (globalBest-pos))",
   "#",
   "# where r1 and r2 are random numbers between 0 and 1.0",
   "lb",
   "=",
   "float",
   "(",
   "Configuration",
   ".",
   "get",
   "(",
   "\"nupic.hypersearch.randomLowerBound\"",
   ")",
   ")",
   "ub",
   "=",
   "float",
   "(",
   "Configuration",
   ".",
   "get",
   "(",
   "\"nupic.hypersearch.randomUpperBound\"",
   ")",
   ")",
   "self",
   ".",
   "_velocity",
   "=",
   "(",
   "self",
   ".",
   "_velocity",
   "*",
   "self",
   ".",
   "_inertia",
   "+",
   "rng",
   ".",
   "uniform",
   "(",
   "lb",
   ",",
   "ub",
   ")",
   "*",
   "self",
   ".",
   "_cogRate",
   "*",
   "(",
   "self",
   ".",
   "_bestPosition",
   "-",
   "self",
   ".",
   "getPosition",
   "(",
   ")",
   ")",
   ")",
   "if",
   "globalBestPosition",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "_velocity",
   "+=",
   "rng",
   ".",
   "uniform",
   "(",
   "lb",
   ",",
   "ub",
   ")",
   "*",
   "self",
   ".",
   "_socRate",
   "*",
   "(",
   "globalBestPosition",
   "-",
   "self",
   ".",
   "getPosition",
   "(",
   ")",
   ")",
   "# update position based on velocity",
   "self",
   ".",
   "_position",
   "+=",
   "self",
   ".",
   "_velocity",
   "# Clip it",
   "self",
   ".",
   "_position",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "min",
   ",",
   "self",
   ".",
   "_position",
   ")",
   "self",
   ".",
   "_position",
   "=",
   "min",
   "(",
   "self",
   ".",
   "max",
   ",",
   "self",
   ".",
   "_position",
   ")",
   "# Return it",
   "return",
   "self",
   ".",
   "getPosition",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-54",
  "nl_tokens": [
   "This",
   "runs",
   "a",
   "parallelized",
   "Stellingwerf",
   "phase",
   "-",
   "dispersion",
   "minimization",
   "(",
   "PDM",
   ")",
   "period",
   "search",
   "."
  ],
  "pl_tokens": [
   "def",
   "stellingwerf_pdm",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "startp",
   "=",
   "None",
   ",",
   "endp",
   "=",
   "None",
   ",",
   "stepsize",
   "=",
   "1.0e-4",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "normalize",
   "=",
   "False",
   ",",
   "phasebinsize",
   "=",
   "0.05",
   ",",
   "mindetperbin",
   "=",
   "9",
   ",",
   "nbestpeaks",
   "=",
   "5",
   ",",
   "periodepsilon",
   "=",
   "0.1",
   ",",
   "sigclip",
   "=",
   "10.0",
   ",",
   "nworkers",
   "=",
   "None",
   ",",
   "verbose",
   "=",
   "True",
   ")",
   ":",
   "# get rid of nans first and sigclip",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# get the frequencies to use",
   "if",
   "startp",
   ":",
   "endf",
   "=",
   "1.0",
   "/",
   "startp",
   "else",
   ":",
   "# default start period is 0.1 day",
   "endf",
   "=",
   "1.0",
   "/",
   "0.1",
   "if",
   "endp",
   ":",
   "startf",
   "=",
   "1.0",
   "/",
   "endp",
   "else",
   ":",
   "# default end period is length of time series",
   "startf",
   "=",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# if we're not using autofreq, then use the provided frequencies",
   "if",
   "not",
   "autofreq",
   ":",
   "frequencies",
   "=",
   "nparange",
   "(",
   "startf",
   ",",
   "endf",
   ",",
   "stepsize",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using %s frequency points, start P = %.3f, end P = %.3f'",
   "%",
   "(",
   "frequencies",
   ".",
   "size",
   ",",
   "1.0",
   "/",
   "endf",
   ",",
   "1.0",
   "/",
   "startf",
   ")",
   ")",
   "else",
   ":",
   "# this gets an automatic grid of frequencies to use",
   "frequencies",
   "=",
   "get_frequency_grid",
   "(",
   "stimes",
   ",",
   "minfreq",
   "=",
   "startf",
   ",",
   "maxfreq",
   "=",
   "endf",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using autofreq with %s frequency points, '",
   "'start P = %.3f, end P = %.3f'",
   "%",
   "(",
   "frequencies",
   ".",
   "size",
   ",",
   "1.0",
   "/",
   "frequencies",
   ".",
   "max",
   "(",
   ")",
   ",",
   "1.0",
   "/",
   "frequencies",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "# map to parallel workers",
   "if",
   "(",
   "not",
   "nworkers",
   ")",
   "or",
   "(",
   "nworkers",
   ">",
   "NCPUS",
   ")",
   ":",
   "nworkers",
   "=",
   "NCPUS",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using %s workers...'",
   "%",
   "nworkers",
   ")",
   "pool",
   "=",
   "Pool",
   "(",
   "nworkers",
   ")",
   "# renormalize the working mags to zero and scale them so that the",
   "# variance = 1 for use with our LSP functions",
   "if",
   "normalize",
   ":",
   "nmags",
   "=",
   "(",
   "smags",
   "-",
   "npmedian",
   "(",
   "smags",
   ")",
   ")",
   "/",
   "npstd",
   "(",
   "smags",
   ")",
   "else",
   ":",
   "nmags",
   "=",
   "smags",
   "tasks",
   "=",
   "[",
   "(",
   "stimes",
   ",",
   "nmags",
   ",",
   "serrs",
   ",",
   "x",
   ",",
   "phasebinsize",
   ",",
   "mindetperbin",
   ")",
   "for",
   "x",
   "in",
   "frequencies",
   "]",
   "lsp",
   "=",
   "pool",
   ".",
   "map",
   "(",
   "_stellingwerf_pdm_worker",
   ",",
   "tasks",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "del",
   "pool",
   "lsp",
   "=",
   "nparray",
   "(",
   "lsp",
   ")",
   "periods",
   "=",
   "1.0",
   "/",
   "frequencies",
   "# find the nbestpeaks for the periodogram: 1. sort the lsp array by",
   "# lowest value first 2. go down the values until we find five values",
   "# that are separated by at least periodepsilon in period",
   "# make sure to filter out the non-finite values of lsp",
   "finitepeakind",
   "=",
   "npisfinite",
   "(",
   "lsp",
   ")",
   "finlsp",
   "=",
   "lsp",
   "[",
   "finitepeakind",
   "]",
   "finperiods",
   "=",
   "periods",
   "[",
   "finitepeakind",
   "]",
   "# finlsp might not have any finite values if the period finding",
   "# failed. if so, argmin will return a ValueError.",
   "try",
   ":",
   "bestperiodind",
   "=",
   "npargmin",
   "(",
   "finlsp",
   ")",
   "except",
   "ValueError",
   ":",
   "LOGERROR",
   "(",
   "'no finite periodogram values for '",
   "'this mag series, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'pdm'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'normalize'",
   ":",
   "normalize",
   ",",
   "'phasebinsize'",
   ":",
   "phasebinsize",
   ",",
   "'mindetperbin'",
   ":",
   "mindetperbin",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   "}",
   "}",
   "sortedlspind",
   "=",
   "npargsort",
   "(",
   "finlsp",
   ")",
   "sortedlspperiods",
   "=",
   "finperiods",
   "[",
   "sortedlspind",
   "]",
   "sortedlspvals",
   "=",
   "finlsp",
   "[",
   "sortedlspind",
   "]",
   "# now get the nbestpeaks",
   "nbestperiods",
   ",",
   "nbestlspvals",
   ",",
   "peakcount",
   "=",
   "(",
   "[",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "1",
   ")",
   "prevperiod",
   "=",
   "sortedlspperiods",
   "[",
   "0",
   "]",
   "# find the best nbestpeaks in the lsp and their periods",
   "for",
   "period",
   ",",
   "lspval",
   "in",
   "zip",
   "(",
   "sortedlspperiods",
   ",",
   "sortedlspvals",
   ")",
   ":",
   "if",
   "peakcount",
   "==",
   "nbestpeaks",
   ":",
   "break",
   "perioddiff",
   "=",
   "abs",
   "(",
   "period",
   "-",
   "prevperiod",
   ")",
   "bestperiodsdiff",
   "=",
   "[",
   "abs",
   "(",
   "period",
   "-",
   "x",
   ")",
   "for",
   "x",
   "in",
   "nbestperiods",
   "]",
   "# print('prevperiod = %s, thisperiod = %s, '",
   "#       'perioddiff = %s, peakcount = %s' %",
   "#       (prevperiod, period, perioddiff, peakcount))",
   "# this ensures that this period is different from the last",
   "# period and from all the other existing best periods by",
   "# periodepsilon to make sure we jump to an entire different peak",
   "# in the periodogram",
   "if",
   "(",
   "perioddiff",
   ">",
   "(",
   "periodepsilon",
   "*",
   "prevperiod",
   ")",
   "and",
   "all",
   "(",
   "x",
   ">",
   "(",
   "periodepsilon",
   "*",
   "period",
   ")",
   "for",
   "x",
   "in",
   "bestperiodsdiff",
   ")",
   ")",
   ":",
   "nbestperiods",
   ".",
   "append",
   "(",
   "period",
   ")",
   "nbestlspvals",
   ".",
   "append",
   "(",
   "lspval",
   ")",
   "peakcount",
   "=",
   "peakcount",
   "+",
   "1",
   "prevperiod",
   "=",
   "period",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'bestlspval'",
   ":",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "nbestlspvals",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'lspvals'",
   ":",
   "lsp",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'method'",
   ":",
   "'pdm'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'normalize'",
   ":",
   "normalize",
   ",",
   "'phasebinsize'",
   ":",
   "phasebinsize",
   ",",
   "'mindetperbin'",
   ":",
   "mindetperbin",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   "}",
   "}",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'pdm'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'normalize'",
   ":",
   "normalize",
   ",",
   "'phasebinsize'",
   ":",
   "phasebinsize",
   ",",
   "'mindetperbin'",
   ":",
   "mindetperbin",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   "}",
   "}"
  ]
 },
 {
  "idx": "maxmin-55",
  "nl_tokens": [
   "Receives",
   "a",
   "message",
   "as",
   "msgpack",
   "-",
   "numpy",
   "encoded",
   "byte",
   "-",
   "string",
   "from",
   "the",
   "given",
   "socket",
   "object",
   ".",
   "Blocks",
   "until",
   "something",
   "was",
   "received",
   "."
  ],
  "pl_tokens": [
   "def",
   "recv",
   "(",
   "self",
   ",",
   "socket_",
   ",",
   "encoding",
   "=",
   "None",
   ")",
   ":",
   "unpacker",
   "=",
   "msgpack",
   ".",
   "Unpacker",
   "(",
   "encoding",
   "=",
   "encoding",
   ")",
   "# Wait for an immediate response.",
   "response",
   "=",
   "socket_",
   ".",
   "recv",
   "(",
   "8",
   ")",
   "# get the length of the message",
   "if",
   "response",
   "==",
   "b\"\"",
   ":",
   "raise",
   "TensorForceError",
   "(",
   "\"No data received by socket.recv in call to method `recv` \"",
   "+",
   "\"(listener possibly closed)!\"",
   ")",
   "orig_len",
   "=",
   "int",
   "(",
   "response",
   ")",
   "received_len",
   "=",
   "0",
   "while",
   "True",
   ":",
   "data",
   "=",
   "socket_",
   ".",
   "recv",
   "(",
   "<mask>",
   "(",
   "orig_len",
   "-",
   "received_len",
   ",",
   "self",
   ".",
   "max_msg_len",
   ")",
   ")",
   "# There must be a response.",
   "if",
   "not",
   "data",
   ":",
   "raise",
   "TensorForceError",
   "(",
   "\"No data of len {} received by socket.recv in call to method `recv`!\"",
   ".",
   "format",
   "(",
   "orig_len",
   "-",
   "received_len",
   ")",
   ")",
   "data_len",
   "=",
   "len",
   "(",
   "data",
   ")",
   "received_len",
   "+=",
   "data_len",
   "unpacker",
   ".",
   "feed",
   "(",
   "data",
   ")",
   "if",
   "received_len",
   "==",
   "orig_len",
   ":",
   "break",
   "# Get the data.",
   "for",
   "message",
   "in",
   "unpacker",
   ":",
   "sts",
   "=",
   "message",
   ".",
   "get",
   "(",
   "\"status\"",
   ",",
   "message",
   ".",
   "get",
   "(",
   "b\"status\"",
   ")",
   ")",
   "if",
   "sts",
   ":",
   "if",
   "sts",
   "==",
   "\"ok\"",
   "or",
   "sts",
   "==",
   "b\"ok\"",
   ":",
   "return",
   "message",
   "else",
   ":",
   "raise",
   "TensorForceError",
   "(",
   "\"RemoteEnvironment server error: {}\"",
   ".",
   "format",
   "(",
   "message",
   ".",
   "get",
   "(",
   "\"message\"",
   ",",
   "\"not specified\"",
   ")",
   ")",
   ")",
   "else",
   ":",
   "raise",
   "TensorForceError",
   "(",
   "\"Message without field 'status' received!\"",
   ")",
   "raise",
   "TensorForceError",
   "(",
   "\"No message encoded in data stream (data stream had len={})\"",
   ".",
   "format",
   "(",
   "orig_len",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-56",
  "nl_tokens": [
   "applies",
   "max",
   "haplotypes",
   "filter",
   "returns",
   "pass",
   "and",
   "consens"
  ],
  "pl_tokens": [
   "def",
   "nfilter4",
   "(",
   "consens",
   ",",
   "hidx",
   ",",
   "arrayed",
   ")",
   ":",
   "## if less than two Hs then there is only one allele",
   "if",
   "len",
   "(",
   "hidx",
   ")",
   "<",
   "2",
   ":",
   "return",
   "consens",
   ",",
   "1",
   "## store base calls for hetero sites",
   "harray",
   "=",
   "arrayed",
   "[",
   ":",
   ",",
   "hidx",
   "]",
   "## remove any reads that have N or - base calls at hetero sites",
   "## these cannot be used when calling alleles currently.",
   "harray",
   "=",
   "harray",
   "[",
   "~",
   "np",
   ".",
   "any",
   "(",
   "harray",
   "==",
   "\"-\"",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "]",
   "harray",
   "=",
   "harray",
   "[",
   "~",
   "np",
   ".",
   "any",
   "(",
   "harray",
   "==",
   "\"N\"",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "]",
   "## get counts of each allele (e.g., AT:2, CG:2)",
   "ccx",
   "=",
   "Counter",
   "(",
   "[",
   "tuple",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "harray",
   "]",
   ")",
   "## Two possibilities we would like to distinguish, but we can't. Therefore,",
   "## we just throw away low depth third alleles that are within seq. error.",
   "## 1) a third base came up as a sequencing error but is not a unique allele",
   "## 2) a third or more unique allele is there but at low frequency",
   "## remove low freq alleles if more than 2, since they may reflect",
   "## sequencing errors at hetero sites, making a third allele, or a new",
   "## allelic combination that is not real.",
   "if",
   "len",
   "(",
   "ccx",
   ")",
   ">",
   "2",
   ":",
   "totdepth",
   "=",
   "harray",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "cutoff",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "totdepth",
   "//",
   "10",
   ")",
   "alleles",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "ccx",
   "if",
   "ccx",
   "[",
   "i",
   "]",
   ">",
   "cutoff",
   "]",
   "else",
   ":",
   "alleles",
   "=",
   "ccx",
   ".",
   "keys",
   "(",
   ")",
   "## how many high depth alleles?",
   "nalleles",
   "=",
   "len",
   "(",
   "alleles",
   ")",
   "## if 2 alleles then save the phase using lowercase coding",
   "if",
   "nalleles",
   "==",
   "2",
   ":",
   "try",
   ":",
   "consens",
   "=",
   "storealleles",
   "(",
   "consens",
   ",",
   "hidx",
   ",",
   "alleles",
   ")",
   "except",
   "(",
   "IndexError",
   ",",
   "KeyError",
   ")",
   ":",
   "## the H sites do not form good alleles",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"failed at phasing loc, skipping\"",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"\"\"\n    consens %s\n    hidx %s\n    alleles %s\n                \"\"\"",
   ",",
   "consens",
   ",",
   "hidx",
   ",",
   "alleles",
   ")",
   "return",
   "consens",
   ",",
   "nalleles",
   "## just return the info for later filtering",
   "else",
   ":",
   "return",
   "consens",
   ",",
   "nalleles"
  ]
 },
 {
  "idx": "maxmin-57",
  "nl_tokens": [
   "Add",
   "new",
   "(",
   "essay_text",
   "essay_score",
   ")",
   "pair",
   "to",
   "the",
   "essay",
   "set",
   ".",
   "essay_text",
   "must",
   "be",
   "a",
   "string",
   ".",
   "essay_score",
   "must",
   "be",
   "an",
   "int",
   ".",
   "essay_generated",
   "should",
   "not",
   "be",
   "changed",
   "by",
   "the",
   "user",
   ".",
   "Returns",
   "a",
   "confirmation",
   "that",
   "essay",
   "was",
   "added",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_essay",
   "(",
   "self",
   ",",
   "essay_text",
   ",",
   "essay_score",
   ",",
   "essay_generated",
   "=",
   "0",
   ")",
   ":",
   "# Get maximum current essay id, or set to 0 if this is the first essay added",
   "if",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_id",
   ")",
   ">",
   "0",
   ")",
   ":",
   "max_id",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_id",
   ")",
   "else",
   ":",
   "max_id",
   "=",
   "0",
   "# Verify that essay_score is an int, essay_text is a string, and essay_generated equals 0 or 1",
   "try",
   ":",
   "essay_text",
   "=",
   "essay_text",
   ".",
   "encode",
   "(",
   "'ascii'",
   ",",
   "'ignore'",
   ")",
   "if",
   "len",
   "(",
   "essay_text",
   ")",
   "<",
   "5",
   ":",
   "essay_text",
   "=",
   "\"Invalid essay.\"",
   "except",
   ":",
   "log",
   ".",
   "exception",
   "(",
   "\"Could not parse essay into ascii.\"",
   ")",
   "try",
   ":",
   "# Try conversion of types",
   "essay_score",
   "=",
   "int",
   "(",
   "essay_score",
   ")",
   "essay_text",
   "=",
   "str",
   "(",
   "essay_text",
   ")",
   "except",
   ":",
   "# Nothing needed here, will return error in any case.",
   "log",
   ".",
   "exception",
   "(",
   "\"Invalid type for essay score : {0} or essay text : {1}\"",
   ".",
   "format",
   "(",
   "type",
   "(",
   "essay_score",
   ")",
   ",",
   "type",
   "(",
   "essay_text",
   ")",
   ")",
   ")",
   "if",
   "isinstance",
   "(",
   "essay_score",
   ",",
   "int",
   ")",
   "and",
   "isinstance",
   "(",
   "essay_text",
   ",",
   "basestring",
   ")",
   "and",
   "(",
   "essay_generated",
   "==",
   "0",
   "or",
   "essay_generated",
   "==",
   "1",
   ")",
   ":",
   "self",
   ".",
   "_id",
   ".",
   "append",
   "(",
   "max_id",
   "+",
   "1",
   ")",
   "self",
   ".",
   "_score",
   ".",
   "append",
   "(",
   "essay_score",
   ")",
   "# Clean text by removing non digit/work/punctuation characters",
   "try",
   ":",
   "essay_text",
   "=",
   "str",
   "(",
   "essay_text",
   ".",
   "encode",
   "(",
   "'ascii'",
   ",",
   "'ignore'",
   ")",
   ")",
   "except",
   ":",
   "essay_text",
   "=",
   "(",
   "essay_text",
   ".",
   "decode",
   "(",
   "'utf-8'",
   ",",
   "'replace'",
   ")",
   ")",
   ".",
   "encode",
   "(",
   "'ascii'",
   ",",
   "'ignore'",
   ")",
   "cleaned_essay",
   "=",
   "util_functions",
   ".",
   "sub_chars",
   "(",
   "essay_text",
   ")",
   ".",
   "lower",
   "(",
   ")",
   "if",
   "(",
   "len",
   "(",
   "cleaned_essay",
   ")",
   ">",
   "MAXIMUM_ESSAY_LENGTH",
   ")",
   ":",
   "cleaned_essay",
   "=",
   "cleaned_essay",
   "[",
   "0",
   ":",
   "MAXIMUM_ESSAY_LENGTH",
   "]",
   "self",
   ".",
   "_text",
   ".",
   "append",
   "(",
   "cleaned_essay",
   ")",
   "# Spell correct text using aspell",
   "cleaned_text",
   ",",
   "spell_errors",
   ",",
   "markup_text",
   "=",
   "util_functions",
   ".",
   "spell_correct",
   "(",
   "self",
   ".",
   "_text",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_text",
   ")",
   "-",
   "1",
   "]",
   ")",
   "self",
   ".",
   "_clean_text",
   ".",
   "append",
   "(",
   "cleaned_text",
   ")",
   "self",
   ".",
   "_spelling_errors",
   ".",
   "append",
   "(",
   "spell_errors",
   ")",
   "self",
   ".",
   "_markup_text",
   ".",
   "append",
   "(",
   "markup_text",
   ")",
   "# Tokenize text",
   "self",
   ".",
   "_tokens",
   ".",
   "append",
   "(",
   "nltk",
   ".",
   "word_tokenize",
   "(",
   "self",
   ".",
   "_clean_text",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_clean_text",
   ")",
   "-",
   "1",
   "]",
   ")",
   ")",
   "# Part of speech tag text",
   "self",
   ".",
   "_pos",
   ".",
   "append",
   "(",
   "nltk",
   ".",
   "pos_tag",
   "(",
   "self",
   ".",
   "_clean_text",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_clean_text",
   ")",
   "-",
   "1",
   "]",
   ".",
   "split",
   "(",
   "\" \"",
   ")",
   ")",
   ")",
   "self",
   ".",
   "_generated",
   ".",
   "append",
   "(",
   "essay_generated",
   ")",
   "# Stem spell corrected text",
   "porter",
   "=",
   "nltk",
   ".",
   "PorterStemmer",
   "(",
   ")",
   "por_toks",
   "=",
   "\" \"",
   ".",
   "join",
   "(",
   "[",
   "porter",
   ".",
   "stem",
   "(",
   "w",
   ")",
   "for",
   "w",
   "in",
   "self",
   ".",
   "_tokens",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_tokens",
   ")",
   "-",
   "1",
   "]",
   "]",
   ")",
   "self",
   ".",
   "_clean_stem_text",
   ".",
   "append",
   "(",
   "por_toks",
   ")",
   "ret",
   "=",
   "\"text: \"",
   "+",
   "self",
   ".",
   "_text",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_text",
   ")",
   "-",
   "1",
   "]",
   "+",
   "\" score: \"",
   "+",
   "str",
   "(",
   "essay_score",
   ")",
   "else",
   ":",
   "raise",
   "util_functions",
   ".",
   "InputError",
   "(",
   "essay_text",
   ",",
   "\"arguments need to be in format \"",
   "\"(text,score). text needs to be string,\"",
   "\" score needs to be int.\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-58",
  "nl_tokens": [
   "Determine",
   "zoom",
   "levels",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_zoom_level",
   "(",
   "zoom",
   ",",
   "process",
   ")",
   ":",
   "if",
   "zoom",
   "is",
   "None",
   ":",
   "return",
   "reversed",
   "(",
   "process",
   ".",
   "config",
   ".",
   "zoom_levels",
   ")",
   "if",
   "isinstance",
   "(",
   "zoom",
   ",",
   "int",
   ")",
   ":",
   "return",
   "[",
   "zoom",
   "]",
   "elif",
   "len",
   "(",
   "zoom",
   ")",
   "==",
   "2",
   ":",
   "return",
   "reversed",
   "(",
   "range",
   "(",
   "<mask>",
   "(",
   "zoom",
   ")",
   ",",
   "max",
   "(",
   "zoom",
   ")",
   "+",
   "1",
   ")",
   ")",
   "elif",
   "len",
   "(",
   "zoom",
   ")",
   "==",
   "1",
   ":",
   "return",
   "zoom"
  ]
 },
 {
  "idx": "maxmin-59",
  "nl_tokens": [
   "This",
   "estimates",
   "M",
   ":",
   "the",
   "number",
   "of",
   "independent",
   "frequencies",
   "in",
   "the",
   "periodogram",
   "."
  ],
  "pl_tokens": [
   "def",
   "independent_freq_count",
   "(",
   "frequencies",
   ",",
   "times",
   ",",
   "conservative",
   "=",
   "True",
   ")",
   ":",
   "M",
   "=",
   "frequencies",
   ".",
   "ptp",
   "(",
   ")",
   "*",
   "times",
   ".",
   "ptp",
   "(",
   ")",
   "if",
   "conservative",
   ":",
   "M_eff",
   "=",
   "<mask>",
   "(",
   "[",
   "times",
   ".",
   "size",
   ",",
   "frequencies",
   ".",
   "size",
   ",",
   "M",
   "]",
   ")",
   "else",
   ":",
   "M_eff",
   "=",
   "M",
   "return",
   "M_eff"
  ]
 },
 {
  "idx": "maxmin-60",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "get_nearest_entry",
   "(",
   "self",
   ",",
   "entry",
   ",",
   "type_measurement",
   ")",
   ":",
   "min_key",
   "=",
   "lambda",
   "cur_entity",
   ":",
   "cur_entity",
   ".",
   "get_distance",
   "(",
   "entry",
   ",",
   "type_measurement",
   ")",
   "return",
   "<mask>",
   "(",
   "self",
   ".",
   "__entries",
   ",",
   "key",
   "=",
   "min_key",
   ")"
  ]
 },
 {
  "idx": "maxmin-61",
  "nl_tokens": [
   "Convert",
   "the",
   "payload",
   "into",
   "an",
   "ASCII",
   "table",
   "suitable",
   "for",
   "printing",
   "on",
   "screen",
   "and",
   "return",
   "it",
   "."
  ],
  "pl_tokens": [
   "def",
   "_format_human",
   "(",
   "self",
   ",",
   "payload",
   ")",
   ":",
   "page",
   "=",
   "None",
   "total_pages",
   "=",
   "None",
   "# What are the columns we will show?",
   "columns",
   "=",
   "[",
   "field",
   ".",
   "name",
   "for",
   "field",
   "in",
   "self",
   ".",
   "resource",
   ".",
   "fields",
   "if",
   "field",
   ".",
   "display",
   "or",
   "settings",
   ".",
   "description_on",
   "and",
   "field",
   ".",
   "name",
   "==",
   "'description'",
   "]",
   "columns",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "'id'",
   ")",
   "# Save a dictionary-by-name of fields for later use",
   "fields_by_name",
   "=",
   "{",
   "}",
   "for",
   "field",
   "in",
   "self",
   ".",
   "resource",
   ".",
   "fields",
   ":",
   "fields_by_name",
   "[",
   "field",
   ".",
   "name",
   "]",
   "=",
   "field",
   "# Sanity check: If there is a \"changed\" key in our payload",
   "# and little else, we print a short message and not a table.",
   "# this specifically applies to deletion",
   "if",
   "'changed'",
   "in",
   "payload",
   "and",
   "'id'",
   "not",
   "in",
   "payload",
   ":",
   "return",
   "'OK. (changed: {0})'",
   ".",
   "format",
   "(",
   "six",
   ".",
   "text_type",
   "(",
   "payload",
   "[",
   "'changed'",
   "]",
   ")",
   ".",
   "lower",
   "(",
   ")",
   ",",
   ")",
   "# Sanity check: If there is no ID and no results, then this",
   "# is unusual output; keep our table formatting, but plow",
   "# over the columns-as-keys stuff above.",
   "# this originally applied to launch/status/update methods",
   "# but it may become deprecated",
   "if",
   "'id'",
   "not",
   "in",
   "payload",
   "and",
   "'results'",
   "not",
   "in",
   "payload",
   ":",
   "columns",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "payload",
   ".",
   "keys",
   "(",
   ")",
   "]",
   "# Get our raw rows into a standard format.",
   "if",
   "'results'",
   "in",
   "payload",
   ":",
   "raw_rows",
   "=",
   "payload",
   "[",
   "'results'",
   "]",
   "if",
   "payload",
   ".",
   "get",
   "(",
   "'count'",
   ",",
   "0",
   ")",
   ">",
   "len",
   "(",
   "payload",
   "[",
   "'results'",
   "]",
   ")",
   ":",
   "prev",
   "=",
   "payload",
   ".",
   "get",
   "(",
   "'previous'",
   ",",
   "0",
   ")",
   "or",
   "0",
   "page",
   "=",
   "prev",
   "+",
   "1",
   "count",
   "=",
   "payload",
   "[",
   "'count'",
   "]",
   "if",
   "payload",
   ".",
   "get",
   "(",
   "'next'",
   ",",
   "None",
   ")",
   ":",
   "total_pages",
   "=",
   "math",
   ".",
   "ceil",
   "(",
   "count",
   "/",
   "len",
   "(",
   "raw_rows",
   ")",
   ")",
   "else",
   ":",
   "total_pages",
   "=",
   "page",
   "else",
   ":",
   "raw_rows",
   "=",
   "[",
   "payload",
   "]",
   "# If we have no rows to display, return this information",
   "# and don't do any further processing.",
   "if",
   "not",
   "raw_rows",
   ":",
   "return",
   "'No records found.'",
   "# Determine the width for each column.",
   "widths",
   "=",
   "{",
   "}",
   "for",
   "col",
   "in",
   "columns",
   ":",
   "widths",
   "[",
   "col",
   "]",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "col",
   ")",
   ",",
   "*",
   "[",
   "len",
   "(",
   "self",
   ".",
   "get_print_value",
   "(",
   "i",
   ",",
   "col",
   ")",
   ")",
   "for",
   "i",
   "in",
   "raw_rows",
   "]",
   ")",
   "fd",
   "=",
   "fields_by_name",
   ".",
   "get",
   "(",
   "col",
   ",",
   "None",
   ")",
   "if",
   "fd",
   "is",
   "not",
   "None",
   "and",
   "fd",
   ".",
   "col_width",
   "is",
   "not",
   "None",
   ":",
   "widths",
   "[",
   "col",
   "]",
   "=",
   "fd",
   ".",
   "col_width",
   "# It's possible that the column widths will exceed our terminal",
   "# width; if so, reduce column widths accordingly.",
   "# TODO: Write this.",
   "# Put together the divider row.",
   "# This is easy and straightforward: it's simply a table divider",
   "# using the widths calculated.",
   "divider_row",
   "=",
   "''",
   "for",
   "col",
   "in",
   "columns",
   ":",
   "divider_row",
   "+=",
   "'='",
   "*",
   "widths",
   "[",
   "col",
   "]",
   "+",
   "' '",
   "divider_row",
   ".",
   "rstrip",
   "(",
   ")",
   "# Put together the header row.",
   "# This is also easy and straightforward; simply center the",
   "# headers (which str.format does for us!).",
   "header_row",
   "=",
   "''",
   "for",
   "col",
   "in",
   "columns",
   ":",
   "header_row",
   "+=",
   "(",
   "'{0:^%d}'",
   "%",
   "widths",
   "[",
   "col",
   "]",
   ")",
   ".",
   "format",
   "(",
   "col",
   ")",
   "+",
   "' '",
   "header_row",
   ".",
   "rstrip",
   "(",
   ")",
   "# Piece together each row of data.",
   "data_rows",
   "=",
   "[",
   "]",
   "for",
   "raw_row",
   "in",
   "raw_rows",
   ":",
   "data_row",
   "=",
   "''",
   "for",
   "col",
   "in",
   "columns",
   ":",
   "template",
   "=",
   "six",
   ".",
   "text_type",
   "(",
   "'{0:%d}'",
   ")",
   "%",
   "widths",
   "[",
   "col",
   "]",
   "value",
   "=",
   "self",
   ".",
   "get_print_value",
   "(",
   "raw_row",
   ",",
   "col",
   ")",
   "# Right-align certain native data types",
   "if",
   "isinstance",
   "(",
   "raw_row",
   ".",
   "get",
   "(",
   "col",
   ",",
   "'N/A'",
   ")",
   ",",
   "(",
   "bool",
   ",",
   "int",
   ")",
   ")",
   ":",
   "template",
   "=",
   "template",
   ".",
   "replace",
   "(",
   "'{0:'",
   ",",
   "'{0:>'",
   ")",
   "# Truncate the cell entry if exceeds manually",
   "# specified column width limit",
   "fd",
   "=",
   "fields_by_name",
   ".",
   "get",
   "(",
   "col",
   ",",
   "None",
   ")",
   "if",
   "fd",
   "is",
   "not",
   "None",
   "and",
   "fd",
   ".",
   "col_width",
   "is",
   "not",
   "None",
   ":",
   "str_value",
   "=",
   "template",
   ".",
   "format",
   "(",
   "value",
   "or",
   "''",
   ")",
   "if",
   "len",
   "(",
   "str_value",
   ")",
   ">",
   "fd",
   ".",
   "col_width",
   ":",
   "value",
   "=",
   "str_value",
   "[",
   ":",
   "fd",
   ".",
   "col_width",
   "]",
   "data_row",
   "+=",
   "template",
   ".",
   "format",
   "(",
   "value",
   "or",
   "''",
   ")",
   "+",
   "' '",
   "data_rows",
   ".",
   "append",
   "(",
   "data_row",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   "# Result the resulting table.",
   "response",
   "=",
   "'\\n'",
   ".",
   "join",
   "(",
   "(",
   "divider_row",
   ",",
   "header_row",
   ",",
   "divider_row",
   ",",
   "'\\n'",
   ".",
   "join",
   "(",
   "data_rows",
   ")",
   ",",
   "divider_row",
   ",",
   ")",
   ")",
   "# Don't print page numbers for 1 page results",
   "if",
   "page",
   "and",
   "total_pages",
   "!=",
   "1",
   ":",
   "response",
   "+=",
   "'(Page %d of %d.)'",
   "%",
   "(",
   "page",
   ",",
   "total_pages",
   ")",
   "if",
   "payload",
   ".",
   "get",
   "(",
   "'changed'",
   ",",
   "False",
   ")",
   ":",
   "response",
   "=",
   "'Resource changed.\\n'",
   "+",
   "response",
   "return",
   "response"
  ]
 },
 {
  "idx": "maxmin-62",
  "nl_tokens": [
   "Takes",
   "in",
   "a",
   "path",
   "(",
   "a",
   "list",
   "of",
   "nodes",
   "in",
   "the",
   "graph",
   ")",
   "and",
   "calculates",
   "a",
   "score"
  ],
  "pl_tokens": [
   "def",
   "rank_path",
   "(",
   "graph",
   ",",
   "path",
   ",",
   "edge_ranking",
   "=",
   "None",
   ")",
   ":",
   "edge_ranking",
   "=",
   "default_edge_ranking",
   "if",
   "edge_ranking",
   "is",
   "None",
   "else",
   "edge_ranking",
   "return",
   "sum",
   "(",
   "<mask>",
   "(",
   "edge_ranking",
   "[",
   "d",
   "[",
   "RELATION",
   "]",
   "]",
   "for",
   "d",
   "in",
   "graph",
   ".",
   "edge",
   "[",
   "u",
   "]",
   "[",
   "v",
   "]",
   ".",
   "values",
   "(",
   ")",
   ")",
   "for",
   "u",
   ",",
   "v",
   "in",
   "pairwise",
   "(",
   "path",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-63",
  "nl_tokens": [
   "Rebuilds",
   "the",
   "graph",
   "around",
   "the",
   "given",
   "node",
   "id",
   "."
  ],
  "pl_tokens": [
   "def",
   "load",
   "(",
   "self",
   ",",
   "id",
   ")",
   ":",
   "self",
   ".",
   "clear",
   "(",
   ")",
   "# Root node.",
   "self",
   ".",
   "add_node",
   "(",
   "id",
   ",",
   "root",
   "=",
   "True",
   ")",
   "# Directly connected nodes have priority.",
   "for",
   "w",
   ",",
   "id2",
   "in",
   "self",
   ".",
   "get_links",
   "(",
   "id",
   ")",
   ":",
   "self",
   ".",
   "add_edge",
   "(",
   "id",
   ",",
   "id2",
   ",",
   "weight",
   "=",
   "w",
   ")",
   "if",
   "len",
   "(",
   "self",
   ")",
   ">",
   "self",
   ".",
   "<mask>",
   ":",
   "break",
   "# Now get all the other nodes in the cluster.",
   "for",
   "w",
   ",",
   "id2",
   ",",
   "links",
   "in",
   "self",
   ".",
   "get_cluster",
   "(",
   "id",
   ")",
   ":",
   "for",
   "id3",
   "in",
   "links",
   ":",
   "self",
   ".",
   "add_edge",
   "(",
   "id3",
   ",",
   "id2",
   ",",
   "weight",
   "=",
   "w",
   ")",
   "self",
   ".",
   "add_edge",
   "(",
   "id",
   ",",
   "id3",
   ",",
   "weight",
   "=",
   "w",
   ")",
   "#if len(links) == 0:",
   "#    self.add_edge(id, id2)",
   "if",
   "len",
   "(",
   "self",
   ")",
   ">",
   "self",
   ".",
   "max",
   ":",
   "break",
   "# Provide a backlink to the previous root.",
   "if",
   "self",
   ".",
   "event",
   ".",
   "clicked",
   ":",
   "g",
   ".",
   "add_node",
   "(",
   "self",
   ".",
   "event",
   ".",
   "clicked",
   ")"
  ]
 },
 {
  "idx": "maxmin-64",
  "nl_tokens": [
   "Remove",
   "labels",
   "from",
   "each",
   "record",
   "with",
   "record",
   "ROWID",
   "in",
   "range",
   "from",
   "start",
   "to",
   "end",
   "noninclusive",
   "of",
   "end",
   ".",
   "Removes",
   "all",
   "records",
   "if",
   "labelFilter",
   "is",
   "None",
   "otherwise",
   "only",
   "removes",
   "the",
   "labels",
   "eqaul",
   "to",
   "labelFilter",
   "."
  ],
  "pl_tokens": [
   "def",
   "removeLabels",
   "(",
   "self",
   ",",
   "start",
   "=",
   "None",
   ",",
   "end",
   "=",
   "None",
   ",",
   "labelFilter",
   "=",
   "None",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for \"",
   "\"'removeLabels'. Model has no saved records.\"",
   ")",
   "startID",
   "=",
   "self",
   ".",
   "saved_states",
   "[",
   "0",
   "]",
   ".",
   "ROWID",
   "clippedStart",
   "=",
   "0",
   "if",
   "start",
   "is",
   "None",
   "else",
   "<mask>",
   "(",
   "0",
   ",",
   "start",
   "-",
   "startID",
   ")",
   "clippedEnd",
   "=",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "if",
   "end",
   "is",
   "None",
   "else",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   ",",
   "end",
   "-",
   "startID",
   ")",
   ")",
   "if",
   "clippedEnd",
   "<=",
   "clippedStart",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for \"",
   "\"'removeLabels'.\"",
   ",",
   "debugInfo",
   "=",
   "{",
   "'requestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "start",
   ",",
   "'endRecordID'",
   ":",
   "end",
   "}",
   ",",
   "'clippedRequestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "clippedStart",
   ",",
   "'endRecordID'",
   ":",
   "clippedEnd",
   "}",
   ",",
   "'validRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "startID",
   ",",
   "'endRecordID'",
   ":",
   "self",
   ".",
   "saved_states",
   "[",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "-",
   "1",
   "]",
   ".",
   "ROWID",
   "}",
   ",",
   "'numRecordsStored'",
   ":",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "}",
   ")",
   "# Remove records within the cache",
   "recordsToDelete",
   "=",
   "[",
   "]",
   "for",
   "state",
   "in",
   "self",
   ".",
   "saved_states",
   "[",
   "clippedStart",
   ":",
   "clippedEnd",
   "]",
   ":",
   "if",
   "labelFilter",
   "is",
   "not",
   "None",
   ":",
   "if",
   "labelFilter",
   "in",
   "state",
   ".",
   "anomalyLabel",
   ":",
   "state",
   ".",
   "anomalyLabel",
   ".",
   "remove",
   "(",
   "labelFilter",
   ")",
   "else",
   ":",
   "state",
   ".",
   "anomalyLabel",
   "=",
   "[",
   "]",
   "state",
   ".",
   "setByUser",
   "=",
   "False",
   "recordsToDelete",
   ".",
   "append",
   "(",
   "state",
   ")",
   "self",
   ".",
   "_deleteRecordsFromKNN",
   "(",
   "recordsToDelete",
   ")",
   "# Remove records not in cache",
   "self",
   ".",
   "_deleteRangeFromKNN",
   "(",
   "start",
   ",",
   "end",
   ")",
   "# Recompute [clippedEnd, ...)",
   "for",
   "state",
   "in",
   "self",
   ".",
   "saved_states",
   "[",
   "clippedEnd",
   ":",
   "]",
   ":",
   "self",
   ".",
   "_updateState",
   "(",
   "state",
   ")",
   "return",
   "{",
   "'status'",
   ":",
   "'success'",
   "}"
  ]
 },
 {
  "idx": "maxmin-65",
  "nl_tokens": [
   "LML",
   "fixed",
   "-",
   "effect",
   "sizes",
   "and",
   "scale",
   "of",
   "the",
   "candidate",
   "set",
   "."
  ],
  "pl_tokens": [
   "def",
   "scan",
   "(",
   "self",
   ",",
   "M",
   ")",
   ":",
   "from",
   "numpy_sugar",
   ".",
   "linalg",
   "import",
   "ddot",
   "from",
   "numpy_sugar",
   "import",
   "is_all_finite",
   "M",
   "=",
   "asarray",
   "(",
   "M",
   ",",
   "float",
   ")",
   "if",
   "M",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "==",
   "0",
   ":",
   "return",
   "{",
   "\"lml\"",
   ":",
   "self",
   ".",
   "null_lml",
   "(",
   ")",
   ",",
   "\"effsizes0\"",
   ":",
   "self",
   ".",
   "null_beta",
   ",",
   "\"effsizes0_se\"",
   ":",
   "self",
   ".",
   "null_beta_se",
   ",",
   "\"effsizes1\"",
   ":",
   "empty",
   "(",
   "(",
   "0",
   ")",
   ")",
   ",",
   "\"effsizes1_se\"",
   ":",
   "empty",
   "(",
   "(",
   "0",
   ")",
   ")",
   ",",
   "\"scale\"",
   ":",
   "self",
   ".",
   "null_scale",
   ",",
   "}",
   "if",
   "not",
   "is_all_finite",
   "(",
   "M",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"M parameter has non-finite elements.\"",
   ")",
   "MTQ",
   "=",
   "[",
   "dot",
   "(",
   "M",
   ".",
   "T",
   ",",
   "Q",
   ")",
   "for",
   "Q",
   "in",
   "self",
   ".",
   "_QS",
   "[",
   "0",
   "]",
   "if",
   "Q",
   ".",
   "size",
   ">",
   "0",
   "]",
   "yTBM",
   "=",
   "[",
   "dot",
   "(",
   "i",
   ",",
   "j",
   ".",
   "T",
   ")",
   "for",
   "(",
   "i",
   ",",
   "j",
   ")",
   "in",
   "zip",
   "(",
   "self",
   ".",
   "_yTQDi",
   ",",
   "MTQ",
   ")",
   "]",
   "XTBM",
   "=",
   "[",
   "dot",
   "(",
   "i",
   ",",
   "j",
   ".",
   "T",
   ")",
   "for",
   "(",
   "i",
   ",",
   "j",
   ")",
   "in",
   "zip",
   "(",
   "self",
   ".",
   "_XTQDi",
   ",",
   "MTQ",
   ")",
   "]",
   "D",
   "=",
   "self",
   ".",
   "_D",
   "MTBM",
   "=",
   "[",
   "ddot",
   "(",
   "i",
   ",",
   "1",
   "/",
   "j",
   ")",
   "@",
   "i",
   ".",
   "T",
   "for",
   "i",
   ",",
   "j",
   "in",
   "zip",
   "(",
   "MTQ",
   ",",
   "D",
   ")",
   "if",
   "j",
   ".",
   "<mask>",
   "(",
   ")",
   ">",
   "0",
   "]",
   "return",
   "self",
   ".",
   "_multicovariate_set",
   "(",
   "yTBM",
   ",",
   "XTBM",
   ",",
   "MTBM",
   ")"
  ]
 },
 {
  "idx": "maxmin-66",
  "nl_tokens": [
   "graph_data_on_the_same_graph",
   ":",
   "put",
   "a",
   "list",
   "of",
   "plots",
   "on",
   "the",
   "same",
   "graph",
   ":",
   "currently",
   "it",
   "supports",
   "CDF"
  ],
  "pl_tokens": [
   "def",
   "graph_data_on_the_same_graph",
   "(",
   "list_of_plots",
   ",",
   "output_directory",
   ",",
   "resource_path",
   ",",
   "output_filename",
   ")",
   ":",
   "maximum_yvalue",
   "=",
   "-",
   "float",
   "(",
   "'inf'",
   ")",
   "minimum_yvalue",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "plots",
   "=",
   "curate_plot_list",
   "(",
   "list_of_plots",
   ")",
   "plot_count",
   "=",
   "len",
   "(",
   "plots",
   ")",
   "if",
   "plot_count",
   "==",
   "0",
   ":",
   "return",
   "False",
   ",",
   "None",
   "graph_height",
   ",",
   "graph_width",
   ",",
   "graph_title",
   "=",
   "get_graph_metadata",
   "(",
   "plots",
   ")",
   "current_plot_count",
   "=",
   "0",
   "fig",
   ",",
   "axis",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   ")",
   "fig",
   ".",
   "set_size_inches",
   "(",
   "graph_width",
   ",",
   "graph_height",
   ")",
   "if",
   "plot_count",
   "<",
   "2",
   ":",
   "fig",
   ".",
   "subplots_adjust",
   "(",
   "left",
   "=",
   "CONSTANTS",
   ".",
   "SUBPLOT_LEFT_OFFSET",
   ",",
   "bottom",
   "=",
   "CONSTANTS",
   ".",
   "SUBPLOT_BOTTOM_OFFSET",
   ",",
   "right",
   "=",
   "CONSTANTS",
   ".",
   "SUBPLOT_RIGHT_OFFSET",
   ")",
   "else",
   ":",
   "fig",
   ".",
   "subplots_adjust",
   "(",
   "left",
   "=",
   "CONSTANTS",
   ".",
   "SUBPLOT_LEFT_OFFSET",
   ",",
   "bottom",
   "=",
   "CONSTANTS",
   ".",
   "SUBPLOT_BOTTOM_OFFSET",
   ",",
   "right",
   "=",
   "CONSTANTS",
   ".",
   "SUBPLOT_RIGHT_OFFSET",
   "-",
   "CONSTANTS",
   ".",
   "Y_AXIS_OFFSET",
   "*",
   "(",
   "plot_count",
   "-",
   "2",
   ")",
   ")",
   "# Generate each plot on the graph",
   "for",
   "plot",
   "in",
   "plots",
   ":",
   "current_plot_count",
   "+=",
   "1",
   "logger",
   ".",
   "info",
   "(",
   "'Processing: '",
   "+",
   "plot",
   ".",
   "input_csv",
   "+",
   "' [ '",
   "+",
   "output_filename",
   "+",
   "' ]'",
   ")",
   "xval",
   ",",
   "yval",
   "=",
   "numpy",
   ".",
   "loadtxt",
   "(",
   "plot",
   ".",
   "input_csv",
   ",",
   "unpack",
   "=",
   "True",
   ",",
   "delimiter",
   "=",
   "','",
   ")",
   "axis",
   ".",
   "plot",
   "(",
   "xval",
   ",",
   "yval",
   ",",
   "linestyle",
   "=",
   "'-'",
   ",",
   "marker",
   "=",
   "None",
   ",",
   "color",
   "=",
   "get_current_color",
   "(",
   "current_plot_count",
   ")",
   ",",
   "label",
   "=",
   "plot",
   ".",
   "plot_label",
   ")",
   "axis",
   ".",
   "legend",
   "(",
   ")",
   "maximum_yvalue",
   "=",
   "<mask>",
   "(",
   "maximum_yvalue",
   ",",
   "numpy",
   ".",
   "amax",
   "(",
   "yval",
   ")",
   "*",
   "(",
   "1.0",
   "+",
   "CONSTANTS",
   ".",
   "ZOOM_FACTOR",
   "*",
   "current_plot_count",
   ")",
   ")",
   "minimum_yvalue",
   "=",
   "min",
   "(",
   "minimum_yvalue",
   ",",
   "numpy",
   ".",
   "amin",
   "(",
   "yval",
   ")",
   "*",
   "(",
   "1.0",
   "-",
   "CONSTANTS",
   ".",
   "ZOOM_FACTOR",
   "*",
   "current_plot_count",
   ")",
   ")",
   "# Set properties of the plots",
   "axis",
   ".",
   "yaxis",
   ".",
   "set_ticks_position",
   "(",
   "'left'",
   ")",
   "axis",
   ".",
   "set_xlabel",
   "(",
   "plots",
   "[",
   "0",
   "]",
   ".",
   "x_label",
   ")",
   "axis",
   ".",
   "set_ylabel",
   "(",
   "plots",
   "[",
   "0",
   "]",
   ".",
   "y_label",
   ",",
   "fontsize",
   "=",
   "CONSTANTS",
   ".",
   "Y_LABEL_FONTSIZE",
   ")",
   "axis",
   ".",
   "set_ylim",
   "(",
   "[",
   "minimum_yvalue",
   ",",
   "maximum_yvalue",
   "]",
   ")",
   "axis",
   ".",
   "yaxis",
   ".",
   "grid",
   "(",
   "True",
   ")",
   "axis",
   ".",
   "xaxis",
   ".",
   "grid",
   "(",
   "True",
   ")",
   "axis",
   ".",
   "set_title",
   "(",
   "graph_title",
   ")",
   "plot_file_name",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "output_directory",
   ",",
   "output_filename",
   "+",
   "\".png\"",
   ")",
   "fig",
   ".",
   "savefig",
   "(",
   "plot_file_name",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "# Create html fragment to be used for creation of the report",
   "with",
   "open",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "output_directory",
   ",",
   "output_filename",
   "+",
   "'.div'",
   ")",
   ",",
   "'w'",
   ")",
   "as",
   "div_file",
   ":",
   "div_file",
   ".",
   "write",
   "(",
   "'<a name=\"'",
   "+",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "plot_file_name",
   ")",
   ".",
   "replace",
   "(",
   "\".png\"",
   ",",
   "\"\"",
   ")",
   ".",
   "replace",
   "(",
   "\".diff\"",
   ",",
   "\"\"",
   ")",
   "+",
   "'\"></a><div class=\"col-md-12\"><img src=\"'",
   "+",
   "resource_path",
   "+",
   "'/'",
   "+",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "plot_file_name",
   ")",
   "+",
   "'\" id=\"'",
   "+",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "plot_file_name",
   ")",
   "+",
   "'\" width=\"100%\" height=\"auto\"/></div><div class=\"col-md-12\"><p align=center>'",
   "+",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "plot_file_name",
   ")",
   "+",
   "'<br/></p></div>'",
   ")",
   "return",
   "True",
   ",",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "output_directory",
   ",",
   "output_filename",
   "+",
   "'.div'",
   ")"
  ]
 },
 {
  "idx": "maxmin-67",
  "nl_tokens": [
   "Perform",
   "a",
   "vector",
   "services",
   "query",
   "using",
   "the",
   "QUERY",
   "API",
   "(",
   "https",
   ":",
   "//",
   "gbdxdocs",
   ".",
   "digitalglobe",
   ".",
   "com",
   "/",
   "docs",
   "/",
   "vs",
   "-",
   "query",
   "-",
   "list",
   "-",
   "vector",
   "-",
   "items",
   "-",
   "returns",
   "-",
   "default",
   "-",
   "fields",
   ")"
  ],
  "pl_tokens": [
   "def",
   "query_iteratively",
   "(",
   "self",
   ",",
   "searchAreaWkt",
   ",",
   "query",
   ",",
   "count",
   "=",
   "100",
   ",",
   "ttl",
   "=",
   "'5m'",
   ",",
   "index",
   "=",
   "default_index",
   ")",
   ":",
   "search_area_polygon",
   "=",
   "from_wkt",
   "(",
   "searchAreaWkt",
   ")",
   "left",
   ",",
   "lower",
   ",",
   "right",
   ",",
   "upper",
   "=",
   "search_area_polygon",
   ".",
   "bounds",
   "params",
   "=",
   "{",
   "\"q\"",
   ":",
   "query",
   ",",
   "\"count\"",
   ":",
   "<mask>",
   "(",
   "count",
   ",",
   "1000",
   ")",
   ",",
   "\"ttl\"",
   ":",
   "ttl",
   ",",
   "\"left\"",
   ":",
   "left",
   ",",
   "\"right\"",
   ":",
   "right",
   ",",
   "\"lower\"",
   ":",
   "lower",
   ",",
   "\"upper\"",
   ":",
   "upper",
   "}",
   "# initialize paging request",
   "url",
   "=",
   "self",
   ".",
   "query_index_page_url",
   "%",
   "index",
   "if",
   "index",
   "else",
   "self",
   ".",
   "query_page_url",
   "r",
   "=",
   "self",
   ".",
   "gbdx_connection",
   ".",
   "get",
   "(",
   "url",
   ",",
   "params",
   "=",
   "params",
   ")",
   "r",
   ".",
   "raise_for_status",
   "(",
   ")",
   "page",
   "=",
   "r",
   ".",
   "json",
   "(",
   ")",
   "paging_id",
   "=",
   "page",
   "[",
   "'next_paging_id'",
   "]",
   "item_count",
   "=",
   "int",
   "(",
   "page",
   "[",
   "'item_count'",
   "]",
   ")",
   "data",
   "=",
   "page",
   "[",
   "'data'",
   "]",
   "num_results",
   "=",
   "0",
   "for",
   "vector",
   "in",
   "data",
   ":",
   "num_results",
   "+=",
   "1",
   "if",
   "num_results",
   ">",
   "count",
   ":",
   "break",
   "yield",
   "vector",
   "if",
   "num_results",
   "==",
   "count",
   ":",
   "return",
   "# get vectors from each page",
   "while",
   "paging_id",
   "and",
   "item_count",
   ">",
   "0",
   "and",
   "num_results",
   "<",
   "count",
   ":",
   "headers",
   "=",
   "{",
   "'Content-Type'",
   ":",
   "'application/x-www-form-urlencoded'",
   "}",
   "data",
   "=",
   "{",
   "\"pagingId\"",
   ":",
   "paging_id",
   ",",
   "\"ttl\"",
   ":",
   "ttl",
   "}",
   "r",
   "=",
   "self",
   ".",
   "gbdx_connection",
   ".",
   "post",
   "(",
   "self",
   ".",
   "page_url",
   ",",
   "headers",
   "=",
   "headers",
   ",",
   "data",
   "=",
   "data",
   ")",
   "r",
   ".",
   "raise_for_status",
   "(",
   ")",
   "page",
   "=",
   "r",
   ".",
   "json",
   "(",
   ")",
   "paging_id",
   "=",
   "page",
   "[",
   "'next_paging_id'",
   "]",
   "item_count",
   "=",
   "int",
   "(",
   "page",
   "[",
   "'item_count'",
   "]",
   ")",
   "data",
   "=",
   "page",
   "[",
   "'data'",
   "]",
   "for",
   "vector",
   "in",
   "data",
   ":",
   "num_results",
   "+=",
   "1",
   "if",
   "num_results",
   ">",
   "count",
   ":",
   "break",
   "yield",
   "vector"
  ]
 },
 {
  "idx": "maxmin-68",
  "nl_tokens": [
   "Compute",
   "the",
   "minimum",
   "and",
   "maximum",
   "to",
   "be",
   "used",
   "for",
   "later",
   "scaling",
   "."
  ],
  "pl_tokens": [
   "def",
   "fit",
   "(",
   "self",
   ",",
   "X",
   ",",
   "y",
   "=",
   "None",
   ")",
   ":",
   "X",
   "=",
   "check_array",
   "(",
   "X",
   ",",
   "copy",
   "=",
   "self",
   ".",
   "copy",
   ",",
   "dtype",
   "=",
   "[",
   "np",
   ".",
   "float64",
   ",",
   "np",
   ".",
   "float32",
   ",",
   "np",
   ".",
   "float16",
   ",",
   "np",
   ".",
   "float128",
   "]",
   ")",
   "feature_range",
   "=",
   "self",
   ".",
   "feature_range",
   "if",
   "feature_range",
   "[",
   "0",
   "]",
   ">=",
   "feature_range",
   "[",
   "1",
   "]",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Minimum of desired feature range must be smaller\"",
   "\" than maximum. Got %s.\"",
   "%",
   "str",
   "(",
   "feature_range",
   ")",
   ")",
   "if",
   "self",
   ".",
   "fit_feature_range",
   "is",
   "not",
   "None",
   ":",
   "fit_feature_range",
   "=",
   "self",
   ".",
   "fit_feature_range",
   "if",
   "fit_feature_range",
   "[",
   "0",
   "]",
   ">=",
   "fit_feature_range",
   "[",
   "1",
   "]",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Minimum of desired (fit) feature range must \"",
   "\"be smaller than maximum. Got %s.\"",
   "%",
   "str",
   "(",
   "feature_range",
   ")",
   ")",
   "if",
   "(",
   "fit_feature_range",
   "[",
   "0",
   "]",
   "<",
   "feature_range",
   "[",
   "0",
   "]",
   "or",
   "fit_feature_range",
   "[",
   "1",
   "]",
   ">",
   "feature_range",
   "[",
   "1",
   "]",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"fit_feature_range must be a subset of \"",
   "\"feature_range. Got %s, fit %s.\"",
   "%",
   "(",
   "str",
   "(",
   "feature_range",
   ")",
   ",",
   "str",
   "(",
   "fit_feature_range",
   ")",
   ")",
   ")",
   "feature_range",
   "=",
   "fit_feature_range",
   "data_min",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "X",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "data_range",
   "=",
   "np",
   ".",
   "max",
   "(",
   "X",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "-",
   "data_min",
   "# Do not scale constant features",
   "data_range",
   "[",
   "data_range",
   "==",
   "0.0",
   "]",
   "=",
   "1.0",
   "self",
   ".",
   "scale_",
   "=",
   "(",
   "feature_range",
   "[",
   "1",
   "]",
   "-",
   "feature_range",
   "[",
   "0",
   "]",
   ")",
   "/",
   "data_range",
   "self",
   ".",
   "min_",
   "=",
   "feature_range",
   "[",
   "0",
   "]",
   "-",
   "data_min",
   "*",
   "self",
   ".",
   "scale_",
   "self",
   ".",
   "data_range",
   "=",
   "data_range",
   "self",
   ".",
   "data_min",
   "=",
   "data_min",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-69",
  "nl_tokens": [
   "Add",
   "a",
   "set",
   "of",
   "data",
   "points",
   "."
  ],
  "pl_tokens": [
   "def",
   "update",
   "(",
   "self",
   ",",
   "points",
   ",",
   "values",
   "=",
   "None",
   ")",
   ":",
   "self",
   ".",
   "values",
   "=",
   "values",
   "or",
   "[",
   "None",
   "]",
   "*",
   "len",
   "(",
   "points",
   ")",
   "if",
   "np",
   "is",
   "None",
   ":",
   "if",
   "self",
   ".",
   "option",
   ".",
   "function",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "'numpy not available, function ignored'",
   ")",
   "self",
   ".",
   "points",
   "=",
   "points",
   "self",
   ".",
   "minimum",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "points",
   ")",
   "self",
   ".",
   "maximum",
   "=",
   "max",
   "(",
   "self",
   ".",
   "points",
   ")",
   "self",
   ".",
   "current",
   "=",
   "self",
   ".",
   "points",
   "[",
   "-",
   "1",
   "]",
   "else",
   ":",
   "self",
   ".",
   "points",
   "=",
   "self",
   ".",
   "apply_function",
   "(",
   "points",
   ")",
   "self",
   ".",
   "minimum",
   "=",
   "np",
   ".",
   "min",
   "(",
   "self",
   ".",
   "points",
   ")",
   "self",
   ".",
   "maximum",
   "=",
   "np",
   ".",
   "max",
   "(",
   "self",
   ".",
   "points",
   ")",
   "self",
   ".",
   "current",
   "=",
   "self",
   ".",
   "points",
   "[",
   "-",
   "1",
   "]",
   "if",
   "self",
   ".",
   "maximum",
   "==",
   "self",
   ".",
   "minimum",
   ":",
   "self",
   ".",
   "extents",
   "=",
   "1",
   "else",
   ":",
   "self",
   ".",
   "extents",
   "=",
   "(",
   "self",
   ".",
   "maximum",
   "-",
   "self",
   ".",
   "minimum",
   ")",
   "self",
   ".",
   "extents",
   "=",
   "(",
   "self",
   ".",
   "maximum",
   "-",
   "self",
   ".",
   "minimum",
   ")"
  ]
 },
 {
  "idx": "maxmin-70",
  "nl_tokens": [
   ":",
   "param",
   "connections",
   ":",
   "(",
   "Object",
   ")",
   "Connections",
   "for",
   "the",
   "TM",
   ".",
   "Gets",
   "mutated",
   "."
  ],
  "pl_tokens": [
   "def",
   "_burstColumn",
   "(",
   "cls",
   ",",
   "connections",
   ",",
   "random",
   ",",
   "lastUsedIterationForSegment",
   ",",
   "column",
   ",",
   "columnMatchingSegments",
   ",",
   "prevActiveCells",
   ",",
   "prevWinnerCells",
   ",",
   "cellsForColumn",
   ",",
   "numActivePotentialSynapsesForSegment",
   ",",
   "iteration",
   ",",
   "maxNewSynapseCount",
   ",",
   "initialPermanence",
   ",",
   "permanenceIncrement",
   ",",
   "permanenceDecrement",
   ",",
   "maxSegmentsPerCell",
   ",",
   "maxSynapsesPerSegment",
   ",",
   "learn",
   ")",
   ":",
   "if",
   "columnMatchingSegments",
   "is",
   "not",
   "None",
   ":",
   "numActive",
   "=",
   "lambda",
   "s",
   ":",
   "numActivePotentialSynapsesForSegment",
   "[",
   "s",
   ".",
   "flatIdx",
   "]",
   "bestMatchingSegment",
   "=",
   "<mask>",
   "(",
   "columnMatchingSegments",
   ",",
   "key",
   "=",
   "numActive",
   ")",
   "winnerCell",
   "=",
   "bestMatchingSegment",
   ".",
   "cell",
   "if",
   "learn",
   ":",
   "cls",
   ".",
   "_adaptSegment",
   "(",
   "connections",
   ",",
   "bestMatchingSegment",
   ",",
   "prevActiveCells",
   ",",
   "permanenceIncrement",
   ",",
   "permanenceDecrement",
   ")",
   "nGrowDesired",
   "=",
   "maxNewSynapseCount",
   "-",
   "numActive",
   "(",
   "bestMatchingSegment",
   ")",
   "if",
   "nGrowDesired",
   ">",
   "0",
   ":",
   "cls",
   ".",
   "_growSynapses",
   "(",
   "connections",
   ",",
   "random",
   ",",
   "bestMatchingSegment",
   ",",
   "nGrowDesired",
   ",",
   "prevWinnerCells",
   ",",
   "initialPermanence",
   ",",
   "maxSynapsesPerSegment",
   ")",
   "else",
   ":",
   "winnerCell",
   "=",
   "cls",
   ".",
   "_leastUsedCell",
   "(",
   "random",
   ",",
   "cellsForColumn",
   ",",
   "connections",
   ")",
   "if",
   "learn",
   ":",
   "nGrowExact",
   "=",
   "min",
   "(",
   "maxNewSynapseCount",
   ",",
   "len",
   "(",
   "prevWinnerCells",
   ")",
   ")",
   "if",
   "nGrowExact",
   ">",
   "0",
   ":",
   "segment",
   "=",
   "cls",
   ".",
   "_createSegment",
   "(",
   "connections",
   ",",
   "lastUsedIterationForSegment",
   ",",
   "winnerCell",
   ",",
   "iteration",
   ",",
   "maxSegmentsPerCell",
   ")",
   "cls",
   ".",
   "_growSynapses",
   "(",
   "connections",
   ",",
   "random",
   ",",
   "segment",
   ",",
   "nGrowExact",
   ",",
   "prevWinnerCells",
   ",",
   "initialPermanence",
   ",",
   "maxSynapsesPerSegment",
   ")",
   "return",
   "cellsForColumn",
   ",",
   "winnerCell"
  ]
 },
 {
  "idx": "maxmin-71",
  "nl_tokens": [
   "Calculate",
   "the",
   "tanimoto",
   "set",
   "similarity",
   "using",
   "the",
   "minimum",
   "size",
   "."
  ],
  "pl_tokens": [
   "def",
   "min_tanimoto_set_similarity",
   "(",
   "x",
   ":",
   "Iterable",
   "[",
   "X",
   "]",
   ",",
   "y",
   ":",
   "Iterable",
   "[",
   "X",
   "]",
   ")",
   "->",
   "float",
   ":",
   "a",
   ",",
   "b",
   "=",
   "set",
   "(",
   "x",
   ")",
   ",",
   "set",
   "(",
   "y",
   ")",
   "if",
   "not",
   "a",
   "or",
   "not",
   "b",
   ":",
   "return",
   "0.0",
   "return",
   "len",
   "(",
   "a",
   "&",
   "b",
   ")",
   "/",
   "<mask>",
   "(",
   "len",
   "(",
   "a",
   ")",
   ",",
   "len",
   "(",
   "b",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-72",
  "nl_tokens": [
   "Compare",
   "the",
   "results",
   "and",
   "return",
   "True",
   "if",
   "success",
   "False",
   "if",
   "failure",
   "Parameters",
   ":",
   "--------------------------------------------------------------------",
   "coincs",
   ":",
   "Which",
   "cells",
   "are",
   "we",
   "comparing?",
   "comparedTo",
   ":",
   "The",
   "set",
   "of",
   "40",
   "cells",
   "we",
   "being",
   "compared",
   "to",
   "(",
   "they",
   "have",
   "no",
   "overlap",
   "with",
   "seen",
   ")",
   "seen",
   ":",
   "Which",
   "of",
   "the",
   "cells",
   "we",
   "are",
   "comparing",
   "to",
   "have",
   "already",
   "been",
   "encountered",
   ".",
   "This",
   "helps",
   "glue",
   "together",
   "the",
   "unique",
   "and",
   "reused",
   "coincs"
  ],
  "pl_tokens": [
   "def",
   "printOverlaps",
   "(",
   "comparedTo",
   ",",
   "coincs",
   ",",
   "seen",
   ")",
   ":",
   "inputOverlap",
   "=",
   "0",
   "cellOverlap",
   "=",
   "0",
   "for",
   "y",
   "in",
   "comparedTo",
   ":",
   "closestInputs",
   "=",
   "[",
   "]",
   "closestCells",
   "=",
   "[",
   "]",
   "if",
   "len",
   "(",
   "seen",
   ")",
   ">",
   "0",
   ":",
   "inputOverlap",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "seen",
   "[",
   "m",
   "]",
   "[",
   "1",
   "]",
   ".",
   "intersection",
   "(",
   "y",
   "[",
   "4",
   "]",
   ")",
   ")",
   "for",
   "m",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "seen",
   ")",
   ")",
   "]",
   ")",
   "cellOverlap",
   "=",
   "max",
   "(",
   "[",
   "len",
   "(",
   "seen",
   "[",
   "m",
   "]",
   "[",
   "0",
   "]",
   ".",
   "intersection",
   "(",
   "y",
   "[",
   "1",
   "]",
   ")",
   ")",
   "for",
   "m",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "seen",
   ")",
   ")",
   "]",
   ")",
   "for",
   "m",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "seen",
   ")",
   ")",
   ":",
   "if",
   "len",
   "(",
   "seen",
   "[",
   "m",
   "]",
   "[",
   "1",
   "]",
   ".",
   "intersection",
   "(",
   "y",
   "[",
   "4",
   "]",
   ")",
   ")",
   "==",
   "inputOverlap",
   ":",
   "closestInputs",
   ".",
   "append",
   "(",
   "seen",
   "[",
   "m",
   "]",
   "[",
   "2",
   "]",
   ")",
   "if",
   "len",
   "(",
   "seen",
   "[",
   "m",
   "]",
   "[",
   "0",
   "]",
   ".",
   "intersection",
   "(",
   "y",
   "[",
   "1",
   "]",
   ")",
   ")",
   "==",
   "cellOverlap",
   ":",
   "closestCells",
   ".",
   "append",
   "(",
   "seen",
   "[",
   "m",
   "]",
   "[",
   "2",
   "]",
   ")",
   "seen",
   ".",
   "append",
   "(",
   "(",
   "y",
   "[",
   "1",
   "]",
   ",",
   "y",
   "[",
   "4",
   "]",
   ",",
   "y",
   "[",
   "0",
   "]",
   ")",
   ")",
   "print",
   "'Pattern'",
   ",",
   "y",
   "[",
   "0",
   "]",
   "+",
   "1",
   ",",
   "':'",
   ",",
   "' '",
   ".",
   "join",
   "(",
   "str",
   "(",
   "len",
   "(",
   "z",
   "[",
   "1",
   "]",
   ".",
   "intersection",
   "(",
   "y",
   "[",
   "1",
   "]",
   ")",
   ")",
   ")",
   ".",
   "rjust",
   "(",
   "2",
   ")",
   "for",
   "z",
   "in",
   "coincs",
   ")",
   ",",
   "'input overlap:'",
   ",",
   "inputOverlap",
   ",",
   "';'",
   ",",
   "len",
   "(",
   "closestInputs",
   ")",
   ",",
   "'closest encodings:'",
   ",",
   "','",
   ".",
   "join",
   "(",
   "str",
   "(",
   "m",
   "+",
   "1",
   ")",
   "for",
   "m",
   "in",
   "closestInputs",
   ")",
   ".",
   "ljust",
   "(",
   "15",
   ")",
   ",",
   "'cell overlap:'",
   ",",
   "cellOverlap",
   ",",
   "';'",
   ",",
   "len",
   "(",
   "closestCells",
   ")",
   ",",
   "'closest set(s):'",
   ",",
   "','",
   ".",
   "join",
   "(",
   "str",
   "(",
   "m",
   "+",
   "1",
   ")",
   "for",
   "m",
   "in",
   "closestCells",
   ")",
   "return",
   "seen"
  ]
 },
 {
  "idx": "maxmin-73",
  "nl_tokens": [
   "Updates",
   "the",
   "minimum",
   "duty",
   "cycles",
   "in",
   "a",
   "global",
   "fashion",
   ".",
   "Sets",
   "the",
   "minimum",
   "duty",
   "cycles",
   "for",
   "the",
   "overlap",
   "all",
   "columns",
   "to",
   "be",
   "a",
   "percent",
   "of",
   "the",
   "maximum",
   "in",
   "the",
   "region",
   "specified",
   "by",
   "minPctOverlapDutyCycle",
   ".",
   "Functionality",
   "it",
   "is",
   "equivalent",
   "to",
   "_updateMinDutyCyclesLocal",
   "but",
   "this",
   "function",
   "exploits",
   "the",
   "globality",
   "of",
   "the",
   "computation",
   "to",
   "perform",
   "it",
   "in",
   "a",
   "straightforward",
   "and",
   "efficient",
   "manner",
   "."
  ],
  "pl_tokens": [
   "def",
   "_updateMinDutyCyclesGlobal",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "_minOverlapDutyCycles",
   ".",
   "fill",
   "(",
   "self",
   ".",
   "_minPctOverlapDutyCycles",
   "*",
   "self",
   ".",
   "_overlapDutyCycles",
   ".",
   "<mask>",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-74",
  "nl_tokens": [
   "Shows",
   "an",
   "image",
   "in",
   "a",
   "window",
   "."
  ],
  "pl_tokens": [
   "def",
   "imshow",
   "(",
   "image",
   ",",
   "backend",
   "=",
   "IMSHOW_BACKEND_DEFAULT",
   ")",
   ":",
   "do_assert",
   "(",
   "backend",
   "in",
   "[",
   "\"matplotlib\"",
   ",",
   "\"cv2\"",
   "]",
   ",",
   "\"Expected backend 'matplotlib' or 'cv2', got %s.\"",
   "%",
   "(",
   "backend",
   ",",
   ")",
   ")",
   "if",
   "backend",
   "==",
   "\"cv2\"",
   ":",
   "image_bgr",
   "=",
   "image",
   "if",
   "image",
   ".",
   "ndim",
   "==",
   "3",
   "and",
   "image",
   ".",
   "shape",
   "[",
   "2",
   "]",
   "in",
   "[",
   "3",
   ",",
   "4",
   "]",
   ":",
   "image_bgr",
   "=",
   "image",
   "[",
   "...",
   ",",
   "0",
   ":",
   "3",
   "]",
   "[",
   "...",
   ",",
   ":",
   ":",
   "-",
   "1",
   "]",
   "win_name",
   "=",
   "\"imgaug-default-window\"",
   "cv2",
   ".",
   "namedWindow",
   "(",
   "win_name",
   ",",
   "cv2",
   ".",
   "WINDOW_NORMAL",
   ")",
   "cv2",
   ".",
   "imshow",
   "(",
   "win_name",
   ",",
   "image_bgr",
   ")",
   "cv2",
   ".",
   "waitKey",
   "(",
   "0",
   ")",
   "cv2",
   ".",
   "destroyWindow",
   "(",
   "win_name",
   ")",
   "else",
   ":",
   "# import only when necessary (faster startup; optional dependency; less fragile -- see issue #225)",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "dpi",
   "=",
   "96",
   "h",
   ",",
   "w",
   "=",
   "image",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "/",
   "dpi",
   ",",
   "image",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "/",
   "dpi",
   "w",
   "=",
   "<mask>",
   "(",
   "w",
   ",",
   "6",
   ")",
   "# if the figure is too narrow, the footer may appear and make the fig suddenly wider (ugly)",
   "fig",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "figsize",
   "=",
   "(",
   "w",
   ",",
   "h",
   ")",
   ",",
   "dpi",
   "=",
   "dpi",
   ")",
   "fig",
   ".",
   "canvas",
   ".",
   "set_window_title",
   "(",
   "\"imgaug.imshow(%s)\"",
   "%",
   "(",
   "image",
   ".",
   "shape",
   ",",
   ")",
   ")",
   "ax",
   ".",
   "imshow",
   "(",
   "image",
   ",",
   "cmap",
   "=",
   "\"gray\"",
   ")",
   "# cmap is only activate for grayscale images",
   "plt",
   ".",
   "show",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-75",
  "nl_tokens": [
   "Make",
   "a",
   "grid",
   "of",
   "images",
   "via",
   "numpy",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_grid",
   "(",
   "tensor",
   ",",
   "nrow",
   "=",
   "8",
   ",",
   "padding",
   "=",
   "2",
   ",",
   "pad_value",
   "=",
   "0",
   ")",
   ":",
   "if",
   "not",
   "(",
   "isinstance",
   "(",
   "tensor",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "or",
   "(",
   "isinstance",
   "(",
   "tensor",
   ",",
   "list",
   ")",
   "and",
   "all",
   "(",
   "isinstance",
   "(",
   "t",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "for",
   "t",
   "in",
   "tensor",
   ")",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "'tensor or list of tensors expected, got {}'",
   ".",
   "format",
   "(",
   "type",
   "(",
   "tensor",
   ")",
   ")",
   ")",
   "# if list of tensors, convert to a 4D mini-batch Tensor",
   "if",
   "isinstance",
   "(",
   "tensor",
   ",",
   "list",
   ")",
   ":",
   "tensor",
   "=",
   "np",
   ".",
   "stack",
   "(",
   "tensor",
   ",",
   "0",
   ")",
   "if",
   "tensor",
   ".",
   "ndim",
   "==",
   "2",
   ":",
   "# single image H x W",
   "tensor",
   "=",
   "tensor",
   ".",
   "reshape",
   "(",
   "(",
   "1",
   ",",
   "tensor",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "tensor",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   "if",
   "tensor",
   ".",
   "ndim",
   "==",
   "3",
   ":",
   "if",
   "tensor",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "==",
   "1",
   ":",
   "# if single-channel, single image, convert to 3-channel",
   "tensor",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "tensor",
   ",",
   "tensor",
   ",",
   "tensor",
   ")",
   ",",
   "0",
   ")",
   "tensor",
   "=",
   "tensor",
   ".",
   "reshape",
   "(",
   "(",
   "1",
   ",",
   "tensor",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "tensor",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "tensor",
   ".",
   "shape",
   "[",
   "2",
   "]",
   ")",
   ")",
   "if",
   "tensor",
   ".",
   "ndim",
   "==",
   "4",
   "and",
   "tensor",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "==",
   "1",
   ":",
   "# single-channel images",
   "tensor",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "tensor",
   ",",
   "tensor",
   ",",
   "tensor",
   ")",
   ",",
   "1",
   ")",
   "if",
   "tensor",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "==",
   "1",
   ":",
   "return",
   "np",
   ".",
   "squeeze",
   "(",
   "tensor",
   ")",
   "# make the mini-batch of images into a grid",
   "nmaps",
   "=",
   "tensor",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "xmaps",
   "=",
   "<mask>",
   "(",
   "nrow",
   ",",
   "nmaps",
   ")",
   "ymaps",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "float",
   "(",
   "nmaps",
   ")",
   "/",
   "xmaps",
   ")",
   ")",
   "height",
   ",",
   "width",
   "=",
   "int",
   "(",
   "tensor",
   ".",
   "shape",
   "[",
   "2",
   "]",
   "+",
   "padding",
   ")",
   ",",
   "int",
   "(",
   "tensor",
   ".",
   "shape",
   "[",
   "3",
   "]",
   "+",
   "padding",
   ")",
   "grid",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "3",
   ",",
   "height",
   "*",
   "ymaps",
   "+",
   "padding",
   ",",
   "width",
   "*",
   "xmaps",
   "+",
   "padding",
   ")",
   ")",
   "*",
   "pad_value",
   "k",
   "=",
   "0",
   "for",
   "y",
   "in",
   "range",
   "(",
   "ymaps",
   ")",
   ":",
   "for",
   "x",
   "in",
   "range",
   "(",
   "xmaps",
   ")",
   ":",
   "if",
   "k",
   ">=",
   "nmaps",
   ":",
   "break",
   "grid",
   "[",
   ":",
   ",",
   "y",
   "*",
   "height",
   "+",
   "padding",
   ":",
   "(",
   "y",
   "+",
   "1",
   ")",
   "*",
   "height",
   ",",
   "x",
   "*",
   "width",
   "+",
   "padding",
   ":",
   "(",
   "x",
   "+",
   "1",
   ")",
   "*",
   "width",
   "]",
   "=",
   "tensor",
   "[",
   "k",
   "]",
   "k",
   "=",
   "k",
   "+",
   "1",
   "return",
   "grid"
  ]
 },
 {
  "idx": "maxmin-76",
  "nl_tokens": [
   "Input",
   "a",
   "graph",
   "and",
   "output",
   "a",
   "DAG",
   "."
  ],
  "pl_tokens": [
   "def",
   "dagify_min_edge",
   "(",
   "g",
   ")",
   ":",
   "while",
   "not",
   "nx",
   ".",
   "is_directed_acyclic_graph",
   "(",
   "g",
   ")",
   ":",
   "cycle",
   "=",
   "next",
   "(",
   "nx",
   ".",
   "simple_cycles",
   "(",
   "g",
   ")",
   ")",
   "scores",
   "=",
   "[",
   "]",
   "edges",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "j",
   "in",
   "zip",
   "(",
   "cycle",
   "[",
   ":",
   "1",
   "]",
   ",",
   "cycle",
   "[",
   ":",
   "1",
   "]",
   ")",
   ":",
   "edges",
   ".",
   "append",
   "(",
   "(",
   "i",
   ",",
   "j",
   ")",
   ")",
   "scores",
   ".",
   "append",
   "(",
   "g",
   "[",
   "i",
   "]",
   "[",
   "j",
   "]",
   "[",
   "'weight'",
   "]",
   ")",
   "i",
   ",",
   "j",
   "=",
   "edges",
   "[",
   "scores",
   ".",
   "index",
   "(",
   "<mask>",
   "(",
   "scores",
   ")",
   ")",
   "]",
   "gc",
   "=",
   "deepcopy",
   "(",
   "g",
   ")",
   "gc",
   ".",
   "remove_edge",
   "(",
   "i",
   ",",
   "j",
   ")",
   "gc",
   ".",
   "add_edge",
   "(",
   "j",
   ",",
   "i",
   ")",
   "if",
   "len",
   "(",
   "list",
   "(",
   "nx",
   ".",
   "simple_cycles",
   "(",
   "gc",
   ")",
   ")",
   ")",
   "<",
   "len",
   "(",
   "list",
   "(",
   "nx",
   ".",
   "simple_cycles",
   "(",
   "g",
   ")",
   ")",
   ")",
   ":",
   "g",
   ".",
   "add_edge",
   "(",
   "j",
   ",",
   "i",
   ",",
   "weight",
   "=",
   "min",
   "(",
   "scores",
   ")",
   ")",
   "g",
   ".",
   "remove_edge",
   "(",
   "i",
   ",",
   "j",
   ")",
   "return",
   "g"
  ]
 },
 {
  "idx": "maxmin-77",
  "nl_tokens": [
   "Extract",
   "the",
   "image",
   "pixels",
   "within",
   "the",
   "polygon",
   "."
  ],
  "pl_tokens": [
   "def",
   "extract_from_image",
   "(",
   "self",
   ",",
   "image",
   ")",
   ":",
   "ia",
   ".",
   "do_assert",
   "(",
   "image",
   ".",
   "ndim",
   "in",
   "[",
   "2",
   ",",
   "3",
   "]",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "exterior",
   ")",
   "<=",
   "2",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Polygon must be made up of at least 3 points to extract its area from an image.\"",
   ")",
   "bb",
   "=",
   "self",
   ".",
   "to_bounding_box",
   "(",
   ")",
   "bb_area",
   "=",
   "bb",
   ".",
   "extract_from_image",
   "(",
   "image",
   ")",
   "if",
   "self",
   ".",
   "is_out_of_image",
   "(",
   "image",
   ",",
   "fully",
   "=",
   "True",
   ",",
   "partly",
   "=",
   "False",
   ")",
   ":",
   "return",
   "bb_area",
   "xx",
   "=",
   "self",
   ".",
   "xx_int",
   "yy",
   "=",
   "self",
   ".",
   "yy_int",
   "xx_mask",
   "=",
   "xx",
   "-",
   "np",
   ".",
   "<mask>",
   "(",
   "xx",
   ")",
   "yy_mask",
   "=",
   "yy",
   "-",
   "np",
   ".",
   "min",
   "(",
   "yy",
   ")",
   "height_mask",
   "=",
   "np",
   ".",
   "max",
   "(",
   "yy_mask",
   ")",
   "width_mask",
   "=",
   "np",
   ".",
   "max",
   "(",
   "xx_mask",
   ")",
   "rr_face",
   ",",
   "cc_face",
   "=",
   "skimage",
   ".",
   "draw",
   ".",
   "polygon",
   "(",
   "yy_mask",
   ",",
   "xx_mask",
   ",",
   "shape",
   "=",
   "(",
   "height_mask",
   ",",
   "width_mask",
   ")",
   ")",
   "mask",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "height_mask",
   ",",
   "width_mask",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "bool",
   ")",
   "mask",
   "[",
   "rr_face",
   ",",
   "cc_face",
   "]",
   "=",
   "True",
   "if",
   "image",
   ".",
   "ndim",
   "==",
   "3",
   ":",
   "mask",
   "=",
   "np",
   ".",
   "tile",
   "(",
   "mask",
   "[",
   ":",
   ",",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   ",",
   "(",
   "1",
   ",",
   "1",
   ",",
   "image",
   ".",
   "shape",
   "[",
   "2",
   "]",
   ")",
   ")",
   "return",
   "bb_area",
   "*",
   "mask"
  ]
 },
 {
  "idx": "maxmin-78",
  "nl_tokens": [
   "Predict",
   "if",
   "a",
   "particular",
   "sample",
   "is",
   "an",
   "outlier",
   "or",
   "not",
   "."
  ],
  "pl_tokens": [
   "def",
   "predict",
   "(",
   "self",
   ",",
   "X",
   ")",
   ":",
   "# Check is fit had been called",
   "check_is_fitted",
   "(",
   "self",
   ",",
   "[",
   "'_x_min'",
   ",",
   "'_x_max'",
   "]",
   ")",
   "# Input validation",
   "X",
   "=",
   "check_array",
   "(",
   "X",
   ")",
   "return",
   "(",
   "(",
   "X",
   "-",
   "self",
   ".",
   "_x_min",
   ")",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ">=",
   "0",
   ")",
   "&",
   "(",
   "(",
   "self",
   ".",
   "_x_max",
   "-",
   "X",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ">=",
   "0",
   ")"
  ]
 },
 {
  "idx": "maxmin-79",
  "nl_tokens": [
   "The",
   "speed",
   "limit",
   "for",
   "a",
   "boid",
   ".",
   "Boids",
   "can",
   "momentarily",
   "go",
   "very",
   "fast",
   "something",
   "that",
   "is",
   "impossible",
   "for",
   "real",
   "animals",
   "."
  ],
  "pl_tokens": [
   "def",
   "limit",
   "(",
   "self",
   ",",
   "<mask>",
   "=",
   "30",
   ")",
   ":",
   "if",
   "abs",
   "(",
   "self",
   ".",
   "vx",
   ")",
   ">",
   "max",
   ":",
   "self",
   ".",
   "vx",
   "=",
   "self",
   ".",
   "vx",
   "/",
   "abs",
   "(",
   "self",
   ".",
   "vx",
   ")",
   "*",
   "max",
   "if",
   "abs",
   "(",
   "self",
   ".",
   "vy",
   ")",
   ">",
   "max",
   ":",
   "self",
   ".",
   "vy",
   "=",
   "self",
   ".",
   "vy",
   "/",
   "abs",
   "(",
   "self",
   ".",
   "vy",
   ")",
   "*",
   "max",
   "if",
   "abs",
   "(",
   "self",
   ".",
   "vz",
   ")",
   ">",
   "max",
   ":",
   "self",
   ".",
   "vz",
   "=",
   "self",
   ".",
   "vz",
   "/",
   "abs",
   "(",
   "self",
   ".",
   "vz",
   ")",
   "*",
   "max"
  ]
 },
 {
  "idx": "maxmin-80",
  "nl_tokens": [
   "If",
   "intervals",
   "intersect",
   "returns",
   "their",
   "union",
   "otherwise",
   "returns",
   "None"
  ],
  "pl_tokens": [
   "def",
   "union",
   "(",
   "self",
   ",",
   "i",
   ")",
   ":",
   "if",
   "self",
   ".",
   "intersects",
   "(",
   "i",
   ")",
   "or",
   "self",
   ".",
   "end",
   "+",
   "1",
   "==",
   "i",
   ".",
   "start",
   "or",
   "i",
   ".",
   "end",
   "+",
   "1",
   "==",
   "self",
   ".",
   "start",
   ":",
   "return",
   "Interval",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "start",
   ",",
   "i",
   ".",
   "start",
   ")",
   ",",
   "max",
   "(",
   "self",
   ".",
   "end",
   ",",
   "i",
   ".",
   "end",
   ")",
   ")",
   "else",
   ":",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-81",
  "nl_tokens": [
   "The",
   "angle",
   "in",
   "degrees",
   "between",
   "two",
   "vectors",
   "."
  ],
  "pl_tokens": [
   "def",
   "angle",
   "(",
   "x1",
   ",",
   "y1",
   ",",
   "x2",
   ",",
   "y2",
   ")",
   ":",
   "sign",
   "=",
   "1.0",
   "usign",
   "=",
   "(",
   "x1",
   "*",
   "y2",
   "-",
   "y1",
   "*",
   "x2",
   ")",
   "if",
   "usign",
   "<",
   "0",
   ":",
   "sign",
   "=",
   "-",
   "1.0",
   "num",
   "=",
   "x1",
   "*",
   "x2",
   "+",
   "y1",
   "*",
   "y2",
   "den",
   "=",
   "hypot",
   "(",
   "x1",
   ",",
   "y1",
   ")",
   "*",
   "hypot",
   "(",
   "x2",
   ",",
   "y2",
   ")",
   "ratio",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "num",
   "/",
   "den",
   ",",
   "-",
   "1.0",
   ")",
   ",",
   "1.0",
   ")",
   "return",
   "sign",
   "*",
   "degrees",
   "(",
   "acos",
   "(",
   "ratio",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-82",
  "nl_tokens": [
   "Run",
   "a",
   "PIF",
   "query",
   "against",
   "Citrination",
   "."
  ],
  "pl_tokens": [
   "def",
   "_execute_search_query",
   "(",
   "self",
   ",",
   "returning_query",
   ",",
   "result_class",
   ")",
   ":",
   "if",
   "returning_query",
   ".",
   "from_index",
   ":",
   "from_index",
   "=",
   "returning_query",
   ".",
   "from_index",
   "else",
   ":",
   "from_index",
   "=",
   "0",
   "if",
   "returning_query",
   ".",
   "size",
   "!=",
   "None",
   ":",
   "size",
   "=",
   "<mask>",
   "(",
   "returning_query",
   ".",
   "size",
   ",",
   "client_config",
   ".",
   "max_query_size",
   ")",
   "else",
   ":",
   "size",
   "=",
   "client_config",
   ".",
   "max_query_size",
   "if",
   "(",
   "size",
   "==",
   "client_config",
   ".",
   "max_query_size",
   "and",
   "size",
   "!=",
   "returning_query",
   ".",
   "size",
   ")",
   ":",
   "self",
   ".",
   "_warn",
   "(",
   "\"Query size greater than max system size - only {} results will be returned\"",
   ".",
   "format",
   "(",
   "size",
   ")",
   ")",
   "time",
   "=",
   "0.0",
   "hits",
   "=",
   "[",
   "]",
   "while",
   "True",
   ":",
   "sub_query",
   "=",
   "deepcopy",
   "(",
   "returning_query",
   ")",
   "sub_query",
   ".",
   "from_index",
   "=",
   "from_index",
   "+",
   "len",
   "(",
   "hits",
   ")",
   "partial_results",
   "=",
   "self",
   ".",
   "_search_internal",
   "(",
   "sub_query",
   ",",
   "result_class",
   ")",
   "total",
   "=",
   "partial_results",
   ".",
   "total_num_hits",
   "time",
   "+=",
   "partial_results",
   ".",
   "took",
   "if",
   "partial_results",
   ".",
   "hits",
   "is",
   "not",
   "None",
   ":",
   "hits",
   ".",
   "extend",
   "(",
   "partial_results",
   ".",
   "hits",
   ")",
   "if",
   "len",
   "(",
   "hits",
   ")",
   ">=",
   "size",
   "or",
   "len",
   "(",
   "hits",
   ")",
   ">=",
   "total",
   "or",
   "sub_query",
   ".",
   "from_index",
   ">=",
   "total",
   ":",
   "break",
   "return",
   "result_class",
   "(",
   "hits",
   "=",
   "hits",
   ",",
   "total_num_hits",
   "=",
   "total",
   ",",
   "took",
   "=",
   "time",
   ")"
  ]
 },
 {
  "idx": "maxmin-83",
  "nl_tokens": [
   "Helper",
   "method",
   "for",
   "displaying",
   "the",
   "answers",
   "so",
   "far",
   "."
  ],
  "pl_tokens": [
   "def",
   "answer_display",
   "(",
   "self",
   ",",
   "s",
   "=",
   "''",
   ")",
   ":",
   "padding",
   "=",
   "len",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "questions",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "key",
   "=",
   "len",
   ")",
   ")",
   "+",
   "5",
   "for",
   "key",
   "in",
   "list",
   "(",
   "self",
   ".",
   "answers",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ":",
   "s",
   "+=",
   "'{:>{}} : {}\\n'",
   ".",
   "format",
   "(",
   "key",
   ",",
   "padding",
   ",",
   "self",
   ".",
   "answers",
   "[",
   "key",
   "]",
   ")",
   "return",
   "s"
  ]
 },
 {
  "idx": "maxmin-84",
  "nl_tokens": [
   "returns",
   "the",
   "classified",
   "labeling",
   "of",
   "record"
  ],
  "pl_tokens": [
   "def",
   "_recomputeRecordFromKNN",
   "(",
   "self",
   ",",
   "record",
   ")",
   ":",
   "inputs",
   "=",
   "{",
   "\"categoryIn\"",
   ":",
   "[",
   "None",
   "]",
   ",",
   "\"bottomUpIn\"",
   ":",
   "self",
   ".",
   "_getStateAnomalyVector",
   "(",
   "record",
   ")",
   ",",
   "}",
   "outputs",
   "=",
   "{",
   "\"categoriesOut\"",
   ":",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   ")",
   ")",
   ",",
   "\"bestPrototypeIndices\"",
   ":",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   ")",
   ")",
   ",",
   "\"categoryProbabilitiesOut\"",
   ":",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   ")",
   ")",
   "}",
   "# Only use points before record to classify and after the wait period.",
   "classifier_indexes",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "getParameter",
   "(",
   "'categoryRecencyList'",
   ")",
   ")",
   "valid_idx",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "(",
   "classifier_indexes",
   ">=",
   "self",
   ".",
   "getParameter",
   "(",
   "'trainRecords'",
   ")",
   ")",
   "&",
   "(",
   "classifier_indexes",
   "<",
   "record",
   ".",
   "ROWID",
   ")",
   ")",
   "[",
   "0",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "if",
   "len",
   "(",
   "valid_idx",
   ")",
   "==",
   "0",
   ":",
   "return",
   "None",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "setParameter",
   "(",
   "'inferenceMode'",
   ",",
   "None",
   ",",
   "True",
   ")",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "setParameter",
   "(",
   "'learningMode'",
   ",",
   "None",
   ",",
   "False",
   ")",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "compute",
   "(",
   "inputs",
   ",",
   "outputs",
   ")",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "setParameter",
   "(",
   "'learningMode'",
   ",",
   "None",
   ",",
   "True",
   ")",
   "classifier_distances",
   "=",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "getLatestDistances",
   "(",
   ")",
   "valid_distances",
   "=",
   "classifier_distances",
   "[",
   "valid_idx",
   "]",
   "if",
   "valid_distances",
   ".",
   "<mask>",
   "(",
   ")",
   "<=",
   "self",
   ".",
   "_classificationMaxDist",
   ":",
   "classifier_indexes_prev",
   "=",
   "classifier_indexes",
   "[",
   "valid_idx",
   "]",
   "rowID",
   "=",
   "classifier_indexes_prev",
   "[",
   "valid_distances",
   ".",
   "argmin",
   "(",
   ")",
   "]",
   "indexID",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "classifier_indexes",
   "==",
   "rowID",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "category",
   "=",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "getCategoryList",
   "(",
   ")",
   "[",
   "indexID",
   "]",
   "return",
   "category",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-85",
  "nl_tokens": [
   "Compute",
   "the",
   "window",
   "data",
   "frequency",
   "response"
  ],
  "pl_tokens": [
   "def",
   "compute_response",
   "(",
   "self",
   ",",
   "*",
   "*",
   "kargs",
   ")",
   ":",
   "from",
   "numpy",
   ".",
   "fft",
   "import",
   "fft",
   ",",
   "fftshift",
   "norm",
   "=",
   "kargs",
   ".",
   "get",
   "(",
   "'norm'",
   ",",
   "self",
   ".",
   "norm",
   ")",
   "# do some padding. Default is max(2048, data.len*2)",
   "NFFT",
   "=",
   "kargs",
   ".",
   "get",
   "(",
   "'NFFT'",
   ",",
   "2048",
   ")",
   "if",
   "NFFT",
   "<",
   "len",
   "(",
   "self",
   ".",
   "data",
   ")",
   ":",
   "NFFT",
   "=",
   "self",
   ".",
   "data",
   ".",
   "size",
   "*",
   "2",
   "# compute the fft modulus",
   "A",
   "=",
   "fft",
   "(",
   "self",
   ".",
   "data",
   ",",
   "NFFT",
   ")",
   "mag",
   "=",
   "abs",
   "(",
   "fftshift",
   "(",
   "A",
   ")",
   ")",
   "# do we want to normalise the data",
   "if",
   "norm",
   "is",
   "True",
   ":",
   "mag",
   "=",
   "mag",
   "/",
   "<mask>",
   "(",
   "mag",
   ")",
   "response",
   "=",
   "20.",
   "*",
   "stools",
   ".",
   "log10",
   "(",
   "mag",
   ")",
   "# factor 20 we are looking at the response",
   "# not the powe",
   "#response = clip(response,mindB,100)",
   "self",
   ".",
   "__response",
   "=",
   "response"
  ]
 },
 {
  "idx": "maxmin-86",
  "nl_tokens": [
   "Get",
   "the",
   "points",
   "in",
   "the",
   "neighborhood",
   "of",
   "a",
   "point",
   "."
  ],
  "pl_tokens": [
   "def",
   "neighborhood",
   "(",
   "centerIndex",
   ",",
   "radius",
   ",",
   "dimensions",
   ")",
   ":",
   "centerPosition",
   "=",
   "coordinatesFromIndex",
   "(",
   "centerIndex",
   ",",
   "dimensions",
   ")",
   "intervals",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "dimension",
   "in",
   "enumerate",
   "(",
   "dimensions",
   ")",
   ":",
   "left",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "centerPosition",
   "[",
   "i",
   "]",
   "-",
   "radius",
   ")",
   "right",
   "=",
   "min",
   "(",
   "dimension",
   "-",
   "1",
   ",",
   "centerPosition",
   "[",
   "i",
   "]",
   "+",
   "radius",
   ")",
   "intervals",
   ".",
   "append",
   "(",
   "xrange",
   "(",
   "left",
   ",",
   "right",
   "+",
   "1",
   ")",
   ")",
   "coords",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "list",
   "(",
   "itertools",
   ".",
   "product",
   "(",
   "*",
   "intervals",
   ")",
   ")",
   ")",
   "return",
   "numpy",
   ".",
   "ravel_multi_index",
   "(",
   "coords",
   ".",
   "T",
   ",",
   "dimensions",
   ")"
  ]
 },
 {
  "idx": "maxmin-87",
  "nl_tokens": [
   "Plots",
   "the",
   "contents",
   "of",
   "real",
   "ndarray",
   "x",
   "as",
   "a",
   "vertical",
   "stacking",
   "of",
   "strips",
   "each",
   "of",
   "length",
   "Nx",
   ".",
   "The",
   "default",
   "figure",
   "size",
   "is",
   "(",
   "6",
   "4",
   ")",
   "inches",
   ".",
   "The",
   "yaxis",
   "tick",
   "labels",
   "are",
   "the",
   "starting",
   "index",
   "of",
   "each",
   "strip",
   ".",
   "The",
   "red",
   "dashed",
   "lines",
   "correspond",
   "to",
   "zero",
   "amplitude",
   "in",
   "each",
   "strip",
   "."
  ],
  "pl_tokens": [
   "def",
   "strips",
   "(",
   "x",
   ",",
   "Nx",
   ",",
   "fig_size",
   "=",
   "(",
   "6",
   ",",
   "4",
   ")",
   ")",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "fig_size",
   ")",
   "#ax = fig.add_subplot(111)",
   "N",
   "=",
   "len",
   "(",
   "x",
   ")",
   "Mx",
   "=",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "N",
   "/",
   "float",
   "(",
   "Nx",
   ")",
   ")",
   ")",
   "x_max",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   ")",
   "for",
   "kk",
   "in",
   "range",
   "(",
   "Mx",
   ")",
   ":",
   "plt",
   ".",
   "plot",
   "(",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0",
   ",",
   "Nx",
   "]",
   ")",
   ",",
   "-",
   "kk",
   "*",
   "Nx",
   "*",
   "np",
   ".",
   "array",
   "(",
   "[",
   "1",
   ",",
   "1",
   "]",
   ")",
   ",",
   "'r-.'",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "x",
   "[",
   "kk",
   "*",
   "Nx",
   ":",
   "(",
   "kk",
   "+",
   "1",
   ")",
   "*",
   "Nx",
   "]",
   "/",
   "x_max",
   "*",
   "0.4",
   "*",
   "Nx",
   "-",
   "kk",
   "*",
   "Nx",
   ",",
   "'b'",
   ")",
   "plt",
   ".",
   "axis",
   "(",
   "[",
   "0",
   ",",
   "Nx",
   ",",
   "-",
   "Nx",
   "*",
   "(",
   "Mx",
   "-",
   "0.5",
   ")",
   ",",
   "Nx",
   "*",
   "0.5",
   "]",
   ")",
   "plt",
   ".",
   "yticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "-",
   "Nx",
   "*",
   "Mx",
   ",",
   "-",
   "Nx",
   ")",
   ",",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "Nx",
   "*",
   "Mx",
   ",",
   "Nx",
   ")",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'Index'",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'Strip Amplitude and Starting Index'",
   ")",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-88",
  "nl_tokens": [
   "Populate",
   "array",
   "with",
   "all",
   "possible",
   "quartets",
   ".",
   "This",
   "allows",
   "us",
   "to",
   "sample",
   "from",
   "the",
   "total",
   "and",
   "also",
   "to",
   "continue",
   "from",
   "a",
   "checkpoint"
  ],
  "pl_tokens": [
   "def",
   "store_all",
   "(",
   "self",
   ")",
   ":",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "self",
   ".",
   "database",
   ".",
   "input",
   ",",
   "'a'",
   ")",
   "as",
   "io5",
   ":",
   "fillsets",
   "=",
   "io5",
   "[",
   "\"quartets\"",
   "]",
   "## generator for all quartet sets",
   "qiter",
   "=",
   "itertools",
   ".",
   "combinations",
   "(",
   "xrange",
   "(",
   "len",
   "(",
   "self",
   ".",
   "samples",
   ")",
   ")",
   ",",
   "4",
   ")",
   "i",
   "=",
   "0",
   "while",
   "i",
   "<",
   "self",
   ".",
   "params",
   ".",
   "nquartets",
   ":",
   "## sample a chunk of the next ordered N set of quartets",
   "dat",
   "=",
   "np",
   ".",
   "array",
   "(",
   "list",
   "(",
   "itertools",
   ".",
   "islice",
   "(",
   "qiter",
   ",",
   "self",
   ".",
   "_chunksize",
   ")",
   ")",
   ")",
   "end",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "params",
   ".",
   "nquartets",
   ",",
   "dat",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "+",
   "i",
   ")",
   "fillsets",
   "[",
   "i",
   ":",
   "end",
   "]",
   "=",
   "dat",
   "[",
   ":",
   "end",
   "-",
   "i",
   "]",
   "i",
   "+=",
   "self",
   ".",
   "_chunksize",
   "## send progress update to stdout on engine",
   "print",
   "(",
   "min",
   "(",
   "i",
   ",",
   "self",
   ".",
   "params",
   ".",
   "nquartets",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-89",
  "nl_tokens": [
   "This",
   "calculates",
   "the",
   "peak",
   "associated",
   "with",
   "the",
   "spectral",
   "window",
   "function",
   "for",
   "times",
   "and",
   "at",
   "the",
   "specified",
   "omega",
   "."
  ],
  "pl_tokens": [
   "def",
   "specwindow_lsp_value",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "omega",
   ")",
   ":",
   "norm_times",
   "=",
   "times",
   "-",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "tau",
   "=",
   "(",
   "(",
   "1.0",
   "/",
   "(",
   "2.0",
   "*",
   "omega",
   ")",
   ")",
   "*",
   "nparctan",
   "(",
   "npsum",
   "(",
   "npsin",
   "(",
   "2.0",
   "*",
   "omega",
   "*",
   "norm_times",
   ")",
   ")",
   "/",
   "npsum",
   "(",
   "npcos",
   "(",
   "2.0",
   "*",
   "omega",
   "*",
   "norm_times",
   ")",
   ")",
   ")",
   ")",
   "lspval_top_cos",
   "=",
   "(",
   "npsum",
   "(",
   "1.0",
   "*",
   "npcos",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   "*",
   "npsum",
   "(",
   "1.0",
   "*",
   "npcos",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   ")",
   "lspval_bot_cos",
   "=",
   "npsum",
   "(",
   "(",
   "npcos",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   "*",
   "(",
   "npcos",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   ")",
   "lspval_top_sin",
   "=",
   "(",
   "npsum",
   "(",
   "1.0",
   "*",
   "npsin",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   "*",
   "npsum",
   "(",
   "1.0",
   "*",
   "npsin",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   ")",
   "lspval_bot_sin",
   "=",
   "npsum",
   "(",
   "(",
   "npsin",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   "*",
   "(",
   "npsin",
   "(",
   "omega",
   "*",
   "(",
   "norm_times",
   "-",
   "tau",
   ")",
   ")",
   ")",
   ")",
   "lspval",
   "=",
   "0.5",
   "*",
   "(",
   "(",
   "lspval_top_cos",
   "/",
   "lspval_bot_cos",
   ")",
   "+",
   "(",
   "lspval_top_sin",
   "/",
   "lspval_bot_sin",
   ")",
   ")",
   "return",
   "lspval"
  ]
 },
 {
  "idx": "maxmin-90",
  "nl_tokens": [
   "This",
   "wraps",
   "Astropy",
   "s",
   "BoxLeastSquares",
   "for",
   "use",
   "with",
   "bls_parallel_pfind",
   "below",
   "."
  ],
  "pl_tokens": [
   "def",
   "_parallel_bls_worker",
   "(",
   "task",
   ")",
   ":",
   "try",
   ":",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   "=",
   "task",
   "[",
   ":",
   "3",
   "]",
   "magsarefluxes",
   "=",
   "task",
   "[",
   "3",
   "]",
   "minfreq",
   ",",
   "nfreq",
   ",",
   "stepsize",
   "=",
   "task",
   "[",
   "4",
   ":",
   "7",
   "]",
   "ndurations",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   "=",
   "task",
   "[",
   "7",
   ":",
   "10",
   "]",
   "blsobjective",
   ",",
   "blsmethod",
   ",",
   "blsoversample",
   "=",
   "task",
   "[",
   "10",
   ":",
   "]",
   "frequencies",
   "=",
   "minfreq",
   "+",
   "nparange",
   "(",
   "nfreq",
   ")",
   "*",
   "stepsize",
   "periods",
   "=",
   "1.0",
   "/",
   "frequencies",
   "# astropy's BLS requires durations in units of time",
   "durations",
   "=",
   "nplinspace",
   "(",
   "mintransitduration",
   "*",
   "periods",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "maxtransitduration",
   "*",
   "periods",
   ".",
   "min",
   "(",
   ")",
   ",",
   "ndurations",
   ")",
   "# set up the correct units for the BLS model",
   "if",
   "magsarefluxes",
   ":",
   "blsmodel",
   "=",
   "BoxLeastSquares",
   "(",
   "times",
   "*",
   "u",
   ".",
   "day",
   ",",
   "mags",
   "*",
   "u",
   ".",
   "dimensionless_unscaled",
   ",",
   "dy",
   "=",
   "errs",
   "*",
   "u",
   ".",
   "dimensionless_unscaled",
   ")",
   "else",
   ":",
   "blsmodel",
   "=",
   "BoxLeastSquares",
   "(",
   "times",
   "*",
   "u",
   ".",
   "day",
   ",",
   "mags",
   "*",
   "u",
   ".",
   "mag",
   ",",
   "dy",
   "=",
   "errs",
   "*",
   "u",
   ".",
   "mag",
   ")",
   "blsresult",
   "=",
   "blsmodel",
   ".",
   "power",
   "(",
   "periods",
   "*",
   "u",
   ".",
   "day",
   ",",
   "durations",
   "*",
   "u",
   ".",
   "day",
   ",",
   "objective",
   "=",
   "blsobjective",
   ",",
   "method",
   "=",
   "blsmethod",
   ",",
   "oversample",
   "=",
   "blsoversample",
   ")",
   "return",
   "{",
   "'blsresult'",
   ":",
   "blsresult",
   ",",
   "'blsmodel'",
   ":",
   "blsmodel",
   ",",
   "'durations'",
   ":",
   "durations",
   ",",
   "'power'",
   ":",
   "nparray",
   "(",
   "blsresult",
   ".",
   "power",
   ")",
   "}",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "LOGEXCEPTION",
   "(",
   "'BLS for frequency chunk: (%.6f, %.6f) failed.'",
   "%",
   "(",
   "frequencies",
   "[",
   "0",
   "]",
   ",",
   "frequencies",
   "[",
   "-",
   "1",
   "]",
   ")",
   ")",
   "return",
   "{",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'blsmodel'",
   ":",
   "None",
   ",",
   "'durations'",
   ":",
   "durations",
   ",",
   "'power'",
   ":",
   "nparray",
   "(",
   "[",
   "npnan",
   "for",
   "x",
   "in",
   "range",
   "(",
   "nfreq",
   ")",
   "]",
   ")",
   ",",
   "}"
  ]
 },
 {
  "idx": "maxmin-91",
  "nl_tokens": [
   "Process",
   "one",
   "input",
   "sample",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute",
   "(",
   "self",
   ",",
   "recordNum",
   ",",
   "patternNZ",
   ",",
   "classification",
   ",",
   "learn",
   ",",
   "infer",
   ")",
   ":",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "1",
   ":",
   "print",
   "\"  learn:\"",
   ",",
   "learn",
   "print",
   "\"  recordNum:\"",
   ",",
   "recordNum",
   "print",
   "\"  patternNZ (%d):\"",
   "%",
   "len",
   "(",
   "patternNZ",
   ")",
   ",",
   "patternNZ",
   "print",
   "\"  classificationIn:\"",
   ",",
   "classification",
   "# ensures that recordNum increases monotonically",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_patternNZHistory",
   ")",
   ">",
   "0",
   ":",
   "if",
   "recordNum",
   "<",
   "self",
   ".",
   "_patternNZHistory",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"the record number has to increase monotonically\"",
   ")",
   "# Store pattern in our history if this is a new record",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_patternNZHistory",
   ")",
   "==",
   "0",
   "or",
   "recordNum",
   ">",
   "self",
   ".",
   "_patternNZHistory",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   ":",
   "self",
   ".",
   "_patternNZHistory",
   ".",
   "append",
   "(",
   "(",
   "recordNum",
   ",",
   "patternNZ",
   ")",
   ")",
   "# To allow multi-class classification, we need to be able to run learning",
   "# without inference being on. So initialize retval outside",
   "# of the inference block.",
   "retval",
   "=",
   "{",
   "}",
   "# Update maxInputIdx and augment weight matrix with zero padding",
   "if",
   "<mask>",
   "(",
   "patternNZ",
   ")",
   ">",
   "self",
   ".",
   "_maxInputIdx",
   ":",
   "newMaxInputIdx",
   "=",
   "max",
   "(",
   "patternNZ",
   ")",
   "for",
   "nSteps",
   "in",
   "self",
   ".",
   "steps",
   ":",
   "self",
   ".",
   "_weightMatrix",
   "[",
   "nSteps",
   "]",
   "=",
   "numpy",
   ".",
   "concatenate",
   "(",
   "(",
   "self",
   ".",
   "_weightMatrix",
   "[",
   "nSteps",
   "]",
   ",",
   "numpy",
   ".",
   "zeros",
   "(",
   "shape",
   "=",
   "(",
   "newMaxInputIdx",
   "-",
   "self",
   ".",
   "_maxInputIdx",
   ",",
   "self",
   ".",
   "_maxBucketIdx",
   "+",
   "1",
   ")",
   ")",
   ")",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "self",
   ".",
   "_maxInputIdx",
   "=",
   "int",
   "(",
   "newMaxInputIdx",
   ")",
   "# Get classification info",
   "if",
   "classification",
   "is",
   "not",
   "None",
   ":",
   "if",
   "type",
   "(",
   "classification",
   "[",
   "\"bucketIdx\"",
   "]",
   ")",
   "is",
   "not",
   "list",
   ":",
   "bucketIdxList",
   "=",
   "[",
   "classification",
   "[",
   "\"bucketIdx\"",
   "]",
   "]",
   "actValueList",
   "=",
   "[",
   "classification",
   "[",
   "\"actValue\"",
   "]",
   "]",
   "numCategory",
   "=",
   "1",
   "else",
   ":",
   "bucketIdxList",
   "=",
   "classification",
   "[",
   "\"bucketIdx\"",
   "]",
   "actValueList",
   "=",
   "classification",
   "[",
   "\"actValue\"",
   "]",
   "numCategory",
   "=",
   "len",
   "(",
   "classification",
   "[",
   "\"bucketIdx\"",
   "]",
   ")",
   "else",
   ":",
   "if",
   "learn",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"classification cannot be None when learn=True\"",
   ")",
   "actValueList",
   "=",
   "None",
   "bucketIdxList",
   "=",
   "None",
   "# ------------------------------------------------------------------------",
   "# Inference:",
   "# For each active bit in the activationPattern, get the classification",
   "# votes",
   "if",
   "infer",
   ":",
   "retval",
   "=",
   "self",
   ".",
   "infer",
   "(",
   "patternNZ",
   ",",
   "actValueList",
   ")",
   "if",
   "learn",
   "and",
   "classification",
   "[",
   "\"bucketIdx\"",
   "]",
   "is",
   "not",
   "None",
   ":",
   "for",
   "categoryI",
   "in",
   "range",
   "(",
   "numCategory",
   ")",
   ":",
   "bucketIdx",
   "=",
   "bucketIdxList",
   "[",
   "categoryI",
   "]",
   "actValue",
   "=",
   "actValueList",
   "[",
   "categoryI",
   "]",
   "# Update maxBucketIndex and augment weight matrix with zero padding",
   "if",
   "bucketIdx",
   ">",
   "self",
   ".",
   "_maxBucketIdx",
   ":",
   "for",
   "nSteps",
   "in",
   "self",
   ".",
   "steps",
   ":",
   "self",
   ".",
   "_weightMatrix",
   "[",
   "nSteps",
   "]",
   "=",
   "numpy",
   ".",
   "concatenate",
   "(",
   "(",
   "self",
   ".",
   "_weightMatrix",
   "[",
   "nSteps",
   "]",
   ",",
   "numpy",
   ".",
   "zeros",
   "(",
   "shape",
   "=",
   "(",
   "self",
   ".",
   "_maxInputIdx",
   "+",
   "1",
   ",",
   "bucketIdx",
   "-",
   "self",
   ".",
   "_maxBucketIdx",
   ")",
   ")",
   ")",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "self",
   ".",
   "_maxBucketIdx",
   "=",
   "int",
   "(",
   "bucketIdx",
   ")",
   "# Update rolling average of actual values if it's a scalar. If it's",
   "# not, it must be a category, in which case each bucket only ever",
   "# sees one category so we don't need a running average.",
   "while",
   "self",
   ".",
   "_maxBucketIdx",
   ">",
   "len",
   "(",
   "self",
   ".",
   "_actualValues",
   ")",
   "-",
   "1",
   ":",
   "self",
   ".",
   "_actualValues",
   ".",
   "append",
   "(",
   "None",
   ")",
   "if",
   "self",
   ".",
   "_actualValues",
   "[",
   "bucketIdx",
   "]",
   "is",
   "None",
   ":",
   "self",
   ".",
   "_actualValues",
   "[",
   "bucketIdx",
   "]",
   "=",
   "actValue",
   "else",
   ":",
   "if",
   "(",
   "isinstance",
   "(",
   "actValue",
   ",",
   "int",
   ")",
   "or",
   "isinstance",
   "(",
   "actValue",
   ",",
   "float",
   ")",
   "or",
   "isinstance",
   "(",
   "actValue",
   ",",
   "long",
   ")",
   ")",
   ":",
   "self",
   ".",
   "_actualValues",
   "[",
   "bucketIdx",
   "]",
   "=",
   "(",
   "(",
   "1.0",
   "-",
   "self",
   ".",
   "actValueAlpha",
   ")",
   "*",
   "self",
   ".",
   "_actualValues",
   "[",
   "bucketIdx",
   "]",
   "+",
   "self",
   ".",
   "actValueAlpha",
   "*",
   "actValue",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_actualValues",
   "[",
   "bucketIdx",
   "]",
   "=",
   "actValue",
   "for",
   "(",
   "learnRecordNum",
   ",",
   "learnPatternNZ",
   ")",
   "in",
   "self",
   ".",
   "_patternNZHistory",
   ":",
   "error",
   "=",
   "self",
   ".",
   "_calculateError",
   "(",
   "recordNum",
   ",",
   "bucketIdxList",
   ")",
   "nSteps",
   "=",
   "recordNum",
   "-",
   "learnRecordNum",
   "if",
   "nSteps",
   "in",
   "self",
   ".",
   "steps",
   ":",
   "for",
   "bit",
   "in",
   "learnPatternNZ",
   ":",
   "self",
   ".",
   "_weightMatrix",
   "[",
   "nSteps",
   "]",
   "[",
   "bit",
   ",",
   ":",
   "]",
   "+=",
   "self",
   ".",
   "alpha",
   "*",
   "error",
   "[",
   "nSteps",
   "]",
   "# ------------------------------------------------------------------------",
   "# Verbose print",
   "if",
   "infer",
   "and",
   "self",
   ".",
   "verbosity",
   ">=",
   "1",
   ":",
   "print",
   "\"  inference: combined bucket likelihoods:\"",
   "print",
   "\"    actual bucket values:\"",
   ",",
   "retval",
   "[",
   "\"actualValues\"",
   "]",
   "for",
   "(",
   "nSteps",
   ",",
   "votes",
   ")",
   "in",
   "retval",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "nSteps",
   "==",
   "\"actualValues\"",
   ":",
   "continue",
   "print",
   "\"    %d steps: \"",
   "%",
   "(",
   "nSteps",
   ")",
   ",",
   "_pFormatArray",
   "(",
   "votes",
   ")",
   "bestBucketIdx",
   "=",
   "votes",
   ".",
   "argmax",
   "(",
   ")",
   "print",
   "(",
   "\"      most likely bucket idx: \"",
   "\"%d, value: %s\"",
   "%",
   "(",
   "bestBucketIdx",
   ",",
   "retval",
   "[",
   "\"actualValues\"",
   "]",
   "[",
   "bestBucketIdx",
   "]",
   ")",
   ")",
   "print",
   "return",
   "retval"
  ]
 },
 {
  "idx": "maxmin-92",
  "nl_tokens": [
   "Creates",
   "a",
   "stylized",
   "graph",
   ".",
   "Sets",
   "edge",
   "and",
   "types",
   "using",
   "pagerank",
   "_",
   "."
  ],
  "pl_tokens": [
   "def",
   "set_types_rank",
   "(",
   "g",
   ",",
   "rank",
   ",",
   "pType2",
   "=",
   "0.1",
   ",",
   "pType3",
   "=",
   "0.1",
   ",",
   "seed",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "g",
   "=",
   "_test_graph",
   "(",
   "g",
   ")",
   "if",
   "isinstance",
   "(",
   "seed",
   ",",
   "numbers",
   ".",
   "Integral",
   ")",
   ":",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "seed",
   ")",
   "tmp",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "np",
   ".",
   "array",
   "(",
   "rank",
   ")",
   ")",
   "nDests",
   "=",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "g",
   ".",
   "number_of_nodes",
   "(",
   ")",
   "*",
   "pType2",
   ")",
   ")",
   "dests",
   "=",
   "np",
   ".",
   "where",
   "(",
   "rank",
   ">=",
   "tmp",
   "[",
   "-",
   "nDests",
   "]",
   ")",
   "[",
   "0",
   "]",
   "if",
   "'pos'",
   "not",
   "in",
   "g",
   ".",
   "vertex_properties",
   "(",
   ")",
   ":",
   "g",
   ".",
   "set_pos",
   "(",
   ")",
   "dest_pos",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "g",
   ".",
   "vp",
   "(",
   "v",
   ",",
   "'pos'",
   ")",
   "for",
   "v",
   "in",
   "dests",
   "]",
   ")",
   "nFCQ",
   "=",
   "int",
   "(",
   "pType3",
   "*",
   "g",
   ".",
   "number_of_nodes",
   "(",
   ")",
   ")",
   "min_g_dist",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "nFCQ",
   ")",
   "*",
   "np",
   ".",
   "infty",
   "ind_g_dist",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "nFCQ",
   ",",
   "int",
   ")",
   "r",
   ",",
   "theta",
   "=",
   "np",
   ".",
   "random",
   ".",
   "random",
   "(",
   "nFCQ",
   ")",
   "/",
   "500.",
   ",",
   "np",
   ".",
   "random",
   ".",
   "random",
   "(",
   "nFCQ",
   ")",
   "*",
   "360.",
   "xy_pos",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "r",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "theta",
   ")",
   ",",
   "r",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "theta",
   ")",
   "]",
   ")",
   ".",
   "transpose",
   "(",
   ")",
   "g_pos",
   "=",
   "xy_pos",
   "+",
   "dest_pos",
   "[",
   "np",
   ".",
   "array",
   "(",
   "np",
   ".",
   "mod",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "nFCQ",
   ")",
   ",",
   "nDests",
   ")",
   ",",
   "int",
   ")",
   "]",
   "for",
   "v",
   "in",
   "g",
   ".",
   "nodes",
   "(",
   ")",
   ":",
   "if",
   "v",
   "not",
   "in",
   "dests",
   ":",
   "tmp",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "_calculate_distance",
   "(",
   "g",
   ".",
   "vp",
   "(",
   "v",
   ",",
   "'pos'",
   ")",
   ",",
   "g_pos",
   "[",
   "k",
   ",",
   ":",
   "]",
   ")",
   "for",
   "k",
   "in",
   "range",
   "(",
   "nFCQ",
   ")",
   "]",
   ")",
   "min_g_dist",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "(",
   "tmp",
   ",",
   "min_g_dist",
   ")",
   ",",
   "0",
   ")",
   "ind_g_dist",
   "[",
   "min_g_dist",
   "==",
   "tmp",
   "]",
   "=",
   "v",
   "ind_g_dist",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "ind_g_dist",
   ")",
   "fcqs",
   "=",
   "set",
   "(",
   "ind_g_dist",
   "[",
   ":",
   "min",
   "(",
   "nFCQ",
   ",",
   "len",
   "(",
   "ind_g_dist",
   ")",
   ")",
   "]",
   ")",
   "dests",
   "=",
   "set",
   "(",
   "dests",
   ")",
   "g",
   ".",
   "new_vertex_property",
   "(",
   "'loop_type'",
   ")",
   "for",
   "v",
   "in",
   "g",
   ".",
   "nodes",
   "(",
   ")",
   ":",
   "if",
   "v",
   "in",
   "dests",
   ":",
   "g",
   ".",
   "set_vp",
   "(",
   "v",
   ",",
   "'loop_type'",
   ",",
   "3",
   ")",
   "if",
   "not",
   "g",
   ".",
   "is_edge",
   "(",
   "(",
   "v",
   ",",
   "v",
   ")",
   ")",
   ":",
   "g",
   ".",
   "add_edge",
   "(",
   "v",
   ",",
   "v",
   ")",
   "elif",
   "v",
   "in",
   "fcqs",
   ":",
   "g",
   ".",
   "set_vp",
   "(",
   "v",
   ",",
   "'loop_type'",
   ",",
   "2",
   ")",
   "if",
   "not",
   "g",
   ".",
   "is_edge",
   "(",
   "(",
   "v",
   ",",
   "v",
   ")",
   ")",
   ":",
   "g",
   ".",
   "add_edge",
   "(",
   "v",
   ",",
   "v",
   ")",
   "g",
   ".",
   "new_edge_property",
   "(",
   "'edge_type'",
   ")",
   "for",
   "e",
   "in",
   "g",
   ".",
   "edges",
   "(",
   ")",
   ":",
   "g",
   ".",
   "set_ep",
   "(",
   "e",
   ",",
   "'edge_type'",
   ",",
   "1",
   ")",
   "for",
   "v",
   "in",
   "g",
   ".",
   "nodes",
   "(",
   ")",
   ":",
   "if",
   "g",
   ".",
   "vp",
   "(",
   "v",
   ",",
   "'loop_type'",
   ")",
   "in",
   "[",
   "2",
   ",",
   "3",
   "]",
   ":",
   "e",
   "=",
   "(",
   "v",
   ",",
   "v",
   ")",
   "if",
   "g",
   ".",
   "vp",
   "(",
   "v",
   ",",
   "'loop_type'",
   ")",
   "==",
   "2",
   ":",
   "g",
   ".",
   "set_ep",
   "(",
   "e",
   ",",
   "'edge_type'",
   ",",
   "2",
   ")",
   "else",
   ":",
   "g",
   ".",
   "set_ep",
   "(",
   "e",
   ",",
   "'edge_type'",
   ",",
   "3",
   ")",
   "return",
   "g"
  ]
 },
 {
  "idx": "maxmin-93",
  "nl_tokens": [
   "Merge",
   "PE",
   "reads",
   ".",
   "Takes",
   "in",
   "a",
   "list",
   "of",
   "unmerged",
   "files",
   "[",
   "r1",
   "r2",
   "]",
   "and",
   "the",
   "filehandle",
   "to",
   "write",
   "merged",
   "data",
   "to",
   "and",
   "it",
   "returns",
   "the",
   "number",
   "of",
   "reads",
   "that",
   "were",
   "merged",
   "(",
   "overlapping",
   ")",
   ".",
   "If",
   "merge",
   "==",
   "0",
   "then",
   "only",
   "concat",
   "pairs",
   "(",
   "nnnn",
   ")",
   "no",
   "merging",
   "in",
   "vsearch",
   "."
  ],
  "pl_tokens": [
   "def",
   "merge_pairs",
   "(",
   "data",
   ",",
   "two_files",
   ",",
   "merged_out",
   ",",
   "revcomp",
   ",",
   "merge",
   ")",
   ":",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"Entering merge_pairs()\"",
   ")",
   "## Return the number of merged pairs",
   "nmerged",
   "=",
   "-",
   "1",
   "## Check input files from inside list-tuple [(r1, r2)]",
   "for",
   "fhandle",
   "in",
   "two_files",
   "[",
   "0",
   "]",
   ":",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "fhandle",
   ")",
   ":",
   "raise",
   "IPyradWarningExit",
   "(",
   "\"\"\"\n    Attempting to merge a file that doesn't exist - {}\"\"\"",
   ".",
   "format",
   "(",
   "fhandle",
   ")",
   ")",
   "## If it already exists, clean up the old merged file",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "merged_out",
   ")",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "merged_out",
   ")",
   "## if merge then catch nonmerged in a separate file",
   "if",
   "merge",
   ":",
   "nonmerged1",
   "=",
   "tempfile",
   ".",
   "NamedTemporaryFile",
   "(",
   "mode",
   "=",
   "'wb'",
   ",",
   "dir",
   "=",
   "data",
   ".",
   "dirs",
   ".",
   "edits",
   ",",
   "suffix",
   "=",
   "\"_nonmerged_R1_.fastq\"",
   ")",
   ".",
   "name",
   "nonmerged2",
   "=",
   "tempfile",
   ".",
   "NamedTemporaryFile",
   "(",
   "mode",
   "=",
   "'wb'",
   ",",
   "dir",
   "=",
   "data",
   ".",
   "dirs",
   ".",
   "edits",
   ",",
   "suffix",
   "=",
   "\"_nonmerged_R2_.fastq\"",
   ")",
   ".",
   "name",
   "## if not merging then the nonmerged reads will come from the normal edits",
   "else",
   ":",
   "nonmerged1",
   "=",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "nonmerged2",
   "=",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "## get the maxn and minlen values",
   "try",
   ":",
   "maxn",
   "=",
   "sum",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "'max_low_qual_bases'",
   "]",
   ")",
   "except",
   "TypeError",
   ":",
   "maxn",
   "=",
   "data",
   ".",
   "paramsdict",
   "[",
   "'max_low_qual_bases'",
   "]",
   "minlen",
   "=",
   "str",
   "(",
   "<mask>",
   "(",
   "32",
   ",",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"filter_min_trim_len\"",
   "]",
   ")",
   ")",
   "## we need to gunzip the files if they are zipped (at least for now)",
   "if",
   "merge",
   "and",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ".",
   "endswith",
   "(",
   "\".gz\"",
   ")",
   ":",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"gunzipping pairs\"",
   ")",
   "tmp1",
   "=",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "\".tmp1\"",
   "tmp2",
   "=",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "\".tmp2\"",
   "out1",
   "=",
   "open",
   "(",
   "tmp1",
   ",",
   "'w'",
   ")",
   "out2",
   "=",
   "open",
   "(",
   "tmp2",
   ",",
   "'w'",
   ")",
   "gun1",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "[",
   "\"gunzip\"",
   ",",
   "\"-c\"",
   ",",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "]",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "out1",
   ",",
   "close_fds",
   "=",
   "True",
   ")",
   "gun2",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "[",
   "\"gunzip\"",
   ",",
   "\"-c\"",
   ",",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "]",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "out2",
   ",",
   "close_fds",
   "=",
   "True",
   ")",
   "_",
   "=",
   "gun1",
   ".",
   "communicate",
   "(",
   ")",
   "_",
   "=",
   "gun2",
   ".",
   "communicate",
   "(",
   ")",
   "out1",
   ".",
   "close",
   "(",
   ")",
   "out2",
   ".",
   "close",
   "(",
   ")",
   "else",
   ":",
   "tmp1",
   "=",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "tmp2",
   "=",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "try",
   ":",
   "## If we are actually mergeing and not just joining then do vsearch",
   "if",
   "merge",
   ":",
   "## create tmp files with high quality scores and with R2 oriented",
   "cmd",
   "=",
   "[",
   "ipyrad",
   ".",
   "bins",
   ".",
   "vsearch",
   ",",
   "\"--fastq_mergepairs\"",
   ",",
   "tmp1",
   ",",
   "\"--reverse\"",
   ",",
   "tmp2",
   ",",
   "\"--fastqout\"",
   ",",
   "merged_out",
   ",",
   "\"--fastqout_notmerged_fwd\"",
   ",",
   "nonmerged1",
   ",",
   "\"--fastqout_notmerged_rev\"",
   ",",
   "nonmerged2",
   ",",
   "\"--fasta_width\"",
   ",",
   "\"0\"",
   ",",
   "\"--fastq_minmergelen\"",
   ",",
   "minlen",
   ",",
   "\"--fastq_maxns\"",
   ",",
   "str",
   "(",
   "maxn",
   ")",
   ",",
   "\"--fastq_minovlen\"",
   ",",
   "\"20\"",
   ",",
   "\"--fastq_maxdiffs\"",
   ",",
   "\"4\"",
   ",",
   "\"--label_suffix\"",
   ",",
   "\"_m1\"",
   ",",
   "\"--fastq_qmax\"",
   ",",
   "\"1000\"",
   ",",
   "\"--threads\"",
   ",",
   "\"2\"",
   ",",
   "\"--fastq_allowmergestagger\"",
   "]",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"merge cmd: %s\"",
   ",",
   "\" \"",
   ".",
   "join",
   "(",
   "cmd",
   ")",
   ")",
   "proc",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "cmd",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "sps",
   ".",
   "PIPE",
   ")",
   "try",
   ":",
   "res",
   "=",
   "proc",
   ".",
   "communicate",
   "(",
   ")",
   "[",
   "0",
   "]",
   "except",
   "KeyboardInterrupt",
   ":",
   "proc",
   ".",
   "kill",
   "(",
   ")",
   "if",
   "proc",
   ".",
   "returncode",
   ":",
   "LOGGER",
   ".",
   "error",
   "(",
   "\"Error: %s %s\"",
   ",",
   "cmd",
   ",",
   "res",
   ")",
   "## remove temp files",
   "rmfiles",
   "=",
   "[",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "\".tmp1\"",
   ",",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "\".tmp2\"",
   ",",
   "nonmerged1",
   ",",
   "nonmerged2",
   "]",
   "for",
   "rmfile",
   "in",
   "rmfiles",
   ":",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "rmfile",
   ")",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "rmfile",
   ")",
   "raise",
   "IPyradWarningExit",
   "(",
   "\"Error merge pairs:\\n %s\\n%s\"",
   ",",
   "cmd",
   ",",
   "res",
   ")",
   "## record how many read pairs were merged",
   "with",
   "open",
   "(",
   "merged_out",
   ",",
   "'r'",
   ")",
   "as",
   "tmpf",
   ":",
   "#nmerged = len(tmpf.readlines()) // 4",
   "nmerged",
   "=",
   "sum",
   "(",
   "1",
   "for",
   "i",
   "in",
   "tmpf",
   ".",
   "readlines",
   "(",
   ")",
   ")",
   "//",
   "4",
   "## Combine the unmerged pairs and append to the merge file",
   "with",
   "open",
   "(",
   "merged_out",
   ",",
   "'ab'",
   ")",
   "as",
   "combout",
   ":",
   "## read in paired end read files 4 lines at a time",
   "if",
   "nonmerged1",
   ".",
   "endswith",
   "(",
   "\".gz\"",
   ")",
   ":",
   "fr1",
   "=",
   "gzip",
   ".",
   "open",
   "(",
   "nonmerged1",
   ",",
   "'rb'",
   ")",
   "else",
   ":",
   "fr1",
   "=",
   "open",
   "(",
   "nonmerged1",
   ",",
   "'rb'",
   ")",
   "quart1",
   "=",
   "itertools",
   ".",
   "izip",
   "(",
   "*",
   "[",
   "iter",
   "(",
   "fr1",
   ")",
   "]",
   "*",
   "4",
   ")",
   "if",
   "nonmerged2",
   ".",
   "endswith",
   "(",
   "\".gz\"",
   ")",
   ":",
   "fr2",
   "=",
   "gzip",
   ".",
   "open",
   "(",
   "nonmerged2",
   ",",
   "'rb'",
   ")",
   "else",
   ":",
   "fr2",
   "=",
   "open",
   "(",
   "nonmerged2",
   ",",
   "'rb'",
   ")",
   "quart2",
   "=",
   "itertools",
   ".",
   "izip",
   "(",
   "*",
   "[",
   "iter",
   "(",
   "fr2",
   ")",
   "]",
   "*",
   "4",
   ")",
   "quarts",
   "=",
   "itertools",
   ".",
   "izip",
   "(",
   "quart1",
   ",",
   "quart2",
   ")",
   "## a list to store until writing",
   "writing",
   "=",
   "[",
   "]",
   "counts",
   "=",
   "0",
   "## iterate until done",
   "while",
   "1",
   ":",
   "try",
   ":",
   "read1s",
   ",",
   "read2s",
   "=",
   "quarts",
   ".",
   "next",
   "(",
   ")",
   "except",
   "StopIteration",
   ":",
   "break",
   "if",
   "revcomp",
   ":",
   "writing",
   ".",
   "append",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "[",
   "read1s",
   "[",
   "0",
   "]",
   ",",
   "read1s",
   "[",
   "1",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "+",
   "\"nnnn\"",
   "+",
   "comp",
   "(",
   "read2s",
   "[",
   "1",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   "+",
   "\"\\n\"",
   ",",
   "read1s",
   "[",
   "2",
   "]",
   ",",
   "read1s",
   "[",
   "3",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "+",
   "\"nnnn\"",
   "+",
   "read2s",
   "[",
   "3",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "+",
   "\"\\n\"",
   ",",
   "]",
   ")",
   ")",
   "else",
   ":",
   "writing",
   ".",
   "append",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "[",
   "read1s",
   "[",
   "0",
   "]",
   ",",
   "read1s",
   "[",
   "1",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "+",
   "\"nnnn\"",
   "+",
   "read2s",
   "[",
   "1",
   "]",
   ",",
   "read1s",
   "[",
   "2",
   "]",
   ",",
   "read1s",
   "[",
   "3",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "+",
   "\"nnnn\"",
   "+",
   "read2s",
   "[",
   "3",
   "]",
   ",",
   "]",
   ")",
   ")",
   "counts",
   "+=",
   "1",
   "if",
   "not",
   "counts",
   "%",
   "10",
   ":",
   "combout",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "writing",
   ")",
   ")",
   "#+\"\\n\")",
   "writing",
   "=",
   "[",
   "]",
   "if",
   "writing",
   ":",
   "combout",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "writing",
   ")",
   ")",
   "## close handles",
   "fr1",
   ".",
   "close",
   "(",
   ")",
   "fr2",
   ".",
   "close",
   "(",
   ")",
   "combout",
   ".",
   "close",
   "(",
   ")",
   "except",
   "Exception",
   "as",
   "inst",
   ":",
   "LOGGER",
   ".",
   "error",
   "(",
   "\"Exception in merge_pairs - {}\"",
   ".",
   "format",
   "(",
   "inst",
   ")",
   ")",
   "raise",
   "## No matter what happens please clean up the temp files.",
   "finally",
   ":",
   "## if merged then delete the nonmerge tmp files",
   "if",
   "merge",
   ":",
   "## remove temp files",
   "rmfiles",
   "=",
   "[",
   "nonmerged1",
   ",",
   "nonmerged2",
   ",",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "\".tmp1\"",
   ",",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "\".tmp2\"",
   "]",
   "for",
   "rmfile",
   "in",
   "rmfiles",
   ":",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "rmfile",
   ")",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "rmfile",
   ")",
   "return",
   "nmerged"
  ]
 },
 {
  "idx": "maxmin-94",
  "nl_tokens": [
   "Return",
   "the",
   "Monge",
   "-",
   "Elkan",
   "similarity",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "sim_func",
   "=",
   "sim_levenshtein",
   ",",
   "symmetric",
   "=",
   "False",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "1.0",
   "q_src",
   "=",
   "sorted",
   "(",
   "QGrams",
   "(",
   "src",
   ")",
   ".",
   "elements",
   "(",
   ")",
   ")",
   "q_tar",
   "=",
   "sorted",
   "(",
   "QGrams",
   "(",
   "tar",
   ")",
   ".",
   "elements",
   "(",
   ")",
   ")",
   "if",
   "not",
   "q_src",
   "or",
   "not",
   "q_tar",
   ":",
   "return",
   "0.0",
   "sum_of_maxes",
   "=",
   "0",
   "for",
   "q_s",
   "in",
   "q_src",
   ":",
   "max_sim",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "for",
   "q_t",
   "in",
   "q_tar",
   ":",
   "max_sim",
   "=",
   "<mask>",
   "(",
   "max_sim",
   ",",
   "sim_func",
   "(",
   "q_s",
   ",",
   "q_t",
   ")",
   ")",
   "sum_of_maxes",
   "+=",
   "max_sim",
   "sim_em",
   "=",
   "sum_of_maxes",
   "/",
   "len",
   "(",
   "q_src",
   ")",
   "if",
   "symmetric",
   ":",
   "sim_em",
   "=",
   "(",
   "sim_em",
   "+",
   "self",
   ".",
   "sim",
   "(",
   "tar",
   ",",
   "src",
   ",",
   "sim_func",
   ",",
   "False",
   ")",
   ")",
   "/",
   "2",
   "return",
   "sim_em"
  ]
 },
 {
  "idx": "maxmin-95",
  "nl_tokens": [
   "Extract",
   "the",
   "image",
   "pixels",
   "covered",
   "by",
   "the",
   "line",
   "string",
   "."
  ],
  "pl_tokens": [
   "def",
   "extract_from_image",
   "(",
   "self",
   ",",
   "image",
   ",",
   "size",
   "=",
   "1",
   ",",
   "pad",
   "=",
   "True",
   ",",
   "pad_max",
   "=",
   "None",
   ",",
   "antialiased",
   "=",
   "True",
   ",",
   "prevent_zero_size",
   "=",
   "True",
   ")",
   ":",
   "from",
   ".",
   "bbs",
   "import",
   "BoundingBox",
   "assert",
   "image",
   ".",
   "ndim",
   "in",
   "[",
   "2",
   ",",
   "3",
   "]",
   ",",
   "(",
   "\"Expected image of shape (H,W,[C]), \"",
   "\"got shape %s.\"",
   "%",
   "(",
   "image",
   ".",
   "shape",
   ",",
   ")",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   "==",
   "0",
   "or",
   "size",
   "<=",
   "0",
   ":",
   "if",
   "prevent_zero_size",
   ":",
   "return",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   "1",
   ")",
   "+",
   "image",
   ".",
   "shape",
   "[",
   "2",
   ":",
   "]",
   ",",
   "dtype",
   "=",
   "image",
   ".",
   "dtype",
   ")",
   "return",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "0",
   ",",
   "0",
   ")",
   "+",
   "image",
   ".",
   "shape",
   "[",
   "2",
   ":",
   "]",
   ",",
   "dtype",
   "=",
   "image",
   ".",
   "dtype",
   ")",
   "xx",
   "=",
   "self",
   ".",
   "xx_int",
   "yy",
   "=",
   "self",
   ".",
   "yy_int",
   "# this would probably work if drawing was subpixel-accurate",
   "# x1 = np.min(self.coords[:, 0]) - (size / 2)",
   "# y1 = np.min(self.coords[:, 1]) - (size / 2)",
   "# x2 = np.max(self.coords[:, 0]) + (size / 2)",
   "# y2 = np.max(self.coords[:, 1]) + (size / 2)",
   "# this works currently with non-subpixel-accurate drawing",
   "sizeh",
   "=",
   "(",
   "size",
   "-",
   "1",
   ")",
   "/",
   "2",
   "x1",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "xx",
   ")",
   "-",
   "sizeh",
   "y1",
   "=",
   "np",
   ".",
   "min",
   "(",
   "yy",
   ")",
   "-",
   "sizeh",
   "x2",
   "=",
   "np",
   ".",
   "max",
   "(",
   "xx",
   ")",
   "+",
   "1",
   "+",
   "sizeh",
   "y2",
   "=",
   "np",
   ".",
   "max",
   "(",
   "yy",
   ")",
   "+",
   "1",
   "+",
   "sizeh",
   "bb",
   "=",
   "BoundingBox",
   "(",
   "x1",
   "=",
   "x1",
   ",",
   "y1",
   "=",
   "y1",
   ",",
   "x2",
   "=",
   "x2",
   ",",
   "y2",
   "=",
   "y2",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   "==",
   "1",
   ":",
   "return",
   "bb",
   ".",
   "extract_from_image",
   "(",
   "image",
   ",",
   "pad",
   "=",
   "pad",
   ",",
   "pad_max",
   "=",
   "pad_max",
   ",",
   "prevent_zero_size",
   "=",
   "prevent_zero_size",
   ")",
   "heatmap",
   "=",
   "self",
   ".",
   "draw_lines_heatmap_array",
   "(",
   "image",
   ".",
   "shape",
   "[",
   "0",
   ":",
   "2",
   "]",
   ",",
   "alpha",
   "=",
   "1.0",
   ",",
   "size",
   "=",
   "size",
   ",",
   "antialiased",
   "=",
   "antialiased",
   ")",
   "if",
   "image",
   ".",
   "ndim",
   "==",
   "3",
   ":",
   "heatmap",
   "=",
   "np",
   ".",
   "atleast_3d",
   "(",
   "heatmap",
   ")",
   "image_masked",
   "=",
   "image",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float32",
   ")",
   "*",
   "heatmap",
   "extract",
   "=",
   "bb",
   ".",
   "extract_from_image",
   "(",
   "image_masked",
   ",",
   "pad",
   "=",
   "pad",
   ",",
   "pad_max",
   "=",
   "pad_max",
   ",",
   "prevent_zero_size",
   "=",
   "prevent_zero_size",
   ")",
   "return",
   "np",
   ".",
   "clip",
   "(",
   "np",
   ".",
   "round",
   "(",
   "extract",
   ")",
   ",",
   "0",
   ",",
   "255",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "uint8",
   ")"
  ]
 },
 {
  "idx": "maxmin-96",
  "nl_tokens": [
   "Horizontally",
   "concatenates",
   "strings",
   "preserving",
   "indentation"
  ],
  "pl_tokens": [
   "def",
   "hzcat",
   "(",
   "args",
   ",",
   "sep",
   "=",
   "''",
   ")",
   ":",
   "import",
   "unicodedata",
   "if",
   "'\\n'",
   "in",
   "sep",
   "or",
   "'\\r'",
   "in",
   "sep",
   ":",
   "raise",
   "ValueError",
   "(",
   "'`sep` cannot contain newline characters'",
   ")",
   "# TODO: ensure unicode data works correctly for python2",
   "args",
   "=",
   "[",
   "unicodedata",
   ".",
   "normalize",
   "(",
   "'NFC'",
   ",",
   "ensure_unicode",
   "(",
   "val",
   ")",
   ")",
   "for",
   "val",
   "in",
   "args",
   "]",
   "arglines",
   "=",
   "[",
   "a",
   ".",
   "split",
   "(",
   "'\\n'",
   ")",
   "for",
   "a",
   "in",
   "args",
   "]",
   "height",
   "=",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "arglines",
   ")",
   ")",
   "# Do vertical padding",
   "arglines",
   "=",
   "[",
   "lines",
   "+",
   "[",
   "''",
   "]",
   "*",
   "(",
   "height",
   "-",
   "len",
   "(",
   "lines",
   ")",
   ")",
   "for",
   "lines",
   "in",
   "arglines",
   "]",
   "# Initialize output",
   "all_lines",
   "=",
   "[",
   "''",
   "for",
   "_",
   "in",
   "range",
   "(",
   "height",
   ")",
   "]",
   "width",
   "=",
   "0",
   "n_args",
   "=",
   "len",
   "(",
   "args",
   ")",
   "for",
   "sx",
   ",",
   "lines",
   "in",
   "enumerate",
   "(",
   "arglines",
   ")",
   ":",
   "# Concatenate the new string",
   "for",
   "lx",
   ",",
   "line",
   "in",
   "enumerate",
   "(",
   "lines",
   ")",
   ":",
   "all_lines",
   "[",
   "lx",
   "]",
   "+=",
   "line",
   "# Find the new maximum horizontal width",
   "width",
   "=",
   "max",
   "(",
   "width",
   ",",
   "max",
   "(",
   "map",
   "(",
   "len",
   ",",
   "all_lines",
   ")",
   ")",
   ")",
   "if",
   "sx",
   "<",
   "n_args",
   "-",
   "1",
   ":",
   "# Horizontal padding on all but last iter",
   "for",
   "lx",
   ",",
   "line",
   "in",
   "list",
   "(",
   "enumerate",
   "(",
   "all_lines",
   ")",
   ")",
   ":",
   "residual",
   "=",
   "width",
   "-",
   "len",
   "(",
   "line",
   ")",
   "all_lines",
   "[",
   "lx",
   "]",
   "=",
   "line",
   "+",
   "(",
   "' '",
   "*",
   "residual",
   ")",
   "+",
   "sep",
   "width",
   "+=",
   "len",
   "(",
   "sep",
   ")",
   "# Clean up trailing whitespace",
   "all_lines",
   "=",
   "[",
   "line",
   ".",
   "rstrip",
   "(",
   "' '",
   ")",
   "for",
   "line",
   "in",
   "all_lines",
   "]",
   "ret",
   "=",
   "'\\n'",
   ".",
   "join",
   "(",
   "all_lines",
   ")",
   "return",
   "ret"
  ]
 },
 {
  "idx": "maxmin-97",
  "nl_tokens": [
   "Creates",
   "a",
   "gradient",
   "layer",
   ".",
   "Creates",
   "a",
   "gradient",
   "layer",
   "that",
   "is",
   "usually",
   "used",
   "together",
   "with",
   "the",
   "mask",
   "()",
   "function",
   ".",
   "All",
   "the",
   "image",
   "functions",
   "work",
   "on",
   "gradients",
   "so",
   "they",
   "can",
   "easily",
   "be",
   "flipped",
   "rotated",
   "scaled",
   "inverted",
   "made",
   "brighter",
   "or",
   "darker",
   "...",
   "Styles",
   "for",
   "gradients",
   "are",
   "LINEAR",
   "RADIAL",
   "and",
   "DIAMOND",
   "."
  ],
  "pl_tokens": [
   "def",
   "gradient",
   "(",
   "self",
   ",",
   "style",
   "=",
   "LINEAR",
   ",",
   "w",
   "=",
   "1.0",
   ",",
   "h",
   "=",
   "1.0",
   ",",
   "name",
   "=",
   "\"\"",
   ")",
   ":",
   "from",
   "types",
   "import",
   "FloatType",
   "w0",
   "=",
   "self",
   ".",
   "w",
   "h0",
   "=",
   "self",
   ".",
   "h",
   "if",
   "type",
   "(",
   "w",
   ")",
   "==",
   "FloatType",
   ":",
   "w",
   "*=",
   "w0",
   "if",
   "type",
   "(",
   "h",
   ")",
   "==",
   "FloatType",
   ":",
   "h",
   "*=",
   "h0",
   "img",
   "=",
   "Image",
   ".",
   "new",
   "(",
   "\"L\"",
   ",",
   "(",
   "int",
   "(",
   "w",
   ")",
   ",",
   "int",
   "(",
   "h",
   ")",
   ")",
   ",",
   "255",
   ")",
   "draw",
   "=",
   "ImageDraw",
   ".",
   "Draw",
   "(",
   "img",
   ")",
   "if",
   "style",
   "==",
   "LINEAR",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "int",
   "(",
   "w",
   ")",
   ")",
   ":",
   "k",
   "=",
   "255.0",
   "*",
   "i",
   "/",
   "w",
   "draw",
   ".",
   "rectangle",
   "(",
   "(",
   "i",
   ",",
   "0",
   ",",
   "i",
   ",",
   "h",
   ")",
   ",",
   "fill",
   "=",
   "int",
   "(",
   "k",
   ")",
   ")",
   "if",
   "style",
   "==",
   "RADIAL",
   ":",
   "r",
   "=",
   "<mask>",
   "(",
   "w",
   ",",
   "h",
   ")",
   "/",
   "2",
   "for",
   "i",
   "in",
   "range",
   "(",
   "int",
   "(",
   "r",
   ")",
   ")",
   ":",
   "k",
   "=",
   "255",
   "-",
   "255.0",
   "*",
   "i",
   "/",
   "r",
   "draw",
   ".",
   "ellipse",
   "(",
   "(",
   "w",
   "/",
   "2",
   "-",
   "r",
   "+",
   "i",
   ",",
   "h",
   "/",
   "2",
   "-",
   "r",
   "+",
   "i",
   ",",
   "w",
   "/",
   "2",
   "+",
   "r",
   "-",
   "i",
   ",",
   "h",
   "/",
   "2",
   "+",
   "r",
   "-",
   "i",
   ")",
   ",",
   "fill",
   "=",
   "int",
   "(",
   "k",
   ")",
   ")",
   "if",
   "style",
   "==",
   "DIAMOND",
   ":",
   "r",
   "=",
   "max",
   "(",
   "w",
   ",",
   "h",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "int",
   "(",
   "r",
   ")",
   ")",
   ":",
   "x",
   "=",
   "int",
   "(",
   "i",
   "*",
   "w",
   "/",
   "r",
   "*",
   "0.5",
   ")",
   "y",
   "=",
   "int",
   "(",
   "i",
   "*",
   "h",
   "/",
   "r",
   "*",
   "0.5",
   ")",
   "k",
   "=",
   "255.0",
   "*",
   "i",
   "/",
   "r",
   "draw",
   ".",
   "rectangle",
   "(",
   "(",
   "x",
   ",",
   "y",
   ",",
   "w",
   "-",
   "x",
   ",",
   "h",
   "-",
   "y",
   ")",
   ",",
   "outline",
   "=",
   "int",
   "(",
   "k",
   ")",
   ")",
   "img",
   "=",
   "img",
   ".",
   "convert",
   "(",
   "\"RGBA\"",
   ")",
   "self",
   ".",
   "layer",
   "(",
   "img",
   ",",
   "0",
   ",",
   "0",
   ",",
   "name",
   "=",
   "\"\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-98",
  "nl_tokens": [
   "This",
   "just",
   "puts",
   "all",
   "of",
   "the",
   "period",
   "-",
   "finders",
   "on",
   "a",
   "single",
   "periodogram",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_combined_periodogram",
   "(",
   "pflist",
   ",",
   "outfile",
   ",",
   "addmethods",
   "=",
   "False",
   ")",
   ":",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "for",
   "pf",
   "in",
   "pflist",
   ":",
   "if",
   "pf",
   "[",
   "'method'",
   "]",
   "==",
   "'pdm'",
   ":",
   "plt",
   ".",
   "plot",
   "(",
   "pf",
   "[",
   "'periods'",
   "]",
   ",",
   "np",
   ".",
   "<mask>",
   "(",
   "pf",
   "[",
   "'lspvals'",
   "]",
   ")",
   "/",
   "pf",
   "[",
   "'lspvals'",
   "]",
   "-",
   "1.0",
   ",",
   "label",
   "=",
   "'%s P=%.5f'",
   "%",
   "(",
   "pf",
   "[",
   "'method'",
   "]",
   ",",
   "pf",
   "[",
   "'bestperiod'",
   "]",
   ")",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "plot",
   "(",
   "pf",
   "[",
   "'periods'",
   "]",
   ",",
   "pf",
   "[",
   "'lspvals'",
   "]",
   "/",
   "np",
   ".",
   "max",
   "(",
   "pf",
   "[",
   "'lspvals'",
   "]",
   ")",
   ",",
   "label",
   "=",
   "'%s P=%.5f'",
   "%",
   "(",
   "pf",
   "[",
   "'method'",
   "]",
   ",",
   "pf",
   "[",
   "'bestperiod'",
   "]",
   ")",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'period [days]'",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'normalized periodogram power'",
   ")",
   "plt",
   ".",
   "xscale",
   "(",
   "'log'",
   ")",
   "plt",
   ".",
   "legend",
   "(",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "savefig",
   "(",
   "outfile",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "'all'",
   ")",
   "return",
   "outfile"
  ]
 },
 {
  "idx": "maxmin-99",
  "nl_tokens": [
   "This",
   "method",
   "handles",
   "the",
   "incoming",
   "digital",
   "message",
   ".",
   "It",
   "stores",
   "the",
   "data",
   "values",
   "in",
   "the",
   "digital",
   "response",
   "table",
   ".",
   "Data",
   "is",
   "stored",
   "for",
   "all",
   "8",
   "bits",
   "of",
   "a",
   "digital",
   "port"
  ],
  "pl_tokens": [
   "def",
   "digital_message",
   "(",
   "self",
   ",",
   "data",
   ")",
   ":",
   "port",
   "=",
   "data",
   "[",
   "0",
   "]",
   "port_data",
   "=",
   "(",
   "data",
   "[",
   "self",
   ".",
   "MSB",
   "]",
   "<<",
   "7",
   ")",
   "+",
   "data",
   "[",
   "self",
   ".",
   "LSB",
   "]",
   "# set all the pins for this reporting port",
   "# get the first pin number for this report",
   "pin",
   "=",
   "port",
   "*",
   "8",
   "for",
   "pin",
   "in",
   "range",
   "(",
   "pin",
   ",",
   "<mask>",
   "(",
   "pin",
   "+",
   "8",
   ",",
   "self",
   ".",
   "total_pins_discovered",
   ")",
   ")",
   ":",
   "# shift through all the bit positions and set the digital response table",
   "with",
   "self",
   ".",
   "pymata",
   ".",
   "data_lock",
   ":",
   "# look at the previously stored value for this pin",
   "prev_data",
   "=",
   "self",
   ".",
   "digital_response_table",
   "[",
   "pin",
   "]",
   "[",
   "self",
   ".",
   "RESPONSE_TABLE_PIN_DATA_VALUE",
   "]",
   "# get the current value",
   "self",
   ".",
   "digital_response_table",
   "[",
   "pin",
   "]",
   "[",
   "self",
   ".",
   "RESPONSE_TABLE_PIN_DATA_VALUE",
   "]",
   "=",
   "port_data",
   "&",
   "0x01",
   "# if the values differ and callback is enabled for the pin, then send out the callback",
   "if",
   "prev_data",
   "!=",
   "port_data",
   "&",
   "0x01",
   ":",
   "callback",
   "=",
   "self",
   ".",
   "digital_response_table",
   "[",
   "pin",
   "]",
   "[",
   "self",
   ".",
   "RESPONSE_TABLE_CALLBACK",
   "]",
   "if",
   "callback",
   ":",
   "callback",
   "(",
   "[",
   "self",
   ".",
   "pymata",
   ".",
   "DIGITAL",
   ",",
   "pin",
   ",",
   "self",
   ".",
   "digital_response_table",
   "[",
   "pin",
   "]",
   "[",
   "self",
   ".",
   "RESPONSE_TABLE_PIN_DATA_VALUE",
   "]",
   "]",
   ")",
   "# determine if the latch data table needs to be updated for each pin",
   "latching_entry",
   "=",
   "self",
   ".",
   "digital_latch_table",
   "[",
   "pin",
   "]",
   "if",
   "latching_entry",
   "[",
   "self",
   ".",
   "LATCH_STATE",
   "]",
   "==",
   "self",
   ".",
   "LATCH_ARMED",
   ":",
   "if",
   "latching_entry",
   "[",
   "self",
   ".",
   "LATCHED_THRESHOLD_TYPE",
   "]",
   "==",
   "self",
   ".",
   "DIGITAL_LATCH_LOW",
   ":",
   "if",
   "(",
   "port_data",
   "&",
   "0x01",
   ")",
   "==",
   "0",
   ":",
   "if",
   "latching_entry",
   "[",
   "self",
   ".",
   "DIGITAL_LATCH_CALLBACK",
   "]",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "digital_latch_table",
   "[",
   "pin",
   "]",
   "=",
   "[",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "None",
   "]",
   "latching_entry",
   "[",
   "self",
   ".",
   "DIGITAL_LATCH_CALLBACK",
   "]",
   "(",
   "[",
   "self",
   ".",
   "pymata",
   ".",
   "OUTPUT",
   "|",
   "self",
   ".",
   "pymata",
   ".",
   "LATCH_MODE",
   ",",
   "pin",
   ",",
   "0",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "]",
   ")",
   "else",
   ":",
   "updated_latch_entry",
   "=",
   "latching_entry",
   "updated_latch_entry",
   "[",
   "self",
   ".",
   "LATCH_STATE",
   "]",
   "=",
   "self",
   ".",
   "LATCH_LATCHED",
   "updated_latch_entry",
   "[",
   "self",
   ".",
   "DIGITAL_LATCHED_DATA",
   "]",
   "=",
   "self",
   ".",
   "DIGITAL_LATCH_LOW",
   "# time stamp it",
   "updated_latch_entry",
   "[",
   "self",
   ".",
   "DIGITAL_TIME_STAMP",
   "]",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "else",
   ":",
   "pass",
   "elif",
   "latching_entry",
   "[",
   "self",
   ".",
   "LATCHED_THRESHOLD_TYPE",
   "]",
   "==",
   "self",
   ".",
   "DIGITAL_LATCH_HIGH",
   ":",
   "if",
   "port_data",
   "&",
   "0x01",
   ":",
   "if",
   "latching_entry",
   "[",
   "self",
   ".",
   "DIGITAL_LATCH_CALLBACK",
   "]",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "digital_latch_table",
   "[",
   "pin",
   "]",
   "=",
   "[",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "None",
   "]",
   "latching_entry",
   "[",
   "self",
   ".",
   "DIGITAL_LATCH_CALLBACK",
   "]",
   "(",
   "[",
   "self",
   ".",
   "pymata",
   ".",
   "OUTPUT",
   "|",
   "self",
   ".",
   "pymata",
   ".",
   "LATCH_MODE",
   ",",
   "pin",
   ",",
   "1",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "]",
   ")",
   "else",
   ":",
   "updated_latch_entry",
   "=",
   "latching_entry",
   "updated_latch_entry",
   "[",
   "self",
   ".",
   "LATCH_STATE",
   "]",
   "=",
   "self",
   ".",
   "LATCH_LATCHED",
   "updated_latch_entry",
   "[",
   "self",
   ".",
   "DIGITAL_LATCHED_DATA",
   "]",
   "=",
   "self",
   ".",
   "DIGITAL_LATCH_HIGH",
   "# time stamp it",
   "updated_latch_entry",
   "[",
   "self",
   ".",
   "DIGITAL_TIME_STAMP",
   "]",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "else",
   ":",
   "pass",
   "else",
   ":",
   "pass",
   "# get the next data bit",
   "port_data",
   ">>=",
   "1"
  ]
 },
 {
  "idx": "maxmin-100",
  "nl_tokens": [
   "Run",
   "one",
   "iteration",
   "of",
   "TMRegion",
   "s",
   "compute"
  ],
  "pl_tokens": [
   "def",
   "_compute",
   "(",
   "self",
   ",",
   "inputs",
   ",",
   "outputs",
   ")",
   ":",
   "#if self.topDownMode and (not 'topDownIn' in inputs):",
   "# raise RuntimeError(\"The input topDownIn must be linked in if \"",
   "#                    \"topDownMode is True\")",
   "if",
   "self",
   ".",
   "_tfdr",
   "is",
   "None",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"TM has not been initialized\"",
   ")",
   "# Conditional compute break",
   "self",
   ".",
   "_conditionalBreak",
   "(",
   ")",
   "self",
   ".",
   "_iterations",
   "+=",
   "1",
   "# Get our inputs as numpy array",
   "buInputVector",
   "=",
   "inputs",
   "[",
   "'bottomUpIn'",
   "]",
   "# Handle reset signal",
   "resetSignal",
   "=",
   "False",
   "if",
   "'resetIn'",
   "in",
   "inputs",
   ":",
   "assert",
   "len",
   "(",
   "inputs",
   "[",
   "'resetIn'",
   "]",
   ")",
   "==",
   "1",
   "if",
   "inputs",
   "[",
   "'resetIn'",
   "]",
   "[",
   "0",
   "]",
   "!=",
   "0",
   ":",
   "self",
   ".",
   "_tfdr",
   ".",
   "reset",
   "(",
   ")",
   "self",
   ".",
   "_sequencePos",
   "=",
   "0",
   "# Position within the current sequence",
   "if",
   "self",
   ".",
   "computePredictedActiveCellIndices",
   ":",
   "prevPredictedState",
   "=",
   "self",
   ".",
   "_tfdr",
   ".",
   "getPredictedState",
   "(",
   ")",
   ".",
   "reshape",
   "(",
   "-",
   "1",
   ")",
   ".",
   "astype",
   "(",
   "'float32'",
   ")",
   "if",
   "self",
   ".",
   "anomalyMode",
   ":",
   "prevPredictedColumns",
   "=",
   "self",
   ".",
   "_tfdr",
   ".",
   "topDownCompute",
   "(",
   ")",
   ".",
   "copy",
   "(",
   ")",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   "# Perform inference and/or learning",
   "tpOutput",
   "=",
   "self",
   ".",
   "_tfdr",
   ".",
   "compute",
   "(",
   "buInputVector",
   ",",
   "self",
   ".",
   "learningMode",
   ",",
   "self",
   ".",
   "inferenceMode",
   ")",
   "self",
   ".",
   "_sequencePos",
   "+=",
   "1",
   "# OR'ing together the cells in each column?",
   "if",
   "self",
   ".",
   "orColumnOutputs",
   ":",
   "tpOutput",
   "=",
   "tpOutput",
   ".",
   "reshape",
   "(",
   "self",
   ".",
   "columnCount",
   ",",
   "self",
   ".",
   "cellsPerColumn",
   ")",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "# Direct logging of non-zero TM outputs",
   "if",
   "self",
   ".",
   "_fpLogTPOutput",
   ":",
   "output",
   "=",
   "tpOutput",
   ".",
   "reshape",
   "(",
   "-",
   "1",
   ")",
   "outputNZ",
   "=",
   "tpOutput",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   "outStr",
   "=",
   "\" \"",
   ".",
   "join",
   "(",
   "[",
   "\"%d\"",
   "%",
   "int",
   "(",
   "token",
   ")",
   "for",
   "token",
   "in",
   "outputNZ",
   "]",
   ")",
   "print",
   ">>",
   "self",
   ".",
   "_fpLogTPOutput",
   ",",
   "output",
   ".",
   "size",
   ",",
   "outStr",
   "# Write the bottom up out to our node outputs",
   "outputs",
   "[",
   "'bottomUpOut'",
   "]",
   "[",
   ":",
   "]",
   "=",
   "tpOutput",
   ".",
   "flat",
   "if",
   "self",
   ".",
   "topDownMode",
   ":",
   "# Top-down compute",
   "outputs",
   "[",
   "'topDownOut'",
   "]",
   "[",
   ":",
   "]",
   "=",
   "self",
   ".",
   "_tfdr",
   ".",
   "topDownCompute",
   "(",
   ")",
   ".",
   "copy",
   "(",
   ")",
   "# Set output for use with anomaly classification region if in anomalyMode",
   "if",
   "self",
   ".",
   "anomalyMode",
   ":",
   "activeLearnCells",
   "=",
   "self",
   ".",
   "_tfdr",
   ".",
   "getLearnActiveStateT",
   "(",
   ")",
   "size",
   "=",
   "activeLearnCells",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "*",
   "activeLearnCells",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "outputs",
   "[",
   "'lrnActiveStateT'",
   "]",
   "[",
   ":",
   "]",
   "=",
   "activeLearnCells",
   ".",
   "reshape",
   "(",
   "size",
   ")",
   "activeColumns",
   "=",
   "buInputVector",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   "outputs",
   "[",
   "'anomalyScore'",
   "]",
   "[",
   ":",
   "]",
   "=",
   "anomaly",
   ".",
   "computeRawAnomalyScore",
   "(",
   "activeColumns",
   ",",
   "prevPredictedColumns",
   ")",
   "if",
   "self",
   ".",
   "computePredictedActiveCellIndices",
   ":",
   "# Reshape so we are dealing with 1D arrays",
   "activeState",
   "=",
   "self",
   ".",
   "_tfdr",
   ".",
   "_getActiveState",
   "(",
   ")",
   ".",
   "reshape",
   "(",
   "-",
   "1",
   ")",
   ".",
   "astype",
   "(",
   "'float32'",
   ")",
   "activeIndices",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "activeState",
   "!=",
   "0",
   ")",
   "[",
   "0",
   "]",
   "predictedIndices",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "prevPredictedState",
   "!=",
   "0",
   ")",
   "[",
   "0",
   "]",
   "predictedActiveIndices",
   "=",
   "numpy",
   ".",
   "intersect1d",
   "(",
   "activeIndices",
   ",",
   "predictedIndices",
   ")",
   "outputs",
   "[",
   "\"activeCells\"",
   "]",
   ".",
   "fill",
   "(",
   "0",
   ")",
   "outputs",
   "[",
   "\"activeCells\"",
   "]",
   "[",
   "activeIndices",
   "]",
   "=",
   "1",
   "outputs",
   "[",
   "\"predictedActiveCells\"",
   "]",
   ".",
   "fill",
   "(",
   "0",
   ")",
   "outputs",
   "[",
   "\"predictedActiveCells\"",
   "]",
   "[",
   "predictedActiveIndices",
   "]",
   "=",
   "1"
  ]
 },
 {
  "idx": "maxmin-101",
  "nl_tokens": [
   "Retrieves",
   "the",
   "most",
   "recent",
   "timestamp",
   "of",
   "the",
   "media",
   "in",
   "the",
   "static",
   "root",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_media_timestamp",
   "(",
   "self",
   ",",
   "last_timestamp",
   "=",
   "None",
   ")",
   ":",
   "r",
   "=",
   "self",
   ".",
   "local_renderer",
   "_latest_timestamp",
   "=",
   "-",
   "1e9999999999999999",
   "for",
   "path",
   "in",
   "self",
   ".",
   "iter_static_paths",
   "(",
   ")",
   ":",
   "path",
   "=",
   "r",
   ".",
   "env",
   ".",
   "static_root",
   "+",
   "'/'",
   "+",
   "path",
   "self",
   ".",
   "vprint",
   "(",
   "'checking timestamp of path:'",
   ",",
   "path",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "isfile",
   "(",
   "path",
   ")",
   ":",
   "continue",
   "#print('path:', path)",
   "_latest_timestamp",
   "=",
   "<mask>",
   "(",
   "_latest_timestamp",
   ",",
   "get_last_modified_timestamp",
   "(",
   "path",
   ")",
   "or",
   "_latest_timestamp",
   ")",
   "if",
   "last_timestamp",
   "is",
   "not",
   "None",
   "and",
   "_latest_timestamp",
   ">",
   "last_timestamp",
   ":",
   "break",
   "self",
   ".",
   "vprint",
   "(",
   "'latest_timestamp:'",
   ",",
   "_latest_timestamp",
   ")",
   "return",
   "_latest_timestamp"
  ]
 },
 {
  "idx": "maxmin-102",
  "nl_tokens": [
   "Prepares",
   "the",
   "QueueNetwork",
   "for",
   "simulation",
   "."
  ],
  "pl_tokens": [
   "def",
   "initialize",
   "(",
   "self",
   ",",
   "nActive",
   "=",
   "1",
   ",",
   "queues",
   "=",
   "None",
   ",",
   "edges",
   "=",
   "None",
   ",",
   "edge_type",
   "=",
   "None",
   ")",
   ":",
   "if",
   "queues",
   "is",
   "None",
   "and",
   "edges",
   "is",
   "None",
   "and",
   "edge_type",
   "is",
   "None",
   ":",
   "if",
   "nActive",
   ">=",
   "1",
   "and",
   "isinstance",
   "(",
   "nActive",
   ",",
   "numbers",
   ".",
   "Integral",
   ")",
   ":",
   "qs",
   "=",
   "[",
   "q",
   ".",
   "edge",
   "[",
   "2",
   "]",
   "for",
   "q",
   "in",
   "self",
   ".",
   "edge2queue",
   "if",
   "q",
   ".",
   "edge",
   "[",
   "3",
   "]",
   "!=",
   "0",
   "]",
   "n",
   "=",
   "<mask>",
   "(",
   "nActive",
   ",",
   "len",
   "(",
   "qs",
   ")",
   ")",
   "queues",
   "=",
   "np",
   ".",
   "random",
   ".",
   "choice",
   "(",
   "qs",
   ",",
   "size",
   "=",
   "n",
   ",",
   "replace",
   "=",
   "False",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "nActive",
   ",",
   "numbers",
   ".",
   "Integral",
   ")",
   ":",
   "msg",
   "=",
   "\"If queues is None, then nActive must be an integer.\"",
   "raise",
   "TypeError",
   "(",
   "msg",
   ")",
   "else",
   ":",
   "msg",
   "=",
   "(",
   "\"If queues is None, then nActive must be a \"",
   "\"positive int.\"",
   ")",
   "raise",
   "ValueError",
   "(",
   "msg",
   ")",
   "else",
   ":",
   "queues",
   "=",
   "_get_queues",
   "(",
   "self",
   ".",
   "g",
   ",",
   "queues",
   ",",
   "edges",
   ",",
   "edge_type",
   ")",
   "queues",
   "=",
   "[",
   "e",
   "for",
   "e",
   "in",
   "queues",
   "if",
   "self",
   ".",
   "edge2queue",
   "[",
   "e",
   "]",
   ".",
   "edge",
   "[",
   "3",
   "]",
   "!=",
   "0",
   "]",
   "if",
   "len",
   "(",
   "queues",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "QueueingToolError",
   "(",
   "\"There were no queues to initialize.\"",
   ")",
   "if",
   "len",
   "(",
   "queues",
   ")",
   ">",
   "self",
   ".",
   "max_agents",
   ":",
   "queues",
   "=",
   "queues",
   "[",
   ":",
   "self",
   ".",
   "max_agents",
   "]",
   "for",
   "ei",
   "in",
   "queues",
   ":",
   "self",
   ".",
   "edge2queue",
   "[",
   "ei",
   "]",
   ".",
   "set_active",
   "(",
   ")",
   "self",
   ".",
   "num_agents",
   "[",
   "ei",
   "]",
   "=",
   "self",
   ".",
   "edge2queue",
   "[",
   "ei",
   "]",
   ".",
   "_num_total",
   "keys",
   "=",
   "[",
   "q",
   ".",
   "_key",
   "(",
   ")",
   "for",
   "q",
   "in",
   "self",
   ".",
   "edge2queue",
   "if",
   "q",
   ".",
   "_time",
   "<",
   "np",
   ".",
   "infty",
   "]",
   "self",
   ".",
   "_fancy_heap",
   "=",
   "PriorityQueue",
   "(",
   "keys",
   ",",
   "self",
   ".",
   "nE",
   ")",
   "self",
   ".",
   "_initialized",
   "=",
   "True"
  ]
 },
 {
  "idx": "maxmin-103",
  "nl_tokens": [
   "Convert",
   "key_vals_dict",
   "to",
   "tuple_list",
   "."
  ],
  "pl_tokens": [
   "def",
   "key_vals_dict_to_tuple_list",
   "(",
   "key_vals_dict",
   ",",
   "fill",
   "=",
   "float",
   "(",
   "'nan'",
   ")",
   ")",
   ":",
   "tuple_list",
   "=",
   "[",
   "]",
   "if",
   "not",
   "key_vals_dict",
   ":",
   "return",
   "tuple_list",
   "vlen",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "vs",
   ")",
   "for",
   "vs",
   "in",
   "itertools",
   ".",
   "chain",
   "(",
   "*",
   "key_vals_dict",
   ".",
   "values",
   "(",
   ")",
   ")",
   "]",
   ")",
   "for",
   "k",
   ",",
   "vs",
   "in",
   "key_vals_dict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "try",
   ":",
   "tuple_list",
   ".",
   "extend",
   "(",
   "[",
   "k",
   "+",
   "tuple",
   "(",
   "v",
   ")",
   "+",
   "(",
   "fill",
   ",",
   ")",
   "*",
   "(",
   "vlen",
   "-",
   "len",
   "(",
   "v",
   ")",
   ")",
   "for",
   "v",
   "in",
   "vs",
   "]",
   ")",
   "except",
   "TypeError",
   ":",
   "# assume k is not a tuple",
   "tuple_list",
   ".",
   "extend",
   "(",
   "[",
   "(",
   "k",
   ",",
   ")",
   "+",
   "tuple",
   "(",
   "v",
   ")",
   "+",
   "(",
   "fill",
   ",",
   ")",
   "*",
   "(",
   "vlen",
   "-",
   "len",
   "(",
   "v",
   ")",
   ")",
   "for",
   "v",
   "in",
   "vs",
   "]",
   ")",
   "return",
   "tuple_list"
  ]
 },
 {
  "idx": "maxmin-104",
  "nl_tokens": [
   "Creates",
   "and",
   "returns",
   "a",
   "new",
   "Assembly",
   "object",
   "in",
   "which",
   "samples",
   "from",
   "two",
   "or",
   "more",
   "Assembly",
   "objects",
   "with",
   "matching",
   "names",
   "are",
   "merged",
   ".",
   "Merging",
   "does",
   "not",
   "affect",
   "the",
   "actual",
   "files",
   "written",
   "on",
   "disk",
   "but",
   "rather",
   "creates",
   "new",
   "Samples",
   "that",
   "are",
   "linked",
   "to",
   "multiple",
   "data",
   "files",
   "and",
   "with",
   "stats",
   "summed",
   "."
  ],
  "pl_tokens": [
   "def",
   "merge",
   "(",
   "name",
   ",",
   "assemblies",
   ")",
   ":",
   "## checks",
   "assemblies",
   "=",
   "list",
   "(",
   "assemblies",
   ")",
   "## create new Assembly as a branch (deepcopy)",
   "merged",
   "=",
   "assemblies",
   "[",
   "0",
   "]",
   ".",
   "branch",
   "(",
   "name",
   ")",
   "## get all sample names from all Assemblies",
   "allsamples",
   "=",
   "set",
   "(",
   "merged",
   ".",
   "samples",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "for",
   "iterass",
   "in",
   "assemblies",
   "[",
   "1",
   ":",
   "]",
   ":",
   "allsamples",
   ".",
   "update",
   "(",
   "set",
   "(",
   "iterass",
   ".",
   "samples",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ")",
   "## Make sure we have the max of all values for max frag length",
   "## from all merging assemblies.",
   "merged",
   ".",
   "_hackersonly",
   "[",
   "\"max_fragment_length\"",
   "]",
   "=",
   "<mask>",
   "(",
   "[",
   "x",
   ".",
   "_hackersonly",
   "[",
   "\"max_fragment_length\"",
   "]",
   "for",
   "x",
   "in",
   "assemblies",
   "]",
   ")",
   "## warning message?",
   "warning",
   "=",
   "0",
   "## iterate over assembly objects, skip first already copied",
   "for",
   "iterass",
   "in",
   "assemblies",
   "[",
   "1",
   ":",
   "]",
   ":",
   "## iterate over allsamples, add if not in merged",
   "for",
   "sample",
   "in",
   "iterass",
   ".",
   "samples",
   ":",
   "## iterate over stats, skip 'state'",
   "if",
   "sample",
   "not",
   "in",
   "merged",
   ".",
   "samples",
   ":",
   "merged",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "iterass",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ")",
   "## if barcodes data present then keep it",
   "if",
   "iterass",
   ".",
   "barcodes",
   ".",
   "get",
   "(",
   "sample",
   ")",
   ":",
   "merged",
   ".",
   "barcodes",
   "[",
   "sample",
   "]",
   "=",
   "iterass",
   ".",
   "barcodes",
   "[",
   "sample",
   "]",
   "else",
   ":",
   "## merge stats and files of the sample",
   "for",
   "stat",
   "in",
   "merged",
   ".",
   "stats",
   ".",
   "keys",
   "(",
   ")",
   "[",
   "1",
   ":",
   "]",
   ":",
   "merged",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "stats",
   "[",
   "stat",
   "]",
   "+=",
   "iterass",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "stats",
   "[",
   "stat",
   "]",
   "## merge file references into a list",
   "for",
   "filetype",
   "in",
   "[",
   "'fastqs'",
   ",",
   "'edits'",
   "]",
   ":",
   "merged",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "files",
   "[",
   "filetype",
   "]",
   "+=",
   "iterass",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "files",
   "[",
   "filetype",
   "]",
   "if",
   "iterass",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "files",
   "[",
   "\"clusters\"",
   "]",
   ":",
   "warning",
   "+=",
   "1",
   "## print warning if clusters or later was present in merged assembly",
   "if",
   "warning",
   ":",
   "print",
   "(",
   "\"\"\"\\\n    Warning: the merged Assemblies contained Samples that are identically named,\n    and so ipyrad has attempted to merge these Samples. This is perfectly fine to\n    do up until step 3, but not after, because at step 3 all reads for a Sample\n    should be included during clustering/mapping. Take note, you can merge Assemblies\n    at any step *if they do not contain the same Samples*, however, here that is not\n    the case. If you wish to proceed with this merged Assembly you will have to\n    start from step 3, therefore the 'state' of the Samples in this new merged\n    Assembly ({}) have been set to 2.\n    \"\"\"",
   ".",
   "format",
   "(",
   "name",
   ")",
   ")",
   "for",
   "sample",
   "in",
   "merged",
   ".",
   "samples",
   ":",
   "merged",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "stats",
   ".",
   "state",
   "=",
   "2",
   "## clear stats",
   "for",
   "stat",
   "in",
   "[",
   "\"refseq_mapped_reads\"",
   ",",
   "\"refseq_unmapped_reads\"",
   ",",
   "\"clusters_total\"",
   ",",
   "\"clusters_hidepth\"",
   ",",
   "\"hetero_est\"",
   ",",
   "\"error_est\"",
   ",",
   "\"reads_consens\"",
   "]",
   ":",
   "merged",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "stats",
   "[",
   "stat",
   "]",
   "=",
   "0",
   "## clear files",
   "for",
   "ftype",
   "in",
   "[",
   "\"mapped_reads\"",
   ",",
   "\"unmapped_reads\"",
   ",",
   "\"clusters\"",
   ",",
   "\"consens\"",
   ",",
   "\"database\"",
   "]",
   ":",
   "merged",
   ".",
   "samples",
   "[",
   "sample",
   "]",
   ".",
   "files",
   "[",
   "ftype",
   "]",
   "=",
   "[",
   "]",
   "## Set the values for some params that don't make sense inside",
   "## merged assemblies",
   "merged_names",
   "=",
   "\", \"",
   ".",
   "join",
   "(",
   "[",
   "x",
   ".",
   "name",
   "for",
   "x",
   "in",
   "assemblies",
   "]",
   ")",
   "merged",
   ".",
   "paramsdict",
   "[",
   "\"raw_fastq_path\"",
   "]",
   "=",
   "\"Merged: \"",
   "+",
   "merged_names",
   "merged",
   ".",
   "paramsdict",
   "[",
   "\"barcodes_path\"",
   "]",
   "=",
   "\"Merged: \"",
   "+",
   "merged_names",
   "merged",
   ".",
   "paramsdict",
   "[",
   "\"sorted_fastq_path\"",
   "]",
   "=",
   "\"Merged: \"",
   "+",
   "merged_names",
   "## return the new Assembly object",
   "merged",
   ".",
   "save",
   "(",
   ")",
   "return",
   "merged"
  ]
 },
 {
  "idx": "maxmin-105",
  "nl_tokens": [
   "Given",
   "a",
   "state",
   "in",
   "a",
   "game",
   "calculate",
   "the",
   "best",
   "move",
   "by",
   "searching",
   "forward",
   "all",
   "the",
   "way",
   "to",
   "the",
   "terminal",
   "states",
   ".",
   "[",
   "Fig",
   ".",
   "5",
   ".",
   "3",
   "]"
  ],
  "pl_tokens": [
   "def",
   "minimax_decision",
   "(",
   "state",
   ",",
   "game",
   ")",
   ":",
   "player",
   "=",
   "game",
   ".",
   "to_move",
   "(",
   "state",
   ")",
   "def",
   "max_value",
   "(",
   "state",
   ")",
   ":",
   "if",
   "game",
   ".",
   "terminal_test",
   "(",
   "state",
   ")",
   ":",
   "return",
   "game",
   ".",
   "utility",
   "(",
   "state",
   ",",
   "player",
   ")",
   "v",
   "=",
   "-",
   "infinity",
   "for",
   "a",
   "in",
   "game",
   ".",
   "actions",
   "(",
   "state",
   ")",
   ":",
   "v",
   "=",
   "<mask>",
   "(",
   "v",
   ",",
   "min_value",
   "(",
   "game",
   ".",
   "result",
   "(",
   "state",
   ",",
   "a",
   ")",
   ")",
   ")",
   "return",
   "v",
   "def",
   "min_value",
   "(",
   "state",
   ")",
   ":",
   "if",
   "game",
   ".",
   "terminal_test",
   "(",
   "state",
   ")",
   ":",
   "return",
   "game",
   ".",
   "utility",
   "(",
   "state",
   ",",
   "player",
   ")",
   "v",
   "=",
   "infinity",
   "for",
   "a",
   "in",
   "game",
   ".",
   "actions",
   "(",
   "state",
   ")",
   ":",
   "v",
   "=",
   "min",
   "(",
   "v",
   ",",
   "max_value",
   "(",
   "game",
   ".",
   "result",
   "(",
   "state",
   ",",
   "a",
   ")",
   ")",
   ")",
   "return",
   "v",
   "# Body of minimax_decision:",
   "return",
   "argmax",
   "(",
   "game",
   ".",
   "actions",
   "(",
   "state",
   ")",
   ",",
   "lambda",
   "a",
   ":",
   "min_value",
   "(",
   "game",
   ".",
   "result",
   "(",
   "state",
   ",",
   "a",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-106",
  "nl_tokens": [
   "Given",
   "two",
   "time",
   "points",
   "(",
   "seconds",
   ")",
   "return",
   "IV",
   "data",
   ".",
   "Optionally",
   "plots",
   "a",
   "fancy",
   "graph",
   "(",
   "with",
   "errorbars",
   ")",
   "Returns",
   "[[",
   "AV",
   "]",
   "[",
   "SD",
   "]]",
   "for",
   "the",
   "given",
   "range",
   "."
  ],
  "pl_tokens": [
   "def",
   "IV",
   "(",
   "abf",
   ",",
   "T1",
   ",",
   "T2",
   ",",
   "plotToo",
   "=",
   "True",
   ",",
   "color",
   "=",
   "'b'",
   ")",
   ":",
   "rangeData",
   "=",
   "abf",
   ".",
   "average_data",
   "(",
   "[",
   "[",
   "T1",
   ",",
   "T2",
   "]",
   "]",
   ")",
   "#get the average data per sweep",
   "AV",
   ",",
   "SD",
   "=",
   "rangeData",
   "[",
   ":",
   ",",
   "0",
   ",",
   "0",
   "]",
   ",",
   "rangeData",
   "[",
   ":",
   ",",
   "0",
   ",",
   "1",
   "]",
   "#separate by average and SD",
   "Xs",
   "=",
   "abf",
   ".",
   "clampValues",
   "(",
   "T1",
   ")",
   "#get clamp values at time point T1",
   "if",
   "plotToo",
   ":",
   "new",
   "(",
   "abf",
   ")",
   "#do this so it's the right shape and size",
   "# plot the original sweep",
   "pylab",
   ".",
   "subplot",
   "(",
   "221",
   ")",
   "pylab",
   ".",
   "title",
   "(",
   "\"sweep data\"",
   ")",
   "pylab",
   ".",
   "xlabel",
   "(",
   "\"time (s)\"",
   ")",
   "pylab",
   ".",
   "ylabel",
   "(",
   "\"Measurement (%s)\"",
   "%",
   "abf",
   ".",
   "units",
   ")",
   "sweep",
   "(",
   "abf",
   ",",
   "'all'",
   ",",
   "protocol",
   "=",
   "False",
   ")",
   "pylab",
   ".",
   "axis",
   "(",
   "[",
   "None",
   ",",
   "None",
   ",",
   "np",
   ".",
   "<mask>",
   "(",
   "rangeData",
   ")",
   "-",
   "50",
   ",",
   "np",
   ".",
   "max",
   "(",
   "rangeData",
   ")",
   "+",
   "50",
   "]",
   ")",
   "pylab",
   ".",
   "axvspan",
   "(",
   "T1",
   ",",
   "T2",
   ",",
   "alpha",
   "=",
   ".1",
   ",",
   "color",
   "=",
   "color",
   ")",
   "#share measurement region",
   "pylab",
   ".",
   "margins",
   "(",
   "0",
   ",",
   ".1",
   ")",
   "# plot the data zoomed in",
   "pylab",
   ".",
   "subplot",
   "(",
   "223",
   ")",
   "pylab",
   ".",
   "title",
   "(",
   "\"measurement region\"",
   ")",
   "pylab",
   ".",
   "xlabel",
   "(",
   "\"time (s)\"",
   ")",
   "pylab",
   ".",
   "ylabel",
   "(",
   "\"Measurement (%s)\"",
   "%",
   "abf",
   ".",
   "units",
   ")",
   "sweep",
   "(",
   "abf",
   ",",
   "'all'",
   ",",
   "protocol",
   "=",
   "False",
   ")",
   "pylab",
   ".",
   "axis",
   "(",
   "[",
   "T1",
   "-",
   ".05",
   ",",
   "T2",
   "+",
   ".05",
   ",",
   "np",
   ".",
   "min",
   "(",
   "rangeData",
   ")",
   "-",
   "50",
   ",",
   "np",
   ".",
   "max",
   "(",
   "rangeData",
   ")",
   "+",
   "50",
   "]",
   ")",
   "pylab",
   ".",
   "axvspan",
   "(",
   "T1",
   ",",
   "T2",
   ",",
   "alpha",
   "=",
   ".1",
   ",",
   "color",
   "=",
   "color",
   ")",
   "#share measurement region",
   "pylab",
   ".",
   "margins",
   "(",
   "0",
   ",",
   ".1",
   ")",
   "# plot the protocol",
   "pylab",
   ".",
   "subplot",
   "(",
   "222",
   ")",
   "pylab",
   ".",
   "title",
   "(",
   "\"protocol\"",
   ")",
   "pylab",
   ".",
   "xlabel",
   "(",
   "\"time (s)\"",
   ")",
   "pylab",
   ".",
   "ylabel",
   "(",
   "\"Command (%s)\"",
   "%",
   "abf",
   ".",
   "unitsCommand",
   ")",
   "sweep",
   "(",
   "abf",
   ",",
   "'all'",
   ",",
   "protocol",
   "=",
   "True",
   ")",
   "pylab",
   ".",
   "axvspan",
   "(",
   "T1",
   ",",
   "T2",
   ",",
   "alpha",
   "=",
   ".1",
   ",",
   "color",
   "=",
   "color",
   ")",
   "#share measurement region",
   "pylab",
   ".",
   "margins",
   "(",
   "0",
   ",",
   ".1",
   ")",
   "# plot the I/V",
   "pylab",
   ".",
   "subplot",
   "(",
   "224",
   ")",
   "pylab",
   ".",
   "grid",
   "(",
   "alpha",
   "=",
   ".5",
   ")",
   "pylab",
   ".",
   "title",
   "(",
   "\"command / measure relationship\"",
   ")",
   "pylab",
   ".",
   "xlabel",
   "(",
   "\"Command (%s)\"",
   "%",
   "abf",
   ".",
   "unitsCommand",
   ")",
   "pylab",
   ".",
   "ylabel",
   "(",
   "\"Measurement (%s)\"",
   "%",
   "abf",
   ".",
   "units",
   ")",
   "pylab",
   ".",
   "errorbar",
   "(",
   "Xs",
   ",",
   "AV",
   ",",
   "SD",
   ",",
   "capsize",
   "=",
   "0",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "color",
   ")",
   "if",
   "abf",
   ".",
   "units",
   "==",
   "\"pA\"",
   ":",
   "pylab",
   ".",
   "axhline",
   "(",
   "0",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "ls",
   "=",
   "\"--\"",
   ")",
   "pylab",
   ".",
   "axvline",
   "(",
   "-",
   "70",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "ls",
   "=",
   "\"--\"",
   ")",
   "else",
   ":",
   "pylab",
   ".",
   "axhline",
   "(",
   "-",
   "70",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "ls",
   "=",
   "\"--\"",
   ")",
   "pylab",
   ".",
   "axvline",
   "(",
   "0",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "ls",
   "=",
   "\"--\"",
   ")",
   "pylab",
   ".",
   "margins",
   "(",
   ".1",
   ",",
   ".1",
   ")",
   "annotate",
   "(",
   "abf",
   ")",
   "return",
   "AV",
   ",",
   "SD"
  ]
 },
 {
  "idx": "maxmin-107",
  "nl_tokens": [
   "Trim",
   "the",
   "annotation",
   "and",
   "return",
   "as",
   "a",
   "new",
   "Annotation",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "trim",
   "(",
   "self",
   ",",
   "start_time",
   ",",
   "end_time",
   ",",
   "strict",
   "=",
   "False",
   ")",
   ":",
   "# Check for basic start_time and end_time validity",
   "if",
   "end_time",
   "<=",
   "start_time",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'end_time must be greater than start_time.'",
   ")",
   "# If the annotation does not have a set duration value, we'll assume",
   "# trimming is possible (up to the user to ensure this is valid).",
   "if",
   "self",
   ".",
   "duration",
   "is",
   "None",
   ":",
   "orig_time",
   "=",
   "start_time",
   "orig_duration",
   "=",
   "end_time",
   "-",
   "start_time",
   "warnings",
   ".",
   "warn",
   "(",
   "\"Annotation.duration is not defined, cannot check \"",
   "\"for temporal intersection, assuming the annotation \"",
   "\"is valid between start_time and end_time.\"",
   ")",
   "else",
   ":",
   "orig_time",
   "=",
   "self",
   ".",
   "time",
   "orig_duration",
   "=",
   "self",
   ".",
   "duration",
   "# Check whether there is intersection between the trim range and",
   "# annotation: if not raise a warning and set trim_start and trim_end",
   "# appropriately.",
   "if",
   "start_time",
   ">",
   "(",
   "orig_time",
   "+",
   "orig_duration",
   ")",
   "or",
   "(",
   "end_time",
   "<",
   "orig_time",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "'Time range defined by [start_time,end_time] does not '",
   "'intersect with the time range spanned by this annotation, '",
   "'the trimmed annotation will be empty.'",
   ")",
   "trim_start",
   "=",
   "self",
   ".",
   "time",
   "trim_end",
   "=",
   "trim_start",
   "else",
   ":",
   "# Determine new range",
   "trim_start",
   "=",
   "<mask>",
   "(",
   "orig_time",
   ",",
   "start_time",
   ")",
   "trim_end",
   "=",
   "min",
   "(",
   "orig_time",
   "+",
   "orig_duration",
   ",",
   "end_time",
   ")",
   "# Create new annotation with same namespace/metadata",
   "ann_trimmed",
   "=",
   "Annotation",
   "(",
   "self",
   ".",
   "namespace",
   ",",
   "data",
   "=",
   "None",
   ",",
   "annotation_metadata",
   "=",
   "self",
   ".",
   "annotation_metadata",
   ",",
   "sandbox",
   "=",
   "self",
   ".",
   "sandbox",
   ",",
   "time",
   "=",
   "trim_start",
   ",",
   "duration",
   "=",
   "trim_end",
   "-",
   "trim_start",
   ")",
   "# Selectively add observations based on their start time / duration",
   "# We do this rather than copying and directly manipulating the",
   "# annotation' data frame (which might be faster) since this way trim is",
   "# independent of the internal data representation.",
   "for",
   "obs",
   "in",
   "self",
   ".",
   "data",
   ":",
   "obs_start",
   "=",
   "obs",
   ".",
   "time",
   "obs_end",
   "=",
   "obs_start",
   "+",
   "obs",
   ".",
   "duration",
   "if",
   "obs_start",
   "<",
   "trim_end",
   "and",
   "obs_end",
   ">",
   "trim_start",
   ":",
   "new_start",
   "=",
   "max",
   "(",
   "obs_start",
   ",",
   "trim_start",
   ")",
   "new_end",
   "=",
   "min",
   "(",
   "obs_end",
   ",",
   "trim_end",
   ")",
   "new_duration",
   "=",
   "new_end",
   "-",
   "new_start",
   "if",
   "(",
   "(",
   "not",
   "strict",
   ")",
   "or",
   "(",
   "new_start",
   "==",
   "obs_start",
   "and",
   "new_end",
   "==",
   "obs_end",
   ")",
   ")",
   ":",
   "ann_trimmed",
   ".",
   "append",
   "(",
   "time",
   "=",
   "new_start",
   ",",
   "duration",
   "=",
   "new_duration",
   ",",
   "value",
   "=",
   "obs",
   ".",
   "value",
   ",",
   "confidence",
   "=",
   "obs",
   ".",
   "confidence",
   ")",
   "if",
   "'trim'",
   "not",
   "in",
   "ann_trimmed",
   ".",
   "sandbox",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "ann_trimmed",
   ".",
   "sandbox",
   ".",
   "update",
   "(",
   "trim",
   "=",
   "[",
   "{",
   "'start_time'",
   ":",
   "start_time",
   ",",
   "'end_time'",
   ":",
   "end_time",
   ",",
   "'trim_start'",
   ":",
   "trim_start",
   ",",
   "'trim_end'",
   ":",
   "trim_end",
   "}",
   "]",
   ")",
   "else",
   ":",
   "ann_trimmed",
   ".",
   "sandbox",
   ".",
   "trim",
   ".",
   "append",
   "(",
   "{",
   "'start_time'",
   ":",
   "start_time",
   ",",
   "'end_time'",
   ":",
   "end_time",
   ",",
   "'trim_start'",
   ":",
   "trim_start",
   ",",
   "'trim_end'",
   ":",
   "trim_end",
   "}",
   ")",
   "return",
   "ann_trimmed"
  ]
 },
 {
  "idx": "maxmin-108",
  "nl_tokens": [
   "Internal",
   "function",
   "to",
   "get",
   "the",
   "number",
   "of",
   "grammar",
   "errors",
   "in",
   "given",
   "text",
   "pos",
   "-",
   "part",
   "of",
   "speech",
   "tagged",
   "text",
   "(",
   "list",
   ")",
   "text",
   "-",
   "normal",
   "text",
   "(",
   "list",
   ")",
   "tokens",
   "-",
   "list",
   "of",
   "lists",
   "of",
   "tokenized",
   "text"
  ],
  "pl_tokens": [
   "def",
   "_get_grammar_errors",
   "(",
   "self",
   ",",
   "pos",
   ",",
   "text",
   ",",
   "tokens",
   ")",
   ":",
   "word_counts",
   "=",
   "[",
   "<mask>",
   "(",
   "len",
   "(",
   "t",
   ")",
   ",",
   "1",
   ")",
   "for",
   "t",
   "in",
   "tokens",
   "]",
   "good_pos_tags",
   "=",
   "[",
   "]",
   "min_pos_seq",
   "=",
   "2",
   "max_pos_seq",
   "=",
   "4",
   "bad_pos_positions",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "text",
   ")",
   ")",
   ":",
   "pos_seq",
   "=",
   "[",
   "tag",
   "[",
   "1",
   "]",
   "for",
   "tag",
   "in",
   "pos",
   "[",
   "i",
   "]",
   "]",
   "pos_ngrams",
   "=",
   "util_functions",
   ".",
   "ngrams",
   "(",
   "pos_seq",
   ",",
   "min_pos_seq",
   ",",
   "max_pos_seq",
   ")",
   "long_pos_ngrams",
   "=",
   "[",
   "z",
   "for",
   "z",
   "in",
   "pos_ngrams",
   "if",
   "z",
   ".",
   "count",
   "(",
   "' '",
   ")",
   "==",
   "(",
   "max_pos_seq",
   "-",
   "1",
   ")",
   "]",
   "bad_pos_tuples",
   "=",
   "[",
   "[",
   "z",
   ",",
   "z",
   "+",
   "max_pos_seq",
   "]",
   "for",
   "z",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "long_pos_ngrams",
   ")",
   ")",
   "if",
   "long_pos_ngrams",
   "[",
   "z",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_good_pos_ngrams",
   "]",
   "bad_pos_tuples",
   ".",
   "sort",
   "(",
   "key",
   "=",
   "operator",
   ".",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "to_delete",
   "=",
   "[",
   "]",
   "for",
   "m",
   "in",
   "reversed",
   "(",
   "xrange",
   "(",
   "len",
   "(",
   "bad_pos_tuples",
   ")",
   "-",
   "1",
   ")",
   ")",
   ":",
   "start",
   ",",
   "end",
   "=",
   "bad_pos_tuples",
   "[",
   "m",
   "]",
   "for",
   "j",
   "in",
   "xrange",
   "(",
   "m",
   "+",
   "1",
   ",",
   "len",
   "(",
   "bad_pos_tuples",
   ")",
   ")",
   ":",
   "lstart",
   ",",
   "lend",
   "=",
   "bad_pos_tuples",
   "[",
   "j",
   "]",
   "if",
   "lstart",
   ">=",
   "start",
   "and",
   "lstart",
   "<=",
   "end",
   ":",
   "bad_pos_tuples",
   "[",
   "m",
   "]",
   "[",
   "1",
   "]",
   "=",
   "bad_pos_tuples",
   "[",
   "j",
   "]",
   "[",
   "1",
   "]",
   "to_delete",
   ".",
   "append",
   "(",
   "j",
   ")",
   "fixed_bad_pos_tuples",
   "=",
   "[",
   "bad_pos_tuples",
   "[",
   "z",
   "]",
   "for",
   "z",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "bad_pos_tuples",
   ")",
   ")",
   "if",
   "z",
   "not",
   "in",
   "to_delete",
   "]",
   "bad_pos_positions",
   ".",
   "append",
   "(",
   "fixed_bad_pos_tuples",
   ")",
   "overlap_ngrams",
   "=",
   "[",
   "z",
   "for",
   "z",
   "in",
   "pos_ngrams",
   "if",
   "z",
   "in",
   "self",
   ".",
   "_good_pos_ngrams",
   "]",
   "if",
   "(",
   "len",
   "(",
   "pos_ngrams",
   ")",
   "-",
   "len",
   "(",
   "overlap_ngrams",
   ")",
   ")",
   ">",
   "0",
   ":",
   "divisor",
   "=",
   "len",
   "(",
   "pos_ngrams",
   ")",
   "/",
   "len",
   "(",
   "pos_seq",
   ")",
   "else",
   ":",
   "divisor",
   "=",
   "1",
   "if",
   "divisor",
   "==",
   "0",
   ":",
   "divisor",
   "=",
   "1",
   "good_grammar_ratio",
   "=",
   "(",
   "len",
   "(",
   "pos_ngrams",
   ")",
   "-",
   "len",
   "(",
   "overlap_ngrams",
   ")",
   ")",
   "/",
   "divisor",
   "good_pos_tags",
   ".",
   "append",
   "(",
   "good_grammar_ratio",
   ")",
   "return",
   "good_pos_tags",
   ",",
   "bad_pos_positions"
  ]
 },
 {
  "idx": "maxmin-109",
  "nl_tokens": [
   "Projection",
   "onto",
   "the",
   "fantope",
   "[",
   "1",
   "]",
   "_"
  ],
  "pl_tokens": [
   "def",
   "fantope",
   "(",
   "x",
   ",",
   "rho",
   ",",
   "dim",
   ",",
   "tol",
   "=",
   "1e-4",
   ")",
   ":",
   "U",
   ",",
   "V",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "eigh",
   "(",
   "x",
   ")",
   "minval",
   ",",
   "maxval",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "U",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "0",
   ")",
   ",",
   "np",
   ".",
   "maximum",
   "(",
   "U",
   ".",
   "max",
   "(",
   ")",
   ",",
   "20",
   "*",
   "dim",
   ")",
   "while",
   "True",
   ":",
   "theta",
   "=",
   "0.5",
   "*",
   "(",
   "maxval",
   "+",
   "minval",
   ")",
   "thr_eigvals",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "(",
   "U",
   "-",
   "theta",
   ")",
   ",",
   "0",
   ")",
   ",",
   "1",
   ")",
   "constraint",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "thr_eigvals",
   ")",
   "if",
   "np",
   ".",
   "abs",
   "(",
   "constraint",
   "-",
   "dim",
   ")",
   "<=",
   "tol",
   ":",
   "break",
   "elif",
   "constraint",
   "<",
   "dim",
   ":",
   "maxval",
   "=",
   "theta",
   "elif",
   "constraint",
   ">",
   "dim",
   ":",
   "minval",
   "=",
   "theta",
   "else",
   ":",
   "break",
   "return",
   "np",
   ".",
   "linalg",
   ".",
   "multi_dot",
   "(",
   "(",
   "V",
   ",",
   "np",
   ".",
   "diag",
   "(",
   "thr_eigvals",
   ")",
   ",",
   "V",
   ".",
   "T",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-110",
  "nl_tokens": [
   "Returns",
   "dictionary",
   "of",
   "length",
   "stats",
   "from",
   "an",
   "fai",
   "file",
   ".",
   "Keys",
   "are",
   ":",
   "longest",
   "shortest",
   "mean",
   "total_length",
   "N50",
   "number"
  ],
  "pl_tokens": [
   "def",
   "stats_from_fai",
   "(",
   "infile",
   ")",
   ":",
   "f",
   "=",
   "utils",
   ".",
   "open_file_read",
   "(",
   "infile",
   ")",
   "try",
   ":",
   "lengths",
   "=",
   "sorted",
   "(",
   "[",
   "int",
   "(",
   "line",
   ".",
   "split",
   "(",
   "'\\t'",
   ")",
   "[",
   "1",
   "]",
   ")",
   "for",
   "line",
   "in",
   "f",
   "]",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "except",
   ":",
   "raise",
   "Error",
   "(",
   "'Error getting lengths from fai file '",
   "+",
   "infile",
   ")",
   "utils",
   ".",
   "close",
   "(",
   "f",
   ")",
   "stats",
   "=",
   "{",
   "}",
   "if",
   "len",
   "(",
   "lengths",
   ")",
   ">",
   "0",
   ":",
   "stats",
   "[",
   "'longest'",
   "]",
   "=",
   "<mask>",
   "(",
   "lengths",
   ")",
   "stats",
   "[",
   "'shortest'",
   "]",
   "=",
   "min",
   "(",
   "lengths",
   ")",
   "stats",
   "[",
   "'total_length'",
   "]",
   "=",
   "sum",
   "(",
   "lengths",
   ")",
   "stats",
   "[",
   "'mean'",
   "]",
   "=",
   "stats",
   "[",
   "'total_length'",
   "]",
   "/",
   "len",
   "(",
   "lengths",
   ")",
   "stats",
   "[",
   "'number'",
   "]",
   "=",
   "len",
   "(",
   "lengths",
   ")",
   "cumulative_length",
   "=",
   "0",
   "for",
   "length",
   "in",
   "lengths",
   ":",
   "cumulative_length",
   "+=",
   "length",
   "if",
   "cumulative_length",
   ">=",
   "0.5",
   "*",
   "stats",
   "[",
   "'total_length'",
   "]",
   ":",
   "stats",
   "[",
   "'N50'",
   "]",
   "=",
   "length",
   "break",
   "else",
   ":",
   "stats",
   "=",
   "{",
   "x",
   ":",
   "0",
   "for",
   "x",
   "in",
   "(",
   "'longest'",
   ",",
   "'shortest'",
   ",",
   "'mean'",
   ",",
   "'N50'",
   ",",
   "'total_length'",
   ",",
   "'number'",
   ")",
   "}",
   "return",
   "stats"
  ]
 },
 {
  "idx": "maxmin-111",
  "nl_tokens": [
   "Determine",
   "good",
   "units",
   "for",
   "representing",
   "a",
   "sequence",
   "of",
   "timedeltas"
  ],
  "pl_tokens": [
   "def",
   "best_units",
   "(",
   "self",
   ",",
   "sequence",
   ")",
   ":",
   "# Read",
   "#   [(0.9, 's'),",
   "#    (9, 'm)]",
   "# as, break ranges between 0.9 seconds (inclusive)",
   "# and 9 minutes are represented in seconds. And so on.",
   "ts_range",
   "=",
   "self",
   ".",
   "value",
   "(",
   "<mask>",
   "(",
   "sequence",
   ")",
   ")",
   "-",
   "self",
   ".",
   "value",
   "(",
   "min",
   "(",
   "sequence",
   ")",
   ")",
   "package",
   "=",
   "self",
   ".",
   "determine_package",
   "(",
   "sequence",
   "[",
   "0",
   "]",
   ")",
   "if",
   "package",
   "==",
   "'pandas'",
   ":",
   "cuts",
   "=",
   "[",
   "(",
   "0.9",
   ",",
   "'us'",
   ")",
   ",",
   "(",
   "0.9",
   ",",
   "'ms'",
   ")",
   ",",
   "(",
   "0.9",
   ",",
   "'s'",
   ")",
   ",",
   "(",
   "9",
   ",",
   "'m'",
   ")",
   ",",
   "(",
   "6",
   ",",
   "'h'",
   ")",
   ",",
   "(",
   "4",
   ",",
   "'d'",
   ")",
   ",",
   "(",
   "4",
   ",",
   "'w'",
   ")",
   ",",
   "(",
   "4",
   ",",
   "'M'",
   ")",
   ",",
   "(",
   "3",
   ",",
   "'y'",
   ")",
   "]",
   "denomination",
   "=",
   "NANOSECONDS",
   "base_units",
   "=",
   "'ns'",
   "else",
   ":",
   "cuts",
   "=",
   "[",
   "(",
   "0.9",
   ",",
   "'s'",
   ")",
   ",",
   "(",
   "9",
   ",",
   "'m'",
   ")",
   ",",
   "(",
   "6",
   ",",
   "'h'",
   ")",
   ",",
   "(",
   "4",
   ",",
   "'d'",
   ")",
   ",",
   "(",
   "4",
   ",",
   "'w'",
   ")",
   ",",
   "(",
   "4",
   ",",
   "'M'",
   ")",
   ",",
   "(",
   "3",
   ",",
   "'y'",
   ")",
   "]",
   "denomination",
   "=",
   "SECONDS",
   "base_units",
   "=",
   "'ms'",
   "for",
   "size",
   ",",
   "units",
   "in",
   "reversed",
   "(",
   "cuts",
   ")",
   ":",
   "if",
   "ts_range",
   ">=",
   "size",
   "*",
   "denomination",
   "[",
   "units",
   "]",
   ":",
   "return",
   "units",
   "return",
   "base_units"
  ]
 },
 {
  "idx": "maxmin-112",
  "nl_tokens": [
   "Return",
   "the",
   "normalized",
   "common",
   "Sift4",
   "distance",
   "between",
   "two",
   "terms",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "max_offset",
   "=",
   "5",
   ",",
   "max_distance",
   "=",
   "0",
   ")",
   ":",
   "return",
   "self",
   ".",
   "dist_abs",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "max_offset",
   ",",
   "max_distance",
   ")",
   "/",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ",",
   "1",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-113",
  "nl_tokens": [
   "An",
   "elliptical",
   "arc",
   "approximated",
   "with",
   "Bezier",
   "curves",
   "or",
   "a",
   "line",
   "segment",
   ".",
   "Algorithm",
   "taken",
   "from",
   "the",
   "SVG",
   "1",
   ".",
   "1",
   "Implementation",
   "Notes",
   ":",
   "http",
   ":",
   "//",
   "www",
   ".",
   "w3",
   ".",
   "org",
   "/",
   "TR",
   "/",
   "SVG",
   "/",
   "implnote",
   ".",
   "html#ArcImplementationNotes"
  ],
  "pl_tokens": [
   "def",
   "elliptical_arc_to",
   "(",
   "x1",
   ",",
   "y1",
   ",",
   "rx",
   ",",
   "ry",
   ",",
   "phi",
   ",",
   "large_arc_flag",
   ",",
   "sweep_flag",
   ",",
   "x2",
   ",",
   "y2",
   ")",
   ":",
   "# Basic normalization.",
   "rx",
   "=",
   "abs",
   "(",
   "rx",
   ")",
   "ry",
   "=",
   "abs",
   "(",
   "ry",
   ")",
   "phi",
   "=",
   "phi",
   "%",
   "360",
   "# Check for certain special cases.",
   "if",
   "x1",
   "==",
   "x2",
   "and",
   "y1",
   "==",
   "y2",
   ":",
   "# Omit the arc.",
   "# x1 and y1 can obviously remain the same for the next segment.",
   "return",
   "[",
   "]",
   "if",
   "rx",
   "==",
   "0",
   "or",
   "ry",
   "==",
   "0",
   ":",
   "# Line segment.",
   "return",
   "[",
   "(",
   "x2",
   ",",
   "y2",
   ")",
   "]",
   "rphi",
   "=",
   "radians",
   "(",
   "phi",
   ")",
   "cphi",
   "=",
   "cos",
   "(",
   "rphi",
   ")",
   "sphi",
   "=",
   "sin",
   "(",
   "rphi",
   ")",
   "# Step 1: Rotate to the local coordinates.",
   "dx",
   "=",
   "0.5",
   "*",
   "(",
   "x1",
   "-",
   "x2",
   ")",
   "dy",
   "=",
   "0.5",
   "*",
   "(",
   "y1",
   "-",
   "y2",
   ")",
   "x1p",
   "=",
   "cphi",
   "*",
   "dx",
   "+",
   "sphi",
   "*",
   "dy",
   "y1p",
   "=",
   "-",
   "sphi",
   "*",
   "dx",
   "+",
   "cphi",
   "*",
   "dy",
   "# Ensure that rx and ry are large enough to have a unique solution.",
   "lam",
   "=",
   "(",
   "x1p",
   "/",
   "rx",
   ")",
   "**",
   "2",
   "+",
   "(",
   "y1p",
   "/",
   "ry",
   ")",
   "**",
   "2",
   "if",
   "lam",
   ">",
   "1.0",
   ":",
   "scale",
   "=",
   "sqrt",
   "(",
   "lam",
   ")",
   "rx",
   "*=",
   "scale",
   "ry",
   "*=",
   "scale",
   "# Step 2: Solve for the center in the local coordinates.",
   "num",
   "=",
   "<mask>",
   "(",
   "(",
   "rx",
   "*",
   "ry",
   ")",
   "**",
   "2",
   "-",
   "(",
   "rx",
   "*",
   "y1p",
   ")",
   "**",
   "2",
   "-",
   "(",
   "ry",
   "*",
   "x1p",
   ")",
   "**",
   "2",
   ",",
   "0.0",
   ")",
   "den",
   "=",
   "(",
   "(",
   "rx",
   "*",
   "y1p",
   ")",
   "**",
   "2",
   "+",
   "(",
   "ry",
   "*",
   "x1p",
   ")",
   "**",
   "2",
   ")",
   "a",
   "=",
   "sqrt",
   "(",
   "num",
   "/",
   "den",
   ")",
   "cxp",
   "=",
   "a",
   "*",
   "rx",
   "*",
   "y1p",
   "/",
   "ry",
   "cyp",
   "=",
   "-",
   "a",
   "*",
   "ry",
   "*",
   "x1p",
   "/",
   "rx",
   "if",
   "large_arc_flag",
   "==",
   "sweep_flag",
   ":",
   "cxp",
   "=",
   "-",
   "cxp",
   "cyp",
   "=",
   "-",
   "cyp",
   "# Step 3: Transform back.",
   "mx",
   "=",
   "0.5",
   "*",
   "(",
   "x1",
   "+",
   "x2",
   ")",
   "my",
   "=",
   "0.5",
   "*",
   "(",
   "y1",
   "+",
   "y2",
   ")",
   "# Step 4: Compute the start angle and the angular extent of the arc.",
   "# Note that theta1 is local to the phi-rotated coordinate space.",
   "dx",
   "=",
   "(",
   "x1p",
   "-",
   "cxp",
   ")",
   "/",
   "rx",
   "dy",
   "=",
   "(",
   "y1p",
   "-",
   "cyp",
   ")",
   "/",
   "ry",
   "dx2",
   "=",
   "(",
   "-",
   "x1p",
   "-",
   "cxp",
   ")",
   "/",
   "rx",
   "dy2",
   "=",
   "(",
   "-",
   "y1p",
   "-",
   "cyp",
   ")",
   "/",
   "ry",
   "theta1",
   "=",
   "angle",
   "(",
   "1",
   ",",
   "0",
   ",",
   "dx",
   ",",
   "dy",
   ")",
   "dtheta",
   "=",
   "angle",
   "(",
   "dx",
   ",",
   "dy",
   ",",
   "dx2",
   ",",
   "dy2",
   ")",
   "if",
   "not",
   "sweep_flag",
   "and",
   "dtheta",
   ">",
   "0",
   ":",
   "dtheta",
   "-=",
   "360",
   "elif",
   "sweep_flag",
   "and",
   "dtheta",
   "<",
   "0",
   ":",
   "dtheta",
   "+=",
   "360",
   "# Step 5: Break it apart into Bezier arcs.",
   "p",
   "=",
   "[",
   "]",
   "control_points",
   "=",
   "bezier_arc",
   "(",
   "cxp",
   "-",
   "rx",
   ",",
   "cyp",
   "-",
   "ry",
   ",",
   "cxp",
   "+",
   "rx",
   ",",
   "cyp",
   "+",
   "ry",
   ",",
   "theta1",
   ",",
   "dtheta",
   ")",
   "for",
   "x1p",
   ",",
   "y1p",
   ",",
   "x2p",
   ",",
   "y2p",
   ",",
   "x3p",
   ",",
   "y3p",
   ",",
   "x4p",
   ",",
   "y4p",
   "in",
   "control_points",
   ":",
   "# Transform them back to asbolute space.",
   "p",
   ".",
   "append",
   "(",
   "(",
   "transform_from_local",
   "(",
   "x2p",
   ",",
   "y2p",
   ",",
   "cphi",
   ",",
   "sphi",
   ",",
   "mx",
   ",",
   "my",
   ")",
   "+",
   "transform_from_local",
   "(",
   "x3p",
   ",",
   "y3p",
   ",",
   "cphi",
   ",",
   "sphi",
   ",",
   "mx",
   ",",
   "my",
   ")",
   "+",
   "transform_from_local",
   "(",
   "x4p",
   ",",
   "y4p",
   ",",
   "cphi",
   ",",
   "sphi",
   ",",
   "mx",
   ",",
   "my",
   ")",
   ")",
   ")",
   "return",
   "p"
  ]
 },
 {
  "idx": "maxmin-114",
  "nl_tokens": [
   "Display",
   "an",
   "image",
   "on",
   "a",
   "matrix",
   "."
  ],
  "pl_tokens": [
   "def",
   "show_image",
   "(",
   "setter",
   ",",
   "width",
   ",",
   "height",
   ",",
   "image_path",
   "=",
   "''",
   ",",
   "image_obj",
   "=",
   "None",
   ",",
   "offset",
   "=",
   "(",
   "0",
   ",",
   "0",
   ")",
   ",",
   "bgcolor",
   "=",
   "COLORS",
   ".",
   "Off",
   ",",
   "brightness",
   "=",
   "255",
   ")",
   ":",
   "bgcolor",
   "=",
   "color_scale",
   "(",
   "bgcolor",
   ",",
   "brightness",
   ")",
   "img",
   "=",
   "image_obj",
   "if",
   "image_path",
   "and",
   "not",
   "img",
   ":",
   "from",
   "PIL",
   "import",
   "Image",
   "img",
   "=",
   "Image",
   ".",
   "open",
   "(",
   "image_path",
   ")",
   "elif",
   "not",
   "img",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Must provide either image_path or image_obj'",
   ")",
   "w",
   "=",
   "<mask>",
   "(",
   "width",
   "-",
   "offset",
   "[",
   "0",
   "]",
   ",",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   ")",
   "h",
   "=",
   "min",
   "(",
   "height",
   "-",
   "offset",
   "[",
   "1",
   "]",
   ",",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   ")",
   "ox",
   "=",
   "offset",
   "[",
   "0",
   "]",
   "oy",
   "=",
   "offset",
   "[",
   "1",
   "]",
   "for",
   "x",
   "in",
   "range",
   "(",
   "ox",
   ",",
   "w",
   "+",
   "ox",
   ")",
   ":",
   "for",
   "y",
   "in",
   "range",
   "(",
   "oy",
   ",",
   "h",
   "+",
   "oy",
   ")",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   ",",
   "a",
   "=",
   "(",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "255",
   ")",
   "rgba",
   "=",
   "img",
   ".",
   "getpixel",
   "(",
   "(",
   "x",
   "-",
   "ox",
   ",",
   "y",
   "-",
   "oy",
   ")",
   ")",
   "if",
   "isinstance",
   "(",
   "rgba",
   ",",
   "int",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Image must be in RGB or RGBA format!'",
   ")",
   "if",
   "len",
   "(",
   "rgba",
   ")",
   "==",
   "3",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "rgba",
   "elif",
   "len",
   "(",
   "rgba",
   ")",
   "==",
   "4",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   ",",
   "a",
   "=",
   "rgba",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Image must be in RGB or RGBA format!'",
   ")",
   "if",
   "a",
   "==",
   "0",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "bgcolor",
   "else",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "color_scale",
   "(",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   ",",
   "a",
   ")",
   "if",
   "brightness",
   "!=",
   "255",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "color_scale",
   "(",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   ",",
   "brightness",
   ")",
   "setter",
   "(",
   "x",
   ",",
   "y",
   ",",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-115",
  "nl_tokens": [
   "Return",
   "Snowball",
   "German",
   "stem",
   "."
  ],
  "pl_tokens": [
   "def",
   "stem",
   "(",
   "self",
   ",",
   "word",
   ",",
   "alternate_vowels",
   "=",
   "False",
   ")",
   ":",
   "# lowercase, normalize, and compose",
   "word",
   "=",
   "normalize",
   "(",
   "'NFC'",
   ",",
   "word",
   ".",
   "lower",
   "(",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "ss')",
   "",
   "if",
   "len",
   "(",
   "word",
   ")",
   ">",
   "2",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "if",
   "word",
   "[",
   "i",
   "]",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "word",
   "[",
   "i",
   "-",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_vowels",
   ":",
   "if",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "'u'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "-",
   "1",
   "]",
   "+",
   "'U'",
   "+",
   "word",
   "[",
   "i",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "'y'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "-",
   "1",
   "]",
   "+",
   "'Y'",
   "+",
   "word",
   "[",
   "i",
   ":",
   "]",
   "if",
   "alternate_vowels",
   ":",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'ae'",
   ",",
   "'\u00e4')",
   "",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'oe'",
   ",",
   "'\u00f6')",
   "",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'que'",
   ",",
   "'Q'",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'ue'",
   ",",
   "'\u00fc')",
   "",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'Q'",
   ",",
   "'que'",
   ")",
   "r1_start",
   "=",
   "<mask>",
   "(",
   "3",
   ",",
   "self",
   ".",
   "_sb_r1",
   "(",
   "word",
   ")",
   ")",
   "r2_start",
   "=",
   "self",
   ".",
   "_sb_r2",
   "(",
   "word",
   ")",
   "# Step 1",
   "niss_flag",
   "=",
   "False",
   "if",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "==",
   "'ern'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "3",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'em'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'er'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'en'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "niss_flag",
   "=",
   "True",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'es'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "niss_flag",
   "=",
   "True",
   "elif",
   "word",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'e'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "1",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "niss_flag",
   "=",
   "True",
   "elif",
   "word",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'s'",
   ":",
   "if",
   "(",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "1",
   "and",
   "len",
   "(",
   "word",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_s_endings",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "if",
   "niss_flag",
   "and",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'niss'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# Step 2",
   "if",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "==",
   "'est'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "3",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'en'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'er'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'st'",
   ":",
   "if",
   "(",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "len",
   "(",
   "word",
   ")",
   ">=",
   "6",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "in",
   "self",
   ".",
   "_st_endings",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "# Step 3",
   "if",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'isch'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   "and",
   "word",
   "[",
   "-",
   "5",
   "]",
   "!=",
   "'e'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "in",
   "{",
   "'lich'",
   ",",
   "'heit'",
   "}",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "if",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'er'",
   ",",
   "'en'",
   "}",
   "and",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'keit'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "if",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'lich'",
   "and",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'ig'",
   "and",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "in",
   "{",
   "'end'",
   ",",
   "'ung'",
   "}",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "3",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "if",
   "(",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'ig'",
   "and",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "!=",
   "'e'",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'ig'",
   ",",
   "'ik'",
   "}",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "!=",
   "'e'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "# Change 'Y' and 'U' back to lowercase if survived stemming",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "if",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'Y'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'y'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'U'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'u'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "# Remove umlauts",
   "_umlauts",
   "=",
   "dict",
   "(",
   "zip",
   "(",
   "(",
   "ord",
   "(",
   "_",
   ")",
   "for",
   "_",
   "in",
   "'\u00e4\u00f6\u00fc'), ",
   "'",
   "a",
   "u'))",
   "",
   "",
   "word",
   "=",
   "word",
   ".",
   "translate",
   "(",
   "_umlauts",
   ")",
   "return",
   "word"
  ]
 },
 {
  "idx": "maxmin-116",
  "nl_tokens": [
   "Given",
   "a",
   "seed",
   "color",
   "generate",
   "a",
   "specified",
   "number",
   "of",
   "random",
   "colors",
   "(",
   "1",
   "color",
   "by",
   "default",
   ")",
   "determined",
   "by",
   "a",
   "randomized",
   "offset",
   "from",
   "the",
   "seed",
   "."
  ],
  "pl_tokens": [
   "def",
   "offset_random_rgb",
   "(",
   "seed",
   ",",
   "amount",
   "=",
   "1",
   ")",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "seed",
   "results",
   "=",
   "[",
   "]",
   "for",
   "_",
   "in",
   "range",
   "(",
   "amount",
   ")",
   ":",
   "base_val",
   "=",
   "(",
   "(",
   "r",
   "+",
   "g",
   "+",
   "b",
   ")",
   "/",
   "3",
   ")",
   "+",
   "1",
   "# Add one to eliminate case where the base value would otherwise be 0",
   "new_val",
   "=",
   "base_val",
   "+",
   "(",
   "random",
   ".",
   "random",
   "(",
   ")",
   "*",
   "rgb_max_val",
   "/",
   "5",
   ")",
   "# Randomly offset with an arbitrary multiplier",
   "ratio",
   "=",
   "new_val",
   "/",
   "base_val",
   "results",
   ".",
   "append",
   "(",
   "(",
   "<mask>",
   "(",
   "int",
   "(",
   "r",
   "*",
   "ratio",
   ")",
   ",",
   "rgb_max_val",
   ")",
   ",",
   "min",
   "(",
   "int",
   "(",
   "g",
   "*",
   "ratio",
   ")",
   ",",
   "rgb_max_val",
   ")",
   ",",
   "min",
   "(",
   "int",
   "(",
   "b",
   "*",
   "ratio",
   ")",
   ",",
   "rgb_max_val",
   ")",
   ")",
   ")",
   "return",
   "results",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "results",
   ")",
   ">",
   "1",
   "else",
   "results"
  ]
 },
 {
  "idx": "maxmin-117",
  "nl_tokens": [
   "Plots",
   "but",
   "automatically",
   "resizes",
   "x",
   "axis",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot",
   "(",
   "*",
   "args",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "fig",
   ",",
   "ax",
   "=",
   "_setup_axes",
   "(",
   ")",
   "pl",
   "=",
   "ax",
   ".",
   "plot",
   "(",
   "*",
   "args",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "if",
   "_np",
   ".",
   "shape",
   "(",
   "args",
   ")",
   "[",
   "0",
   "]",
   ">",
   "1",
   ":",
   "if",
   "type",
   "(",
   "args",
   "[",
   "1",
   "]",
   ")",
   "is",
   "not",
   "str",
   ":",
   "min_x",
   "=",
   "<mask>",
   "(",
   "args",
   "[",
   "0",
   "]",
   ")",
   "max_x",
   "=",
   "max",
   "(",
   "args",
   "[",
   "0",
   "]",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "min_x",
   ",",
   "max_x",
   ")",
   ")",
   "return",
   "pl"
  ]
 },
 {
  "idx": "maxmin-118",
  "nl_tokens": [
   "Return",
   "the",
   "NYSIIS",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "6",
   ",",
   "modified",
   "=",
   "False",
   ")",
   ":",
   "# Require a max_length of at least 6",
   "if",
   "max_length",
   ">",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "6",
   ",",
   "max_length",
   ")",
   "word",
   "=",
   "''",
   ".",
   "join",
   "(",
   "c",
   "for",
   "c",
   "in",
   "word",
   ".",
   "upper",
   "(",
   ")",
   "if",
   "c",
   ".",
   "isalpha",
   "(",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "# exit early if there are no alphas",
   "if",
   "not",
   "word",
   ":",
   "return",
   "''",
   "original_first_char",
   "=",
   "word",
   "[",
   "0",
   "]",
   "if",
   "word",
   "[",
   ":",
   "3",
   "]",
   "==",
   "'MAC'",
   ":",
   "word",
   "=",
   "'MCC'",
   "+",
   "word",
   "[",
   "3",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'KN'",
   ":",
   "word",
   "=",
   "'NN'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "1",
   "]",
   "==",
   "'K'",
   ":",
   "word",
   "=",
   "'C'",
   "+",
   "word",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'PH'",
   ",",
   "'PF'",
   "}",
   ":",
   "word",
   "=",
   "'FF'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "3",
   "]",
   "==",
   "'SCH'",
   ":",
   "word",
   "=",
   "'SSS'",
   "+",
   "word",
   "[",
   "3",
   ":",
   "]",
   "elif",
   "modified",
   ":",
   "if",
   "word",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'WR'",
   ":",
   "word",
   "=",
   "'RR'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'RH'",
   ":",
   "word",
   "=",
   "'RR'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'DG'",
   ":",
   "word",
   "=",
   "'GG'",
   "+",
   "word",
   "[",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   ":",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ":",
   "word",
   "=",
   "'A'",
   "+",
   "word",
   "[",
   "1",
   ":",
   "]",
   "if",
   "modified",
   "and",
   "word",
   "[",
   "-",
   "1",
   ":",
   "]",
   "in",
   "{",
   "'S'",
   ",",
   "'Z'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "if",
   "(",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'EE'",
   "or",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'IE'",
   "or",
   "(",
   "modified",
   "and",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'YE'",
   ")",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'Y'",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'DT'",
   ",",
   "'RT'",
   ",",
   "'RD'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'D'",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'NT'",
   ",",
   "'ND'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "(",
   "'N'",
   "if",
   "modified",
   "else",
   "'D'",
   ")",
   "elif",
   "modified",
   ":",
   "if",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'IX'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'ICK'",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'EX'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'ECK'",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'JR'",
   ",",
   "'SR'",
   "}",
   ":",
   "return",
   "'ERROR'",
   "key",
   "=",
   "word",
   "[",
   ":",
   "1",
   "]",
   "skip",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "if",
   "i",
   ">=",
   "len",
   "(",
   "word",
   ")",
   ":",
   "continue",
   "elif",
   "skip",
   ":",
   "skip",
   "-=",
   "1",
   "continue",
   "elif",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'EV'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'AF'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "skip",
   "=",
   "1",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'A'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "modified",
   "and",
   "i",
   "!=",
   "len",
   "(",
   "word",
   ")",
   "-",
   "1",
   "and",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'Y'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'A'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'Q'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'G'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'Z'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'S'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'M'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'N'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'KN'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'N'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'K'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'C'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "modified",
   "and",
   "i",
   "==",
   "len",
   "(",
   "word",
   ")",
   "-",
   "3",
   "and",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "3",
   "]",
   "==",
   "'SCH'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'SSA'",
   "skip",
   "=",
   "2",
   "elif",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "3",
   "]",
   "==",
   "'SCH'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'SSS'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "3",
   ":",
   "]",
   "skip",
   "=",
   "2",
   "elif",
   "modified",
   "and",
   "i",
   "==",
   "len",
   "(",
   "word",
   ")",
   "-",
   "2",
   "and",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'SH'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'SA'",
   "skip",
   "=",
   "1",
   "elif",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'SH'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'SS'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "skip",
   "=",
   "1",
   "elif",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'PH'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'FF'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "skip",
   "=",
   "1",
   "elif",
   "modified",
   "and",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "3",
   "]",
   "==",
   "'GHT'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'TTT'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "3",
   ":",
   "]",
   "skip",
   "=",
   "2",
   "elif",
   "modified",
   "and",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'DG'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'GG'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "skip",
   "=",
   "1",
   "elif",
   "modified",
   "and",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'WR'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'RR'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "skip",
   "=",
   "1",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'H'",
   "and",
   "(",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_uc_v_set",
   "or",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'W'",
   "and",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "if",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "skip",
   "+",
   "1",
   "]",
   "!=",
   "key",
   "[",
   "-",
   "1",
   ":",
   "]",
   ":",
   "key",
   "+=",
   "word",
   "[",
   "i",
   ":",
   "i",
   "+",
   "skip",
   "+",
   "1",
   "]",
   "key",
   "=",
   "self",
   ".",
   "_delete_consecutive_repeats",
   "(",
   "key",
   ")",
   "if",
   "key",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'S'",
   ":",
   "key",
   "=",
   "key",
   "[",
   ":",
   "-",
   "1",
   "]",
   "if",
   "key",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'AY'",
   ":",
   "key",
   "=",
   "key",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "'Y'",
   "if",
   "key",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'A'",
   ":",
   "key",
   "=",
   "key",
   "[",
   ":",
   "-",
   "1",
   "]",
   "if",
   "modified",
   "and",
   "key",
   "[",
   ":",
   "1",
   "]",
   "==",
   "'A'",
   ":",
   "key",
   "=",
   "original_first_char",
   "+",
   "key",
   "[",
   "1",
   ":",
   "]",
   "if",
   "max_length",
   ">",
   "0",
   ":",
   "key",
   "=",
   "key",
   "[",
   ":",
   "max_length",
   "]",
   "return",
   "key"
  ]
 },
 {
  "idx": "maxmin-119",
  "nl_tokens": [
   "Write",
   "STRUCTURE",
   "format",
   "for",
   "all",
   "SNPs",
   "and",
   "unlinked",
   "SNPs"
  ],
  "pl_tokens": [
   "def",
   "write_str",
   "(",
   "data",
   ",",
   "sidx",
   ",",
   "pnames",
   ")",
   ":",
   "## grab snp and bis data from tmparr",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "tmparrs",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "\"tmp-{}.h5\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "name",
   ")",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "tmparrs",
   ",",
   "'r'",
   ")",
   "as",
   "io5",
   ":",
   "snparr",
   "=",
   "io5",
   "[",
   "\"snparr\"",
   "]",
   "bisarr",
   "=",
   "io5",
   "[",
   "\"bisarr\"",
   "]",
   "## trim to size b/c it was made longer than actual",
   "bend",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "bisarr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "bend",
   ")",
   ":",
   "bend",
   "=",
   "bend",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "bend",
   "=",
   "bisarr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "send",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "snparr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "send",
   ")",
   ":",
   "send",
   "=",
   "send",
   ".",
   "min",
   "(",
   ")",
   "else",
   ":",
   "send",
   "=",
   "snparr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "## write to str and ustr",
   "out1",
   "=",
   "open",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "str",
   ",",
   "'w'",
   ")",
   "out2",
   "=",
   "open",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "ustr",
   ",",
   "'w'",
   ")",
   "numdict",
   "=",
   "{",
   "'A'",
   ":",
   "'0'",
   ",",
   "'T'",
   ":",
   "'1'",
   ",",
   "'G'",
   ":",
   "'2'",
   ",",
   "'C'",
   ":",
   "'3'",
   ",",
   "'N'",
   ":",
   "'-9'",
   ",",
   "'-'",
   ":",
   "'-9'",
   "}",
   "if",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"max_alleles_consens\"",
   "]",
   ">",
   "1",
   ":",
   "for",
   "idx",
   ",",
   "name",
   "in",
   "enumerate",
   "(",
   "pnames",
   ")",
   ":",
   "out1",
   ".",
   "write",
   "(",
   "\"{}\\t\\t\\t\\t\\t{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "numdict",
   "[",
   "DUCT",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "]",
   "for",
   "i",
   "in",
   "snparr",
   "[",
   "idx",
   ",",
   ":",
   "send",
   "]",
   "]",
   ")",
   ")",
   ")",
   "out1",
   ".",
   "write",
   "(",
   "\"{}\\t\\t\\t\\t\\t{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "numdict",
   "[",
   "DUCT",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   "]",
   "for",
   "i",
   "in",
   "snparr",
   "[",
   "idx",
   ",",
   ":",
   "send",
   "]",
   "]",
   ")",
   ")",
   ")",
   "out2",
   ".",
   "write",
   "(",
   "\"{}\\t\\t\\t\\t\\t{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "numdict",
   "[",
   "DUCT",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "]",
   "for",
   "i",
   "in",
   "bisarr",
   "[",
   "idx",
   ",",
   ":",
   "bend",
   "]",
   "]",
   ")",
   ")",
   ")",
   "out2",
   ".",
   "write",
   "(",
   "\"{}\\t\\t\\t\\t\\t{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "numdict",
   "[",
   "DUCT",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   "]",
   "for",
   "i",
   "in",
   "bisarr",
   "[",
   "idx",
   ",",
   ":",
   "bend",
   "]",
   "]",
   ")",
   ")",
   ")",
   "else",
   ":",
   "## haploid output",
   "for",
   "idx",
   ",",
   "name",
   "in",
   "enumerate",
   "(",
   "pnames",
   ")",
   ":",
   "out1",
   ".",
   "write",
   "(",
   "\"{}\\t\\t\\t\\t\\t{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "numdict",
   "[",
   "DUCT",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "]",
   "for",
   "i",
   "in",
   "snparr",
   "[",
   "idx",
   ",",
   ":",
   "send",
   "]",
   "]",
   ")",
   ")",
   ")",
   "out2",
   ".",
   "write",
   "(",
   "\"{}\\t\\t\\t\\t\\t{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "numdict",
   "[",
   "DUCT",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "]",
   "for",
   "i",
   "in",
   "bisarr",
   "[",
   "idx",
   ",",
   ":",
   "bend",
   "]",
   "]",
   ")",
   ")",
   ")",
   "out1",
   ".",
   "close",
   "(",
   ")",
   "out2",
   ".",
   "close",
   "(",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"finished writing str in: %s\"",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")"
  ]
 },
 {
  "idx": "maxmin-120",
  "nl_tokens": [
   "Generate",
   "the",
   "correct",
   "function",
   "for",
   "an",
   "array",
   "signature",
   "."
  ],
  "pl_tokens": [
   "def",
   "_handle_array",
   "(",
   "toks",
   ")",
   ":",
   "if",
   "len",
   "(",
   "toks",
   ")",
   "==",
   "5",
   "and",
   "toks",
   "[",
   "1",
   "]",
   "==",
   "'{'",
   "and",
   "toks",
   "[",
   "4",
   "]",
   "==",
   "'}'",
   ":",
   "subtree",
   "=",
   "toks",
   "[",
   "2",
   ":",
   "4",
   "]",
   "signature",
   "=",
   "''",
   ".",
   "join",
   "(",
   "s",
   "for",
   "(",
   "_",
   ",",
   "s",
   ")",
   "in",
   "subtree",
   ")",
   "[",
   "key_func",
   ",",
   "value_func",
   "]",
   "=",
   "[",
   "f",
   "for",
   "(",
   "f",
   ",",
   "_",
   ")",
   "in",
   "subtree",
   "]",
   "def",
   "the_dict_func",
   "(",
   "a_dict",
   ",",
   "variant",
   "=",
   "0",
   ")",
   ":",
   "\"\"\"\n                Function for generating a Dictionary from a dict.\n\n                :param a_dict: the dictionary to transform\n                :type a_dict: dict of (`a * `b)\n                :param int variant: variant level\n\n                :returns: a dbus dictionary of transformed values and level\n                :rtype: Dictionary * int\n                \"\"\"",
   "elements",
   "=",
   "[",
   "(",
   "key_func",
   "(",
   "x",
   ")",
   ",",
   "value_func",
   "(",
   "y",
   ")",
   ")",
   "for",
   "(",
   "x",
   ",",
   "y",
   ")",
   "in",
   "a_dict",
   ".",
   "items",
   "(",
   ")",
   "]",
   "level",
   "=",
   "0",
   "if",
   "elements",
   "==",
   "[",
   "]",
   "else",
   "<mask>",
   "(",
   "max",
   "(",
   "x",
   ",",
   "y",
   ")",
   "for",
   "(",
   "(",
   "_",
   ",",
   "x",
   ")",
   ",",
   "(",
   "_",
   ",",
   "y",
   ")",
   ")",
   "in",
   "elements",
   ")",
   "(",
   "obj_level",
   ",",
   "func_level",
   ")",
   "=",
   "_ToDbusXformer",
   ".",
   "_variant_levels",
   "(",
   "level",
   ",",
   "variant",
   ")",
   "return",
   "(",
   "dbus",
   ".",
   "types",
   ".",
   "Dictionary",
   "(",
   "(",
   "(",
   "x",
   ",",
   "y",
   ")",
   "for",
   "(",
   "(",
   "x",
   ",",
   "_",
   ")",
   ",",
   "(",
   "y",
   ",",
   "_",
   ")",
   ")",
   "in",
   "elements",
   ")",
   ",",
   "signature",
   "=",
   "signature",
   ",",
   "variant_level",
   "=",
   "obj_level",
   ")",
   ",",
   "func_level",
   ")",
   "return",
   "(",
   "the_dict_func",
   ",",
   "'a{'",
   "+",
   "signature",
   "+",
   "'}'",
   ")",
   "if",
   "len",
   "(",
   "toks",
   ")",
   "==",
   "2",
   ":",
   "(",
   "func",
   ",",
   "sig",
   ")",
   "=",
   "toks",
   "[",
   "1",
   "]",
   "def",
   "the_array_func",
   "(",
   "a_list",
   ",",
   "variant",
   "=",
   "0",
   ")",
   ":",
   "\"\"\"\n                Function for generating an Array from a list.\n\n                :param a_list: the list to transform\n                :type a_list: list of `a\n                :param int variant: variant level of the value\n                :returns: a dbus Array of transformed values and variant level\n                :rtype: Array * int\n                \"\"\"",
   "if",
   "isinstance",
   "(",
   "a_list",
   ",",
   "dict",
   ")",
   ":",
   "raise",
   "IntoDPValueError",
   "(",
   "a_list",
   ",",
   "\"a_list\"",
   ",",
   "\"is a dict, must be an array\"",
   ")",
   "elements",
   "=",
   "[",
   "func",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "a_list",
   "]",
   "level",
   "=",
   "0",
   "if",
   "elements",
   "==",
   "[",
   "]",
   "else",
   "max",
   "(",
   "x",
   "for",
   "(",
   "_",
   ",",
   "x",
   ")",
   "in",
   "elements",
   ")",
   "(",
   "obj_level",
   ",",
   "func_level",
   ")",
   "=",
   "_ToDbusXformer",
   ".",
   "_variant_levels",
   "(",
   "level",
   ",",
   "variant",
   ")",
   "return",
   "(",
   "dbus",
   ".",
   "types",
   ".",
   "Array",
   "(",
   "(",
   "x",
   "for",
   "(",
   "x",
   ",",
   "_",
   ")",
   "in",
   "elements",
   ")",
   ",",
   "signature",
   "=",
   "sig",
   ",",
   "variant_level",
   "=",
   "obj_level",
   ")",
   ",",
   "func_level",
   ")",
   "return",
   "(",
   "the_array_func",
   ",",
   "'a'",
   "+",
   "sig",
   ")",
   "raise",
   "IntoDPValueError",
   "(",
   "toks",
   ",",
   "\"toks\"",
   ",",
   "\"unexpected tokens\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-121",
  "nl_tokens": [
   "r",
   "Format",
   "?",
   "output",
   "and",
   "deal",
   "with",
   "leading",
   "tabs",
   "."
  ],
  "pl_tokens": [
   "def",
   "_qformat",
   "(",
   "self",
   ",",
   "aline",
   ",",
   "bline",
   ",",
   "atags",
   ",",
   "btags",
   ")",
   ":",
   "# Can hurt, but will probably help most of the time.",
   "common",
   "=",
   "<mask>",
   "(",
   "_count_leading",
   "(",
   "aline",
   ",",
   "\"\\t\"",
   ")",
   ",",
   "_count_leading",
   "(",
   "bline",
   ",",
   "\"\\t\"",
   ")",
   ")",
   "common",
   "=",
   "min",
   "(",
   "common",
   ",",
   "_count_leading",
   "(",
   "atags",
   "[",
   ":",
   "common",
   "]",
   ",",
   "\" \"",
   ")",
   ")",
   "common",
   "=",
   "min",
   "(",
   "common",
   ",",
   "_count_leading",
   "(",
   "btags",
   "[",
   ":",
   "common",
   "]",
   ",",
   "\" \"",
   ")",
   ")",
   "atags",
   "=",
   "atags",
   "[",
   "common",
   ":",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   "btags",
   "=",
   "btags",
   "[",
   "common",
   ":",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   "yield",
   "\"- \"",
   "+",
   "aline",
   "if",
   "atags",
   ":",
   "yield",
   "\"? %s%s\\n\"",
   "%",
   "(",
   "\"\\t\"",
   "*",
   "common",
   ",",
   "atags",
   ")",
   "yield",
   "\"+ \"",
   "+",
   "bline",
   "if",
   "btags",
   ":",
   "yield",
   "\"? %s%s\\n\"",
   "%",
   "(",
   "\"\\t\"",
   "*",
   "common",
   ",",
   "btags",
   ")"
  ]
 },
 {
  "idx": "maxmin-122",
  "nl_tokens": [
   "Generate",
   "markdown",
   "document",
   "from",
   "module",
   "including",
   "API",
   "section",
   "."
  ],
  "pl_tokens": [
   "def",
   "mod2md",
   "(",
   "module",
   ",",
   "title",
   ",",
   "title_api_section",
   ",",
   "toc",
   "=",
   "True",
   ",",
   "maxdepth",
   "=",
   "0",
   ")",
   ":",
   "docstr",
   "=",
   "module",
   ".",
   "__doc__",
   "text",
   "=",
   "doctrim",
   "(",
   "docstr",
   ")",
   "lines",
   "=",
   "text",
   ".",
   "split",
   "(",
   "'\\n'",
   ")",
   "sections",
   "=",
   "find_sections",
   "(",
   "lines",
   ")",
   "if",
   "sections",
   ":",
   "level",
   "=",
   "<mask>",
   "(",
   "n",
   "for",
   "n",
   ",",
   "t",
   "in",
   "sections",
   ")",
   "-",
   "1",
   "else",
   ":",
   "level",
   "=",
   "1",
   "api_md",
   "=",
   "[",
   "]",
   "api_sec",
   "=",
   "[",
   "]",
   "if",
   "title_api_section",
   "and",
   "module",
   ".",
   "__all__",
   ":",
   "sections",
   ".",
   "append",
   "(",
   "(",
   "level",
   "+",
   "1",
   ",",
   "title_api_section",
   ")",
   ")",
   "for",
   "name",
   "in",
   "module",
   ".",
   "__all__",
   ":",
   "api_sec",
   ".",
   "append",
   "(",
   "(",
   "level",
   "+",
   "2",
   ",",
   "\"`\"",
   "+",
   "name",
   "+",
   "\"`\"",
   ")",
   ")",
   "api_md",
   "+=",
   "[",
   "''",
   ",",
   "''",
   "]",
   "entry",
   "=",
   "module",
   ".",
   "__dict__",
   "[",
   "name",
   "]",
   "if",
   "entry",
   ".",
   "__doc__",
   ":",
   "md",
   ",",
   "sec",
   "=",
   "doc2md",
   "(",
   "entry",
   ".",
   "__doc__",
   ",",
   "\"`\"",
   "+",
   "name",
   "+",
   "\"`\"",
   ",",
   "min_level",
   "=",
   "level",
   "+",
   "2",
   ",",
   "more_info",
   "=",
   "True",
   ",",
   "toc",
   "=",
   "False",
   ")",
   "api_sec",
   "+=",
   "sec",
   "api_md",
   "+=",
   "md",
   "sections",
   "+=",
   "api_sec",
   "# headline",
   "head",
   "=",
   "next",
   "(",
   "(",
   "i",
   "for",
   "i",
   ",",
   "l",
   "in",
   "enumerate",
   "(",
   "lines",
   ")",
   "if",
   "is_heading",
   "(",
   "l",
   ")",
   ")",
   ",",
   "0",
   ")",
   "md",
   "=",
   "[",
   "make_heading",
   "(",
   "level",
   ",",
   "title",
   ")",
   ",",
   "\"\"",
   ",",
   "]",
   "+",
   "lines",
   "[",
   ":",
   "head",
   "]",
   "# main sections",
   "if",
   "toc",
   ":",
   "md",
   "+=",
   "make_toc",
   "(",
   "sections",
   ",",
   "maxdepth",
   ")",
   "md",
   "+=",
   "[",
   "''",
   "]",
   "md",
   "+=",
   "_doc2md",
   "(",
   "lines",
   "[",
   "head",
   ":",
   "]",
   ")",
   "# API section",
   "md",
   "+=",
   "[",
   "''",
   ",",
   "''",
   ",",
   "make_heading",
   "(",
   "level",
   "+",
   "1",
   ",",
   "title_api_section",
   ")",
   ",",
   "]",
   "if",
   "toc",
   ":",
   "md",
   "+=",
   "[",
   "''",
   "]",
   "md",
   "+=",
   "make_toc",
   "(",
   "api_sec",
   ",",
   "1",
   ")",
   "md",
   "+=",
   "api_md",
   "return",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "md",
   ")"
  ]
 },
 {
  "idx": "maxmin-123",
  "nl_tokens": [
   "Returns",
   "the",
   "bounds",
   "of",
   "a",
   "geometry",
   "object",
   "in",
   "pixel",
   "coordinates"
  ],
  "pl_tokens": [
   "def",
   "pxbounds",
   "(",
   "self",
   ",",
   "geom",
   ",",
   "clip",
   "=",
   "False",
   ")",
   ":",
   "try",
   ":",
   "if",
   "isinstance",
   "(",
   "geom",
   ",",
   "dict",
   ")",
   ":",
   "if",
   "'geometry'",
   "in",
   "geom",
   ":",
   "geom",
   "=",
   "shape",
   "(",
   "geom",
   "[",
   "'geometry'",
   "]",
   ")",
   "else",
   ":",
   "geom",
   "=",
   "shape",
   "(",
   "geom",
   ")",
   "elif",
   "isinstance",
   "(",
   "geom",
   ",",
   "BaseGeometry",
   ")",
   ":",
   "geom",
   "=",
   "shape",
   "(",
   "geom",
   ")",
   "else",
   ":",
   "geom",
   "=",
   "wkt",
   ".",
   "loads",
   "(",
   "geom",
   ")",
   "except",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Invalid geometry object\"",
   ")",
   "# if geometry doesn't overlap the image, return an error",
   "if",
   "geom",
   ".",
   "disjoint",
   "(",
   "shape",
   "(",
   "self",
   ")",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Geometry outside of image bounds\"",
   ")",
   "# clip to pixels within the image",
   "(",
   "xmin",
   ",",
   "ymin",
   ",",
   "xmax",
   ",",
   "ymax",
   ")",
   "=",
   "ops",
   ".",
   "transform",
   "(",
   "self",
   ".",
   "__geo_transform__",
   ".",
   "rev",
   ",",
   "geom",
   ")",
   ".",
   "bounds",
   "_nbands",
   ",",
   "ysize",
   ",",
   "xsize",
   "=",
   "self",
   ".",
   "shape",
   "if",
   "clip",
   ":",
   "xmin",
   "=",
   "<mask>",
   "(",
   "xmin",
   ",",
   "0",
   ")",
   "ymin",
   "=",
   "max",
   "(",
   "ymin",
   ",",
   "0",
   ")",
   "xmax",
   "=",
   "min",
   "(",
   "xmax",
   ",",
   "xsize",
   ")",
   "ymax",
   "=",
   "min",
   "(",
   "ymax",
   ",",
   "ysize",
   ")",
   "return",
   "(",
   "xmin",
   ",",
   "ymin",
   ",",
   "xmax",
   ",",
   "ymax",
   ")"
  ]
 },
 {
  "idx": "maxmin-124",
  "nl_tokens": [
   "parallelized",
   "version",
   "of",
   ":",
   "func",
   ":",
   "opt_grid"
  ],
  "pl_tokens": [
   "def",
   "opt_grid_parallel",
   "(",
   "params",
   ",",
   "func",
   ",",
   "limits",
   ",",
   "ftol",
   "=",
   "0.01",
   ",",
   "disp",
   "=",
   "0",
   ",",
   "compute_errors",
   "=",
   "True",
   ")",
   ":",
   "import",
   "multiprocessing",
   "def",
   "spawn",
   "(",
   "f",
   ")",
   ":",
   "def",
   "fun",
   "(",
   "q_in",
   ",",
   "q_out",
   ")",
   ":",
   "while",
   "True",
   ":",
   "i",
   ",",
   "x",
   "=",
   "q_in",
   ".",
   "get",
   "(",
   ")",
   "if",
   "i",
   "==",
   "None",
   ":",
   "break",
   "q_out",
   ".",
   "put",
   "(",
   "(",
   "i",
   ",",
   "f",
   "(",
   "x",
   ")",
   ")",
   ")",
   "return",
   "fun",
   "def",
   "parmap",
   "(",
   "f",
   ",",
   "X",
   ",",
   "nprocs",
   "=",
   "multiprocessing",
   ".",
   "cpu_count",
   "(",
   ")",
   ")",
   ":",
   "q_in",
   "=",
   "multiprocessing",
   ".",
   "Queue",
   "(",
   "1",
   ")",
   "q_out",
   "=",
   "multiprocessing",
   ".",
   "Queue",
   "(",
   ")",
   "proc",
   "=",
   "[",
   "multiprocessing",
   ".",
   "Process",
   "(",
   "target",
   "=",
   "spawn",
   "(",
   "f",
   ")",
   ",",
   "args",
   "=",
   "(",
   "q_in",
   ",",
   "q_out",
   ")",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "nprocs",
   ")",
   "]",
   "for",
   "p",
   "in",
   "proc",
   ":",
   "p",
   ".",
   "daemon",
   "=",
   "True",
   "p",
   ".",
   "start",
   "(",
   ")",
   "sent",
   "=",
   "[",
   "q_in",
   ".",
   "put",
   "(",
   "(",
   "i",
   ",",
   "x",
   ")",
   ")",
   "for",
   "i",
   ",",
   "x",
   "in",
   "enumerate",
   "(",
   "X",
   ")",
   "]",
   "[",
   "q_in",
   ".",
   "put",
   "(",
   "(",
   "None",
   ",",
   "None",
   ")",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "nprocs",
   ")",
   "]",
   "res",
   "=",
   "[",
   "q_out",
   ".",
   "get",
   "(",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "len",
   "(",
   "sent",
   ")",
   ")",
   "]",
   "[",
   "p",
   ".",
   "join",
   "(",
   ")",
   "for",
   "p",
   "in",
   "proc",
   "]",
   "return",
   "[",
   "x",
   "for",
   "i",
   ",",
   "x",
   "in",
   "sorted",
   "(",
   "res",
   ")",
   "]",
   "nthreads",
   "=",
   "multiprocessing",
   ".",
   "cpu_count",
   "(",
   ")",
   "caches",
   "=",
   "[",
   "[",
   "]",
   "for",
   "p",
   "in",
   "params",
   "]",
   "newparams",
   "=",
   "numpy",
   ".",
   "copy",
   "(",
   "params",
   ")",
   "errors",
   "=",
   "[",
   "[",
   "]",
   "for",
   "p",
   "in",
   "params",
   "]",
   "indices",
   "=",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "params",
   ")",
   ",",
   "nthreads",
   ")",
   "k",
   "=",
   "0",
   "while",
   "k",
   "<",
   "len",
   "(",
   "params",
   ")",
   ":",
   "j",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "params",
   ")",
   ",",
   "k",
   "+",
   "nthreads",
   "*",
   "2",
   ")",
   "def",
   "run1d",
   "(",
   "(",
   "i",
   ",",
   "curparams",
   ",",
   "curlimits",
   ")",
   ")",
   ":",
   "cache",
   "=",
   "[",
   "]",
   "def",
   "func1",
   "(",
   "x0",
   ")",
   ":",
   "curparams",
   "[",
   "i",
   "]",
   "=",
   "x0",
   "v",
   "=",
   "func",
   "(",
   "curparams",
   ")",
   "cache",
   ".",
   "append",
   "(",
   "[",
   "x0",
   ",",
   "v",
   "]",
   ")",
   "return",
   "v",
   "lo",
   ",",
   "hi",
   "=",
   "curlimits",
   "bestval",
   "=",
   "optimize",
   "(",
   "func1",
   ",",
   "x0",
   "=",
   "p",
   ",",
   "cons",
   "=",
   "[",
   "lambda",
   "x",
   ":",
   "x",
   "-",
   "lo",
   ",",
   "lambda",
   "x",
   ":",
   "hi",
   "-",
   "x",
   "]",
   ",",
   "ftol",
   "=",
   "ftol",
   ",",
   "disp",
   "=",
   "disp",
   "-",
   "1",
   ")",
   "beststat",
   "=",
   "func1",
   "(",
   "bestval",
   ")",
   "if",
   "compute_errors",
   ":",
   "errors",
   "=",
   "cache2errors",
   "(",
   "func1",
   ",",
   "cache",
   ",",
   "disp",
   "=",
   "disp",
   "-",
   "1",
   ")",
   "return",
   "bestval",
   ",",
   "beststat",
   ",",
   "errors",
   ",",
   "cache",
   "return",
   "bestval",
   ",",
   "beststat",
   ",",
   "cache",
   "results",
   "=",
   "parmap",
   "(",
   "run1d",
   ",",
   "[",
   "(",
   "i",
   ",",
   "numpy",
   ".",
   "copy",
   "(",
   "newparams",
   ")",
   ",",
   "limits",
   "[",
   "i",
   "]",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "k",
   ",",
   "j",
   ")",
   "]",
   ")",
   "for",
   "i",
   ",",
   "r",
   "in",
   "enumerate",
   "(",
   "results",
   ")",
   ":",
   "if",
   "compute_errors",
   ":",
   "v",
   ",",
   "s",
   ",",
   "e",
   ",",
   "c",
   "=",
   "r",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'\\tnew value of %d: %e [%e .. %e] yielded %e'",
   "%",
   "(",
   "i",
   "+",
   "k",
   ",",
   "v",
   ",",
   "e",
   "[",
   "0",
   "]",
   ",",
   "e",
   "[",
   "1",
   "]",
   ",",
   "s",
   ")",
   "else",
   ":",
   "v",
   ",",
   "s",
   ",",
   "c",
   "=",
   "r",
   "e",
   "=",
   "[",
   "]",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'\\tnew value of %d: %e yielded %e'",
   "%",
   "(",
   "i",
   "+",
   "k",
   ",",
   "v",
   ",",
   "s",
   ")",
   "newparams",
   "[",
   "i",
   "+",
   "k",
   "]",
   "=",
   "v",
   "caches",
   "[",
   "i",
   "+",
   "k",
   "]",
   "=",
   "c",
   "errors",
   "[",
   "i",
   "+",
   "k",
   "]",
   "=",
   "e",
   "k",
   "=",
   "j",
   "beststat",
   "=",
   "func",
   "(",
   "newparams",
   ")",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'optimization done, reached %e'",
   "%",
   "(",
   "beststat",
   ")",
   "if",
   "compute_errors",
   ":",
   "return",
   "newparams",
   ",",
   "errors",
   "else",
   ":",
   "return",
   "newparams"
  ]
 },
 {
  "idx": "maxmin-125",
  "nl_tokens": [
   "Do",
   "some",
   "housekeeping",
   "(",
   "cache",
   "expiration",
   "timeout",
   "handling",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "regular_tasks",
   "(",
   "self",
   ")",
   ":",
   "with",
   "self",
   ".",
   "lock",
   ":",
   "ret",
   "=",
   "self",
   ".",
   "_iq_response_handlers",
   ".",
   "expire",
   "(",
   ")",
   "if",
   "ret",
   "is",
   "None",
   ":",
   "return",
   "1",
   "else",
   ":",
   "return",
   "<mask>",
   "(",
   "1",
   ",",
   "ret",
   ")"
  ]
 },
 {
  "idx": "maxmin-126",
  "nl_tokens": [
   "Convert",
   "a",
   "docstring",
   "to",
   "a",
   "markdown",
   "text",
   "."
  ],
  "pl_tokens": [
   "def",
   "doc2md",
   "(",
   "docstr",
   ",",
   "title",
   ",",
   "min_level",
   "=",
   "1",
   ",",
   "more_info",
   "=",
   "False",
   ",",
   "toc",
   "=",
   "True",
   ",",
   "maxdepth",
   "=",
   "0",
   ")",
   ":",
   "text",
   "=",
   "doctrim",
   "(",
   "docstr",
   ")",
   "lines",
   "=",
   "text",
   ".",
   "split",
   "(",
   "'\\n'",
   ")",
   "sections",
   "=",
   "find_sections",
   "(",
   "lines",
   ")",
   "if",
   "sections",
   ":",
   "level",
   "=",
   "<mask>",
   "(",
   "n",
   "for",
   "n",
   ",",
   "t",
   "in",
   "sections",
   ")",
   "-",
   "1",
   "else",
   ":",
   "level",
   "=",
   "1",
   "shiftlevel",
   "=",
   "0",
   "if",
   "level",
   "<",
   "min_level",
   ":",
   "shiftlevel",
   "=",
   "min_level",
   "-",
   "level",
   "level",
   "=",
   "min_level",
   "sections",
   "=",
   "[",
   "(",
   "lev",
   "+",
   "shiftlevel",
   ",",
   "tit",
   ")",
   "for",
   "lev",
   ",",
   "tit",
   "in",
   "sections",
   "]",
   "head",
   "=",
   "next",
   "(",
   "(",
   "i",
   "for",
   "i",
   ",",
   "l",
   "in",
   "enumerate",
   "(",
   "lines",
   ")",
   "if",
   "is_heading",
   "(",
   "l",
   ")",
   ")",
   ",",
   "0",
   ")",
   "md",
   "=",
   "[",
   "make_heading",
   "(",
   "level",
   ",",
   "title",
   ")",
   ",",
   "\"\"",
   ",",
   "]",
   "+",
   "lines",
   "[",
   ":",
   "head",
   "]",
   "if",
   "toc",
   ":",
   "md",
   "+=",
   "make_toc",
   "(",
   "sections",
   ",",
   "maxdepth",
   ")",
   "md",
   "+=",
   "[",
   "''",
   "]",
   "md",
   "+=",
   "_doc2md",
   "(",
   "lines",
   "[",
   "head",
   ":",
   "]",
   ",",
   "shiftlevel",
   ")",
   "if",
   "more_info",
   ":",
   "return",
   "(",
   "md",
   ",",
   "sections",
   ")",
   "else",
   ":",
   "return",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "md",
   ")"
  ]
 },
 {
  "idx": "maxmin-127",
  "nl_tokens": [
   "Create",
   "a",
   "tile",
   "pyramid",
   "out",
   "of",
   "an",
   "input",
   "raster",
   "dataset",
   "."
  ],
  "pl_tokens": [
   "def",
   "raster2pyramid",
   "(",
   "input_file",
   ",",
   "output_dir",
   ",",
   "options",
   ")",
   ":",
   "pyramid_type",
   "=",
   "options",
   "[",
   "\"pyramid_type\"",
   "]",
   "scale_method",
   "=",
   "options",
   "[",
   "\"scale_method\"",
   "]",
   "output_format",
   "=",
   "options",
   "[",
   "\"output_format\"",
   "]",
   "resampling",
   "=",
   "options",
   "[",
   "\"resampling\"",
   "]",
   "zoom",
   "=",
   "options",
   "[",
   "\"zoom\"",
   "]",
   "bounds",
   "=",
   "options",
   "[",
   "\"bounds\"",
   "]",
   "mode",
   "=",
   "\"overwrite\"",
   "if",
   "options",
   "[",
   "\"overwrite\"",
   "]",
   "else",
   "\"continue\"",
   "# Prepare process parameters",
   "minzoom",
   ",",
   "maxzoom",
   "=",
   "_get_zoom",
   "(",
   "zoom",
   ",",
   "input_file",
   ",",
   "pyramid_type",
   ")",
   "with",
   "rasterio",
   ".",
   "open",
   "(",
   "input_file",
   ",",
   "\"r\"",
   ")",
   "as",
   "input_raster",
   ":",
   "output_bands",
   "=",
   "input_raster",
   ".",
   "count",
   "input_dtype",
   "=",
   "input_raster",
   ".",
   "dtypes",
   "[",
   "0",
   "]",
   "output_dtype",
   "=",
   "input_raster",
   ".",
   "dtypes",
   "[",
   "0",
   "]",
   "nodataval",
   "=",
   "input_raster",
   ".",
   "nodatavals",
   "[",
   "0",
   "]",
   "nodataval",
   "=",
   "nodataval",
   "if",
   "nodataval",
   "else",
   "0",
   "if",
   "output_format",
   "==",
   "\"PNG\"",
   "and",
   "output_bands",
   ">",
   "3",
   ":",
   "output_bands",
   "=",
   "3",
   "output_dtype",
   "=",
   "'uint8'",
   "scales_minmax",
   "=",
   "(",
   ")",
   "if",
   "scale_method",
   "==",
   "\"dtype_scale\"",
   ":",
   "for",
   "index",
   "in",
   "range",
   "(",
   "1",
   ",",
   "output_bands",
   "+",
   "1",
   ")",
   ":",
   "scales_minmax",
   "+=",
   "(",
   "DTYPE_RANGES",
   "[",
   "input_dtype",
   "]",
   ",",
   ")",
   "elif",
   "scale_method",
   "==",
   "\"minmax_scale\"",
   ":",
   "for",
   "index",
   "in",
   "range",
   "(",
   "1",
   ",",
   "output_bands",
   "+",
   "1",
   ")",
   ":",
   "band",
   "=",
   "input_raster",
   ".",
   "read",
   "(",
   "index",
   ")",
   "scales_minmax",
   "+=",
   "(",
   "(",
   "band",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "band",
   ".",
   "max",
   "(",
   ")",
   ")",
   ",",
   ")",
   "elif",
   "scale_method",
   "==",
   "\"crop\"",
   ":",
   "for",
   "index",
   "in",
   "range",
   "(",
   "1",
   ",",
   "output_bands",
   "+",
   "1",
   ")",
   ":",
   "scales_minmax",
   "+=",
   "(",
   "(",
   "0",
   ",",
   "255",
   ")",
   ",",
   ")",
   "if",
   "input_dtype",
   "==",
   "\"uint8\"",
   ":",
   "scale_method",
   "=",
   "None",
   "scales_minmax",
   "=",
   "(",
   ")",
   "for",
   "index",
   "in",
   "range",
   "(",
   "1",
   ",",
   "output_bands",
   "+",
   "1",
   ")",
   ":",
   "scales_minmax",
   "+=",
   "(",
   "(",
   "None",
   ",",
   "None",
   ")",
   ",",
   ")",
   "# Create configuration",
   "config",
   "=",
   "dict",
   "(",
   "process",
   "=",
   "\"mapchete.processes.pyramid.tilify\"",
   ",",
   "output",
   "=",
   "{",
   "\"path\"",
   ":",
   "output_dir",
   ",",
   "\"format\"",
   ":",
   "output_format",
   ",",
   "\"bands\"",
   ":",
   "output_bands",
   ",",
   "\"dtype\"",
   ":",
   "output_dtype",
   "}",
   ",",
   "pyramid",
   "=",
   "dict",
   "(",
   "pixelbuffer",
   "=",
   "5",
   ",",
   "grid",
   "=",
   "pyramid_type",
   ")",
   ",",
   "scale_method",
   "=",
   "scale_method",
   ",",
   "scales_minmax",
   "=",
   "scales_minmax",
   ",",
   "input",
   "=",
   "{",
   "\"raster\"",
   ":",
   "input_file",
   "}",
   ",",
   "config_dir",
   "=",
   "os",
   ".",
   "getcwd",
   "(",
   ")",
   ",",
   "zoom_levels",
   "=",
   "dict",
   "(",
   "min",
   "=",
   "minzoom",
   ",",
   "max",
   "=",
   "maxzoom",
   ")",
   ",",
   "nodataval",
   "=",
   "nodataval",
   ",",
   "resampling",
   "=",
   "resampling",
   ",",
   "bounds",
   "=",
   "bounds",
   ",",
   "baselevel",
   "=",
   "{",
   "\"zoom\"",
   ":",
   "maxzoom",
   ",",
   "\"resampling\"",
   ":",
   "resampling",
   "}",
   ",",
   "mode",
   "=",
   "mode",
   ")",
   "# create process",
   "with",
   "mapchete",
   ".",
   "open",
   "(",
   "config",
   ",",
   "zoom",
   "=",
   "zoom",
   ",",
   "bounds",
   "=",
   "bounds",
   ")",
   "as",
   "mp",
   ":",
   "# prepare output directory",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "output_dir",
   ")",
   ":",
   "os",
   ".",
   "makedirs",
   "(",
   "output_dir",
   ")",
   "# run process",
   "mp",
   ".",
   "batch_process",
   "(",
   "zoom",
   "=",
   "[",
   "minzoom",
   ",",
   "maxzoom",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-128",
  "nl_tokens": [
   "Returns",
   "----------",
   "best_candidate",
   ":",
   "the",
   "best",
   "candidate",
   "hyper",
   "-",
   "parameters",
   "as",
   "defined",
   "by"
  ],
  "pl_tokens": [
   "def",
   "get_best_candidate",
   "(",
   "self",
   ")",
   ":",
   "# TODO make this best mean response",
   "self",
   ".",
   "incumbent",
   "=",
   "self",
   ".",
   "surrogate",
   ".",
   "Y",
   ".",
   "<mask>",
   "(",
   ")",
   "# Objective function",
   "def",
   "z",
   "(",
   "x",
   ")",
   ":",
   "# TODO make spread of points around x and take mean value.",
   "x",
   "=",
   "x",
   ".",
   "copy",
   "(",
   ")",
   ".",
   "reshape",
   "(",
   "-",
   "1",
   ",",
   "self",
   ".",
   "n_dims",
   ")",
   "y_mean",
   ",",
   "y_var",
   "=",
   "self",
   ".",
   "surrogate",
   ".",
   "predict",
   "(",
   "x",
   ")",
   "af",
   "=",
   "self",
   ".",
   "_acquisition_function",
   "(",
   "y_mean",
   "=",
   "y_mean",
   ",",
   "y_var",
   "=",
   "y_var",
   ")",
   "# TODO make -1 dependent on flag in inputs for either max or minimization",
   "return",
   "(",
   "-",
   "1",
   ")",
   "*",
   "af",
   "# Optimization loop",
   "af_values",
   "=",
   "[",
   "]",
   "af_args",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "n_iter",
   ")",
   ":",
   "init",
   "=",
   "self",
   ".",
   "_get_random_point",
   "(",
   ")",
   "res",
   "=",
   "minimize",
   "(",
   "z",
   ",",
   "init",
   ",",
   "bounds",
   "=",
   "self",
   ".",
   "n_dims",
   "*",
   "[",
   "(",
   "0.",
   ",",
   "1.",
   ")",
   "]",
   ",",
   "options",
   "=",
   "{",
   "'maxiter'",
   ":",
   "int",
   "(",
   "self",
   ".",
   "max_iter",
   ")",
   ",",
   "'disp'",
   ":",
   "0",
   "}",
   ")",
   "af_args",
   ".",
   "append",
   "(",
   "res",
   ".",
   "x",
   ")",
   "af_values",
   ".",
   "append",
   "(",
   "res",
   ".",
   "fun",
   ")",
   "# Choose the best",
   "af_values",
   "=",
   "np",
   ".",
   "array",
   "(",
   "af_values",
   ")",
   ".",
   "flatten",
   "(",
   ")",
   "af_args",
   "=",
   "np",
   ".",
   "array",
   "(",
   "af_args",
   ")",
   "best_index",
   "=",
   "int",
   "(",
   "np",
   ".",
   "argmin",
   "(",
   "af_values",
   ")",
   ")",
   "best_candidate",
   "=",
   "af_args",
   "[",
   "best_index",
   "]",
   "return",
   "best_candidate"
  ]
 },
 {
  "idx": "maxmin-129",
  "nl_tokens": [
   "Relocate",
   "the",
   "coordinates",
   "of",
   "a",
   "grid",
   "to",
   "its",
   "border",
   "if",
   "they",
   "are",
   "outside",
   "the",
   "border",
   ".",
   "This",
   "is",
   "performed",
   "as",
   "\\",
   "follows",
   ":"
  ],
  "pl_tokens": [
   "def",
   "relocated_grid_from_grid_jit",
   "(",
   "grid",
   ",",
   "border_grid",
   ")",
   ":",
   "border_origin",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "2",
   ")",
   "border_origin",
   "[",
   "0",
   "]",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "border_grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "border_origin",
   "[",
   "1",
   "]",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "border_grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "border_grid_radii",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "add",
   "(",
   "np",
   ".",
   "square",
   "(",
   "np",
   ".",
   "subtract",
   "(",
   "border_grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "border_origin",
   "[",
   "0",
   "]",
   ")",
   ")",
   ",",
   "np",
   ".",
   "square",
   "(",
   "np",
   ".",
   "subtract",
   "(",
   "border_grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ",",
   "border_origin",
   "[",
   "1",
   "]",
   ")",
   ")",
   ")",
   ")",
   "border_min_radii",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "border_grid_radii",
   ")",
   "grid_radii",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "add",
   "(",
   "np",
   ".",
   "square",
   "(",
   "np",
   ".",
   "subtract",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "border_origin",
   "[",
   "0",
   "]",
   ")",
   ")",
   ",",
   "np",
   ".",
   "square",
   "(",
   "np",
   ".",
   "subtract",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ",",
   "border_origin",
   "[",
   "1",
   "]",
   ")",
   ")",
   ")",
   ")",
   "for",
   "pixel_index",
   "in",
   "range",
   "(",
   "grid",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "if",
   "grid_radii",
   "[",
   "pixel_index",
   "]",
   ">",
   "border_min_radii",
   ":",
   "closest_pixel_index",
   "=",
   "np",
   ".",
   "argmin",
   "(",
   "np",
   ".",
   "square",
   "(",
   "grid",
   "[",
   "pixel_index",
   ",",
   "0",
   "]",
   "-",
   "border_grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "+",
   "np",
   ".",
   "square",
   "(",
   "grid",
   "[",
   "pixel_index",
   ",",
   "1",
   "]",
   "-",
   "border_grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   ")",
   "move_factor",
   "=",
   "border_grid_radii",
   "[",
   "closest_pixel_index",
   "]",
   "/",
   "grid_radii",
   "[",
   "pixel_index",
   "]",
   "if",
   "move_factor",
   "<",
   "1.0",
   ":",
   "grid",
   "[",
   "pixel_index",
   ",",
   ":",
   "]",
   "=",
   "move_factor",
   "*",
   "(",
   "grid",
   "[",
   "pixel_index",
   ",",
   ":",
   "]",
   "-",
   "border_origin",
   "[",
   ":",
   "]",
   ")",
   "+",
   "border_origin",
   "[",
   ":",
   "]",
   "return",
   "grid"
  ]
 },
 {
  "idx": "maxmin-130",
  "nl_tokens": [
   "r",
   "Discrete",
   "prolate",
   "spheroidal",
   "(",
   "Slepian",
   ")",
   "sequences"
  ],
  "pl_tokens": [
   "def",
   "dpss",
   "(",
   "N",
   ",",
   "NW",
   "=",
   "None",
   ",",
   "k",
   "=",
   "None",
   ")",
   ":",
   "assert",
   "NW",
   "<",
   "N",
   "/",
   "2",
   ",",
   "\"NW ({}) must be stricly less than N/2 ({}/2)\"",
   ".",
   "format",
   "(",
   "NW",
   ",",
   "N",
   ")",
   "if",
   "k",
   "is",
   "None",
   ":",
   "k",
   "=",
   "<mask>",
   "(",
   "round",
   "(",
   "2",
   "*",
   "NW",
   ")",
   ",",
   "N",
   ")",
   "k",
   "=",
   "int",
   "(",
   "max",
   "(",
   "k",
   ",",
   "1",
   ")",
   ")",
   "from",
   "numpy",
   "import",
   "dot",
   ",",
   "zeros",
   ",",
   "arange",
   ",",
   "sqrt",
   "mtspeclib",
   ".",
   "multitap",
   ".",
   "restype",
   "=",
   "None",
   "lam",
   "=",
   "zeros",
   "(",
   "k",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "tapers",
   "=",
   "zeros",
   "(",
   "k",
   "*",
   "N",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "tapsum",
   "=",
   "zeros",
   "(",
   "k",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "res",
   "=",
   "mtspeclib",
   ".",
   "multitap",
   "(",
   "c_int",
   "(",
   "N",
   ")",
   ",",
   "c_int",
   "(",
   "k",
   ")",
   ",",
   "lam",
   ".",
   "ctypes",
   ".",
   "data_as",
   "(",
   "c_void_p",
   ")",
   ",",
   "c_float",
   "(",
   "NW",
   ")",
   ",",
   "tapers",
   ".",
   "ctypes",
   ".",
   "data_as",
   "(",
   "c_void_p",
   ")",
   ",",
   "tapsum",
   ".",
   "ctypes",
   ".",
   "data_as",
   "(",
   "c_void_p",
   ")",
   ",",
   ")",
   "# normalisation by sqtr(N). It is required to have normalised windows",
   "tapers",
   "=",
   "tapers",
   ".",
   "reshape",
   "(",
   "k",
   ",",
   "N",
   ")",
   ".",
   "transpose",
   "(",
   ")",
   "/",
   "sqrt",
   "(",
   "N",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "k",
   ")",
   ":",
   "# By convention (Percival and Walden, 1993 pg 379)",
   "# * symmetric tapers (k=0,2,4,...) should have a positive average.",
   "# * antisymmetric tapers should begin with a positive lobe",
   "if",
   "i",
   "%",
   "2",
   "==",
   "0",
   ":",
   "if",
   "tapsum",
   "[",
   "i",
   "]",
   "<",
   "0",
   ":",
   "tapsum",
   "[",
   "i",
   "]",
   "*=",
   "-",
   "1",
   "tapers",
   "[",
   ":",
   ",",
   "i",
   "]",
   "*=",
   "-",
   "1",
   "else",
   ":",
   "if",
   "tapers",
   "[",
   "0",
   ",",
   "i",
   "]",
   "<",
   "0",
   ":",
   "tapsum",
   "[",
   "i",
   "]",
   "*=",
   "-",
   "1",
   "tapers",
   "[",
   ":",
   ",",
   "i",
   "]",
   "*=",
   "-",
   "1",
   "# Now find the eigenvalues of the original",
   "# Use the autocovariance sequence technique from Percival and Walden, 1993",
   "# pg 390 to get the eigenvalues more precisely (same as matlab output)",
   "# The values returned in lam are not exacly the same as in the following methods.",
   "acvs",
   "=",
   "_autocov",
   "(",
   "tapers",
   ".",
   "transpose",
   "(",
   ")",
   ",",
   "debias",
   "=",
   "False",
   ")",
   "*",
   "N",
   "nidx",
   "=",
   "arange",
   "(",
   "N",
   ")",
   "W",
   "=",
   "float",
   "(",
   "NW",
   ")",
   "/",
   "N",
   "r",
   "=",
   "4",
   "*",
   "W",
   "*",
   "np",
   ".",
   "sinc",
   "(",
   "2",
   "*",
   "W",
   "*",
   "nidx",
   ")",
   "r",
   "[",
   "0",
   "]",
   "=",
   "2",
   "*",
   "W",
   "eigvals",
   "=",
   "dot",
   "(",
   "acvs",
   ",",
   "r",
   ")",
   "#return (tapers, lam)",
   "return",
   "[",
   "tapers",
   ",",
   "eigvals",
   "]"
  ]
 },
 {
  "idx": "maxmin-131",
  "nl_tokens": [
   "See",
   "comments",
   "in",
   "base",
   "class",
   "."
  ],
  "pl_tokens": [
   "def",
   "agitate",
   "(",
   "self",
   ")",
   ":",
   "# Increase velocity enough that it will be higher the next time",
   "# newPosition() is called. We know that newPosition multiplies by inertia,",
   "# so take that into account.",
   "self",
   ".",
   "_velocity",
   "*=",
   "1.5",
   "/",
   "self",
   ".",
   "_inertia",
   "# Clip velocity",
   "maxV",
   "=",
   "(",
   "self",
   ".",
   "<mask>",
   "-",
   "self",
   ".",
   "min",
   ")",
   "/",
   "2",
   "if",
   "self",
   ".",
   "_velocity",
   ">",
   "maxV",
   ":",
   "self",
   ".",
   "_velocity",
   "=",
   "maxV",
   "elif",
   "self",
   ".",
   "_velocity",
   "<",
   "-",
   "maxV",
   ":",
   "self",
   ".",
   "_velocity",
   "=",
   "-",
   "maxV",
   "# if we at the max or min, reverse direction",
   "if",
   "self",
   ".",
   "_position",
   "==",
   "self",
   ".",
   "max",
   "and",
   "self",
   ".",
   "_velocity",
   ">",
   "0",
   ":",
   "self",
   ".",
   "_velocity",
   "*=",
   "-",
   "1",
   "if",
   "self",
   ".",
   "_position",
   "==",
   "self",
   ".",
   "min",
   "and",
   "self",
   ".",
   "_velocity",
   "<",
   "0",
   ":",
   "self",
   ".",
   "_velocity",
   "*=",
   "-",
   "1"
  ]
 },
 {
  "idx": "maxmin-132",
  "nl_tokens": [
   "Extract",
   "contour",
   "lines",
   "from",
   "an",
   "array",
   "."
  ],
  "pl_tokens": [
   "def",
   "extract_contours",
   "(",
   "array",
   ",",
   "tile",
   ",",
   "interval",
   "=",
   "100",
   ",",
   "field",
   "=",
   "'elev'",
   ",",
   "base",
   "=",
   "0",
   ")",
   ":",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "levels",
   "=",
   "_get_contour_values",
   "(",
   "array",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "array",
   ".",
   "max",
   "(",
   ")",
   ",",
   "interval",
   "=",
   "interval",
   ",",
   "base",
   "=",
   "base",
   ")",
   "if",
   "not",
   "levels",
   ":",
   "return",
   "[",
   "]",
   "contours",
   "=",
   "plt",
   ".",
   "contour",
   "(",
   "array",
   ",",
   "levels",
   ")",
   "index",
   "=",
   "0",
   "out_contours",
   "=",
   "[",
   "]",
   "for",
   "level",
   "in",
   "range",
   "(",
   "len",
   "(",
   "contours",
   ".",
   "collections",
   ")",
   ")",
   ":",
   "elevation",
   "=",
   "levels",
   "[",
   "index",
   "]",
   "index",
   "+=",
   "1",
   "paths",
   "=",
   "contours",
   ".",
   "collections",
   "[",
   "level",
   "]",
   ".",
   "get_paths",
   "(",
   ")",
   "for",
   "path",
   "in",
   "paths",
   ":",
   "out_coords",
   "=",
   "[",
   "(",
   "tile",
   ".",
   "left",
   "+",
   "(",
   "y",
   "*",
   "tile",
   ".",
   "pixel_x_size",
   ")",
   ",",
   "tile",
   ".",
   "top",
   "-",
   "(",
   "x",
   "*",
   "tile",
   ".",
   "pixel_y_size",
   ")",
   ",",
   ")",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "path",
   ".",
   "vertices",
   "[",
   ":",
   ",",
   "1",
   "]",
   ",",
   "path",
   ".",
   "vertices",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "]",
   "if",
   "len",
   "(",
   "out_coords",
   ")",
   ">=",
   "2",
   ":",
   "out_contours",
   ".",
   "append",
   "(",
   "dict",
   "(",
   "properties",
   "=",
   "{",
   "field",
   ":",
   "elevation",
   "}",
   ",",
   "geometry",
   "=",
   "mapping",
   "(",
   "LineString",
   "(",
   "out_coords",
   ")",
   ")",
   ")",
   ")",
   "return",
   "out_contours"
  ]
 },
 {
  "idx": "maxmin-133",
  "nl_tokens": [
   "Turn",
   "tokens",
   "into",
   "a",
   "tokens",
   "of",
   "n",
   "-",
   "grams"
  ],
  "pl_tokens": [
   "def",
   "_word_ngrams",
   "(",
   "self",
   ",",
   "tokens",
   ")",
   ":",
   "# handle stop words",
   "if",
   "self",
   ".",
   "stop_words",
   "is",
   "not",
   "None",
   ":",
   "tokens",
   "=",
   "[",
   "w",
   "for",
   "w",
   "in",
   "tokens",
   "if",
   "w",
   "not",
   "in",
   "self",
   ".",
   "stop_words",
   "]",
   "# handle token n-grams",
   "min_n",
   ",",
   "max_n",
   "=",
   "self",
   ".",
   "ngram_range",
   "if",
   "max_n",
   "!=",
   "1",
   ":",
   "original_tokens",
   "=",
   "tokens",
   "if",
   "min_n",
   "==",
   "1",
   ":",
   "# no need to do any slicing for unigrams",
   "# just iterate through the original tokens",
   "tokens",
   "=",
   "list",
   "(",
   "original_tokens",
   ")",
   "min_n",
   "+=",
   "1",
   "else",
   ":",
   "tokens",
   "=",
   "[",
   "]",
   "n_original_tokens",
   "=",
   "len",
   "(",
   "original_tokens",
   ")",
   "# bind method outside of loop to reduce overhead",
   "tokens_append",
   "=",
   "tokens",
   ".",
   "append",
   "space_join",
   "=",
   "\" \"",
   ".",
   "join",
   "for",
   "n",
   "in",
   "range",
   "(",
   "min_n",
   ",",
   "<mask>",
   "(",
   "max_n",
   "+",
   "1",
   ",",
   "n_original_tokens",
   "+",
   "1",
   ")",
   ")",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n_original_tokens",
   "-",
   "n",
   "+",
   "1",
   ")",
   ":",
   "tokens_append",
   "(",
   "space_join",
   "(",
   "original_tokens",
   "[",
   "i",
   ":",
   "i",
   "+",
   "n",
   "]",
   ")",
   ")",
   "return",
   "tokens"
  ]
 },
 {
  "idx": "maxmin-134",
  "nl_tokens": [
   "Intraday",
   "strategies",
   "will",
   "often",
   "not",
   "hold",
   "positions",
   "at",
   "the",
   "day",
   "end",
   ".",
   "This",
   "attempts",
   "to",
   "find",
   "the",
   "point",
   "in",
   "the",
   "day",
   "that",
   "best",
   "represents",
   "the",
   "activity",
   "of",
   "the",
   "strategy",
   "on",
   "that",
   "day",
   "and",
   "effectively",
   "resamples",
   "the",
   "end",
   "-",
   "of",
   "-",
   "day",
   "positions",
   "with",
   "the",
   "positions",
   "at",
   "this",
   "point",
   "of",
   "day",
   ".",
   "The",
   "point",
   "of",
   "day",
   "is",
   "found",
   "by",
   "detecting",
   "when",
   "our",
   "exposure",
   "in",
   "the",
   "market",
   "is",
   "at",
   "its",
   "maximum",
   "point",
   ".",
   "Note",
   "that",
   "this",
   "is",
   "an",
   "estimate",
   "."
  ],
  "pl_tokens": [
   "def",
   "estimate_intraday",
   "(",
   "returns",
   ",",
   "positions",
   ",",
   "transactions",
   ",",
   "EOD_hour",
   "=",
   "23",
   ")",
   ":",
   "# Construct DataFrame of transaction amounts",
   "txn_val",
   "=",
   "transactions",
   ".",
   "copy",
   "(",
   ")",
   "txn_val",
   ".",
   "index",
   ".",
   "names",
   "=",
   "[",
   "'date'",
   "]",
   "txn_val",
   "[",
   "'value'",
   "]",
   "=",
   "txn_val",
   ".",
   "amount",
   "*",
   "txn_val",
   ".",
   "price",
   "txn_val",
   "=",
   "txn_val",
   ".",
   "reset_index",
   "(",
   ")",
   ".",
   "pivot_table",
   "(",
   "index",
   "=",
   "'date'",
   ",",
   "values",
   "=",
   "'value'",
   ",",
   "columns",
   "=",
   "'symbol'",
   ")",
   ".",
   "replace",
   "(",
   "np",
   ".",
   "nan",
   ",",
   "0",
   ")",
   "# Cumulate transaction amounts each day",
   "txn_val",
   "[",
   "'date'",
   "]",
   "=",
   "txn_val",
   ".",
   "index",
   ".",
   "date",
   "txn_val",
   "=",
   "txn_val",
   ".",
   "groupby",
   "(",
   "'date'",
   ")",
   ".",
   "cumsum",
   "(",
   ")",
   "# Calculate exposure, then take peak of exposure every day",
   "txn_val",
   "[",
   "'exposure'",
   "]",
   "=",
   "txn_val",
   ".",
   "abs",
   "(",
   ")",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "condition",
   "=",
   "(",
   "txn_val",
   "[",
   "'exposure'",
   "]",
   "==",
   "txn_val",
   ".",
   "groupby",
   "(",
   "pd",
   ".",
   "TimeGrouper",
   "(",
   "'24H'",
   ")",
   ")",
   "[",
   "'exposure'",
   "]",
   ".",
   "transform",
   "(",
   "<mask>",
   ")",
   ")",
   "txn_val",
   "=",
   "txn_val",
   "[",
   "condition",
   "]",
   ".",
   "drop",
   "(",
   "'exposure'",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "# Compute cash delta",
   "txn_val",
   "[",
   "'cash'",
   "]",
   "=",
   "-",
   "txn_val",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "# Shift EOD positions to positions at start of next trading day",
   "positions_shifted",
   "=",
   "positions",
   ".",
   "copy",
   "(",
   ")",
   ".",
   "shift",
   "(",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "0",
   ")",
   "starting_capital",
   "=",
   "positions",
   ".",
   "iloc",
   "[",
   "0",
   "]",
   ".",
   "sum",
   "(",
   ")",
   "/",
   "(",
   "1",
   "+",
   "returns",
   "[",
   "0",
   "]",
   ")",
   "positions_shifted",
   ".",
   "cash",
   "[",
   "0",
   "]",
   "=",
   "starting_capital",
   "# Format and add start positions to intraday position changes",
   "txn_val",
   ".",
   "index",
   "=",
   "txn_val",
   ".",
   "index",
   ".",
   "normalize",
   "(",
   ")",
   "corrected_positions",
   "=",
   "positions_shifted",
   ".",
   "add",
   "(",
   "txn_val",
   ",",
   "fill_value",
   "=",
   "0",
   ")",
   "corrected_positions",
   ".",
   "index",
   ".",
   "name",
   "=",
   "'period_close'",
   "corrected_positions",
   ".",
   "columns",
   ".",
   "name",
   "=",
   "'sid'",
   "return",
   "corrected_positions"
  ]
 },
 {
  "idx": "maxmin-135",
  "nl_tokens": [
   "This",
   "finds",
   "a",
   "set",
   "of",
   "solutions",
   "for",
   "symbolic",
   "using",
   "policy",
   ".",
   "This",
   "raises",
   "TooManySolutions",
   "if",
   "more",
   "solutions",
   "than",
   "maxcount"
  ],
  "pl_tokens": [
   "def",
   "concretize",
   "(",
   "self",
   ",",
   "symbolic",
   ",",
   "policy",
   ",",
   "maxcount",
   "=",
   "7",
   ")",
   ":",
   "assert",
   "self",
   ".",
   "constraints",
   "==",
   "self",
   ".",
   "platform",
   ".",
   "constraints",
   "symbolic",
   "=",
   "self",
   ".",
   "migrate_expression",
   "(",
   "symbolic",
   ")",
   "vals",
   "=",
   "[",
   "]",
   "if",
   "policy",
   "==",
   "'MINMAX'",
   ":",
   "vals",
   "=",
   "self",
   ".",
   "_solver",
   ".",
   "minmax",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ")",
   "elif",
   "policy",
   "==",
   "'MAX'",
   ":",
   "vals",
   "=",
   "self",
   ".",
   "_solver",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ")",
   "elif",
   "policy",
   "==",
   "'MIN'",
   ":",
   "vals",
   "=",
   "self",
   ".",
   "_solver",
   ".",
   "min",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ")",
   "elif",
   "policy",
   "==",
   "'SAMPLED'",
   ":",
   "m",
   ",",
   "M",
   "=",
   "self",
   ".",
   "_solver",
   ".",
   "minmax",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ")",
   "vals",
   "+=",
   "[",
   "m",
   ",",
   "M",
   "]",
   "if",
   "M",
   "-",
   "m",
   ">",
   "3",
   ":",
   "if",
   "self",
   ".",
   "_solver",
   ".",
   "can_be_true",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   "==",
   "(",
   "m",
   "+",
   "M",
   ")",
   "//",
   "2",
   ")",
   ":",
   "vals",
   ".",
   "append",
   "(",
   "(",
   "m",
   "+",
   "M",
   ")",
   "//",
   "2",
   ")",
   "if",
   "M",
   "-",
   "m",
   ">",
   "100",
   ":",
   "for",
   "i",
   "in",
   "(",
   "0",
   ",",
   "1",
   ",",
   "2",
   ",",
   "5",
   ",",
   "32",
   ",",
   "64",
   ",",
   "128",
   ",",
   "320",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_solver",
   ".",
   "can_be_true",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   "==",
   "m",
   "+",
   "i",
   ")",
   ":",
   "vals",
   ".",
   "append",
   "(",
   "m",
   "+",
   "i",
   ")",
   "if",
   "maxcount",
   "<=",
   "len",
   "(",
   "vals",
   ")",
   ":",
   "break",
   "if",
   "M",
   "-",
   "m",
   ">",
   "1000",
   "and",
   "maxcount",
   ">",
   "len",
   "(",
   "vals",
   ")",
   ":",
   "vals",
   "+=",
   "self",
   ".",
   "_solver",
   ".",
   "get_all_values",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ",",
   "maxcnt",
   "=",
   "maxcount",
   "-",
   "len",
   "(",
   "vals",
   ")",
   ",",
   "silent",
   "=",
   "True",
   ")",
   "elif",
   "policy",
   "==",
   "'ONE'",
   ":",
   "vals",
   "=",
   "[",
   "self",
   ".",
   "_solver",
   ".",
   "get_value",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ")",
   "]",
   "else",
   ":",
   "assert",
   "policy",
   "==",
   "'ALL'",
   "vals",
   "=",
   "solver",
   ".",
   "get_all_values",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "symbolic",
   ",",
   "maxcnt",
   "=",
   "maxcount",
   ",",
   "silent",
   "=",
   "True",
   ")",
   "return",
   "tuple",
   "(",
   "set",
   "(",
   "vals",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-136",
  "nl_tokens": [
   "Checks",
   "for",
   "duplicate",
   "inputs",
   "and",
   "if",
   "there",
   "are",
   "any",
   "remove",
   "one",
   "and",
   "set",
   "the",
   "output",
   "to",
   "the",
   "max",
   "of",
   "the",
   "two",
   "outputs",
   "Args",
   ":",
   "inputs",
   "(",
   "list<list<float",
   ">>",
   ")",
   ":",
   "Array",
   "of",
   "input",
   "vectors",
   "outputs",
   "(",
   "list<list<float",
   ">>",
   ")",
   ":",
   "Array",
   "of",
   "output",
   "vectors",
   "Returns",
   ":",
   "tuple<inputs",
   "outputs",
   ">",
   ":",
   "The",
   "modified",
   "inputs",
   "and",
   "outputs"
  ],
  "pl_tokens": [
   "def",
   "resolve_conflicts",
   "(",
   "inputs",
   ",",
   "outputs",
   ")",
   ":",
   "data",
   "=",
   "{",
   "}",
   "for",
   "inp",
   ",",
   "out",
   "in",
   "zip",
   "(",
   "inputs",
   ",",
   "outputs",
   ")",
   ":",
   "tup",
   "=",
   "tuple",
   "(",
   "inp",
   ")",
   "if",
   "tup",
   "in",
   "data",
   ":",
   "data",
   "[",
   "tup",
   "]",
   ".",
   "append",
   "(",
   "out",
   ")",
   "else",
   ":",
   "data",
   "[",
   "tup",
   "]",
   "=",
   "[",
   "out",
   "]",
   "inputs",
   ",",
   "outputs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "for",
   "inp",
   ",",
   "outs",
   "in",
   "data",
   ".",
   "items",
   "(",
   ")",
   ":",
   "inputs",
   ".",
   "append",
   "(",
   "list",
   "(",
   "inp",
   ")",
   ")",
   "combined",
   "=",
   "[",
   "0",
   "]",
   "*",
   "len",
   "(",
   "outs",
   "[",
   "0",
   "]",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "combined",
   ")",
   ")",
   ":",
   "combined",
   "[",
   "i",
   "]",
   "=",
   "<mask>",
   "(",
   "j",
   "[",
   "i",
   "]",
   "for",
   "j",
   "in",
   "outs",
   ")",
   "outputs",
   ".",
   "append",
   "(",
   "combined",
   ")",
   "return",
   "inputs",
   ",",
   "outputs"
  ]
 },
 {
  "idx": "maxmin-137",
  "nl_tokens": [
   "A",
   "new",
   "simplified",
   "version",
   "of",
   "prechecks",
   "func",
   "before",
   "demux",
   "Checks",
   "before",
   "starting",
   "analysis",
   ".",
   "-----------------------------------",
   "1",
   ")",
   "Is",
   "there",
   "data",
   "in",
   "raw_fastq_path",
   "2",
   ")",
   "Is",
   "there",
   "a",
   "barcode",
   "file",
   "3",
   ")",
   "Is",
   "there",
   "a",
   "workdir",
   "and",
   "fastqdir",
   "4",
   ")",
   "remove",
   "old",
   "fastq",
   "/",
   "tmp_sample_R",
   "*",
   "_",
   "dirs",
   "/",
   "5",
   ")",
   "return",
   "file",
   "names",
   "as",
   "pairs",
   "(",
   "r1",
   "r2",
   ")",
   "or",
   "fakepairs",
   "(",
   "r1",
   "1",
   ")",
   "6",
   ")",
   "get",
   "ambiguous",
   "cutter",
   "resolutions",
   "7",
   ")",
   "get",
   "optim",
   "size"
  ],
  "pl_tokens": [
   "def",
   "prechecks2",
   "(",
   "data",
   ",",
   "force",
   ")",
   ":",
   "## check for data using glob for fuzzy matching",
   "if",
   "not",
   "glob",
   ".",
   "glob",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"raw_fastq_path\"",
   "]",
   ")",
   ":",
   "raise",
   "IPyradWarningExit",
   "(",
   "NO_RAWS",
   ".",
   "format",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"raw_fastq_path\"",
   "]",
   ")",
   ")",
   "## find longest barcode",
   "try",
   ":",
   "## Handle 3rad multi-barcodes. Gets len of the first one. ",
   "## Should be harmless for single barcode data",
   "barlens",
   "=",
   "[",
   "len",
   "(",
   "i",
   ".",
   "split",
   "(",
   "\"+\"",
   ")",
   "[",
   "0",
   "]",
   ")",
   "for",
   "i",
   "in",
   "data",
   ".",
   "barcodes",
   ".",
   "values",
   "(",
   ")",
   "]",
   "if",
   "len",
   "(",
   "set",
   "(",
   "barlens",
   ")",
   ")",
   "==",
   "1",
   ":",
   "longbar",
   "=",
   "(",
   "barlens",
   "[",
   "0",
   "]",
   ",",
   "'same'",
   ")",
   "else",
   ":",
   "longbar",
   "=",
   "(",
   "<mask>",
   "(",
   "barlens",
   ")",
   ",",
   "'diff'",
   ")",
   "## For 3rad we need to add the length info for barcodes_R2",
   "if",
   "\"3rad\"",
   "in",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"datatype\"",
   "]",
   ":",
   "barlens",
   "=",
   "[",
   "len",
   "(",
   "i",
   ".",
   "split",
   "(",
   "\"+\"",
   ")",
   "[",
   "1",
   "]",
   ")",
   "for",
   "i",
   "in",
   "data",
   ".",
   "barcodes",
   ".",
   "values",
   "(",
   ")",
   "]",
   "longbar",
   "=",
   "(",
   "longbar",
   "[",
   "0",
   "]",
   ",",
   "longbar",
   "[",
   "1",
   "]",
   ",",
   "max",
   "(",
   "barlens",
   ")",
   ")",
   "except",
   "ValueError",
   ":",
   "raise",
   "IPyradWarningExit",
   "(",
   "NO_BARS",
   ".",
   "format",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"barcodes_path\"",
   "]",
   ")",
   ")",
   "## setup dirs: [workdir] and a [workdir/name_fastqs]",
   "opj",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "## create project dir",
   "pdir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "realpath",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"project_dir\"",
   "]",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "pdir",
   ")",
   ":",
   "os",
   ".",
   "mkdir",
   "(",
   "pdir",
   ")",
   "## create fastq dir",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   "=",
   "opj",
   "(",
   "pdir",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\"_fastqs\"",
   ")",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   ")",
   "and",
   "force",
   ":",
   "print",
   "(",
   "OVERWRITING_FASTQS",
   ".",
   "format",
   "(",
   "*",
   "*",
   "{",
   "\"spacer\"",
   ":",
   "data",
   ".",
   "_spacer",
   "}",
   ")",
   ")",
   "shutil",
   ".",
   "rmtree",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   ")",
   ":",
   "os",
   ".",
   "mkdir",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   ")",
   "## insure no leftover tmp files from a previous run (there shouldn't be)",
   "oldtmps",
   "=",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   ",",
   "\"tmp_*_R1_\"",
   ")",
   ")",
   "oldtmps",
   "+=",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "fastqs",
   ",",
   "\"tmp_*_R2_\"",
   ")",
   ")",
   "for",
   "oldtmp",
   "in",
   "oldtmps",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "oldtmp",
   ")",
   "## gather raw sequence filenames (people want this to be flexible ...)",
   "if",
   "'pair'",
   "in",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"datatype\"",
   "]",
   ":",
   "raws",
   "=",
   "combinefiles",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"raw_fastq_path\"",
   "]",
   ")",
   "else",
   ":",
   "raws",
   "=",
   "zip",
   "(",
   "glob",
   ".",
   "glob",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"raw_fastq_path\"",
   "]",
   ")",
   ",",
   "iter",
   "(",
   "int",
   ",",
   "1",
   ")",
   ")",
   "## returns a list of both resolutions of cut site 1",
   "## (TGCAG, ) ==> [TGCAG, ]",
   "## (TWGC, ) ==> [TAGC, TTGC]",
   "## (TWGC, AATT) ==> [TAGC, TTGC]",
   "cutters",
   "=",
   "[",
   "ambigcutters",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"restriction_overhang\"",
   "]",
   "]",
   "print",
   "(",
   "cutters",
   ")",
   "assert",
   "cutters",
   ",",
   "\"Must enter a `restriction_overhang` for demultiplexing.\"",
   "## get matchdict",
   "matchdict",
   "=",
   "inverse_barcodes",
   "(",
   "data",
   ")",
   "## return all",
   "return",
   "raws",
   ",",
   "longbar",
   ",",
   "cutters",
   ",",
   "matchdict"
  ]
 },
 {
  "idx": "maxmin-138",
  "nl_tokens": [
   "stats",
   "cleanup",
   "and",
   "link",
   "to",
   "samples"
  ],
  "pl_tokens": [
   "def",
   "sample_cleanup",
   "(",
   "data",
   ",",
   "sample",
   ")",
   ":",
   "## get maxlen and depths array from clusters",
   "maxlens",
   ",",
   "depths",
   "=",
   "get_quick_depths",
   "(",
   "data",
   ",",
   "sample",
   ")",
   "try",
   ":",
   "depths",
   ".",
   "<mask>",
   "(",
   ")",
   "except",
   "ValueError",
   ":",
   "## If depths is an empty array max() will raise",
   "print",
   "(",
   "\"    no clusters found for {}\"",
   ".",
   "format",
   "(",
   "sample",
   ".",
   "name",
   ")",
   ")",
   "return",
   "## Test if depths is non-empty, but just full of zeros.",
   "if",
   "depths",
   ".",
   "max",
   "(",
   ")",
   ":",
   "## store which min was used to calculate hidepth here",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"hidepth_min\"",
   "]",
   "=",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"mindepth_majrule\"",
   "]",
   "## If our longest sequence is longer than the current max_fragment_length",
   "## then update max_fragment_length. For assurance we require that",
   "## max len is 4 greater than maxlen, to allow for pair separators.",
   "hidepths",
   "=",
   "depths",
   ">=",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"mindepth_majrule\"",
   "]",
   "maxlens",
   "=",
   "maxlens",
   "[",
   "hidepths",
   "]",
   "## Handle the case where there are no hidepth clusters",
   "if",
   "maxlens",
   ".",
   "any",
   "(",
   ")",
   ":",
   "maxlen",
   "=",
   "int",
   "(",
   "maxlens",
   ".",
   "mean",
   "(",
   ")",
   "+",
   "(",
   "2.",
   "*",
   "maxlens",
   ".",
   "std",
   "(",
   ")",
   ")",
   ")",
   "else",
   ":",
   "maxlen",
   "=",
   "0",
   "if",
   "maxlen",
   ">",
   "data",
   ".",
   "_hackersonly",
   "[",
   "\"max_fragment_length\"",
   "]",
   ":",
   "data",
   ".",
   "_hackersonly",
   "[",
   "\"max_fragment_length\"",
   "]",
   "=",
   "maxlen",
   "+",
   "4",
   "## make sense of stats",
   "keepmj",
   "=",
   "depths",
   "[",
   "depths",
   ">=",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"mindepth_majrule\"",
   "]",
   "]",
   "keepstat",
   "=",
   "depths",
   "[",
   "depths",
   ">=",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"mindepth_statistical\"",
   "]",
   "]",
   "## sample summary stat assignments",
   "sample",
   ".",
   "stats",
   "[",
   "\"state\"",
   "]",
   "=",
   "3",
   "sample",
   ".",
   "stats",
   "[",
   "\"clusters_total\"",
   "]",
   "=",
   "depths",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "sample",
   ".",
   "stats",
   "[",
   "\"clusters_hidepth\"",
   "]",
   "=",
   "keepmj",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "## store depths histogram as a dict. Limit to first 25 bins",
   "bars",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "depths",
   ",",
   "bins",
   "=",
   "range",
   "(",
   "1",
   ",",
   "26",
   ")",
   ")",
   "sample",
   ".",
   "depths",
   "=",
   "{",
   "int",
   "(",
   "i",
   ")",
   ":",
   "v",
   "for",
   "i",
   ",",
   "v",
   "in",
   "zip",
   "(",
   "bins",
   ",",
   "bars",
   ")",
   "if",
   "v",
   "}",
   "## sample stat assignments",
   "## Trap numpy warnings (\"mean of empty slice\") printed by samples",
   "## with few reads.",
   "with",
   "warnings",
   ".",
   "catch_warnings",
   "(",
   ")",
   ":",
   "warnings",
   ".",
   "simplefilter",
   "(",
   "\"ignore\"",
   ",",
   "category",
   "=",
   "RuntimeWarning",
   ")",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"merged_pairs\"",
   "]",
   "=",
   "sample",
   ".",
   "stats",
   ".",
   "reads_merged",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"clusters_total\"",
   "]",
   "=",
   "depths",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "try",
   ":",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"clusters_hidepth\"",
   "]",
   "=",
   "int",
   "(",
   "sample",
   ".",
   "stats",
   "[",
   "\"clusters_hidepth\"",
   "]",
   ")",
   "except",
   "ValueError",
   ":",
   "## Handle clusters_hidepth == NaN",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"clusters_hidepth\"",
   "]",
   "=",
   "0",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"avg_depth_total\"",
   "]",
   "=",
   "depths",
   ".",
   "mean",
   "(",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"total depth {}\"",
   ".",
   "format",
   "(",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"avg_depth_total\"",
   "]",
   ")",
   ")",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"avg_depth_mj\"",
   "]",
   "=",
   "keepmj",
   ".",
   "mean",
   "(",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"mj depth {}\"",
   ".",
   "format",
   "(",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"avg_depth_mj\"",
   "]",
   ")",
   ")",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"avg_depth_stat\"",
   "]",
   "=",
   "keepstat",
   ".",
   "mean",
   "(",
   ")",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"sd_depth_total\"",
   "]",
   "=",
   "depths",
   ".",
   "std",
   "(",
   ")",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"sd_depth_mj\"",
   "]",
   "=",
   "keepmj",
   ".",
   "std",
   "(",
   ")",
   "sample",
   ".",
   "stats_dfs",
   ".",
   "s3",
   "[",
   "\"sd_depth_stat\"",
   "]",
   "=",
   "keepstat",
   ".",
   "std",
   "(",
   ")",
   "else",
   ":",
   "print",
   "(",
   "\"    no clusters found for {}\"",
   ".",
   "format",
   "(",
   "sample",
   ".",
   "name",
   ")",
   ")",
   "## Get some stats from the bam files",
   "## This is moderately hackish. samtools flagstat returns",
   "## the number of reads in the bam file as the first element",
   "## of the first line, this call makes this assumption.",
   "if",
   "not",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"assembly_method\"",
   "]",
   "==",
   "\"denovo\"",
   ":",
   "refmap_stats",
   "(",
   "data",
   ",",
   "sample",
   ")",
   "log_level",
   "=",
   "logging",
   ".",
   "getLevelName",
   "(",
   "LOGGER",
   ".",
   "getEffectiveLevel",
   "(",
   ")",
   ")",
   "if",
   "not",
   "log_level",
   "==",
   "\"DEBUG\"",
   ":",
   "## Clean up loose files only if not in DEBUG",
   "##- edits/*derep, utemp, *utemp.sort, *htemp, *clust.gz",
   "derepfile",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "edits",
   ",",
   "sample",
   ".",
   "name",
   "+",
   "\"_derep.fastq\"",
   ")",
   "mergefile",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "edits",
   ",",
   "sample",
   ".",
   "name",
   "+",
   "\"_merged_.fastq\"",
   ")",
   "uhandle",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "clusts",
   ",",
   "sample",
   ".",
   "name",
   "+",
   "\".utemp\"",
   ")",
   "usort",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "clusts",
   ",",
   "sample",
   ".",
   "name",
   "+",
   "\".utemp.sort\"",
   ")",
   "hhandle",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "clusts",
   ",",
   "sample",
   ".",
   "name",
   "+",
   "\".htemp\"",
   ")",
   "clusters",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "clusts",
   ",",
   "sample",
   ".",
   "name",
   "+",
   "\".clust.gz\"",
   ")",
   "for",
   "f",
   "in",
   "[",
   "derepfile",
   ",",
   "mergefile",
   ",",
   "uhandle",
   ",",
   "usort",
   ",",
   "hhandle",
   ",",
   "clusters",
   "]",
   ":",
   "try",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "f",
   ")",
   "except",
   ":",
   "pass"
  ]
 },
 {
  "idx": "maxmin-139",
  "nl_tokens": [
   "Uploads",
   "an",
   "application",
   "archive",
   "version",
   "to",
   "s3"
  ],
  "pl_tokens": [
   "def",
   "upload_archive",
   "(",
   "self",
   ",",
   "filename",
   ",",
   "key",
   ",",
   "auto_create_bucket",
   "=",
   "True",
   ")",
   ":",
   "try",
   ":",
   "bucket",
   "=",
   "self",
   ".",
   "s3",
   ".",
   "get_bucket",
   "(",
   "self",
   ".",
   "aws",
   ".",
   "bucket",
   ")",
   "if",
   "(",
   "(",
   "self",
   ".",
   "aws",
   ".",
   "region",
   "!=",
   "'us-east-1'",
   "and",
   "self",
   ".",
   "aws",
   ".",
   "region",
   "!=",
   "'eu-west-1'",
   ")",
   "and",
   "bucket",
   ".",
   "get_location",
   "(",
   ")",
   "!=",
   "self",
   ".",
   "aws",
   ".",
   "region",
   ")",
   "or",
   "(",
   "self",
   ".",
   "aws",
   ".",
   "region",
   "==",
   "'us-east-1'",
   "and",
   "bucket",
   ".",
   "get_location",
   "(",
   ")",
   "!=",
   "''",
   ")",
   "or",
   "(",
   "self",
   ".",
   "aws",
   ".",
   "region",
   "==",
   "'eu-west-1'",
   "and",
   "bucket",
   ".",
   "get_location",
   "(",
   ")",
   "!=",
   "'eu-west-1'",
   ")",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Existing bucket doesn't match region\"",
   ")",
   "except",
   "S3ResponseError",
   ":",
   "bucket",
   "=",
   "self",
   ".",
   "s3",
   ".",
   "create_bucket",
   "(",
   "self",
   ".",
   "aws",
   ".",
   "bucket",
   ",",
   "location",
   "=",
   "self",
   ".",
   "aws",
   ".",
   "region",
   ")",
   "def",
   "__report_upload_progress",
   "(",
   "sent",
   ",",
   "total",
   ")",
   ":",
   "if",
   "not",
   "sent",
   ":",
   "sent",
   "=",
   "0",
   "if",
   "not",
   "total",
   ":",
   "total",
   "=",
   "0",
   "out",
   "(",
   "\"Uploaded \"",
   "+",
   "str",
   "(",
   "sent",
   ")",
   "+",
   "\" bytes of \"",
   "+",
   "str",
   "(",
   "total",
   ")",
   "+",
   "\" (\"",
   "+",
   "str",
   "(",
   "int",
   "(",
   "float",
   "(",
   "<mask>",
   "(",
   "1",
   ",",
   "sent",
   ")",
   ")",
   "/",
   "float",
   "(",
   "total",
   ")",
   "*",
   "100",
   ")",
   ")",
   "+",
   "\"%)\"",
   ")",
   "# upload the new version",
   "k",
   "=",
   "Key",
   "(",
   "bucket",
   ")",
   "k",
   ".",
   "key",
   "=",
   "self",
   ".",
   "aws",
   ".",
   "bucket_path",
   "+",
   "key",
   "k",
   ".",
   "set_metadata",
   "(",
   "'time'",
   ",",
   "str",
   "(",
   "time",
   "(",
   ")",
   ")",
   ")",
   "k",
   ".",
   "set_contents_from_filename",
   "(",
   "filename",
   ",",
   "cb",
   "=",
   "__report_upload_progress",
   ",",
   "num_cb",
   "=",
   "10",
   ")"
  ]
 },
 {
  "idx": "maxmin-140",
  "nl_tokens": [
   "Returns",
   "the",
   "darkest",
   "color",
   "from",
   "the",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "_darkest",
   "(",
   "self",
   ")",
   ":",
   "<mask>",
   ",",
   "n",
   "=",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ")",
   ",",
   "3.0",
   "for",
   "clr",
   "in",
   "self",
   ":",
   "if",
   "clr",
   ".",
   "r",
   "+",
   "clr",
   ".",
   "g",
   "+",
   "clr",
   ".",
   "b",
   "<",
   "n",
   ":",
   "min",
   ",",
   "n",
   "=",
   "clr",
   ",",
   "clr",
   ".",
   "r",
   "+",
   "clr",
   ".",
   "g",
   "+",
   "clr",
   ".",
   "b",
   "return",
   "min"
  ]
 },
 {
  "idx": "maxmin-141",
  "nl_tokens": [
   "rects",
   ":",
   "a",
   "list",
   "of",
   "rects",
   "such",
   "as",
   "[",
   "(",
   "0",
   "0",
   "10",
   "10",
   ")",
   "(",
   "10",
   "10",
   "20",
   "20",
   ")",
   "(",
   "x",
   "y",
   "width",
   "height",
   ")",
   "]",
   ".",
   "Return",
   "list",
   "a",
   "list",
   "whose",
   "elements",
   "are",
   "ctypes",
   ".",
   "Array",
   "which",
   "is",
   "an",
   "iterable",
   "array",
   "of",
   "int",
   "values",
   "in",
   "argb",
   "."
  ],
  "pl_tokens": [
   "def",
   "GetPixelColorsOfRects",
   "(",
   "self",
   ",",
   "rects",
   ":",
   "list",
   ")",
   "->",
   "list",
   ":",
   "rects2",
   "=",
   "[",
   "(",
   "x",
   ",",
   "y",
   ",",
   "x",
   "+",
   "width",
   ",",
   "y",
   "+",
   "height",
   ")",
   "for",
   "x",
   ",",
   "y",
   ",",
   "width",
   ",",
   "height",
   "in",
   "rects",
   "]",
   "left",
   ",",
   "top",
   ",",
   "right",
   ",",
   "bottom",
   "=",
   "zip",
   "(",
   "*",
   "rects2",
   ")",
   "left",
   ",",
   "top",
   ",",
   "right",
   ",",
   "bottom",
   "=",
   "<mask>",
   "(",
   "left",
   ")",
   ",",
   "min",
   "(",
   "top",
   ")",
   ",",
   "max",
   "(",
   "right",
   ")",
   ",",
   "max",
   "(",
   "bottom",
   ")",
   "width",
   ",",
   "height",
   "=",
   "right",
   "-",
   "left",
   ",",
   "bottom",
   "-",
   "top",
   "allColors",
   "=",
   "self",
   ".",
   "GetPixelColorsOfRect",
   "(",
   "left",
   ",",
   "top",
   ",",
   "width",
   ",",
   "height",
   ")",
   "colorsOfRects",
   "=",
   "[",
   "]",
   "for",
   "x",
   ",",
   "y",
   ",",
   "w",
   ",",
   "h",
   "in",
   "rects",
   ":",
   "x",
   "-=",
   "left",
   "y",
   "-=",
   "top",
   "colors",
   "=",
   "[",
   "]",
   "for",
   "row",
   "in",
   "range",
   "(",
   "h",
   ")",
   ":",
   "colors",
   ".",
   "extend",
   "(",
   "allColors",
   "[",
   "(",
   "y",
   "+",
   "row",
   ")",
   "*",
   "width",
   "+",
   "x",
   ":",
   "(",
   "y",
   "+",
   "row",
   ")",
   "*",
   "width",
   "+",
   "x",
   "+",
   "w",
   "]",
   ")",
   "colorsOfRects",
   ".",
   "append",
   "(",
   "colors",
   ")",
   "return",
   "colorsOfRects"
  ]
 },
 {
  "idx": "maxmin-142",
  "nl_tokens": [
   "Calls",
   "fortran",
   "functions",
   "to",
   "load",
   "CDF",
   "variable",
   "data"
  ],
  "pl_tokens": [
   "def",
   "_call_multi_fortran_z",
   "(",
   "self",
   ",",
   "names",
   ",",
   "data_types",
   ",",
   "rec_nums",
   ",",
   "dim_sizes",
   ",",
   "input_type_code",
   ",",
   "func",
   ",",
   "epoch",
   "=",
   "False",
   ",",
   "data_offset",
   "=",
   "None",
   ",",
   "epoch16",
   "=",
   "False",
   ")",
   ":",
   "# isolate input type code variables from total supplied types",
   "idx",
   ",",
   "=",
   "np",
   ".",
   "where",
   "(",
   "data_types",
   "==",
   "input_type_code",
   ")",
   "if",
   "len",
   "(",
   "idx",
   ")",
   ">",
   "0",
   ":",
   "# read all data of a given type at once",
   "max_rec",
   "=",
   "rec_nums",
   "[",
   "idx",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "sub_names",
   "=",
   "np",
   ".",
   "array",
   "(",
   "names",
   ")",
   "[",
   "idx",
   "]",
   "sub_sizes",
   "=",
   "dim_sizes",
   "[",
   "idx",
   "]",
   "status",
   ",",
   "data",
   "=",
   "func",
   "(",
   "self",
   ".",
   "fname",
   ",",
   "sub_names",
   ".",
   "tolist",
   "(",
   ")",
   ",",
   "sub_sizes",
   ",",
   "sub_sizes",
   ".",
   "sum",
   "(",
   ")",
   ",",
   "max_rec",
   ",",
   "len",
   "(",
   "sub_names",
   ")",
   ")",
   "if",
   "status",
   "==",
   "0",
   ":",
   "# account for quirks of CDF data storage for certain types",
   "if",
   "data_offset",
   "is",
   "not",
   "None",
   ":",
   "data",
   "=",
   "data",
   ".",
   "astype",
   "(",
   "int",
   ")",
   "idx",
   ",",
   "idy",
   ",",
   "=",
   "np",
   ".",
   "where",
   "(",
   "data",
   "<",
   "0",
   ")",
   "data",
   "[",
   "idx",
   ",",
   "idy",
   "]",
   "+=",
   "data_offset",
   "if",
   "epoch",
   ":",
   "# account for difference in seconds between",
   "# CDF epoch and python's epoch, leap year in there",
   "# (datetime(1971,1,2) - ",
   "#      datetime(1,1,1)).total_seconds()*1000",
   "data",
   "-=",
   "62167219200000",
   "data",
   "=",
   "data",
   ".",
   "astype",
   "(",
   "'<M8[ms]'",
   ")",
   "if",
   "epoch16",
   ":",
   "data",
   "[",
   "0",
   ":",
   ":",
   "2",
   ",",
   ":",
   "]",
   "-=",
   "62167219200",
   "data",
   "=",
   "data",
   "[",
   "0",
   ":",
   ":",
   "2",
   ",",
   ":",
   "]",
   "*",
   "1E9",
   "+",
   "data",
   "[",
   "1",
   ":",
   ":",
   "2",
   ",",
   ":",
   "]",
   "/",
   "1.E3",
   "data",
   "=",
   "data",
   ".",
   "astype",
   "(",
   "'datetime64[ns]'",
   ")",
   "sub_sizes",
   "/=",
   "2",
   "# all data of a type has been loaded and tweaked as necessary",
   "# parse through returned array to break out the individual variables",
   "# as appropriate",
   "self",
   ".",
   "_process_return_multi_z",
   "(",
   "data",
   ",",
   "sub_names",
   ",",
   "sub_sizes",
   ")",
   "else",
   ":",
   "raise",
   "IOError",
   "(",
   "fortran_cdf",
   ".",
   "statusreporter",
   "(",
   "status",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-143",
  "nl_tokens": [
   "Convert",
   "GRIB",
   "to",
   "Tif"
  ],
  "pl_tokens": [
   "def",
   "convertGribToTiff",
   "(",
   "listeFile",
   ",",
   "listParam",
   ",",
   "listLevel",
   ",",
   "liststep",
   ",",
   "grid",
   ",",
   "startDate",
   ",",
   "endDate",
   ",",
   "outFolder",
   ")",
   ":",
   "dicoValues",
   "=",
   "{",
   "}",
   "for",
   "l",
   "in",
   "listeFile",
   ":",
   "grbs",
   "=",
   "pygrib",
   ".",
   "open",
   "(",
   "l",
   ")",
   "grbs",
   ".",
   "seek",
   "(",
   "0",
   ")",
   "index",
   "=",
   "1",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "listLevel",
   ")",
   ",",
   "0",
   ",",
   "-",
   "1",
   ")",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "listParam",
   ")",
   "-",
   "1",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   ":",
   "grb",
   "=",
   "grbs",
   "[",
   "index",
   "]",
   "p",
   "=",
   "grb",
   ".",
   "name",
   ".",
   "replace",
   "(",
   "' '",
   ",",
   "'_'",
   ")",
   "if",
   "grb",
   ".",
   "level",
   "!=",
   "0",
   ":",
   "l",
   "=",
   "str",
   "(",
   "grb",
   ".",
   "level",
   ")",
   "+",
   "'_'",
   "+",
   "grb",
   ".",
   "typeOfLevel",
   "else",
   ":",
   "l",
   "=",
   "grb",
   ".",
   "typeOfLevel",
   "if",
   "p",
   "+",
   "'_'",
   "+",
   "l",
   "not",
   "in",
   "dicoValues",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "dicoValues",
   "[",
   "p",
   "+",
   "'_'",
   "+",
   "l",
   "]",
   "=",
   "[",
   "]",
   "dicoValues",
   "[",
   "p",
   "+",
   "'_'",
   "+",
   "l",
   "]",
   ".",
   "append",
   "(",
   "grb",
   ".",
   "values",
   ")",
   "shape",
   "=",
   "grb",
   ".",
   "values",
   ".",
   "shape",
   "lat",
   ",",
   "lon",
   "=",
   "grb",
   ".",
   "latlons",
   "(",
   ")",
   "geoparam",
   "=",
   "(",
   "lon",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "lat",
   ".",
   "max",
   "(",
   ")",
   ",",
   "grid",
   ",",
   "grid",
   ")",
   "index",
   "+=",
   "1",
   "nbJour",
   "=",
   "(",
   "endDate",
   "-",
   "startDate",
   ")",
   ".",
   "days",
   "+",
   "1",
   "#on joute des arrayNan si il manque des fichiers",
   "for",
   "s",
   "in",
   "range",
   "(",
   "0",
   ",",
   "(",
   "len",
   "(",
   "liststep",
   ")",
   "*",
   "nbJour",
   "-",
   "len",
   "(",
   "listeFile",
   ")",
   ")",
   ")",
   ":",
   "for",
   "k",
   "in",
   "dicoValues",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "dicoValues",
   "[",
   "k",
   "]",
   ".",
   "append",
   "(",
   "np",
   ".",
   "full",
   "(",
   "shape",
   ",",
   "np",
   ".",
   "nan",
   ")",
   ")",
   "#On \u00e9crit pour chacune des variables dans un fichier",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "dicoValues",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "-",
   "1",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   ":",
   "dictParam",
   "=",
   "dict",
   "(",
   "(",
   "k",
   ",",
   "dicoValues",
   "[",
   "dicoValues",
   ".",
   "keys",
   "(",
   ")",
   "[",
   "i",
   "]",
   "]",
   "[",
   "k",
   "]",
   ")",
   "for",
   "k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "dicoValues",
   "[",
   "dicoValues",
   ".",
   "keys",
   "(",
   ")",
   "[",
   "i",
   "]",
   "]",
   ")",
   ")",
   ")",
   "sorted",
   "(",
   "dictParam",
   ".",
   "items",
   "(",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   "outputImg",
   "=",
   "outFolder",
   "+",
   "'/'",
   "+",
   "dicoValues",
   ".",
   "keys",
   "(",
   ")",
   "[",
   "i",
   "]",
   "+",
   "'_'",
   "+",
   "startDate",
   ".",
   "strftime",
   "(",
   "'%Y%M%d'",
   ")",
   "+",
   "'_'",
   "+",
   "endDate",
   ".",
   "strftime",
   "(",
   "'%Y%M%d'",
   ")",
   "+",
   "'.tif'",
   "writeTiffFromDicoArray",
   "(",
   "dictParam",
   ",",
   "outputImg",
   ",",
   "shape",
   ",",
   "geoparam",
   ")",
   "for",
   "f",
   "in",
   "listeFile",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "f",
   ")"
  ]
 },
 {
  "idx": "maxmin-144",
  "nl_tokens": [
   "Actually",
   "calculates",
   "the",
   "stats",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_bls_stats",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "thistransdepth",
   ",",
   "thistransduration",
   ",",
   "ingressdurationfraction",
   ",",
   "nphasebins",
   ",",
   "thistransingressbin",
   ",",
   "thistransegressbin",
   ",",
   "thisbestperiod",
   ",",
   "thisnphasebins",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "verbose",
   "=",
   "False",
   ")",
   ":",
   "try",
   ":",
   "# try getting the minimum light epoch using the phase bin method",
   "me_epochbin",
   "=",
   "int",
   "(",
   "(",
   "thistransegressbin",
   "+",
   "thistransingressbin",
   ")",
   "/",
   "2.0",
   ")",
   "me_phases",
   "=",
   "(",
   "(",
   "stimes",
   "-",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "/",
   "thisbestperiod",
   "-",
   "npfloor",
   "(",
   "(",
   "stimes",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "/",
   "thisbestperiod",
   ")",
   ")",
   "me_phases_sortind",
   "=",
   "npargsort",
   "(",
   "me_phases",
   ")",
   "me_sorted_phases",
   "=",
   "me_phases",
   "[",
   "me_phases_sortind",
   "]",
   "me_sorted_times",
   "=",
   "stimes",
   "[",
   "me_phases_sortind",
   "]",
   "me_bins",
   "=",
   "nplinspace",
   "(",
   "0.0",
   ",",
   "1.0",
   ",",
   "thisnphasebins",
   ")",
   "me_bininds",
   "=",
   "npdigitize",
   "(",
   "me_sorted_phases",
   ",",
   "me_bins",
   ")",
   "me_centertransit_ind",
   "=",
   "me_bininds",
   "==",
   "me_epochbin",
   "me_centertransit_phase",
   "=",
   "(",
   "npmedian",
   "(",
   "me_sorted_phases",
   "[",
   "me_centertransit_ind",
   "]",
   ")",
   ")",
   "me_centertransit_timeloc",
   "=",
   "npwhere",
   "(",
   "npabs",
   "(",
   "me_sorted_phases",
   "-",
   "me_centertransit_phase",
   ")",
   "==",
   "npmin",
   "(",
   "npabs",
   "(",
   "me_sorted_phases",
   "-",
   "me_centertransit_phase",
   ")",
   ")",
   ")",
   "me_centertransit_time",
   "=",
   "me_sorted_times",
   "[",
   "me_centertransit_timeloc",
   "]",
   "if",
   "me_centertransit_time",
   ".",
   "size",
   ">",
   "1",
   ":",
   "LOGWARNING",
   "(",
   "'multiple possible times-of-center transits '",
   "'found for period %.7f, picking the first '",
   "'one from: %s'",
   "%",
   "(",
   "thisbestperiod",
   ",",
   "repr",
   "(",
   "me_centertransit_time",
   ")",
   ")",
   ")",
   "thisminepoch",
   "=",
   "me_centertransit_time",
   "[",
   "0",
   "]",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "LOGEXCEPTION",
   "(",
   "'could not determine the center time of transit for '",
   "'the phased LC, trying SavGol fit instead...'",
   ")",
   "# fit a Savitsky-Golay instead and get its minimum",
   "savfit",
   "=",
   "savgol_fit_magseries",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "thisbestperiod",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   "sigclip",
   "=",
   "None",
   ")",
   "thisminepoch",
   "=",
   "savfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'fitepoch'",
   "]",
   "if",
   "isinstance",
   "(",
   "thisminepoch",
   ",",
   "npndarray",
   ")",
   ":",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'minimum epoch is actually an array:\\n'",
   "'%s\\n'",
   "'instead of a float, '",
   "'are there duplicate time values '",
   "'in the original input? '",
   "'will use the first value in this array.'",
   "%",
   "repr",
   "(",
   "thisminepoch",
   ")",
   ")",
   "thisminepoch",
   "=",
   "thisminepoch",
   "[",
   "0",
   "]",
   "# set up trapezoid transit model to fit for this LC",
   "transitparams",
   "=",
   "[",
   "thisbestperiod",
   ",",
   "thisminepoch",
   ",",
   "thistransdepth",
   ",",
   "thistransduration",
   ",",
   "ingressdurationfraction",
   "*",
   "thistransduration",
   "]",
   "modelfit",
   "=",
   "traptransit_fit_magseries",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "transitparams",
   ",",
   "sigclip",
   "=",
   "None",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "verbose",
   "=",
   "verbose",
   ")",
   "# if the model fit succeeds, calculate SNR using the trapezoid model fit",
   "if",
   "modelfit",
   "and",
   "modelfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'finalparams'",
   "]",
   "is",
   "not",
   "None",
   ":",
   "fitparams",
   "=",
   "modelfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'finalparams'",
   "]",
   "fiterrs",
   "=",
   "modelfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'finalparamerrs'",
   "]",
   "modelmags",
   ",",
   "actualmags",
   ",",
   "modelphase",
   "=",
   "(",
   "modelfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'fitmags'",
   "]",
   ",",
   "modelfit",
   "[",
   "'magseries'",
   "]",
   "[",
   "'mags'",
   "]",
   ",",
   "modelfit",
   "[",
   "'magseries'",
   "]",
   "[",
   "'phase'",
   "]",
   ")",
   "subtractedmags",
   "=",
   "actualmags",
   "-",
   "modelmags",
   "subtractedrms",
   "=",
   "npstd",
   "(",
   "subtractedmags",
   ")",
   "fit_period",
   ",",
   "fit_epoch",
   ",",
   "fit_depth",
   ",",
   "fit_duration",
   ",",
   "fit_ingress_dur",
   "=",
   "(",
   "fitparams",
   ")",
   "npts_in_transit",
   "=",
   "modelfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'ntransitpoints'",
   "]",
   "transit_snr",
   "=",
   "(",
   "npsqrt",
   "(",
   "npts_in_transit",
   ")",
   "*",
   "npabs",
   "(",
   "fit_depth",
   "/",
   "subtractedrms",
   ")",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'refit best period: %.6f, '",
   "'refit center of transit: %.5f'",
   "%",
   "(",
   "fit_period",
   ",",
   "fit_epoch",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'npoints in transit: %s'",
   "%",
   "npts_in_transit",
   ")",
   "LOGINFO",
   "(",
   "'transit depth (delta): %.5f, '",
   "'frac transit length (q): %.3f, '",
   "' SNR: %.3f'",
   "%",
   "(",
   "fit_depth",
   ",",
   "fit_duration",
   ",",
   "transit_snr",
   ")",
   ")",
   "return",
   "{",
   "'period'",
   ":",
   "fit_period",
   ",",
   "'epoch'",
   ":",
   "fit_epoch",
   ",",
   "'snr'",
   ":",
   "transit_snr",
   ",",
   "'transitdepth'",
   ":",
   "fit_depth",
   ",",
   "'transitduration'",
   ":",
   "fit_duration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'transingressbin'",
   ":",
   "thistransingressbin",
   ",",
   "'transegressbin'",
   ":",
   "thistransegressbin",
   ",",
   "'npoints_in_transit'",
   ":",
   "npts_in_transit",
   ",",
   "'blsmodel'",
   ":",
   "modelmags",
   ",",
   "'subtractedmags'",
   ":",
   "subtractedmags",
   ",",
   "'phasedmags'",
   ":",
   "actualmags",
   ",",
   "'phases'",
   ":",
   "modelphase",
   ",",
   "'fitparams'",
   ":",
   "fitparams",
   ",",
   "'fiterrs'",
   ":",
   "fiterrs",
   ",",
   "'fitinfo'",
   ":",
   "modelfit",
   "}",
   "# if the model fit doesn't work, then do the SNR calculation the old way",
   "else",
   ":",
   "# phase using this epoch",
   "phased_magseries",
   "=",
   "phase_magseries_with_errs",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "thisbestperiod",
   ",",
   "thisminepoch",
   ",",
   "wrap",
   "=",
   "False",
   ",",
   "sort",
   "=",
   "True",
   ")",
   "tphase",
   "=",
   "phased_magseries",
   "[",
   "'phase'",
   "]",
   "tmags",
   "=",
   "phased_magseries",
   "[",
   "'mags'",
   "]",
   "# use the transit depth and duration to subtract the BLS transit",
   "# model from the phased mag series. we're centered about 0.0 as the",
   "# phase of the transit minimum so we need to look at stuff from",
   "# [0.0, transitphase] and [1.0-transitphase, 1.0]",
   "transitphase",
   "=",
   "thistransduration",
   "/",
   "2.0",
   "transitindices",
   "=",
   "(",
   "(",
   "tphase",
   "<",
   "transitphase",
   ")",
   "|",
   "(",
   "tphase",
   ">",
   "(",
   "1.0",
   "-",
   "transitphase",
   ")",
   ")",
   ")",
   "# this is the BLS model",
   "# constant = median(tmags) outside transit",
   "# constant = thistransitdepth inside transit",
   "blsmodel",
   "=",
   "npfull_like",
   "(",
   "tmags",
   ",",
   "npmedian",
   "(",
   "tmags",
   ")",
   ")",
   "if",
   "magsarefluxes",
   ":",
   "# eebls.f returns +ve transit depth for fluxes",
   "# so we need to subtract here to get fainter fluxes in transit",
   "blsmodel",
   "[",
   "transitindices",
   "]",
   "=",
   "(",
   "blsmodel",
   "[",
   "transitindices",
   "]",
   "-",
   "thistransdepth",
   ")",
   "else",
   ":",
   "# eebls.f returns -ve transit depth for magnitudes",
   "# so we need to subtract here to get fainter mags in transits",
   "blsmodel",
   "[",
   "transitindices",
   "]",
   "=",
   "(",
   "blsmodel",
   "[",
   "transitindices",
   "]",
   "-",
   "thistransdepth",
   ")",
   "# see __init__/get_snr_of_dip docstring for description of transit",
   "# SNR equation, which is what we use for `thissnr`.",
   "subtractedmags",
   "=",
   "tmags",
   "-",
   "blsmodel",
   "subtractedrms",
   "=",
   "npstd",
   "(",
   "subtractedmags",
   ")",
   "npts_in_transit",
   "=",
   "len",
   "(",
   "tmags",
   "[",
   "transitindices",
   "]",
   ")",
   "thissnr",
   "=",
   "(",
   "npsqrt",
   "(",
   "npts_in_transit",
   ")",
   "*",
   "npabs",
   "(",
   "thistransdepth",
   "/",
   "subtractedrms",
   ")",
   ")",
   "# tell user about stuff if verbose = True",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'refit best period: %.6f, '",
   "'refit center of transit: %.5f'",
   "%",
   "(",
   "thisbestperiod",
   ",",
   "thisminepoch",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'transit ingress phase = %.3f to %.3f'",
   "%",
   "(",
   "1.0",
   "-",
   "transitphase",
   ",",
   "1.0",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'transit egress phase = %.3f to %.3f'",
   "%",
   "(",
   "0.0",
   ",",
   "transitphase",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'npoints in transit: %s'",
   "%",
   "tmags",
   "[",
   "transitindices",
   "]",
   ".",
   "size",
   ")",
   "LOGINFO",
   "(",
   "'transit depth (delta): %.5f, '",
   "'frac transit length (q): %.3f, '",
   "' SNR: %.3f'",
   "%",
   "(",
   "thistransdepth",
   ",",
   "thistransduration",
   ",",
   "thissnr",
   ")",
   ")",
   "return",
   "{",
   "'period'",
   ":",
   "thisbestperiod",
   ",",
   "'epoch'",
   ":",
   "thisminepoch",
   ",",
   "'snr'",
   ":",
   "thissnr",
   ",",
   "'transitdepth'",
   ":",
   "thistransdepth",
   ",",
   "'transitduration'",
   ":",
   "thistransduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'transingressbin'",
   ":",
   "thistransingressbin",
   ",",
   "'transegressbin'",
   ":",
   "thistransegressbin",
   ",",
   "'blsmodel'",
   ":",
   "blsmodel",
   ",",
   "'subtractedmags'",
   ":",
   "subtractedmags",
   ",",
   "'phasedmags'",
   ":",
   "tmags",
   ",",
   "'phases'",
   ":",
   "tphase",
   "}"
  ]
 },
 {
  "idx": "maxmin-145",
  "nl_tokens": [
   "Get",
   "support",
   "size",
   "and",
   "drift",
   "polynomial",
   "for",
   "current",
   "set",
   "of",
   "params"
  ],
  "pl_tokens": [
   "def",
   "characterize_psf",
   "(",
   "self",
   ")",
   ":",
   "l",
   ",",
   "u",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "zrange",
   "[",
   "0",
   "]",
   ",",
   "self",
   ".",
   "param_dict",
   "[",
   "'psf-zslab'",
   "]",
   ")",
   ",",
   "self",
   ".",
   "zrange",
   "[",
   "1",
   "]",
   "size_l",
   ",",
   "drift_l",
   "=",
   "self",
   ".",
   "measure_size_drift",
   "(",
   "l",
   ",",
   "size",
   "=",
   "self",
   ".",
   "support",
   ")",
   "size_u",
   ",",
   "drift_u",
   "=",
   "self",
   ".",
   "measure_size_drift",
   "(",
   "u",
   ",",
   "size",
   "=",
   "self",
   ".",
   "support",
   ")",
   "self",
   ".",
   "drift_poly",
   "=",
   "np",
   ".",
   "polyfit",
   "(",
   "[",
   "l",
   ",",
   "u",
   "]",
   ",",
   "[",
   "drift_l",
   ",",
   "drift_u",
   "]",
   ",",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-146",
  "nl_tokens": [
   "The",
   "images",
   "are",
   "processed",
   "as",
   "follows",
   ":",
   "..",
   "They",
   "are",
   "cropped",
   "to",
   "24",
   "x",
   "24",
   "pixels",
   "centrally",
   "for",
   "evaluation",
   "or",
   "randomly",
   "for",
   "training",
   ".",
   "..",
   "They",
   "are",
   "approximately",
   "whitened",
   "to",
   "make",
   "the",
   "model",
   "insensitive",
   "to",
   "dynamic",
   "range",
   ".",
   "For",
   "training",
   "we",
   "additionally",
   "apply",
   "a",
   "series",
   "of",
   "random",
   "distortions",
   "to",
   "artificially",
   "increase",
   "the",
   "data",
   "set",
   "size",
   ":",
   "..",
   "Randomly",
   "flip",
   "the",
   "image",
   "from",
   "left",
   "to",
   "right",
   ".",
   "..",
   "Randomly",
   "distort",
   "the",
   "image",
   "brightness",
   "."
  ],
  "pl_tokens": [
   "def",
   "distort_fn",
   "(",
   "x",
   ",",
   "is_train",
   "=",
   "False",
   ")",
   ":",
   "# print('begin',x.shape, np.min(x), np.max(x))",
   "x",
   "=",
   "tl",
   ".",
   "prepro",
   ".",
   "crop",
   "(",
   "x",
   ",",
   "24",
   ",",
   "24",
   ",",
   "is_random",
   "=",
   "is_train",
   ")",
   "# print('after crop',x.shape, np.min(x), np.max(x))",
   "if",
   "is_train",
   ":",
   "# x = tl.prepro.zoom(x, zoom_range=(0.9, 1.0), is_random=True)",
   "# print('after zoom', x.shape, np.min(x), np.max(x))",
   "x",
   "=",
   "tl",
   ".",
   "prepro",
   ".",
   "flip_axis",
   "(",
   "x",
   ",",
   "axis",
   "=",
   "1",
   ",",
   "is_random",
   "=",
   "True",
   ")",
   "# print('after flip',x.shape, np.min(x), np.max(x))",
   "x",
   "=",
   "tl",
   ".",
   "prepro",
   ".",
   "brightness",
   "(",
   "x",
   ",",
   "gamma",
   "=",
   "0.1",
   ",",
   "gain",
   "=",
   "1",
   ",",
   "is_random",
   "=",
   "True",
   ")",
   "# print('after brightness',x.shape, np.min(x), np.max(x))",
   "# tmp = np.max(x)",
   "# x += np.random.uniform(-20, 20)",
   "# x /= tmp",
   "# normalize the image",
   "x",
   "=",
   "(",
   "x",
   "-",
   "np",
   ".",
   "mean",
   "(",
   "x",
   ")",
   ")",
   "/",
   "<mask>",
   "(",
   "np",
   ".",
   "std",
   "(",
   "x",
   ")",
   ",",
   "1e-5",
   ")",
   "# avoid values divided by 0",
   "# print('after norm', x.shape, np.min(x), np.max(x), np.mean(x))",
   "return",
   "x"
  ]
 },
 {
  "idx": "maxmin-147",
  "nl_tokens": [
   "Return",
   "the",
   "value",
   "with",
   "the",
   "greatest",
   "total",
   "weight",
   ".",
   ">>>",
   "weighted_mode",
   "(",
   "abbaa",
   "[",
   "1",
   "2",
   "3",
   "1",
   "2",
   "]",
   ")",
   "b"
  ],
  "pl_tokens": [
   "def",
   "weighted_mode",
   "(",
   "values",
   ",",
   "weights",
   ")",
   ":",
   "totals",
   "=",
   "defaultdict",
   "(",
   "int",
   ")",
   "for",
   "v",
   ",",
   "w",
   "in",
   "zip",
   "(",
   "values",
   ",",
   "weights",
   ")",
   ":",
   "totals",
   "[",
   "v",
   "]",
   "+=",
   "w",
   "return",
   "<mask>",
   "(",
   "totals",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "key",
   "=",
   "totals",
   ".",
   "get",
   ")"
  ]
 },
 {
  "idx": "maxmin-148",
  "nl_tokens": [
   "Draw",
   "the",
   "keypoint",
   "onto",
   "a",
   "given",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw_on_image",
   "(",
   "self",
   ",",
   "image",
   ",",
   "color",
   "=",
   "(",
   "0",
   ",",
   "255",
   ",",
   "0",
   ")",
   ",",
   "alpha",
   "=",
   "1.0",
   ",",
   "size",
   "=",
   "3",
   ",",
   "copy",
   "=",
   "True",
   ",",
   "raise_if_out_of_image",
   "=",
   "False",
   ")",
   ":",
   "if",
   "copy",
   ":",
   "image",
   "=",
   "np",
   ".",
   "copy",
   "(",
   "image",
   ")",
   "if",
   "image",
   ".",
   "ndim",
   "==",
   "2",
   ":",
   "assert",
   "ia",
   ".",
   "is_single_number",
   "(",
   "color",
   ")",
   ",",
   "(",
   "\"Got a 2D image. Expected then 'color' to be a single number, \"",
   "\"but got %s.\"",
   "%",
   "(",
   "str",
   "(",
   "color",
   ")",
   ",",
   ")",
   ")",
   "elif",
   "image",
   ".",
   "ndim",
   "==",
   "3",
   "and",
   "ia",
   ".",
   "is_single_number",
   "(",
   "color",
   ")",
   ":",
   "color",
   "=",
   "[",
   "color",
   "]",
   "*",
   "image",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   "input_dtype",
   "=",
   "image",
   ".",
   "dtype",
   "alpha_color",
   "=",
   "color",
   "if",
   "alpha",
   "<",
   "0.01",
   ":",
   "# keypoint invisible, nothing to do",
   "return",
   "image",
   "elif",
   "alpha",
   ">",
   "0.99",
   ":",
   "alpha",
   "=",
   "1",
   "else",
   ":",
   "image",
   "=",
   "image",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float32",
   ",",
   "copy",
   "=",
   "False",
   ")",
   "alpha_color",
   "=",
   "alpha",
   "*",
   "np",
   ".",
   "array",
   "(",
   "color",
   ")",
   "height",
   ",",
   "width",
   "=",
   "image",
   ".",
   "shape",
   "[",
   "0",
   ":",
   "2",
   "]",
   "y",
   ",",
   "x",
   "=",
   "self",
   ".",
   "y_int",
   ",",
   "self",
   ".",
   "x_int",
   "x1",
   "=",
   "<mask>",
   "(",
   "x",
   "-",
   "size",
   "//",
   "2",
   ",",
   "0",
   ")",
   "x2",
   "=",
   "min",
   "(",
   "x",
   "+",
   "1",
   "+",
   "size",
   "//",
   "2",
   ",",
   "width",
   ")",
   "y1",
   "=",
   "max",
   "(",
   "y",
   "-",
   "size",
   "//",
   "2",
   ",",
   "0",
   ")",
   "y2",
   "=",
   "min",
   "(",
   "y",
   "+",
   "1",
   "+",
   "size",
   "//",
   "2",
   ",",
   "height",
   ")",
   "x1_clipped",
   ",",
   "x2_clipped",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "[",
   "x1",
   ",",
   "x2",
   "]",
   ",",
   "0",
   ",",
   "width",
   ")",
   "y1_clipped",
   ",",
   "y2_clipped",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "[",
   "y1",
   ",",
   "y2",
   "]",
   ",",
   "0",
   ",",
   "height",
   ")",
   "x1_clipped_ooi",
   "=",
   "(",
   "x1_clipped",
   "<",
   "0",
   "or",
   "x1_clipped",
   ">=",
   "width",
   ")",
   "x2_clipped_ooi",
   "=",
   "(",
   "x2_clipped",
   "<",
   "0",
   "or",
   "x2_clipped",
   ">=",
   "width",
   "+",
   "1",
   ")",
   "y1_clipped_ooi",
   "=",
   "(",
   "y1_clipped",
   "<",
   "0",
   "or",
   "y1_clipped",
   ">=",
   "height",
   ")",
   "y2_clipped_ooi",
   "=",
   "(",
   "y2_clipped",
   "<",
   "0",
   "or",
   "y2_clipped",
   ">=",
   "height",
   "+",
   "1",
   ")",
   "x_ooi",
   "=",
   "(",
   "x1_clipped_ooi",
   "and",
   "x2_clipped_ooi",
   ")",
   "y_ooi",
   "=",
   "(",
   "y1_clipped_ooi",
   "and",
   "y2_clipped_ooi",
   ")",
   "x_zero_size",
   "=",
   "(",
   "x2_clipped",
   "-",
   "x1_clipped",
   ")",
   "<",
   "1",
   "# min size is 1px",
   "y_zero_size",
   "=",
   "(",
   "y2_clipped",
   "-",
   "y1_clipped",
   ")",
   "<",
   "1",
   "if",
   "not",
   "x_ooi",
   "and",
   "not",
   "y_ooi",
   "and",
   "not",
   "x_zero_size",
   "and",
   "not",
   "y_zero_size",
   ":",
   "if",
   "alpha",
   "==",
   "1",
   ":",
   "image",
   "[",
   "y1_clipped",
   ":",
   "y2_clipped",
   ",",
   "x1_clipped",
   ":",
   "x2_clipped",
   "]",
   "=",
   "color",
   "else",
   ":",
   "image",
   "[",
   "y1_clipped",
   ":",
   "y2_clipped",
   ",",
   "x1_clipped",
   ":",
   "x2_clipped",
   "]",
   "=",
   "(",
   "(",
   "1",
   "-",
   "alpha",
   ")",
   "*",
   "image",
   "[",
   "y1_clipped",
   ":",
   "y2_clipped",
   ",",
   "x1_clipped",
   ":",
   "x2_clipped",
   "]",
   "+",
   "alpha_color",
   ")",
   "else",
   ":",
   "if",
   "raise_if_out_of_image",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Cannot draw keypoint x=%.8f, y=%.8f on image with \"",
   "\"shape %s.\"",
   "%",
   "(",
   "y",
   ",",
   "x",
   ",",
   "image",
   ".",
   "shape",
   ")",
   ")",
   "if",
   "image",
   ".",
   "dtype",
   ".",
   "name",
   "!=",
   "input_dtype",
   ".",
   "name",
   ":",
   "if",
   "input_dtype",
   ".",
   "name",
   "==",
   "\"uint8\"",
   ":",
   "image",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "image",
   ",",
   "0",
   ",",
   "255",
   ",",
   "out",
   "=",
   "image",
   ")",
   "image",
   "=",
   "image",
   ".",
   "astype",
   "(",
   "input_dtype",
   ",",
   "copy",
   "=",
   "False",
   ")",
   "return",
   "image"
  ]
 },
 {
  "idx": "maxmin-149",
  "nl_tokens": [
   "write",
   "the",
   "phylip",
   "output",
   "file",
   "from",
   "the",
   "tmparr",
   "[",
   "seqarray",
   "]"
  ],
  "pl_tokens": [
   "def",
   "write_phy",
   "(",
   "data",
   ",",
   "sidx",
   ",",
   "pnames",
   ")",
   ":",
   "## grab seq data from tmparr",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "tmparrs",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "\"tmp-{}.h5\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "name",
   ")",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "tmparrs",
   ",",
   "'r'",
   ")",
   "as",
   "io5",
   ":",
   "seqarr",
   "=",
   "io5",
   "[",
   "\"seqarr\"",
   "]",
   "## trim to size b/c it was made longer than actual",
   "end",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "seqarr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "end",
   ")",
   ":",
   "end",
   "=",
   "end",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "end",
   "=",
   "seqarr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "## write to phylip ",
   "with",
   "open",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "phy",
   ",",
   "'w'",
   ")",
   "as",
   "out",
   ":",
   "## write header",
   "out",
   ".",
   "write",
   "(",
   "\"{} {}\\n\"",
   ".",
   "format",
   "(",
   "seqarr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "end",
   ")",
   ")",
   "## write data rows",
   "for",
   "idx",
   ",",
   "name",
   "in",
   "enumerate",
   "(",
   "pnames",
   ")",
   ":",
   "out",
   ".",
   "write",
   "(",
   "\"{}{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\"",
   ".",
   "join",
   "(",
   "seqarr",
   "[",
   "idx",
   ",",
   ":",
   "end",
   "]",
   ")",
   ")",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"finished writing phy in: %s\"",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")"
  ]
 },
 {
  "idx": "maxmin-150",
  "nl_tokens": [
   "Sample",
   "a",
   "single",
   "chain",
   "for",
   "OptGPSampler",
   "."
  ],
  "pl_tokens": [
   "def",
   "_sample_chain",
   "(",
   "args",
   ")",
   ":",
   "n",
   ",",
   "idx",
   "=",
   "args",
   "# has to be this way to work in Python 2.7",
   "center",
   "=",
   "sampler",
   ".",
   "center",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "(",
   "sampler",
   ".",
   "_seed",
   "+",
   "idx",
   ")",
   "%",
   "np",
   ".",
   "iinfo",
   "(",
   "np",
   ".",
   "int32",
   ")",
   ".",
   "<mask>",
   ")",
   "pi",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "sampler",
   ".",
   "n_warmup",
   ")",
   "prev",
   "=",
   "sampler",
   ".",
   "warmup",
   "[",
   "pi",
   ",",
   "]",
   "prev",
   "=",
   "step",
   "(",
   "sampler",
   ",",
   "center",
   ",",
   "prev",
   "-",
   "center",
   ",",
   "0.95",
   ")",
   "n_samples",
   "=",
   "max",
   "(",
   "sampler",
   ".",
   "n_samples",
   ",",
   "1",
   ")",
   "samples",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "n",
   ",",
   "center",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "sampler",
   ".",
   "thinning",
   "*",
   "n",
   "+",
   "1",
   ")",
   ":",
   "pi",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "sampler",
   ".",
   "n_warmup",
   ")",
   "delta",
   "=",
   "sampler",
   ".",
   "warmup",
   "[",
   "pi",
   ",",
   "]",
   "-",
   "center",
   "prev",
   "=",
   "step",
   "(",
   "sampler",
   ",",
   "prev",
   ",",
   "delta",
   ")",
   "if",
   "sampler",
   ".",
   "problem",
   ".",
   "homogeneous",
   "and",
   "(",
   "n_samples",
   "*",
   "sampler",
   ".",
   "thinning",
   "%",
   "sampler",
   ".",
   "nproj",
   "==",
   "0",
   ")",
   ":",
   "prev",
   "=",
   "sampler",
   ".",
   "_reproject",
   "(",
   "prev",
   ")",
   "center",
   "=",
   "sampler",
   ".",
   "_reproject",
   "(",
   "center",
   ")",
   "if",
   "i",
   "%",
   "sampler",
   ".",
   "thinning",
   "==",
   "0",
   ":",
   "samples",
   "[",
   "i",
   "//",
   "sampler",
   ".",
   "thinning",
   "-",
   "1",
   ",",
   "]",
   "=",
   "prev",
   "center",
   "=",
   "(",
   "(",
   "n_samples",
   "*",
   "center",
   ")",
   "/",
   "(",
   "n_samples",
   "+",
   "1",
   ")",
   "+",
   "prev",
   "/",
   "(",
   "n_samples",
   "+",
   "1",
   ")",
   ")",
   "n_samples",
   "+=",
   "1",
   "return",
   "(",
   "sampler",
   ".",
   "retries",
   ",",
   "samples",
   ")"
  ]
 },
 {
  "idx": "maxmin-151",
  "nl_tokens": [
   "Finds",
   "the",
   "closest",
   "object",
   "in",
   "(",
   "ra2",
   "dec2",
   ")",
   "to",
   "scalar",
   "coordinate",
   "pair",
   "(",
   "ra1",
   "dec1",
   ")",
   "and",
   "returns",
   "the",
   "distance",
   "in",
   "arcseconds",
   "."
  ],
  "pl_tokens": [
   "def",
   "xmatch_basic",
   "(",
   "ra1",
   ",",
   "dec1",
   ",",
   "ra2",
   ",",
   "dec2",
   ",",
   "match_radius",
   "=",
   "5.0",
   ")",
   ":",
   "min_dist_arcsec",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "great_circle_dist",
   "(",
   "ra1",
   ",",
   "dec1",
   ",",
   "ra2",
   ",",
   "dec2",
   ")",
   ")",
   "if",
   "(",
   "min_dist_arcsec",
   "<",
   "match_radius",
   ")",
   ":",
   "return",
   "(",
   "True",
   ",",
   "min_dist_arcsec",
   ")",
   "else",
   ":",
   "return",
   "(",
   "False",
   ",",
   "min_dist_arcsec",
   ")"
  ]
 },
 {
  "idx": "maxmin-152",
  "nl_tokens": [
   "Compare",
   "this",
   "and",
   "another",
   "LineString",
   "s",
   "coordinates",
   "."
  ],
  "pl_tokens": [
   "def",
   "coords_almost_equals",
   "(",
   "self",
   ",",
   "other",
   ",",
   "max_distance",
   "=",
   "1e-6",
   ",",
   "points_per_edge",
   "=",
   "8",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "other",
   ",",
   "LineString",
   ")",
   ":",
   "pass",
   "elif",
   "isinstance",
   "(",
   "other",
   ",",
   "tuple",
   ")",
   ":",
   "other",
   "=",
   "LineString",
   "(",
   "[",
   "other",
   "]",
   ")",
   "else",
   ":",
   "other",
   "=",
   "LineString",
   "(",
   "other",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   "==",
   "0",
   "and",
   "len",
   "(",
   "other",
   ".",
   "coords",
   ")",
   "==",
   "0",
   ":",
   "return",
   "True",
   "elif",
   "0",
   "in",
   "[",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   ",",
   "len",
   "(",
   "other",
   ".",
   "coords",
   ")",
   "]",
   ":",
   "# only one of the two line strings has no coords",
   "return",
   "False",
   "self_subd",
   "=",
   "self",
   ".",
   "subdivide",
   "(",
   "points_per_edge",
   ")",
   "other_subd",
   "=",
   "other",
   ".",
   "subdivide",
   "(",
   "points_per_edge",
   ")",
   "dist_self2other",
   "=",
   "self_subd",
   ".",
   "compute_pointwise_distances",
   "(",
   "other_subd",
   ")",
   "dist_other2self",
   "=",
   "other_subd",
   ".",
   "compute_pointwise_distances",
   "(",
   "self_subd",
   ")",
   "dist",
   "=",
   "<mask>",
   "(",
   "np",
   ".",
   "max",
   "(",
   "dist_self2other",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "dist_other2self",
   ")",
   ")",
   "return",
   "dist",
   "<",
   "max_distance"
  ]
 },
 {
  "idx": "maxmin-153",
  "nl_tokens": [
   "Simulate",
   "timestamps",
   "from",
   "emission",
   "trajectories",
   "."
  ],
  "pl_tokens": [
   "def",
   "_sim_timestamps",
   "(",
   "self",
   ",",
   "max_rate",
   ",",
   "bg_rate",
   ",",
   "emission",
   ",",
   "i_start",
   ",",
   "rs",
   ",",
   "ip_start",
   "=",
   "0",
   ",",
   "scale",
   "=",
   "10",
   ",",
   "sort",
   "=",
   "True",
   ")",
   ":",
   "counts_chunk",
   "=",
   "sim_timetrace_bg",
   "(",
   "emission",
   ",",
   "max_rate",
   ",",
   "bg_rate",
   ",",
   "self",
   ".",
   "t_step",
   ",",
   "rs",
   "=",
   "rs",
   ")",
   "nrows",
   "=",
   "emission",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "if",
   "bg_rate",
   "is",
   "not",
   "None",
   ":",
   "nrows",
   "+=",
   "1",
   "assert",
   "counts_chunk",
   ".",
   "shape",
   "==",
   "(",
   "nrows",
   ",",
   "emission",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "max_counts",
   "=",
   "counts_chunk",
   ".",
   "<mask>",
   "(",
   ")",
   "if",
   "max_counts",
   "==",
   "0",
   ":",
   "return",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int64",
   ")",
   ",",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int64",
   ")",
   "time_start",
   "=",
   "i_start",
   "*",
   "scale",
   "time_stop",
   "=",
   "time_start",
   "+",
   "counts_chunk",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "*",
   "scale",
   "ts_range",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "time_start",
   ",",
   "time_stop",
   ",",
   "scale",
   ",",
   "dtype",
   "=",
   "'int64'",
   ")",
   "# Loop for each particle to compute timestamps",
   "times_chunk_p",
   "=",
   "[",
   "]",
   "par_index_chunk_p",
   "=",
   "[",
   "]",
   "for",
   "ip",
   ",",
   "counts_chunk_ip",
   "in",
   "enumerate",
   "(",
   "counts_chunk",
   ")",
   ":",
   "# Compute timestamps for particle ip for all bins with counts",
   "times_c_ip",
   "=",
   "[",
   "]",
   "for",
   "v",
   "in",
   "range",
   "(",
   "1",
   ",",
   "max_counts",
   "+",
   "1",
   ")",
   ":",
   "times_c_ip",
   ".",
   "append",
   "(",
   "ts_range",
   "[",
   "counts_chunk_ip",
   ">=",
   "v",
   "]",
   ")",
   "# Stack the timestamps from different \"counts\"",
   "t",
   "=",
   "np",
   ".",
   "hstack",
   "(",
   "times_c_ip",
   ")",
   "# Append current particle",
   "times_chunk_p",
   ".",
   "append",
   "(",
   "t",
   ")",
   "par_index_chunk_p",
   ".",
   "append",
   "(",
   "np",
   ".",
   "full",
   "(",
   "t",
   ".",
   "size",
   ",",
   "ip",
   "+",
   "ip_start",
   ",",
   "dtype",
   "=",
   "'u1'",
   ")",
   ")",
   "# Merge the arrays of different particles",
   "times_chunk",
   "=",
   "np",
   ".",
   "hstack",
   "(",
   "times_chunk_p",
   ")",
   "par_index_chunk",
   "=",
   "np",
   ".",
   "hstack",
   "(",
   "par_index_chunk_p",
   ")",
   "if",
   "sort",
   ":",
   "# Sort timestamps inside the merged chunk",
   "index_sort",
   "=",
   "times_chunk",
   ".",
   "argsort",
   "(",
   "kind",
   "=",
   "'mergesort'",
   ")",
   "times_chunk",
   "=",
   "times_chunk",
   "[",
   "index_sort",
   "]",
   "par_index_chunk",
   "=",
   "par_index_chunk",
   "[",
   "index_sort",
   "]",
   "return",
   "times_chunk",
   ",",
   "par_index_chunk"
  ]
 },
 {
  "idx": "maxmin-154",
  "nl_tokens": [
   "Hack",
   "to",
   "act",
   "like",
   "clean_outcpd",
   "on",
   "zeta1",
   ".",
   "TopLevelNode",
   ".",
   "Take",
   "the",
   "max",
   "element",
   "in",
   "each",
   "to",
   "column",
   "set",
   "it",
   "to",
   "1",
   "and",
   "set",
   "all",
   "the",
   "other",
   "elements",
   "to",
   "0",
   ".",
   "Only",
   "called",
   "by",
   "inferRowMaxProd",
   "()",
   "and",
   "only",
   "needed",
   "if",
   "an",
   "updateRow",
   "()",
   "has",
   "been",
   "called",
   "since",
   "the",
   "last",
   "clean_outcpd",
   "()",
   "."
  ],
  "pl_tokens": [
   "def",
   "clean_outcpd",
   "(",
   "self",
   ")",
   ":",
   "m",
   "=",
   "self",
   ".",
   "hist_",
   ".",
   "toDense",
   "(",
   ")",
   "for",
   "j",
   "in",
   "xrange",
   "(",
   "m",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ":",
   "# For each column.",
   "cmax",
   "=",
   "m",
   "[",
   ":",
   ",",
   "j",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "if",
   "cmax",
   ":",
   "m",
   "[",
   ":",
   ",",
   "j",
   "]",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "m",
   "[",
   ":",
   ",",
   "j",
   "]",
   "==",
   "cmax",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "self",
   ".",
   "hack_",
   "=",
   "SparseMatrix",
   "(",
   "0",
   ",",
   "self",
   ".",
   "hist_",
   ".",
   "nCols",
   "(",
   ")",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "self",
   ".",
   "hack_",
   ".",
   "addRow",
   "(",
   "m",
   "[",
   "i",
   ",",
   ":",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-155",
  "nl_tokens": [
   "A",
   "loop",
   "iteration",
   "-",
   "check",
   "any",
   "scheduled",
   "events",
   "and",
   "I",
   "/",
   "O",
   "available",
   "and",
   "run",
   "the",
   "handlers",
   "."
  ],
  "pl_tokens": [
   "def",
   "loop_iteration",
   "(",
   "self",
   ",",
   "timeout",
   "=",
   "60",
   ")",
   ":",
   "next_timeout",
   ",",
   "sources_handled",
   "=",
   "self",
   ".",
   "_call_timeout_handlers",
   "(",
   ")",
   "if",
   "self",
   ".",
   "_quit",
   ":",
   "return",
   "sources_handled",
   "if",
   "self",
   ".",
   "_timeout",
   "is",
   "not",
   "None",
   ":",
   "timeout",
   "=",
   "<mask>",
   "(",
   "timeout",
   ",",
   "self",
   ".",
   "_timeout",
   ")",
   "if",
   "next_timeout",
   "is",
   "not",
   "None",
   ":",
   "timeout",
   "=",
   "min",
   "(",
   "next_timeout",
   ",",
   "timeout",
   ")",
   "for",
   "handler",
   "in",
   "list",
   "(",
   "self",
   ".",
   "_unprepared_handlers",
   ")",
   ":",
   "self",
   ".",
   "_configure_io_handler",
   "(",
   "handler",
   ")",
   "events",
   "=",
   "self",
   ".",
   "poll",
   ".",
   "poll",
   "(",
   "timeout",
   "*",
   "1000",
   ")",
   "self",
   ".",
   "_timeout",
   "=",
   "None",
   "for",
   "(",
   "fileno",
   ",",
   "event",
   ")",
   "in",
   "events",
   ":",
   "if",
   "event",
   "&",
   "select",
   ".",
   "POLLHUP",
   ":",
   "self",
   ".",
   "_handlers",
   "[",
   "fileno",
   "]",
   ".",
   "handle_hup",
   "(",
   ")",
   "if",
   "event",
   "&",
   "select",
   ".",
   "POLLNVAL",
   ":",
   "self",
   ".",
   "_handlers",
   "[",
   "fileno",
   "]",
   ".",
   "handle_nval",
   "(",
   ")",
   "if",
   "event",
   "&",
   "select",
   ".",
   "POLLIN",
   ":",
   "self",
   ".",
   "_handlers",
   "[",
   "fileno",
   "]",
   ".",
   "handle_read",
   "(",
   ")",
   "elif",
   "event",
   "&",
   "select",
   ".",
   "POLLERR",
   ":",
   "# if POLLIN was set this condition should be already handled",
   "self",
   ".",
   "_handlers",
   "[",
   "fileno",
   "]",
   ".",
   "handle_err",
   "(",
   ")",
   "if",
   "event",
   "&",
   "select",
   ".",
   "POLLOUT",
   ":",
   "self",
   ".",
   "_handlers",
   "[",
   "fileno",
   "]",
   ".",
   "handle_write",
   "(",
   ")",
   "sources_handled",
   "+=",
   "1",
   "self",
   ".",
   "_configure_io_handler",
   "(",
   "self",
   ".",
   "_handlers",
   "[",
   "fileno",
   "]",
   ")",
   "return",
   "sources_handled"
  ]
 },
 {
  "idx": "maxmin-156",
  "nl_tokens": [
   "Return",
   "the",
   "Damerau",
   "-",
   "Levenshtein",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "cost",
   "=",
   "(",
   "1",
   ",",
   "1",
   ",",
   "1",
   ",",
   "1",
   ")",
   ")",
   ":",
   "ins_cost",
   ",",
   "del_cost",
   ",",
   "sub_cost",
   ",",
   "trans_cost",
   "=",
   "cost",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0",
   "if",
   "not",
   "src",
   ":",
   "return",
   "len",
   "(",
   "tar",
   ")",
   "*",
   "ins_cost",
   "if",
   "not",
   "tar",
   ":",
   "return",
   "len",
   "(",
   "src",
   ")",
   "*",
   "del_cost",
   "if",
   "2",
   "*",
   "trans_cost",
   "<",
   "ins_cost",
   "+",
   "del_cost",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Unsupported cost assignment; the cost of two transpositions '",
   "+",
   "'must not be less than the cost of an insert plus a delete.'",
   ")",
   "d_mat",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   ")",
   "*",
   "(",
   "len",
   "(",
   "tar",
   ")",
   ")",
   ",",
   "dtype",
   "=",
   "np_int",
   ")",
   ".",
   "reshape",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   ")",
   "if",
   "src",
   "[",
   "0",
   "]",
   "!=",
   "tar",
   "[",
   "0",
   "]",
   ":",
   "d_mat",
   "[",
   "0",
   ",",
   "0",
   "]",
   "=",
   "<mask>",
   "(",
   "sub_cost",
   ",",
   "ins_cost",
   "+",
   "del_cost",
   ")",
   "src_index_by_character",
   "=",
   "{",
   "src",
   "[",
   "0",
   "]",
   ":",
   "0",
   "}",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "src",
   ")",
   ")",
   ":",
   "del_distance",
   "=",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "0",
   "]",
   "+",
   "del_cost",
   "ins_distance",
   "=",
   "(",
   "i",
   "+",
   "1",
   ")",
   "*",
   "del_cost",
   "+",
   "ins_cost",
   "match_distance",
   "=",
   "i",
   "*",
   "del_cost",
   "+",
   "(",
   "0",
   "if",
   "src",
   "[",
   "i",
   "]",
   "==",
   "tar",
   "[",
   "0",
   "]",
   "else",
   "sub_cost",
   ")",
   "d_mat",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "min",
   "(",
   "del_distance",
   ",",
   "ins_distance",
   ",",
   "match_distance",
   ")",
   "for",
   "j",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   ":",
   "del_distance",
   "=",
   "(",
   "j",
   "+",
   "1",
   ")",
   "*",
   "ins_cost",
   "+",
   "del_cost",
   "ins_distance",
   "=",
   "d_mat",
   "[",
   "0",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "ins_cost",
   "match_distance",
   "=",
   "j",
   "*",
   "ins_cost",
   "+",
   "(",
   "0",
   "if",
   "src",
   "[",
   "0",
   "]",
   "==",
   "tar",
   "[",
   "j",
   "]",
   "else",
   "sub_cost",
   ")",
   "d_mat",
   "[",
   "0",
   ",",
   "j",
   "]",
   "=",
   "min",
   "(",
   "del_distance",
   ",",
   "ins_distance",
   ",",
   "match_distance",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "src",
   ")",
   ")",
   ":",
   "max_src_letter_match_index",
   "=",
   "0",
   "if",
   "src",
   "[",
   "i",
   "]",
   "==",
   "tar",
   "[",
   "0",
   "]",
   "else",
   "-",
   "1",
   "for",
   "j",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   ":",
   "candidate_swap_index",
   "=",
   "(",
   "-",
   "1",
   "if",
   "tar",
   "[",
   "j",
   "]",
   "not",
   "in",
   "src_index_by_character",
   "else",
   "src_index_by_character",
   "[",
   "tar",
   "[",
   "j",
   "]",
   "]",
   ")",
   "j_swap",
   "=",
   "max_src_letter_match_index",
   "del_distance",
   "=",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "]",
   "+",
   "del_cost",
   "ins_distance",
   "=",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "ins_cost",
   "match_distance",
   "=",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   "]",
   "if",
   "src",
   "[",
   "i",
   "]",
   "!=",
   "tar",
   "[",
   "j",
   "]",
   ":",
   "match_distance",
   "+=",
   "sub_cost",
   "else",
   ":",
   "max_src_letter_match_index",
   "=",
   "j",
   "if",
   "candidate_swap_index",
   "!=",
   "-",
   "1",
   "and",
   "j_swap",
   "!=",
   "-",
   "1",
   ":",
   "i_swap",
   "=",
   "candidate_swap_index",
   "if",
   "i_swap",
   "==",
   "0",
   "and",
   "j_swap",
   "==",
   "0",
   ":",
   "pre_swap_cost",
   "=",
   "0",
   "else",
   ":",
   "pre_swap_cost",
   "=",
   "d_mat",
   "[",
   "max",
   "(",
   "0",
   ",",
   "i_swap",
   "-",
   "1",
   ")",
   ",",
   "max",
   "(",
   "0",
   ",",
   "j_swap",
   "-",
   "1",
   ")",
   "]",
   "swap_distance",
   "=",
   "(",
   "pre_swap_cost",
   "+",
   "(",
   "i",
   "-",
   "i_swap",
   "-",
   "1",
   ")",
   "*",
   "del_cost",
   "+",
   "(",
   "j",
   "-",
   "j_swap",
   "-",
   "1",
   ")",
   "*",
   "ins_cost",
   "+",
   "trans_cost",
   ")",
   "else",
   ":",
   "swap_distance",
   "=",
   "maxsize",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "min",
   "(",
   "del_distance",
   ",",
   "ins_distance",
   ",",
   "match_distance",
   ",",
   "swap_distance",
   ")",
   "src_index_by_character",
   "[",
   "src",
   "[",
   "i",
   "]",
   "]",
   "=",
   "i",
   "return",
   "d_mat",
   "[",
   "len",
   "(",
   "src",
   ")",
   "-",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "-",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-157",
  "nl_tokens": [
   "See",
   "comments",
   "in",
   "base",
   "class",
   "."
  ],
  "pl_tokens": [
   "def",
   "resetVelocity",
   "(",
   "self",
   ",",
   "rng",
   ")",
   ":",
   "maxVelocity",
   "=",
   "(",
   "self",
   ".",
   "<mask>",
   "-",
   "self",
   ".",
   "min",
   ")",
   "/",
   "5.0",
   "self",
   ".",
   "_velocity",
   "=",
   "maxVelocity",
   "#min(abs(self._velocity), maxVelocity)",
   "self",
   ".",
   "_velocity",
   "*=",
   "rng",
   ".",
   "choice",
   "(",
   "[",
   "1",
   ",",
   "-",
   "1",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-158",
  "nl_tokens": [
   "Reads",
   "data",
   "from",
   "the",
   "socket",
   "until",
   "a",
   "marker",
   "is",
   "found",
   ".",
   "Data",
   "read",
   "includes",
   "the",
   "marker",
   "."
  ],
  "pl_tokens": [
   "def",
   "read_until",
   "(",
   "self",
   ",",
   "marker",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "marker",
   ",",
   "byte_cls",
   ")",
   "and",
   "not",
   "isinstance",
   "(",
   "marker",
   ",",
   "Pattern",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "pretty_message",
   "(",
   "'''\n                marker must be a byte string or compiled regex object, not %s\n                '''",
   ",",
   "type_name",
   "(",
   "marker",
   ")",
   ")",
   ")",
   "output",
   "=",
   "b''",
   "is_regex",
   "=",
   "isinstance",
   "(",
   "marker",
   ",",
   "Pattern",
   ")",
   "while",
   "True",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_decrypted_bytes",
   ")",
   ">",
   "0",
   ":",
   "chunk",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "b''",
   "else",
   ":",
   "to_read",
   "=",
   "self",
   ".",
   "_os_buffered_size",
   "(",
   ")",
   "or",
   "8192",
   "chunk",
   "=",
   "self",
   ".",
   "read",
   "(",
   "to_read",
   ")",
   "offset",
   "=",
   "len",
   "(",
   "output",
   ")",
   "output",
   "+=",
   "chunk",
   "if",
   "is_regex",
   ":",
   "match",
   "=",
   "marker",
   ".",
   "search",
   "(",
   "output",
   ")",
   "if",
   "match",
   "is",
   "not",
   "None",
   ":",
   "end",
   "=",
   "match",
   ".",
   "end",
   "(",
   ")",
   "break",
   "else",
   ":",
   "# If the marker was not found last time, we have to start",
   "# at a position where the marker would have its final char",
   "# in the newly read chunk",
   "start",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "offset",
   "-",
   "len",
   "(",
   "marker",
   ")",
   "-",
   "1",
   ")",
   "match",
   "=",
   "output",
   ".",
   "find",
   "(",
   "marker",
   ",",
   "start",
   ")",
   "if",
   "match",
   "!=",
   "-",
   "1",
   ":",
   "end",
   "=",
   "match",
   "+",
   "len",
   "(",
   "marker",
   ")",
   "break",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "output",
   "[",
   "end",
   ":",
   "]",
   "+",
   "self",
   ".",
   "_decrypted_bytes",
   "return",
   "output",
   "[",
   "0",
   ":",
   "end",
   "]"
  ]
 },
 {
  "idx": "maxmin-159",
  "nl_tokens": [
   "todo"
  ],
  "pl_tokens": [
   "def",
   "_get_signal_space",
   "(",
   "S",
   ",",
   "NP",
   ",",
   "verbose",
   "=",
   "False",
   ",",
   "threshold",
   "=",
   "None",
   ",",
   "NSIG",
   "=",
   "None",
   ",",
   "criteria",
   "=",
   "'aic'",
   ")",
   ":",
   "from",
   ".",
   "criteria",
   "import",
   "aic_eigen",
   ",",
   "mdl_eigen",
   "# This section selects automatically the noise and signal subspaces.",
   "# NSIG being the number of eigenvalues corresponding to signals.",
   "if",
   "NSIG",
   "is",
   "None",
   ":",
   "if",
   "threshold",
   "is",
   "None",
   ":",
   "logging",
   ".",
   "debug",
   "(",
   "'computing NSIG using AIC method'",
   ")",
   "# get the minimum index of the AIC vector",
   "if",
   "criteria",
   "==",
   "'aic'",
   ":",
   "aic",
   "=",
   "aic_eigen",
   "(",
   "S",
   ",",
   "NP",
   "*",
   "2",
   ")",
   "elif",
   "criteria",
   "==",
   "'mdl'",
   ":",
   "aic",
   "=",
   "mdl_eigen",
   "(",
   "S",
   ",",
   "NP",
   "*",
   "2",
   ")",
   "# get the minimum index of the AIC vector, add 1 to get the NSIG",
   "NSIG",
   "=",
   "np",
   ".",
   "argmin",
   "(",
   "aic",
   ")",
   "+",
   "1",
   "logging",
   ".",
   "debug",
   "(",
   "'NSIG='",
   ",",
   "NSIG",
   ",",
   "' found as the number of pertinent sinusoids'",
   ")",
   "else",
   ":",
   "logging",
   ".",
   "debug",
   "(",
   "'computing NSIG using user threshold '",
   ")",
   "# following an idea from Matlab, pmusic, we look at the minimum",
   "# eigen value, and split the eigen values above and below",
   "# K times min eigen value, where K is >1",
   "m",
   "=",
   "threshold",
   "*",
   "<mask>",
   "(",
   "S",
   ")",
   "new_s",
   "=",
   "S",
   "[",
   "np",
   ".",
   "where",
   "(",
   "S",
   ">",
   "m",
   ")",
   "]",
   "NSIG",
   "=",
   "len",
   "(",
   "new_s",
   ")",
   "logging",
   ".",
   "debug",
   "(",
   "'found'",
   ",",
   "NSIG",
   ")",
   "if",
   "NSIG",
   "==",
   "0",
   ":",
   "NSIG",
   "=",
   "1",
   "return",
   "NSIG"
  ]
 },
 {
  "idx": "maxmin-160",
  "nl_tokens": [
   "No",
   "reads",
   "can",
   "go",
   "past",
   "the",
   "left",
   "of",
   "the",
   "seed",
   "or",
   "right",
   "of",
   "the",
   "least",
   "extended",
   "reverse",
   "complement",
   "match",
   ".",
   "Example",
   "below",
   ".",
   "m",
   "is",
   "a",
   "match",
   ".",
   "u",
   "is",
   "an",
   "area",
   "where",
   "lots",
   "of",
   "mismatches",
   "typically",
   "occur",
   ".",
   "The",
   "cut",
   "sites",
   "are",
   "shown",
   ".",
   "Original",
   "locus",
   "*",
   "Seed",
   "TGCAG",
   "************************************",
   "-----------------------",
   "Forward",
   "-",
   "match",
   "TGCAGmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
   "-----------------------",
   "Forward",
   "-",
   "match",
   "TGCAGmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
   "-----------------------------",
   "Forward",
   "-",
   "match",
   "TGCAGmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm",
   "------------------------",
   "Revcomp",
   "-",
   "match",
   "------------------------",
   "mmmmmmmmmmmmmmmmmmmmmmmmmmmCTGCAuuuuuuuu",
   "Revcomp",
   "-",
   "match",
   "---------------",
   "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmCTGCAuuuuuuuuuuuuuu",
   "Revcomp",
   "-",
   "match",
   "--------------------------------",
   "mmmmmmmmmmmmmmmmmmmmmmmmmmmCTGCA",
   "Revcomp",
   "-",
   "match",
   "------------------------",
   "mmmmmmmmmmmmmmmmmmmmmmmmmmmCTGCAuuuuuuuu"
  ],
  "pl_tokens": [
   "def",
   "gbs_trim",
   "(",
   "align1",
   ")",
   ":",
   "leftmost",
   "=",
   "rightmost",
   "=",
   "None",
   "dd",
   "=",
   "{",
   "k",
   ":",
   "v",
   "for",
   "k",
   ",",
   "v",
   "in",
   "[",
   "j",
   ".",
   "rsplit",
   "(",
   "\"\\n\"",
   ",",
   "1",
   ")",
   "for",
   "j",
   "in",
   "align1",
   "]",
   "}",
   "seed",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "dd",
   ".",
   "keys",
   "(",
   ")",
   "if",
   "i",
   ".",
   "rsplit",
   "(",
   "\";\"",
   ")",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "\"*\"",
   "]",
   "[",
   "0",
   "]",
   "leftmost",
   "=",
   "[",
   "i",
   "!=",
   "\"-\"",
   "for",
   "i",
   "in",
   "dd",
   "[",
   "seed",
   "]",
   "]",
   ".",
   "index",
   "(",
   "True",
   ")",
   "revs",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "dd",
   ".",
   "keys",
   "(",
   ")",
   "if",
   "i",
   ".",
   "rsplit",
   "(",
   "\";\"",
   ")",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "\"-\"",
   "]",
   "if",
   "revs",
   ":",
   "subright",
   "=",
   "<mask>",
   "(",
   "[",
   "[",
   "i",
   "!=",
   "\"-\"",
   "for",
   "i",
   "in",
   "seq",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "]",
   ".",
   "index",
   "(",
   "True",
   ")",
   "for",
   "seq",
   "in",
   "[",
   "dd",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "revs",
   "]",
   "]",
   ")",
   "else",
   ":",
   "subright",
   "=",
   "0",
   "rightmost",
   "=",
   "len",
   "(",
   "dd",
   "[",
   "seed",
   "]",
   ")",
   "-",
   "subright",
   "## if locus got clobbered then print place-holder NNN",
   "names",
   ",",
   "seqs",
   "=",
   "zip",
   "(",
   "*",
   "[",
   "i",
   ".",
   "rsplit",
   "(",
   "\"\\n\"",
   ",",
   "1",
   ")",
   "for",
   "i",
   "in",
   "align1",
   "]",
   ")",
   "if",
   "rightmost",
   ">",
   "leftmost",
   ":",
   "newalign1",
   "=",
   "[",
   "n",
   "+",
   "\"\\n\"",
   "+",
   "i",
   "[",
   "leftmost",
   ":",
   "rightmost",
   "]",
   "for",
   "i",
   ",",
   "n",
   "in",
   "zip",
   "(",
   "seqs",
   ",",
   "names",
   ")",
   "]",
   "else",
   ":",
   "newalign1",
   "=",
   "[",
   "n",
   "+",
   "\"\\nNNN\"",
   "for",
   "i",
   ",",
   "n",
   "in",
   "zip",
   "(",
   "seqs",
   ",",
   "names",
   ")",
   "]",
   "return",
   "newalign1"
  ]
 },
 {
  "idx": "maxmin-161",
  "nl_tokens": [
   "Return",
   "the",
   "Minkowski",
   "distance",
   "(",
   ":",
   "math",
   ":",
   "L^p",
   "-",
   "norm",
   ")",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "qval",
   "=",
   "2",
   ",",
   "pval",
   "=",
   "1",
   ",",
   "normalized",
   "=",
   "False",
   ",",
   "alphabet",
   "=",
   "None",
   ")",
   ":",
   "q_src",
   ",",
   "q_tar",
   "=",
   "self",
   ".",
   "_get_qgrams",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "qval",
   ")",
   "diffs",
   "=",
   "(",
   "(",
   "q_src",
   "-",
   "q_tar",
   ")",
   "+",
   "(",
   "q_tar",
   "-",
   "q_src",
   ")",
   ")",
   ".",
   "values",
   "(",
   ")",
   "normalizer",
   "=",
   "1",
   "if",
   "normalized",
   ":",
   "totals",
   "=",
   "(",
   "q_src",
   "+",
   "q_tar",
   ")",
   ".",
   "values",
   "(",
   ")",
   "if",
   "alphabet",
   "is",
   "not",
   "None",
   ":",
   "# noinspection PyTypeChecker",
   "normalizer",
   "=",
   "(",
   "alphabet",
   "if",
   "isinstance",
   "(",
   "alphabet",
   ",",
   "Number",
   ")",
   "else",
   "len",
   "(",
   "alphabet",
   ")",
   ")",
   "elif",
   "pval",
   "==",
   "0",
   ":",
   "normalizer",
   "=",
   "len",
   "(",
   "totals",
   ")",
   "else",
   ":",
   "normalizer",
   "=",
   "sum",
   "(",
   "_",
   "**",
   "pval",
   "for",
   "_",
   "in",
   "totals",
   ")",
   "**",
   "(",
   "1",
   "/",
   "pval",
   ")",
   "if",
   "len",
   "(",
   "diffs",
   ")",
   "==",
   "0",
   ":",
   "return",
   "0.0",
   "if",
   "pval",
   "==",
   "float",
   "(",
   "'inf'",
   ")",
   ":",
   "# Chebyshev distance",
   "return",
   "<mask>",
   "(",
   "diffs",
   ")",
   "/",
   "normalizer",
   "if",
   "pval",
   "==",
   "0",
   ":",
   "# This is the l_0 \"norm\" as developed by David Donoho",
   "return",
   "len",
   "(",
   "diffs",
   ")",
   "/",
   "normalizer",
   "return",
   "sum",
   "(",
   "_",
   "**",
   "pval",
   "for",
   "_",
   "in",
   "diffs",
   ")",
   "**",
   "(",
   "1",
   "/",
   "pval",
   ")",
   "/",
   "normalizer"
  ]
 },
 {
  "idx": "maxmin-162",
  "nl_tokens": [
   "Grows",
   "the",
   "histogram",
   "to",
   "have",
   "rows",
   "rows",
   "and",
   "cols",
   "columns",
   ".",
   "Must",
   "not",
   "have",
   "been",
   "initialized",
   "before",
   "or",
   "already",
   "have",
   "the",
   "same",
   "number",
   "of",
   "columns",
   ".",
   "If",
   "rows",
   "is",
   "smaller",
   "than",
   "the",
   "current",
   "number",
   "of",
   "rows",
   "does",
   "not",
   "shrink",
   ".",
   "Also",
   "updates",
   "the",
   "sizes",
   "of",
   "the",
   "row",
   "and",
   "column",
   "sums",
   "."
  ],
  "pl_tokens": [
   "def",
   "grow",
   "(",
   "self",
   ",",
   "rows",
   ",",
   "cols",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "hist_",
   ":",
   "self",
   ".",
   "hist_",
   "=",
   "SparseMatrix",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   "self",
   ".",
   "rowSums_",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "rows",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "self",
   ".",
   "colSums_",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "cols",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "self",
   ".",
   "hack_",
   "=",
   "None",
   "else",
   ":",
   "oldRows",
   "=",
   "self",
   ".",
   "hist_",
   ".",
   "nRows",
   "(",
   ")",
   "oldCols",
   "=",
   "self",
   ".",
   "hist_",
   ".",
   "nCols",
   "(",
   ")",
   "nextRows",
   "=",
   "<mask>",
   "(",
   "oldRows",
   ",",
   "rows",
   ")",
   "nextCols",
   "=",
   "max",
   "(",
   "oldCols",
   ",",
   "cols",
   ")",
   "if",
   "(",
   "oldRows",
   "<",
   "nextRows",
   ")",
   "or",
   "(",
   "oldCols",
   "<",
   "nextCols",
   ")",
   ":",
   "self",
   ".",
   "hist_",
   ".",
   "resize",
   "(",
   "nextRows",
   ",",
   "nextCols",
   ")",
   "if",
   "oldRows",
   "<",
   "nextRows",
   ":",
   "oldSums",
   "=",
   "self",
   ".",
   "rowSums_",
   "self",
   ".",
   "rowSums_",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "nextRows",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "self",
   ".",
   "rowSums_",
   "[",
   "0",
   ":",
   "len",
   "(",
   "oldSums",
   ")",
   "]",
   "=",
   "oldSums",
   "self",
   ".",
   "hack_",
   "=",
   "None",
   "if",
   "oldCols",
   "<",
   "nextCols",
   ":",
   "oldSums",
   "=",
   "self",
   ".",
   "colSums_",
   "self",
   ".",
   "colSums_",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "nextCols",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "self",
   ".",
   "colSums_",
   "[",
   "0",
   ":",
   "len",
   "(",
   "oldSums",
   ")",
   "]",
   "=",
   "oldSums",
   "self",
   ".",
   "hack_",
   "=",
   "None"
  ]
 },
 {
  "idx": "maxmin-163",
  "nl_tokens": [
   "Return",
   "the",
   "Double",
   "Metaphone",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "-",
   "1",
   ")",
   ":",
   "# Require a max_length of at least 4",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "4",
   ",",
   "max_length",
   ")",
   "primary",
   "=",
   "''",
   "secondary",
   "=",
   "''",
   "def",
   "_slavo_germanic",
   "(",
   ")",
   ":",
   "\"\"\"Return True if the word appears to be Slavic or Germanic.\n\n            Returns\n            -------\n            bool\n                True if the word appears to be Slavic or Germanic\n\n            \"\"\"",
   "if",
   "'W'",
   "in",
   "word",
   "or",
   "'K'",
   "in",
   "word",
   "or",
   "'CZ'",
   "in",
   "word",
   ":",
   "return",
   "True",
   "return",
   "False",
   "def",
   "_metaph_add",
   "(",
   "pri",
   ",",
   "sec",
   "=",
   "''",
   ")",
   ":",
   "\"\"\"Return a new metaphone tuple with the supplied elements.\n\n            Parameters\n            ----------\n            pri : str\n                The primary element\n            sec : str\n                The secondary element\n\n            Returns\n            -------\n            tuple\n                A new metaphone tuple with the supplied elements\n\n            \"\"\"",
   "newpri",
   "=",
   "primary",
   "newsec",
   "=",
   "secondary",
   "if",
   "pri",
   ":",
   "newpri",
   "+=",
   "pri",
   "if",
   "sec",
   ":",
   "if",
   "sec",
   "!=",
   "' '",
   ":",
   "newsec",
   "+=",
   "sec",
   "else",
   ":",
   "newsec",
   "+=",
   "pri",
   "return",
   "newpri",
   ",",
   "newsec",
   "def",
   "_is_vowel",
   "(",
   "pos",
   ")",
   ":",
   "\"\"\"Return True if the character at word[pos] is a vowel.\n\n            Parameters\n            ----------\n            pos : int\n                Position in the word\n\n            Returns\n            -------\n            bool\n                True if the character is a vowel\n\n            \"\"\"",
   "if",
   "pos",
   ">=",
   "0",
   "and",
   "word",
   "[",
   "pos",
   "]",
   "in",
   "{",
   "'A'",
   ",",
   "'E'",
   ",",
   "'I'",
   ",",
   "'O'",
   ",",
   "'U'",
   ",",
   "'Y'",
   "}",
   ":",
   "return",
   "True",
   "return",
   "False",
   "def",
   "_get_at",
   "(",
   "pos",
   ")",
   ":",
   "\"\"\"Return the character at word[pos].\n\n            Parameters\n            ----------\n            pos : int\n                Position in the word\n\n            Returns\n            -------\n            str\n                Character at word[pos]\n\n            \"\"\"",
   "return",
   "word",
   "[",
   "pos",
   "]",
   "def",
   "_string_at",
   "(",
   "pos",
   ",",
   "slen",
   ",",
   "substrings",
   ")",
   ":",
   "\"\"\"Return True if word[pos:pos+slen] is in substrings.\n\n            Parameters\n            ----------\n            pos : int\n                Position in the word\n            slen : int\n                Substring length\n            substrings : set\n                Substrings to search\n\n            Returns\n            -------\n            bool\n                True if word[pos:pos+slen] is in substrings\n\n            \"\"\"",
   "if",
   "pos",
   "<",
   "0",
   ":",
   "return",
   "False",
   "return",
   "word",
   "[",
   "pos",
   ":",
   "pos",
   "+",
   "slen",
   "]",
   "in",
   "substrings",
   "current",
   "=",
   "0",
   "length",
   "=",
   "len",
   "(",
   "word",
   ")",
   "if",
   "length",
   "<",
   "1",
   ":",
   "return",
   "''",
   ",",
   "''",
   "last",
   "=",
   "length",
   "-",
   "1",
   "word",
   "=",
   "word",
   ".",
   "upper",
   "(",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "# Pad the original string so that we can index beyond the edge of the",
   "# world",
   "word",
   "+=",
   "'     '",
   "# Skip these when at start of word",
   "if",
   "word",
   "[",
   "0",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'GN'",
   ",",
   "'KN'",
   ",",
   "'PN'",
   ",",
   "'WR'",
   ",",
   "'PS'",
   "}",
   ":",
   "current",
   "+=",
   "1",
   "# Initial 'X' is pronounced 'Z' e.g. 'Xavier'",
   "if",
   "_get_at",
   "(",
   "0",
   ")",
   "==",
   "'X'",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "# 'Z' maps to 'S'",
   "current",
   "+=",
   "1",
   "# Main loop",
   "while",
   "True",
   ":",
   "if",
   "current",
   ">=",
   "length",
   ":",
   "break",
   "if",
   "_get_at",
   "(",
   "current",
   ")",
   "in",
   "{",
   "'A'",
   ",",
   "'E'",
   ",",
   "'I'",
   ",",
   "'O'",
   ",",
   "'U'",
   ",",
   "'Y'",
   "}",
   ":",
   "if",
   "current",
   "==",
   "0",
   ":",
   "# All init vowels now map to 'A'",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'A'",
   ")",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'B'",
   ":",
   "# \"-mb\", e.g\", \"dumb\", already skipped over...",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'P'",
   ")",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'B'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'\u00c7':",
   "",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'C'",
   ":",
   "# Various Germanic",
   "if",
   "(",
   "current",
   ">",
   "1",
   "and",
   "not",
   "_is_vowel",
   "(",
   "current",
   "-",
   "2",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'ACH'",
   "}",
   ")",
   "and",
   "(",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "2",
   ")",
   "!=",
   "'I'",
   ")",
   "and",
   "(",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "2",
   ")",
   "!=",
   "'E'",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "6",
   ",",
   "{",
   "'BACHER'",
   ",",
   "'MACHER'",
   "}",
   ")",
   ")",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# Special case 'caesar'",
   "elif",
   "current",
   "==",
   "0",
   "and",
   "_string_at",
   "(",
   "current",
   ",",
   "6",
   ",",
   "{",
   "'CAESAR'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# Italian 'chianti'",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'CHIA'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'CH'",
   "}",
   ")",
   ":",
   "# Find 'Michael'",
   "if",
   "current",
   ">",
   "0",
   "and",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'CHAE'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ",",
   "'X'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# Greek roots e.g. 'chemistry', 'chorus'",
   "elif",
   "(",
   "current",
   "==",
   "0",
   "and",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "5",
   ",",
   "{",
   "'HARAC'",
   ",",
   "'HARIS'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'HOR'",
   ",",
   "'HYM'",
   ",",
   "'HIA'",
   ",",
   "'HEM'",
   "}",
   ")",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "0",
   ",",
   "5",
   ",",
   "{",
   "'CHORE'",
   "}",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# Germanic, Greek, or otherwise 'ch' for 'kh' sound",
   "elif",
   "(",
   "(",
   "_string_at",
   "(",
   "0",
   ",",
   "4",
   ",",
   "{",
   "'VAN '",
   ",",
   "'VON '",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "3",
   ",",
   "{",
   "'SCH'",
   "}",
   ")",
   ")",
   "or",
   "# 'architect but not 'arch', 'orchestra', 'orchid'",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "6",
   ",",
   "{",
   "'ORCHES'",
   ",",
   "'ARCHIT'",
   ",",
   "'ORCHID'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'T'",
   ",",
   "'S'",
   "}",
   ")",
   "or",
   "(",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'A'",
   ",",
   "'O'",
   ",",
   "'U'",
   ",",
   "'E'",
   "}",
   ")",
   "or",
   "(",
   "current",
   "==",
   "0",
   ")",
   ")",
   "and",
   "# e.g., 'wachtler', 'wechsler', but not 'tichner'",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'L'",
   ",",
   "'R'",
   ",",
   "'N'",
   ",",
   "'M'",
   ",",
   "'B'",
   ",",
   "'H'",
   ",",
   "'F'",
   ",",
   "'V'",
   ",",
   "'W'",
   ",",
   "' '",
   ",",
   "}",
   ",",
   ")",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "else",
   ":",
   "if",
   "current",
   ">",
   "0",
   ":",
   "if",
   "_string_at",
   "(",
   "0",
   ",",
   "2",
   ",",
   "{",
   "'MC'",
   "}",
   ")",
   ":",
   "# e.g., \"McHugh\"",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ",",
   "'K'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# e.g, 'czerny'",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'CZ'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "4",
   ",",
   "{",
   "'WICZ'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ",",
   "'X'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# e.g., 'focaccia'",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'CIA'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "3",
   "# double 'C', but not if e.g. 'McClellan'",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'CC'",
   "}",
   ")",
   "and",
   "not",
   "(",
   "(",
   "current",
   "==",
   "1",
   ")",
   "and",
   "(",
   "_get_at",
   "(",
   "0",
   ")",
   "==",
   "'M'",
   ")",
   ")",
   ":",
   "# 'bellocchio' but not 'bacchus'",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'I'",
   ",",
   "'E'",
   ",",
   "'H'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'HU'",
   "}",
   ")",
   ":",
   "# 'accident', 'accede' 'succeed'",
   "if",
   "(",
   "(",
   "current",
   "==",
   "1",
   ")",
   "and",
   "_get_at",
   "(",
   "current",
   "-",
   "1",
   ")",
   "==",
   "'A'",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "5",
   ",",
   "{",
   "'UCCEE'",
   ",",
   "'UCCES'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'KS'",
   ")",
   "# 'bacci', 'bertucci', other italian",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "else",
   ":",
   "# Pierce's rule",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'CK'",
   ",",
   "'CG'",
   ",",
   "'CQ'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'CI'",
   ",",
   "'CE'",
   ",",
   "'CY'",
   "}",
   ")",
   ":",
   "# Italian vs. English",
   "if",
   "_string_at",
   "(",
   "current",
   ",",
   "3",
   ",",
   "{",
   "'CIO'",
   ",",
   "'CIE'",
   ",",
   "'CIA'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ",",
   "'X'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# else",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "# name sent in 'mac caffrey', 'mac gregor",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "' C'",
   ",",
   "' Q'",
   ",",
   "' G'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "3",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'C'",
   ",",
   "'K'",
   ",",
   "'Q'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'CE'",
   ",",
   "'CI'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'D'",
   ":",
   "if",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'DG'",
   "}",
   ")",
   ":",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'I'",
   ",",
   "'E'",
   ",",
   "'Y'",
   "}",
   ")",
   ":",
   "# e.g. 'edge'",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "else",
   ":",
   "# e.g. 'edgar'",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'TK'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'DT'",
   ",",
   "'DD'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'T'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# else",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'T'",
   ")",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'F'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'F'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'F'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'G'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'H'",
   ":",
   "if",
   "(",
   "current",
   ">",
   "0",
   ")",
   "and",
   "not",
   "_is_vowel",
   "(",
   "current",
   "-",
   "1",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# 'ghislane', ghiradelli",
   "elif",
   "current",
   "==",
   "0",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "2",
   ")",
   "==",
   "'I'",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# Parker's rule (with some further refinements) -",
   "# e.g., 'hugh'",
   "elif",
   "(",
   "(",
   "(",
   "current",
   ">",
   "1",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'B'",
   ",",
   "'H'",
   ",",
   "'D'",
   "}",
   ")",
   ")",
   "or",
   "# e.g., 'bough'",
   "(",
   "(",
   "current",
   ">",
   "2",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "3",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'B'",
   ",",
   "'H'",
   ",",
   "'D'",
   "}",
   ")",
   ")",
   "or",
   "# e.g., 'broughton'",
   "(",
   "(",
   "current",
   ">",
   "3",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "4",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'B'",
   ",",
   "'H'",
   "}",
   ")",
   ")",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "continue",
   "else",
   ":",
   "# e.g. 'laugh', 'McLaughlin', 'cough',",
   "#      'gough', 'rough', 'tough'",
   "if",
   "(",
   "(",
   "current",
   ">",
   "2",
   ")",
   "and",
   "(",
   "_get_at",
   "(",
   "current",
   "-",
   "1",
   ")",
   "==",
   "'U'",
   ")",
   "and",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "3",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'C'",
   ",",
   "'G'",
   ",",
   "'L'",
   ",",
   "'R'",
   ",",
   "'T'",
   "}",
   ")",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'F'",
   ")",
   "elif",
   "(",
   "current",
   ">",
   "0",
   ")",
   "and",
   "_get_at",
   "(",
   "current",
   "-",
   "1",
   ")",
   "!=",
   "'I'",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'N'",
   ":",
   "if",
   "(",
   "(",
   "current",
   "==",
   "1",
   ")",
   "and",
   "_is_vowel",
   "(",
   "0",
   ")",
   "and",
   "not",
   "_slavo_germanic",
   "(",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'KN'",
   ",",
   "'N'",
   ")",
   "# not e.g. 'cagney'",
   "elif",
   "(",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'EY'",
   "}",
   ")",
   "and",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "!=",
   "'Y'",
   ")",
   "and",
   "not",
   "_slavo_germanic",
   "(",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'N'",
   ",",
   "'KN'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'KN'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# 'tagliaro'",
   "elif",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'LI'",
   "}",
   ")",
   "and",
   "not",
   "_slavo_germanic",
   "(",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'KL'",
   ",",
   "'L'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# -ges-, -gep-, -gel-, -gie- at beginning",
   "elif",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "(",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'Y'",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ES'",
   ",",
   "'EP'",
   ",",
   "'EB'",
   ",",
   "'EL'",
   ",",
   "'EY'",
   ",",
   "'IB'",
   ",",
   "'IL'",
   ",",
   "'IN'",
   ",",
   "'IE'",
   ",",
   "'EI'",
   ",",
   "'ER'",
   ",",
   "}",
   ",",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ",",
   "'J'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "#  -ger-,  -gy-",
   "elif",
   "(",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ER'",
   "}",
   ")",
   "or",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'Y'",
   ")",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "0",
   ",",
   "6",
   ",",
   "{",
   "'DANGER'",
   ",",
   "'RANGER'",
   ",",
   "'MANGER'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'E'",
   ",",
   "'I'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'RGY'",
   ",",
   "'OGY'",
   "}",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ",",
   "'J'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "#  italian e.g, 'biaggi'",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'E'",
   ",",
   "'I'",
   ",",
   "'Y'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "4",
   ",",
   "{",
   "'AGGI'",
   ",",
   "'OGGI'",
   "}",
   ")",
   ":",
   "# obvious germanic",
   "if",
   "(",
   "_string_at",
   "(",
   "0",
   ",",
   "4",
   ",",
   "{",
   "'VAN '",
   ",",
   "'VON '",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "3",
   ",",
   "{",
   "'SCH'",
   "}",
   ")",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ET'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "4",
   ",",
   "{",
   "'IER '",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ",",
   "'K'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "else",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'G'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'H'",
   ":",
   "# only keep if first & before vowel or btw. 2 vowels",
   "if",
   "(",
   "(",
   "current",
   "==",
   "0",
   ")",
   "or",
   "_is_vowel",
   "(",
   "current",
   "-",
   "1",
   ")",
   ")",
   "and",
   "_is_vowel",
   "(",
   "current",
   "+",
   "1",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'H'",
   ")",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "# also takes care of 'HH'",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'J'",
   ":",
   "# obvious spanish, 'jose', 'san jacinto'",
   "if",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'JOSE'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "4",
   ",",
   "{",
   "'SAN '",
   "}",
   ")",
   ":",
   "if",
   "(",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "4",
   ")",
   "==",
   "' '",
   ")",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "4",
   ",",
   "{",
   "'SAN '",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'H'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ",",
   "'H'",
   ")",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'JOSE'",
   "}",
   ")",
   ":",
   "# Yankelovich/Jankelowicz",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ",",
   "'A'",
   ")",
   "# Spanish pron. of e.g. 'bajador'",
   "elif",
   "(",
   "_is_vowel",
   "(",
   "current",
   "-",
   "1",
   ")",
   "and",
   "not",
   "_slavo_germanic",
   "(",
   ")",
   "and",
   "(",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'A'",
   ")",
   "or",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'O'",
   ")",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ",",
   "'H'",
   ")",
   "elif",
   "current",
   "==",
   "last",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ",",
   "' '",
   ")",
   "elif",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'L'",
   ",",
   "'T'",
   ",",
   "'K'",
   ",",
   "'S'",
   ",",
   "'N'",
   ",",
   "'M'",
   ",",
   "'B'",
   ",",
   "'Z'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'S'",
   ",",
   "'K'",
   ",",
   "'L'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ")",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'J'",
   ":",
   "# it could happen!",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'K'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'K'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'L'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'L'",
   ":",
   "# Spanish e.g. 'cabrillo', 'gallegos'",
   "if",
   "(",
   "(",
   "current",
   "==",
   "(",
   "length",
   "-",
   "3",
   ")",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "4",
   ",",
   "{",
   "'ILLO'",
   ",",
   "'ILLA'",
   ",",
   "'ALLE'",
   "}",
   ")",
   ")",
   "or",
   "(",
   "(",
   "_string_at",
   "(",
   "(",
   "last",
   "-",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'AS'",
   ",",
   "'OS'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "last",
   ",",
   "1",
   ",",
   "{",
   "'A'",
   ",",
   "'O'",
   "}",
   ")",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "4",
   ",",
   "{",
   "'ALLE'",
   "}",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'L'",
   ",",
   "' '",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'L'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'M'",
   ":",
   "if",
   "(",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'UMB'",
   "}",
   ")",
   "and",
   "(",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "last",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ER'",
   "}",
   ")",
   ")",
   ")",
   "or",
   "# 'dumb', 'thumb'",
   "(",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'M'",
   ")",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'M'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'N'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'N'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'N'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'\u00d1':",
   "",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'N'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'P'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'H'",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'F'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# also account for \"campbell\", \"raspberry\"",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'P'",
   ",",
   "'B'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'P'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'Q'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'Q'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'K'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'R'",
   ":",
   "# french e.g. 'rogier', but exclude 'hochmeier'",
   "if",
   "(",
   "(",
   "current",
   "==",
   "last",
   ")",
   "and",
   "not",
   "_slavo_germanic",
   "(",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'IE'",
   "}",
   ")",
   "and",
   "not",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "4",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ME'",
   ",",
   "'MA'",
   "}",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "''",
   ",",
   "'R'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'R'",
   ")",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'R'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'S'",
   ":",
   "# special cases 'island', 'isle', 'carlisle', 'carlysle'",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'ISL'",
   ",",
   "'YSL'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "# special case 'sugar-'",
   "elif",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "_string_at",
   "(",
   "current",
   ",",
   "5",
   ",",
   "{",
   "'SUGAR'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ",",
   "'S'",
   ")",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'SH'",
   "}",
   ")",
   ":",
   "# Germanic",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "4",
   ",",
   "{",
   "'HEIM'",
   ",",
   "'HOEK'",
   ",",
   "'HOLM'",
   ",",
   "'HOLZ'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "# Italian & Armenian",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "3",
   ",",
   "{",
   "'SIO'",
   ",",
   "'SIA'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'SIAN'",
   "}",
   ")",
   ":",
   "if",
   "not",
   "_slavo_germanic",
   "(",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ",",
   "'X'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "# German & anglicisations, e.g. 'smith' match 'schmidt',",
   "#                               'snider' match 'schneider'",
   "# also, -sz- in Slavic language although in Hungarian it is",
   "#       pronounced 's'",
   "elif",
   "(",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'M'",
   ",",
   "'N'",
   ",",
   "'L'",
   ",",
   "'W'",
   "}",
   ")",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'Z'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ",",
   "'X'",
   ")",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'Z'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'SC'",
   "}",
   ")",
   ":",
   "# Schlesinger's rule",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "2",
   ")",
   "==",
   "'H'",
   ":",
   "# dutch origin, e.g. 'school', 'schooner'",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "3",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'OO'",
   ",",
   "'ER'",
   ",",
   "'EN'",
   ",",
   "'UY'",
   ",",
   "'ED'",
   ",",
   "'EM'",
   "}",
   ",",
   ")",
   ":",
   "# 'schermerhorn', 'schenker'",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "3",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ER'",
   ",",
   "'EN'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ",",
   "'SK'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'SK'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "else",
   ":",
   "if",
   "(",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "not",
   "_is_vowel",
   "(",
   "3",
   ")",
   "and",
   "(",
   "_get_at",
   "(",
   "3",
   ")",
   "!=",
   "'W'",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ",",
   "'S'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'I'",
   ",",
   "'E'",
   ",",
   "'Y'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "# else",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'SK'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "else",
   ":",
   "# french e.g. 'resnais', 'artois'",
   "if",
   "(",
   "current",
   "==",
   "last",
   ")",
   "and",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'AI'",
   ",",
   "'OI'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "''",
   ",",
   "'S'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'S'",
   ",",
   "'Z'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'T'",
   ":",
   "if",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'TION'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "3",
   ",",
   "{",
   "'TIA'",
   ",",
   "'TCH'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'X'",
   ")",
   "current",
   "+=",
   "3",
   "continue",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'TH'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "current",
   ",",
   "3",
   ",",
   "{",
   "'TTH'",
   "}",
   ")",
   ":",
   "# special case 'thomas', 'thames' or germanic",
   "if",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'OM'",
   ",",
   "'AM'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "4",
   ",",
   "{",
   "'VAN '",
   ",",
   "'VON '",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "3",
   ",",
   "{",
   "'SCH'",
   "}",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'T'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'0'",
   ",",
   "'T'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'T'",
   ",",
   "'D'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'T'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'V'",
   ":",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'V'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'F'",
   ")",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'W'",
   ":",
   "# can also be in middle of word",
   "if",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'WR'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'R'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "(",
   "current",
   "==",
   "0",
   ")",
   "and",
   "(",
   "_is_vowel",
   "(",
   "current",
   "+",
   "1",
   ")",
   "or",
   "_string_at",
   "(",
   "current",
   ",",
   "2",
   ",",
   "{",
   "'WH'",
   "}",
   ")",
   ")",
   ":",
   "# Wasserman should match Vasserman",
   "if",
   "_is_vowel",
   "(",
   "current",
   "+",
   "1",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'A'",
   ",",
   "'F'",
   ")",
   "else",
   ":",
   "# need Uomo to match Womo",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'A'",
   ")",
   "# Arnow should match Arnoff",
   "if",
   "(",
   "(",
   "(",
   "current",
   "==",
   "last",
   ")",
   "and",
   "_is_vowel",
   "(",
   "current",
   "-",
   "1",
   ")",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "1",
   ")",
   ",",
   "5",
   ",",
   "{",
   "'EWSKI'",
   ",",
   "'EWSKY'",
   ",",
   "'OWSKI'",
   ",",
   "'OWSKY'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "0",
   ",",
   "3",
   ",",
   "{",
   "'SCH'",
   "}",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "''",
   ",",
   "'F'",
   ")",
   "current",
   "+=",
   "1",
   "continue",
   "# Polish e.g. 'filipowicz'",
   "elif",
   "_string_at",
   "(",
   "current",
   ",",
   "4",
   ",",
   "{",
   "'WICZ'",
   ",",
   "'WITZ'",
   "}",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'TS'",
   ",",
   "'FX'",
   ")",
   "current",
   "+=",
   "4",
   "continue",
   "# else skip it",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'X'",
   ":",
   "# French e.g. breaux",
   "if",
   "not",
   "(",
   "(",
   "current",
   "==",
   "last",
   ")",
   "and",
   "(",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "3",
   ")",
   ",",
   "3",
   ",",
   "{",
   "'IAU'",
   ",",
   "'EAU'",
   "}",
   ")",
   "or",
   "_string_at",
   "(",
   "(",
   "current",
   "-",
   "2",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'AU'",
   ",",
   "'OU'",
   "}",
   ")",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'KS'",
   ")",
   "if",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "1",
   ",",
   "{",
   "'C'",
   ",",
   "'X'",
   "}",
   ")",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "elif",
   "_get_at",
   "(",
   "current",
   ")",
   "==",
   "'Z'",
   ":",
   "# Chinese Pinyin e.g. 'zhao'",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'H'",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'J'",
   ")",
   "current",
   "+=",
   "2",
   "continue",
   "elif",
   "_string_at",
   "(",
   "(",
   "current",
   "+",
   "1",
   ")",
   ",",
   "2",
   ",",
   "{",
   "'ZO'",
   ",",
   "'ZI'",
   ",",
   "'ZA'",
   "}",
   ")",
   "or",
   "(",
   "_slavo_germanic",
   "(",
   ")",
   "and",
   "(",
   "(",
   "current",
   ">",
   "0",
   ")",
   "and",
   "_get_at",
   "(",
   "current",
   "-",
   "1",
   ")",
   "!=",
   "'T'",
   ")",
   ")",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ",",
   "'TS'",
   ")",
   "else",
   ":",
   "primary",
   ",",
   "secondary",
   "=",
   "_metaph_add",
   "(",
   "'S'",
   ")",
   "if",
   "_get_at",
   "(",
   "current",
   "+",
   "1",
   ")",
   "==",
   "'Z'",
   ":",
   "current",
   "+=",
   "2",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "continue",
   "else",
   ":",
   "current",
   "+=",
   "1",
   "if",
   "max_length",
   ">",
   "0",
   ":",
   "primary",
   "=",
   "primary",
   "[",
   ":",
   "max_length",
   "]",
   "secondary",
   "=",
   "secondary",
   "[",
   ":",
   "max_length",
   "]",
   "if",
   "primary",
   "==",
   "secondary",
   ":",
   "secondary",
   "=",
   "''",
   "return",
   "primary",
   ",",
   "secondary"
  ]
 },
 {
  "idx": "maxmin-164",
  "nl_tokens": [
   "Rotates",
   "the",
   "layer",
   ".",
   "Rotates",
   "the",
   "layer",
   "by",
   "given",
   "angle",
   ".",
   "Positive",
   "numbers",
   "rotate",
   "counter",
   "-",
   "clockwise",
   "negative",
   "numbers",
   "rotate",
   "clockwise",
   ".",
   "Rotate",
   "commands",
   "are",
   "executed",
   "instantly",
   "so",
   "many",
   "subsequent",
   "rotates",
   "will",
   "distort",
   "the",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "rotate",
   "(",
   "self",
   ",",
   "angle",
   ")",
   ":",
   "#When a layer rotates, its corners will fall outside",
   "#of its defined width and height.",
   "#Thus, its bounding box needs to be expanded.",
   "#Calculate the diagonal width, and angle from the layer center.",
   "#This way we can use the layers's corners ",
   "#to calculate the bounding box.",
   "from",
   "math",
   "import",
   "sqrt",
   ",",
   "pow",
   ",",
   "sin",
   ",",
   "cos",
   ",",
   "degrees",
   ",",
   "radians",
   ",",
   "asin",
   "w0",
   ",",
   "h0",
   "=",
   "self",
   ".",
   "img",
   ".",
   "size",
   "d",
   "=",
   "sqrt",
   "(",
   "pow",
   "(",
   "w0",
   ",",
   "2",
   ")",
   "+",
   "pow",
   "(",
   "h0",
   ",",
   "2",
   ")",
   ")",
   "d_angle",
   "=",
   "degrees",
   "(",
   "asin",
   "(",
   "(",
   "w0",
   "*",
   "0.5",
   ")",
   "/",
   "(",
   "d",
   "*",
   "0.5",
   ")",
   ")",
   ")",
   "angle",
   "=",
   "angle",
   "%",
   "360",
   "if",
   "angle",
   ">",
   "90",
   "and",
   "angle",
   "<=",
   "270",
   ":",
   "d_angle",
   "+=",
   "180",
   "w",
   "=",
   "sin",
   "(",
   "radians",
   "(",
   "d_angle",
   "+",
   "angle",
   ")",
   ")",
   "*",
   "d",
   "w",
   "=",
   "<mask>",
   "(",
   "w",
   ",",
   "sin",
   "(",
   "radians",
   "(",
   "d_angle",
   "-",
   "angle",
   ")",
   ")",
   "*",
   "d",
   ")",
   "w",
   "=",
   "int",
   "(",
   "abs",
   "(",
   "w",
   ")",
   ")",
   "h",
   "=",
   "cos",
   "(",
   "radians",
   "(",
   "d_angle",
   "+",
   "angle",
   ")",
   ")",
   "*",
   "d",
   "h",
   "=",
   "max",
   "(",
   "h",
   ",",
   "cos",
   "(",
   "radians",
   "(",
   "d_angle",
   "-",
   "angle",
   ")",
   ")",
   "*",
   "d",
   ")",
   "h",
   "=",
   "int",
   "(",
   "abs",
   "(",
   "h",
   ")",
   ")",
   "dx",
   "=",
   "int",
   "(",
   "(",
   "w",
   "-",
   "w0",
   ")",
   "/",
   "2",
   ")",
   "dy",
   "=",
   "int",
   "(",
   "(",
   "h",
   "-",
   "h0",
   ")",
   "/",
   "2",
   ")",
   "d",
   "=",
   "int",
   "(",
   "d",
   ")",
   "#The rotation box's background color",
   "#is the mean pixel value of the rotating image.",
   "#This is the best option to avoid borders around",
   "#the rotated image.",
   "bg",
   "=",
   "ImageStat",
   ".",
   "Stat",
   "(",
   "self",
   ".",
   "img",
   ")",
   ".",
   "mean",
   "bg",
   "=",
   "(",
   "int",
   "(",
   "bg",
   "[",
   "0",
   "]",
   ")",
   ",",
   "int",
   "(",
   "bg",
   "[",
   "1",
   "]",
   ")",
   ",",
   "int",
   "(",
   "bg",
   "[",
   "2",
   "]",
   ")",
   ",",
   "0",
   ")",
   "box",
   "=",
   "Image",
   ".",
   "new",
   "(",
   "\"RGBA\"",
   ",",
   "(",
   "d",
   ",",
   "d",
   ")",
   ",",
   "bg",
   ")",
   "box",
   ".",
   "paste",
   "(",
   "self",
   ".",
   "img",
   ",",
   "(",
   "(",
   "d",
   "-",
   "w0",
   ")",
   "/",
   "2",
   ",",
   "(",
   "d",
   "-",
   "h0",
   ")",
   "/",
   "2",
   ")",
   ")",
   "box",
   "=",
   "box",
   ".",
   "rotate",
   "(",
   "angle",
   ",",
   "INTERPOLATION",
   ")",
   "box",
   "=",
   "box",
   ".",
   "crop",
   "(",
   "(",
   "(",
   "d",
   "-",
   "w",
   ")",
   "/",
   "2",
   "+",
   "2",
   ",",
   "(",
   "d",
   "-",
   "h",
   ")",
   "/",
   "2",
   ",",
   "d",
   "-",
   "(",
   "d",
   "-",
   "w",
   ")",
   "/",
   "2",
   ",",
   "d",
   "-",
   "(",
   "d",
   "-",
   "h",
   ")",
   "/",
   "2",
   ")",
   ")",
   "self",
   ".",
   "img",
   "=",
   "box",
   "#Since rotate changes the bounding box size,",
   "#update the layers' width, height, and position,",
   "#so it rotates from the center.",
   "self",
   ".",
   "x",
   "+=",
   "(",
   "self",
   ".",
   "w",
   "-",
   "w",
   ")",
   "/",
   "2",
   "self",
   ".",
   "y",
   "+=",
   "(",
   "self",
   ".",
   "h",
   "-",
   "h",
   ")",
   "/",
   "2",
   "self",
   ".",
   "w",
   "=",
   "w",
   "self",
   ".",
   "h",
   "=",
   "h"
  ]
 },
 {
  "idx": "maxmin-165",
  "nl_tokens": [
   "Return",
   "the",
   "Tversky",
   "index",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "qval",
   "=",
   "2",
   ",",
   "alpha",
   "=",
   "1",
   ",",
   "beta",
   "=",
   "1",
   ",",
   "bias",
   "=",
   "None",
   ")",
   ":",
   "if",
   "alpha",
   "<",
   "0",
   "or",
   "beta",
   "<",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Unsupported weight assignment; alpha and beta '",
   "+",
   "'must be greater than or equal to 0.'",
   ")",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "1.0",
   "elif",
   "not",
   "src",
   "or",
   "not",
   "tar",
   ":",
   "return",
   "0.0",
   "q_src",
   ",",
   "q_tar",
   "=",
   "self",
   ".",
   "_get_qgrams",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "qval",
   ")",
   "q_src_mag",
   "=",
   "sum",
   "(",
   "q_src",
   ".",
   "values",
   "(",
   ")",
   ")",
   "q_tar_mag",
   "=",
   "sum",
   "(",
   "q_tar",
   ".",
   "values",
   "(",
   ")",
   ")",
   "q_intersection_mag",
   "=",
   "sum",
   "(",
   "(",
   "q_src",
   "&",
   "q_tar",
   ")",
   ".",
   "values",
   "(",
   ")",
   ")",
   "if",
   "not",
   "q_src",
   "or",
   "not",
   "q_tar",
   ":",
   "return",
   "0.0",
   "if",
   "bias",
   "is",
   "None",
   ":",
   "return",
   "q_intersection_mag",
   "/",
   "(",
   "q_intersection_mag",
   "+",
   "alpha",
   "*",
   "(",
   "q_src_mag",
   "-",
   "q_intersection_mag",
   ")",
   "+",
   "beta",
   "*",
   "(",
   "q_tar_mag",
   "-",
   "q_intersection_mag",
   ")",
   ")",
   "a_val",
   "=",
   "<mask>",
   "(",
   "q_src_mag",
   "-",
   "q_intersection_mag",
   ",",
   "q_tar_mag",
   "-",
   "q_intersection_mag",
   ")",
   "b_val",
   "=",
   "max",
   "(",
   "q_src_mag",
   "-",
   "q_intersection_mag",
   ",",
   "q_tar_mag",
   "-",
   "q_intersection_mag",
   ")",
   "c_val",
   "=",
   "q_intersection_mag",
   "+",
   "bias",
   "return",
   "c_val",
   "/",
   "(",
   "beta",
   "*",
   "(",
   "alpha",
   "*",
   "a_val",
   "+",
   "(",
   "1",
   "-",
   "alpha",
   ")",
   "*",
   "b_val",
   ")",
   "+",
   "c_val",
   ")"
  ]
 },
 {
  "idx": "maxmin-166",
  "nl_tokens": [
   "Create",
   "a",
   "string",
   "representation",
   "for",
   "each",
   "item",
   "in",
   "a",
   "dict",
   "."
  ],
  "pl_tokens": [
   "def",
   "_dict_itemstrs",
   "(",
   "dict_",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "import",
   "ubelt",
   "as",
   "ub",
   "explicit",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'explicit'",
   ",",
   "False",
   ")",
   "kwargs",
   "[",
   "'explicit'",
   "]",
   "=",
   "_rectify_countdown_or_bool",
   "(",
   "explicit",
   ")",
   "precision",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'precision'",
   ",",
   "None",
   ")",
   "kvsep",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'kvsep'",
   ",",
   "': '",
   ")",
   "if",
   "explicit",
   ":",
   "kvsep",
   "=",
   "'='",
   "def",
   "make_item_str",
   "(",
   "key",
   ",",
   "val",
   ")",
   ":",
   "if",
   "explicit",
   "or",
   "kwargs",
   ".",
   "get",
   "(",
   "'strkeys'",
   ",",
   "False",
   ")",
   ":",
   "key_str",
   "=",
   "six",
   ".",
   "text_type",
   "(",
   "key",
   ")",
   "else",
   ":",
   "key_str",
   "=",
   "repr2",
   "(",
   "key",
   ",",
   "precision",
   "=",
   "precision",
   ",",
   "newlines",
   "=",
   "0",
   ")",
   "prefix",
   "=",
   "key_str",
   "+",
   "kvsep",
   "kwargs",
   "[",
   "'_return_info'",
   "]",
   "=",
   "True",
   "val_str",
   ",",
   "_leaf_info",
   "=",
   "repr2",
   "(",
   "val",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "# If the first line does not end with an open nest char",
   "# (e.g. for ndarrays), otherwise we need to worry about",
   "# residual indentation.",
   "pos",
   "=",
   "val_str",
   ".",
   "find",
   "(",
   "'\\n'",
   ")",
   "first_line",
   "=",
   "val_str",
   "if",
   "pos",
   "==",
   "-",
   "1",
   "else",
   "val_str",
   "[",
   ":",
   "pos",
   "]",
   "compact_brace",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'cbr'",
   ",",
   "kwargs",
   ".",
   "get",
   "(",
   "'compact_brace'",
   ",",
   "False",
   ")",
   ")",
   "if",
   "compact_brace",
   "or",
   "not",
   "first_line",
   ".",
   "rstrip",
   "(",
   ")",
   ".",
   "endswith",
   "(",
   "tuple",
   "(",
   "'([{<'",
   ")",
   ")",
   ":",
   "rest",
   "=",
   "''",
   "if",
   "pos",
   "==",
   "-",
   "1",
   "else",
   "val_str",
   "[",
   "pos",
   ":",
   "]",
   "val_str",
   "=",
   "first_line",
   ".",
   "lstrip",
   "(",
   ")",
   "+",
   "rest",
   "if",
   "'\\n'",
   "in",
   "prefix",
   ":",
   "# Fix issue with keys that span new lines",
   "item_str",
   "=",
   "prefix",
   "+",
   "val_str",
   "else",
   ":",
   "item_str",
   "=",
   "ub",
   ".",
   "hzcat",
   "(",
   "[",
   "prefix",
   ",",
   "val_str",
   "]",
   ")",
   "else",
   ":",
   "item_str",
   "=",
   "prefix",
   "+",
   "val_str",
   "return",
   "item_str",
   ",",
   "_leaf_info",
   "items",
   "=",
   "list",
   "(",
   "six",
   ".",
   "iteritems",
   "(",
   "dict_",
   ")",
   ")",
   "_tups",
   "=",
   "[",
   "make_item_str",
   "(",
   "key",
   ",",
   "val",
   ")",
   "for",
   "(",
   "key",
   ",",
   "val",
   ")",
   "in",
   "items",
   "]",
   "itemstrs",
   "=",
   "[",
   "t",
   "[",
   "0",
   "]",
   "for",
   "t",
   "in",
   "_tups",
   "]",
   "max_height",
   "=",
   "<mask>",
   "(",
   "[",
   "t",
   "[",
   "1",
   "]",
   "[",
   "'max_height'",
   "]",
   "for",
   "t",
   "in",
   "_tups",
   "]",
   ")",
   "if",
   "_tups",
   "else",
   "0",
   "_leaf_info",
   "=",
   "{",
   "'max_height'",
   ":",
   "max_height",
   "+",
   "1",
   ",",
   "}",
   "sort",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'sort'",
   ",",
   "None",
   ")",
   "if",
   "sort",
   "is",
   "None",
   ":",
   "# Force ordering on unordered dicts",
   "sort",
   "=",
   "True",
   "if",
   "isinstance",
   "(",
   "dict_",
   ",",
   "collections",
   ".",
   "OrderedDict",
   ")",
   ":",
   "# never sort ordered dicts; they are perfect just the way they are!",
   "sort",
   "=",
   "False",
   "if",
   "sort",
   ":",
   "itemstrs",
   "=",
   "_sort_itemstrs",
   "(",
   "items",
   ",",
   "itemstrs",
   ")",
   "return",
   "itemstrs",
   ",",
   "_leaf_info"
  ]
 },
 {
  "idx": "maxmin-167",
  "nl_tokens": [
   "Gets",
   "an",
   "artifact",
   "directory",
   "by",
   "its",
   "path",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_directory",
   "(",
   "self",
   ",",
   "path_to_directory",
   ",",
   "timeout",
   "=",
   "30",
   ",",
   "backoff",
   "=",
   "0.4",
   ",",
   "max_wait",
   "=",
   "4",
   ")",
   ":",
   "response",
   "=",
   "None",
   "started_at",
   "=",
   "None",
   "time_elapsed",
   "=",
   "0",
   "i",
   "=",
   "0",
   "while",
   "time_elapsed",
   "<",
   "timeout",
   ":",
   "response",
   "=",
   "self",
   ".",
   "_get",
   "(",
   "'{0}.zip'",
   ".",
   "format",
   "(",
   "path_to_directory",
   ")",
   ")",
   "if",
   "response",
   ":",
   "break",
   "else",
   ":",
   "if",
   "started_at",
   "is",
   "None",
   ":",
   "started_at",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "<mask>",
   "(",
   "backoff",
   "*",
   "(",
   "2",
   "**",
   "i",
   ")",
   ",",
   "max_wait",
   ")",
   ")",
   "i",
   "+=",
   "1",
   "time_elapsed",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "started_at",
   "return",
   "response"
  ]
 },
 {
  "idx": "maxmin-168",
  "nl_tokens": [
   "Add",
   "the",
   "label",
   "labelName",
   "to",
   "each",
   "record",
   "with",
   "record",
   "ROWID",
   "in",
   "range",
   "from",
   "start",
   "to",
   "end",
   "noninclusive",
   "of",
   "end",
   "."
  ],
  "pl_tokens": [
   "def",
   "addLabel",
   "(",
   "self",
   ",",
   "start",
   ",",
   "end",
   ",",
   "labelName",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for 'addLabel'. \"",
   "\"Model has no saved records.\"",
   ")",
   "try",
   ":",
   "start",
   "=",
   "int",
   "(",
   "start",
   ")",
   "except",
   "Exception",
   ":",
   "start",
   "=",
   "0",
   "try",
   ":",
   "end",
   "=",
   "int",
   "(",
   "end",
   ")",
   "except",
   "Exception",
   ":",
   "end",
   "=",
   "int",
   "(",
   "self",
   ".",
   "_recordsCache",
   "[",
   "-",
   "1",
   "]",
   ".",
   "ROWID",
   ")",
   "startID",
   "=",
   "self",
   ".",
   "_recordsCache",
   "[",
   "0",
   "]",
   ".",
   "ROWID",
   "clippedStart",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "start",
   "-",
   "startID",
   ")",
   "clippedEnd",
   "=",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   ",",
   "end",
   "-",
   "startID",
   ")",
   ")",
   "if",
   "clippedEnd",
   "<=",
   "clippedStart",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for 'addLabel'.\"",
   ",",
   "debugInfo",
   "=",
   "{",
   "'requestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "start",
   ",",
   "'endRecordID'",
   ":",
   "end",
   "}",
   ",",
   "'clippedRequestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "clippedStart",
   ",",
   "'endRecordID'",
   ":",
   "clippedEnd",
   "}",
   ",",
   "'validRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "startID",
   ",",
   "'endRecordID'",
   ":",
   "self",
   ".",
   "_recordsCache",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "-",
   "1",
   "]",
   ".",
   "ROWID",
   "}",
   ",",
   "'numRecordsStored'",
   ":",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "}",
   ")",
   "# Add label to range [clippedStart, clippedEnd)",
   "for",
   "state",
   "in",
   "self",
   ".",
   "_recordsCache",
   "[",
   "clippedStart",
   ":",
   "clippedEnd",
   "]",
   ":",
   "if",
   "labelName",
   "not",
   "in",
   "state",
   ".",
   "anomalyLabel",
   ":",
   "state",
   ".",
   "anomalyLabel",
   ".",
   "append",
   "(",
   "labelName",
   ")",
   "state",
   ".",
   "setByUser",
   "=",
   "True",
   "self",
   ".",
   "_addRecordToKNN",
   "(",
   "state",
   ")",
   "assert",
   "len",
   "(",
   "self",
   ".",
   "saved_categories",
   ")",
   ">",
   "0",
   "# Recompute [end, ...)",
   "for",
   "state",
   "in",
   "self",
   ".",
   "_recordsCache",
   "[",
   "clippedEnd",
   ":",
   "]",
   ":",
   "self",
   ".",
   "_classifyState",
   "(",
   "state",
   ")"
  ]
 },
 {
  "idx": "maxmin-169",
  "nl_tokens": [
   "Produce",
   "two",
   "gametes",
   "an",
   "egg",
   "and",
   "a",
   "sperm",
   "from",
   "input",
   "Gods",
   ".",
   "Combine",
   "them",
   "to",
   "produce",
   "a",
   "genome",
   "a",
   "la",
   "sexual",
   "reproduction",
   ".",
   "Assign",
   "divinity",
   "according",
   "to",
   "probabilities",
   "in",
   "p_divinity",
   ".",
   "The",
   "more",
   "divine",
   "the",
   "parents",
   "the",
   "more",
   "divine",
   "their",
   "offspring",
   "."
  ],
  "pl_tokens": [
   "def",
   "reproduce_sexually",
   "(",
   "self",
   ",",
   "egg_donor",
   ",",
   "sperm_donor",
   ")",
   ":",
   "egg_word",
   "=",
   "random",
   ".",
   "choice",
   "(",
   "egg_donor",
   ".",
   "genome",
   ")",
   "egg",
   "=",
   "self",
   ".",
   "generate_gamete",
   "(",
   "egg_word",
   ")",
   "sperm_word",
   "=",
   "random",
   ".",
   "choice",
   "(",
   "sperm_donor",
   ".",
   "genome",
   ")",
   "sperm",
   "=",
   "self",
   ".",
   "generate_gamete",
   "(",
   "sperm_word",
   ")",
   "self",
   ".",
   "genome",
   "=",
   "list",
   "(",
   "set",
   "(",
   "egg",
   "+",
   "sperm",
   ")",
   ")",
   "# Eliminate duplicates",
   "self",
   ".",
   "parents",
   "=",
   "[",
   "egg_donor",
   ".",
   "name",
   ",",
   "sperm_donor",
   ".",
   "name",
   "]",
   "self",
   ".",
   "generation",
   "=",
   "<mask>",
   "(",
   "egg_donor",
   ".",
   "generation",
   ",",
   "sperm_donor",
   ".",
   "generation",
   ")",
   "+",
   "1",
   "sum_",
   "=",
   "egg_donor",
   ".",
   "divinity",
   "+",
   "sperm_donor",
   ".",
   "divinity",
   "self",
   ".",
   "divinity",
   "=",
   "int",
   "(",
   "npchoice",
   "(",
   "divinities",
   ",",
   "1",
   ",",
   "p",
   "=",
   "p_divinity",
   "[",
   "sum_",
   "]",
   ")",
   "[",
   "0",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-170",
  "nl_tokens": [
   "Displays",
   "a",
   "list",
   "of",
   "all",
   "environment",
   "key",
   "/",
   "value",
   "pairs",
   "for",
   "the",
   "current",
   "role",
   "."
  ],
  "pl_tokens": [
   "def",
   "show",
   "(",
   "keyword",
   "=",
   "''",
   ")",
   ":",
   "keyword",
   "=",
   "keyword",
   ".",
   "strip",
   "(",
   ")",
   ".",
   "lower",
   "(",
   ")",
   "max_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "k",
   ")",
   "for",
   "k",
   "in",
   "env",
   ".",
   "iterkeys",
   "(",
   ")",
   ")",
   "keyword_found",
   "=",
   "False",
   "for",
   "k",
   "in",
   "sorted",
   "(",
   "env",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ":",
   "if",
   "keyword",
   "and",
   "keyword",
   "not",
   "in",
   "k",
   ".",
   "lower",
   "(",
   ")",
   ":",
   "continue",
   "keyword_found",
   "=",
   "True",
   "#print '%s: %s' % (k, env[k])",
   "print",
   "(",
   "'%s: '",
   "%",
   "(",
   "k",
   ".",
   "ljust",
   "(",
   "max_len",
   ")",
   ",",
   ")",
   ")",
   "pprint",
   "(",
   "env",
   "[",
   "k",
   "]",
   ",",
   "indent",
   "=",
   "4",
   ")",
   "if",
   "keyword",
   ":",
   "if",
   "not",
   "keyword_found",
   ":",
   "print",
   "(",
   "'Keyword \"%s\" not found.'",
   "%",
   "keyword",
   ")"
  ]
 },
 {
  "idx": "maxmin-171",
  "nl_tokens": [
   "Determine",
   "if",
   "range",
   "of",
   "vector",
   "is",
   "close",
   "to",
   "zero",
   "."
  ],
  "pl_tokens": [
   "def",
   "zero_range",
   "(",
   "x",
   ",",
   "tol",
   "=",
   "np",
   ".",
   "finfo",
   "(",
   "float",
   ")",
   ".",
   "eps",
   "*",
   "100",
   ")",
   ":",
   "try",
   ":",
   "if",
   "len",
   "(",
   "x",
   ")",
   "==",
   "1",
   ":",
   "return",
   "True",
   "except",
   "TypeError",
   ":",
   "return",
   "True",
   "if",
   "len",
   "(",
   "x",
   ")",
   "!=",
   "2",
   ":",
   "raise",
   "ValueError",
   "(",
   "'x must be length 1 or 2'",
   ")",
   "# Deals with array_likes that have non-standard indices",
   "x",
   "=",
   "tuple",
   "(",
   "x",
   ")",
   "# datetime - pandas, cpython",
   "if",
   "isinstance",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "(",
   "pd",
   ".",
   "Timestamp",
   ",",
   "datetime",
   ".",
   "datetime",
   ")",
   ")",
   ":",
   "# date2num include timezone info, .toordinal() does not",
   "x",
   "=",
   "date2num",
   "(",
   "x",
   ")",
   "# datetime - numpy",
   "elif",
   "isinstance",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "np",
   ".",
   "datetime64",
   ")",
   ":",
   "return",
   "x",
   "[",
   "0",
   "]",
   "==",
   "x",
   "[",
   "1",
   "]",
   "# timedelta - pandas, cpython",
   "elif",
   "isinstance",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "(",
   "pd",
   ".",
   "Timedelta",
   ",",
   "datetime",
   ".",
   "timedelta",
   ")",
   ")",
   ":",
   "x",
   "=",
   "x",
   "[",
   "0",
   "]",
   ".",
   "total_seconds",
   "(",
   ")",
   ",",
   "x",
   "[",
   "1",
   "]",
   ".",
   "total_seconds",
   "(",
   ")",
   "# timedelta - numpy",
   "elif",
   "isinstance",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "np",
   ".",
   "timedelta64",
   ")",
   ":",
   "return",
   "x",
   "[",
   "0",
   "]",
   "==",
   "x",
   "[",
   "1",
   "]",
   "elif",
   "not",
   "isinstance",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "(",
   "float",
   ",",
   "int",
   ",",
   "np",
   ".",
   "number",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"zero_range objects cannot work with objects \"",
   "\"of type '{}'\"",
   ".",
   "format",
   "(",
   "type",
   "(",
   "x",
   "[",
   "0",
   "]",
   ")",
   ")",
   ")",
   "if",
   "any",
   "(",
   "np",
   ".",
   "isnan",
   "(",
   "x",
   ")",
   ")",
   ":",
   "return",
   "np",
   ".",
   "nan",
   "if",
   "x",
   "[",
   "0",
   "]",
   "==",
   "x",
   "[",
   "1",
   "]",
   ":",
   "return",
   "True",
   "if",
   "all",
   "(",
   "np",
   ".",
   "isinf",
   "(",
   "x",
   ")",
   ")",
   ":",
   "return",
   "False",
   "m",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "if",
   "m",
   "==",
   "0",
   ":",
   "return",
   "False",
   "return",
   "np",
   ".",
   "abs",
   "(",
   "(",
   "x",
   "[",
   "0",
   "]",
   "-",
   "x",
   "[",
   "1",
   "]",
   ")",
   "/",
   "m",
   ")",
   "<",
   "tol"
  ]
 },
 {
  "idx": "maxmin-172",
  "nl_tokens": [
   "Draw",
   "the",
   "line",
   "segments",
   "and",
   "points",
   "of",
   "the",
   "line",
   "string",
   "as",
   "a",
   "heatmap",
   "array",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw_heatmap_array",
   "(",
   "self",
   ",",
   "image_shape",
   ",",
   "alpha_lines",
   "=",
   "1.0",
   ",",
   "alpha_points",
   "=",
   "1.0",
   ",",
   "size_lines",
   "=",
   "1",
   ",",
   "size_points",
   "=",
   "0",
   ",",
   "antialiased",
   "=",
   "True",
   ",",
   "raise_if_out_of_image",
   "=",
   "False",
   ")",
   ":",
   "heatmap_lines",
   "=",
   "self",
   ".",
   "draw_lines_heatmap_array",
   "(",
   "image_shape",
   ",",
   "alpha",
   "=",
   "alpha_lines",
   ",",
   "size",
   "=",
   "size_lines",
   ",",
   "antialiased",
   "=",
   "antialiased",
   ",",
   "raise_if_out_of_image",
   "=",
   "raise_if_out_of_image",
   ")",
   "if",
   "size_points",
   "<=",
   "0",
   ":",
   "return",
   "heatmap_lines",
   "heatmap_points",
   "=",
   "self",
   ".",
   "draw_points_heatmap_array",
   "(",
   "image_shape",
   ",",
   "alpha",
   "=",
   "alpha_points",
   ",",
   "size",
   "=",
   "size_points",
   ",",
   "raise_if_out_of_image",
   "=",
   "raise_if_out_of_image",
   ")",
   "heatmap",
   "=",
   "np",
   ".",
   "dstack",
   "(",
   "[",
   "heatmap_lines",
   ",",
   "heatmap_points",
   "]",
   ")",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "heatmap",
   ",",
   "axis",
   "=",
   "2",
   ")"
  ]
 },
 {
  "idx": "maxmin-173",
  "nl_tokens": [
   "This",
   "is",
   "the",
   "parallel",
   "version",
   "of",
   "the",
   "function",
   "above",
   "."
  ],
  "pl_tokens": [
   "def",
   "pdw_period_find",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "init_p",
   "=",
   "None",
   ",",
   "end_p",
   "=",
   "None",
   ",",
   "f_step",
   "=",
   "1.0e-4",
   ",",
   "phasebinsize",
   "=",
   "None",
   ",",
   "sigclip",
   "=",
   "10.0",
   ",",
   "nworkers",
   "=",
   "None",
   ",",
   "verbose",
   "=",
   "False",
   ")",
   ":",
   "# remove nans",
   "find",
   "=",
   "npisfinite",
   "(",
   "times",
   ")",
   "&",
   "npisfinite",
   "(",
   "mags",
   ")",
   "&",
   "npisfinite",
   "(",
   "errs",
   ")",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   "=",
   "times",
   "[",
   "find",
   "]",
   ",",
   "mags",
   "[",
   "find",
   "]",
   ",",
   "errs",
   "[",
   "find",
   "]",
   "mod_mags",
   "=",
   "(",
   "fmags",
   "-",
   "npmin",
   "(",
   "fmags",
   ")",
   ")",
   "/",
   "(",
   "2.0",
   "*",
   "(",
   "npmax",
   "(",
   "fmags",
   ")",
   "-",
   "npmin",
   "(",
   "fmags",
   ")",
   ")",
   ")",
   "-",
   "0.25",
   "if",
   "len",
   "(",
   "ftimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "fmags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "ferrs",
   ")",
   ">",
   "9",
   ":",
   "# get the median and stdev = 1.483 x MAD",
   "median_mag",
   "=",
   "np",
   ".",
   "median",
   "(",
   "fmags",
   ")",
   "stddev_mag",
   "=",
   "(",
   "np",
   ".",
   "median",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "fmags",
   "-",
   "median_mag",
   ")",
   ")",
   ")",
   "*",
   "1.483",
   "# sigclip next",
   "if",
   "sigclip",
   ":",
   "sigind",
   "=",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "fmags",
   "-",
   "median_mag",
   ")",
   ")",
   "<",
   "(",
   "sigclip",
   "*",
   "stddev_mag",
   ")",
   "stimes",
   "=",
   "ftimes",
   "[",
   "sigind",
   "]",
   "smags",
   "=",
   "fmags",
   "[",
   "sigind",
   "]",
   "serrs",
   "=",
   "ferrs",
   "[",
   "sigind",
   "]",
   "LOGINFO",
   "(",
   "'sigclip = %s: before = %s observations, '",
   "'after = %s observations'",
   "%",
   "(",
   "sigclip",
   ",",
   "len",
   "(",
   "times",
   ")",
   ",",
   "len",
   "(",
   "stimes",
   ")",
   ")",
   ")",
   "else",
   ":",
   "stimes",
   "=",
   "ftimes",
   "smags",
   "=",
   "fmags",
   "serrs",
   "=",
   "ferrs",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# get the frequencies to use",
   "if",
   "init_p",
   ":",
   "endf",
   "=",
   "1.0",
   "/",
   "init_p",
   "else",
   ":",
   "# default start period is 0.1 day",
   "endf",
   "=",
   "1.0",
   "/",
   "0.1",
   "if",
   "end_p",
   ":",
   "startf",
   "=",
   "1.0",
   "/",
   "end_p",
   "else",
   ":",
   "# default end period is length of time series",
   "startf",
   "=",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# if we're not using autofreq, then use the provided frequencies",
   "if",
   "not",
   "autofreq",
   ":",
   "frequencies",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "startf",
   ",",
   "endf",
   ",",
   "stepsize",
   ")",
   "LOGINFO",
   "(",
   "'using %s frequency points, start P = %.3f, end P = %.3f'",
   "%",
   "(",
   "frequencies",
   ".",
   "size",
   ",",
   "1.0",
   "/",
   "endf",
   ",",
   "1.0",
   "/",
   "startf",
   ")",
   ")",
   "else",
   ":",
   "# this gets an automatic grid of frequencies to use",
   "frequencies",
   "=",
   "get_frequency_grid",
   "(",
   "stimes",
   ",",
   "minfreq",
   "=",
   "startf",
   ",",
   "maxfreq",
   "=",
   "endf",
   ")",
   "LOGINFO",
   "(",
   "'using autofreq with %s frequency points, '",
   "'start P = %.3f, end P = %.3f'",
   "%",
   "(",
   "frequencies",
   ".",
   "size",
   ",",
   "1.0",
   "/",
   "frequencies",
   ".",
   "max",
   "(",
   ")",
   ",",
   "1.0",
   "/",
   "frequencies",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "# set up some internal stuff",
   "fold_time",
   "=",
   "npmin",
   "(",
   "ftimes",
   ")",
   "# fold at the first time element",
   "j_range",
   "=",
   "len",
   "(",
   "fmags",
   ")",
   "-",
   "1",
   "epsilon",
   "=",
   "2.0",
   "*",
   "npmean",
   "(",
   "ferrs",
   ")",
   "delta_l",
   "=",
   "0.34",
   "*",
   "(",
   "epsilon",
   "-",
   "0.5",
   "*",
   "(",
   "epsilon",
   "**",
   "2",
   ")",
   ")",
   "*",
   "(",
   "len",
   "(",
   "ftimes",
   ")",
   "-",
   "npsqrt",
   "(",
   "10.0",
   "/",
   "epsilon",
   ")",
   ")",
   "keep_threshold_1",
   "=",
   "1.6",
   "+",
   "1.2",
   "*",
   "delta_l",
   "l",
   "=",
   "0.212",
   "*",
   "len",
   "(",
   "ftimes",
   ")",
   "sig_l",
   "=",
   "len",
   "(",
   "ftimes",
   ")",
   "/",
   "37.5",
   "keep_threshold_2",
   "=",
   "l",
   "+",
   "4.0",
   "*",
   "sig_l",
   "# generate the tasks",
   "tasks",
   "=",
   "[",
   "(",
   "x",
   ",",
   "ftimes",
   ",",
   "mod_mags",
   ",",
   "fold_time",
   ",",
   "j_range",
   ",",
   "keep_threshold_1",
   ",",
   "keep_threshold_2",
   ",",
   "phasebinsize",
   ")",
   "for",
   "x",
   "in",
   "frequencies",
   "]",
   "# fire up the pool and farm out the tasks",
   "if",
   "(",
   "not",
   "nworkers",
   ")",
   "or",
   "(",
   "nworkers",
   ">",
   "NCPUS",
   ")",
   ":",
   "nworkers",
   "=",
   "NCPUS",
   "LOGINFO",
   "(",
   "'using %s workers...'",
   "%",
   "nworkers",
   ")",
   "pool",
   "=",
   "Pool",
   "(",
   "nworkers",
   ")",
   "strlen_results",
   "=",
   "pool",
   ".",
   "map",
   "(",
   "pdw_worker",
   ",",
   "tasks",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "del",
   "pool",
   "periods",
   ",",
   "strlens",
   ",",
   "goodflags",
   "=",
   "zip",
   "(",
   "*",
   "strlen_results",
   ")",
   "periods",
   ",",
   "strlens",
   ",",
   "goodflags",
   "=",
   "(",
   "np",
   ".",
   "array",
   "(",
   "periods",
   ")",
   ",",
   "np",
   ".",
   "array",
   "(",
   "strlens",
   ")",
   ",",
   "np",
   ".",
   "array",
   "(",
   "goodflags",
   ")",
   ")",
   "strlensort",
   "=",
   "npargsort",
   "(",
   "strlens",
   ")",
   "nbeststrlens",
   "=",
   "strlens",
   "[",
   "strlensort",
   "[",
   ":",
   "5",
   "]",
   "]",
   "nbestperiods",
   "=",
   "periods",
   "[",
   "strlensort",
   "[",
   ":",
   "5",
   "]",
   "]",
   "nbestflags",
   "=",
   "goodflags",
   "[",
   "strlensort",
   "[",
   ":",
   "5",
   "]",
   "]",
   "bestperiod",
   "=",
   "nbestperiods",
   "[",
   "0",
   "]",
   "beststrlen",
   "=",
   "nbeststrlens",
   "[",
   "0",
   "]",
   "bestflag",
   "=",
   "nbestflags",
   "[",
   "0",
   "]",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "bestperiod",
   ",",
   "'beststrlen'",
   ":",
   "beststrlen",
   ",",
   "'bestflag'",
   ":",
   "bestflag",
   ",",
   "'nbeststrlens'",
   ":",
   "nbeststrlens",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'nbestflags'",
   ":",
   "nbestflags",
   ",",
   "'strlens'",
   ":",
   "strlens",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'goodflags'",
   ":",
   "goodflags",
   "}",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'beststrlen'",
   ":",
   "npnan",
   ",",
   "'bestflag'",
   ":",
   "npnan",
   ",",
   "'nbeststrlens'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'nbestflags'",
   ":",
   "None",
   ",",
   "'strlens'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'goodflags'",
   ":",
   "None",
   "}",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'beststrlen'",
   ":",
   "npnan",
   ",",
   "'bestflag'",
   ":",
   "npnan",
   ",",
   "'nbeststrlens'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'nbestflags'",
   ":",
   "None",
   ",",
   "'strlens'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'goodflags'",
   ":",
   "None",
   "}"
  ]
 },
 {
  "idx": "maxmin-174",
  "nl_tokens": [
   "Makes",
   "list",
   "of",
   "next",
   "links"
  ],
  "pl_tokens": [
   "def",
   "_convert_flags",
   "(",
   "self",
   ",",
   "fromlist",
   ",",
   "tolist",
   ",",
   "flaglist",
   ",",
   "context",
   ",",
   "numlines",
   ")",
   ":",
   "# all anchor names will be generated using the unique \"to\" prefix",
   "toprefix",
   "=",
   "self",
   ".",
   "_prefix",
   "[",
   "1",
   "]",
   "# process change flags, generating middle column of next anchors/links",
   "next_id",
   "=",
   "[",
   "''",
   "]",
   "*",
   "len",
   "(",
   "flaglist",
   ")",
   "next_href",
   "=",
   "[",
   "''",
   "]",
   "*",
   "len",
   "(",
   "flaglist",
   ")",
   "num_chg",
   ",",
   "in_change",
   "=",
   "0",
   ",",
   "False",
   "last",
   "=",
   "0",
   "for",
   "i",
   ",",
   "flag",
   "in",
   "enumerate",
   "(",
   "flaglist",
   ")",
   ":",
   "if",
   "flag",
   ":",
   "if",
   "not",
   "in_change",
   ":",
   "in_change",
   "=",
   "True",
   "last",
   "=",
   "i",
   "# at the beginning of a change, drop an anchor a few lines",
   "# (the context lines) before the change for the previous",
   "# link",
   "i",
   "=",
   "<mask>",
   "(",
   "[",
   "0",
   ",",
   "i",
   "-",
   "numlines",
   "]",
   ")",
   "next_id",
   "[",
   "i",
   "]",
   "=",
   "' id=\"difflib_chg_%s_%d\"'",
   "%",
   "(",
   "toprefix",
   ",",
   "num_chg",
   ")",
   "# at the beginning of a change, drop a link to the next",
   "# change",
   "num_chg",
   "+=",
   "1",
   "next_href",
   "[",
   "last",
   "]",
   "=",
   "'<a href=\"#difflib_chg_%s_%d\">n</a>'",
   "%",
   "(",
   "toprefix",
   ",",
   "num_chg",
   ")",
   "else",
   ":",
   "in_change",
   "=",
   "False",
   "# check for cases where there is no content to avoid exceptions",
   "if",
   "not",
   "flaglist",
   ":",
   "flaglist",
   "=",
   "[",
   "False",
   "]",
   "next_id",
   "=",
   "[",
   "''",
   "]",
   "next_href",
   "=",
   "[",
   "''",
   "]",
   "last",
   "=",
   "0",
   "if",
   "context",
   ":",
   "fromlist",
   "=",
   "[",
   "'<td></td><td>&nbsp;No Differences Found&nbsp;</td>'",
   "]",
   "tolist",
   "=",
   "fromlist",
   "else",
   ":",
   "fromlist",
   "=",
   "tolist",
   "=",
   "[",
   "'<td></td><td>&nbsp;Empty File&nbsp;</td>'",
   "]",
   "# if not a change on first line, drop a link",
   "if",
   "not",
   "flaglist",
   "[",
   "0",
   "]",
   ":",
   "next_href",
   "[",
   "0",
   "]",
   "=",
   "'<a href=\"#difflib_chg_%s_0\">f</a>'",
   "%",
   "toprefix",
   "# redo the last link to link to the top",
   "next_href",
   "[",
   "last",
   "]",
   "=",
   "'<a href=\"#difflib_chg_%s_top\">t</a>'",
   "%",
   "(",
   "toprefix",
   ")",
   "return",
   "fromlist",
   ",",
   "tolist",
   ",",
   "flaglist",
   ",",
   "next_href",
   ",",
   "next_id"
  ]
 },
 {
  "idx": "maxmin-175",
  "nl_tokens": [
   "Flattens",
   "all",
   "layers",
   "according",
   "to",
   "their",
   "blend",
   "modes",
   ".",
   "Merges",
   "all",
   "layers",
   "to",
   "the",
   "canvas",
   "using",
   "the",
   "blend",
   "mode",
   "and",
   "opacity",
   "defined",
   "for",
   "each",
   "layer",
   ".",
   "Once",
   "flattened",
   "the",
   "stack",
   "of",
   "layers",
   "is",
   "emptied",
   "except",
   "for",
   "the",
   "transparent",
   "background",
   "(",
   "bottom",
   "layer",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "flatten",
   "(",
   "self",
   ",",
   "layers",
   "=",
   "[",
   "]",
   ")",
   ":",
   "#When the layers argument is omitted,",
   "#flattens all the layers on the canvas.",
   "#When given, merges the indexed layers.",
   "#Layers that fall outside of the canvas are cropped:",
   "#this should be fixed by merging to a transparent background",
   "#large enough to hold all the given layers' data",
   "#(=time consuming).",
   "if",
   "layers",
   "==",
   "[",
   "]",
   ":",
   "layers",
   "=",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "self",
   ".",
   "layers",
   ")",
   ")",
   "background",
   "=",
   "self",
   ".",
   "layers",
   ".",
   "_get_bg",
   "(",
   ")",
   "background",
   ".",
   "name",
   "=",
   "\"Background\"",
   "for",
   "i",
   "in",
   "layers",
   ":",
   "layer",
   "=",
   "self",
   ".",
   "layers",
   "[",
   "i",
   "]",
   "#Determine which portion of the canvas",
   "#needs to be updated with the overlaying layer.",
   "x",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "layer",
   ".",
   "x",
   ")",
   "y",
   "=",
   "max",
   "(",
   "0",
   ",",
   "layer",
   ".",
   "y",
   ")",
   "w",
   "=",
   "min",
   "(",
   "background",
   ".",
   "w",
   ",",
   "layer",
   ".",
   "x",
   "+",
   "layer",
   ".",
   "w",
   ")",
   "h",
   "=",
   "min",
   "(",
   "background",
   ".",
   "h",
   ",",
   "layer",
   ".",
   "y",
   "+",
   "layer",
   ".",
   "h",
   ")",
   "base",
   "=",
   "background",
   ".",
   "img",
   ".",
   "crop",
   "(",
   "(",
   "x",
   ",",
   "y",
   ",",
   "w",
   ",",
   "h",
   ")",
   ")",
   "#Determine which piece of the layer",
   "#falls within the canvas.",
   "x",
   "=",
   "max",
   "(",
   "0",
   ",",
   "-",
   "layer",
   ".",
   "x",
   ")",
   "y",
   "=",
   "max",
   "(",
   "0",
   ",",
   "-",
   "layer",
   ".",
   "y",
   ")",
   "w",
   "-=",
   "layer",
   ".",
   "x",
   "h",
   "-=",
   "layer",
   ".",
   "y",
   "blend",
   "=",
   "layer",
   ".",
   "img",
   ".",
   "crop",
   "(",
   "(",
   "x",
   ",",
   "y",
   ",",
   "w",
   ",",
   "h",
   ")",
   ")",
   "#Buffer layer blend modes:",
   "#the base below is a flattened version",
   "#of all the layers below this one,",
   "#on which to merge this blended layer.",
   "if",
   "layer",
   ".",
   "blend",
   "==",
   "NORMAL",
   ":",
   "buffer",
   "=",
   "blend",
   "if",
   "layer",
   ".",
   "blend",
   "==",
   "MULTIPLY",
   ":",
   "buffer",
   "=",
   "ImageChops",
   ".",
   "multiply",
   "(",
   "base",
   ",",
   "blend",
   ")",
   "if",
   "layer",
   ".",
   "blend",
   "==",
   "SCREEN",
   ":",
   "buffer",
   "=",
   "ImageChops",
   ".",
   "screen",
   "(",
   "base",
   ",",
   "blend",
   ")",
   "if",
   "layer",
   ".",
   "blend",
   "==",
   "OVERLAY",
   ":",
   "buffer",
   "=",
   "Blend",
   "(",
   ")",
   ".",
   "overlay",
   "(",
   "base",
   ",",
   "blend",
   ")",
   "if",
   "layer",
   ".",
   "blend",
   "==",
   "HUE",
   ":",
   "buffer",
   "=",
   "Blend",
   "(",
   ")",
   ".",
   "hue",
   "(",
   "base",
   ",",
   "blend",
   ")",
   "if",
   "layer",
   ".",
   "blend",
   "==",
   "COLOR",
   ":",
   "buffer",
   "=",
   "Blend",
   "(",
   ")",
   ".",
   "color",
   "(",
   "base",
   ",",
   "blend",
   ")",
   "#Buffer a merge between the base and blend",
   "#according to the blend's alpha channel:",
   "#the base shines through where the blend is less opaque.",
   "#Merging the first layer to the transparent canvas",
   "#works slightly different than the other layers.",
   "alpha",
   "=",
   "buffer",
   ".",
   "split",
   "(",
   ")",
   "[",
   "3",
   "]",
   "if",
   "i",
   "==",
   "1",
   ":",
   "buffer",
   "=",
   "Image",
   ".",
   "composite",
   "(",
   "base",
   ",",
   "buffer",
   ",",
   "base",
   ".",
   "split",
   "(",
   ")",
   "[",
   "3",
   "]",
   ")",
   "else",
   ":",
   "buffer",
   "=",
   "Image",
   ".",
   "composite",
   "(",
   "buffer",
   ",",
   "base",
   ",",
   "alpha",
   ")",
   "#The alpha channel becomes a composite of",
   "#this layer and the base:",
   "#the base's (optional) tranparent background",
   "#is retained in arrays where the blend layer",
   "#is transparent as well.",
   "alpha",
   "=",
   "ImageChops",
   ".",
   "lighter",
   "(",
   "alpha",
   ",",
   "base",
   ".",
   "split",
   "(",
   ")",
   "[",
   "3",
   "]",
   ")",
   "buffer",
   ".",
   "putalpha",
   "(",
   "alpha",
   ")",
   "#Apply the layer's opacity,",
   "#merging the buffer to the base with",
   "#the given layer opacity.",
   "base",
   "=",
   "Image",
   ".",
   "blend",
   "(",
   "base",
   ",",
   "buffer",
   ",",
   "layer",
   ".",
   "alpha",
   ")",
   "#Merge the base to the flattened canvas.",
   "x",
   "=",
   "max",
   "(",
   "0",
   ",",
   "layer",
   ".",
   "x",
   ")",
   "y",
   "=",
   "max",
   "(",
   "0",
   ",",
   "layer",
   ".",
   "y",
   ")",
   "background",
   ".",
   "img",
   ".",
   "paste",
   "(",
   "base",
   ",",
   "(",
   "x",
   ",",
   "y",
   ")",
   ")",
   "layers",
   ".",
   "reverse",
   "(",
   ")",
   "for",
   "i",
   "in",
   "layers",
   ":",
   "del",
   "self",
   ".",
   "layers",
   "[",
   "i",
   "]",
   "img",
   "=",
   "Image",
   ".",
   "new",
   "(",
   "\"RGBA\"",
   ",",
   "(",
   "self",
   ".",
   "w",
   ",",
   "self",
   ".",
   "h",
   ")",
   ",",
   "(",
   "255",
   ",",
   "255",
   ",",
   "255",
   ",",
   "0",
   ")",
   ")",
   "self",
   ".",
   "layers",
   ".",
   "_set_bg",
   "(",
   "Layer",
   "(",
   "self",
   ",",
   "img",
   ",",
   "0",
   ",",
   "0",
   ",",
   "name",
   "=",
   "\"_bg\"",
   ")",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "layers",
   ")",
   "==",
   "1",
   ":",
   "self",
   ".",
   "layers",
   ".",
   "append",
   "(",
   "background",
   ")",
   "else",
   ":",
   "self",
   ".",
   "layers",
   ".",
   "insert",
   "(",
   "layers",
   "[",
   "-",
   "1",
   "]",
   ",",
   "background",
   ")"
  ]
 },
 {
  "idx": "maxmin-176",
  "nl_tokens": [
   "Finds",
   "the",
   "longest",
   "estimated",
   "liquidation",
   "time",
   "for",
   "each",
   "traded",
   "name",
   "over",
   "the",
   "course",
   "of",
   "backtest",
   "(",
   "or",
   "last",
   "n",
   "days",
   "of",
   "the",
   "backtest",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_max_days_to_liquidate_by_ticker",
   "(",
   "positions",
   ",",
   "market_data",
   ",",
   "max_bar_consumption",
   "=",
   "0.2",
   ",",
   "capital_base",
   "=",
   "1e6",
   ",",
   "mean_volume_window",
   "=",
   "5",
   ",",
   "last_n_days",
   "=",
   "None",
   ")",
   ":",
   "dtlp",
   "=",
   "days_to_liquidate_positions",
   "(",
   "positions",
   ",",
   "market_data",
   ",",
   "max_bar_consumption",
   "=",
   "max_bar_consumption",
   ",",
   "capital_base",
   "=",
   "capital_base",
   ",",
   "mean_volume_window",
   "=",
   "mean_volume_window",
   ")",
   "if",
   "last_n_days",
   "is",
   "not",
   "None",
   ":",
   "dtlp",
   "=",
   "dtlp",
   ".",
   "loc",
   "[",
   "dtlp",
   ".",
   "index",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "pd",
   ".",
   "Timedelta",
   "(",
   "days",
   "=",
   "last_n_days",
   ")",
   ":",
   "]",
   "pos_alloc",
   "=",
   "pos",
   ".",
   "get_percent_alloc",
   "(",
   "positions",
   ")",
   "pos_alloc",
   "=",
   "pos_alloc",
   ".",
   "drop",
   "(",
   "'cash'",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "liq_desc",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   ")",
   "liq_desc",
   "[",
   "'days_to_liquidate'",
   "]",
   "=",
   "dtlp",
   ".",
   "unstack",
   "(",
   ")",
   "liq_desc",
   "[",
   "'pos_alloc_pct'",
   "]",
   "=",
   "pos_alloc",
   ".",
   "unstack",
   "(",
   ")",
   "*",
   "100",
   "liq_desc",
   ".",
   "index",
   ".",
   "levels",
   "[",
   "0",
   "]",
   ".",
   "name",
   "=",
   "'symbol'",
   "liq_desc",
   ".",
   "index",
   ".",
   "levels",
   "[",
   "1",
   "]",
   ".",
   "name",
   "=",
   "'date'",
   "worst_liq",
   "=",
   "liq_desc",
   ".",
   "reset_index",
   "(",
   ")",
   ".",
   "sort_values",
   "(",
   "'days_to_liquidate'",
   ",",
   "ascending",
   "=",
   "False",
   ")",
   ".",
   "groupby",
   "(",
   "'symbol'",
   ")",
   ".",
   "first",
   "(",
   ")",
   "return",
   "worst_liq"
  ]
 },
 {
  "idx": "maxmin-177",
  "nl_tokens": [
   "Generate",
   "some",
   "dimensions",
   "for",
   "resizing",
   "an",
   "object",
   ".",
   "This",
   "function",
   "DOES",
   "NOT",
   "handle",
   "scaling",
   "it",
   "simply",
   "calculates",
   "maximums",
   ".",
   "These",
   "values",
   "should",
   "then",
   "be",
   "passed",
   "to",
   "the",
   "resize",
   "()",
   "method",
   "which",
   "will",
   "scale",
   "it",
   "and",
   "return",
   "the",
   "scaled",
   "width",
   "&",
   "height",
   "."
  ],
  "pl_tokens": [
   "def",
   "size_to_nearest",
   "(",
   "width",
   "=",
   "None",
   ",",
   "height",
   "=",
   "None",
   ",",
   "allowed_sizes",
   "=",
   "OEMBED_ALLOWED_SIZES",
   ",",
   "force_fit",
   "=",
   "False",
   ")",
   ":",
   "minwidth",
   ",",
   "minheight",
   "=",
   "<mask>",
   "(",
   "allowed_sizes",
   ")",
   "maxwidth",
   ",",
   "maxheight",
   "=",
   "max",
   "(",
   "allowed_sizes",
   ")",
   "if",
   "not",
   "width",
   "and",
   "not",
   "height",
   ":",
   "return",
   "maxwidth",
   ",",
   "maxheight",
   "if",
   "width",
   ":",
   "width",
   "=",
   "int",
   "(",
   "width",
   ")",
   ">",
   "minwidth",
   "and",
   "int",
   "(",
   "width",
   ")",
   "or",
   "minwidth",
   "elif",
   "force_fit",
   ":",
   "width",
   "=",
   "maxwidth",
   "if",
   "height",
   ":",
   "height",
   "=",
   "int",
   "(",
   "height",
   ")",
   ">",
   "minheight",
   "and",
   "int",
   "(",
   "height",
   ")",
   "or",
   "minheight",
   "elif",
   "force_fit",
   ":",
   "height",
   "=",
   "maxheight",
   "for",
   "size",
   "in",
   "sorted",
   "(",
   "allowed_sizes",
   ")",
   ":",
   "if",
   "width",
   "and",
   "not",
   "height",
   ":",
   "if",
   "width",
   ">=",
   "size",
   "[",
   "0",
   "]",
   ":",
   "maxwidth",
   "=",
   "size",
   "[",
   "0",
   "]",
   "if",
   "force_fit",
   ":",
   "maxheight",
   "=",
   "size",
   "[",
   "1",
   "]",
   "else",
   ":",
   "break",
   "elif",
   "height",
   "and",
   "not",
   "width",
   ":",
   "if",
   "height",
   ">=",
   "size",
   "[",
   "1",
   "]",
   ":",
   "maxheight",
   "=",
   "size",
   "[",
   "1",
   "]",
   "if",
   "force_fit",
   ":",
   "maxwidth",
   "=",
   "size",
   "[",
   "0",
   "]",
   "else",
   ":",
   "break",
   "else",
   ":",
   "if",
   "force_fit",
   ":",
   "if",
   "(",
   "width",
   ">=",
   "size",
   "[",
   "0",
   "]",
   ")",
   "and",
   "(",
   "height",
   ">=",
   "size",
   "[",
   "1",
   "]",
   ")",
   ":",
   "maxwidth",
   ",",
   "maxheight",
   "=",
   "size",
   "else",
   ":",
   "break",
   "else",
   ":",
   "if",
   "width",
   ">=",
   "size",
   "[",
   "0",
   "]",
   ":",
   "maxwidth",
   "=",
   "size",
   "[",
   "0",
   "]",
   "if",
   "height",
   ">=",
   "size",
   "[",
   "1",
   "]",
   ":",
   "maxheight",
   "=",
   "size",
   "[",
   "1",
   "]",
   "return",
   "maxwidth",
   ",",
   "maxheight"
  ]
 },
 {
  "idx": "maxmin-178",
  "nl_tokens": [
   "Returns",
   "True",
   "if",
   "the",
   "given",
   "color",
   "is",
   "part",
   "of",
   "this",
   "color",
   "range",
   "."
  ],
  "pl_tokens": [
   "def",
   "contains",
   "(",
   "self",
   ",",
   "clr",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "clr",
   ",",
   "Color",
   ")",
   ":",
   "return",
   "False",
   "if",
   "not",
   "isinstance",
   "(",
   "clr",
   ",",
   "_list",
   ")",
   ":",
   "clr",
   "=",
   "[",
   "clr",
   "]",
   "for",
   "clr",
   "in",
   "clr",
   ":",
   "if",
   "clr",
   ".",
   "is_grey",
   "and",
   "not",
   "self",
   ".",
   "grayscale",
   ":",
   "return",
   "(",
   "self",
   ".",
   "black",
   ".",
   "contains",
   "(",
   "clr",
   ")",
   "or",
   "self",
   ".",
   "white",
   ".",
   "contains",
   "(",
   "clr",
   ")",
   ")",
   "for",
   "r",
   ",",
   "v",
   "in",
   "[",
   "(",
   "self",
   ".",
   "h",
   ",",
   "clr",
   ".",
   "h",
   ")",
   ",",
   "(",
   "self",
   ".",
   "s",
   ",",
   "clr",
   ".",
   "s",
   ")",
   ",",
   "(",
   "self",
   ".",
   "b",
   ",",
   "clr",
   ".",
   "brightness",
   ")",
   ",",
   "(",
   "self",
   ".",
   "a",
   ",",
   "clr",
   ".",
   "a",
   ")",
   "]",
   ":",
   "if",
   "isinstance",
   "(",
   "r",
   ",",
   "_list",
   ")",
   ":",
   "pass",
   "elif",
   "isinstance",
   "(",
   "r",
   ",",
   "tuple",
   ")",
   ":",
   "r",
   "=",
   "[",
   "r",
   "]",
   "else",
   ":",
   "r",
   "=",
   "[",
   "(",
   "r",
   ",",
   "r",
   ")",
   "]",
   "for",
   "<mask>",
   ",",
   "max",
   "in",
   "r",
   ":",
   "if",
   "not",
   "(",
   "min",
   "<=",
   "v",
   "<=",
   "max",
   ")",
   ":",
   "return",
   "False",
   "return",
   "True"
  ]
 },
 {
  "idx": "maxmin-179",
  "nl_tokens": [
   "Simulate",
   "mouse",
   "move",
   "to",
   "point",
   "x",
   "y",
   "from",
   "current",
   "cursor",
   ".",
   "x",
   ":",
   "int",
   ".",
   "y",
   ":",
   "int",
   ".",
   "moveSpeed",
   ":",
   "float",
   "1",
   "normal",
   "speed",
   "<",
   "1",
   "move",
   "slower",
   ">",
   "1",
   "move",
   "faster",
   ".",
   "waitTime",
   ":",
   "float",
   "."
  ],
  "pl_tokens": [
   "def",
   "MoveTo",
   "(",
   "x",
   ":",
   "int",
   ",",
   "y",
   ":",
   "int",
   ",",
   "moveSpeed",
   ":",
   "float",
   "=",
   "1",
   ",",
   "waitTime",
   ":",
   "float",
   "=",
   "OPERATION_WAIT_TIME",
   ")",
   "->",
   "None",
   ":",
   "if",
   "moveSpeed",
   "<=",
   "0",
   ":",
   "moveTime",
   "=",
   "0",
   "else",
   ":",
   "moveTime",
   "=",
   "MAX_MOVE_SECOND",
   "/",
   "moveSpeed",
   "curX",
   ",",
   "curY",
   "=",
   "GetCursorPos",
   "(",
   ")",
   "xCount",
   "=",
   "abs",
   "(",
   "x",
   "-",
   "curX",
   ")",
   "yCount",
   "=",
   "abs",
   "(",
   "y",
   "-",
   "curY",
   ")",
   "maxPoint",
   "=",
   "<mask>",
   "(",
   "xCount",
   ",",
   "yCount",
   ")",
   "screenWidth",
   ",",
   "screenHeight",
   "=",
   "GetScreenSize",
   "(",
   ")",
   "maxSide",
   "=",
   "max",
   "(",
   "screenWidth",
   ",",
   "screenHeight",
   ")",
   "minSide",
   "=",
   "min",
   "(",
   "screenWidth",
   ",",
   "screenHeight",
   ")",
   "if",
   "maxPoint",
   ">",
   "minSide",
   ":",
   "maxPoint",
   "=",
   "minSide",
   "if",
   "maxPoint",
   "<",
   "maxSide",
   ":",
   "maxPoint",
   "=",
   "100",
   "+",
   "int",
   "(",
   "(",
   "maxSide",
   "-",
   "100",
   ")",
   "/",
   "maxSide",
   "*",
   "maxPoint",
   ")",
   "moveTime",
   "=",
   "moveTime",
   "*",
   "maxPoint",
   "*",
   "1.0",
   "/",
   "maxSide",
   "stepCount",
   "=",
   "maxPoint",
   "//",
   "20",
   "if",
   "stepCount",
   ">",
   "1",
   ":",
   "xStep",
   "=",
   "(",
   "x",
   "-",
   "curX",
   ")",
   "*",
   "1.0",
   "/",
   "stepCount",
   "yStep",
   "=",
   "(",
   "y",
   "-",
   "curY",
   ")",
   "*",
   "1.0",
   "/",
   "stepCount",
   "interval",
   "=",
   "moveTime",
   "/",
   "stepCount",
   "for",
   "i",
   "in",
   "range",
   "(",
   "stepCount",
   ")",
   ":",
   "cx",
   "=",
   "curX",
   "+",
   "int",
   "(",
   "xStep",
   "*",
   "i",
   ")",
   "cy",
   "=",
   "curY",
   "+",
   "int",
   "(",
   "yStep",
   "*",
   "i",
   ")",
   "# upper-left(0,0), lower-right(65536,65536)",
   "# mouse_event(MouseEventFlag.Move | MouseEventFlag.Absolute, cx*65536//screenWidth, cy*65536//screenHeight, 0, 0)",
   "SetCursorPos",
   "(",
   "cx",
   ",",
   "cy",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "interval",
   ")",
   "SetCursorPos",
   "(",
   "x",
   ",",
   "y",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "waitTime",
   ")"
  ]
 },
 {
  "idx": "maxmin-180",
  "nl_tokens": [
   "Returns",
   "colors",
   "in",
   "the",
   "same",
   "hue",
   "with",
   "varying",
   "brightness",
   "/",
   "saturation",
   "."
  ],
  "pl_tokens": [
   "def",
   "monochrome",
   "(",
   "clr",
   ")",
   ":",
   "def",
   "_wrap",
   "(",
   "x",
   ",",
   "<mask>",
   ",",
   "threshold",
   ",",
   "plus",
   ")",
   ":",
   "if",
   "x",
   "-",
   "min",
   "<",
   "threshold",
   ":",
   "return",
   "x",
   "+",
   "plus",
   "else",
   ":",
   "return",
   "x",
   "-",
   "min",
   "colors",
   "=",
   "colorlist",
   "(",
   "clr",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "copy",
   "(",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.5",
   ",",
   "0.2",
   ",",
   "0.3",
   ")",
   "c",
   ".",
   "saturation",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "saturation",
   ",",
   "0.3",
   ",",
   "0.1",
   ",",
   "0.3",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "copy",
   "(",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.2",
   ",",
   "0.2",
   ",",
   "0.6",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "copy",
   "(",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "max",
   "(",
   "0.2",
   ",",
   "clr",
   ".",
   "brightness",
   "+",
   "(",
   "1",
   "-",
   "clr",
   ".",
   "brightness",
   ")",
   "*",
   "0.2",
   ")",
   "c",
   ".",
   "saturation",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "saturation",
   ",",
   "0.3",
   ",",
   "0.1",
   ",",
   "0.3",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "copy",
   "(",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.5",
   ",",
   "0.2",
   ",",
   "0.3",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "return",
   "colors"
  ]
 },
 {
  "idx": "maxmin-181",
  "nl_tokens": [
   "The",
   "average",
   "number",
   "of",
   "columns",
   "per",
   "input",
   "taking",
   "into",
   "account",
   "the",
   "topology",
   "of",
   "the",
   "inputs",
   "and",
   "columns",
   ".",
   "This",
   "value",
   "is",
   "used",
   "to",
   "calculate",
   "the",
   "inhibition",
   "radius",
   ".",
   "This",
   "function",
   "supports",
   "an",
   "arbitrary",
   "number",
   "of",
   "dimensions",
   ".",
   "If",
   "the",
   "number",
   "of",
   "column",
   "dimensions",
   "does",
   "not",
   "match",
   "the",
   "number",
   "of",
   "input",
   "dimensions",
   "we",
   "treat",
   "the",
   "missing",
   "or",
   "phantom",
   "dimensions",
   "as",
   "ones",
   "."
  ],
  "pl_tokens": [
   "def",
   "_avgColumnsPerInput",
   "(",
   "self",
   ")",
   ":",
   "#TODO: extend to support different number of dimensions for inputs and",
   "# columns",
   "numDim",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_columnDimensions",
   ".",
   "size",
   ",",
   "self",
   ".",
   "_inputDimensions",
   ".",
   "size",
   ")",
   "colDim",
   "=",
   "numpy",
   ".",
   "ones",
   "(",
   "numDim",
   ")",
   "colDim",
   "[",
   ":",
   "self",
   ".",
   "_columnDimensions",
   ".",
   "size",
   "]",
   "=",
   "self",
   ".",
   "_columnDimensions",
   "inputDim",
   "=",
   "numpy",
   ".",
   "ones",
   "(",
   "numDim",
   ")",
   "inputDim",
   "[",
   ":",
   "self",
   ".",
   "_inputDimensions",
   ".",
   "size",
   "]",
   "=",
   "self",
   ".",
   "_inputDimensions",
   "columnsPerInput",
   "=",
   "colDim",
   ".",
   "astype",
   "(",
   "realDType",
   ")",
   "/",
   "inputDim",
   "return",
   "numpy",
   ".",
   "average",
   "(",
   "columnsPerInput",
   ")"
  ]
 },
 {
  "idx": "maxmin-182",
  "nl_tokens": [
   "Gets",
   "the",
   "list",
   "of",
   "operations",
   "for",
   "the",
   "specified",
   "filter",
   "."
  ],
  "pl_tokens": [
   "def",
   "_operations_list",
   "(",
   "self",
   ",",
   "ops_filter",
   ",",
   "max_tasks",
   ",",
   "page_size",
   ",",
   "page_token",
   ")",
   ":",
   "# We are not using the documented default page size of 256,",
   "# nor allowing for the maximum page size of 2048 as larger page sizes",
   "# currently cause the operations.list() API to return an error:",
   "# HttpError 429 ... Resource has been exhausted (e.g. check quota).",
   "max_page_size",
   "=",
   "128",
   "# Set the page size to the smallest (non-zero) size we can",
   "page_size",
   "=",
   "<mask>",
   "(",
   "sz",
   "for",
   "sz",
   "in",
   "[",
   "page_size",
   ",",
   "max_page_size",
   ",",
   "max_tasks",
   "]",
   "if",
   "sz",
   ")",
   "# Execute operations.list() and return all of the dsub operations",
   "api",
   "=",
   "self",
   ".",
   "_service",
   ".",
   "projects",
   "(",
   ")",
   ".",
   "operations",
   "(",
   ")",
   ".",
   "list",
   "(",
   "name",
   "=",
   "'projects/{}/operations'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "_project",
   ")",
   ",",
   "filter",
   "=",
   "ops_filter",
   ",",
   "pageToken",
   "=",
   "page_token",
   ",",
   "pageSize",
   "=",
   "page_size",
   ")",
   "response",
   "=",
   "google_base",
   ".",
   "Api",
   ".",
   "execute",
   "(",
   "api",
   ")",
   "return",
   "[",
   "GoogleOperation",
   "(",
   "op",
   ")",
   "for",
   "op",
   "in",
   "response",
   ".",
   "get",
   "(",
   "'operations'",
   ",",
   "[",
   "]",
   ")",
   "if",
   "google_v2_operations",
   ".",
   "is_dsub_operation",
   "(",
   "op",
   ")",
   "]",
   ",",
   "response",
   ".",
   "get",
   "(",
   "'nextPageToken'",
   ")"
  ]
 },
 {
  "idx": "maxmin-183",
  "nl_tokens": [
   "Slice",
   "the",
   "annotation",
   "and",
   "return",
   "as",
   "a",
   "new",
   "Annotation",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "slice",
   "(",
   "self",
   ",",
   "start_time",
   ",",
   "end_time",
   ",",
   "strict",
   "=",
   "False",
   ")",
   ":",
   "# start by trimming the annotation",
   "sliced_ann",
   "=",
   "self",
   ".",
   "trim",
   "(",
   "start_time",
   ",",
   "end_time",
   ",",
   "strict",
   "=",
   "strict",
   ")",
   "raw_data",
   "=",
   "sliced_ann",
   ".",
   "pop_data",
   "(",
   ")",
   "# now adjust the start time of the annotation and the observations it",
   "# contains.",
   "for",
   "obs",
   "in",
   "raw_data",
   ":",
   "new_time",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "obs",
   ".",
   "time",
   "-",
   "start_time",
   ")",
   "# if obs.time > start_time,",
   "#   duration doesn't change",
   "# if obs.time < start_time,",
   "#   duration shrinks by start_time - obs.time",
   "sliced_ann",
   ".",
   "append",
   "(",
   "time",
   "=",
   "new_time",
   ",",
   "duration",
   "=",
   "obs",
   ".",
   "duration",
   ",",
   "value",
   "=",
   "obs",
   ".",
   "value",
   ",",
   "confidence",
   "=",
   "obs",
   ".",
   "confidence",
   ")",
   "ref_time",
   "=",
   "sliced_ann",
   ".",
   "time",
   "slice_start",
   "=",
   "ref_time",
   "slice_end",
   "=",
   "ref_time",
   "+",
   "sliced_ann",
   ".",
   "duration",
   "if",
   "'slice'",
   "not",
   "in",
   "sliced_ann",
   ".",
   "sandbox",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "sliced_ann",
   ".",
   "sandbox",
   ".",
   "update",
   "(",
   "slice",
   "=",
   "[",
   "{",
   "'start_time'",
   ":",
   "start_time",
   ",",
   "'end_time'",
   ":",
   "end_time",
   ",",
   "'slice_start'",
   ":",
   "slice_start",
   ",",
   "'slice_end'",
   ":",
   "slice_end",
   "}",
   "]",
   ")",
   "else",
   ":",
   "sliced_ann",
   ".",
   "sandbox",
   ".",
   "slice",
   ".",
   "append",
   "(",
   "{",
   "'start_time'",
   ":",
   "start_time",
   ",",
   "'end_time'",
   ":",
   "end_time",
   ",",
   "'slice_start'",
   ":",
   "slice_start",
   ",",
   "'slice_end'",
   ":",
   "slice_end",
   "}",
   ")",
   "# Update the timing for the sliced annotation",
   "sliced_ann",
   ".",
   "time",
   "=",
   "max",
   "(",
   "0",
   ",",
   "ref_time",
   "-",
   "start_time",
   ")",
   "return",
   "sliced_ann"
  ]
 },
 {
  "idx": "maxmin-184",
  "nl_tokens": [
   "Calculate",
   "the",
   "heat",
   "capacity",
   "of",
   "the",
   "compound",
   "phase",
   "at",
   "the",
   "specified",
   "temperature",
   "."
  ],
  "pl_tokens": [
   "def",
   "G",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "h",
   "=",
   "self",
   ".",
   "DHref",
   "s",
   "=",
   "self",
   ".",
   "Sref",
   "for",
   "Tmax",
   "in",
   "sorted",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   ":",
   "h",
   "=",
   "h",
   "+",
   "self",
   ".",
   "_Cp_records",
   "[",
   "str",
   "(",
   "Tmax",
   ")",
   "]",
   ".",
   "H",
   "(",
   "T",
   ")",
   "s",
   "=",
   "s",
   "+",
   "self",
   ".",
   "_Cp_records",
   "[",
   "str",
   "(",
   "Tmax",
   ")",
   "]",
   ".",
   "S",
   "(",
   "T",
   ")",
   "if",
   "T",
   "<=",
   "Tmax",
   ":",
   "return",
   "h",
   "-",
   "T",
   "*",
   "s",
   "+",
   "self",
   ".",
   "G_mag",
   "(",
   "T",
   ")",
   "# Extrapolate beyond the upper limit by using a constant heat capacity.",
   "Tmax",
   "=",
   "<mask>",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "h",
   "=",
   "h",
   "+",
   "self",
   ".",
   "Cp",
   "(",
   "Tmax",
   ")",
   "*",
   "(",
   "T",
   "-",
   "Tmax",
   ")",
   "s",
   "=",
   "s",
   "+",
   "self",
   ".",
   "Cp",
   "(",
   "Tmax",
   ")",
   "*",
   "math",
   ".",
   "log",
   "(",
   "T",
   "/",
   "Tmax",
   ")",
   "return",
   "h",
   "-",
   "T",
   "*",
   "s",
   "+",
   "self",
   ".",
   "G_mag",
   "(",
   "T",
   ")"
  ]
 },
 {
  "idx": "maxmin-185",
  "nl_tokens": [
   "Computes",
   "the",
   "percentage",
   "of",
   "overlap",
   "between",
   "vectors",
   "x1",
   "and",
   "x2",
   "."
  ],
  "pl_tokens": [
   "def",
   "percentOverlap",
   "(",
   "x1",
   ",",
   "x2",
   ",",
   "size",
   ")",
   ":",
   "nonZeroX1",
   "=",
   "np",
   ".",
   "count_nonzero",
   "(",
   "x1",
   ")",
   "nonZeroX2",
   "=",
   "np",
   ".",
   "count_nonzero",
   "(",
   "x2",
   ")",
   "minX1X2",
   "=",
   "<mask>",
   "(",
   "nonZeroX1",
   ",",
   "nonZeroX2",
   ")",
   "percentOverlap",
   "=",
   "0",
   "if",
   "minX1X2",
   ">",
   "0",
   ":",
   "percentOverlap",
   "=",
   "float",
   "(",
   "np",
   ".",
   "dot",
   "(",
   "x1",
   ",",
   "x2",
   ")",
   ")",
   "/",
   "float",
   "(",
   "minX1X2",
   ")",
   "return",
   "percentOverlap"
  ]
 },
 {
  "idx": "maxmin-186",
  "nl_tokens": [
   "This",
   "method",
   "generates",
   "a",
   ":",
   "class",
   ":",
   "PifSystemReturningQuery",
   "object",
   "using",
   "the",
   "supplied",
   "arguments",
   ".",
   "All",
   "arguments",
   "that",
   "accept",
   "lists",
   "have",
   "logical",
   "OR",
   "s",
   "on",
   "the",
   "queries",
   "that",
   "they",
   "generate",
   ".",
   "This",
   "means",
   "that",
   "for",
   "example",
   "simple_chemical_search",
   "(",
   "name",
   "=",
   "[",
   "A",
   "B",
   "]",
   ")",
   "will",
   "match",
   "records",
   "that",
   "have",
   "name",
   "equal",
   "to",
   "A",
   "or",
   "B",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_simple_chemical_query",
   "(",
   "self",
   ",",
   "name",
   "=",
   "None",
   ",",
   "chemical_formula",
   "=",
   "None",
   ",",
   "property_name",
   "=",
   "None",
   ",",
   "property_value",
   "=",
   "None",
   ",",
   "property_min",
   "=",
   "None",
   ",",
   "property_max",
   "=",
   "None",
   ",",
   "property_units",
   "=",
   "None",
   ",",
   "reference_doi",
   "=",
   "None",
   ",",
   "include_datasets",
   "=",
   "[",
   "]",
   ",",
   "exclude_datasets",
   "=",
   "[",
   "]",
   ",",
   "from_index",
   "=",
   "None",
   ",",
   "size",
   "=",
   "None",
   ")",
   ":",
   "pif_system_query",
   "=",
   "PifSystemQuery",
   "(",
   ")",
   "pif_system_query",
   ".",
   "names",
   "=",
   "FieldQuery",
   "(",
   "extract_as",
   "=",
   "'name'",
   ",",
   "filter",
   "=",
   "[",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_get_list",
   "(",
   "name",
   ")",
   "]",
   ")",
   "pif_system_query",
   ".",
   "chemical_formula",
   "=",
   "ChemicalFieldQuery",
   "(",
   "extract_as",
   "=",
   "'chemical_formula'",
   ",",
   "filter",
   "=",
   "[",
   "ChemicalFilter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_get_list",
   "(",
   "chemical_formula",
   ")",
   "]",
   ")",
   "pif_system_query",
   ".",
   "references",
   "=",
   "ReferenceQuery",
   "(",
   "doi",
   "=",
   "FieldQuery",
   "(",
   "extract_as",
   "=",
   "'reference_doi'",
   ",",
   "filter",
   "=",
   "[",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_get_list",
   "(",
   "reference_doi",
   ")",
   "]",
   ")",
   ")",
   "# Generate the parts of the property query",
   "property_name_query",
   "=",
   "FieldQuery",
   "(",
   "extract_as",
   "=",
   "'property_name'",
   ",",
   "filter",
   "=",
   "[",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_get_list",
   "(",
   "property_name",
   ")",
   "]",
   ")",
   "property_units_query",
   "=",
   "FieldQuery",
   "(",
   "extract_as",
   "=",
   "'property_units'",
   ",",
   "filter",
   "=",
   "[",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_get_list",
   "(",
   "property_units",
   ")",
   "]",
   ")",
   "property_value_query",
   "=",
   "FieldQuery",
   "(",
   "extract_as",
   "=",
   "'property_value'",
   ",",
   "filter",
   "=",
   "[",
   "]",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_get_list",
   "(",
   "property_value",
   ")",
   ":",
   "property_value_query",
   ".",
   "filter",
   ".",
   "append",
   "(",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   ")",
   "if",
   "property_min",
   "is",
   "not",
   "None",
   "or",
   "property_max",
   "is",
   "not",
   "None",
   ":",
   "property_value_query",
   ".",
   "filter",
   ".",
   "append",
   "(",
   "Filter",
   "(",
   "<mask>",
   "=",
   "property_min",
   ",",
   "max",
   "=",
   "property_max",
   ")",
   ")",
   "# Generate the full property query",
   "pif_system_query",
   ".",
   "properties",
   "=",
   "PropertyQuery",
   "(",
   "name",
   "=",
   "property_name_query",
   ",",
   "value",
   "=",
   "property_value_query",
   ",",
   "units",
   "=",
   "property_units_query",
   ")",
   "# Generate the dataset query",
   "dataset_query",
   "=",
   "list",
   "(",
   ")",
   "if",
   "include_datasets",
   ":",
   "dataset_query",
   ".",
   "append",
   "(",
   "DatasetQuery",
   "(",
   "logic",
   "=",
   "'MUST'",
   ",",
   "id",
   "=",
   "[",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "include_datasets",
   "]",
   ")",
   ")",
   "if",
   "exclude_datasets",
   ":",
   "dataset_query",
   ".",
   "append",
   "(",
   "DatasetQuery",
   "(",
   "logic",
   "=",
   "'MUST_NOT'",
   ",",
   "id",
   "=",
   "[",
   "Filter",
   "(",
   "equal",
   "=",
   "i",
   ")",
   "for",
   "i",
   "in",
   "exclude_datasets",
   "]",
   ")",
   ")",
   "# Run the query",
   "pif_system_returning_query",
   "=",
   "PifSystemReturningQuery",
   "(",
   "query",
   "=",
   "DataQuery",
   "(",
   "system",
   "=",
   "pif_system_query",
   ",",
   "dataset",
   "=",
   "dataset_query",
   ")",
   ",",
   "from_index",
   "=",
   "from_index",
   ",",
   "size",
   "=",
   "size",
   ",",
   "score_relevance",
   "=",
   "True",
   ")",
   "return",
   "pif_system_returning_query"
  ]
 },
 {
  "idx": "maxmin-187",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__generate_cluster_centers",
   "(",
   "self",
   ",",
   "width",
   ")",
   ":",
   "centers",
   "=",
   "[",
   "]",
   "default_offset",
   "=",
   "<mask>",
   "(",
   "width",
   ")",
   "*",
   "4.0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "__amount_clusters",
   ")",
   ":",
   "center",
   "=",
   "[",
   "random",
   ".",
   "gauss",
   "(",
   "i",
   "*",
   "default_offset",
   ",",
   "width",
   "[",
   "i",
   "]",
   "/",
   "2.0",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "self",
   ".",
   "__dimension",
   ")",
   "]",
   "centers",
   ".",
   "append",
   "(",
   "center",
   ")",
   "return",
   "centers"
  ]
 },
 {
  "idx": "maxmin-188",
  "nl_tokens": [
   "Return",
   "a",
   "value",
   "check",
   "function",
   "which",
   "raises",
   "a",
   "ValueError",
   "if",
   "the",
   "supplied",
   "value",
   "when",
   "converted",
   "to",
   "a",
   "datetime",
   "using",
   "the",
   "supplied",
   "format",
   "string",
   "is",
   "less",
   "than",
   "min",
   "or",
   "greater",
   "than",
   "max",
   "."
  ],
  "pl_tokens": [
   "def",
   "datetime_range_inclusive",
   "(",
   "<mask>",
   ",",
   "max",
   ",",
   "format",
   ")",
   ":",
   "dmin",
   "=",
   "datetime",
   ".",
   "strptime",
   "(",
   "min",
   ",",
   "format",
   ")",
   "dmax",
   "=",
   "datetime",
   ".",
   "strptime",
   "(",
   "max",
   ",",
   "format",
   ")",
   "def",
   "checker",
   "(",
   "v",
   ")",
   ":",
   "dv",
   "=",
   "datetime",
   ".",
   "strptime",
   "(",
   "v",
   ",",
   "format",
   ")",
   "if",
   "dv",
   "<",
   "dmin",
   "or",
   "dv",
   ">",
   "dmax",
   ":",
   "raise",
   "ValueError",
   "(",
   "v",
   ")",
   "return",
   "checker"
  ]
 },
 {
  "idx": "maxmin-189",
  "nl_tokens": [
   "Maps",
   "a",
   "slice",
   "object",
   "for",
   "whole",
   "array",
   "to",
   "slice",
   "objects",
   "for",
   "subarrays",
   ".",
   "Returns",
   "pair",
   "(",
   "ss",
   "ms",
   ")",
   "where",
   "ss",
   "is",
   "a",
   "list",
   "of",
   "subarrays",
   "and",
   "ms",
   "is",
   "a",
   "list",
   "giving",
   "the",
   "slice",
   "object",
   "that",
   "should",
   "be",
   "applied",
   "to",
   "each",
   "subarray",
   "."
  ],
  "pl_tokens": [
   "def",
   "_tosubslices",
   "(",
   "self",
   ",",
   "sl",
   ")",
   ":",
   "N",
   "=",
   "self",
   ".",
   "shape",
   "[",
   "self",
   ".",
   "_distaxis",
   "]",
   "start",
   ",",
   "stop",
   ",",
   "step",
   "=",
   "sl",
   ".",
   "start",
   ",",
   "sl",
   ".",
   "stop",
   ",",
   "sl",
   ".",
   "step",
   "if",
   "step",
   "is",
   "None",
   ":",
   "step",
   "=",
   "1",
   "ss",
   "=",
   "[",
   "]",
   "ms",
   "=",
   "[",
   "]",
   "if",
   "step",
   ">",
   "0",
   ":",
   "if",
   "start",
   "is",
   "None",
   ":",
   "start",
   "=",
   "0",
   "if",
   "stop",
   "is",
   "None",
   ":",
   "stop",
   "=",
   "N",
   "subs",
   "=",
   "range",
   "(",
   "0",
   ",",
   "self",
   ".",
   "_n",
   ")",
   "for",
   "s",
   "in",
   "subs",
   ":",
   "low",
   "=",
   "self",
   ".",
   "_si",
   "[",
   "s",
   "]",
   "high",
   "=",
   "self",
   ".",
   "_si",
   "[",
   "s",
   "+",
   "1",
   "]",
   "first",
   "=",
   "low",
   "+",
   "(",
   "(",
   "low",
   "-",
   "start",
   ")",
   "%",
   "step",
   ")",
   "last",
   "=",
   "high",
   "+",
   "(",
   "(",
   "high",
   "-",
   "start",
   ")",
   "%",
   "step",
   ")",
   "if",
   "start",
   "<",
   "high",
   "and",
   "stop",
   ">",
   "low",
   "and",
   "first",
   "<",
   "high",
   ":",
   "ss",
   ".",
   "append",
   "(",
   "s",
   ")",
   "substart",
   "=",
   "<mask>",
   "(",
   "first",
   ",",
   "start",
   ")",
   "-",
   "low",
   "substop",
   "=",
   "min",
   "(",
   "last",
   ",",
   "stop",
   ")",
   "-",
   "low",
   "ms",
   ".",
   "append",
   "(",
   "slice",
   "(",
   "substart",
   ",",
   "substop",
   ",",
   "step",
   ")",
   ")",
   "elif",
   "step",
   "<",
   "0",
   ":",
   "if",
   "start",
   "is",
   "None",
   ":",
   "start",
   "=",
   "N",
   "-",
   "1",
   "if",
   "stop",
   "is",
   "None",
   ":",
   "stop",
   "=",
   "-",
   "1",
   "subs",
   "=",
   "range",
   "(",
   "self",
   ".",
   "_n",
   "-",
   "1",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   "for",
   "s",
   "in",
   "subs",
   ":",
   "low",
   "=",
   "self",
   ".",
   "_si",
   "[",
   "s",
   "]",
   "high",
   "=",
   "self",
   ".",
   "_si",
   "[",
   "s",
   "+",
   "1",
   "]",
   "first",
   "=",
   "high",
   "+",
   "step",
   "+",
   "(",
   "(",
   "high",
   "-",
   "start",
   ")",
   "%",
   "step",
   ")",
   "last",
   "=",
   "low",
   "+",
   "step",
   "+",
   "(",
   "(",
   "low",
   "-",
   "start",
   ")",
   "%",
   "step",
   ")",
   "if",
   "start",
   ">=",
   "low",
   "and",
   "stop",
   "<",
   "high",
   "and",
   "first",
   ">=",
   "low",
   ":",
   "ss",
   ".",
   "append",
   "(",
   "s",
   ")",
   "substart",
   "=",
   "min",
   "(",
   "first",
   ",",
   "start",
   ")",
   "-",
   "low",
   "substop",
   "=",
   "max",
   "(",
   "last",
   "+",
   "step",
   ",",
   "stop",
   ")",
   "-",
   "low",
   "if",
   "substop",
   "<",
   "0",
   ":",
   "substop",
   "=",
   "None",
   "ms",
   ".",
   "append",
   "(",
   "slice",
   "(",
   "substart",
   ",",
   "substop",
   ",",
   "step",
   ")",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'slice step cannot be zero'",
   ")",
   "return",
   "ss",
   ",",
   "ms"
  ]
 },
 {
  "idx": "maxmin-190",
  "nl_tokens": [
   "implements",
   "the",
   "30E",
   "/",
   "360",
   "Day",
   "Count",
   "Convention",
   "(",
   "4",
   ".",
   "16",
   "(",
   "g",
   ")",
   "2006",
   "ISDA",
   "Definitons",
   ")"
  ],
  "pl_tokens": [
   "def",
   "get_30E_360",
   "(",
   "self",
   ",",
   "end",
   ")",
   ":",
   "y1",
   ",",
   "m1",
   ",",
   "d1",
   "=",
   "self",
   ".",
   "to_ymd",
   "(",
   ")",
   "# adjust to date immediately following the the last day",
   "y2",
   ",",
   "m2",
   ",",
   "d2",
   "=",
   "end",
   ".",
   "add_days",
   "(",
   "0",
   ")",
   ".",
   "to_ymd",
   "(",
   ")",
   "d1",
   "=",
   "<mask>",
   "(",
   "d1",
   ",",
   "30",
   ")",
   "d2",
   "=",
   "min",
   "(",
   "d2",
   ",",
   "30",
   ")",
   "return",
   "(",
   "360",
   "*",
   "(",
   "y2",
   "-",
   "y1",
   ")",
   "+",
   "30",
   "*",
   "(",
   "m2",
   "-",
   "m1",
   ")",
   "+",
   "(",
   "d2",
   "-",
   "d1",
   ")",
   ")",
   "/",
   "360.0"
  ]
 },
 {
  "idx": "maxmin-191",
  "nl_tokens": [
   "Transform",
   "a",
   "list",
   "of",
   "bag",
   "features",
   "into",
   "its",
   "projection",
   "series",
   "representation",
   "."
  ],
  "pl_tokens": [
   "def",
   "transform",
   "(",
   "self",
   ",",
   "X",
   ")",
   ":",
   "self",
   ".",
   "_check_fitted",
   "(",
   ")",
   "M",
   "=",
   "self",
   ".",
   "smoothness",
   "dim",
   "=",
   "self",
   ".",
   "dim_",
   "inds",
   "=",
   "self",
   ".",
   "inds_",
   "do_check",
   "=",
   "self",
   ".",
   "do_bounds_check",
   "X",
   "=",
   "as_features",
   "(",
   "X",
   ")",
   "if",
   "X",
   ".",
   "dim",
   "!=",
   "dim",
   ":",
   "msg",
   "=",
   "\"model fit for dimension {} but got dim {}\"",
   "raise",
   "ValueError",
   "(",
   "msg",
   ".",
   "format",
   "(",
   "dim",
   ",",
   "X",
   ".",
   "dim",
   ")",
   ")",
   "Xt",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "(",
   "len",
   "(",
   "X",
   ")",
   ",",
   "self",
   ".",
   "inds_",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "Xt",
   ".",
   "fill",
   "(",
   "np",
   ".",
   "nan",
   ")",
   "if",
   "self",
   ".",
   "basis",
   "==",
   "'cosine'",
   ":",
   "# TODO: put this in a C extension?",
   "coefs",
   "=",
   "(",
   "np",
   ".",
   "pi",
   "*",
   "np",
   ".",
   "arange",
   "(",
   "M",
   "+",
   "1",
   ")",
   ")",
   "[",
   "...",
   ",",
   ":",
   "]",
   "for",
   "i",
   ",",
   "bag",
   "in",
   "enumerate",
   "(",
   "X",
   ")",
   ":",
   "if",
   "do_check",
   ":",
   "if",
   "np",
   ".",
   "<mask>",
   "(",
   "bag",
   ")",
   "<",
   "0",
   "or",
   "np",
   ".",
   "max",
   "(",
   "bag",
   ")",
   ">",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Bag {} not in [0, 1]\"",
   ".",
   "format",
   "(",
   "i",
   ")",
   ")",
   "# apply each phi func to each dataset point: n x dim x M",
   "phi",
   "=",
   "coefs",
   "*",
   "bag",
   "[",
   "...",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "np",
   ".",
   "cos",
   "(",
   "phi",
   ",",
   "out",
   "=",
   "phi",
   ")",
   "phi",
   "[",
   ":",
   ",",
   ":",
   ",",
   "1",
   ":",
   "]",
   "*=",
   "np",
   ".",
   "sqrt",
   "(",
   "2",
   ")",
   "# B is the evaluation of each tensor-prodded basis func",
   "# at each point: n x inds.shape[0]",
   "B",
   "=",
   "reduce",
   "(",
   "op",
   ".",
   "mul",
   ",",
   "(",
   "phi",
   "[",
   ":",
   ",",
   "i",
   ",",
   "inds",
   "[",
   ":",
   ",",
   "i",
   "]",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "dim",
   ")",
   ")",
   ")",
   "Xt",
   "[",
   "i",
   ",",
   ":",
   "]",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "B",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"unknown basis '{}'\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "basis",
   ")",
   ")",
   "return",
   "Xt"
  ]
 },
 {
  "idx": "maxmin-192",
  "nl_tokens": [
   "Returns",
   "bounds",
   "that",
   "encompass",
   "the",
   "union",
   "of",
   "the",
   "two",
   "."
  ],
  "pl_tokens": [
   "def",
   "union",
   "(",
   "self",
   ",",
   "b",
   ")",
   ":",
   "mx",
   ",",
   "my",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "x",
   ",",
   "b",
   ".",
   "x",
   ")",
   ",",
   "min",
   "(",
   "self",
   ".",
   "y",
   ",",
   "b",
   ".",
   "y",
   ")",
   "return",
   "Bounds",
   "(",
   "mx",
   ",",
   "my",
   ",",
   "max",
   "(",
   "self",
   ".",
   "x",
   "+",
   "self",
   ".",
   "width",
   ",",
   "b",
   ".",
   "x",
   "+",
   "b",
   ".",
   "width",
   ")",
   "-",
   "mx",
   ",",
   "max",
   "(",
   "self",
   ".",
   "y",
   "+",
   "self",
   ".",
   "height",
   ",",
   "b",
   ".",
   "y",
   "+",
   "b",
   ".",
   "height",
   ")",
   "-",
   "my",
   ")"
  ]
 },
 {
  "idx": "maxmin-193",
  "nl_tokens": [
   "Check",
   "if",
   "current",
   "line",
   "contains",
   "an",
   "out",
   "-",
   "of",
   "-",
   "line",
   "method",
   "definition",
   "."
  ],
  "pl_tokens": [
   "def",
   "IsOutOfLineMethodDefinition",
   "(",
   "clean_lines",
   ",",
   "linenum",
   ")",
   ":",
   "# Scan back a few lines for start of current function",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "linenum",
   ",",
   "<mask>",
   "(",
   "-",
   "1",
   ",",
   "linenum",
   "-",
   "10",
   ")",
   ",",
   "-",
   "1",
   ")",
   ":",
   "if",
   "Match",
   "(",
   "r'^([^()]*\\w+)\\('",
   ",",
   "clean_lines",
   ".",
   "elided",
   "[",
   "i",
   "]",
   ")",
   ":",
   "return",
   "Match",
   "(",
   "r'^[^()]*\\w+::\\w+\\('",
   ",",
   "clean_lines",
   ".",
   "elided",
   "[",
   "i",
   "]",
   ")",
   "is",
   "not",
   "None",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-194",
  "nl_tokens": [
   "Formats",
   "bullets",
   "and",
   "numbering",
   "of",
   "Wikipedia",
   "lists",
   ".",
   "List",
   "items",
   "are",
   "marked",
   "by",
   "*",
   "#",
   "or",
   ";",
   "at",
   "the",
   "start",
   "of",
   "a",
   "line",
   ".",
   "We",
   "treat",
   ";",
   "the",
   "same",
   "as",
   "*",
   "and",
   "replace",
   "#",
   "with",
   "real",
   "numbering",
   "(",
   "e",
   ".",
   "g",
   ".",
   "2",
   ".",
   ")",
   ".",
   "Sublists",
   "(",
   "e",
   ".",
   "g",
   ".",
   "***",
   "and",
   "###",
   ")",
   "get",
   "indented",
   "by",
   "tabs",
   ".",
   "Called",
   "from",
   "parse_paragraphs",
   "()",
   "method",
   "."
  ],
  "pl_tokens": [
   "def",
   "parse_paragraph_list",
   "(",
   "self",
   ",",
   "markup",
   ",",
   "indent",
   "=",
   "\"\\t\"",
   ")",
   ":",
   "def",
   "lastleft",
   "(",
   "ch",
   ",",
   "str",
   ")",
   ":",
   "n",
   "=",
   "0",
   "while",
   "n",
   "<",
   "len",
   "(",
   "str",
   ")",
   "and",
   "str",
   "[",
   "n",
   "]",
   "==",
   "ch",
   ":",
   "n",
   "+=",
   "1",
   "return",
   "n",
   "tally",
   "=",
   "[",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "10",
   ")",
   "]",
   "chunks",
   "=",
   "markup",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "chunks",
   ")",
   ")",
   ":",
   "if",
   "chunks",
   "[",
   "i",
   "]",
   ".",
   "startswith",
   "(",
   "\"#\"",
   ")",
   ":",
   "j",
   "=",
   "<mask>",
   "(",
   "lastleft",
   "(",
   "\"#\"",
   ",",
   "chunks",
   "[",
   "i",
   "]",
   ")",
   ",",
   "len",
   "(",
   "tally",
   ")",
   "-",
   "1",
   ")",
   "chunks",
   "[",
   "i",
   "]",
   "=",
   "indent",
   "*",
   "(",
   "j",
   "-",
   "1",
   ")",
   "+",
   "str",
   "(",
   "tally",
   "[",
   "j",
   "]",
   ")",
   "+",
   "\". \"",
   "+",
   "chunks",
   "[",
   "i",
   "]",
   "[",
   "j",
   ":",
   "]",
   "chunks",
   "[",
   "i",
   "]",
   "=",
   "chunks",
   "[",
   "i",
   "]",
   ".",
   "replace",
   "(",
   "\".  \"",
   ",",
   "\". \"",
   ")",
   "tally",
   "[",
   "j",
   "]",
   "+=",
   "1",
   "# Reset the numbering of sublists.",
   "for",
   "k",
   "in",
   "range",
   "(",
   "j",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tally",
   ")",
   ")",
   ":",
   "tally",
   "[",
   "k",
   "]",
   "=",
   "1",
   "if",
   "chunks",
   "[",
   "i",
   "]",
   ".",
   "startswith",
   "(",
   "\";\"",
   ")",
   ":",
   "chunks",
   "[",
   "i",
   "]",
   "=",
   "\"*\"",
   "+",
   "chunks",
   "[",
   "i",
   "]",
   "[",
   "1",
   ":",
   "]",
   "if",
   "chunks",
   "[",
   "i",
   "]",
   ".",
   "startswith",
   "(",
   "\"*\"",
   ")",
   ":",
   "j",
   "=",
   "lastleft",
   "(",
   "\"*\"",
   ",",
   "chunks",
   "[",
   "i",
   "]",
   ")",
   "chunks",
   "[",
   "i",
   "]",
   "=",
   "indent",
   "*",
   "(",
   "j",
   "-",
   "1",
   ")",
   "+",
   "\"* \"",
   "+",
   "chunks",
   "[",
   "i",
   "]",
   "[",
   "j",
   ":",
   "]",
   "chunks",
   "[",
   "i",
   "]",
   "=",
   "chunks",
   "[",
   "i",
   "]",
   ".",
   "replace",
   "(",
   "\"*  \"",
   ",",
   "\"* \"",
   ")",
   "return",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "chunks",
   ")"
  ]
 },
 {
  "idx": "maxmin-195",
  "nl_tokens": [
   "Genetic",
   "recombination",
   "of",
   "two",
   "themes",
   "using",
   "cut",
   "and",
   "splice",
   "technique",
   "."
  ],
  "pl_tokens": [
   "def",
   "recombine",
   "(",
   "self",
   ",",
   "other",
   ",",
   "d",
   "=",
   "0.7",
   ")",
   ":",
   "a",
   ",",
   "b",
   "=",
   "self",
   ",",
   "other",
   "d1",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "min",
   "(",
   "d",
   ",",
   "1",
   ")",
   ")",
   "d2",
   "=",
   "d1",
   "c",
   "=",
   "ColorTheme",
   "(",
   "name",
   "=",
   "a",
   ".",
   "name",
   "[",
   ":",
   "int",
   "(",
   "len",
   "(",
   "a",
   ".",
   "name",
   ")",
   "*",
   "d1",
   ")",
   "]",
   "+",
   "b",
   ".",
   "name",
   "[",
   "int",
   "(",
   "len",
   "(",
   "b",
   ".",
   "name",
   ")",
   "*",
   "d2",
   ")",
   ":",
   "]",
   ",",
   "ranges",
   "=",
   "a",
   ".",
   "ranges",
   "[",
   ":",
   "int",
   "(",
   "len",
   "(",
   "a",
   ".",
   "ranges",
   ")",
   "*",
   "d1",
   ")",
   "]",
   "+",
   "b",
   ".",
   "ranges",
   "[",
   "int",
   "(",
   "len",
   "(",
   "b",
   ".",
   "ranges",
   ")",
   "*",
   "d2",
   ")",
   ":",
   "]",
   ",",
   "top",
   "=",
   "a",
   ".",
   "top",
   ",",
   "cache",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "DEFAULT_CACHE",
   ",",
   "\"recombined\"",
   ")",
   ",",
   "blue",
   "=",
   "a",
   ".",
   "blue",
   ",",
   "length",
   "=",
   "a",
   ".",
   "length",
   "*",
   "d1",
   "+",
   "b",
   ".",
   "length",
   "*",
   "d2",
   ")",
   "c",
   ".",
   "tags",
   "=",
   "a",
   ".",
   "tags",
   "[",
   ":",
   "int",
   "(",
   "len",
   "(",
   "a",
   ".",
   "tags",
   ")",
   "*",
   "d1",
   ")",
   "]",
   "c",
   ".",
   "tags",
   "+=",
   "b",
   ".",
   "tags",
   "[",
   "int",
   "(",
   "len",
   "(",
   "b",
   ".",
   "tags",
   ")",
   "*",
   "d2",
   ")",
   ":",
   "]",
   "return",
   "c"
  ]
 },
 {
  "idx": "maxmin-196",
  "nl_tokens": [
   "Execute",
   "an",
   "eigen",
   "update",
   "of",
   "J"
  ],
  "pl_tokens": [
   "def",
   "update_eig_J",
   "(",
   "self",
   ")",
   ":",
   "CLOG",
   ".",
   "debug",
   "(",
   "'Eigen update.'",
   ")",
   "vls",
   ",",
   "vcs",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "eigh",
   "(",
   "self",
   ".",
   "JTJ",
   ")",
   "res0",
   "=",
   "self",
   ".",
   "calc_residuals",
   "(",
   ")",
   "for",
   "a",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "num_eig_dirs",
   ",",
   "vls",
   ".",
   "size",
   "]",
   ")",
   ")",
   ":",
   "#1. Finding stiff directions",
   "stif_dir",
   "=",
   "vcs",
   "[",
   "-",
   "(",
   "a",
   "+",
   "1",
   ")",
   "]",
   "#already normalized",
   "#2. Evaluating derivative along that direction, we'll use dl=5e-4:",
   "dl",
   "=",
   "self",
   ".",
   "eig_dl",
   "#1e-5",
   "_",
   "=",
   "self",
   ".",
   "update_function",
   "(",
   "self",
   ".",
   "param_vals",
   "+",
   "dl",
   "*",
   "stif_dir",
   ")",
   "res1",
   "=",
   "self",
   ".",
   "calc_residuals",
   "(",
   ")",
   "#3. Updating",
   "grad_stif",
   "=",
   "(",
   "res1",
   "-",
   "res0",
   ")",
   "/",
   "dl",
   "self",
   ".",
   "_rank_1_J_update",
   "(",
   "stif_dir",
   ",",
   "grad_stif",
   ")",
   "self",
   ".",
   "JTJ",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "self",
   ".",
   "J",
   ",",
   "self",
   ".",
   "J",
   ".",
   "T",
   ")",
   "#Putting the parameters back:",
   "_",
   "=",
   "self",
   ".",
   "update_function",
   "(",
   "self",
   ".",
   "param_vals",
   ")"
  ]
 },
 {
  "idx": "maxmin-197",
  "nl_tokens": [
   "Returns",
   "the",
   "loss",
   "and",
   "the",
   "gradient",
   "of",
   "the",
   "loss",
   "w",
   ".",
   "r",
   ".",
   "t",
   ".",
   "x",
   "assuming",
   "that",
   "logits",
   "=",
   "model",
   "(",
   "x",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "loss_function",
   "(",
   "cls",
   ",",
   "const",
   ",",
   "a",
   ",",
   "x",
   ",",
   "logits",
   ",",
   "reconstructed_original",
   ",",
   "confidence",
   ",",
   "min_",
   ",",
   "max_",
   ")",
   ":",
   "targeted",
   "=",
   "a",
   ".",
   "target_class",
   "(",
   ")",
   "is",
   "not",
   "None",
   "if",
   "targeted",
   ":",
   "c_minimize",
   "=",
   "cls",
   ".",
   "best_other_class",
   "(",
   "logits",
   ",",
   "a",
   ".",
   "target_class",
   "(",
   ")",
   ")",
   "c_maximize",
   "=",
   "a",
   ".",
   "target_class",
   "(",
   ")",
   "else",
   ":",
   "c_minimize",
   "=",
   "a",
   ".",
   "original_class",
   "c_maximize",
   "=",
   "cls",
   ".",
   "best_other_class",
   "(",
   "logits",
   ",",
   "a",
   ".",
   "original_class",
   ")",
   "is_adv_loss",
   "=",
   "logits",
   "[",
   "c_minimize",
   "]",
   "-",
   "logits",
   "[",
   "c_maximize",
   "]",
   "# is_adv is True as soon as the is_adv_loss goes below 0",
   "# but sometimes we want additional confidence",
   "is_adv_loss",
   "+=",
   "confidence",
   "is_adv_loss",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "is_adv_loss",
   ")",
   "s",
   "=",
   "max_",
   "-",
   "min_",
   "squared_l2_distance",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "(",
   "x",
   "-",
   "reconstructed_original",
   ")",
   "**",
   "2",
   ")",
   "/",
   "s",
   "**",
   "2",
   "total_loss",
   "=",
   "squared_l2_distance",
   "+",
   "const",
   "*",
   "is_adv_loss",
   "# calculate the gradient of total_loss w.r.t. x",
   "logits_diff_grad",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "logits",
   ")",
   "logits_diff_grad",
   "[",
   "c_minimize",
   "]",
   "=",
   "1",
   "logits_diff_grad",
   "[",
   "c_maximize",
   "]",
   "=",
   "-",
   "1",
   "is_adv_loss_grad",
   "=",
   "a",
   ".",
   "backward",
   "(",
   "logits_diff_grad",
   ",",
   "x",
   ")",
   "assert",
   "is_adv_loss",
   ">=",
   "0",
   "if",
   "is_adv_loss",
   "==",
   "0",
   ":",
   "is_adv_loss_grad",
   "=",
   "0",
   "squared_l2_distance_grad",
   "=",
   "(",
   "2",
   "/",
   "s",
   "**",
   "2",
   ")",
   "*",
   "(",
   "x",
   "-",
   "reconstructed_original",
   ")",
   "total_loss_grad",
   "=",
   "squared_l2_distance_grad",
   "+",
   "const",
   "*",
   "is_adv_loss_grad",
   "return",
   "total_loss",
   ",",
   "total_loss_grad"
  ]
 },
 {
  "idx": "maxmin-198",
  "nl_tokens": [
   "Explicitly",
   "specify",
   "start",
   "time",
   "and",
   "end",
   "time"
  ],
  "pl_tokens": [
   "def",
   "market_exact",
   "(",
   "self",
   ",",
   "session",
   ",",
   "start_time",
   ":",
   "str",
   ",",
   "end_time",
   ":",
   "str",
   ")",
   "->",
   "Session",
   ":",
   "if",
   "session",
   "not",
   "in",
   "self",
   ".",
   "exch",
   ":",
   "return",
   "SessNA",
   "ss",
   "=",
   "self",
   ".",
   "exch",
   "[",
   "session",
   "]",
   "same_day",
   "=",
   "ss",
   "[",
   "0",
   "]",
   "<",
   "ss",
   "[",
   "-",
   "1",
   "]",
   "if",
   "not",
   "start_time",
   ":",
   "s_time",
   "=",
   "ss",
   "[",
   "0",
   "]",
   "else",
   ":",
   "s_time",
   "=",
   "param",
   ".",
   "to_hour",
   "(",
   "start_time",
   ")",
   "if",
   "same_day",
   ":",
   "s_time",
   "=",
   "<mask>",
   "(",
   "s_time",
   ",",
   "ss",
   "[",
   "0",
   "]",
   ")",
   "if",
   "not",
   "end_time",
   ":",
   "e_time",
   "=",
   "ss",
   "[",
   "-",
   "1",
   "]",
   "else",
   ":",
   "e_time",
   "=",
   "param",
   ".",
   "to_hour",
   "(",
   "end_time",
   ")",
   "if",
   "same_day",
   ":",
   "e_time",
   "=",
   "min",
   "(",
   "e_time",
   ",",
   "ss",
   "[",
   "-",
   "1",
   "]",
   ")",
   "if",
   "same_day",
   "and",
   "(",
   "s_time",
   ">",
   "e_time",
   ")",
   ":",
   "return",
   "SessNA",
   "return",
   "Session",
   "(",
   "start_time",
   "=",
   "s_time",
   ",",
   "end_time",
   "=",
   "e_time",
   ")"
  ]
 },
 {
  "idx": "maxmin-199",
  "nl_tokens": [
   "Get",
   "chunk",
   "meta",
   "of",
   "NVMe",
   "device"
  ],
  "pl_tokens": [
   "def",
   "get_meta",
   "(",
   "offset",
   ",",
   "length",
   ",",
   "output",
   ")",
   ":",
   "if",
   "env",
   "(",
   ")",
   ":",
   "cij",
   ".",
   "err",
   "(",
   "\"cij.nvme.meta: Invalid NVMe ENV.\"",
   ")",
   "return",
   "1",
   "nvme",
   "=",
   "cij",
   ".",
   "env_to_dict",
   "(",
   "PREFIX",
   ",",
   "EXPORTED",
   "+",
   "REQUIRED",
   ")",
   "max_size",
   "=",
   "0x40000",
   "with",
   "open",
   "(",
   "output",
   ",",
   "\"wb\"",
   ")",
   "as",
   "fout",
   ":",
   "for",
   "off",
   "in",
   "range",
   "(",
   "offset",
   ",",
   "length",
   ",",
   "max_size",
   ")",
   ":",
   "size",
   "=",
   "<mask>",
   "(",
   "length",
   "-",
   "off",
   ",",
   "max_size",
   ")",
   "cmd",
   "=",
   "[",
   "\"nvme get-log\"",
   ",",
   "nvme",
   "[",
   "\"DEV_PATH\"",
   "]",
   ",",
   "\"-i 0xca\"",
   ",",
   "\"-o 0x%x\"",
   "%",
   "off",
   ",",
   "\"-l 0x%x\"",
   "%",
   "size",
   ",",
   "\"-b\"",
   "]",
   "status",
   ",",
   "stdout",
   ",",
   "_",
   "=",
   "cij",
   ".",
   "ssh",
   ".",
   "command",
   "(",
   "cmd",
   ",",
   "shell",
   "=",
   "True",
   ")",
   "if",
   "status",
   ":",
   "cij",
   ".",
   "err",
   "(",
   "\"cij.nvme.meta: Error get chunk meta\"",
   ")",
   "return",
   "1",
   "fout",
   ".",
   "write",
   "(",
   "stdout",
   ")",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-200",
  "nl_tokens": [
   "Compare",
   "two",
   "Project",
   "Haystack",
   "version",
   "strings",
   "then",
   "return",
   "-",
   "1",
   "if",
   "self",
   "<",
   "other",
   "0",
   "if",
   "self",
   "==",
   "other",
   "or",
   "1",
   "if",
   "self",
   ">",
   "other",
   "."
  ],
  "pl_tokens": [
   "def",
   "_cmp",
   "(",
   "self",
   ",",
   "other",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "other",
   ",",
   "Version",
   ")",
   ":",
   "other",
   "=",
   "Version",
   "(",
   "other",
   ")",
   "num1",
   "=",
   "self",
   ".",
   "version_nums",
   "num2",
   "=",
   "other",
   ".",
   "version_nums",
   "# Pad both to be the same length",
   "ver_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "num1",
   ")",
   ",",
   "len",
   "(",
   "num2",
   ")",
   ")",
   "num1",
   "+=",
   "tuple",
   "(",
   "[",
   "0",
   "for",
   "n",
   "in",
   "range",
   "(",
   "len",
   "(",
   "num1",
   ")",
   ",",
   "ver_len",
   ")",
   "]",
   ")",
   "num2",
   "+=",
   "tuple",
   "(",
   "[",
   "0",
   "for",
   "n",
   "in",
   "range",
   "(",
   "len",
   "(",
   "num2",
   ")",
   ",",
   "ver_len",
   ")",
   "]",
   ")",
   "# Compare the versions",
   "for",
   "(",
   "p1",
   ",",
   "p2",
   ")",
   "in",
   "zip",
   "(",
   "num1",
   ",",
   "num2",
   ")",
   ":",
   "if",
   "p1",
   "<",
   "p2",
   ":",
   "return",
   "-",
   "1",
   "elif",
   "p1",
   ">",
   "p2",
   ":",
   "return",
   "1",
   "# All the same, compare the extra strings.",
   "# If a version misses the extra part; we consider that as coming *before*.",
   "if",
   "self",
   ".",
   "version_extra",
   "is",
   "None",
   ":",
   "if",
   "other",
   ".",
   "version_extra",
   "is",
   "None",
   ":",
   "return",
   "0",
   "else",
   ":",
   "return",
   "-",
   "1",
   "elif",
   "other",
   ".",
   "version_extra",
   "is",
   "None",
   ":",
   "return",
   "1",
   "elif",
   "self",
   ".",
   "version_extra",
   "==",
   "other",
   ".",
   "version_extra",
   ":",
   "return",
   "0",
   "elif",
   "self",
   ".",
   "version_extra",
   "<",
   "other",
   ".",
   "version_extra",
   ":",
   "return",
   "-",
   "1",
   "else",
   ":",
   "return",
   "1"
  ]
 },
 {
  "idx": "maxmin-201",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "find_nearest_leaf",
   "(",
   "self",
   ",",
   "entry",
   ",",
   "search_node",
   "=",
   "None",
   ")",
   ":",
   "if",
   "(",
   "search_node",
   "is",
   "None",
   ")",
   ":",
   "search_node",
   "=",
   "self",
   ".",
   "__root",
   "nearest_node",
   "=",
   "search_node",
   "if",
   "(",
   "search_node",
   ".",
   "type",
   "==",
   "cfnode_type",
   ".",
   "CFNODE_NONLEAF",
   ")",
   ":",
   "min_key",
   "=",
   "lambda",
   "child_node",
   ":",
   "child_node",
   ".",
   "feature",
   ".",
   "get_distance",
   "(",
   "entry",
   ",",
   "self",
   ".",
   "__type_measurement",
   ")",
   "nearest_child_node",
   "=",
   "<mask>",
   "(",
   "search_node",
   ".",
   "successors",
   ",",
   "key",
   "=",
   "min_key",
   ")",
   "nearest_node",
   "=",
   "self",
   ".",
   "find_nearest_leaf",
   "(",
   "entry",
   ",",
   "nearest_child_node",
   ")",
   "return",
   "nearest_node"
  ]
 },
 {
  "idx": "maxmin-202",
  "nl_tokens": [
   "Determine",
   "if",
   "the",
   "provided",
   "time",
   "is",
   "within",
   "the",
   "range",
   "inclusive",
   "."
  ],
  "pl_tokens": [
   "def",
   "_datetime_in_range",
   "(",
   "self",
   ",",
   "dt",
   ",",
   "dt_min",
   "=",
   "None",
   ",",
   "dt_max",
   "=",
   "None",
   ")",
   ":",
   "# The pipelines API stores operation create-time with second granularity.",
   "# We mimic this behavior in the local provider by truncating to seconds.",
   "dt",
   "=",
   "dt",
   ".",
   "replace",
   "(",
   "microsecond",
   "=",
   "0",
   ")",
   "if",
   "dt_min",
   ":",
   "dt_min",
   "=",
   "dt_min",
   ".",
   "replace",
   "(",
   "microsecond",
   "=",
   "0",
   ")",
   "else",
   ":",
   "dt_min",
   "=",
   "dsub_util",
   ".",
   "replace_timezone",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "<mask>",
   ",",
   "pytz",
   ".",
   "utc",
   ")",
   "if",
   "dt_max",
   ":",
   "dt_max",
   "=",
   "dt_max",
   ".",
   "replace",
   "(",
   "microsecond",
   "=",
   "0",
   ")",
   "else",
   ":",
   "dt_max",
   "=",
   "dsub_util",
   ".",
   "replace_timezone",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "max",
   ",",
   "pytz",
   ".",
   "utc",
   ")",
   "return",
   "dt_min",
   "<=",
   "dt",
   "<=",
   "dt_max"
  ]
 },
 {
  "idx": "maxmin-203",
  "nl_tokens": [
   "Tabulate",
   "an",
   "integral",
   "over",
   "the",
   "surface",
   "density",
   "of",
   "deflection",
   "potential",
   "of",
   "a",
   "mass",
   "profile",
   ".",
   "This",
   "is",
   "used",
   "in",
   "\\",
   "the",
   "GeneralizedNFW",
   "profile",
   "classes",
   "to",
   "speed",
   "up",
   "the",
   "integration",
   "procedure",
   "."
  ],
  "pl_tokens": [
   "def",
   "tabulate_integral",
   "(",
   "self",
   ",",
   "grid",
   ",",
   "tabulate_bins",
   ")",
   ":",
   "eta_min",
   "=",
   "1.0e-4",
   "eta_max",
   "=",
   "1.05",
   "*",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "grid_to_elliptical_radii",
   "(",
   "grid",
   ")",
   ")",
   "minimum_log_eta",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "eta_min",
   ")",
   "maximum_log_eta",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "eta_max",
   ")",
   "bin_size",
   "=",
   "(",
   "maximum_log_eta",
   "-",
   "minimum_log_eta",
   ")",
   "/",
   "(",
   "tabulate_bins",
   "-",
   "1",
   ")",
   "return",
   "eta_min",
   ",",
   "eta_max",
   ",",
   "minimum_log_eta",
   ",",
   "maximum_log_eta",
   ",",
   "bin_size"
  ]
 },
 {
  "idx": "maxmin-204",
  "nl_tokens": [
   "LMLs",
   "fixed",
   "-",
   "effect",
   "sizes",
   "and",
   "scales",
   "for",
   "single",
   "-",
   "marker",
   "scan",
   "."
  ],
  "pl_tokens": [
   "def",
   "fast_scan",
   "(",
   "self",
   ",",
   "M",
   ",",
   "verbose",
   "=",
   "True",
   ")",
   ":",
   "from",
   "tqdm",
   "import",
   "tqdm",
   "if",
   "M",
   ".",
   "ndim",
   "!=",
   "2",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"`M` array must be bidimensional.\"",
   ")",
   "p",
   "=",
   "M",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "lmls",
   "=",
   "empty",
   "(",
   "p",
   ")",
   "effsizes0",
   "=",
   "empty",
   "(",
   "(",
   "p",
   ",",
   "self",
   ".",
   "_XTQ",
   "[",
   "0",
   "]",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "effsizes0_se",
   "=",
   "empty",
   "(",
   "(",
   "p",
   ",",
   "self",
   ".",
   "_XTQ",
   "[",
   "0",
   "]",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "effsizes1",
   "=",
   "empty",
   "(",
   "p",
   ")",
   "effsizes1_se",
   "=",
   "empty",
   "(",
   "p",
   ")",
   "scales",
   "=",
   "empty",
   "(",
   "p",
   ")",
   "if",
   "verbose",
   ":",
   "nchunks",
   "=",
   "<mask>",
   "(",
   "p",
   ",",
   "30",
   ")",
   "else",
   ":",
   "nchunks",
   "=",
   "min",
   "(",
   "p",
   ",",
   "1",
   ")",
   "chunk_size",
   "=",
   "(",
   "p",
   "+",
   "nchunks",
   "-",
   "1",
   ")",
   "//",
   "nchunks",
   "for",
   "i",
   "in",
   "tqdm",
   "(",
   "range",
   "(",
   "nchunks",
   ")",
   ",",
   "desc",
   "=",
   "\"Scanning\"",
   ",",
   "disable",
   "=",
   "not",
   "verbose",
   ")",
   ":",
   "start",
   "=",
   "i",
   "*",
   "chunk_size",
   "stop",
   "=",
   "min",
   "(",
   "start",
   "+",
   "chunk_size",
   ",",
   "M",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "r",
   "=",
   "self",
   ".",
   "_fast_scan_chunk",
   "(",
   "M",
   "[",
   ":",
   ",",
   "start",
   ":",
   "stop",
   "]",
   ")",
   "lmls",
   "[",
   "start",
   ":",
   "stop",
   "]",
   "=",
   "r",
   "[",
   "\"lml\"",
   "]",
   "effsizes0",
   "[",
   "start",
   ":",
   "stop",
   ",",
   ":",
   "]",
   "=",
   "r",
   "[",
   "\"effsizes0\"",
   "]",
   "effsizes0_se",
   "[",
   "start",
   ":",
   "stop",
   ",",
   ":",
   "]",
   "=",
   "r",
   "[",
   "\"effsizes0_se\"",
   "]",
   "effsizes1",
   "[",
   "start",
   ":",
   "stop",
   "]",
   "=",
   "r",
   "[",
   "\"effsizes1\"",
   "]",
   "effsizes1_se",
   "[",
   "start",
   ":",
   "stop",
   "]",
   "=",
   "r",
   "[",
   "\"effsizes1_se\"",
   "]",
   "scales",
   "[",
   "start",
   ":",
   "stop",
   "]",
   "=",
   "r",
   "[",
   "\"scale\"",
   "]",
   "return",
   "{",
   "\"lml\"",
   ":",
   "lmls",
   ",",
   "\"effsizes0\"",
   ":",
   "effsizes0",
   ",",
   "\"effsizes0_se\"",
   ":",
   "effsizes0_se",
   ",",
   "\"effsizes1\"",
   ":",
   "effsizes1",
   ",",
   "\"effsizes1_se\"",
   ":",
   "effsizes1_se",
   ",",
   "\"scale\"",
   ":",
   "scales",
   ",",
   "}"
  ]
 },
 {
  "idx": "maxmin-205",
  "nl_tokens": [
   ":",
   "return",
   ":",
   "The",
   "current",
   "view",
   "matrix",
   "for",
   "the",
   "camera"
  ],
  "pl_tokens": [
   "def",
   "view_matrix",
   "(",
   "self",
   ")",
   ":",
   "# Use separate time in camera so we can move it when the demo is paused",
   "now",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "# If the camera has been inactive for a while, a large time delta",
   "# can suddenly move the camera far away from the scene",
   "t",
   "=",
   "<mask>",
   "(",
   "now",
   "-",
   "self",
   ".",
   "_last_time",
   ",",
   "0",
   ")",
   "self",
   ".",
   "_last_time",
   "=",
   "now",
   "# X Movement",
   "if",
   "self",
   ".",
   "_xdir",
   "==",
   "POSITIVE",
   ":",
   "self",
   ".",
   "position",
   "+=",
   "self",
   ".",
   "right",
   "*",
   "self",
   ".",
   "velocity",
   "*",
   "t",
   "elif",
   "self",
   ".",
   "_xdir",
   "==",
   "NEGATIVE",
   ":",
   "self",
   ".",
   "position",
   "-=",
   "self",
   ".",
   "right",
   "*",
   "self",
   ".",
   "velocity",
   "*",
   "t",
   "# Z Movement",
   "if",
   "self",
   ".",
   "_zdir",
   "==",
   "NEGATIVE",
   ":",
   "self",
   ".",
   "position",
   "+=",
   "self",
   ".",
   "dir",
   "*",
   "self",
   ".",
   "velocity",
   "*",
   "t",
   "elif",
   "self",
   ".",
   "_zdir",
   "==",
   "POSITIVE",
   ":",
   "self",
   ".",
   "position",
   "-=",
   "self",
   ".",
   "dir",
   "*",
   "self",
   ".",
   "velocity",
   "*",
   "t",
   "# Y Movement",
   "if",
   "self",
   ".",
   "_ydir",
   "==",
   "POSITIVE",
   ":",
   "self",
   ".",
   "position",
   "+=",
   "self",
   ".",
   "up",
   "*",
   "self",
   ".",
   "velocity",
   "*",
   "t",
   "elif",
   "self",
   ".",
   "_ydir",
   "==",
   "NEGATIVE",
   ":",
   "self",
   ".",
   "position",
   "-=",
   "self",
   ".",
   "up",
   "*",
   "self",
   ".",
   "velocity",
   "*",
   "t",
   "return",
   "self",
   ".",
   "_gl_look_at",
   "(",
   "self",
   ".",
   "position",
   ",",
   "self",
   ".",
   "position",
   "+",
   "self",
   ".",
   "dir",
   ",",
   "self",
   ".",
   "_up",
   ")"
  ]
 },
 {
  "idx": "maxmin-206",
  "nl_tokens": [
   "Get",
   "contour",
   "polygons",
   "between",
   "the",
   "given",
   "levels",
   "."
  ],
  "pl_tokens": [
   "def",
   "filled_contour",
   "(",
   "self",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "max",
   "=",
   "None",
   ")",
   ":",
   "# pylint: disable=redefined-builtin,redefined-outer-name",
   "# Get the contour vertices.",
   "if",
   "min",
   "is",
   "None",
   ":",
   "min",
   "=",
   "np",
   ".",
   "finfo",
   "(",
   "np",
   ".",
   "float64",
   ")",
   ".",
   "min",
   "if",
   "max",
   "is",
   "None",
   ":",
   "max",
   "=",
   "np",
   ".",
   "finfo",
   "(",
   "np",
   ".",
   "float64",
   ")",
   ".",
   "max",
   "vertices",
   ",",
   "codes",
   "=",
   "(",
   "self",
   ".",
   "_contour_generator",
   ".",
   "create_filled_contour",
   "(",
   "min",
   ",",
   "max",
   ")",
   ")",
   "return",
   "self",
   ".",
   "formatter",
   "(",
   "(",
   "min",
   ",",
   "max",
   ")",
   ",",
   "vertices",
   ",",
   "codes",
   ")"
  ]
 },
 {
  "idx": "maxmin-207",
  "nl_tokens": [
   "r",
   "Correlation",
   "function"
  ],
  "pl_tokens": [
   "def",
   "CORRELATION",
   "(",
   "x",
   ",",
   "y",
   "=",
   "None",
   ",",
   "maxlags",
   "=",
   "None",
   ",",
   "norm",
   "=",
   "'unbiased'",
   ")",
   ":",
   "assert",
   "norm",
   "in",
   "[",
   "'unbiased'",
   ",",
   "'biased'",
   ",",
   "'coeff'",
   ",",
   "None",
   "]",
   "#transform lag into list if it is an integer",
   "x",
   "=",
   "np",
   ".",
   "array",
   "(",
   "x",
   ")",
   "if",
   "y",
   "is",
   "None",
   ":",
   "y",
   "=",
   "x",
   "else",
   ":",
   "y",
   "=",
   "np",
   ".",
   "array",
   "(",
   "y",
   ")",
   "# N is the max of x and y",
   "N",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "x",
   ")",
   ",",
   "len",
   "(",
   "y",
   ")",
   ")",
   "if",
   "len",
   "(",
   "x",
   ")",
   "<",
   "N",
   ":",
   "x",
   "=",
   "y",
   ".",
   "copy",
   "(",
   ")",
   "x",
   ".",
   "resize",
   "(",
   "N",
   ")",
   "if",
   "len",
   "(",
   "y",
   ")",
   "<",
   "N",
   ":",
   "y",
   "=",
   "y",
   ".",
   "copy",
   "(",
   ")",
   "y",
   ".",
   "resize",
   "(",
   "N",
   ")",
   "#default lag is N-1",
   "if",
   "maxlags",
   "is",
   "None",
   ":",
   "maxlags",
   "=",
   "N",
   "-",
   "1",
   "assert",
   "maxlags",
   "<",
   "N",
   ",",
   "'lag must be less than len(x)'",
   "realdata",
   "=",
   "np",
   ".",
   "isrealobj",
   "(",
   "x",
   ")",
   "and",
   "np",
   ".",
   "isrealobj",
   "(",
   "y",
   ")",
   "#create an autocorrelation array with same length as lag",
   "if",
   "realdata",
   "==",
   "True",
   ":",
   "r",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "maxlags",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "else",
   ":",
   "r",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "maxlags",
   ",",
   "dtype",
   "=",
   "complex",
   ")",
   "if",
   "norm",
   "==",
   "'coeff'",
   ":",
   "rmsx",
   "=",
   "pylab_rms_flat",
   "(",
   "x",
   ")",
   "rmsy",
   "=",
   "pylab_rms_flat",
   "(",
   "y",
   ")",
   "for",
   "k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "maxlags",
   "+",
   "1",
   ")",
   ":",
   "nk",
   "=",
   "N",
   "-",
   "k",
   "-",
   "1",
   "if",
   "realdata",
   "==",
   "True",
   ":",
   "sum",
   "=",
   "0",
   "for",
   "j",
   "in",
   "range",
   "(",
   "0",
   ",",
   "nk",
   "+",
   "1",
   ")",
   ":",
   "sum",
   "=",
   "sum",
   "+",
   "x",
   "[",
   "j",
   "+",
   "k",
   "]",
   "*",
   "y",
   "[",
   "j",
   "]",
   "else",
   ":",
   "sum",
   "=",
   "0.",
   "+",
   "0j",
   "for",
   "j",
   "in",
   "range",
   "(",
   "0",
   ",",
   "nk",
   "+",
   "1",
   ")",
   ":",
   "sum",
   "=",
   "sum",
   "+",
   "x",
   "[",
   "j",
   "+",
   "k",
   "]",
   "*",
   "y",
   "[",
   "j",
   "]",
   ".",
   "conjugate",
   "(",
   ")",
   "if",
   "k",
   "==",
   "0",
   ":",
   "if",
   "norm",
   "in",
   "[",
   "'biased'",
   ",",
   "'unbiased'",
   "]",
   ":",
   "r0",
   "=",
   "sum",
   "/",
   "float",
   "(",
   "N",
   ")",
   "elif",
   "norm",
   "is",
   "None",
   ":",
   "r0",
   "=",
   "sum",
   "else",
   ":",
   "r0",
   "=",
   "1.",
   "else",
   ":",
   "if",
   "norm",
   "==",
   "'unbiased'",
   ":",
   "r",
   "[",
   "k",
   "-",
   "1",
   "]",
   "=",
   "sum",
   "/",
   "float",
   "(",
   "N",
   "-",
   "k",
   ")",
   "elif",
   "norm",
   "==",
   "'biased'",
   ":",
   "r",
   "[",
   "k",
   "-",
   "1",
   "]",
   "=",
   "sum",
   "/",
   "float",
   "(",
   "N",
   ")",
   "elif",
   "norm",
   "is",
   "None",
   ":",
   "r",
   "[",
   "k",
   "-",
   "1",
   "]",
   "=",
   "sum",
   "elif",
   "norm",
   "==",
   "'coeff'",
   ":",
   "r",
   "[",
   "k",
   "-",
   "1",
   "]",
   "=",
   "sum",
   "/",
   "(",
   "rmsx",
   "*",
   "rmsy",
   ")",
   "/",
   "float",
   "(",
   "N",
   ")",
   "r",
   "=",
   "np",
   ".",
   "insert",
   "(",
   "r",
   ",",
   "0",
   ",",
   "r0",
   ")",
   "return",
   "r"
  ]
 },
 {
  "idx": "maxmin-208",
  "nl_tokens": [
   "Add",
   "constraints",
   "for",
   "CycleFreeFlux",
   "."
  ],
  "pl_tokens": [
   "def",
   "_add_cycle_free",
   "(",
   "model",
   ",",
   "fluxes",
   ")",
   ":",
   "model",
   ".",
   "objective",
   "=",
   "model",
   ".",
   "solver",
   ".",
   "interface",
   ".",
   "Objective",
   "(",
   "Zero",
   ",",
   "direction",
   "=",
   "\"min\"",
   ",",
   "sloppy",
   "=",
   "True",
   ")",
   "objective_vars",
   "=",
   "[",
   "]",
   "for",
   "rxn",
   "in",
   "model",
   ".",
   "reactions",
   ":",
   "flux",
   "=",
   "fluxes",
   "[",
   "rxn",
   ".",
   "id",
   "]",
   "if",
   "rxn",
   ".",
   "boundary",
   ":",
   "rxn",
   ".",
   "bounds",
   "=",
   "(",
   "flux",
   ",",
   "flux",
   ")",
   "continue",
   "if",
   "flux",
   ">=",
   "0",
   ":",
   "rxn",
   ".",
   "bounds",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "rxn",
   ".",
   "lower_bound",
   ")",
   ",",
   "max",
   "(",
   "flux",
   ",",
   "rxn",
   ".",
   "upper_bound",
   ")",
   "objective_vars",
   ".",
   "append",
   "(",
   "rxn",
   ".",
   "forward_variable",
   ")",
   "else",
   ":",
   "rxn",
   ".",
   "bounds",
   "=",
   "min",
   "(",
   "flux",
   ",",
   "rxn",
   ".",
   "lower_bound",
   ")",
   ",",
   "min",
   "(",
   "0",
   ",",
   "rxn",
   ".",
   "upper_bound",
   ")",
   "objective_vars",
   ".",
   "append",
   "(",
   "rxn",
   ".",
   "reverse_variable",
   ")",
   "model",
   ".",
   "objective",
   ".",
   "set_linear_coefficients",
   "(",
   "{",
   "v",
   ":",
   "1.0",
   "for",
   "v",
   "in",
   "objective_vars",
   "}",
   ")"
  ]
 },
 {
  "idx": "maxmin-209",
  "nl_tokens": [
   "Generate",
   "according",
   "to",
   "the",
   "topological",
   "order",
   "of",
   "the",
   "graph",
   "."
  ],
  "pl_tokens": [
   "def",
   "forward",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "noise",
   ".",
   "data",
   ".",
   "normal_",
   "(",
   ")",
   "if",
   "not",
   "self",
   ".",
   "confounding",
   ":",
   "for",
   "i",
   "in",
   "self",
   ".",
   "topological_order",
   ":",
   "self",
   ".",
   "generated",
   "[",
   "i",
   "]",
   "=",
   "self",
   ".",
   "blocks",
   "[",
   "i",
   "]",
   "(",
   "th",
   ".",
   "cat",
   "(",
   "[",
   "v",
   "for",
   "c",
   "in",
   "[",
   "[",
   "self",
   ".",
   "generated",
   "[",
   "j",
   "]",
   "for",
   "j",
   "in",
   "np",
   ".",
   "nonzero",
   "(",
   "self",
   ".",
   "adjacency_matrix",
   "[",
   ":",
   ",",
   "i",
   "]",
   ")",
   "[",
   "0",
   "]",
   "]",
   ",",
   "[",
   "self",
   ".",
   "noise",
   "[",
   ":",
   ",",
   "[",
   "i",
   "]",
   "]",
   "]",
   "]",
   "for",
   "v",
   "in",
   "c",
   "]",
   ",",
   "1",
   ")",
   ")",
   "else",
   ":",
   "for",
   "i",
   "in",
   "self",
   ".",
   "topological_order",
   ":",
   "self",
   ".",
   "generated",
   "[",
   "i",
   "]",
   "=",
   "self",
   ".",
   "blocks",
   "[",
   "i",
   "]",
   "(",
   "th",
   ".",
   "cat",
   "(",
   "[",
   "v",
   "for",
   "c",
   "in",
   "[",
   "[",
   "self",
   ".",
   "generated",
   "[",
   "j",
   "]",
   "for",
   "j",
   "in",
   "np",
   ".",
   "nonzero",
   "(",
   "self",
   ".",
   "adjacency_matrix",
   "[",
   ":",
   ",",
   "i",
   "]",
   ")",
   "[",
   "0",
   "]",
   "]",
   ",",
   "[",
   "self",
   ".",
   "corr_noise",
   "[",
   "<mask>",
   "(",
   "i",
   ",",
   "j",
   ")",
   ",",
   "max",
   "(",
   "i",
   ",",
   "j",
   ")",
   "]",
   "for",
   "j",
   "in",
   "np",
   ".",
   "nonzero",
   "(",
   "self",
   ".",
   "i_adj_matrix",
   "[",
   ":",
   ",",
   "i",
   "]",
   ")",
   "[",
   "0",
   "]",
   "]",
   "[",
   "self",
   ".",
   "noise",
   "[",
   ":",
   ",",
   "[",
   "i",
   "]",
   "]",
   "]",
   "]",
   "for",
   "v",
   "in",
   "c",
   "]",
   ",",
   "1",
   ")",
   ")",
   "return",
   "th",
   ".",
   "cat",
   "(",
   "self",
   ".",
   "generated",
   ",",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-210",
  "nl_tokens": [
   "Return",
   "an",
   "upper",
   "bound",
   "on",
   "ratio",
   "()",
   "very",
   "quickly",
   "."
  ],
  "pl_tokens": [
   "def",
   "real_quick_ratio",
   "(",
   "self",
   ")",
   ":",
   "la",
   ",",
   "lb",
   "=",
   "len",
   "(",
   "self",
   ".",
   "a",
   ")",
   ",",
   "len",
   "(",
   "self",
   ".",
   "b",
   ")",
   "# can't have more matches than the number of elements in the",
   "# shorter sequence",
   "return",
   "_calculate_ratio",
   "(",
   "<mask>",
   "(",
   "la",
   ",",
   "lb",
   ")",
   ",",
   "la",
   "+",
   "lb",
   ")"
  ]
 },
 {
  "idx": "maxmin-211",
  "nl_tokens": [
   "Attempts",
   "to",
   "add",
   "missing",
   "particles",
   "to",
   "the",
   "state",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_missing_particles",
   "(",
   "st",
   ",",
   "rad",
   "=",
   "'calc'",
   ",",
   "tries",
   "=",
   "50",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "rad",
   "==",
   "'calc'",
   ":",
   "rad",
   "=",
   "guess_add_radii",
   "(",
   "st",
   ")",
   "guess",
   ",",
   "npart",
   "=",
   "feature_guess",
   "(",
   "st",
   ",",
   "rad",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "tries",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "tries",
   ",",
   "npart",
   "]",
   ")",
   "accepts",
   ",",
   "new_poses",
   "=",
   "check_add_particles",
   "(",
   "st",
   ",",
   "guess",
   "[",
   ":",
   "tries",
   "]",
   ",",
   "rad",
   "=",
   "rad",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "return",
   "accepts",
   ",",
   "new_poses"
  ]
 },
 {
  "idx": "maxmin-212",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "find_nearest_dist_node",
   "(",
   "self",
   ",",
   "point",
   ",",
   "distance",
   ",",
   "retdistance",
   "=",
   "False",
   ")",
   ":",
   "best_nodes",
   "=",
   "self",
   ".",
   "find_nearest_dist_nodes",
   "(",
   "point",
   ",",
   "distance",
   ")",
   "if",
   "best_nodes",
   "==",
   "[",
   "]",
   ":",
   "return",
   "None",
   "nearest",
   "=",
   "<mask>",
   "(",
   "best_nodes",
   ",",
   "key",
   "=",
   "lambda",
   "item",
   ":",
   "item",
   "[",
   "0",
   "]",
   ")",
   "if",
   "retdistance",
   "is",
   "True",
   ":",
   "return",
   "nearest",
   "else",
   ":",
   "return",
   "nearest",
   "[",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-213",
  "nl_tokens": [
   "Return",
   "the",
   "bag",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "tar",
   "==",
   "src",
   ":",
   "return",
   "0",
   "elif",
   "not",
   "src",
   ":",
   "return",
   "len",
   "(",
   "tar",
   ")",
   "elif",
   "not",
   "tar",
   ":",
   "return",
   "len",
   "(",
   "src",
   ")",
   "src_bag",
   "=",
   "Counter",
   "(",
   "src",
   ")",
   "tar_bag",
   "=",
   "Counter",
   "(",
   "tar",
   ")",
   "return",
   "<mask>",
   "(",
   "sum",
   "(",
   "(",
   "src_bag",
   "-",
   "tar_bag",
   ")",
   ".",
   "values",
   "(",
   ")",
   ")",
   ",",
   "sum",
   "(",
   "(",
   "tar_bag",
   "-",
   "src_bag",
   ")",
   ".",
   "values",
   "(",
   ")",
   ")",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-214",
  "nl_tokens": [
   "Generic",
   "Metropolis",
   "MCMC",
   ".",
   "Advances",
   "the",
   "chain",
   "by",
   "nsteps",
   ".",
   "Called",
   "by",
   ":",
   "func",
   ":",
   "mcmc",
   ":",
   "param",
   "adapt",
   ":",
   "enables",
   "adaptive",
   "stepwidth",
   "alteration",
   "(",
   "converges",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "mcmc_advance",
   "(",
   "start",
   ",",
   "stdevs",
   ",",
   "logp",
   ",",
   "nsteps",
   "=",
   "1e300",
   ",",
   "adapt",
   "=",
   "True",
   ",",
   "callback",
   "=",
   "None",
   ")",
   ":",
   "import",
   "scipy",
   "from",
   "numpy",
   "import",
   "log",
   "import",
   "progressbar",
   "prob",
   "=",
   "logp",
   "(",
   "start",
   ")",
   "chain",
   "=",
   "[",
   "start",
   "]",
   "accepts",
   "=",
   "[",
   "True",
   "]",
   "probs",
   "=",
   "[",
   "prob",
   "]",
   "assert",
   "not",
   "numpy",
   ".",
   "isnan",
   "(",
   "start",
   ")",
   ".",
   "any",
   "(",
   ")",
   "assert",
   "not",
   "numpy",
   ".",
   "isnan",
   "(",
   "stdevs",
   ")",
   ".",
   "any",
   "(",
   ")",
   "i",
   "=",
   "0",
   "widgets",
   "=",
   "[",
   "'AR'",
   ",",
   "progressbar",
   ".",
   "Percentage",
   "(",
   ")",
   ",",
   "progressbar",
   ".",
   "Counter",
   "(",
   "'%5d'",
   ")",
   ",",
   "progressbar",
   ".",
   "Bar",
   "(",
   ")",
   ",",
   "progressbar",
   ".",
   "ETA",
   "(",
   ")",
   "]",
   "pbar",
   "=",
   "progressbar",
   ".",
   "ProgressBar",
   "(",
   "widgets",
   "=",
   "widgets",
   ",",
   "maxval",
   "=",
   "nsteps",
   ")",
   ".",
   "start",
   "(",
   ")",
   "prev",
   "=",
   "start",
   "prev_prob",
   "=",
   "prob",
   "print",
   "'MCMC: start at prob'",
   ",",
   "prob",
   "stepchange",
   "=",
   "0.1",
   "while",
   "len",
   "(",
   "chain",
   ")",
   "<",
   "nsteps",
   ":",
   "i",
   "=",
   "i",
   "+",
   "1",
   "next",
   "=",
   "scipy",
   ".",
   "random",
   ".",
   "normal",
   "(",
   "prev",
   ",",
   "stdevs",
   ")",
   "next",
   "[",
   "next",
   ">",
   "1",
   "]",
   "=",
   "1",
   "next",
   "[",
   "next",
   "<",
   "0",
   "]",
   "=",
   "0",
   "next_prob",
   "=",
   "logp",
   "(",
   "next",
   ")",
   "assert",
   "not",
   "numpy",
   ".",
   "isnan",
   "(",
   "next",
   ")",
   ".",
   "any",
   "(",
   ")",
   "assert",
   "not",
   "numpy",
   ".",
   "isnan",
   "(",
   "next_prob",
   ")",
   ".",
   "any",
   "(",
   ")",
   "delta",
   "=",
   "next_prob",
   "-",
   "prev_prob",
   "dice",
   "=",
   "log",
   "(",
   "scipy",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "0",
   ",",
   "1",
   ")",
   ")",
   "accept",
   "=",
   "delta",
   ">",
   "dice",
   "if",
   "accept",
   ":",
   "prev",
   "=",
   "next",
   "prev_prob",
   "=",
   "next_prob",
   "if",
   "adapt",
   ":",
   "stdevs",
   "*=",
   "(",
   "1",
   "+",
   "stepchange",
   ")",
   "else",
   ":",
   "if",
   "adapt",
   ":",
   "stdevs",
   "*=",
   "(",
   "1",
   "+",
   "stepchange",
   ")",
   "**",
   "(",
   "-",
   "0.4",
   ")",
   "# aiming for 40% acceptance",
   "if",
   "callback",
   ":",
   "callback",
   "(",
   "prev_prob",
   ",",
   "prev",
   ",",
   "accept",
   ")",
   "chain",
   ".",
   "append",
   "(",
   "prev",
   ")",
   "accepts",
   ".",
   "append",
   "(",
   "accept",
   ")",
   "probs",
   ".",
   "append",
   "(",
   "prev_prob",
   ")",
   "if",
   "adapt",
   ":",
   "stepchange",
   "=",
   "<mask>",
   "(",
   "0.1",
   ",",
   "10.",
   "/",
   "i",
   ")",
   "#print 'STDEV', stdevs[:5], stepchange",
   "# compute stats",
   "widgets",
   "[",
   "0",
   "]",
   "=",
   "'AR: %.03f'",
   "%",
   "numpy",
   ".",
   "mean",
   "(",
   "numpy",
   ".",
   "array",
   "(",
   "accepts",
   "[",
   "len",
   "(",
   "accepts",
   ")",
   "/",
   "3",
   ":",
   "]",
   ")",
   "+",
   "0",
   ")",
   "pbar",
   ".",
   "update",
   "(",
   "pbar",
   ".",
   "currval",
   "+",
   "1",
   ")",
   "pbar",
   ".",
   "finish",
   "(",
   ")",
   "return",
   "chain",
   ",",
   "probs",
   ",",
   "accepts",
   ",",
   "stdevs"
  ]
 },
 {
  "idx": "maxmin-215",
  "nl_tokens": [
   "Takes",
   "your",
   "standard",
   "rgb",
   "color",
   "and",
   "converts",
   "it",
   "to",
   "a",
   "proper",
   "hue",
   "value"
  ],
  "pl_tokens": [
   "def",
   "color_from_rgb",
   "(",
   "red",
   ",",
   "green",
   ",",
   "blue",
   ")",
   ":",
   "r",
   "=",
   "<mask>",
   "(",
   "red",
   ",",
   "255",
   ")",
   "g",
   "=",
   "min",
   "(",
   "green",
   ",",
   "255",
   ")",
   "b",
   "=",
   "min",
   "(",
   "blue",
   ",",
   "255",
   ")",
   "if",
   "r",
   ">",
   "1",
   "or",
   "g",
   ">",
   "1",
   "or",
   "b",
   ">",
   "1",
   ":",
   "r",
   "=",
   "r",
   "/",
   "255.0",
   "g",
   "=",
   "g",
   "/",
   "255.0",
   "b",
   "=",
   "b",
   "/",
   "255.0",
   "return",
   "color_from_hls",
   "(",
   "*",
   "rgb_to_hls",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-216",
  "nl_tokens": [
   "Return",
   "InputTile",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "open",
   "(",
   "self",
   ",",
   "tile",
   ",",
   "tile_directory_zoom",
   "=",
   "None",
   ",",
   "matching_method",
   "=",
   "\"gdal\"",
   ",",
   "matching_max_zoom",
   "=",
   "None",
   ",",
   "matching_precision",
   "=",
   "8",
   ",",
   "fallback_to_higher_zoom",
   "=",
   "False",
   ",",
   "resampling",
   "=",
   "\"nearest\"",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# determine tile bounds in TileDirectory CRS",
   "td_bounds",
   "=",
   "reproject_geometry",
   "(",
   "tile",
   ".",
   "bbox",
   ",",
   "src_crs",
   "=",
   "tile",
   ".",
   "tp",
   ".",
   "crs",
   ",",
   "dst_crs",
   "=",
   "self",
   ".",
   "td_pyramid",
   ".",
   "crs",
   ")",
   ".",
   "bounds",
   "# find target zoom level",
   "if",
   "tile_directory_zoom",
   "is",
   "not",
   "None",
   ":",
   "zoom",
   "=",
   "tile_directory_zoom",
   "else",
   ":",
   "zoom",
   "=",
   "tile_to_zoom_level",
   "(",
   "tile",
   ",",
   "dst_pyramid",
   "=",
   "self",
   ".",
   "td_pyramid",
   ",",
   "matching_method",
   "=",
   "matching_method",
   ",",
   "precision",
   "=",
   "matching_precision",
   ")",
   "if",
   "matching_max_zoom",
   "is",
   "not",
   "None",
   ":",
   "zoom",
   "=",
   "<mask>",
   "(",
   "[",
   "zoom",
   ",",
   "matching_max_zoom",
   "]",
   ")",
   "if",
   "fallback_to_higher_zoom",
   ":",
   "tiles_paths",
   "=",
   "[",
   "]",
   "# check if tiles exist otherwise try higher zoom level",
   "while",
   "len",
   "(",
   "tiles_paths",
   ")",
   "==",
   "0",
   "and",
   "zoom",
   ">=",
   "0",
   ":",
   "tiles_paths",
   "=",
   "_get_tiles_paths",
   "(",
   "basepath",
   "=",
   "self",
   ".",
   "path",
   ",",
   "ext",
   "=",
   "self",
   ".",
   "_ext",
   ",",
   "pyramid",
   "=",
   "self",
   ".",
   "td_pyramid",
   ",",
   "bounds",
   "=",
   "td_bounds",
   ",",
   "zoom",
   "=",
   "zoom",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"%s existing tiles found at zoom %s\"",
   ",",
   "len",
   "(",
   "tiles_paths",
   ")",
   ",",
   "zoom",
   ")",
   "zoom",
   "-=",
   "1",
   "else",
   ":",
   "tiles_paths",
   "=",
   "_get_tiles_paths",
   "(",
   "basepath",
   "=",
   "self",
   ".",
   "path",
   ",",
   "ext",
   "=",
   "self",
   ".",
   "_ext",
   ",",
   "pyramid",
   "=",
   "self",
   ".",
   "td_pyramid",
   ",",
   "bounds",
   "=",
   "td_bounds",
   ",",
   "zoom",
   "=",
   "zoom",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"%s existing tiles found at zoom %s\"",
   ",",
   "len",
   "(",
   "tiles_paths",
   ")",
   ",",
   "zoom",
   ")",
   "return",
   "InputTile",
   "(",
   "tile",
   ",",
   "tiles_paths",
   "=",
   "tiles_paths",
   ",",
   "file_type",
   "=",
   "self",
   ".",
   "_file_type",
   ",",
   "profile",
   "=",
   "self",
   ".",
   "_profile",
   ",",
   "td_crs",
   "=",
   "self",
   ".",
   "td_pyramid",
   ".",
   "crs",
   ",",
   "resampling",
   "=",
   "resampling",
   ",",
   "read_as_tiledir_func",
   "=",
   "self",
   ".",
   "_read_as_tiledir_func",
   ",",
   "*",
   "*",
   "kwargs",
   ")"
  ]
 },
 {
  "idx": "maxmin-217",
  "nl_tokens": [
   "Roughly",
   "the",
   "complement",
   "and",
   "some",
   "far",
   "analogs",
   "."
  ],
  "pl_tokens": [
   "def",
   "compound",
   "(",
   "clr",
   ",",
   "flip",
   "=",
   "False",
   ")",
   ":",
   "def",
   "_wrap",
   "(",
   "x",
   ",",
   "<mask>",
   ",",
   "threshold",
   ",",
   "plus",
   ")",
   ":",
   "if",
   "x",
   "-",
   "min",
   "<",
   "threshold",
   ":",
   "return",
   "x",
   "+",
   "plus",
   "else",
   ":",
   "return",
   "x",
   "-",
   "min",
   "d",
   "=",
   "1",
   "if",
   "flip",
   ":",
   "d",
   "=",
   "-",
   "1",
   "clr",
   "=",
   "color",
   "(",
   "clr",
   ")",
   "colors",
   "=",
   "colorlist",
   "(",
   "clr",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "rotate_ryb",
   "(",
   "30",
   "*",
   "d",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.25",
   ",",
   "0.6",
   ",",
   "0.25",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "rotate_ryb",
   "(",
   "30",
   "*",
   "d",
   ")",
   "c",
   ".",
   "saturation",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "saturation",
   ",",
   "0.4",
   ",",
   "0.1",
   ",",
   "0.4",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.4",
   ",",
   "0.2",
   ",",
   "0.4",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "rotate_ryb",
   "(",
   "160",
   "*",
   "d",
   ")",
   "c",
   ".",
   "saturation",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "saturation",
   ",",
   "0.25",
   ",",
   "0.1",
   ",",
   "0.25",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "max",
   "(",
   "0.2",
   ",",
   "clr",
   ".",
   "brightness",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "rotate_ryb",
   "(",
   "150",
   "*",
   "d",
   ")",
   "c",
   ".",
   "saturation",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "saturation",
   ",",
   "0.1",
   ",",
   "0.8",
   ",",
   "0.1",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.3",
   ",",
   "0.6",
   ",",
   "0.3",
   ")",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "c",
   "=",
   "clr",
   ".",
   "rotate_ryb",
   "(",
   "150",
   "*",
   "d",
   ")",
   "c",
   ".",
   "saturation",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "saturation",
   ",",
   "0.1",
   ",",
   "0.8",
   ",",
   "0.1",
   ")",
   "c",
   ".",
   "brightness",
   "=",
   "_wrap",
   "(",
   "clr",
   ".",
   "brightness",
   ",",
   "0.4",
   ",",
   "0.2",
   ",",
   "0.4",
   ")",
   "# colors.append(c)",
   "return",
   "colors"
  ]
 },
 {
  "idx": "maxmin-218",
  "nl_tokens": [
   "Pour",
   "chaque",
   "serie",
   "(",
   "colonne",
   ")",
   "d",
   "un",
   "DataFrame",
   "va",
   "rechercher",
   "la",
   "(",
   "les",
   ")",
   "valeur",
   "(",
   "s",
   ")",
   "et",
   "la",
   "(",
   "les",
   ")",
   "date",
   "(",
   "s",
   ")",
   "du",
   "(",
   "des",
   ")",
   "max",
   "."
  ],
  "pl_tokens": [
   "def",
   "show_max",
   "(",
   "df",
   ")",
   ":",
   "df",
   "=",
   "df",
   ".",
   "astype",
   "(",
   "pd",
   ".",
   "np",
   ".",
   "float",
   ")",
   "res",
   "=",
   "list",
   "(",
   ")",
   "for",
   "c",
   "in",
   "df",
   ".",
   "columns",
   ":",
   "serie",
   "=",
   "df",
   "[",
   "c",
   "]",
   "res",
   ".",
   "append",
   "(",
   "serie",
   ".",
   "where",
   "(",
   "cond",
   "=",
   "serie",
   "==",
   "serie",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "other",
   "=",
   "pd",
   ".",
   "np",
   ".",
   "nan",
   ")",
   ".",
   "dropna",
   "(",
   ")",
   ")",
   "return",
   "pd",
   ".",
   "DataFrame",
   "(",
   "res",
   ")",
   ".",
   "T"
  ]
 },
 {
  "idx": "maxmin-219",
  "nl_tokens": [
   "Checks",
   "whether",
   "or",
   "not",
   "adding",
   "a",
   "particle",
   "should",
   "be",
   "present",
   "."
  ],
  "pl_tokens": [
   "def",
   "should_particle_exist",
   "(",
   "absent_err",
   ",",
   "present_err",
   ",",
   "absent_d",
   ",",
   "present_d",
   ",",
   "im_change_frac",
   "=",
   "0.2",
   ",",
   "min_derr",
   "=",
   "0.1",
   ")",
   ":",
   "delta_im",
   "=",
   "np",
   ".",
   "ravel",
   "(",
   "present_d",
   "-",
   "absent_d",
   ")",
   "im_change",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "delta_im",
   ",",
   "delta_im",
   ")",
   "err_cutoff",
   "=",
   "<mask>",
   "(",
   "[",
   "im_change_frac",
   "*",
   "im_change",
   ",",
   "min_derr",
   "]",
   ")",
   "return",
   "(",
   "absent_err",
   "-",
   "present_err",
   ")",
   ">=",
   "err_cutoff"
  ]
 },
 {
  "idx": "maxmin-220",
  "nl_tokens": [
   "Perform",
   "inference",
   "for",
   "a",
   "single",
   "step",
   ".",
   "Given",
   "an",
   "SDR",
   "input",
   "and",
   "a",
   "weight",
   "matrix",
   "return",
   "a",
   "predicted",
   "distribution",
   "."
  ],
  "pl_tokens": [
   "def",
   "inferSingleStep",
   "(",
   "self",
   ",",
   "patternNZ",
   ",",
   "weightMatrix",
   ")",
   ":",
   "outputActivation",
   "=",
   "weightMatrix",
   "[",
   "patternNZ",
   "]",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "# softmax normalization",
   "outputActivation",
   "=",
   "outputActivation",
   "-",
   "numpy",
   ".",
   "<mask>",
   "(",
   "outputActivation",
   ")",
   "expOutputActivation",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "outputActivation",
   ")",
   "predictDist",
   "=",
   "expOutputActivation",
   "/",
   "numpy",
   ".",
   "sum",
   "(",
   "expOutputActivation",
   ")",
   "return",
   "predictDist"
  ]
 },
 {
  "idx": "maxmin-221",
  "nl_tokens": [
   "Generates",
   "ngrams",
   "(",
   "word",
   "sequences",
   "of",
   "fixed",
   "length",
   ")",
   "from",
   "an",
   "input",
   "token",
   "sequence",
   ".",
   "tokens",
   "is",
   "a",
   "list",
   "of",
   "words",
   ".",
   "min_n",
   "is",
   "the",
   "minimum",
   "length",
   "of",
   "an",
   "ngram",
   "to",
   "return",
   ".",
   "max_n",
   "is",
   "the",
   "maximum",
   "length",
   "of",
   "an",
   "ngram",
   "to",
   "return",
   ".",
   "returns",
   "a",
   "list",
   "of",
   "ngrams",
   "(",
   "words",
   "separated",
   "by",
   "a",
   "space",
   ")"
  ],
  "pl_tokens": [
   "def",
   "ngrams",
   "(",
   "tokens",
   ",",
   "min_n",
   ",",
   "max_n",
   ")",
   ":",
   "all_ngrams",
   "=",
   "list",
   "(",
   ")",
   "n_tokens",
   "=",
   "len",
   "(",
   "tokens",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "n_tokens",
   ")",
   ":",
   "for",
   "j",
   "in",
   "xrange",
   "(",
   "i",
   "+",
   "min_n",
   ",",
   "<mask>",
   "(",
   "n_tokens",
   ",",
   "i",
   "+",
   "max_n",
   ")",
   "+",
   "1",
   ")",
   ":",
   "all_ngrams",
   ".",
   "append",
   "(",
   "\" \"",
   ".",
   "join",
   "(",
   "tokens",
   "[",
   "i",
   ":",
   "j",
   "]",
   ")",
   ")",
   "return",
   "all_ngrams"
  ]
 },
 {
  "idx": "maxmin-222",
  "nl_tokens": [
   "Determines",
   "a",
   "confidence",
   "in",
   "a",
   "certain",
   "score",
   "given",
   "proper",
   "input",
   "parameters",
   "algorithm",
   "-",
   "from",
   "util_functions",
   ".",
   "AlgorithmTypes",
   "model",
   "-",
   "a",
   "trained",
   "model",
   "grader_feats",
   "-",
   "a",
   "row",
   "of",
   "features",
   "used",
   "by",
   "the",
   "model",
   "for",
   "classification",
   "/",
   "regression",
   "score",
   "-",
   "The",
   "score",
   "assigned",
   "to",
   "the",
   "submission",
   "by",
   "a",
   "prior",
   "model"
  ],
  "pl_tokens": [
   "def",
   "get_confidence_value",
   "(",
   "algorithm",
   ",",
   "model",
   ",",
   "grader_feats",
   ",",
   "score",
   ",",
   "scores",
   ")",
   ":",
   "min_score",
   "=",
   "<mask>",
   "(",
   "numpy",
   ".",
   "asarray",
   "(",
   "scores",
   ")",
   ")",
   "max_score",
   "=",
   "max",
   "(",
   "numpy",
   ".",
   "asarray",
   "(",
   "scores",
   ")",
   ")",
   "if",
   "algorithm",
   "==",
   "util_functions",
   ".",
   "AlgorithmTypes",
   ".",
   "classification",
   "and",
   "hasattr",
   "(",
   "model",
   ",",
   "\"predict_proba\"",
   ")",
   ":",
   "#If classification, predict with probability, which gives you a matrix of confidences per score point",
   "raw_confidence",
   "=",
   "model",
   ".",
   "predict_proba",
   "(",
   "grader_feats",
   ")",
   "[",
   "0",
   ",",
   "(",
   "float",
   "(",
   "score",
   ")",
   "-",
   "float",
   "(",
   "min_score",
   ")",
   ")",
   "]",
   "#TODO: Normalize confidence somehow here",
   "confidence",
   "=",
   "raw_confidence",
   "elif",
   "hasattr",
   "(",
   "model",
   ",",
   "\"predict\"",
   ")",
   ":",
   "raw_confidence",
   "=",
   "model",
   ".",
   "predict",
   "(",
   "grader_feats",
   ")",
   "[",
   "0",
   "]",
   "confidence",
   "=",
   "max",
   "(",
   "float",
   "(",
   "raw_confidence",
   ")",
   "-",
   "math",
   ".",
   "floor",
   "(",
   "float",
   "(",
   "raw_confidence",
   ")",
   ")",
   ",",
   "math",
   ".",
   "ceil",
   "(",
   "float",
   "(",
   "raw_confidence",
   ")",
   ")",
   "-",
   "float",
   "(",
   "raw_confidence",
   ")",
   ")",
   "else",
   ":",
   "confidence",
   "=",
   "0",
   "return",
   "confidence"
  ]
 },
 {
  "idx": "maxmin-223",
  "nl_tokens": [
   ":",
   "returns",
   ":",
   "maximum",
   "stop",
   "in",
   "list",
   "or",
   "None",
   "if",
   "there",
   "s",
   "at",
   "least",
   "one",
   "open",
   "range",
   ":",
   "type",
   ":",
   "int",
   "float",
   "or",
   "None"
  ],
  "pl_tokens": [
   "def",
   "max_stop",
   "(",
   "self",
   ")",
   ":",
   "m",
   "=",
   "0",
   "for",
   "r",
   "in",
   "self",
   ":",
   "if",
   "r",
   ".",
   "is_open",
   "(",
   ")",
   ":",
   "return",
   "None",
   "m",
   "=",
   "<mask>",
   "(",
   "m",
   ",",
   "r",
   ".",
   "stop",
   ")",
   "return",
   "m"
  ]
 },
 {
  "idx": "maxmin-224",
  "nl_tokens": [
   "Sets",
   "up",
   "for",
   "divergence",
   "estimation",
   "from",
   "new",
   "data",
   "to",
   "X",
   ".",
   "Builds",
   "FLANN",
   "indices",
   "for",
   "each",
   "bag",
   "and",
   "maybe",
   "gets",
   "within",
   "-",
   "bag",
   "distances",
   "."
  ],
  "pl_tokens": [
   "def",
   "fit",
   "(",
   "self",
   ",",
   "X",
   ",",
   "y",
   "=",
   "None",
   ",",
   "get_rhos",
   "=",
   "False",
   ")",
   ":",
   "self",
   ".",
   "features_",
   "=",
   "X",
   "=",
   "as_features",
   "(",
   "X",
   ",",
   "stack",
   "=",
   "True",
   ",",
   "bare",
   "=",
   "True",
   ")",
   "# if we're using a function that needs to pick its K vals itself,",
   "# then we need to set max_K here. when we transform(), might have to",
   "# re-do this :|",
   "Ks",
   "=",
   "self",
   ".",
   "_get_Ks",
   "(",
   ")",
   "_",
   ",",
   "_",
   ",",
   "_",
   ",",
   "max_K",
   ",",
   "save_all_Ks",
   ",",
   "_",
   "=",
   "_choose_funcs",
   "(",
   "self",
   ".",
   "div_funcs",
   ",",
   "Ks",
   ",",
   "X",
   ".",
   "dim",
   ",",
   "X",
   ".",
   "n_pts",
   ",",
   "None",
   ",",
   "self",
   ".",
   "version",
   ")",
   "if",
   "max_K",
   ">=",
   "X",
   ".",
   "n_pts",
   ".",
   "<mask>",
   "(",
   ")",
   ":",
   "msg",
   "=",
   "\"asked for K = {}, but there's a bag with only {} points\"",
   "raise",
   "ValueError",
   "(",
   "msg",
   ".",
   "format",
   "(",
   "max_K",
   ",",
   "X",
   ".",
   "n_pts",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "memory",
   "=",
   "self",
   ".",
   "memory",
   "if",
   "isinstance",
   "(",
   "memory",
   ",",
   "string_types",
   ")",
   ":",
   "memory",
   "=",
   "Memory",
   "(",
   "cachedir",
   "=",
   "memory",
   ",",
   "verbose",
   "=",
   "0",
   ")",
   "self",
   ".",
   "indices_",
   "=",
   "id",
   "=",
   "memory",
   ".",
   "cache",
   "(",
   "_build_indices",
   ")",
   "(",
   "X",
   ",",
   "self",
   ".",
   "_flann_args",
   "(",
   ")",
   ")",
   "if",
   "get_rhos",
   ":",
   "self",
   ".",
   "rhos_",
   "=",
   "_get_rhos",
   "(",
   "X",
   ",",
   "id",
   ",",
   "Ks",
   ",",
   "max_K",
   ",",
   "save_all_Ks",
   ",",
   "self",
   ".",
   "min_dist",
   ")",
   "elif",
   "hasattr",
   "(",
   "self",
   ",",
   "'rhos_'",
   ")",
   ":",
   "del",
   "self",
   ".",
   "rhos_",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-225",
  "nl_tokens": [
   "For",
   "step",
   "6",
   "the",
   "run",
   "function",
   "is",
   "sub",
   "divided",
   "a",
   "bit",
   "so",
   "that",
   "users",
   "with",
   "really",
   "difficult",
   "assemblies",
   "can",
   "possibly",
   "interrupt",
   "and",
   "restart",
   "the",
   "step",
   "from",
   "a",
   "checkpoint",
   "."
  ],
  "pl_tokens": [
   "def",
   "run",
   "(",
   "data",
   ",",
   "samples",
   ",",
   "noreverse",
   ",",
   "force",
   ",",
   "randomseed",
   ",",
   "ipyclient",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "## if force then set checkpoint to zero and run all substeps for just",
   "## the user specified steps. ",
   "if",
   "force",
   ":",
   "data",
   ".",
   "_checkpoint",
   "=",
   "0",
   "if",
   "kwargs",
   ".",
   "get",
   "(",
   "'substeps'",
   ")",
   ":",
   "substeps",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'substeps'",
   ")",
   "else",
   ":",
   "substeps",
   "=",
   "range",
   "(",
   "1",
   ",",
   "8",
   ")",
   "## if {data}._checkpoint attribute exists then find the checkpoint where",
   "## this assembly left off (unless force) and build step list from there.",
   "else",
   ":",
   "if",
   "kwargs",
   ".",
   "get",
   "(",
   "'substeps'",
   ")",
   ":",
   "substeps",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'substeps'",
   ")",
   "else",
   ":",
   "if",
   "hasattr",
   "(",
   "data",
   ",",
   "'_checkpoint'",
   ")",
   ":",
   "substeps",
   "=",
   "range",
   "(",
   "<mask>",
   "(",
   "1",
   ",",
   "data",
   ".",
   "_checkpoint",
   ")",
   ",",
   "8",
   ")",
   "else",
   ":",
   "data",
   ".",
   "_checkpoint",
   "=",
   "0",
   "substeps",
   "=",
   "range",
   "(",
   "1",
   ",",
   "8",
   ")",
   "## build substeps list to subset which funtions need to be run",
   "if",
   "isinstance",
   "(",
   "substeps",
   ",",
   "(",
   "int",
   ",",
   "float",
   ",",
   "str",
   ")",
   ")",
   ":",
   "substeps",
   "=",
   "[",
   "substeps",
   "]",
   "substeps",
   "=",
   "[",
   "int",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "substeps",
   "]",
   "## print continuation message",
   "if",
   "substeps",
   "[",
   "0",
   "]",
   "!=",
   "1",
   ":",
   "print",
   "(",
   "\"{}Continuing from checkpoint 6.{}\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "_spacer",
   ",",
   "substeps",
   "[",
   "0",
   "]",
   ")",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"checkpoint = %s\"",
   ",",
   "data",
   ".",
   "_checkpoint",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"substeps = %s\"",
   ",",
   "substeps",
   ")",
   "## Set variables on data that are needed for all steps;",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   "=",
   "os",
   ".",
   "path",
   ".",
   "realpath",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"project_dir\"",
   "]",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\"_across\"",
   ")",
   ")",
   "data",
   ".",
   "tmpdir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\"-tmpalign\"",
   ")",
   "data",
   ".",
   "clust_database",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".clust.hdf5\"",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   ")",
   ":",
   "os",
   ".",
   "mkdir",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "data",
   ".",
   "tmpdir",
   ")",
   ":",
   "os",
   ".",
   "mkdir",
   "(",
   "data",
   ".",
   "tmpdir",
   ")",
   "data",
   ".",
   "cpus",
   "=",
   "data",
   ".",
   "_ipcluster",
   "[",
   "\"cores\"",
   "]",
   "if",
   "not",
   "data",
   ".",
   "cpus",
   ":",
   "data",
   ".",
   "cpus",
   "=",
   "len",
   "(",
   "ipyclient",
   ")",
   "## STEP 6-1: Clean database and build input concat file for clustering",
   "if",
   "1",
   "in",
   "substeps",
   ":",
   "clean_and_build_concat",
   "(",
   "data",
   ",",
   "samples",
   ",",
   "randomseed",
   ",",
   "ipyclient",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "1",
   "## STEP 6-2: Cluster across w/ vsearch; uses all threads on largest host ",
   "if",
   "2",
   "in",
   "substeps",
   ":",
   "call_cluster",
   "(",
   "data",
   ",",
   "noreverse",
   ",",
   "ipyclient",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "2",
   "## builds consens cluster bits and writes them to the tmp directory. These",
   "## will not be deleted until either step 6-6 is complete, or the force flag",
   "## is used. This will clear the tmpdir if it is run.",
   "if",
   "3",
   "in",
   "substeps",
   ":",
   "build_clustbits",
   "(",
   "data",
   ",",
   "ipyclient",
   ",",
   "force",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "3",
   "## muscle align the cluster bits and create tmp hdf5 indel arrays for the",
   "## next step. These will not be deleted until...",
   "if",
   "4",
   "in",
   "substeps",
   ":",
   "multi_muscle_align",
   "(",
   "data",
   ",",
   "samples",
   ",",
   "ipyclient",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "4",
   "## fill the indel array with the indel tmp arrays from aligning step.",
   "if",
   "5",
   "in",
   "substeps",
   ":",
   "build_indels",
   "(",
   "data",
   ",",
   "samples",
   ",",
   "ipyclient",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "5",
   "if",
   "6",
   "in",
   "substeps",
   ":",
   "## builds the final HDF5 array which includes three main keys",
   "## /catg -- contains all indiv catgs and has indels inserted",
   "##   .attr['samples'] = [samples]",
   "## /filters -- filled for dups, left empty for others until step 7.",
   "##   .attr['filters'] = [f1, f2, f3, f4, f5]",
   "## /seqs -- contains the clustered sequence data as string arrays",
   "##   .attr['samples'] = [samples]",
   "## /edges -- gets the paired split locations for now.",
   "## /snps  -- left empty for now",
   "## FILL SUPERCATG and fills dupfilter, indfilter, and nalleles",
   "## this function calls singlecat() on each sample and enters their",
   "## resulting arrays into the superarray. If all singlecats are built",
   "## then it will continue to enter them into the database. ",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"multicat -- building full database\"",
   ")",
   "new_multicat",
   "(",
   "data",
   ",",
   "samples",
   ",",
   "ipyclient",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "6",
   "if",
   "7",
   "in",
   "substeps",
   ":",
   "## FILL SUPERSEQS and fills edges(splits) for paired-end data",
   "fill_superseqs",
   "(",
   "data",
   ",",
   "samples",
   ")",
   "data",
   ".",
   "_checkpoint",
   "=",
   "7",
   "## remove files but not dir (used in step 1 too)",
   "cleanup_tempfiles",
   "(",
   "data",
   ")",
   "## remove the tmpdir",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "data",
   ".",
   "tmpdir",
   ")",
   ":",
   "shutil",
   ".",
   "rmtree",
   "(",
   "data",
   ".",
   "tmpdir",
   ")",
   "## set sample states",
   "for",
   "sample",
   "in",
   "samples",
   ":",
   "sample",
   ".",
   "stats",
   ".",
   "state",
   "=",
   "6",
   "print",
   "(",
   "\"\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-226",
  "nl_tokens": [
   "Given",
   "the",
   "name",
   "of",
   "an",
   "aggregation",
   "function",
   "returns",
   "the",
   "function",
   "pointer",
   "and",
   "param",
   "."
  ],
  "pl_tokens": [
   "def",
   "_getFuncPtrAndParams",
   "(",
   "self",
   ",",
   "funcName",
   ")",
   ":",
   "params",
   "=",
   "None",
   "if",
   "isinstance",
   "(",
   "funcName",
   ",",
   "basestring",
   ")",
   ":",
   "if",
   "funcName",
   "==",
   "'sum'",
   ":",
   "fp",
   "=",
   "_aggr_sum",
   "elif",
   "funcName",
   "==",
   "'first'",
   ":",
   "fp",
   "=",
   "_aggr_first",
   "elif",
   "funcName",
   "==",
   "'last'",
   ":",
   "fp",
   "=",
   "_aggr_last",
   "elif",
   "funcName",
   "==",
   "'mean'",
   ":",
   "fp",
   "=",
   "_aggr_mean",
   "elif",
   "funcName",
   "==",
   "'max'",
   ":",
   "fp",
   "=",
   "<mask>",
   "elif",
   "funcName",
   "==",
   "'min'",
   ":",
   "fp",
   "=",
   "min",
   "elif",
   "funcName",
   "==",
   "'mode'",
   ":",
   "fp",
   "=",
   "_aggr_mode",
   "elif",
   "funcName",
   ".",
   "startswith",
   "(",
   "'wmean:'",
   ")",
   ":",
   "fp",
   "=",
   "_aggr_weighted_mean",
   "paramsName",
   "=",
   "funcName",
   "[",
   "6",
   ":",
   "]",
   "params",
   "=",
   "[",
   "f",
   "[",
   "0",
   "]",
   "for",
   "f",
   "in",
   "self",
   ".",
   "_inputFields",
   "]",
   ".",
   "index",
   "(",
   "paramsName",
   ")",
   "else",
   ":",
   "fp",
   "=",
   "funcName",
   "return",
   "(",
   "fp",
   ",",
   "params",
   ")"
  ]
 },
 {
  "idx": "maxmin-227",
  "nl_tokens": [
   "Removes",
   "a",
   "periodic",
   "sinusoidal",
   "signal",
   "generated",
   "using",
   "whitenparams",
   "from",
   "the",
   "input",
   "magnitude",
   "time",
   "series",
   "."
  ],
  "pl_tokens": [
   "def",
   "prewhiten_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "whitenperiod",
   ",",
   "whitenparams",
   ",",
   "sigclip",
   "=",
   "3.0",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "plotfit",
   "=",
   "None",
   ",",
   "plotfitphasedlconly",
   "=",
   "True",
   ",",
   "rescaletomedian",
   "=",
   "True",
   ")",
   ":",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ")",
   "median_mag",
   "=",
   "np",
   ".",
   "median",
   "(",
   "smags",
   ")",
   "# phase the mag series using the given period and epoch = min(stimes)",
   "mintime",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "stimes",
   ")",
   "# calculate the unsorted phase, then sort it",
   "iphase",
   "=",
   "(",
   "(",
   "stimes",
   "-",
   "mintime",
   ")",
   "/",
   "whitenperiod",
   "-",
   "np",
   ".",
   "floor",
   "(",
   "(",
   "stimes",
   "-",
   "mintime",
   ")",
   "/",
   "whitenperiod",
   ")",
   ")",
   "phasesortind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "iphase",
   ")",
   "# these are the final quantities to use for the Fourier fits",
   "phase",
   "=",
   "iphase",
   "[",
   "phasesortind",
   "]",
   "pmags",
   "=",
   "smags",
   "[",
   "phasesortind",
   "]",
   "perrs",
   "=",
   "serrs",
   "[",
   "phasesortind",
   "]",
   "# get the times sorted in phase order (useful to get the fit mag minimum",
   "# with respect to phase -- the light curve minimum)",
   "ptimes",
   "=",
   "stimes",
   "[",
   "phasesortind",
   "]",
   "# now subtract the harmonic series from the phased LC",
   "# these are still in phase order",
   "wmags",
   "=",
   "pmags",
   "-",
   "_fourier_func",
   "(",
   "whitenparams",
   ",",
   "phase",
   ",",
   "pmags",
   ")",
   "# resort everything by time order",
   "wtimeorder",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "ptimes",
   ")",
   "wtimes",
   "=",
   "ptimes",
   "[",
   "wtimeorder",
   "]",
   "wphase",
   "=",
   "phase",
   "[",
   "wtimeorder",
   "]",
   "wmags",
   "=",
   "wmags",
   "[",
   "wtimeorder",
   "]",
   "werrs",
   "=",
   "perrs",
   "[",
   "wtimeorder",
   "]",
   "if",
   "rescaletomedian",
   ":",
   "wmags",
   "=",
   "wmags",
   "+",
   "median_mag",
   "# prepare the returndict",
   "returndict",
   "=",
   "{",
   "'wtimes'",
   ":",
   "wtimes",
   ",",
   "# these are in the new time order",
   "'wphase'",
   ":",
   "wphase",
   ",",
   "'wmags'",
   ":",
   "wmags",
   ",",
   "'werrs'",
   ":",
   "werrs",
   ",",
   "'whitenparams'",
   ":",
   "whitenparams",
   ",",
   "'whitenperiod'",
   ":",
   "whitenperiod",
   "}",
   "# make the fit plot if required",
   "if",
   "plotfit",
   "and",
   "(",
   "isinstance",
   "(",
   "plotfit",
   ",",
   "str",
   ")",
   "or",
   "isinstance",
   "(",
   "plotfit",
   ",",
   "Strio",
   ")",
   ")",
   ":",
   "if",
   "plotfitphasedlconly",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "10",
   ",",
   "4.8",
   ")",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "16",
   ",",
   "9.6",
   ")",
   ")",
   "if",
   "plotfitphasedlconly",
   ":",
   "# phased series before whitening",
   "plt",
   ".",
   "subplot",
   "(",
   "121",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "phase",
   ",",
   "pmags",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "linestyle",
   "=",
   "'None'",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylabel",
   "(",
   "'fluxes'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'phase'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'phased LC before pre-whitening'",
   ")",
   "# phased series after whitening",
   "plt",
   ".",
   "subplot",
   "(",
   "122",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "wphase",
   ",",
   "wmags",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "'g'",
   ",",
   "linestyle",
   "=",
   "'None'",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylabel",
   "(",
   "'fluxes'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'phase'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'phased LC after pre-whitening'",
   ")",
   "else",
   ":",
   "# time series before whitening",
   "plt",
   ".",
   "subplot",
   "(",
   "221",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "linestyle",
   "=",
   "'None'",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylabel",
   "(",
   "'fluxes'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'JD'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'LC before pre-whitening'",
   ")",
   "# time series after whitening",
   "plt",
   ".",
   "subplot",
   "(",
   "222",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "wtimes",
   ",",
   "wmags",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "'g'",
   ",",
   "linestyle",
   "=",
   "'None'",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylabel",
   "(",
   "'fluxes'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'JD'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'LC after pre-whitening with period: %.6f'",
   "%",
   "whitenperiod",
   ")",
   "# phased series before whitening",
   "plt",
   ".",
   "subplot",
   "(",
   "223",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "phase",
   ",",
   "pmags",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "linestyle",
   "=",
   "'None'",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylabel",
   "(",
   "'fluxes'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'phase'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'phased LC before pre-whitening'",
   ")",
   "# phased series after whitening",
   "plt",
   ".",
   "subplot",
   "(",
   "224",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "wphase",
   ",",
   "wmags",
   ",",
   "marker",
   "=",
   "'.'",
   ",",
   "color",
   "=",
   "'g'",
   ",",
   "linestyle",
   "=",
   "'None'",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylabel",
   "(",
   "'fluxes'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'phase'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'phased LC after pre-whitening'",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "savefig",
   "(",
   "plotfit",
   ",",
   "format",
   "=",
   "'png'",
   ",",
   "pad_inches",
   "=",
   "0.0",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "if",
   "isinstance",
   "(",
   "plotfit",
   ",",
   "str",
   ")",
   "or",
   "isinstance",
   "(",
   "plotfit",
   ",",
   "Strio",
   ")",
   ":",
   "returndict",
   "[",
   "'fitplotfile'",
   "]",
   "=",
   "plotfit",
   "return",
   "returndict"
  ]
 },
 {
  "idx": "maxmin-228",
  "nl_tokens": [
   "Remove",
   "common",
   "indentation",
   "from",
   "string",
   "."
  ],
  "pl_tokens": [
   "def",
   "unindent",
   "(",
   "lines",
   ")",
   ":",
   "try",
   ":",
   "# Determine minimum indentation:",
   "indent",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "line",
   ")",
   "-",
   "len",
   "(",
   "line",
   ".",
   "lstrip",
   "(",
   ")",
   ")",
   "for",
   "line",
   "in",
   "lines",
   "if",
   "line",
   ")",
   "except",
   "ValueError",
   ":",
   "return",
   "lines",
   "else",
   ":",
   "return",
   "[",
   "line",
   "[",
   "indent",
   ":",
   "]",
   "for",
   "line",
   "in",
   "lines",
   "]"
  ]
 },
 {
  "idx": "maxmin-229",
  "nl_tokens": [
   "r",
   "Solves",
   "the",
   "objective",
   "function",
   "of",
   "the",
   "Rachford",
   "-",
   "Rice",
   "flash",
   "equation",
   ".",
   "Uses",
   "the",
   "method",
   "proposed",
   "in",
   "[",
   "2",
   "]",
   "_",
   "to",
   "obtain",
   "an",
   "initial",
   "guess",
   "."
  ],
  "pl_tokens": [
   "def",
   "Rachford_Rice_solution",
   "(",
   "zs",
   ",",
   "Ks",
   ")",
   ":",
   "Kmin",
   "=",
   "<mask>",
   "(",
   "Ks",
   ")",
   "Kmax",
   "=",
   "max",
   "(",
   "Ks",
   ")",
   "z_of_Kmax",
   "=",
   "zs",
   "[",
   "Ks",
   ".",
   "index",
   "(",
   "Kmax",
   ")",
   "]",
   "V_over_F_min",
   "=",
   "(",
   "(",
   "Kmax",
   "-",
   "Kmin",
   ")",
   "*",
   "z_of_Kmax",
   "-",
   "(",
   "1.",
   "-",
   "Kmin",
   ")",
   ")",
   "/",
   "(",
   "(",
   "1.",
   "-",
   "Kmin",
   ")",
   "*",
   "(",
   "Kmax",
   "-",
   "1.",
   ")",
   ")",
   "V_over_F_max",
   "=",
   "1.",
   "/",
   "(",
   "1.",
   "-",
   "Kmin",
   ")",
   "V_over_F_min2",
   "=",
   "max",
   "(",
   "0.",
   ",",
   "V_over_F_min",
   ")",
   "V_over_F_max2",
   "=",
   "min",
   "(",
   "1.",
   ",",
   "V_over_F_max",
   ")",
   "x0",
   "=",
   "(",
   "V_over_F_min2",
   "+",
   "V_over_F_max2",
   ")",
   "*",
   "0.5",
   "try",
   ":",
   "# Newton's method is marginally faster than brenth",
   "V_over_F",
   "=",
   "newton",
   "(",
   "Rachford_Rice_flash_error",
   ",",
   "x0",
   "=",
   "x0",
   ",",
   "args",
   "=",
   "(",
   "zs",
   ",",
   "Ks",
   ")",
   ")",
   "# newton skips out of its specified range in some cases, finding another solution",
   "# Check for that with asserts, and use brenth if it did",
   "assert",
   "V_over_F",
   ">=",
   "V_over_F_min2",
   "assert",
   "V_over_F",
   "<=",
   "V_over_F_max2",
   "except",
   ":",
   "V_over_F",
   "=",
   "brenth",
   "(",
   "Rachford_Rice_flash_error",
   ",",
   "V_over_F_max",
   "-",
   "1E-7",
   ",",
   "V_over_F_min",
   "+",
   "1E-7",
   ",",
   "args",
   "=",
   "(",
   "zs",
   ",",
   "Ks",
   ")",
   ")",
   "# Cases not covered by the above solvers: When all components have K > 1, or all have K < 1",
   "# Should get a solution for all other cases.",
   "xs",
   "=",
   "[",
   "zi",
   "/",
   "(",
   "1.",
   "+",
   "V_over_F",
   "*",
   "(",
   "Ki",
   "-",
   "1.",
   ")",
   ")",
   "for",
   "zi",
   ",",
   "Ki",
   "in",
   "zip",
   "(",
   "zs",
   ",",
   "Ks",
   ")",
   "]",
   "ys",
   "=",
   "[",
   "Ki",
   "*",
   "xi",
   "for",
   "xi",
   ",",
   "Ki",
   "in",
   "zip",
   "(",
   "xs",
   ",",
   "Ks",
   ")",
   "]",
   "return",
   "V_over_F",
   ",",
   "xs",
   ",",
   "ys"
  ]
 },
 {
  "idx": "maxmin-230",
  "nl_tokens": [
   "builds",
   "snps",
   "output"
  ],
  "pl_tokens": [
   "def",
   "make",
   "(",
   "data",
   ",",
   "samples",
   ")",
   ":",
   "## get attr ",
   "ploidy",
   "=",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"max_alleles_consens\"",
   "]",
   "names",
   "=",
   "[",
   "i",
   ".",
   "name",
   "for",
   "i",
   "in",
   "samples",
   "]",
   "longname",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "## TODO: use iter cuz of super huge files",
   "inloci",
   "=",
   "open",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".loci\"",
   ")",
   ",",
   "'r'",
   ")",
   ".",
   "read",
   "(",
   ")",
   "## Potential outfiles",
   "snpsout",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".snps\"",
   ")",
   "usnpsout",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".usnps\"",
   ")",
   "structout",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".str\"",
   ")",
   "genoout",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".snps.geno\"",
   ")",
   "ugenoout",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".usnps.geno\"",
   ")",
   "## Output file for writing some stats",
   "statsfile",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".snps.stats\"",
   ")",
   "## The output formats to write",
   "formats",
   "=",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"output_formats\"",
   "]",
   "seed",
   "=",
   "data",
   ".",
   "_hackersonly",
   "[",
   "\"random_seed\"",
   "]",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "int",
   "(",
   "seed",
   ")",
   ")",
   "## output .snps and .unlinked_snps\"",
   "S",
   "=",
   "{",
   "}",
   "## snp dict",
   "Si",
   "=",
   "{",
   "}",
   "## unlinked snp dict",
   "for",
   "name",
   "in",
   "list",
   "(",
   "names",
   ")",
   ":",
   "S",
   "[",
   "name",
   "]",
   "=",
   "[",
   "]",
   "Si",
   "[",
   "name",
   "]",
   "=",
   "[",
   "]",
   "## record bi-allelic snps\"",
   "bis",
   "=",
   "0",
   "## for each locus select out the SNPs\"",
   "for",
   "loc",
   "in",
   "inloci",
   ".",
   "strip",
   "(",
   ")",
   ".",
   "split",
   "(",
   "\"|\"",
   ")",
   "[",
   ":",
   "-",
   "1",
   "]",
   ":",
   "pis",
   "=",
   "\"\"",
   "ns",
   "=",
   "[",
   "]",
   "ss",
   "=",
   "[",
   "]",
   "cov",
   "=",
   "{",
   "}",
   "## record coverage for each SNP",
   "for",
   "line",
   "in",
   "loc",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   ":",
   "if",
   "\">\"",
   "in",
   "line",
   ":",
   "ns",
   ".",
   "append",
   "(",
   "line",
   ".",
   "split",
   "(",
   ")",
   "[",
   "0",
   "]",
   ".",
   "replace",
   "(",
   "\">\"",
   ",",
   "\"\"",
   ")",
   ")",
   "ss",
   ".",
   "append",
   "(",
   "line",
   ".",
   "split",
   "(",
   ")",
   "[",
   "-",
   "1",
   "]",
   ")",
   "else",
   ":",
   "pis",
   "=",
   "[",
   "i",
   "[",
   "0",
   "]",
   "for",
   "i",
   "in",
   "enumerate",
   "(",
   "line",
   ")",
   "if",
   "i",
   "[",
   "1",
   "]",
   "in",
   "list",
   "(",
   "'*-'",
   ")",
   "]",
   "## assign snps to S, and record coverage for usnps\"",
   "for",
   "tax",
   "in",
   "S",
   ":",
   "if",
   "tax",
   "in",
   "ns",
   ":",
   "if",
   "pis",
   ":",
   "for",
   "snpsite",
   "in",
   "pis",
   ":",
   "snpsite",
   "-=",
   "(",
   "longname",
   "+",
   "5",
   ")",
   "S",
   "[",
   "tax",
   "]",
   ".",
   "append",
   "(",
   "ss",
   "[",
   "ns",
   ".",
   "index",
   "(",
   "tax",
   ")",
   "]",
   "[",
   "snpsite",
   "]",
   ")",
   "if",
   "snpsite",
   "not",
   "in",
   "cov",
   ":",
   "cov",
   "[",
   "snpsite",
   "]",
   "=",
   "1",
   "else",
   ":",
   "cov",
   "[",
   "snpsite",
   "]",
   "+=",
   "1",
   "## downweight selection of gap sites \"",
   "if",
   "ss",
   "[",
   "ns",
   ".",
   "index",
   "(",
   "tax",
   ")",
   "]",
   "[",
   "snpsite",
   "]",
   "!=",
   "'-'",
   ":",
   "cov",
   "[",
   "snpsite",
   "]",
   "+=",
   "1",
   "else",
   ":",
   "if",
   "pis",
   ":",
   "for",
   "snpsite",
   "in",
   "pis",
   ":",
   "S",
   "[",
   "tax",
   "]",
   ".",
   "append",
   "(",
   "\"N\"",
   ")",
   "Si",
   "[",
   "tax",
   "]",
   ".",
   "append",
   "(",
   "\"N\"",
   ")",
   "## randomly select among snps w/ greatest coverage for unlinked snp \"",
   "maxlist",
   "=",
   "[",
   "]",
   "for",
   "j",
   ",",
   "k",
   "in",
   "cov",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "k",
   "==",
   "max",
   "(",
   "cov",
   ".",
   "values",
   "(",
   ")",
   ")",
   ":",
   "maxlist",
   ".",
   "append",
   "(",
   "j",
   ")",
   "## Is bi-allelic ? \"",
   "bisnps",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "maxlist",
   ":",
   "if",
   "len",
   "(",
   "set",
   "(",
   "[",
   "ss",
   "[",
   "ns",
   ".",
   "index",
   "(",
   "tax",
   ")",
   "]",
   "[",
   "i",
   "]",
   "for",
   "tax",
   "in",
   "S",
   "if",
   "tax",
   "in",
   "ns",
   "]",
   ")",
   ")",
   "<",
   "3",
   ":",
   "bisnps",
   ".",
   "append",
   "(",
   "i",
   ")",
   "#rando = pis[np.random.randint(len(pis))]",
   "#rando -= (longname+5)",
   "if",
   "bisnps",
   ":",
   "rando",
   "=",
   "bisnps",
   "[",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "len",
   "(",
   "bisnps",
   ")",
   ")",
   "]",
   "elif",
   "maxlist",
   ":",
   "rando",
   "=",
   "maxlist",
   "[",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "len",
   "(",
   "maxlist",
   ")",
   ")",
   "]",
   "tbi",
   "=",
   "0",
   "for",
   "tax",
   "in",
   "S",
   ":",
   "if",
   "tax",
   "in",
   "ns",
   ":",
   "if",
   "pis",
   ":",
   "## if none are bi-allelic \"",
   "if",
   "not",
   "bisnps",
   ":",
   "tbi",
   "+=",
   "1",
   "Si",
   "[",
   "tax",
   "]",
   ".",
   "append",
   "(",
   "ss",
   "[",
   "ns",
   ".",
   "index",
   "(",
   "tax",
   ")",
   "]",
   "[",
   "rando",
   "]",
   ")",
   "if",
   "pis",
   ":",
   "## add spacer between loci \"                ",
   "S",
   "[",
   "tax",
   "]",
   ".",
   "append",
   "(",
   "\" \"",
   ")",
   "else",
   ":",
   "## invariable locus \"",
   "S",
   "[",
   "tax",
   "]",
   ".",
   "append",
   "(",
   "\"_ \"",
   ")",
   "bis",
   "+=",
   "tbi",
   "## names",
   "SF",
   "=",
   "list",
   "(",
   "S",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "SF",
   ".",
   "sort",
   "(",
   ")",
   "## Write linked snps format",
   "if",
   "\"snps\"",
   "in",
   "formats",
   ":",
   "with",
   "open",
   "(",
   "snpsout",
   ",",
   "'w'",
   ")",
   "as",
   "outfile",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "\"## %s taxa, %s loci, %s snps\"",
   "%",
   "(",
   "len",
   "(",
   "S",
   ")",
   ",",
   "len",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "S",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ".",
   "split",
   "(",
   "\" \"",
   ")",
   ")",
   "-",
   "1",
   ",",
   "len",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "S",
   "[",
   "SF",
   "[",
   "0",
   "]",
   "]",
   ")",
   ".",
   "replace",
   "(",
   "\" \"",
   ",",
   "\"\"",
   ")",
   ")",
   ")",
   "for",
   "i",
   "in",
   "SF",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "i",
   "+",
   "(",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "i",
   ")",
   "+",
   "3",
   ")",
   ")",
   "+",
   "\"\"",
   ".",
   "join",
   "(",
   "S",
   "[",
   "i",
   "]",
   ")",
   "## Write unlinked snps format",
   "if",
   "\"usnps\"",
   "in",
   "formats",
   ":",
   "with",
   "open",
   "(",
   "usnpsout",
   ",",
   "'w'",
   ")",
   "as",
   "outfile",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "len",
   "(",
   "Si",
   ")",
   ",",
   "len",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "Si",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ")",
   "for",
   "i",
   "in",
   "SF",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "i",
   "+",
   "(",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "i",
   ")",
   "+",
   "3",
   ")",
   ")",
   "+",
   "\"\"",
   ".",
   "join",
   "(",
   "Si",
   "[",
   "i",
   "]",
   ")",
   "with",
   "open",
   "(",
   "statsfile",
   ",",
   "'a'",
   ")",
   "as",
   "statsout",
   ":",
   "print",
   ">>",
   "statsout",
   ",",
   "\"sampled unlinked SNPs=\"",
   ",",
   "len",
   "(",
   "Si",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   "print",
   ">>",
   "statsout",
   ",",
   "\"sampled unlinked bi-allelic SNPs=\"",
   ",",
   "len",
   "(",
   "Si",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   "-",
   "bis",
   "## Write STRUCTURE format",
   "if",
   "\"str\"",
   "in",
   "formats",
   ":",
   "with",
   "open",
   "(",
   "structout",
   ",",
   "'w'",
   ")",
   "as",
   "outfile",
   ":",
   "B",
   "=",
   "{",
   "'A'",
   ":",
   "'0'",
   ",",
   "'T'",
   ":",
   "'1'",
   ",",
   "'G'",
   ":",
   "'2'",
   ",",
   "'C'",
   ":",
   "'3'",
   ",",
   "'N'",
   ":",
   "'-9'",
   ",",
   "'-'",
   ":",
   "'-9'",
   "}",
   "if",
   "ploidy",
   ">",
   "1",
   ":",
   "for",
   "line",
   "in",
   "SF",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "line",
   "+",
   "(",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "line",
   ")",
   "+",
   "3",
   ")",
   ")",
   "+",
   "\"\\t\"",
   "*",
   "6",
   "+",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "B",
   "[",
   "unstruct",
   "(",
   "j",
   ")",
   "[",
   "0",
   "]",
   "]",
   "for",
   "j",
   "in",
   "Si",
   "[",
   "line",
   "]",
   "]",
   ")",
   "print",
   ">>",
   "outfile",
   ",",
   "line",
   "+",
   "(",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "line",
   ")",
   "+",
   "3",
   ")",
   ")",
   "+",
   "\"\\t\"",
   "*",
   "6",
   "+",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "B",
   "[",
   "unstruct",
   "(",
   "j",
   ")",
   "[",
   "1",
   "]",
   "]",
   "for",
   "j",
   "in",
   "Si",
   "[",
   "line",
   "]",
   "]",
   ")",
   "else",
   ":",
   "for",
   "line",
   "in",
   "SF",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "line",
   "+",
   "(",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "line",
   ")",
   "+",
   "3",
   ")",
   ")",
   "+",
   "\"\\t\"",
   "*",
   "6",
   "+",
   "\"\\t\"",
   ".",
   "join",
   "(",
   "[",
   "B",
   "[",
   "unstruct",
   "(",
   "j",
   ")",
   "[",
   "1",
   "]",
   "]",
   "for",
   "j",
   "in",
   "Si",
   "[",
   "line",
   "]",
   "]",
   ")",
   "## Do linked and unlinked snps in .geno format",
   "if",
   "\"geno\"",
   "in",
   "formats",
   ":",
   "with",
   "open",
   "(",
   "ugenoout",
   ",",
   "'w'",
   ")",
   "as",
   "outfile",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "Si",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ")",
   ":",
   "getref",
   "=",
   "0",
   "ref",
   "=",
   "\"N\"",
   "while",
   "ref",
   "==",
   "\"N\"",
   ":",
   "ref",
   "=",
   "unstruct",
   "(",
   "Si",
   "[",
   "SF",
   "[",
   "getref",
   "]",
   "]",
   "[",
   "i",
   "]",
   ")",
   "[",
   "0",
   "]",
   "getref",
   "+=",
   "1",
   "SNProw",
   "=",
   "\"\"",
   ".",
   "join",
   "(",
   "map",
   "(",
   "str",
   ",",
   "[",
   "unstruct",
   "(",
   "Si",
   "[",
   "j",
   "]",
   "[",
   "i",
   "]",
   ")",
   ".",
   "count",
   "(",
   "ref",
   ")",
   "if",
   "Si",
   "[",
   "j",
   "]",
   "[",
   "i",
   "]",
   "!=",
   "\"N\"",
   "else",
   "\"9\"",
   "for",
   "j",
   "in",
   "SF",
   "]",
   ")",
   ")",
   "## print ref,SNProw",
   "if",
   "len",
   "(",
   "set",
   "(",
   "SNProw",
   ")",
   ")",
   ">",
   "1",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "SNProw",
   "with",
   "open",
   "(",
   "genoout",
   ",",
   "'w'",
   ")",
   "as",
   "outfile",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "S",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ")",
   ":",
   "if",
   "S",
   "[",
   "SF",
   "[",
   "0",
   "]",
   "]",
   "[",
   "i",
   "]",
   ".",
   "strip",
   "(",
   "\"_\"",
   ")",
   ".",
   "strip",
   "(",
   ")",
   ":",
   "getref",
   "=",
   "0",
   "ref",
   "=",
   "\"N\"",
   "while",
   "ref",
   "==",
   "\"N\"",
   ":",
   "#print i, S[SF[0]][i]",
   "ref",
   "=",
   "unstruct",
   "(",
   "S",
   "[",
   "SF",
   "[",
   "getref",
   "]",
   "]",
   "[",
   "i",
   "]",
   ")",
   "[",
   "0",
   "]",
   "getref",
   "+=",
   "1",
   "SNProw",
   "=",
   "\"\"",
   ".",
   "join",
   "(",
   "map",
   "(",
   "str",
   ",",
   "[",
   "unstruct",
   "(",
   "S",
   "[",
   "j",
   "]",
   "[",
   "i",
   "]",
   ")",
   ".",
   "count",
   "(",
   "ref",
   ")",
   "if",
   "S",
   "[",
   "j",
   "]",
   "[",
   "i",
   "]",
   "!=",
   "\"N\"",
   "else",
   "\"9\"",
   "for",
   "j",
   "in",
   "SF",
   "]",
   ")",
   ")",
   "## print ref,SNProw",
   "if",
   "len",
   "(",
   "set",
   "(",
   "SNProw",
   ")",
   ")",
   ">",
   "1",
   ":",
   "print",
   ">>",
   "outfile",
   ",",
   "SNProw"
  ]
 },
 {
  "idx": "maxmin-231",
  "nl_tokens": [
   "Generates",
   "length",
   "based",
   "features",
   "from",
   "an",
   "essay",
   "set",
   "Generally",
   "an",
   "internal",
   "function",
   "called",
   "by",
   "gen_feats",
   "Returns",
   "an",
   "array",
   "of",
   "length",
   "features",
   "e_set",
   "-",
   "EssaySet",
   "object"
  ],
  "pl_tokens": [
   "def",
   "gen_length_feats",
   "(",
   "self",
   ",",
   "e_set",
   ")",
   ":",
   "text",
   "=",
   "e_set",
   ".",
   "_text",
   "lengths",
   "=",
   "[",
   "len",
   "(",
   "e",
   ")",
   "for",
   "e",
   "in",
   "text",
   "]",
   "word_counts",
   "=",
   "[",
   "<mask>",
   "(",
   "len",
   "(",
   "t",
   ")",
   ",",
   "1",
   ")",
   "for",
   "t",
   "in",
   "e_set",
   ".",
   "_tokens",
   "]",
   "comma_count",
   "=",
   "[",
   "e",
   ".",
   "count",
   "(",
   "\",\"",
   ")",
   "for",
   "e",
   "in",
   "text",
   "]",
   "ap_count",
   "=",
   "[",
   "e",
   ".",
   "count",
   "(",
   "\"'\"",
   ")",
   "for",
   "e",
   "in",
   "text",
   "]",
   "punc_count",
   "=",
   "[",
   "e",
   ".",
   "count",
   "(",
   "\".\"",
   ")",
   "+",
   "e",
   ".",
   "count",
   "(",
   "\"?\"",
   ")",
   "+",
   "e",
   ".",
   "count",
   "(",
   "\"!\"",
   ")",
   "for",
   "e",
   "in",
   "text",
   "]",
   "chars_per_word",
   "=",
   "[",
   "lengths",
   "[",
   "m",
   "]",
   "/",
   "float",
   "(",
   "word_counts",
   "[",
   "m",
   "]",
   ")",
   "for",
   "m",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "text",
   ")",
   ")",
   "]",
   "good_pos_tags",
   ",",
   "bad_pos_positions",
   "=",
   "self",
   ".",
   "_get_grammar_errors",
   "(",
   "e_set",
   ".",
   "_pos",
   ",",
   "e_set",
   ".",
   "_text",
   ",",
   "e_set",
   ".",
   "_tokens",
   ")",
   "good_pos_tag_prop",
   "=",
   "[",
   "good_pos_tags",
   "[",
   "m",
   "]",
   "/",
   "float",
   "(",
   "word_counts",
   "[",
   "m",
   "]",
   ")",
   "for",
   "m",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "text",
   ")",
   ")",
   "]",
   "length_arr",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "(",
   "lengths",
   ",",
   "word_counts",
   ",",
   "comma_count",
   ",",
   "ap_count",
   ",",
   "punc_count",
   ",",
   "chars_per_word",
   ",",
   "good_pos_tags",
   ",",
   "good_pos_tag_prop",
   ")",
   ")",
   ".",
   "transpose",
   "(",
   ")",
   "return",
   "length_arr",
   ".",
   "copy",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-232",
  "nl_tokens": [
   "This",
   "calculates",
   "a",
   "frequency",
   "grid",
   "for",
   "the",
   "period",
   "finding",
   "functions",
   "in",
   "this",
   "module",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_frequency_grid",
   "(",
   "times",
   ",",
   "samplesperpeak",
   "=",
   "5",
   ",",
   "nyquistfactor",
   "=",
   "5",
   ",",
   "minfreq",
   "=",
   "None",
   ",",
   "maxfreq",
   "=",
   "None",
   ",",
   "returnf0dfnf",
   "=",
   "False",
   ")",
   ":",
   "baseline",
   "=",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "times",
   ".",
   "min",
   "(",
   ")",
   "nsamples",
   "=",
   "times",
   ".",
   "size",
   "df",
   "=",
   "1.",
   "/",
   "baseline",
   "/",
   "samplesperpeak",
   "if",
   "minfreq",
   "is",
   "not",
   "None",
   ":",
   "f0",
   "=",
   "minfreq",
   "else",
   ":",
   "f0",
   "=",
   "0.5",
   "*",
   "df",
   "if",
   "maxfreq",
   "is",
   "not",
   "None",
   ":",
   "Nf",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "f0",
   ")",
   "/",
   "df",
   ")",
   ")",
   "else",
   ":",
   "Nf",
   "=",
   "int",
   "(",
   "0.5",
   "*",
   "samplesperpeak",
   "*",
   "nyquistfactor",
   "*",
   "nsamples",
   ")",
   "if",
   "returnf0dfnf",
   ":",
   "return",
   "f0",
   ",",
   "df",
   ",",
   "Nf",
   ",",
   "f0",
   "+",
   "df",
   "*",
   "nparange",
   "(",
   "Nf",
   ")",
   "else",
   ":",
   "return",
   "f0",
   "+",
   "df",
   "*",
   "nparange",
   "(",
   "Nf",
   ")"
  ]
 },
 {
  "idx": "maxmin-233",
  "nl_tokens": [
   "Add",
   "a",
   "mixed",
   "-",
   "integer",
   "version",
   "of",
   "a",
   "minimal",
   "medium",
   "to",
   "the",
   "model",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_mip_obj",
   "(",
   "model",
   ")",
   ":",
   "if",
   "len",
   "(",
   "model",
   ".",
   "variables",
   ")",
   ">",
   "1e4",
   ":",
   "LOGGER",
   ".",
   "warning",
   "(",
   "\"the MIP version of minimal media is extremely slow for\"",
   "\" models that large :(\"",
   ")",
   "exchange_rxns",
   "=",
   "find_boundary_types",
   "(",
   "model",
   ",",
   "\"exchange\"",
   ")",
   "big_m",
   "=",
   "<mask>",
   "(",
   "abs",
   "(",
   "b",
   ")",
   "for",
   "r",
   "in",
   "exchange_rxns",
   "for",
   "b",
   "in",
   "r",
   ".",
   "bounds",
   ")",
   "prob",
   "=",
   "model",
   ".",
   "problem",
   "coefs",
   "=",
   "{",
   "}",
   "to_add",
   "=",
   "[",
   "]",
   "for",
   "rxn",
   "in",
   "exchange_rxns",
   ":",
   "export",
   "=",
   "len",
   "(",
   "rxn",
   ".",
   "reactants",
   ")",
   "==",
   "1",
   "indicator",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "\"ind_\"",
   "+",
   "rxn",
   ".",
   "id",
   ",",
   "lb",
   "=",
   "0",
   ",",
   "ub",
   "=",
   "1",
   ",",
   "type",
   "=",
   "\"binary\"",
   ")",
   "if",
   "export",
   ":",
   "vrv",
   "=",
   "rxn",
   ".",
   "reverse_variable",
   "indicator_const",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "vrv",
   "-",
   "indicator",
   "*",
   "big_m",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "\"ind_constraint_\"",
   "+",
   "rxn",
   ".",
   "id",
   ")",
   "else",
   ":",
   "vfw",
   "=",
   "rxn",
   ".",
   "forward_variable",
   "indicator_const",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "vfw",
   "-",
   "indicator",
   "*",
   "big_m",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "\"ind_constraint_\"",
   "+",
   "rxn",
   ".",
   "id",
   ")",
   "to_add",
   ".",
   "extend",
   "(",
   "[",
   "indicator",
   ",",
   "indicator_const",
   "]",
   ")",
   "coefs",
   "[",
   "indicator",
   "]",
   "=",
   "1",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "to_add",
   ")",
   "model",
   ".",
   "solver",
   ".",
   "update",
   "(",
   ")",
   "model",
   ".",
   "objective",
   ".",
   "set_linear_coefficients",
   "(",
   "coefs",
   ")",
   "model",
   ".",
   "objective",
   ".",
   "direction",
   "=",
   "\"min\""
  ]
 },
 {
  "idx": "maxmin-234",
  "nl_tokens": [
   "Calculates",
   "the",
   "cross",
   "-",
   "entropy",
   "."
  ],
  "pl_tokens": [
   "def",
   "crossentropy",
   "(",
   "label",
   ",",
   "logits",
   ")",
   ":",
   "assert",
   "logits",
   ".",
   "ndim",
   "==",
   "1",
   "# for numerical reasons we subtract the max logit",
   "# (mathematically it doesn't matter!)",
   "# otherwise exp(logits) might become too large or too small",
   "logits",
   "=",
   "logits",
   "-",
   "np",
   ".",
   "<mask>",
   "(",
   "logits",
   ")",
   "e",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "logits",
   ")",
   "s",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "e",
   ")",
   "ce",
   "=",
   "np",
   ".",
   "log",
   "(",
   "s",
   ")",
   "-",
   "logits",
   "[",
   "label",
   "]",
   "return",
   "ce"
  ]
 },
 {
  "idx": "maxmin-235",
  "nl_tokens": [
   "signature",
   "..."
  ],
  "pl_tokens": [
   "def",
   "baba_panel_plot",
   "(",
   "ttree",
   ",",
   "tests",
   ",",
   "boots",
   ",",
   "show_tip_labels",
   "=",
   "True",
   ",",
   "show_test_labels",
   "=",
   "True",
   ",",
   "use_edge_lengths",
   "=",
   "False",
   ",",
   "collapse_outgroup",
   "=",
   "False",
   ",",
   "pct_tree_x",
   "=",
   "0.4",
   ",",
   "pct_tree_y",
   "=",
   "0.2",
   ",",
   "alpha",
   "=",
   "3.0",
   ",",
   "*",
   "args",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "## create Panel plot object and set height & width",
   "bootsarr",
   "=",
   "np",
   ".",
   "array",
   "(",
   "boots",
   ")",
   "panel",
   "=",
   "Panel",
   "(",
   "ttree",
   ",",
   "tests",
   ",",
   "bootsarr",
   ",",
   "alpha",
   ")",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"width\"",
   ")",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"width\"",
   "]",
   "=",
   "<mask>",
   "(",
   "1000",
   ",",
   "50",
   "*",
   "len",
   "(",
   "panel",
   ".",
   "tree",
   ")",
   ")",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"height\"",
   ")",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"height\"",
   "]",
   "=",
   "min",
   "(",
   "1000",
   ",",
   "50",
   "*",
   "len",
   "(",
   "panel",
   ".",
   "tests",
   ")",
   ")",
   "## update defaults with kwargs & update size based on ntips & ntests",
   "kwargs",
   ".",
   "update",
   "(",
   "dict",
   "(",
   "pct_tree_x",
   "=",
   "pct_tree_x",
   ",",
   "pct_tree_y",
   "=",
   "pct_tree_y",
   ")",
   ")",
   "panel",
   ".",
   "kwargs",
   ".",
   "update",
   "(",
   "kwargs",
   ")",
   "## create a canvas and a single cartesian coord system",
   "canvas",
   "=",
   "toyplot",
   ".",
   "Canvas",
   "(",
   "height",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "'height'",
   "]",
   ",",
   "width",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "'width'",
   "]",
   ")",
   "axes",
   "=",
   "canvas",
   ".",
   "cartesian",
   "(",
   "bounds",
   "=",
   "(",
   "\"10%\"",
   ",",
   "\"90%\"",
   ",",
   "\"5%\"",
   ",",
   "\"95%\"",
   ")",
   ")",
   "axes",
   ".",
   "show",
   "=",
   "False",
   "## add panels to axes",
   "panel",
   ".",
   "panel_tree",
   "(",
   "axes",
   ")",
   "panel",
   ".",
   "panel_test",
   "(",
   "axes",
   ")",
   "panel",
   ".",
   "panel_tip_labels",
   "(",
   "axes",
   ")",
   "if",
   "isinstance",
   "(",
   "boots",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "panel",
   ".",
   "panel_results",
   "(",
   "axes",
   ")",
   "return",
   "canvas",
   ",",
   "axes",
   ",",
   "panel"
  ]
 },
 {
  "idx": "maxmin-236",
  "nl_tokens": [
   "pretty",
   "print",
   "for",
   "confusion",
   "matrixes"
  ],
  "pl_tokens": [
   "def",
   "print_cm",
   "(",
   "cm",
   ",",
   "labels",
   ",",
   "hide_zeroes",
   "=",
   "False",
   ",",
   "hide_diagonal",
   "=",
   "False",
   ",",
   "hide_threshold",
   "=",
   "None",
   ")",
   ":",
   "columnwidth",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "labels",
   "]",
   "+",
   "[",
   "5",
   "]",
   ")",
   "# 5 is value length",
   "empty_cell",
   "=",
   "\" \"",
   "*",
   "columnwidth",
   "# Print header",
   "print",
   "(",
   "\"    \"",
   "+",
   "empty_cell",
   ",",
   "end",
   "=",
   "\" \"",
   ")",
   "for",
   "label",
   "in",
   "labels",
   ":",
   "print",
   "(",
   "\"%{0}s\"",
   ".",
   "format",
   "(",
   "columnwidth",
   ")",
   "%",
   "label",
   ",",
   "end",
   "=",
   "\" \"",
   ")",
   "print",
   "(",
   ")",
   "# Print rows",
   "for",
   "i",
   ",",
   "label1",
   "in",
   "enumerate",
   "(",
   "labels",
   ")",
   ":",
   "print",
   "(",
   "\"    %{0}s\"",
   ".",
   "format",
   "(",
   "columnwidth",
   ")",
   "%",
   "label1",
   ",",
   "end",
   "=",
   "\" \"",
   ")",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "labels",
   ")",
   ")",
   ":",
   "cell",
   "=",
   "\"%{0}.1f\"",
   ".",
   "format",
   "(",
   "columnwidth",
   ")",
   "%",
   "cm",
   "[",
   "i",
   ",",
   "j",
   "]",
   "if",
   "hide_zeroes",
   ":",
   "cell",
   "=",
   "cell",
   "if",
   "float",
   "(",
   "cm",
   "[",
   "i",
   ",",
   "j",
   "]",
   ")",
   "!=",
   "0",
   "else",
   "empty_cell",
   "if",
   "hide_diagonal",
   ":",
   "cell",
   "=",
   "cell",
   "if",
   "i",
   "!=",
   "j",
   "else",
   "empty_cell",
   "if",
   "hide_threshold",
   ":",
   "cell",
   "=",
   "cell",
   "if",
   "cm",
   "[",
   "i",
   ",",
   "j",
   "]",
   ">",
   "hide_threshold",
   "else",
   "empty_cell",
   "print",
   "(",
   "cell",
   ",",
   "end",
   "=",
   "\" \"",
   ")",
   "print",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-237",
  "nl_tokens": [
   "Return",
   "the",
   "Metaphone",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "-",
   "1",
   ")",
   ":",
   "# Require a max_length of at least 4",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "4",
   ",",
   "max_length",
   ")",
   "else",
   ":",
   "max_length",
   "=",
   "64",
   "# As in variable sound--those modified by adding an \"h\"",
   "ename",
   "=",
   "''",
   ".",
   "join",
   "(",
   "c",
   "for",
   "c",
   "in",
   "word",
   ".",
   "upper",
   "(",
   ")",
   "if",
   "c",
   ".",
   "isalnum",
   "(",
   ")",
   ")",
   "ename",
   "=",
   "ename",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "# Delete non-alphanumeric characters and make all caps",
   "if",
   "not",
   "ename",
   ":",
   "return",
   "''",
   "if",
   "ename",
   "[",
   "0",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'PN'",
   ",",
   "'AE'",
   ",",
   "'KN'",
   ",",
   "'GN'",
   ",",
   "'WR'",
   "}",
   ":",
   "ename",
   "=",
   "ename",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "ename",
   "[",
   "0",
   "]",
   "==",
   "'X'",
   ":",
   "ename",
   "=",
   "'S'",
   "+",
   "ename",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "ename",
   "[",
   "0",
   ":",
   "2",
   "]",
   "==",
   "'WH'",
   ":",
   "ename",
   "=",
   "'W'",
   "+",
   "ename",
   "[",
   "2",
   ":",
   "]",
   "# Convert to metaphone",
   "elen",
   "=",
   "len",
   "(",
   "ename",
   ")",
   "-",
   "1",
   "metaph",
   "=",
   "''",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "ename",
   ")",
   ")",
   ":",
   "if",
   "len",
   "(",
   "metaph",
   ")",
   ">=",
   "max_length",
   ":",
   "break",
   "if",
   "(",
   "ename",
   "[",
   "i",
   "]",
   "not",
   "in",
   "{",
   "'G'",
   ",",
   "'T'",
   "}",
   "and",
   "i",
   ">",
   "0",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "ename",
   "[",
   "i",
   "]",
   ")",
   ":",
   "continue",
   "if",
   "ename",
   "[",
   "i",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   "and",
   "i",
   "==",
   "0",
   ":",
   "metaph",
   "=",
   "ename",
   "[",
   "i",
   "]",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'B'",
   ":",
   "if",
   "i",
   "!=",
   "elen",
   "or",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "!=",
   "'M'",
   ":",
   "metaph",
   "+=",
   "ename",
   "[",
   "i",
   "]",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'C'",
   ":",
   "if",
   "not",
   "(",
   "i",
   ">",
   "0",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "'S'",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_frontv",
   ")",
   ":",
   "if",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "3",
   "]",
   "==",
   "'IA'",
   ":",
   "metaph",
   "+=",
   "'X'",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_frontv",
   ":",
   "metaph",
   "+=",
   "'S'",
   "elif",
   "i",
   ">",
   "0",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'SCH'",
   ":",
   "metaph",
   "+=",
   "'K'",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'H'",
   ":",
   "if",
   "(",
   "i",
   "==",
   "0",
   "and",
   "i",
   "+",
   "1",
   "<",
   "elen",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "2",
   ":",
   "i",
   "+",
   "3",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ")",
   ":",
   "metaph",
   "+=",
   "'K'",
   "else",
   ":",
   "metaph",
   "+=",
   "'X'",
   "else",
   ":",
   "metaph",
   "+=",
   "'K'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'D'",
   ":",
   "if",
   "(",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'G'",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "2",
   ":",
   "i",
   "+",
   "3",
   "]",
   "in",
   "self",
   ".",
   "_frontv",
   ")",
   ":",
   "metaph",
   "+=",
   "'J'",
   "else",
   ":",
   "metaph",
   "+=",
   "'T'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'G'",
   ":",
   "if",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'H'",
   "and",
   "not",
   "(",
   "i",
   "+",
   "1",
   "==",
   "elen",
   "or",
   "ename",
   "[",
   "i",
   "+",
   "2",
   ":",
   "i",
   "+",
   "3",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ")",
   ":",
   "continue",
   "elif",
   "i",
   ">",
   "0",
   "and",
   "(",
   "(",
   "i",
   "+",
   "1",
   "==",
   "elen",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   "]",
   "==",
   "'N'",
   ")",
   "or",
   "(",
   "i",
   "+",
   "3",
   "==",
   "elen",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "4",
   "]",
   "==",
   "'NED'",
   ")",
   ")",
   ":",
   "continue",
   "elif",
   "(",
   "i",
   "-",
   "1",
   ">",
   "0",
   "and",
   "i",
   "+",
   "1",
   "<=",
   "elen",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "'D'",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_frontv",
   ")",
   ":",
   "continue",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'G'",
   ":",
   "continue",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_frontv",
   ":",
   "if",
   "i",
   "==",
   "0",
   "or",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "!=",
   "'G'",
   ":",
   "metaph",
   "+=",
   "'J'",
   "else",
   ":",
   "metaph",
   "+=",
   "'K'",
   "else",
   ":",
   "metaph",
   "+=",
   "'K'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'H'",
   ":",
   "if",
   "(",
   "i",
   ">",
   "0",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ")",
   ":",
   "continue",
   "elif",
   "i",
   ">",
   "0",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_varson",
   ":",
   "continue",
   "else",
   ":",
   "metaph",
   "+=",
   "'H'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "in",
   "{",
   "'F'",
   ",",
   "'J'",
   ",",
   "'L'",
   ",",
   "'M'",
   ",",
   "'N'",
   ",",
   "'R'",
   "}",
   ":",
   "metaph",
   "+=",
   "ename",
   "[",
   "i",
   "]",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'K'",
   ":",
   "if",
   "i",
   ">",
   "0",
   "and",
   "ename",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "'C'",
   ":",
   "continue",
   "else",
   ":",
   "metaph",
   "+=",
   "'K'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'P'",
   ":",
   "if",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'H'",
   ":",
   "metaph",
   "+=",
   "'F'",
   "else",
   ":",
   "metaph",
   "+=",
   "'P'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'Q'",
   ":",
   "metaph",
   "+=",
   "'K'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'S'",
   ":",
   "if",
   "(",
   "i",
   ">",
   "0",
   "and",
   "i",
   "+",
   "2",
   "<=",
   "elen",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   "]",
   "==",
   "'I'",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "2",
   "]",
   "in",
   "'OA'",
   ")",
   ":",
   "metaph",
   "+=",
   "'X'",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'H'",
   ":",
   "metaph",
   "+=",
   "'X'",
   "else",
   ":",
   "metaph",
   "+=",
   "'S'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'T'",
   ":",
   "if",
   "(",
   "i",
   ">",
   "0",
   "and",
   "i",
   "+",
   "2",
   "<=",
   "elen",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "1",
   "]",
   "==",
   "'I'",
   "and",
   "ename",
   "[",
   "i",
   "+",
   "2",
   "]",
   "in",
   "{",
   "'A'",
   ",",
   "'O'",
   "}",
   ")",
   ":",
   "metaph",
   "+=",
   "'X'",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "==",
   "'H'",
   ":",
   "metaph",
   "+=",
   "'0'",
   "elif",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "3",
   "]",
   "!=",
   "'CH'",
   ":",
   "if",
   "ename",
   "[",
   "i",
   "-",
   "1",
   ":",
   "i",
   "]",
   "!=",
   "'T'",
   ":",
   "metaph",
   "+=",
   "'T'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'V'",
   ":",
   "metaph",
   "+=",
   "'F'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "in",
   "'WY'",
   ":",
   "if",
   "ename",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ":",
   "metaph",
   "+=",
   "ename",
   "[",
   "i",
   "]",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'X'",
   ":",
   "metaph",
   "+=",
   "'KS'",
   "elif",
   "ename",
   "[",
   "i",
   "]",
   "==",
   "'Z'",
   ":",
   "metaph",
   "+=",
   "'S'",
   "return",
   "metaph"
  ]
 },
 {
  "idx": "maxmin-238",
  "nl_tokens": [
   "Figure",
   "of",
   "merit",
   "in",
   "time"
  ],
  "pl_tokens": [
   "def",
   "fmt",
   "(",
   "a",
   ",",
   "b",
   ")",
   ":",
   "return",
   "100",
   "*",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "a",
   ",",
   "b",
   "]",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ".",
   "sum",
   "(",
   ")",
   "/",
   "np",
   ".",
   "max",
   "(",
   "[",
   "a",
   ",",
   "b",
   "]",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ".",
   "sum",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-239",
  "nl_tokens": [
   "Train",
   "the",
   "classifier",
   "to",
   "associate",
   "specified",
   "input",
   "pattern",
   "with",
   "a",
   "particular",
   "category",
   "."
  ],
  "pl_tokens": [
   "def",
   "learn",
   "(",
   "self",
   ",",
   "inputPattern",
   ",",
   "inputCategory",
   ",",
   "partitionId",
   "=",
   "None",
   ",",
   "isSparse",
   "=",
   "0",
   ",",
   "rowID",
   "=",
   "None",
   ")",
   ":",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "1",
   ":",
   "print",
   "\"%s learn:\"",
   "%",
   "g_debugPrefix",
   "print",
   "\"  category:\"",
   ",",
   "int",
   "(",
   "inputCategory",
   ")",
   "print",
   "\"  active inputs:\"",
   ",",
   "_labeledInput",
   "(",
   "inputPattern",
   ",",
   "cellsPerCol",
   "=",
   "self",
   ".",
   "cellsPerCol",
   ")",
   "if",
   "isSparse",
   ">",
   "0",
   ":",
   "assert",
   "all",
   "(",
   "inputPattern",
   "[",
   "i",
   "]",
   "<=",
   "inputPattern",
   "[",
   "i",
   "+",
   "1",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "inputPattern",
   ")",
   "-",
   "1",
   ")",
   ")",
   ",",
   "\"Sparse inputPattern must be sorted.\"",
   "assert",
   "all",
   "(",
   "bit",
   "<",
   "isSparse",
   "for",
   "bit",
   "in",
   "inputPattern",
   ")",
   ",",
   "(",
   "\"Sparse inputPattern must not index outside the dense \"",
   "\"representation's bounds.\"",
   ")",
   "if",
   "rowID",
   "is",
   "None",
   ":",
   "rowID",
   "=",
   "self",
   ".",
   "_iterationIdx",
   "# Dense vectors",
   "if",
   "not",
   "self",
   ".",
   "useSparseMemory",
   ":",
   "# Not supported",
   "assert",
   "self",
   ".",
   "cellsPerCol",
   "==",
   "0",
   ",",
   "\"not implemented for dense vectors\"",
   "# If the input was given in sparse form, convert it to dense",
   "if",
   "isSparse",
   ">",
   "0",
   ":",
   "denseInput",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "isSparse",
   ")",
   "denseInput",
   "[",
   "inputPattern",
   "]",
   "=",
   "1.0",
   "inputPattern",
   "=",
   "denseInput",
   "if",
   "self",
   ".",
   "_specificIndexTraining",
   "and",
   "not",
   "self",
   ".",
   "_nextTrainingIndices",
   ":",
   "# Specific index mode without any index provided - skip training",
   "return",
   "self",
   ".",
   "_numPatterns",
   "if",
   "self",
   ".",
   "_Memory",
   "is",
   "None",
   ":",
   "# Initialize memory with 100 rows and numPatterns = 0",
   "inputWidth",
   "=",
   "len",
   "(",
   "inputPattern",
   ")",
   "self",
   ".",
   "_Memory",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "100",
   ",",
   "inputWidth",
   ")",
   ")",
   "self",
   ".",
   "_numPatterns",
   "=",
   "0",
   "self",
   ".",
   "_M",
   "=",
   "self",
   ".",
   "_Memory",
   "[",
   ":",
   "self",
   ".",
   "_numPatterns",
   "]",
   "addRow",
   "=",
   "True",
   "if",
   "self",
   ".",
   "_vt",
   "is",
   "not",
   "None",
   ":",
   "# Compute projection",
   "inputPattern",
   "=",
   "numpy",
   ".",
   "dot",
   "(",
   "self",
   ".",
   "_vt",
   ",",
   "inputPattern",
   "-",
   "self",
   ".",
   "_mean",
   ")",
   "if",
   "self",
   ".",
   "distThreshold",
   ">",
   "0",
   ":",
   "# Check if input is too close to an existing input to be accepted",
   "dist",
   "=",
   "self",
   ".",
   "_calcDistance",
   "(",
   "inputPattern",
   ")",
   "minDist",
   "=",
   "dist",
   ".",
   "<mask>",
   "(",
   ")",
   "addRow",
   "=",
   "(",
   "minDist",
   ">=",
   "self",
   ".",
   "distThreshold",
   ")",
   "if",
   "addRow",
   ":",
   "self",
   ".",
   "_protoSizes",
   "=",
   "None",
   "# need to re-compute",
   "if",
   "self",
   ".",
   "_numPatterns",
   "==",
   "self",
   ".",
   "_Memory",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   "# Double the size of the memory",
   "self",
   ".",
   "_doubleMemoryNumRows",
   "(",
   ")",
   "if",
   "not",
   "self",
   ".",
   "_specificIndexTraining",
   ":",
   "# Normal learning - append the new input vector",
   "self",
   ".",
   "_Memory",
   "[",
   "self",
   ".",
   "_numPatterns",
   "]",
   "=",
   "inputPattern",
   "self",
   ".",
   "_numPatterns",
   "+=",
   "1",
   "self",
   ".",
   "_categoryList",
   ".",
   "append",
   "(",
   "int",
   "(",
   "inputCategory",
   ")",
   ")",
   "else",
   ":",
   "# Specific index training mode - insert vector in specified slot",
   "vectorIndex",
   "=",
   "self",
   ".",
   "_nextTrainingIndices",
   ".",
   "pop",
   "(",
   "0",
   ")",
   "while",
   "vectorIndex",
   ">=",
   "self",
   ".",
   "_Memory",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   "self",
   ".",
   "_doubleMemoryNumRows",
   "(",
   ")",
   "self",
   ".",
   "_Memory",
   "[",
   "vectorIndex",
   "]",
   "=",
   "inputPattern",
   "self",
   ".",
   "_numPatterns",
   "=",
   "max",
   "(",
   "self",
   ".",
   "_numPatterns",
   ",",
   "vectorIndex",
   "+",
   "1",
   ")",
   "if",
   "vectorIndex",
   ">=",
   "len",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   ":",
   "self",
   ".",
   "_categoryList",
   "+=",
   "[",
   "-",
   "1",
   "]",
   "*",
   "(",
   "vectorIndex",
   "-",
   "len",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   "+",
   "1",
   ")",
   "self",
   ".",
   "_categoryList",
   "[",
   "vectorIndex",
   "]",
   "=",
   "int",
   "(",
   "inputCategory",
   ")",
   "# Set _M to the \"active\" part of _Memory",
   "self",
   ".",
   "_M",
   "=",
   "self",
   ".",
   "_Memory",
   "[",
   "0",
   ":",
   "self",
   ".",
   "_numPatterns",
   "]",
   "self",
   ".",
   "_addPartitionId",
   "(",
   "self",
   ".",
   "_numPatterns",
   "-",
   "1",
   ",",
   "partitionId",
   ")",
   "# Sparse vectors",
   "else",
   ":",
   "# If the input was given in sparse form, convert it to dense if necessary",
   "if",
   "isSparse",
   ">",
   "0",
   "and",
   "(",
   "self",
   ".",
   "_vt",
   "is",
   "not",
   "None",
   "or",
   "self",
   ".",
   "distThreshold",
   ">",
   "0",
   "or",
   "self",
   ".",
   "numSVDDims",
   "is",
   "not",
   "None",
   "or",
   "self",
   ".",
   "numSVDSamples",
   ">",
   "0",
   "or",
   "self",
   ".",
   "numWinners",
   ">",
   "0",
   ")",
   ":",
   "denseInput",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "isSparse",
   ")",
   "denseInput",
   "[",
   "inputPattern",
   "]",
   "=",
   "1.0",
   "inputPattern",
   "=",
   "denseInput",
   "isSparse",
   "=",
   "0",
   "# Get the input width",
   "if",
   "isSparse",
   ">",
   "0",
   ":",
   "inputWidth",
   "=",
   "isSparse",
   "else",
   ":",
   "inputWidth",
   "=",
   "len",
   "(",
   "inputPattern",
   ")",
   "# Allocate storage if this is the first training vector",
   "if",
   "self",
   ".",
   "_Memory",
   "is",
   "None",
   ":",
   "self",
   ".",
   "_Memory",
   "=",
   "NearestNeighbor",
   "(",
   "0",
   ",",
   "inputWidth",
   ")",
   "# Support SVD if it is on",
   "if",
   "self",
   ".",
   "_vt",
   "is",
   "not",
   "None",
   ":",
   "inputPattern",
   "=",
   "numpy",
   ".",
   "dot",
   "(",
   "self",
   ".",
   "_vt",
   ",",
   "inputPattern",
   "-",
   "self",
   ".",
   "_mean",
   ")",
   "# Threshold the input, zeroing out entries that are too close to 0.",
   "#  This is only done if we are given a dense input.",
   "if",
   "isSparse",
   "==",
   "0",
   ":",
   "thresholdedInput",
   "=",
   "self",
   ".",
   "_sparsifyVector",
   "(",
   "inputPattern",
   ",",
   "True",
   ")",
   "addRow",
   "=",
   "True",
   "# If given the layout of the cells, then turn on the logic that stores",
   "# only the start cell for bursting columns.",
   "if",
   "self",
   ".",
   "cellsPerCol",
   ">=",
   "1",
   ":",
   "burstingCols",
   "=",
   "thresholdedInput",
   ".",
   "reshape",
   "(",
   "-",
   "1",
   ",",
   "self",
   ".",
   "cellsPerCol",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   "for",
   "col",
   "in",
   "burstingCols",
   ":",
   "thresholdedInput",
   "[",
   "(",
   "col",
   "*",
   "self",
   ".",
   "cellsPerCol",
   ")",
   "+",
   "1",
   ":",
   "(",
   "col",
   "*",
   "self",
   ".",
   "cellsPerCol",
   ")",
   "+",
   "self",
   ".",
   "cellsPerCol",
   "]",
   "=",
   "0",
   "# Don't learn entries that are too close to existing entries.",
   "if",
   "self",
   ".",
   "_Memory",
   ".",
   "nRows",
   "(",
   ")",
   ">",
   "0",
   ":",
   "dist",
   "=",
   "None",
   "# if this vector is a perfect match for one we already learned, then",
   "#  replace the category - it may have changed with online learning on.",
   "if",
   "self",
   ".",
   "replaceDuplicates",
   ":",
   "dist",
   "=",
   "self",
   ".",
   "_calcDistance",
   "(",
   "thresholdedInput",
   ",",
   "distanceNorm",
   "=",
   "1",
   ")",
   "if",
   "dist",
   ".",
   "min",
   "(",
   ")",
   "==",
   "0",
   ":",
   "rowIdx",
   "=",
   "dist",
   ".",
   "argmin",
   "(",
   ")",
   "self",
   ".",
   "_categoryList",
   "[",
   "rowIdx",
   "]",
   "=",
   "int",
   "(",
   "inputCategory",
   ")",
   "if",
   "self",
   ".",
   "fixedCapacity",
   ":",
   "self",
   ".",
   "_categoryRecencyList",
   "[",
   "rowIdx",
   "]",
   "=",
   "rowID",
   "addRow",
   "=",
   "False",
   "# Don't add this vector if it matches closely with another we already",
   "#  added",
   "if",
   "self",
   ".",
   "distThreshold",
   ">",
   "0",
   ":",
   "if",
   "dist",
   "is",
   "None",
   "or",
   "self",
   ".",
   "distanceNorm",
   "!=",
   "1",
   ":",
   "dist",
   "=",
   "self",
   ".",
   "_calcDistance",
   "(",
   "thresholdedInput",
   ")",
   "minDist",
   "=",
   "dist",
   ".",
   "min",
   "(",
   ")",
   "addRow",
   "=",
   "(",
   "minDist",
   ">=",
   "self",
   ".",
   "distThreshold",
   ")",
   "if",
   "not",
   "addRow",
   ":",
   "if",
   "self",
   ".",
   "fixedCapacity",
   ":",
   "rowIdx",
   "=",
   "dist",
   ".",
   "argmin",
   "(",
   ")",
   "self",
   ".",
   "_categoryRecencyList",
   "[",
   "rowIdx",
   "]",
   "=",
   "rowID",
   "# If sparsity is too low, we do not want to add this vector",
   "if",
   "addRow",
   "and",
   "self",
   ".",
   "minSparsity",
   ">",
   "0.0",
   ":",
   "if",
   "isSparse",
   "==",
   "0",
   ":",
   "sparsity",
   "=",
   "(",
   "float",
   "(",
   "len",
   "(",
   "thresholdedInput",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ")",
   "/",
   "len",
   "(",
   "thresholdedInput",
   ")",
   ")",
   "else",
   ":",
   "sparsity",
   "=",
   "float",
   "(",
   "len",
   "(",
   "inputPattern",
   ")",
   ")",
   "/",
   "isSparse",
   "if",
   "sparsity",
   "<",
   "self",
   ".",
   "minSparsity",
   ":",
   "addRow",
   "=",
   "False",
   "# Add the new sparse vector to our storage",
   "if",
   "addRow",
   ":",
   "self",
   ".",
   "_protoSizes",
   "=",
   "None",
   "# need to re-compute",
   "if",
   "isSparse",
   "==",
   "0",
   ":",
   "self",
   ".",
   "_Memory",
   ".",
   "addRow",
   "(",
   "thresholdedInput",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_Memory",
   ".",
   "addRowNZ",
   "(",
   "inputPattern",
   ",",
   "[",
   "1",
   "]",
   "*",
   "len",
   "(",
   "inputPattern",
   ")",
   ")",
   "self",
   ".",
   "_numPatterns",
   "+=",
   "1",
   "self",
   ".",
   "_categoryList",
   ".",
   "append",
   "(",
   "int",
   "(",
   "inputCategory",
   ")",
   ")",
   "self",
   ".",
   "_addPartitionId",
   "(",
   "self",
   ".",
   "_numPatterns",
   "-",
   "1",
   ",",
   "partitionId",
   ")",
   "if",
   "self",
   ".",
   "fixedCapacity",
   ":",
   "self",
   ".",
   "_categoryRecencyList",
   ".",
   "append",
   "(",
   "rowID",
   ")",
   "if",
   "self",
   ".",
   "_numPatterns",
   ">",
   "self",
   ".",
   "maxStoredPatterns",
   "and",
   "self",
   ".",
   "maxStoredPatterns",
   ">",
   "0",
   ":",
   "leastRecentlyUsedPattern",
   "=",
   "numpy",
   ".",
   "argmin",
   "(",
   "self",
   ".",
   "_categoryRecencyList",
   ")",
   "self",
   ".",
   "_Memory",
   ".",
   "deleteRow",
   "(",
   "leastRecentlyUsedPattern",
   ")",
   "self",
   ".",
   "_categoryList",
   ".",
   "pop",
   "(",
   "leastRecentlyUsedPattern",
   ")",
   "self",
   ".",
   "_categoryRecencyList",
   ".",
   "pop",
   "(",
   "leastRecentlyUsedPattern",
   ")",
   "self",
   ".",
   "_numPatterns",
   "-=",
   "1",
   "if",
   "self",
   ".",
   "numSVDDims",
   "is",
   "not",
   "None",
   "and",
   "self",
   ".",
   "numSVDSamples",
   ">",
   "0",
   "and",
   "self",
   ".",
   "_numPatterns",
   "==",
   "self",
   ".",
   "numSVDSamples",
   ":",
   "self",
   ".",
   "computeSVD",
   "(",
   ")",
   "return",
   "self",
   ".",
   "_numPatterns"
  ]
 },
 {
  "idx": "maxmin-240",
  "nl_tokens": [
   "Get",
   "the",
   "minimum",
   "and",
   "maximum",
   "of",
   "the",
   "normalization",
   "of",
   "the",
   "array",
   "which",
   "sets",
   "the",
   "lower",
   "and",
   "upper",
   "limits",
   "of",
   "the",
   "\\",
   "colormap",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_normalization_min_max",
   "(",
   "array",
   ",",
   "norm_min",
   ",",
   "norm_max",
   ")",
   ":",
   "if",
   "norm_min",
   "is",
   "None",
   ":",
   "norm_min",
   "=",
   "array",
   ".",
   "<mask>",
   "(",
   ")",
   "if",
   "norm_max",
   "is",
   "None",
   ":",
   "norm_max",
   "=",
   "array",
   ".",
   "max",
   "(",
   ")",
   "return",
   "norm_min",
   ",",
   "norm_max"
  ]
 },
 {
  "idx": "maxmin-241",
  "nl_tokens": [
   "Get",
   "LanguageTool",
   "directory",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_directory",
   "(",
   ")",
   ":",
   "try",
   ":",
   "language_check_dir",
   "=",
   "cache",
   "[",
   "'language_check_dir'",
   "]",
   "except",
   "KeyError",
   ":",
   "def",
   "version_key",
   "(",
   "string",
   ")",
   ":",
   "return",
   "[",
   "int",
   "(",
   "e",
   ")",
   "if",
   "e",
   ".",
   "isdigit",
   "(",
   ")",
   "else",
   "e",
   "for",
   "e",
   "in",
   "re",
   ".",
   "split",
   "(",
   "r\"(\\d+)\"",
   ",",
   "string",
   ")",
   "]",
   "def",
   "get_lt_dir",
   "(",
   "base_dir",
   ")",
   ":",
   "paths",
   "=",
   "[",
   "path",
   "for",
   "path",
   "in",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "base_dir",
   ",",
   "'LanguageTool*'",
   ")",
   ")",
   "if",
   "os",
   ".",
   "path",
   ".",
   "isdir",
   "(",
   "path",
   ")",
   "]",
   "return",
   "<mask>",
   "(",
   "paths",
   ",",
   "key",
   "=",
   "version_key",
   ")",
   "if",
   "paths",
   "else",
   "None",
   "base_dir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "dirname",
   "(",
   "sys",
   ".",
   "argv",
   "[",
   "0",
   "]",
   ")",
   "language_check_dir",
   "=",
   "get_lt_dir",
   "(",
   "base_dir",
   ")",
   "if",
   "not",
   "language_check_dir",
   ":",
   "try",
   ":",
   "base_dir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "dirname",
   "(",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "__file__",
   ")",
   ")",
   "except",
   "NameError",
   ":",
   "pass",
   "else",
   ":",
   "language_check_dir",
   "=",
   "get_lt_dir",
   "(",
   "base_dir",
   ")",
   "if",
   "not",
   "language_check_dir",
   ":",
   "raise",
   "PathError",
   "(",
   "\"can't find LanguageTool directory in {!r}\"",
   ".",
   "format",
   "(",
   "base_dir",
   ")",
   ")",
   "cache",
   "[",
   "'language_check_dir'",
   "]",
   "=",
   "language_check_dir",
   "return",
   "language_check_dir"
  ]
 },
 {
  "idx": "maxmin-242",
  "nl_tokens": [
   "Re",
   "-",
   "apply",
   "type",
   "annotations",
   "from",
   ".",
   "pyi",
   "stubs",
   "to",
   "your",
   "codebase",
   "."
  ],
  "pl_tokens": [
   "def",
   "main",
   "(",
   "src",
   ",",
   "pyi_dir",
   ",",
   "target_dir",
   ",",
   "incremental",
   ",",
   "quiet",
   ",",
   "replace_any",
   ",",
   "hg",
   ",",
   "traceback",
   ")",
   ":",
   "Config",
   ".",
   "incremental",
   "=",
   "incremental",
   "Config",
   ".",
   "replace_any",
   "=",
   "replace_any",
   "returncode",
   "=",
   "0",
   "for",
   "src_entry",
   "in",
   "src",
   ":",
   "for",
   "file",
   ",",
   "error",
   ",",
   "exc_type",
   ",",
   "tb",
   "in",
   "retype_path",
   "(",
   "Path",
   "(",
   "src_entry",
   ")",
   ",",
   "pyi_dir",
   "=",
   "Path",
   "(",
   "pyi_dir",
   ")",
   ",",
   "targets",
   "=",
   "Path",
   "(",
   "target_dir",
   ")",
   ",",
   "src_explicitly_given",
   "=",
   "True",
   ",",
   "quiet",
   "=",
   "quiet",
   ",",
   "hg",
   "=",
   "hg",
   ",",
   ")",
   ":",
   "print",
   "(",
   "f'error: {file}: {error}'",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ")",
   "if",
   "traceback",
   ":",
   "print",
   "(",
   "'Traceback (most recent call last):'",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ")",
   "for",
   "line",
   "in",
   "tb",
   ":",
   "print",
   "(",
   "line",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ",",
   "end",
   "=",
   "''",
   ")",
   "print",
   "(",
   "f'{exc_type.__name__}: {error}'",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ")",
   "returncode",
   "+=",
   "1",
   "if",
   "not",
   "src",
   "and",
   "not",
   "quiet",
   ":",
   "print",
   "(",
   "'warning: no sources given'",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ")",
   "# According to http://tldp.org/LDP/abs/html/index.html starting with 126",
   "# we have special returncodes.",
   "sys",
   ".",
   "exit",
   "(",
   "<mask>",
   "(",
   "returncode",
   ",",
   "125",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-243",
  "nl_tokens": [
   "check",
   "whether",
   "mindepth",
   "has",
   "changed",
   "and",
   "thus",
   "whether",
   "clusters_hidepth",
   "needs",
   "to",
   "be",
   "recalculated",
   "and",
   "get",
   "new",
   "maxlen",
   "for",
   "new",
   "highdepth",
   "clusts",
   ".",
   "if",
   "mindepth",
   "not",
   "changed",
   "then",
   "nothing",
   "changes",
   "."
  ],
  "pl_tokens": [
   "def",
   "calculate_depths",
   "(",
   "data",
   ",",
   "samples",
   ",",
   "lbview",
   ")",
   ":",
   "## send jobs to be processed on engines",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "printstr",
   "=",
   "\" calculating depths    | {} | s5 |\"",
   "recaljobs",
   "=",
   "{",
   "}",
   "maxlens",
   "=",
   "[",
   "]",
   "for",
   "sample",
   "in",
   "samples",
   ":",
   "recaljobs",
   "[",
   "sample",
   ".",
   "name",
   "]",
   "=",
   "lbview",
   ".",
   "apply",
   "(",
   "recal_hidepth",
   ",",
   "*",
   "(",
   "data",
   ",",
   "sample",
   ")",
   ")",
   "## block until finished",
   "while",
   "1",
   ":",
   "ready",
   "=",
   "[",
   "i",
   ".",
   "ready",
   "(",
   ")",
   "for",
   "i",
   "in",
   "recaljobs",
   ".",
   "values",
   "(",
   ")",
   "]",
   "elapsed",
   "=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "seconds",
   "=",
   "int",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")",
   ")",
   "progressbar",
   "(",
   "len",
   "(",
   "ready",
   ")",
   ",",
   "sum",
   "(",
   "ready",
   ")",
   ",",
   "printstr",
   ".",
   "format",
   "(",
   "elapsed",
   ")",
   ",",
   "spacer",
   "=",
   "data",
   ".",
   "_spacer",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "0.1",
   ")",
   "if",
   "len",
   "(",
   "ready",
   ")",
   "==",
   "sum",
   "(",
   "ready",
   ")",
   ":",
   "print",
   "(",
   "\"\"",
   ")",
   "break",
   "## check for failures and collect results",
   "modsamples",
   "=",
   "[",
   "]",
   "for",
   "sample",
   "in",
   "samples",
   ":",
   "if",
   "not",
   "recaljobs",
   "[",
   "sample",
   ".",
   "name",
   "]",
   ".",
   "successful",
   "(",
   ")",
   ":",
   "LOGGER",
   ".",
   "error",
   "(",
   "\"  sample %s failed: %s\"",
   ",",
   "sample",
   ".",
   "name",
   ",",
   "recaljobs",
   "[",
   "sample",
   ".",
   "name",
   "]",
   ".",
   "exception",
   "(",
   ")",
   ")",
   "else",
   ":",
   "modsample",
   ",",
   "_",
   ",",
   "maxlen",
   ",",
   "_",
   ",",
   "_",
   "=",
   "recaljobs",
   "[",
   "sample",
   ".",
   "name",
   "]",
   ".",
   "result",
   "(",
   ")",
   "modsamples",
   ".",
   "append",
   "(",
   "modsample",
   ")",
   "maxlens",
   ".",
   "append",
   "(",
   "maxlen",
   ")",
   "## reset global maxlen if something changed",
   "data",
   ".",
   "_hackersonly",
   "[",
   "\"max_fragment_length\"",
   "]",
   "=",
   "int",
   "(",
   "<mask>",
   "(",
   "maxlens",
   ")",
   ")",
   "+",
   "4",
   "return",
   "samples"
  ]
 },
 {
  "idx": "maxmin-244",
  "nl_tokens": [
   "This",
   "calculates",
   "various",
   "point",
   "-",
   "to",
   "-",
   "point",
   "measures",
   "(",
   "eta",
   "in",
   "Kim",
   "+",
   "2014",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "lightcurve_ptp_measures",
   "(",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   ")",
   ":",
   "ndet",
   "=",
   "len",
   "(",
   "fmags",
   ")",
   "if",
   "ndet",
   ">",
   "9",
   ":",
   "timediffs",
   "=",
   "npdiff",
   "(",
   "ftimes",
   ")",
   "# get rid of stuff with time diff = 0.0",
   "nzind",
   "=",
   "npnonzero",
   "(",
   "timediffs",
   ")",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   "=",
   "ftimes",
   "[",
   "nzind",
   "]",
   ",",
   "fmags",
   "[",
   "nzind",
   "]",
   ",",
   "ferrs",
   "[",
   "nzind",
   "]",
   "# recalculate ndet and diffs",
   "ndet",
   "=",
   "ftimes",
   ".",
   "size",
   "timediffs",
   "=",
   "npdiff",
   "(",
   "ftimes",
   ")",
   "# calculate the point to point measures",
   "p2p_abs_magdiffs",
   "=",
   "npabs",
   "(",
   "npdiff",
   "(",
   "fmags",
   ")",
   ")",
   "p2p_squared_magdiffs",
   "=",
   "npdiff",
   "(",
   "fmags",
   ")",
   "*",
   "npdiff",
   "(",
   "fmags",
   ")",
   "robstd",
   "=",
   "npmedian",
   "(",
   "npabs",
   "(",
   "fmags",
   "-",
   "npmedian",
   "(",
   "fmags",
   ")",
   ")",
   ")",
   "*",
   "1.483",
   "robvar",
   "=",
   "robstd",
   "*",
   "robstd",
   "# these are eta from the Kim+ 2014 paper - ratio of point-to-point",
   "# difference to the variance of the entire series",
   "# this is the robust version",
   "eta_robust",
   "=",
   "npmedian",
   "(",
   "p2p_abs_magdiffs",
   ")",
   "/",
   "robvar",
   "eta_robust",
   "=",
   "eta_robust",
   "/",
   "(",
   "ndet",
   "-",
   "1.0",
   ")",
   "# this is the usual version",
   "eta_normal",
   "=",
   "npsum",
   "(",
   "p2p_squared_magdiffs",
   ")",
   "/",
   "npvar",
   "(",
   "fmags",
   ")",
   "eta_normal",
   "=",
   "eta_normal",
   "/",
   "(",
   "ndet",
   "-",
   "1.0",
   ")",
   "timeweights",
   "=",
   "1.0",
   "/",
   "(",
   "timediffs",
   "*",
   "timediffs",
   ")",
   "# this is eta_e modified for uneven sampling from the Kim+ 2014 paper",
   "eta_uneven_normal",
   "=",
   "(",
   "(",
   "npsum",
   "(",
   "timeweights",
   "*",
   "p2p_squared_magdiffs",
   ")",
   "/",
   "(",
   "npvar",
   "(",
   "fmags",
   ")",
   "*",
   "npsum",
   "(",
   "timeweights",
   ")",
   ")",
   ")",
   "*",
   "npmean",
   "(",
   "timeweights",
   ")",
   "*",
   "(",
   "ftimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "ftimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "*",
   "(",
   "ftimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "ftimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "# this is robust eta_e modified for uneven sampling from the Kim+ 2014",
   "# paper",
   "eta_uneven_robust",
   "=",
   "(",
   "(",
   "npsum",
   "(",
   "timeweights",
   "*",
   "p2p_abs_magdiffs",
   ")",
   "/",
   "(",
   "robvar",
   "*",
   "npsum",
   "(",
   "timeweights",
   ")",
   ")",
   ")",
   "*",
   "npmedian",
   "(",
   "timeweights",
   ")",
   "*",
   "(",
   "ftimes",
   "[",
   "-",
   "1",
   "]",
   "-",
   "ftimes",
   "[",
   "0",
   "]",
   ")",
   "*",
   "(",
   "ftimes",
   "[",
   "-",
   "1",
   "]",
   "-",
   "ftimes",
   "[",
   "0",
   "]",
   ")",
   ")",
   "return",
   "{",
   "'eta_normal'",
   ":",
   "eta_normal",
   ",",
   "'eta_robust'",
   ":",
   "eta_robust",
   ",",
   "'eta_uneven_normal'",
   ":",
   "eta_uneven_normal",
   ",",
   "'eta_uneven_robust'",
   ":",
   "eta_uneven_robust",
   "}",
   "else",
   ":",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-245",
  "nl_tokens": [
   "Returns",
   "index",
   "/",
   "key",
   "of",
   "the",
   "item",
   "with",
   "the",
   "smallest",
   "value",
   "."
  ],
  "pl_tokens": [
   "def",
   "argmin",
   "(",
   "indexable",
   ",",
   "key",
   "=",
   "None",
   ")",
   ":",
   "if",
   "key",
   "is",
   "None",
   "and",
   "isinstance",
   "(",
   "indexable",
   ",",
   "collections_abc",
   ".",
   "Mapping",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "indexable",
   ".",
   "items",
   "(",
   ")",
   ",",
   "key",
   "=",
   "operator",
   ".",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "elif",
   "hasattr",
   "(",
   "indexable",
   ",",
   "'index'",
   ")",
   ":",
   "if",
   "key",
   "is",
   "None",
   ":",
   "return",
   "indexable",
   ".",
   "index",
   "(",
   "min",
   "(",
   "indexable",
   ")",
   ")",
   "else",
   ":",
   "return",
   "indexable",
   ".",
   "index",
   "(",
   "min",
   "(",
   "indexable",
   ",",
   "key",
   "=",
   "key",
   ")",
   ")",
   "else",
   ":",
   "# less efficient, but catch all solution",
   "return",
   "argsort",
   "(",
   "indexable",
   ",",
   "key",
   "=",
   "key",
   ")",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-246",
  "nl_tokens": [
   "The",
   "range",
   "of",
   "connected",
   "synapses",
   "for",
   "column",
   ".",
   "This",
   "is",
   "used",
   "to",
   "calculate",
   "the",
   "inhibition",
   "radius",
   ".",
   "This",
   "variation",
   "of",
   "the",
   "function",
   "only",
   "supports",
   "a",
   "1",
   "dimensional",
   "column",
   "topology",
   "."
  ],
  "pl_tokens": [
   "def",
   "_avgConnectedSpanForColumn1D",
   "(",
   "self",
   ",",
   "columnIndex",
   ")",
   ":",
   "assert",
   "(",
   "self",
   ".",
   "_inputDimensions",
   ".",
   "size",
   "==",
   "1",
   ")",
   "connected",
   "=",
   "self",
   ".",
   "_connectedSynapses",
   "[",
   "columnIndex",
   "]",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   "if",
   "connected",
   ".",
   "size",
   "==",
   "0",
   ":",
   "return",
   "0",
   "else",
   ":",
   "return",
   "<mask>",
   "(",
   "connected",
   ")",
   "-",
   "min",
   "(",
   "connected",
   ")",
   "+",
   "1"
  ]
 },
 {
  "idx": "maxmin-247",
  "nl_tokens": [
   "Outlines",
   "each",
   "contour",
   "in",
   "a",
   "path",
   "with",
   "the",
   "colors",
   "in",
   "the",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "outline",
   "(",
   "path",
   ",",
   "colors",
   ",",
   "precision",
   "=",
   "0.4",
   ",",
   "continuous",
   "=",
   "True",
   ")",
   ":",
   "# The count of points in a given path/contour.",
   "def",
   "_point_count",
   "(",
   "path",
   ",",
   "precision",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "int",
   "(",
   "path",
   ".",
   "length",
   "*",
   "precision",
   "*",
   "0.5",
   ")",
   ",",
   "10",
   ")",
   "# The total count of points in the path.",
   "n",
   "=",
   "sum",
   "(",
   "[",
   "_point_count",
   "(",
   "contour",
   ",",
   "precision",
   ")",
   "for",
   "contour",
   "in",
   "path",
   ".",
   "contours",
   "]",
   ")",
   "# For a continuous gradient,",
   "# we need to calculate a subrange in the list of colors",
   "# for each contour to draw colors from.",
   "contour_i",
   "=",
   "0",
   "contour_n",
   "=",
   "len",
   "(",
   "path",
   ".",
   "contours",
   ")",
   "-",
   "1",
   "if",
   "contour_n",
   "==",
   "0",
   ":",
   "continuous",
   "=",
   "False",
   "i",
   "=",
   "0",
   "for",
   "contour",
   "in",
   "path",
   ".",
   "contours",
   ":",
   "if",
   "not",
   "continuous",
   ":",
   "i",
   "=",
   "0",
   "# The number of points for each contour.",
   "j",
   "=",
   "_point_count",
   "(",
   "contour",
   ",",
   "precision",
   ")",
   "first",
   "=",
   "True",
   "for",
   "pt",
   "in",
   "contour",
   ".",
   "points",
   "(",
   "j",
   ")",
   ":",
   "if",
   "first",
   ":",
   "first",
   "=",
   "False",
   "else",
   ":",
   "if",
   "not",
   "continuous",
   ":",
   "# If we have a list of 100 colors and 50 points,",
   "# point i maps to color i*2.",
   "clr",
   "=",
   "float",
   "(",
   "i",
   ")",
   "/",
   "j",
   "*",
   "len",
   "(",
   "colors",
   ")",
   "else",
   ":",
   "# In a continuous gradient of 100 colors,",
   "# the 2nd contour in a path with 10 contours",
   "# draws colors between 10-20",
   "clr",
   "=",
   "float",
   "(",
   "i",
   ")",
   "/",
   "n",
   "*",
   "len",
   "(",
   "colors",
   ")",
   "-",
   "1",
   "*",
   "contour_i",
   "/",
   "contour_n",
   "_ctx",
   ".",
   "stroke",
   "(",
   "colors",
   "[",
   "int",
   "(",
   "clr",
   ")",
   "]",
   ")",
   "_ctx",
   ".",
   "line",
   "(",
   "x0",
   ",",
   "y0",
   ",",
   "pt",
   ".",
   "x",
   ",",
   "pt",
   ".",
   "y",
   ")",
   "x0",
   "=",
   "pt",
   ".",
   "x",
   "y0",
   "=",
   "pt",
   ".",
   "y",
   "i",
   "+=",
   "1",
   "pt",
   "=",
   "contour",
   ".",
   "point",
   "(",
   "0.9999999",
   ")",
   "# Fix in pathmatics!",
   "_ctx",
   ".",
   "line",
   "(",
   "x0",
   ",",
   "y0",
   ",",
   "pt",
   ".",
   "x",
   ",",
   "pt",
   ".",
   "y",
   ")",
   "contour_i",
   "+=",
   "1"
  ]
 },
 {
  "idx": "maxmin-248",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "initialize",
   "the",
   "object",
   "by",
   "precomputing",
   "any",
   "values",
   "which",
   "may",
   "be",
   "used",
   "repeatedly",
   "and",
   "by",
   "retrieving",
   "mixture",
   "-",
   "specific",
   "variables",
   ".",
   "All",
   "data",
   "are",
   "stored",
   "as",
   "attributes",
   ".",
   "This",
   "method",
   "also",
   "sets",
   ":",
   "obj",
   ":",
   "Tmin",
   ":",
   "obj",
   ":",
   "Tmax",
   "and",
   ":",
   "obj",
   ":",
   "all_methods",
   "as",
   "a",
   "set",
   "of",
   "methods",
   "which",
   "should",
   "work",
   "to",
   "calculate",
   "the",
   "property",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "DIPPR_9H",
   ",",
   "SIMPLE",
   "]",
   "if",
   "len",
   "(",
   "self",
   ".",
   "CASs",
   ")",
   "==",
   "2",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "FILIPPOV",
   ")",
   "if",
   "'7732-18-5'",
   "in",
   "self",
   ".",
   "CASs",
   "and",
   "len",
   "(",
   "self",
   ".",
   "CASs",
   ")",
   ">",
   "1",
   ":",
   "wCASs",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "self",
   ".",
   "CASs",
   "if",
   "i",
   "!=",
   "'7732-18-5'",
   "]",
   "if",
   "all",
   "(",
   "[",
   "i",
   "in",
   "Magomedovk_thermal_cond",
   ".",
   "index",
   "for",
   "i",
   "in",
   "wCASs",
   "]",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "MAGOMEDOV",
   ")",
   "self",
   ".",
   "wCASs",
   "=",
   "wCASs",
   "self",
   ".",
   "index_w",
   "=",
   "self",
   ".",
   "CASs",
   ".",
   "index",
   "(",
   "'7732-18-5'",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "Tmins",
   "=",
   "[",
   "i",
   ".",
   "Tmin",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ThermalConductivityLiquids",
   "if",
   "i",
   ".",
   "Tmin",
   "]",
   "Tmaxs",
   "=",
   "[",
   "i",
   ".",
   "Tmax",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ThermalConductivityLiquids",
   "if",
   "i",
   ".",
   "Tmax",
   "]",
   "if",
   "Tmins",
   ":",
   "self",
   ".",
   "Tmin",
   "=",
   "<mask>",
   "(",
   "Tmins",
   ")",
   "if",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmax",
   "=",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-249",
  "nl_tokens": [
   "Determine",
   "the",
   "suitable",
   "reference",
   "stars",
   "and",
   "then",
   "the",
   "total",
   "flux",
   "in",
   "those",
   "stars",
   "and",
   "in",
   "the",
   "target",
   "star",
   "in",
   "each",
   "epoch",
   "Args",
   ":",
   "min_flux",
   ":",
   "The",
   "size",
   "of",
   "the",
   "region",
   "around",
   "the",
   "target",
   "star",
   "to",
   "be",
   "plotted",
   ".",
   "Images",
   "will",
   "be",
   "a",
   "square",
   "with",
   "side",
   "length",
   "image_region",
   "(",
   "default",
   ":",
   "5000",
   ")",
   "outlier_iterations",
   ":",
   "The",
   "number",
   "of",
   "iterations",
   "to",
   "remove",
   "outliers",
   "from",
   "the",
   "reference",
   "star",
   "sample",
   "(",
   "stars",
   "at",
   "epochs",
   "with",
   "more",
   "than",
   "max_outlier_obs",
   "observations",
   "more",
   "than",
   "outlier_limit",
   "standard",
   "deviations",
   "from",
   "the",
   "median",
   "value",
   "for",
   "all",
   "stars",
   "after",
   "normalization",
   ")",
   "(",
   "default",
   ":",
   "5",
   ")",
   "max_outlier_obs",
   ":",
   "The",
   "maximum",
   "number",
   "of",
   "epochs",
   "at",
   "which",
   "a",
   "star",
   "is",
   "allowed",
   "to",
   "be",
   "more",
   "than",
   "outlier_limit",
   "standard",
   "deviations",
   "from",
   "the",
   "median",
   "value",
   "for",
   "all",
   "stars",
   "before",
   "it",
   "is",
   "removed",
   "as",
   "a",
   "suitable",
   "reference",
   "star",
   "(",
   "default",
   ":",
   "4",
   ")",
   "outlier_limit",
   ":",
   "The",
   "level",
   "of",
   "deviation",
   "(",
   "measured",
   "in",
   "standard",
   "deviations",
   ")",
   "which",
   "a",
   "target",
   "is",
   "allowed",
   "to",
   "be",
   "discrepant",
   "from",
   "the",
   "median",
   ".",
   "If",
   "it",
   "is",
   "this",
   "discrepant",
   "at",
   "more",
   "than",
   "max_outlier_obs",
   "epochs",
   "it",
   "is",
   "removed",
   "from",
   "consideration",
   "(",
   "default",
   ":",
   "1",
   ".",
   "7",
   ")"
  ],
  "pl_tokens": [
   "def",
   "calc_fluxes",
   "(",
   "self",
   ",",
   "min_flux",
   "=",
   "5000",
   ",",
   "outlier_iterations",
   "=",
   "5",
   ",",
   "max_outlier_obs",
   "=",
   "4",
   ",",
   "outlier_limit",
   "=",
   "1.7",
   ")",
   ":",
   "jj",
   ",",
   "ii",
   "=",
   "self",
   ".",
   "center",
   "numer",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ")",
   "denom",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ")",
   "factr",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ")",
   "numer_pix",
   "=",
   "self",
   ".",
   "postcard",
   "[",
   ":",
   ",",
   "self",
   ".",
   "targets",
   "==",
   "1",
   "]",
   "numer",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "numer_pix",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "tar_vals",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ",",
   "int",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "targets",
   ")",
   "+",
   "1",
   "-",
   "2",
   "-",
   "self",
   ".",
   "ignore_bright",
   ")",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   "+",
   "self",
   ".",
   "ignore_bright",
   ",",
   "int",
   "(",
   "np",
   ".",
   "max",
   "(",
   "self",
   ".",
   "targets",
   ")",
   "+",
   "1",
   ")",
   ")",
   ":",
   "tval",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "self",
   ".",
   "postcard",
   "[",
   ":",
   ",",
   "self",
   ".",
   "targets",
   "==",
   "i",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "#denom += tval/np.median(tval)",
   "tar_vals",
   "[",
   ":",
   ",",
   "i",
   "-",
   "2",
   "-",
   "self",
   ".",
   "ignore_bright",
   "]",
   "=",
   "tval",
   "#/ np.median(tval)",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "obs_filenames",
   ")",
   ")",
   ":",
   "if",
   "np",
   ".",
   "max",
   "(",
   "tar_vals",
   "[",
   "i",
   "]",
   ")",
   "<",
   "min_flux",
   ":",
   "tar_vals",
   "[",
   "self",
   ".",
   "qs",
   "==",
   "self",
   ".",
   "qs",
   "[",
   "i",
   "]",
   "]",
   "=",
   "0.0",
   "all_tar",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ",",
   "int",
   "(",
   "np",
   ".",
   "max",
   "(",
   "self",
   ".",
   "targets",
   ")",
   "-",
   "self",
   ".",
   "ignore_bright",
   ")",
   ")",
   ")",
   "all_tar",
   "[",
   ":",
   ",",
   "0",
   "]",
   "=",
   "numer",
   "all_tar",
   "[",
   ":",
   ",",
   "1",
   ":",
   "]",
   "=",
   "tar_vals",
   "self",
   ".",
   "photometry_array",
   "=",
   "all_tar",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "tar_vals",
   "[",
   "0",
   "]",
   ")",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "4",
   ")",
   ":",
   "g",
   "=",
   "np",
   ".",
   "where",
   "(",
   "self",
   ".",
   "qs",
   "==",
   "j",
   ")",
   "[",
   "0",
   "]",
   "tar_vals",
   "[",
   "g",
   ",",
   "i",
   "]",
   "/=",
   "(",
   "np",
   ".",
   "median",
   "(",
   "tar_vals",
   "[",
   "g",
   ",",
   "i",
   "]",
   ")",
   "+",
   "1e-15",
   ")",
   "tar_vals_old",
   "=",
   "tar_vals",
   "+",
   "0.0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "outlier_iterations",
   ")",
   ":",
   "nonzeros",
   "=",
   "np",
   ".",
   "where",
   "(",
   "tar_vals",
   "[",
   "0",
   ",",
   ":",
   "]",
   "!=",
   "0",
   ")",
   "[",
   "0",
   "]",
   "med",
   "=",
   "np",
   ".",
   "median",
   "(",
   "tar_vals",
   "[",
   ":",
   ",",
   "nonzeros",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "std",
   "=",
   "np",
   ".",
   "std",
   "(",
   "tar_vals",
   "[",
   ":",
   ",",
   "nonzeros",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "if",
   "np",
   ".",
   "sum",
   "(",
   "tar_vals",
   ")",
   "!=",
   "0.0",
   ":",
   "tar_vals_old",
   "=",
   "tar_vals",
   "+",
   "0.0",
   "for",
   "k",
   "in",
   "range",
   "(",
   "len",
   "(",
   "tar_vals",
   "[",
   "0",
   "]",
   ")",
   ")",
   ":",
   "h",
   "=",
   "np",
   ".",
   "where",
   "(",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "med",
   "-",
   "tar_vals",
   "[",
   ":",
   ",",
   "k",
   "]",
   ")",
   "/",
   "std",
   ")",
   ">",
   "outlier_limit",
   ")",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "h",
   ")",
   ">=",
   "max_outlier_obs",
   ":",
   "tar_vals",
   "[",
   ":",
   ",",
   "k",
   "]",
   "=",
   "0",
   "if",
   "np",
   ".",
   "sum",
   "(",
   "tar_vals",
   ")",
   "==",
   "0.0",
   ":",
   "tar_vals",
   "=",
   "tar_vals_old",
   "+",
   "0.0",
   "denom",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "tar_vals",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "self",
   ".",
   "target_flux_pixels",
   "=",
   "numer_pix",
   "self",
   ".",
   "reference_flux",
   "=",
   "denom"
  ]
 },
 {
  "idx": "maxmin-250",
  "nl_tokens": [
   "This",
   "calculates",
   "the",
   "future",
   "epochs",
   "for",
   "a",
   "transit",
   "given",
   "a",
   "period",
   "and",
   "a",
   "starting",
   "epoch"
  ],
  "pl_tokens": [
   "def",
   "get_epochs_given_midtimes_and_period",
   "(",
   "t_mid",
   ",",
   "period",
   ",",
   "err_t_mid",
   "=",
   "None",
   ",",
   "t0_fixed",
   "=",
   "None",
   ",",
   "t0_percentile",
   "=",
   "None",
   ",",
   "verbose",
   "=",
   "False",
   ")",
   ":",
   "kwargarr",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "isinstance",
   "(",
   "err_t_mid",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ",",
   "t0_fixed",
   ",",
   "t0_percentile",
   "]",
   ")",
   "if",
   "not",
   "_single_true",
   "(",
   "kwargarr",
   ")",
   "and",
   "not",
   "np",
   ".",
   "all",
   "(",
   "~",
   "kwargarr",
   ".",
   "astype",
   "(",
   "bool",
   ")",
   ")",
   ":",
   "raise",
   "AssertionError",
   "(",
   "'can have at most one of err_t_mid, t0_fixed, t0_percentile'",
   ")",
   "t_mid",
   "=",
   "t_mid",
   "[",
   "np",
   ".",
   "isfinite",
   "(",
   "t_mid",
   ")",
   "]",
   "N_midtimes",
   "=",
   "len",
   "(",
   "t_mid",
   ")",
   "if",
   "t0_fixed",
   ":",
   "t0",
   "=",
   "t0_fixed",
   "elif",
   "isinstance",
   "(",
   "err_t_mid",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "# get the weighted average. then round it to the nearest transit epoch.",
   "t0_avg",
   "=",
   "np",
   ".",
   "average",
   "(",
   "t_mid",
   ",",
   "weights",
   "=",
   "1",
   "/",
   "err_t_mid",
   "**",
   "2",
   ")",
   "t0_options",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "<mask>",
   "(",
   "t_mid",
   ")",
   ",",
   "max",
   "(",
   "t_mid",
   ")",
   "+",
   "period",
   ",",
   "period",
   ")",
   "t0",
   "=",
   "t0_options",
   "[",
   "np",
   ".",
   "argmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "t0_options",
   "-",
   "t0_avg",
   ")",
   ")",
   "]",
   "else",
   ":",
   "if",
   "not",
   "t0_percentile",
   ":",
   "# if there are an odd number of times, take the median time as",
   "# epoch=0.  elif there are an even number of times, take the lower",
   "# of the two middle times as epoch=0.",
   "if",
   "N_midtimes",
   "%",
   "2",
   "==",
   "1",
   ":",
   "t0",
   "=",
   "np",
   ".",
   "median",
   "(",
   "t_mid",
   ")",
   "else",
   ":",
   "t0",
   "=",
   "t_mid",
   "[",
   "int",
   "(",
   "N_midtimes",
   "/",
   "2",
   ")",
   "]",
   "else",
   ":",
   "t0",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "t_mid",
   ")",
   "[",
   "int",
   "(",
   "N_midtimes",
   "*",
   "t0_percentile",
   "/",
   "100",
   ")",
   "]",
   "epoch",
   "=",
   "(",
   "t_mid",
   "-",
   "t0",
   ")",
   "/",
   "period",
   "# do not convert numpy entries to actual ints, because np.nan is float type",
   "int_epoch",
   "=",
   "np",
   ".",
   "round",
   "(",
   "epoch",
   ",",
   "0",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'epochs before rounding'",
   ")",
   "LOGINFO",
   "(",
   "'\\n{:s}'",
   ".",
   "format",
   "(",
   "repr",
   "(",
   "epoch",
   ")",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'epochs after rounding'",
   ")",
   "LOGINFO",
   "(",
   "'\\n{:s}'",
   ".",
   "format",
   "(",
   "repr",
   "(",
   "int_epoch",
   ")",
   ")",
   ")",
   "return",
   "int_epoch",
   ",",
   "t0"
  ]
 },
 {
  "idx": "maxmin-251",
  "nl_tokens": [
   "Returns",
   "bounds",
   "that",
   "encompass",
   "the",
   "intersection",
   "of",
   "the",
   "two",
   ".",
   "If",
   "there",
   "is",
   "no",
   "overlap",
   "between",
   "the",
   "two",
   "None",
   "is",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "intersection",
   "(",
   "self",
   ",",
   "b",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "intersects",
   "(",
   "b",
   ")",
   ":",
   "return",
   "None",
   "mx",
   ",",
   "my",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "x",
   ",",
   "b",
   ".",
   "x",
   ")",
   ",",
   "max",
   "(",
   "self",
   ".",
   "y",
   ",",
   "b",
   ".",
   "y",
   ")",
   "return",
   "Bounds",
   "(",
   "mx",
   ",",
   "my",
   ",",
   "min",
   "(",
   "self",
   ".",
   "x",
   "+",
   "self",
   ".",
   "width",
   ",",
   "b",
   ".",
   "x",
   "+",
   "b",
   ".",
   "width",
   ")",
   "-",
   "mx",
   ",",
   "min",
   "(",
   "self",
   ".",
   "y",
   "+",
   "self",
   ".",
   "height",
   ",",
   "b",
   ".",
   "y",
   "+",
   "b",
   ".",
   "height",
   ")",
   "-",
   "my",
   ")"
  ]
 },
 {
  "idx": "maxmin-252",
  "nl_tokens": [
   "Execute",
   "SAM",
   "on",
   "a",
   "dataset",
   "given",
   "a",
   "skeleton",
   "or",
   "not",
   "."
  ],
  "pl_tokens": [
   "def",
   "predict",
   "(",
   "self",
   ",",
   "data",
   ",",
   "graph",
   "=",
   "None",
   ",",
   "nruns",
   "=",
   "6",
   ",",
   "njobs",
   "=",
   "None",
   ",",
   "gpus",
   "=",
   "0",
   ",",
   "verbose",
   "=",
   "None",
   ",",
   "plot",
   "=",
   "False",
   ",",
   "plot_generated_pair",
   "=",
   "False",
   ",",
   "return_list_results",
   "=",
   "False",
   ")",
   ":",
   "verbose",
   ",",
   "njobs",
   "=",
   "SETTINGS",
   ".",
   "get_default",
   "(",
   "(",
   "'verbose'",
   ",",
   "verbose",
   ")",
   ",",
   "(",
   "'nb_jobs'",
   ",",
   "njobs",
   ")",
   ")",
   "if",
   "njobs",
   "!=",
   "1",
   ":",
   "list_out",
   "=",
   "Parallel",
   "(",
   "n_jobs",
   "=",
   "njobs",
   ")",
   "(",
   "delayed",
   "(",
   "run_SAM",
   ")",
   "(",
   "data",
   ",",
   "skeleton",
   "=",
   "graph",
   ",",
   "lr_gen",
   "=",
   "self",
   ".",
   "lr",
   ",",
   "lr_disc",
   "=",
   "self",
   ".",
   "dlr",
   ",",
   "regul_param",
   "=",
   "self",
   ".",
   "l1",
   ",",
   "nh",
   "=",
   "self",
   ".",
   "nh",
   ",",
   "dnh",
   "=",
   "self",
   ".",
   "dnh",
   ",",
   "gpu",
   "=",
   "bool",
   "(",
   "gpus",
   ")",
   ",",
   "train_epochs",
   "=",
   "self",
   ".",
   "train",
   ",",
   "test_epochs",
   "=",
   "self",
   ".",
   "test",
   ",",
   "batch_size",
   "=",
   "self",
   ".",
   "batchsize",
   ",",
   "plot",
   "=",
   "plot",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   "gpu_no",
   "=",
   "idx",
   "%",
   "<mask>",
   "(",
   "gpus",
   ",",
   "1",
   ")",
   ")",
   "for",
   "idx",
   "in",
   "range",
   "(",
   "nruns",
   ")",
   ")",
   "else",
   ":",
   "list_out",
   "=",
   "[",
   "run_SAM",
   "(",
   "data",
   ",",
   "skeleton",
   "=",
   "graph",
   ",",
   "lr_gen",
   "=",
   "self",
   ".",
   "lr",
   ",",
   "lr_disc",
   "=",
   "self",
   ".",
   "dlr",
   ",",
   "regul_param",
   "=",
   "self",
   ".",
   "l1",
   ",",
   "nh",
   "=",
   "self",
   ".",
   "nh",
   ",",
   "dnh",
   "=",
   "self",
   ".",
   "dnh",
   ",",
   "gpu",
   "=",
   "bool",
   "(",
   "gpus",
   ")",
   ",",
   "train_epochs",
   "=",
   "self",
   ".",
   "train",
   ",",
   "test_epochs",
   "=",
   "self",
   ".",
   "test",
   ",",
   "batch_size",
   "=",
   "self",
   ".",
   "batchsize",
   ",",
   "plot",
   "=",
   "plot",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   "gpu_no",
   "=",
   "0",
   ")",
   "for",
   "idx",
   "in",
   "range",
   "(",
   "nruns",
   ")",
   "]",
   "if",
   "return_list_results",
   ":",
   "return",
   "list_out",
   "else",
   ":",
   "W",
   "=",
   "list_out",
   "[",
   "0",
   "]",
   "for",
   "w",
   "in",
   "list_out",
   "[",
   "1",
   ":",
   "]",
   ":",
   "W",
   "+=",
   "w",
   "W",
   "/=",
   "nruns",
   "return",
   "nx",
   ".",
   "relabel_nodes",
   "(",
   "nx",
   ".",
   "DiGraph",
   "(",
   "W",
   ")",
   ",",
   "{",
   "idx",
   ":",
   "i",
   "for",
   "idx",
   ",",
   "i",
   "in",
   "enumerate",
   "(",
   "data",
   ".",
   "columns",
   ")",
   "}",
   ")"
  ]
 },
 {
  "idx": "maxmin-253",
  "nl_tokens": [
   "Do",
   "various",
   "$",
   "{}",
   "substitutions"
  ],
  "pl_tokens": [
   "def",
   "_substituteCheckPattern",
   "(",
   "self",
   ",",
   "inputString",
   ",",
   "lineNumber",
   ",",
   "lastLineNumber",
   ",",
   "checkFileName",
   ",",
   "isForRegex",
   ")",
   ":",
   "assert",
   "isinstance",
   "(",
   "inputString",
   ",",
   "str",
   ")",
   "assert",
   "isinstance",
   "(",
   "lineNumber",
   ",",
   "int",
   ")",
   "assert",
   "isinstance",
   "(",
   "lastLineNumber",
   ",",
   "int",
   ")",
   "assert",
   "isinstance",
   "(",
   "checkFileName",
   ",",
   "str",
   ")",
   "\"\"\"\n        Do ${LINE}, ${LINE:+N}, and ${LINE:-N} substitutions.\n        To escape prepend with slash\n        \"\"\"",
   "sPattern",
   "=",
   "r'\\$\\{LINE(\\:(?P<sign>\\+|-)(?P<offset>\\d+))?\\}'",
   "matcher",
   "=",
   "re",
   ".",
   "compile",
   "(",
   "sPattern",
   ")",
   "result",
   "=",
   "\"\"",
   "loop",
   "=",
   "True",
   "start",
   "=",
   "0",
   "end",
   "=",
   "len",
   "(",
   "inputString",
   ")",
   "# Not inclusive",
   "while",
   "loop",
   ":",
   "m",
   "=",
   "matcher",
   ".",
   "search",
   "(",
   "inputString",
   ",",
   "start",
   ",",
   "end",
   ")",
   "if",
   "not",
   "m",
   ":",
   "# No match so copy verbatim",
   "_logger",
   ".",
   "debug",
   "(",
   "'Result is currently \"{}\"'",
   ".",
   "format",
   "(",
   "result",
   ")",
   ")",
   "result",
   "+=",
   "inputString",
   "[",
   "start",
   ":",
   "end",
   "]",
   "break",
   "# And we're done :)",
   "else",
   ":",
   "prevIndex",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "m",
   ".",
   "start",
   "(",
   ")",
   "-",
   "1",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Previous character before match is at index {index} \"{char}\"'",
   ".",
   "format",
   "(",
   "index",
   "=",
   "prevIndex",
   ",",
   "char",
   "=",
   "inputString",
   "[",
   "prevIndex",
   "]",
   ")",
   ")",
   "if",
   "inputString",
   "[",
   "prevIndex",
   "]",
   "==",
   "\"\\\\\"",
   ":",
   "# User asked to escape",
   "_logger",
   ".",
   "debug",
   "(",
   "'Substitution is escaped'",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Result is currently \"{}\"'",
   ".",
   "format",
   "(",
   "result",
   ")",
   ")",
   "result",
   "+=",
   "inputString",
   "[",
   "start",
   ":",
   "prevIndex",
   "]",
   "# Copy before escaping character",
   "_logger",
   ".",
   "debug",
   "(",
   "'Result is currently \"{}\"'",
   ".",
   "format",
   "(",
   "result",
   ")",
   ")",
   "result",
   "+=",
   "inputString",
   "[",
   "(",
   "prevIndex",
   "+",
   "1",
   ")",
   ":",
   "m",
   ".",
   "end",
   "(",
   ")",
   "]",
   "# Copy the ${LINE..} verbatim",
   "start",
   "=",
   "min",
   "(",
   "m",
   ".",
   "end",
   "(",
   ")",
   ",",
   "end",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Result is currently \"{}\"'",
   ".",
   "format",
   "(",
   "result",
   ")",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Next search is {start}:{end} = \"{ss}\"'",
   ".",
   "format",
   "(",
   "start",
   "=",
   "start",
   ",",
   "end",
   "=",
   "end",
   ",",
   "ss",
   "=",
   "inputString",
   "[",
   "start",
   ":",
   "end",
   "]",
   ")",
   ")",
   "else",
   ":",
   "_logger",
   ".",
   "debug",
   "(",
   "'Result is currently \"{}\"'",
   ".",
   "format",
   "(",
   "result",
   ")",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Doing subsitution. Found at {begin}:{end} = {ss}'",
   ".",
   "format",
   "(",
   "begin",
   "=",
   "m",
   ".",
   "start",
   "(",
   ")",
   ",",
   "end",
   "=",
   "m",
   ".",
   "end",
   "(",
   ")",
   ",",
   "ss",
   "=",
   "inputString",
   "[",
   "m",
   ".",
   "start",
   "(",
   ")",
   ":",
   "m",
   ".",
   "end",
   "(",
   ")",
   "]",
   ")",
   ")",
   "result",
   "+=",
   "inputString",
   "[",
   "start",
   ":",
   "m",
   ".",
   "start",
   "(",
   ")",
   "]",
   "# Copy before substitution starts",
   "if",
   "m",
   ".",
   "groupdict",
   "(",
   ")",
   "[",
   "'sign'",
   "]",
   "==",
   "None",
   ":",
   "# No offset just substitute line number",
   "_logger",
   ".",
   "debug",
   "(",
   "'No offset'",
   ")",
   "result",
   "+=",
   "str",
   "(",
   "lineNumber",
   ")",
   "else",
   ":",
   "offset",
   "=",
   "1",
   "if",
   "m",
   ".",
   "groupdict",
   "(",
   ")",
   "[",
   "'sign'",
   "]",
   "==",
   "'+'",
   "else",
   "-",
   "1",
   "offset",
   "*=",
   "int",
   "(",
   "m",
   ".",
   "groupdict",
   "(",
   ")",
   "[",
   "'offset'",
   "]",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Offset is {}'",
   ".",
   "format",
   "(",
   "offset",
   ")",
   ")",
   "requestedLineNumber",
   "=",
   "lineNumber",
   "+",
   "offset",
   "_logger",
   ".",
   "debug",
   "(",
   "'Request line number to print is  {}'",
   ".",
   "format",
   "(",
   "requestedLineNumber",
   ")",
   ")",
   "if",
   "requestedLineNumber",
   "<=",
   "0",
   ":",
   "raise",
   "ParsingException",
   "(",
   "'{file}:{line}:{col} offset gives line number < 1'",
   ".",
   "format",
   "(",
   "file",
   "=",
   "checkFileName",
   ",",
   "line",
   "=",
   "lineNumber",
   ",",
   "col",
   "=",
   "m",
   ".",
   "start",
   "(",
   ")",
   ")",
   ")",
   "elif",
   "requestedLineNumber",
   ">",
   "lastLineNumber",
   ":",
   "raise",
   "ParsingException",
   "(",
   "'{file}:{line}:{col} offset gives line number past the end of file'",
   ".",
   "format",
   "(",
   "file",
   "=",
   "checkFileName",
   ",",
   "line",
   "=",
   "lineNumber",
   ",",
   "col",
   "=",
   "m",
   ".",
   "start",
   "(",
   ")",
   ")",
   ")",
   "result",
   "+=",
   "str",
   "(",
   "requestedLineNumber",
   ")",
   "start",
   "=",
   "min",
   "(",
   "m",
   ".",
   "end",
   "(",
   ")",
   ",",
   "end",
   ")",
   "_logger",
   ".",
   "debug",
   "(",
   "'Next search is {start}:{end} = \"{ss}\"'",
   ".",
   "format",
   "(",
   "start",
   "=",
   "start",
   ",",
   "end",
   "=",
   "end",
   ",",
   "ss",
   "=",
   "inputString",
   "[",
   "start",
   ":",
   "end",
   "]",
   ")",
   ")",
   "\"\"\"\n        Do simple ${...} substitutions\n        \"\"\"",
   "# Do ${CHECKFILE_NAME} substitution",
   "basenameCheckFileName",
   "=",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "checkFileName",
   ")",
   "assert",
   "basenameCheckFileName",
   ".",
   "count",
   "(",
   "'\\\\'",
   ")",
   "==",
   "0",
   "result",
   "=",
   "self",
   ".",
   "_simpleSubstitution",
   "(",
   "\"CHECKFILE_NAME\"",
   ",",
   "basenameCheckFileName",
   ",",
   "result",
   ")",
   "# Do ${CHECKFILE_ABS_PATH} substitution",
   "abspathCheckFileName",
   "=",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "checkFileName",
   ")",
   "if",
   "isForRegex",
   ":",
   "# Note slash substitution is for Windows paths (e.g. \"c:\\mything\\foo.txt\") which can break regexes if we don't",
   "# correctly escape them.",
   "abspathCheckFileName",
   "=",
   "abspathCheckFileName",
   ".",
   "replace",
   "(",
   "'\\\\'",
   ",",
   "'\\\\\\\\'",
   ")",
   "result",
   "=",
   "self",
   ".",
   "_simpleSubstitution",
   "(",
   "\"CHECKFILE_ABS_PATH\"",
   ",",
   "abspathCheckFileName",
   ",",
   "result",
   ")",
   "assert",
   "len",
   "(",
   "result",
   ")",
   "!=",
   "0",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-254",
  "nl_tokens": [
   "Use",
   "CGNN",
   "to",
   "create",
   "a",
   "graph",
   "from",
   "scratch",
   ".",
   "All",
   "the",
   "possible",
   "structures",
   "are",
   "tested",
   "which",
   "leads",
   "to",
   "a",
   "super",
   "exponential",
   "complexity",
   ".",
   "It",
   "would",
   "be",
   "preferable",
   "to",
   "start",
   "from",
   "a",
   "graph",
   "skeleton",
   "for",
   "large",
   "graphs",
   "."
  ],
  "pl_tokens": [
   "def",
   "create_graph_from_data",
   "(",
   "self",
   ",",
   "data",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"An exhaustive search of the causal structure of CGNN without\"",
   "\" skeleton is super-exponential in the number of variables.\"",
   ")",
   "# Building all possible candidates:",
   "nb_vars",
   "=",
   "len",
   "(",
   "list",
   "(",
   "data",
   ".",
   "columns",
   ")",
   ")",
   "data",
   "=",
   "scale",
   "(",
   "data",
   ".",
   "values",
   ")",
   ".",
   "astype",
   "(",
   "'float32'",
   ")",
   "candidates",
   "=",
   "[",
   "np",
   ".",
   "reshape",
   "(",
   "np",
   ".",
   "array",
   "(",
   "i",
   ")",
   ",",
   "(",
   "nb_vars",
   ",",
   "nb_vars",
   ")",
   ")",
   "for",
   "i",
   "in",
   "itertools",
   ".",
   "product",
   "(",
   "[",
   "0",
   ",",
   "1",
   "]",
   ",",
   "repeat",
   "=",
   "nb_vars",
   "*",
   "nb_vars",
   ")",
   "if",
   "(",
   "np",
   ".",
   "trace",
   "(",
   "np",
   ".",
   "reshape",
   "(",
   "np",
   ".",
   "array",
   "(",
   "i",
   ")",
   ",",
   "(",
   "nb_vars",
   ",",
   "nb_vars",
   ")",
   ")",
   ")",
   "==",
   "0",
   "and",
   "nx",
   ".",
   "is_directed_acyclic_graph",
   "(",
   "nx",
   ".",
   "DiGraph",
   "(",
   "np",
   ".",
   "reshape",
   "(",
   "np",
   ".",
   "array",
   "(",
   "i",
   ")",
   ",",
   "(",
   "nb_vars",
   ",",
   "nb_vars",
   ")",
   ")",
   ")",
   ")",
   ")",
   "]",
   "warnings",
   ".",
   "warn",
   "(",
   "\"A total of {} graphs will be evaluated.\"",
   ".",
   "format",
   "(",
   "len",
   "(",
   "candidates",
   ")",
   ")",
   ")",
   "scores",
   "=",
   "[",
   "parallel_graph_evaluation",
   "(",
   "data",
   ",",
   "i",
   ",",
   "nh",
   "=",
   "self",
   ".",
   "nh",
   ",",
   "nb_runs",
   "=",
   "self",
   ".",
   "nb_runs",
   ",",
   "gpu",
   "=",
   "self",
   ".",
   "gpu",
   ",",
   "nb_jobs",
   "=",
   "self",
   ".",
   "nb_jobs",
   ",",
   "lr",
   "=",
   "self",
   ".",
   "lr",
   ",",
   "train_epochs",
   "=",
   "self",
   ".",
   "train_epochs",
   ",",
   "test_epochs",
   "=",
   "self",
   ".",
   "test_epochs",
   ",",
   "verbose",
   "=",
   "self",
   ".",
   "verbose",
   ")",
   "for",
   "i",
   "in",
   "candidates",
   "]",
   "final_candidate",
   "=",
   "candidates",
   "[",
   "scores",
   ".",
   "index",
   "(",
   "<mask>",
   "(",
   "scores",
   ")",
   ")",
   "]",
   "output",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "final_candidate",
   ".",
   "shape",
   ")",
   "# Retrieve the confidence score on each edge.",
   "for",
   "(",
   "i",
   ",",
   "j",
   ")",
   ",",
   "x",
   "in",
   "np",
   ".",
   "ndenumerate",
   "(",
   "final_candidate",
   ")",
   ":",
   "if",
   "x",
   ">",
   "0",
   ":",
   "cand",
   "=",
   "final_candidate",
   "cand",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "0",
   "output",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "min",
   "(",
   "scores",
   ")",
   "-",
   "scores",
   "[",
   "candidates",
   ".",
   "index",
   "(",
   "cand",
   ")",
   "]",
   "return",
   "nx",
   ".",
   "DiGraph",
   "(",
   "candidates",
   "[",
   "output",
   "]",
   ",",
   "{",
   "idx",
   ":",
   "i",
   "for",
   "idx",
   ",",
   "i",
   "in",
   "enumerate",
   "(",
   "data",
   ".",
   "columns",
   ")",
   "}",
   ")"
  ]
 },
 {
  "idx": "maxmin-255",
  "nl_tokens": [
   "returns",
   "tuple",
   "(",
   "list",
   "value",
   ")"
  ],
  "pl_tokens": [
   "def",
   "obtain_content_ranges",
   "(",
   "rangetext",
   ",",
   "filesize",
   ")",
   ":",
   "listReturn",
   "=",
   "[",
   "]",
   "seqRanges",
   "=",
   "rangetext",
   ".",
   "split",
   "(",
   "\",\"",
   ")",
   "for",
   "subrange",
   "in",
   "seqRanges",
   ":",
   "matched",
   "=",
   "False",
   "if",
   "not",
   "matched",
   ":",
   "mObj",
   "=",
   "reByteRangeSpecifier",
   ".",
   "search",
   "(",
   "subrange",
   ")",
   "if",
   "mObj",
   ":",
   "firstpos",
   "=",
   "int",
   "(",
   "mObj",
   ".",
   "group",
   "(",
   "2",
   ")",
   ")",
   "if",
   "mObj",
   ".",
   "group",
   "(",
   "3",
   ")",
   "==",
   "\"\"",
   ":",
   "lastpos",
   "=",
   "filesize",
   "-",
   "1",
   "else",
   ":",
   "lastpos",
   "=",
   "int",
   "(",
   "mObj",
   ".",
   "group",
   "(",
   "3",
   ")",
   ")",
   "if",
   "firstpos",
   "<=",
   "lastpos",
   "and",
   "firstpos",
   "<",
   "filesize",
   ":",
   "if",
   "lastpos",
   ">=",
   "filesize",
   ":",
   "lastpos",
   "=",
   "filesize",
   "-",
   "1",
   "listReturn",
   ".",
   "append",
   "(",
   "(",
   "firstpos",
   ",",
   "lastpos",
   ")",
   ")",
   "matched",
   "=",
   "True",
   "if",
   "not",
   "matched",
   ":",
   "mObj",
   "=",
   "reSuffixByteRangeSpecifier",
   ".",
   "search",
   "(",
   "subrange",
   ")",
   "if",
   "mObj",
   ":",
   "firstpos",
   "=",
   "filesize",
   "-",
   "int",
   "(",
   "mObj",
   ".",
   "group",
   "(",
   "2",
   ")",
   ")",
   "if",
   "firstpos",
   "<",
   "0",
   ":",
   "firstpos",
   "=",
   "0",
   "lastpos",
   "=",
   "filesize",
   "-",
   "1",
   "listReturn",
   ".",
   "append",
   "(",
   "(",
   "firstpos",
   ",",
   "lastpos",
   ")",
   ")",
   "matched",
   "=",
   "True",
   "# consolidate ranges",
   "listReturn",
   ".",
   "sort",
   "(",
   ")",
   "listReturn2",
   "=",
   "[",
   "]",
   "totallength",
   "=",
   "0",
   "while",
   "len",
   "(",
   "listReturn",
   ")",
   ">",
   "0",
   ":",
   "(",
   "rfirstpos",
   ",",
   "rlastpos",
   ")",
   "=",
   "listReturn",
   ".",
   "pop",
   "(",
   ")",
   "counter",
   "=",
   "len",
   "(",
   "listReturn",
   ")",
   "while",
   "counter",
   ">",
   "0",
   ":",
   "(",
   "nfirstpos",
   ",",
   "nlastpos",
   ")",
   "=",
   "listReturn",
   "[",
   "counter",
   "-",
   "1",
   "]",
   "if",
   "nlastpos",
   "<",
   "rfirstpos",
   "-",
   "1",
   "or",
   "nfirstpos",
   ">",
   "nlastpos",
   "+",
   "1",
   ":",
   "pass",
   "else",
   ":",
   "rfirstpos",
   "=",
   "<mask>",
   "(",
   "rfirstpos",
   ",",
   "nfirstpos",
   ")",
   "rlastpos",
   "=",
   "max",
   "(",
   "rlastpos",
   ",",
   "nlastpos",
   ")",
   "del",
   "listReturn",
   "[",
   "counter",
   "-",
   "1",
   "]",
   "counter",
   "=",
   "counter",
   "-",
   "1",
   "listReturn2",
   ".",
   "append",
   "(",
   "(",
   "rfirstpos",
   ",",
   "rlastpos",
   ",",
   "rlastpos",
   "-",
   "rfirstpos",
   "+",
   "1",
   ")",
   ")",
   "totallength",
   "=",
   "totallength",
   "+",
   "rlastpos",
   "-",
   "rfirstpos",
   "+",
   "1",
   "return",
   "(",
   "listReturn2",
   ",",
   "totallength",
   ")"
  ]
 },
 {
  "idx": "maxmin-256",
  "nl_tokens": [
   "Run",
   "the",
   "Hot",
   "Gym",
   "example",
   "."
  ],
  "pl_tokens": [
   "def",
   "runHotgym",
   "(",
   "numRecords",
   ")",
   ":",
   "# Create a data source for the network.",
   "dataSource",
   "=",
   "FileRecordStream",
   "(",
   "streamID",
   "=",
   "_INPUT_FILE_PATH",
   ")",
   "numRecords",
   "=",
   "<mask>",
   "(",
   "numRecords",
   ",",
   "dataSource",
   ".",
   "getDataRowCount",
   "(",
   ")",
   ")",
   "network",
   "=",
   "createNetwork",
   "(",
   "dataSource",
   ")",
   "# Set predicted field",
   "network",
   ".",
   "regions",
   "[",
   "\"sensor\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"predictedField\"",
   ",",
   "\"consumption\"",
   ")",
   "# Enable learning for all regions.",
   "network",
   ".",
   "regions",
   "[",
   "\"SP\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"learningMode\"",
   ",",
   "1",
   ")",
   "network",
   ".",
   "regions",
   "[",
   "\"TM\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"learningMode\"",
   ",",
   "1",
   ")",
   "network",
   ".",
   "regions",
   "[",
   "\"classifier\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"learningMode\"",
   ",",
   "1",
   ")",
   "# Enable inference for all regions.",
   "network",
   ".",
   "regions",
   "[",
   "\"SP\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"inferenceMode\"",
   ",",
   "1",
   ")",
   "network",
   ".",
   "regions",
   "[",
   "\"TM\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"inferenceMode\"",
   ",",
   "1",
   ")",
   "network",
   ".",
   "regions",
   "[",
   "\"classifier\"",
   "]",
   ".",
   "setParameter",
   "(",
   "\"inferenceMode\"",
   ",",
   "1",
   ")",
   "results",
   "=",
   "[",
   "]",
   "N",
   "=",
   "1",
   "# Run the network, N iterations at a time.",
   "for",
   "iteration",
   "in",
   "range",
   "(",
   "0",
   ",",
   "numRecords",
   ",",
   "N",
   ")",
   ":",
   "network",
   ".",
   "run",
   "(",
   "N",
   ")",
   "predictionResults",
   "=",
   "getPredictionResults",
   "(",
   "network",
   ",",
   "\"classifier\"",
   ")",
   "oneStep",
   "=",
   "predictionResults",
   "[",
   "1",
   "]",
   "[",
   "\"predictedValue\"",
   "]",
   "oneStepConfidence",
   "=",
   "predictionResults",
   "[",
   "1",
   "]",
   "[",
   "\"predictionConfidence\"",
   "]",
   "fiveStep",
   "=",
   "predictionResults",
   "[",
   "5",
   "]",
   "[",
   "\"predictedValue\"",
   "]",
   "fiveStepConfidence",
   "=",
   "predictionResults",
   "[",
   "5",
   "]",
   "[",
   "\"predictionConfidence\"",
   "]",
   "result",
   "=",
   "(",
   "oneStep",
   ",",
   "oneStepConfidence",
   "*",
   "100",
   ",",
   "fiveStep",
   ",",
   "fiveStepConfidence",
   "*",
   "100",
   ")",
   "print",
   "\"1-step: {:16} ({:4.4}%)\\t 5-step: {:16} ({:4.4}%)\"",
   ".",
   "format",
   "(",
   "*",
   "result",
   ")",
   "results",
   ".",
   "append",
   "(",
   "result",
   ")",
   "return",
   "results"
  ]
 },
 {
  "idx": "maxmin-257",
  "nl_tokens": [
   "Sample",
   "minibatch",
   "of",
   "size",
   "batch_size",
   "."
  ],
  "pl_tokens": [
   "def",
   "sample_minibatch",
   "(",
   "self",
   ",",
   "batch_size",
   ")",
   ":",
   "pool_size",
   "=",
   "len",
   "(",
   "self",
   ")",
   "if",
   "pool_size",
   "==",
   "0",
   ":",
   "return",
   "[",
   "]",
   "delta_p",
   "=",
   "self",
   ".",
   "_memory",
   "[",
   "0",
   "]",
   "/",
   "batch_size",
   "chosen_idx",
   "=",
   "[",
   "]",
   "# if all priorities sum to ~0  choose randomly otherwise random sample",
   "if",
   "abs",
   "(",
   "self",
   ".",
   "_memory",
   "[",
   "0",
   "]",
   ")",
   "<",
   "util",
   ".",
   "epsilon",
   ":",
   "chosen_idx",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "self",
   ".",
   "_capacity",
   "-",
   "1",
   ",",
   "self",
   ".",
   "_capacity",
   "-",
   "1",
   "+",
   "len",
   "(",
   "self",
   ")",
   ",",
   "size",
   "=",
   "batch_size",
   ")",
   ".",
   "tolist",
   "(",
   ")",
   "else",
   ":",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "batch_size",
   ")",
   ":",
   "lower",
   "=",
   "<mask>",
   "(",
   "i",
   "*",
   "delta_p",
   ",",
   "0",
   ")",
   "upper",
   "=",
   "min",
   "(",
   "(",
   "i",
   "+",
   "1",
   ")",
   "*",
   "delta_p",
   ",",
   "self",
   ".",
   "_memory",
   "[",
   "0",
   "]",
   ")",
   "p",
   "=",
   "random",
   ".",
   "uniform",
   "(",
   "lower",
   ",",
   "upper",
   ")",
   "chosen_idx",
   ".",
   "append",
   "(",
   "self",
   ".",
   "_sample_with_priority",
   "(",
   "p",
   ")",
   ")",
   "return",
   "[",
   "(",
   "i",
   ",",
   "self",
   ".",
   "_memory",
   "[",
   "i",
   "]",
   ")",
   "for",
   "i",
   "in",
   "chosen_idx",
   "]"
  ]
 },
 {
  "idx": "maxmin-258",
  "nl_tokens": [
   "Counts",
   "the",
   "number",
   "of",
   "real",
   "volumes",
   "in",
   "Vs",
   "and",
   "determines",
   "what",
   "to",
   "do",
   ".",
   "If",
   "there",
   "is",
   "only",
   "one",
   "real",
   "volume",
   "the",
   "method",
   "set_properties_from_solution",
   "is",
   "called",
   "with",
   "it",
   ".",
   "If",
   "there",
   "are",
   "two",
   "real",
   "volumes",
   "set_properties_from_solution",
   "is",
   "called",
   "once",
   "with",
   "each",
   "volume",
   ".",
   "The",
   "phase",
   "is",
   "returned",
   "by",
   "set_properties_from_solution",
   "and",
   "the",
   "volumes",
   "is",
   "set",
   "to",
   "either",
   "V_l",
   "or",
   "V_g",
   "as",
   "appropriate",
   "."
  ],
  "pl_tokens": [
   "def",
   "set_from_PT",
   "(",
   "self",
   ",",
   "Vs",
   ")",
   ":",
   "# All roots will have some imaginary component; ignore them if > 1E-9",
   "good_roots",
   "=",
   "[",
   "]",
   "bad_roots",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "Vs",
   ":",
   "j",
   "=",
   "i",
   ".",
   "real",
   "if",
   "abs",
   "(",
   "i",
   ".",
   "imag",
   ")",
   ">",
   "1E-9",
   "or",
   "j",
   "<",
   "0",
   ":",
   "bad_roots",
   ".",
   "append",
   "(",
   "i",
   ")",
   "else",
   ":",
   "good_roots",
   ".",
   "append",
   "(",
   "j",
   ")",
   "if",
   "len",
   "(",
   "bad_roots",
   ")",
   "==",
   "2",
   ":",
   "V",
   "=",
   "good_roots",
   "[",
   "0",
   "]",
   "self",
   ".",
   "phase",
   "=",
   "self",
   ".",
   "set_properties_from_solution",
   "(",
   "self",
   ".",
   "T",
   ",",
   "self",
   ".",
   "P",
   ",",
   "V",
   ",",
   "self",
   ".",
   "b",
   ",",
   "self",
   ".",
   "delta",
   ",",
   "self",
   ".",
   "epsilon",
   ",",
   "self",
   ".",
   "a_alpha",
   ",",
   "self",
   ".",
   "da_alpha_dT",
   ",",
   "self",
   ".",
   "d2a_alpha_dT2",
   ")",
   "if",
   "self",
   ".",
   "phase",
   "==",
   "'l'",
   ":",
   "self",
   ".",
   "V_l",
   "=",
   "V",
   "else",
   ":",
   "self",
   ".",
   "V_g",
   "=",
   "V",
   "else",
   ":",
   "# Even in the case of three real roots, it is still the min/max that make sense",
   "self",
   ".",
   "V_l",
   ",",
   "self",
   ".",
   "V_g",
   "=",
   "<mask>",
   "(",
   "good_roots",
   ")",
   ",",
   "max",
   "(",
   "good_roots",
   ")",
   "[",
   "self",
   ".",
   "set_properties_from_solution",
   "(",
   "self",
   ".",
   "T",
   ",",
   "self",
   ".",
   "P",
   ",",
   "V",
   ",",
   "self",
   ".",
   "b",
   ",",
   "self",
   ".",
   "delta",
   ",",
   "self",
   ".",
   "epsilon",
   ",",
   "self",
   ".",
   "a_alpha",
   ",",
   "self",
   ".",
   "da_alpha_dT",
   ",",
   "self",
   ".",
   "d2a_alpha_dT2",
   ")",
   "for",
   "V",
   "in",
   "[",
   "self",
   ".",
   "V_l",
   ",",
   "self",
   ".",
   "V_g",
   "]",
   "]",
   "self",
   ".",
   "phase",
   "=",
   "'l/g'"
  ]
 },
 {
  "idx": "maxmin-259",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__update_order_seed",
   "(",
   "self",
   ",",
   "optic_descriptor",
   ",",
   "neighbors_descriptors",
   ",",
   "order_seed",
   ")",
   ":",
   "for",
   "neighbor_descriptor",
   "in",
   "neighbors_descriptors",
   ":",
   "index_neighbor",
   "=",
   "neighbor_descriptor",
   "[",
   "0",
   "]",
   "current_reachable_distance",
   "=",
   "neighbor_descriptor",
   "[",
   "1",
   "]",
   "if",
   "self",
   ".",
   "__optics_objects",
   "[",
   "index_neighbor",
   "]",
   ".",
   "processed",
   "is",
   "not",
   "True",
   ":",
   "reachable_distance",
   "=",
   "<mask>",
   "(",
   "current_reachable_distance",
   ",",
   "optic_descriptor",
   ".",
   "core_distance",
   ")",
   "if",
   "self",
   ".",
   "__optics_objects",
   "[",
   "index_neighbor",
   "]",
   ".",
   "reachability_distance",
   "is",
   "None",
   ":",
   "self",
   ".",
   "__optics_objects",
   "[",
   "index_neighbor",
   "]",
   ".",
   "reachability_distance",
   "=",
   "reachable_distance",
   "# insert element in queue O(n) - worst case.\r",
   "index_insertion",
   "=",
   "len",
   "(",
   "order_seed",
   ")",
   "for",
   "index_seed",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "order_seed",
   ")",
   ")",
   ":",
   "if",
   "reachable_distance",
   "<",
   "order_seed",
   "[",
   "index_seed",
   "]",
   ".",
   "reachability_distance",
   ":",
   "index_insertion",
   "=",
   "index_seed",
   "break",
   "order_seed",
   ".",
   "insert",
   "(",
   "index_insertion",
   ",",
   "self",
   ".",
   "__optics_objects",
   "[",
   "index_neighbor",
   "]",
   ")",
   "else",
   ":",
   "if",
   "reachable_distance",
   "<",
   "self",
   ".",
   "__optics_objects",
   "[",
   "index_neighbor",
   "]",
   ".",
   "reachability_distance",
   ":",
   "self",
   ".",
   "__optics_objects",
   "[",
   "index_neighbor",
   "]",
   ".",
   "reachability_distance",
   "=",
   "reachable_distance",
   "order_seed",
   ".",
   "sort",
   "(",
   "key",
   "=",
   "lambda",
   "obj",
   ":",
   "obj",
   ".",
   "reachability_distance",
   ")"
  ]
 },
 {
  "idx": "maxmin-260",
  "nl_tokens": [
   "Read",
   "points",
   "from",
   "istream",
   "and",
   "output",
   "to",
   "ostream",
   "."
  ],
  "pl_tokens": [
   "def",
   "consume",
   "(",
   "self",
   ",",
   "istream",
   ",",
   "ostream",
   ",",
   "batch",
   "=",
   "False",
   ")",
   ":",
   "datapoints",
   "=",
   "[",
   "]",
   "# List of 2-tuples",
   "if",
   "batch",
   ":",
   "sleep",
   "=",
   "<mask>",
   "(",
   "0.01",
   ",",
   "self",
   ".",
   "option",
   ".",
   "sleep",
   ")",
   "fd",
   "=",
   "istream",
   ".",
   "fileno",
   "(",
   ")",
   "while",
   "True",
   ":",
   "try",
   ":",
   "if",
   "select",
   ".",
   "select",
   "(",
   "[",
   "fd",
   "]",
   ",",
   "[",
   "]",
   ",",
   "[",
   "]",
   ",",
   "sleep",
   ")",
   ":",
   "try",
   ":",
   "line",
   "=",
   "istream",
   ".",
   "readline",
   "(",
   ")",
   "if",
   "line",
   "==",
   "''",
   ":",
   "break",
   "datapoints",
   ".",
   "append",
   "(",
   "self",
   ".",
   "consume_line",
   "(",
   "line",
   ")",
   ")",
   "except",
   "ValueError",
   ":",
   "continue",
   "if",
   "self",
   ".",
   "option",
   ".",
   "sort_by_column",
   ":",
   "datapoints",
   "=",
   "sorted",
   "(",
   "datapoints",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "self",
   ".",
   "option",
   ".",
   "sort_by_column",
   "-",
   "1",
   ")",
   ")",
   "if",
   "len",
   "(",
   "datapoints",
   ")",
   ">",
   "1",
   ":",
   "datapoints",
   "=",
   "datapoints",
   "[",
   "-",
   "self",
   ".",
   "maximum_points",
   ":",
   "]",
   "self",
   ".",
   "update",
   "(",
   "[",
   "dp",
   "[",
   "0",
   "]",
   "for",
   "dp",
   "in",
   "datapoints",
   "]",
   ",",
   "[",
   "dp",
   "[",
   "1",
   "]",
   "for",
   "dp",
   "in",
   "datapoints",
   "]",
   ")",
   "self",
   ".",
   "render",
   "(",
   "ostream",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "sleep",
   ")",
   "except",
   "KeyboardInterrupt",
   ":",
   "break",
   "else",
   ":",
   "for",
   "line",
   "in",
   "istream",
   ":",
   "try",
   ":",
   "datapoints",
   ".",
   "append",
   "(",
   "self",
   ".",
   "consume_line",
   "(",
   "line",
   ")",
   ")",
   "except",
   "ValueError",
   ":",
   "pass",
   "if",
   "self",
   ".",
   "option",
   ".",
   "sort_by_column",
   ":",
   "datapoints",
   "=",
   "sorted",
   "(",
   "datapoints",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "self",
   ".",
   "option",
   ".",
   "sort_by_column",
   "-",
   "1",
   ")",
   ")",
   "self",
   ".",
   "update",
   "(",
   "[",
   "dp",
   "[",
   "0",
   "]",
   "for",
   "dp",
   "in",
   "datapoints",
   "]",
   ",",
   "[",
   "dp",
   "[",
   "1",
   "]",
   "for",
   "dp",
   "in",
   "datapoints",
   "]",
   ")",
   "self",
   ".",
   "render",
   "(",
   "ostream",
   ")"
  ]
 },
 {
  "idx": "maxmin-261",
  "nl_tokens": [
   "Plots",
   "timespans",
   "and",
   "directions",
   "of",
   "a",
   "sample",
   "of",
   "round",
   "trip",
   "trades",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_round_trip_lifetimes",
   "(",
   "round_trips",
   ",",
   "disp_amount",
   "=",
   "16",
   ",",
   "lsize",
   "=",
   "18",
   ",",
   "ax",
   "=",
   "None",
   ")",
   ":",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   ")",
   "symbols_sample",
   "=",
   "round_trips",
   ".",
   "symbol",
   ".",
   "unique",
   "(",
   ")",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "1",
   ")",
   "sample",
   "=",
   "np",
   ".",
   "random",
   ".",
   "choice",
   "(",
   "round_trips",
   ".",
   "symbol",
   ".",
   "unique",
   "(",
   ")",
   ",",
   "replace",
   "=",
   "False",
   ",",
   "size",
   "=",
   "<mask>",
   "(",
   "disp_amount",
   ",",
   "len",
   "(",
   "symbols_sample",
   ")",
   ")",
   ")",
   "sample_round_trips",
   "=",
   "round_trips",
   "[",
   "round_trips",
   ".",
   "symbol",
   ".",
   "isin",
   "(",
   "sample",
   ")",
   "]",
   "symbol_idx",
   "=",
   "pd",
   ".",
   "Series",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "sample",
   ")",
   ")",
   ",",
   "index",
   "=",
   "sample",
   ")",
   "for",
   "symbol",
   ",",
   "sym_round_trips",
   "in",
   "sample_round_trips",
   ".",
   "groupby",
   "(",
   "'symbol'",
   ")",
   ":",
   "for",
   "_",
   ",",
   "row",
   "in",
   "sym_round_trips",
   ".",
   "iterrows",
   "(",
   ")",
   ":",
   "c",
   "=",
   "'b'",
   "if",
   "row",
   ".",
   "long",
   "else",
   "'r'",
   "y_ix",
   "=",
   "symbol_idx",
   "[",
   "symbol",
   "]",
   "+",
   "0.05",
   "ax",
   ".",
   "plot",
   "(",
   "[",
   "row",
   "[",
   "'open_dt'",
   "]",
   ",",
   "row",
   "[",
   "'close_dt'",
   "]",
   "]",
   ",",
   "[",
   "y_ix",
   ",",
   "y_ix",
   "]",
   ",",
   "color",
   "=",
   "c",
   ",",
   "linewidth",
   "=",
   "lsize",
   ",",
   "solid_capstyle",
   "=",
   "'butt'",
   ")",
   "ax",
   ".",
   "set_yticks",
   "(",
   "range",
   "(",
   "disp_amount",
   ")",
   ")",
   "ax",
   ".",
   "set_yticklabels",
   "(",
   "[",
   "utils",
   ".",
   "format_asset",
   "(",
   "s",
   ")",
   "for",
   "s",
   "in",
   "sample",
   "]",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "(",
   "-",
   "0.5",
   ",",
   "min",
   "(",
   "len",
   "(",
   "sample",
   ")",
   ",",
   "disp_amount",
   ")",
   "-",
   "0.5",
   ")",
   ")",
   "blue",
   "=",
   "patches",
   ".",
   "Rectangle",
   "(",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "1",
   ",",
   "1",
   ",",
   "color",
   "=",
   "'b'",
   ",",
   "label",
   "=",
   "'Long'",
   ")",
   "red",
   "=",
   "patches",
   ".",
   "Rectangle",
   "(",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "1",
   ",",
   "1",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "label",
   "=",
   "'Short'",
   ")",
   "leg",
   "=",
   "ax",
   ".",
   "legend",
   "(",
   "handles",
   "=",
   "[",
   "blue",
   ",",
   "red",
   "]",
   ",",
   "loc",
   "=",
   "'lower left'",
   ",",
   "frameon",
   "=",
   "True",
   ",",
   "framealpha",
   "=",
   "0.5",
   ")",
   "leg",
   ".",
   "get_frame",
   "(",
   ")",
   ".",
   "set_edgecolor",
   "(",
   "'black'",
   ")",
   "ax",
   ".",
   "grid",
   "(",
   "False",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-262",
  "nl_tokens": [
   "chunkMs",
   "should",
   "be",
   "~50",
   "ms",
   "or",
   "greater",
   ".",
   "bin",
   "sizes",
   "must",
   "be",
   "equal",
   "to",
   "or",
   "multiples",
   "of",
   "the",
   "data",
   "resolution",
   ".",
   "transients",
   "smaller",
   "than",
   "the",
   "expected",
   "RMS",
   "will",
   "be",
   "silenced",
   "."
  ],
  "pl_tokens": [
   "def",
   "phasicTonic",
   "(",
   "self",
   ",",
   "m1",
   "=",
   "None",
   ",",
   "m2",
   "=",
   "None",
   ",",
   "chunkMs",
   "=",
   "50",
   ",",
   "quietPercentile",
   "=",
   "10",
   ",",
   "histResolution",
   "=",
   ".5",
   ",",
   "plotToo",
   "=",
   "False",
   ",",
   "rmsExpected",
   "=",
   "5",
   ")",
   ":",
   "# prepare sectioning values to be used later",
   "m1",
   "=",
   "0",
   "if",
   "m1",
   "is",
   "None",
   "else",
   "m1",
   "*",
   "self",
   ".",
   "pointsPerSec",
   "m2",
   "=",
   "len",
   "(",
   "abf",
   ".",
   "sweepY",
   ")",
   "if",
   "m2",
   "is",
   "None",
   "else",
   "m2",
   "*",
   "self",
   ".",
   "pointsPerSec",
   "m1",
   ",",
   "m2",
   "=",
   "int",
   "(",
   "m1",
   ")",
   ",",
   "int",
   "(",
   "m2",
   ")",
   "# prepare histogram values to be used later",
   "padding",
   "=",
   "200",
   "# pA or mV of maximum expected deviation",
   "chunkPoints",
   "=",
   "int",
   "(",
   "chunkMs",
   "*",
   "self",
   ".",
   "pointsPerMs",
   ")",
   "histBins",
   "=",
   "int",
   "(",
   "(",
   "padding",
   "*",
   "2",
   ")",
   "/",
   "histResolution",
   ")",
   "# center the data at 0 using peak histogram, not the mean",
   "Y",
   "=",
   "self",
   ".",
   "sweepY",
   "[",
   "m1",
   ":",
   "m2",
   "]",
   "hist",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "Y",
   ",",
   "bins",
   "=",
   "2",
   "*",
   "padding",
   ")",
   "Yoffset",
   "=",
   "bins",
   "[",
   "np",
   ".",
   "where",
   "(",
   "hist",
   "==",
   "<mask>",
   "(",
   "hist",
   ")",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "]",
   "Y",
   "=",
   "Y",
   "-",
   "Yoffset",
   "# we don't have to, but PDF math is easier",
   "# calculate all histogram",
   "nChunks",
   "=",
   "int",
   "(",
   "len",
   "(",
   "Y",
   ")",
   "/",
   "chunkPoints",
   ")",
   "hist",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "Y",
   ",",
   "bins",
   "=",
   "histBins",
   ",",
   "range",
   "=",
   "(",
   "-",
   "padding",
   ",",
   "padding",
   ")",
   ")",
   "hist",
   "=",
   "hist",
   "/",
   "len",
   "(",
   "Y",
   ")",
   "# count as a fraction of total",
   "Xs",
   "=",
   "bins",
   "[",
   "1",
   ":",
   "]",
   "# get baseline data from chunks with smallest variance",
   "chunks",
   "=",
   "np",
   ".",
   "reshape",
   "(",
   "Y",
   "[",
   ":",
   "nChunks",
   "*",
   "chunkPoints",
   "]",
   ",",
   "(",
   "nChunks",
   ",",
   "chunkPoints",
   ")",
   ")",
   "variances",
   "=",
   "np",
   ".",
   "var",
   "(",
   "chunks",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "percentiles",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "len",
   "(",
   "variances",
   ")",
   ")",
   "for",
   "i",
   ",",
   "variance",
   "in",
   "enumerate",
   "(",
   "variances",
   ")",
   ":",
   "percentiles",
   "[",
   "i",
   "]",
   "=",
   "sorted",
   "(",
   "variances",
   ")",
   ".",
   "index",
   "(",
   "variance",
   ")",
   "/",
   "len",
   "(",
   "variances",
   ")",
   "*",
   "100",
   "blData",
   "=",
   "chunks",
   "[",
   "np",
   ".",
   "where",
   "(",
   "percentiles",
   "<=",
   "quietPercentile",
   ")",
   "[",
   "0",
   "]",
   "]",
   ".",
   "flatten",
   "(",
   ")",
   "# generate the standard curve and pull it to the histogram height",
   "sigma",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "var",
   "(",
   "blData",
   ")",
   ")",
   "center",
   "=",
   "np",
   ".",
   "average",
   "(",
   "blData",
   ")",
   "+",
   "histResolution",
   "/",
   "2",
   "blCurve",
   "=",
   "mlab",
   ".",
   "normpdf",
   "(",
   "Xs",
   ",",
   "center",
   ",",
   "sigma",
   ")",
   "blCurve",
   "=",
   "blCurve",
   "*",
   "max",
   "(",
   "hist",
   ")",
   "/",
   "max",
   "(",
   "blCurve",
   ")",
   "# determine the phasic current by subtracting-out the baseline",
   "diff",
   "=",
   "hist",
   "-",
   "blCurve",
   "# manually zero-out data which we expect to be within the RMS range",
   "ignrCenter",
   "=",
   "len",
   "(",
   "Xs",
   ")",
   "/",
   "2",
   "ignrPad",
   "=",
   "rmsExpected",
   "/",
   "histResolution",
   "ignr1",
   ",",
   "ignt2",
   "=",
   "int",
   "(",
   "ignrCenter",
   "-",
   "ignrPad",
   ")",
   ",",
   "int",
   "(",
   "ignrCenter",
   "+",
   "ignrPad",
   ")",
   "diff",
   "[",
   "ignr1",
   ":",
   "ignt2",
   "]",
   "=",
   "0",
   "return",
   "diff",
   "/",
   "len",
   "(",
   "Y",
   ")",
   "*",
   "abf",
   ".",
   "pointsPerSec"
  ]
 },
 {
  "idx": "maxmin-263",
  "nl_tokens": [
   "r",
   "Computes",
   "power",
   "spectral",
   "density",
   "given",
   "ARMA",
   "values",
   "."
  ],
  "pl_tokens": [
   "def",
   "arma2psd",
   "(",
   "A",
   "=",
   "None",
   ",",
   "B",
   "=",
   "None",
   ",",
   "rho",
   "=",
   "1.",
   ",",
   "T",
   "=",
   "1.",
   ",",
   "NFFT",
   "=",
   "4096",
   ",",
   "sides",
   "=",
   "'default'",
   ",",
   "norm",
   "=",
   "False",
   ")",
   ":",
   "if",
   "NFFT",
   "is",
   "None",
   ":",
   "NFFT",
   "=",
   "4096",
   "if",
   "A",
   "is",
   "None",
   "and",
   "B",
   "is",
   "None",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Either AR or MA model must be provided\"",
   ")",
   "psd",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "NFFT",
   ",",
   "dtype",
   "=",
   "complex",
   ")",
   "if",
   "A",
   "is",
   "not",
   "None",
   ":",
   "ip",
   "=",
   "len",
   "(",
   "A",
   ")",
   "den",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "NFFT",
   ",",
   "dtype",
   "=",
   "complex",
   ")",
   "den",
   "[",
   "0",
   "]",
   "=",
   "1.",
   "+",
   "0j",
   "for",
   "k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "ip",
   ")",
   ":",
   "den",
   "[",
   "k",
   "+",
   "1",
   "]",
   "=",
   "A",
   "[",
   "k",
   "]",
   "denf",
   "=",
   "fft",
   "(",
   "den",
   ",",
   "NFFT",
   ")",
   "if",
   "B",
   "is",
   "not",
   "None",
   ":",
   "iq",
   "=",
   "len",
   "(",
   "B",
   ")",
   "num",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "NFFT",
   ",",
   "dtype",
   "=",
   "complex",
   ")",
   "num",
   "[",
   "0",
   "]",
   "=",
   "1.",
   "+",
   "0j",
   "for",
   "k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "iq",
   ")",
   ":",
   "num",
   "[",
   "k",
   "+",
   "1",
   "]",
   "=",
   "B",
   "[",
   "k",
   "]",
   "numf",
   "=",
   "fft",
   "(",
   "num",
   ",",
   "NFFT",
   ")",
   "# Changed in version 0.6.9 (divided by T instead of multiply)",
   "if",
   "A",
   "is",
   "not",
   "None",
   "and",
   "B",
   "is",
   "not",
   "None",
   ":",
   "psd",
   "=",
   "rho",
   "/",
   "T",
   "*",
   "abs",
   "(",
   "numf",
   ")",
   "**",
   "2.",
   "/",
   "abs",
   "(",
   "denf",
   ")",
   "**",
   "2.",
   "elif",
   "A",
   "is",
   "not",
   "None",
   ":",
   "psd",
   "=",
   "rho",
   "/",
   "T",
   "/",
   "abs",
   "(",
   "denf",
   ")",
   "**",
   "2.",
   "elif",
   "B",
   "is",
   "not",
   "None",
   ":",
   "psd",
   "=",
   "rho",
   "/",
   "T",
   "*",
   "abs",
   "(",
   "numf",
   ")",
   "**",
   "2.",
   "psd",
   "=",
   "np",
   ".",
   "real",
   "(",
   "psd",
   ")",
   "# The PSD is a twosided PSD.",
   "# to obtain the centerdc",
   "if",
   "sides",
   "!=",
   "'default'",
   ":",
   "from",
   ".",
   "import",
   "tools",
   "assert",
   "sides",
   "in",
   "[",
   "'centerdc'",
   "]",
   "if",
   "sides",
   "==",
   "'centerdc'",
   ":",
   "psd",
   "=",
   "tools",
   ".",
   "twosided_2_centerdc",
   "(",
   "psd",
   ")",
   "if",
   "norm",
   "==",
   "True",
   ":",
   "psd",
   "/=",
   "<mask>",
   "(",
   "psd",
   ")",
   "return",
   "psd"
  ]
 },
 {
  "idx": "maxmin-264",
  "nl_tokens": [
   "Return",
   "the",
   "Phonex",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "4",
   ",",
   "zero_pad",
   "=",
   "True",
   ")",
   ":",
   "name",
   "=",
   "unicode_normalize",
   "(",
   "'NFKD'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "upper",
   "(",
   ")",
   ")",
   ")",
   "name",
   "=",
   "name",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "# Clamp max_length to [4, 64]",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "4",
   ",",
   "max_length",
   ")",
   ",",
   "64",
   ")",
   "else",
   ":",
   "max_length",
   "=",
   "64",
   "name_code",
   "=",
   "last",
   "=",
   "''",
   "# Deletions effected by replacing with next letter which",
   "# will be ignored due to duplicate handling of Soundex code.",
   "# This is faster than 'moving' all subsequent letters.",
   "# Remove any trailing Ss",
   "while",
   "name",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'S'",
   ":",
   "name",
   "=",
   "name",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# Phonetic equivalents of first 2 characters",
   "# Works since duplicate letters are ignored",
   "if",
   "name",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'KN'",
   ":",
   "name",
   "=",
   "'N'",
   "+",
   "name",
   "[",
   "2",
   ":",
   "]",
   "# KN.. == N..",
   "elif",
   "name",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'PH'",
   ":",
   "name",
   "=",
   "'F'",
   "+",
   "name",
   "[",
   "2",
   ":",
   "]",
   "# PH.. == F.. (H ignored anyway)",
   "elif",
   "name",
   "[",
   ":",
   "2",
   "]",
   "==",
   "'WR'",
   ":",
   "name",
   "=",
   "'R'",
   "+",
   "name",
   "[",
   "2",
   ":",
   "]",
   "# WR.. == R..",
   "if",
   "name",
   ":",
   "# Special case, ignore H first letter (subsequent Hs ignored",
   "# anyway)",
   "# Works since duplicate letters are ignored",
   "if",
   "name",
   "[",
   "0",
   "]",
   "==",
   "'H'",
   ":",
   "name",
   "=",
   "name",
   "[",
   "1",
   ":",
   "]",
   "if",
   "name",
   ":",
   "# Phonetic equivalents of first character",
   "if",
   "name",
   "[",
   "0",
   "]",
   "in",
   "self",
   ".",
   "_uc_vy_set",
   ":",
   "name",
   "=",
   "'A'",
   "+",
   "name",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "name",
   "[",
   "0",
   "]",
   "in",
   "{",
   "'B'",
   ",",
   "'P'",
   "}",
   ":",
   "name",
   "=",
   "'B'",
   "+",
   "name",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "name",
   "[",
   "0",
   "]",
   "in",
   "{",
   "'V'",
   ",",
   "'F'",
   "}",
   ":",
   "name",
   "=",
   "'F'",
   "+",
   "name",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "name",
   "[",
   "0",
   "]",
   "in",
   "{",
   "'C'",
   ",",
   "'K'",
   ",",
   "'Q'",
   "}",
   ":",
   "name",
   "=",
   "'C'",
   "+",
   "name",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "name",
   "[",
   "0",
   "]",
   "in",
   "{",
   "'G'",
   ",",
   "'J'",
   "}",
   ":",
   "name",
   "=",
   "'G'",
   "+",
   "name",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "name",
   "[",
   "0",
   "]",
   "in",
   "{",
   "'S'",
   ",",
   "'Z'",
   "}",
   ":",
   "name",
   "=",
   "'S'",
   "+",
   "name",
   "[",
   "1",
   ":",
   "]",
   "name_code",
   "=",
   "last",
   "=",
   "name",
   "[",
   "0",
   "]",
   "# Modified Soundex code",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "name",
   ")",
   ")",
   ":",
   "code",
   "=",
   "'0'",
   "if",
   "name",
   "[",
   "i",
   "]",
   "in",
   "{",
   "'B'",
   ",",
   "'F'",
   ",",
   "'P'",
   ",",
   "'V'",
   "}",
   ":",
   "code",
   "=",
   "'1'",
   "elif",
   "name",
   "[",
   "i",
   "]",
   "in",
   "{",
   "'C'",
   ",",
   "'G'",
   ",",
   "'J'",
   ",",
   "'K'",
   ",",
   "'Q'",
   ",",
   "'S'",
   ",",
   "'X'",
   ",",
   "'Z'",
   "}",
   ":",
   "code",
   "=",
   "'2'",
   "elif",
   "name",
   "[",
   "i",
   "]",
   "in",
   "{",
   "'D'",
   ",",
   "'T'",
   "}",
   ":",
   "if",
   "name",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "!=",
   "'C'",
   ":",
   "code",
   "=",
   "'3'",
   "elif",
   "name",
   "[",
   "i",
   "]",
   "==",
   "'L'",
   ":",
   "if",
   "name",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_uc_vy_set",
   "or",
   "i",
   "+",
   "1",
   "==",
   "len",
   "(",
   "name",
   ")",
   ":",
   "code",
   "=",
   "'4'",
   "elif",
   "name",
   "[",
   "i",
   "]",
   "in",
   "{",
   "'M'",
   ",",
   "'N'",
   "}",
   ":",
   "if",
   "name",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "{",
   "'D'",
   ",",
   "'G'",
   "}",
   ":",
   "name",
   "=",
   "name",
   "[",
   ":",
   "i",
   "+",
   "1",
   "]",
   "+",
   "name",
   "[",
   "i",
   "]",
   "+",
   "name",
   "[",
   "i",
   "+",
   "2",
   ":",
   "]",
   "code",
   "=",
   "'5'",
   "elif",
   "name",
   "[",
   "i",
   "]",
   "==",
   "'R'",
   ":",
   "if",
   "name",
   "[",
   "i",
   "+",
   "1",
   ":",
   "i",
   "+",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_uc_vy_set",
   "or",
   "i",
   "+",
   "1",
   "==",
   "len",
   "(",
   "name",
   ")",
   ":",
   "code",
   "=",
   "'6'",
   "if",
   "code",
   "!=",
   "last",
   "and",
   "code",
   "!=",
   "'0'",
   "and",
   "i",
   "!=",
   "0",
   ":",
   "name_code",
   "+=",
   "code",
   "last",
   "=",
   "name_code",
   "[",
   "-",
   "1",
   "]",
   "if",
   "zero_pad",
   ":",
   "name_code",
   "+=",
   "'0'",
   "*",
   "max_length",
   "if",
   "not",
   "name_code",
   ":",
   "name_code",
   "=",
   "'0'",
   "return",
   "name_code",
   "[",
   ":",
   "max_length",
   "]"
  ]
 },
 {
  "idx": "maxmin-265",
  "nl_tokens": [
   "Convert",
   "weird",
   "TIF",
   "files",
   "into",
   "web",
   "-",
   "friendly",
   "versions",
   ".",
   "Auto",
   "contrast",
   "is",
   "applied",
   "(",
   "saturating",
   "lower",
   "and",
   "upper",
   "0",
   ".",
   "1%",
   ")",
   ".",
   "make",
   "saveAs",
   "True",
   "to",
   "save",
   "as",
   ".",
   "TIF",
   ".",
   "png",
   "make",
   "saveAs",
   "False",
   "and",
   "it",
   "won",
   "t",
   "save",
   "at",
   "all",
   "make",
   "saveAs",
   "someFile",
   ".",
   "jpg",
   "to",
   "save",
   "it",
   "as",
   "a",
   "different",
   "path",
   "/",
   "format"
  ],
  "pl_tokens": [
   "def",
   "image_convert",
   "(",
   "fname",
   ",",
   "saveAs",
   "=",
   "True",
   ",",
   "showToo",
   "=",
   "False",
   ")",
   ":",
   "# load the image",
   "#im = Image.open(fname) #PIL can't handle 12-bit TIFs well",
   "im",
   "=",
   "scipy",
   ".",
   "ndimage",
   ".",
   "imread",
   "(",
   "fname",
   ")",
   "#scipy does better with it",
   "im",
   "=",
   "np",
   ".",
   "array",
   "(",
   "im",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "# now it's a numpy array",
   "# do all image enhancement here",
   "cutoffLow",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "im",
   ",",
   ".01",
   ")",
   "cutoffHigh",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "im",
   ",",
   "99.99",
   ")",
   "im",
   "[",
   "np",
   ".",
   "where",
   "(",
   "im",
   "<",
   "cutoffLow",
   ")",
   "]",
   "=",
   "cutoffLow",
   "im",
   "[",
   "np",
   ".",
   "where",
   "(",
   "im",
   ">",
   "cutoffHigh",
   ")",
   "]",
   "=",
   "cutoffHigh",
   "# IMAGE FORMATTING",
   "im",
   "-=",
   "np",
   ".",
   "<mask>",
   "(",
   "im",
   ")",
   "#auto contrast",
   "im",
   "/=",
   "np",
   ".",
   "max",
   "(",
   "im",
   ")",
   "#normalize",
   "im",
   "*=",
   "255",
   "#stretch contrast (8-bit)",
   "im",
   "=",
   "Image",
   ".",
   "fromarray",
   "(",
   "im",
   ")",
   "# IMAGE DRAWING",
   "msg",
   "=",
   "\"Filename: %s\\n\"",
   "%",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "fname",
   ")",
   "timestamp",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "fromtimestamp",
   "(",
   "os",
   ".",
   "path",
   ".",
   "getctime",
   "(",
   "fname",
   ")",
   ")",
   "msg",
   "+=",
   "\"Created: %s\\n\"",
   "%",
   "timestamp",
   ".",
   "strftime",
   "(",
   "'%Y-%m-%d %H:%M:%S'",
   ")",
   "d",
   "=",
   "ImageDraw",
   ".",
   "Draw",
   "(",
   "im",
   ")",
   "fnt",
   "=",
   "ImageFont",
   ".",
   "truetype",
   "(",
   "\"arial.ttf\"",
   ",",
   "20",
   ")",
   "d",
   ".",
   "text",
   "(",
   "(",
   "6",
   ",",
   "6",
   ")",
   ",",
   "msg",
   ",",
   "font",
   "=",
   "fnt",
   ",",
   "fill",
   "=",
   "0",
   ")",
   "d",
   ".",
   "text",
   "(",
   "(",
   "4",
   ",",
   "4",
   ")",
   ",",
   "msg",
   ",",
   "font",
   "=",
   "fnt",
   ",",
   "fill",
   "=",
   "255",
   ")",
   "if",
   "showToo",
   ":",
   "im",
   ".",
   "show",
   "(",
   ")",
   "if",
   "saveAs",
   "is",
   "False",
   ":",
   "return",
   "if",
   "saveAs",
   "is",
   "True",
   ":",
   "saveAs",
   "=",
   "fname",
   "+",
   "\".png\"",
   "im",
   ".",
   "convert",
   "(",
   "'RGB'",
   ")",
   ".",
   "save",
   "(",
   "saveAs",
   ")"
  ]
 },
 {
  "idx": "maxmin-266",
  "nl_tokens": [
   "Return",
   "True",
   "if",
   "a",
   "part",
   "of",
   "the",
   "two",
   "bounds",
   "overlaps",
   "."
  ],
  "pl_tokens": [
   "def",
   "intersects",
   "(",
   "self",
   ",",
   "b",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "self",
   ".",
   "x",
   ",",
   "b",
   ".",
   "x",
   ")",
   "<",
   "min",
   "(",
   "self",
   ".",
   "x",
   "+",
   "self",
   ".",
   "width",
   ",",
   "b",
   ".",
   "x",
   "+",
   "b",
   ".",
   "width",
   ")",
   "and",
   "max",
   "(",
   "self",
   ".",
   "y",
   ",",
   "b",
   ".",
   "y",
   ")",
   "<",
   "min",
   "(",
   "self",
   ".",
   "y",
   "+",
   "self",
   ".",
   "height",
   ",",
   "b",
   ".",
   "y",
   "+",
   "b",
   ".",
   "height",
   ")"
  ]
 },
 {
  "idx": "maxmin-267",
  "nl_tokens": [
   "If",
   "exposure",
   "was",
   "not",
   "set",
   "in",
   "the",
   "__init__",
   "get",
   "the",
   "exposure",
   "associated",
   "with",
   "this",
   "RawImage",
   "so",
   "that",
   "it",
   "may",
   "be",
   "used",
   "in",
   "other",
   ":",
   "class",
   ":",
   "~peri",
   ".",
   "util",
   ".",
   "RawImage",
   ".",
   "This",
   "is",
   "useful",
   "for",
   "transferring",
   "exposure",
   "parameters",
   "to",
   "a",
   "series",
   "of",
   "images",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_scale",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "exposure",
   "is",
   "not",
   "None",
   ":",
   "return",
   "self",
   ".",
   "exposure",
   "raw",
   "=",
   "initializers",
   ".",
   "load_tiff",
   "(",
   "self",
   ".",
   "filename",
   ")",
   "return",
   "raw",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "raw",
   ".",
   "max",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-268",
  "nl_tokens": [
   "Draws",
   "a",
   "new",
   "black",
   "image",
   "of",
   "shape",
   "(",
   "H",
   "W",
   "N",
   ")",
   "in",
   "which",
   "all",
   "keypoint",
   "coordinates",
   "are",
   "set",
   "to",
   "255",
   ".",
   "(",
   "H",
   "=",
   "shape",
   "height",
   "W",
   "=",
   "shape",
   "width",
   "N",
   "=",
   "number",
   "of",
   "keypoints",
   ")"
  ],
  "pl_tokens": [
   "def",
   "to_keypoint_image",
   "(",
   "self",
   ",",
   "size",
   "=",
   "1",
   ")",
   ":",
   "ia",
   ".",
   "do_assert",
   "(",
   "len",
   "(",
   "self",
   ".",
   "keypoints",
   ")",
   ">",
   "0",
   ")",
   "height",
   ",",
   "width",
   "=",
   "self",
   ".",
   "shape",
   "[",
   "0",
   ":",
   "2",
   "]",
   "image",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "height",
   ",",
   "width",
   ",",
   "len",
   "(",
   "self",
   ".",
   "keypoints",
   ")",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "uint8",
   ")",
   "ia",
   ".",
   "do_assert",
   "(",
   "size",
   "%",
   "2",
   "!=",
   "0",
   ")",
   "sizeh",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "(",
   "size",
   "-",
   "1",
   ")",
   "//",
   "2",
   ")",
   "for",
   "i",
   ",",
   "keypoint",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "keypoints",
   ")",
   ":",
   "# TODO for float values spread activation over several cells",
   "# here and do voting at the end",
   "y",
   "=",
   "keypoint",
   ".",
   "y_int",
   "x",
   "=",
   "keypoint",
   ".",
   "x_int",
   "x1",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "x",
   "-",
   "sizeh",
   ",",
   "0",
   ",",
   "width",
   "-",
   "1",
   ")",
   "x2",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "x",
   "+",
   "sizeh",
   "+",
   "1",
   ",",
   "0",
   ",",
   "width",
   ")",
   "y1",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "y",
   "-",
   "sizeh",
   ",",
   "0",
   ",",
   "height",
   "-",
   "1",
   ")",
   "y2",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "y",
   "+",
   "sizeh",
   "+",
   "1",
   ",",
   "0",
   ",",
   "height",
   ")",
   "if",
   "x1",
   "<",
   "x2",
   "and",
   "y1",
   "<",
   "y2",
   ":",
   "image",
   "[",
   "y1",
   ":",
   "y2",
   ",",
   "x1",
   ":",
   "x2",
   ",",
   "i",
   "]",
   "=",
   "128",
   "if",
   "0",
   "<=",
   "y",
   "<",
   "height",
   "and",
   "0",
   "<=",
   "x",
   "<",
   "width",
   ":",
   "image",
   "[",
   "y",
   ",",
   "x",
   ",",
   "i",
   "]",
   "=",
   "255",
   "return",
   "image"
  ]
 },
 {
  "idx": "maxmin-269",
  "nl_tokens": [
   "create",
   "a",
   "dict",
   "mapping",
   "model",
   "attributes",
   "to",
   "arrays"
  ],
  "pl_tokens": [
   "def",
   "create_mat_dict",
   "(",
   "model",
   ")",
   ":",
   "rxns",
   "=",
   "model",
   ".",
   "reactions",
   "mets",
   "=",
   "model",
   ".",
   "metabolites",
   "mat",
   "=",
   "OrderedDict",
   "(",
   ")",
   "mat",
   "[",
   "\"mets\"",
   "]",
   "=",
   "_cell",
   "(",
   "[",
   "met_id",
   "for",
   "met_id",
   "in",
   "create_mat_metabolite_id",
   "(",
   "model",
   ")",
   "]",
   ")",
   "mat",
   "[",
   "\"metNames\"",
   "]",
   "=",
   "_cell",
   "(",
   "mets",
   ".",
   "list_attr",
   "(",
   "\"name\"",
   ")",
   ")",
   "mat",
   "[",
   "\"metFormulas\"",
   "]",
   "=",
   "_cell",
   "(",
   "[",
   "str",
   "(",
   "m",
   ".",
   "formula",
   ")",
   "for",
   "m",
   "in",
   "mets",
   "]",
   ")",
   "try",
   ":",
   "mat",
   "[",
   "\"metCharge\"",
   "]",
   "=",
   "array",
   "(",
   "mets",
   ".",
   "list_attr",
   "(",
   "\"charge\"",
   ")",
   ")",
   "*",
   "1.",
   "except",
   "TypeError",
   ":",
   "# can't have any None entries for charge, or this will fail",
   "pass",
   "mat",
   "[",
   "\"genes\"",
   "]",
   "=",
   "_cell",
   "(",
   "model",
   ".",
   "genes",
   ".",
   "list_attr",
   "(",
   "\"id\"",
   ")",
   ")",
   "# make a matrix for rxnGeneMat",
   "# reactions are rows, genes are columns",
   "rxn_gene",
   "=",
   "scipy_sparse",
   ".",
   "dok_matrix",
   "(",
   "(",
   "len",
   "(",
   "model",
   ".",
   "reactions",
   ")",
   ",",
   "len",
   "(",
   "model",
   ".",
   "genes",
   ")",
   ")",
   ")",
   "if",
   "<mask>",
   "(",
   "rxn_gene",
   ".",
   "shape",
   ")",
   ">",
   "0",
   ":",
   "for",
   "i",
   ",",
   "reaction",
   "in",
   "enumerate",
   "(",
   "model",
   ".",
   "reactions",
   ")",
   ":",
   "for",
   "gene",
   "in",
   "reaction",
   ".",
   "genes",
   ":",
   "rxn_gene",
   "[",
   "i",
   ",",
   "model",
   ".",
   "genes",
   ".",
   "index",
   "(",
   "gene",
   ")",
   "]",
   "=",
   "1",
   "mat",
   "[",
   "\"rxnGeneMat\"",
   "]",
   "=",
   "rxn_gene",
   "mat",
   "[",
   "\"grRules\"",
   "]",
   "=",
   "_cell",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"gene_reaction_rule\"",
   ")",
   ")",
   "mat",
   "[",
   "\"rxns\"",
   "]",
   "=",
   "_cell",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"id\"",
   ")",
   ")",
   "mat",
   "[",
   "\"rxnNames\"",
   "]",
   "=",
   "_cell",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"name\"",
   ")",
   ")",
   "mat",
   "[",
   "\"subSystems\"",
   "]",
   "=",
   "_cell",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"subsystem\"",
   ")",
   ")",
   "stoich_mat",
   "=",
   "create_stoichiometric_matrix",
   "(",
   "model",
   ")",
   "mat",
   "[",
   "\"S\"",
   "]",
   "=",
   "stoich_mat",
   "if",
   "stoich_mat",
   "is",
   "not",
   "None",
   "else",
   "[",
   "[",
   "]",
   "]",
   "# multiply by 1 to convert to float, working around scipy bug",
   "# https://github.com/scipy/scipy/issues/4537",
   "mat",
   "[",
   "\"lb\"",
   "]",
   "=",
   "array",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"lower_bound\"",
   ")",
   ")",
   "*",
   "1.",
   "mat",
   "[",
   "\"ub\"",
   "]",
   "=",
   "array",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"upper_bound\"",
   ")",
   ")",
   "*",
   "1.",
   "mat",
   "[",
   "\"b\"",
   "]",
   "=",
   "array",
   "(",
   "mets",
   ".",
   "list_attr",
   "(",
   "\"_bound\"",
   ")",
   ")",
   "*",
   "1.",
   "mat",
   "[",
   "\"c\"",
   "]",
   "=",
   "array",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"objective_coefficient\"",
   ")",
   ")",
   "*",
   "1.",
   "mat",
   "[",
   "\"rev\"",
   "]",
   "=",
   "array",
   "(",
   "rxns",
   ".",
   "list_attr",
   "(",
   "\"reversibility\"",
   ")",
   ")",
   "*",
   "1",
   "mat",
   "[",
   "\"description\"",
   "]",
   "=",
   "str",
   "(",
   "model",
   ".",
   "id",
   ")",
   "return",
   "mat"
  ]
 },
 {
  "idx": "maxmin-270",
  "nl_tokens": [
   "Handle",
   "a",
   "watermark",
   "notification",
   "."
  ],
  "pl_tokens": [
   "def",
   "_on_watermark_notification",
   "(",
   "self",
   ",",
   "notif",
   ")",
   ":",
   "# Update the conversation:",
   "if",
   "self",
   ".",
   "get_user",
   "(",
   "notif",
   ".",
   "user_id",
   ")",
   ".",
   "is_self",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "'latest_read_timestamp for {} updated to {}'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "id_",
   ",",
   "notif",
   ".",
   "read_timestamp",
   ")",
   ")",
   "self_conversation_state",
   "=",
   "(",
   "self",
   ".",
   "_conversation",
   ".",
   "self_conversation_state",
   ")",
   "self_conversation_state",
   ".",
   "self_read_state",
   ".",
   "latest_read_timestamp",
   "=",
   "(",
   "parsers",
   ".",
   "to_timestamp",
   "(",
   "notif",
   ".",
   "read_timestamp",
   ")",
   ")",
   "# Update the participants' watermarks:",
   "previous_timestamp",
   "=",
   "self",
   ".",
   "_watermarks",
   ".",
   "get",
   "(",
   "notif",
   ".",
   "user_id",
   ",",
   "datetime",
   ".",
   "datetime",
   ".",
   "<mask>",
   ".",
   "replace",
   "(",
   "tzinfo",
   "=",
   "datetime",
   ".",
   "timezone",
   ".",
   "utc",
   ")",
   ")",
   "if",
   "notif",
   ".",
   "read_timestamp",
   ">",
   "previous_timestamp",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "(",
   "'latest_read_timestamp for conv {} participant {}'",
   "+",
   "' updated to {}'",
   ")",
   ".",
   "format",
   "(",
   "self",
   ".",
   "id_",
   ",",
   "notif",
   ".",
   "user_id",
   ".",
   "chat_id",
   ",",
   "notif",
   ".",
   "read_timestamp",
   ")",
   ")",
   "self",
   ".",
   "_watermarks",
   "[",
   "notif",
   ".",
   "user_id",
   "]",
   "=",
   "notif",
   ".",
   "read_timestamp"
  ]
 },
 {
  "idx": "maxmin-271",
  "nl_tokens": [
   "Adds",
   "a",
   "watermark",
   "to",
   "an",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "watermark",
   "(",
   "im",
   ",",
   "mark",
   ",",
   "position",
   ",",
   "opacity",
   "=",
   "1",
   ")",
   ":",
   "if",
   "opacity",
   "<",
   "1",
   ":",
   "mark",
   "=",
   "reduce_opacity",
   "(",
   "mark",
   ",",
   "opacity",
   ")",
   "if",
   "im",
   ".",
   "mode",
   "!=",
   "'RGBA'",
   ":",
   "im",
   "=",
   "im",
   ".",
   "convert",
   "(",
   "'RGBA'",
   ")",
   "# create a transparent layer the size of the image and draw the",
   "# watermark in that layer.",
   "layer",
   "=",
   "Image",
   ".",
   "new",
   "(",
   "'RGBA'",
   ",",
   "im",
   ".",
   "size",
   ",",
   "(",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0",
   ")",
   ")",
   "if",
   "position",
   "==",
   "'tile'",
   ":",
   "for",
   "y",
   "in",
   "range",
   "(",
   "0",
   ",",
   "im",
   ".",
   "size",
   "[",
   "1",
   "]",
   ",",
   "mark",
   ".",
   "size",
   "[",
   "1",
   "]",
   ")",
   ":",
   "for",
   "x",
   "in",
   "range",
   "(",
   "0",
   ",",
   "im",
   ".",
   "size",
   "[",
   "0",
   "]",
   ",",
   "mark",
   ".",
   "size",
   "[",
   "0",
   "]",
   ")",
   ":",
   "layer",
   ".",
   "paste",
   "(",
   "mark",
   ",",
   "(",
   "x",
   ",",
   "y",
   ")",
   ")",
   "elif",
   "position",
   "==",
   "'scale'",
   ":",
   "# scale, but preserve the aspect ratio",
   "ratio",
   "=",
   "<mask>",
   "(",
   "float",
   "(",
   "im",
   ".",
   "size",
   "[",
   "0",
   "]",
   ")",
   "/",
   "mark",
   ".",
   "size",
   "[",
   "0",
   "]",
   ",",
   "float",
   "(",
   "im",
   ".",
   "size",
   "[",
   "1",
   "]",
   ")",
   "/",
   "mark",
   ".",
   "size",
   "[",
   "1",
   "]",
   ")",
   "w",
   "=",
   "int",
   "(",
   "mark",
   ".",
   "size",
   "[",
   "0",
   "]",
   "*",
   "ratio",
   ")",
   "h",
   "=",
   "int",
   "(",
   "mark",
   ".",
   "size",
   "[",
   "1",
   "]",
   "*",
   "ratio",
   ")",
   "mark",
   "=",
   "mark",
   ".",
   "resize",
   "(",
   "(",
   "w",
   ",",
   "h",
   ")",
   ")",
   "layer",
   ".",
   "paste",
   "(",
   "mark",
   ",",
   "(",
   "int",
   "(",
   "(",
   "im",
   ".",
   "size",
   "[",
   "0",
   "]",
   "-",
   "w",
   ")",
   "/",
   "2",
   ")",
   ",",
   "int",
   "(",
   "(",
   "im",
   ".",
   "size",
   "[",
   "1",
   "]",
   "-",
   "h",
   ")",
   "/",
   "2",
   ")",
   ")",
   ")",
   "else",
   ":",
   "layer",
   ".",
   "paste",
   "(",
   "mark",
   ",",
   "position",
   ")",
   "# composite the watermark with the layer",
   "return",
   "Image",
   ".",
   "composite",
   "(",
   "layer",
   ",",
   "im",
   ",",
   "layer",
   ")"
  ]
 },
 {
  "idx": "maxmin-272",
  "nl_tokens": [
   "r",
   "Method",
   "which",
   "picks",
   "out",
   "coefficients",
   "for",
   "the",
   "specified",
   "chemical",
   "from",
   "the",
   "various",
   "dictionaries",
   "and",
   "DataFrames",
   "storing",
   "it",
   ".",
   "All",
   "data",
   "is",
   "stored",
   "as",
   "attributes",
   ".",
   "This",
   "method",
   "also",
   "sets",
   ":",
   "obj",
   ":",
   "Tmin",
   ":",
   "obj",
   ":",
   "Tmax",
   "and",
   ":",
   "obj",
   ":",
   "all_methods",
   "as",
   "a",
   "set",
   "of",
   "methods",
   "for",
   "which",
   "the",
   "data",
   "exists",
   "for",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "]",
   "Tmins",
   ",",
   "Tmaxs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "if",
   "has_CoolProp",
   "and",
   "self",
   ".",
   "CASRN",
   "in",
   "coolprop_dict",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "COOLPROP",
   ")",
   "self",
   ".",
   "CP_f",
   "=",
   "coolprop_fluids",
   "[",
   "self",
   ".",
   "CASRN",
   "]",
   "Tmins",
   ".",
   "append",
   "(",
   "self",
   ".",
   "CP_f",
   ".",
   "Tt",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "CP_f",
   ".",
   "Tc",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "_VDISaturationDict",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "VDI_TABULAR",
   ")",
   "Ts",
   ",",
   "props",
   "=",
   "VDI_tabular_data",
   "(",
   "self",
   ".",
   "CASRN",
   ",",
   "'Hvap'",
   ")",
   "self",
   ".",
   "VDI_Tmin",
   "=",
   "Ts",
   "[",
   "0",
   "]",
   "self",
   ".",
   "VDI_Tmax",
   "=",
   "Ts",
   "[",
   "-",
   "1",
   "]",
   "self",
   ".",
   "tabular_data",
   "[",
   "VDI_TABULAR",
   "]",
   "=",
   "(",
   "Ts",
   ",",
   "props",
   ")",
   "Tmins",
   ".",
   "append",
   "(",
   "self",
   ".",
   "VDI_Tmin",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "VDI_Tmax",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "Alibakhshi_Cs",
   ".",
   "index",
   "and",
   "self",
   ".",
   "Tc",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "ALIBAKHSHI",
   ")",
   "self",
   ".",
   "Alibakhshi_C",
   "=",
   "float",
   "(",
   "Alibakhshi_Cs",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'C'",
   "]",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "Tc",
   "-",
   "100.",
   ",",
   "0",
   ")",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "CRCHvap_data",
   ".",
   "index",
   "and",
   "not",
   "np",
   ".",
   "isnan",
   "(",
   "CRCHvap_data",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'HvapTb'",
   "]",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "CRC_HVAP_TB",
   ")",
   "self",
   ".",
   "CRC_HVAP_TB_Tb",
   "=",
   "float",
   "(",
   "CRCHvap_data",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'Tb'",
   "]",
   ")",
   "self",
   ".",
   "CRC_HVAP_TB_Hvap",
   "=",
   "float",
   "(",
   "CRCHvap_data",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'HvapTb'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "CRCHvap_data",
   ".",
   "index",
   "and",
   "not",
   "np",
   ".",
   "isnan",
   "(",
   "CRCHvap_data",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'Hvap298'",
   "]",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "CRC_HVAP_298",
   ")",
   "self",
   ".",
   "CRC_HVAP_298",
   "=",
   "float",
   "(",
   "CRCHvap_data",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'Hvap298'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "GharagheiziHvap_data",
   ".",
   "index",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "GHARAGHEIZI_HVAP_298",
   ")",
   "self",
   ".",
   "GHARAGHEIZI_HVAP_298_Hvap",
   "=",
   "float",
   "(",
   "GharagheiziHvap_data",
   ".",
   "at",
   "[",
   "self",
   ".",
   "CASRN",
   ",",
   "'Hvap298'",
   "]",
   ")",
   "if",
   "all",
   "(",
   "(",
   "self",
   ".",
   "Tc",
   ",",
   "self",
   ".",
   "omega",
   ")",
   ")",
   ":",
   "methods",
   ".",
   "extend",
   "(",
   "self",
   ".",
   "CSP_methods",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "Tc",
   ")",
   "Tmins",
   ".",
   "append",
   "(",
   "0",
   ")",
   "if",
   "all",
   "(",
   "(",
   "self",
   ".",
   "Tc",
   ",",
   "self",
   ".",
   "Pc",
   ")",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "CLAPEYRON",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "Tc",
   ")",
   "Tmins",
   ".",
   "append",
   "(",
   "0",
   ")",
   "if",
   "all",
   "(",
   "(",
   "self",
   ".",
   "Tb",
   ",",
   "self",
   ".",
   "Tc",
   ",",
   "self",
   ".",
   "Pc",
   ")",
   ")",
   ":",
   "methods",
   ".",
   "extend",
   "(",
   "self",
   ".",
   "boiling_methods",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "Tc",
   ")",
   "Tmins",
   ".",
   "append",
   "(",
   "0",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "Perrys2_150",
   ".",
   "index",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "DIPPR_PERRY_8E",
   ")",
   "_",
   ",",
   "Tc",
   ",",
   "C1",
   ",",
   "C2",
   ",",
   "C3",
   ",",
   "C4",
   ",",
   "self",
   ".",
   "Perrys2_150_Tmin",
   ",",
   "self",
   ".",
   "Perrys2_150_Tmax",
   "=",
   "_Perrys2_150_values",
   "[",
   "Perrys2_150",
   ".",
   "index",
   ".",
   "get_loc",
   "(",
   "self",
   ".",
   "CASRN",
   ")",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "self",
   ".",
   "Perrys2_150_coeffs",
   "=",
   "[",
   "Tc",
   ",",
   "C1",
   ",",
   "C2",
   ",",
   "C3",
   ",",
   "C4",
   "]",
   "Tmins",
   ".",
   "append",
   "(",
   "self",
   ".",
   "Perrys2_150_Tmin",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "Perrys2_150_Tmax",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "VDI_PPDS_4",
   ".",
   "index",
   ":",
   "_",
   ",",
   "MW",
   ",",
   "Tc",
   ",",
   "A",
   ",",
   "B",
   ",",
   "C",
   ",",
   "D",
   ",",
   "E",
   "=",
   "_VDI_PPDS_4_values",
   "[",
   "VDI_PPDS_4",
   ".",
   "index",
   ".",
   "get_loc",
   "(",
   "self",
   ".",
   "CASRN",
   ")",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "self",
   ".",
   "VDI_PPDS_coeffs",
   "=",
   "[",
   "A",
   ",",
   "B",
   ",",
   "C",
   ",",
   "D",
   ",",
   "E",
   "]",
   "self",
   ".",
   "VDI_PPDS_Tc",
   "=",
   "Tc",
   "self",
   ".",
   "VDI_PPDS_MW",
   "=",
   "MW",
   "methods",
   ".",
   "append",
   "(",
   "VDI_PPDS",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "VDI_PPDS_Tc",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "if",
   "Tmins",
   "and",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmin",
   ",",
   "self",
   ".",
   "Tmax",
   "=",
   "min",
   "(",
   "Tmins",
   ")",
   ",",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-273",
  "nl_tokens": [
   "Returns",
   "a",
   "map",
   "of",
   "nodename",
   "to",
   "average",
   "fitness",
   "value",
   "for",
   "this",
   "block",
   ".",
   "Assumes",
   "that",
   "required",
   "resources",
   "have",
   "been",
   "checked",
   "on",
   "all",
   "nodes",
   "."
  ],
  "pl_tokens": [
   "def",
   "block_resource_fitnesses",
   "(",
   "self",
   ",",
   "block",
   ":",
   "block",
   ".",
   "Block",
   ")",
   ":",
   "# Short-circuit! My algorithm is terrible, so it doesn't work well for the edge case where",
   "# the block has no requirements",
   "if",
   "not",
   "block",
   ".",
   "resources",
   ":",
   "return",
   "{",
   "n",
   ":",
   "1",
   "for",
   "n",
   "in",
   "self",
   ".",
   "config",
   ".",
   "nodes",
   ".",
   "keys",
   "(",
   ")",
   "}",
   "node_fitnesses",
   "=",
   "{",
   "}",
   "for",
   "resource",
   "in",
   "block",
   ".",
   "resources",
   ":",
   "resource_fitnesses",
   "=",
   "self",
   ".",
   "resource_fitnesses",
   "(",
   "resource",
   ")",
   "if",
   "not",
   "resource_fitnesses",
   ":",
   "raise",
   "UnassignableBlock",
   "(",
   "block",
   ".",
   "name",
   ")",
   "max_fit",
   "=",
   "<mask>",
   "(",
   "resource_fitnesses",
   ".",
   "values",
   "(",
   ")",
   ")",
   "min_fit",
   "=",
   "min",
   "(",
   "resource_fitnesses",
   ".",
   "values",
   "(",
   ")",
   ")",
   "for",
   "node",
   ",",
   "fitness",
   "in",
   "resource_fitnesses",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "node",
   "not",
   "in",
   "node_fitnesses",
   ":",
   "node_fitnesses",
   "[",
   "node",
   "]",
   "=",
   "{",
   "}",
   "if",
   "not",
   "fitness",
   ":",
   "# Since we're rescaling, 0 is now an OK value...",
   "# We will check for `is False` after this",
   "node_fitnesses",
   "[",
   "node",
   "]",
   "[",
   "resource",
   ".",
   "describe",
   "(",
   ")",
   "]",
   "=",
   "False",
   "else",
   ":",
   "if",
   "max_fit",
   "-",
   "min_fit",
   ":",
   "node_fitnesses",
   "[",
   "node",
   "]",
   "[",
   "resource",
   ".",
   "describe",
   "(",
   ")",
   "]",
   "=",
   "(",
   "fitness",
   "-",
   "min_fit",
   ")",
   "/",
   "(",
   "max_fit",
   "-",
   "min_fit",
   ")",
   "else",
   ":",
   "# All the values are the same, default to 1",
   "node_fitnesses",
   "[",
   "node",
   "]",
   "[",
   "resource",
   ".",
   "describe",
   "(",
   ")",
   "]",
   "=",
   "1.0",
   "res",
   "=",
   "{",
   "}",
   "for",
   "node",
   ",",
   "res_fits",
   "in",
   "node_fitnesses",
   ".",
   "items",
   "(",
   ")",
   ":",
   "fit_sum",
   "=",
   "0",
   "for",
   "res_desc",
   ",",
   "fit",
   "in",
   "res_fits",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "fit",
   "is",
   "False",
   ":",
   "fit_sum",
   "=",
   "False",
   "break",
   "fit_sum",
   "+=",
   "fit",
   "if",
   "fit_sum",
   "is",
   "False",
   ":",
   "# Skip this node entirely",
   "res",
   "[",
   "node",
   "]",
   "=",
   "False",
   "continue",
   "res",
   "[",
   "node",
   "]",
   "=",
   "fit_sum",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-274",
  "nl_tokens": [
   "Runs",
   "the",
   "Box",
   "Least",
   "Squares",
   "Fitting",
   "Search",
   "for",
   "transit",
   "-",
   "shaped",
   "signals",
   "."
  ],
  "pl_tokens": [
   "def",
   "bls_parallel_pfind",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "startp",
   "=",
   "0.1",
   ",",
   "# by default, search from 0.1 d to...",
   "endp",
   "=",
   "100.0",
   ",",
   "# ... 100.0 d -- don't search full timebase",
   "stepsize",
   "=",
   "1.0e-4",
   ",",
   "mintransitduration",
   "=",
   "0.01",
   ",",
   "# minimum transit length in phase",
   "maxtransitduration",
   "=",
   "0.4",
   ",",
   "# maximum transit length in phase",
   "nphasebins",
   "=",
   "200",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "# figure out f0, nf, and df automatically",
   "nbestpeaks",
   "=",
   "5",
   ",",
   "periodepsilon",
   "=",
   "0.1",
   ",",
   "# 0.1",
   "sigclip",
   "=",
   "10.0",
   ",",
   "verbose",
   "=",
   "True",
   ",",
   "nworkers",
   "=",
   "None",
   ",",
   "get_stats",
   "=",
   "True",
   ",",
   ")",
   ":",
   "# get rid of nans first and sigclip",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# if we're setting up everything automatically",
   "if",
   "autofreq",
   ":",
   "# figure out the best number of phasebins to use",
   "nphasebins",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "2.0",
   "/",
   "mintransitduration",
   ")",
   ")",
   "if",
   "nphasebins",
   ">",
   "3000",
   ":",
   "nphasebins",
   "=",
   "3000",
   "# use heuristic to figure out best timestep",
   "stepsize",
   "=",
   "0.25",
   "*",
   "mintransitduration",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# now figure out the frequencies to use",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = True: using AUTOMATIC values for '",
   "'freq stepsize: %s, nphasebins: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "nphasebins",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "else",
   ":",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = False: using PROVIDED values for '",
   "'freq stepsize: %s, nphasebins: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "nphasebins",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "# check the minimum frequency",
   "if",
   "minfreq",
   "<",
   "(",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   ":",
   "minfreq",
   "=",
   "2.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'the requested max P = %.3f is larger than '",
   "'the time base of the observations = %.3f, '",
   "' will make minfreq = 2 x 1/timebase'",
   "%",
   "(",
   "endp",
   ",",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'new minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "#############################",
   "## NOW RUN BLS IN PARALLEL ##",
   "#############################",
   "# fix number of CPUs if needed",
   "if",
   "not",
   "nworkers",
   "or",
   "nworkers",
   ">",
   "NCPUS",
   ":",
   "nworkers",
   "=",
   "NCPUS",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using %s workers...'",
   "%",
   "nworkers",
   ")",
   "# the frequencies array to be searched",
   "frequencies",
   "=",
   "minfreq",
   "+",
   "nparange",
   "(",
   "nfreq",
   ")",
   "*",
   "stepsize",
   "# break up the tasks into chunks",
   "csrem",
   "=",
   "int",
   "(",
   "fmod",
   "(",
   "nfreq",
   ",",
   "nworkers",
   ")",
   ")",
   "csint",
   "=",
   "int",
   "(",
   "float",
   "(",
   "nfreq",
   "/",
   "nworkers",
   ")",
   ")",
   "chunk_minfreqs",
   ",",
   "chunk_nfreqs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "for",
   "x",
   "in",
   "range",
   "(",
   "nworkers",
   ")",
   ":",
   "this_minfreqs",
   "=",
   "frequencies",
   "[",
   "x",
   "*",
   "csint",
   "]",
   "# handle usual nfreqs",
   "if",
   "x",
   "<",
   "(",
   "nworkers",
   "-",
   "1",
   ")",
   ":",
   "this_nfreqs",
   "=",
   "frequencies",
   "[",
   "x",
   "*",
   "csint",
   ":",
   "x",
   "*",
   "csint",
   "+",
   "csint",
   "]",
   ".",
   "size",
   "else",
   ":",
   "this_nfreqs",
   "=",
   "frequencies",
   "[",
   "x",
   "*",
   "csint",
   ":",
   "x",
   "*",
   "csint",
   "+",
   "csint",
   "+",
   "csrem",
   "]",
   ".",
   "size",
   "chunk_minfreqs",
   ".",
   "append",
   "(",
   "this_minfreqs",
   ")",
   "chunk_nfreqs",
   ".",
   "append",
   "(",
   "this_nfreqs",
   ")",
   "# populate the tasks list",
   "tasks",
   "=",
   "[",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "chunk_minf",
   ",",
   "chunk_nf",
   ",",
   "stepsize",
   ",",
   "nphasebins",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   "for",
   "(",
   "chunk_nf",
   ",",
   "chunk_minf",
   ")",
   "in",
   "zip",
   "(",
   "chunk_minfreqs",
   ",",
   "chunk_nfreqs",
   ")",
   "]",
   "if",
   "verbose",
   ":",
   "for",
   "ind",
   ",",
   "task",
   "in",
   "enumerate",
   "(",
   "tasks",
   ")",
   ":",
   "LOGINFO",
   "(",
   "'worker %s: minfreq = %.6f, nfreqs = %s'",
   "%",
   "(",
   "ind",
   "+",
   "1",
   ",",
   "task",
   "[",
   "3",
   "]",
   ",",
   "task",
   "[",
   "2",
   "]",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'running...'",
   ")",
   "# return tasks",
   "# start the pool",
   "pool",
   "=",
   "Pool",
   "(",
   "nworkers",
   ")",
   "results",
   "=",
   "pool",
   ".",
   "map",
   "(",
   "_parallel_bls_worker",
   ",",
   "tasks",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "del",
   "pool",
   "# now concatenate the output lsp arrays",
   "lsp",
   "=",
   "npconcatenate",
   "(",
   "[",
   "x",
   "[",
   "'power'",
   "]",
   "for",
   "x",
   "in",
   "results",
   "]",
   ")",
   "periods",
   "=",
   "1.0",
   "/",
   "frequencies",
   "# find the nbestpeaks for the periodogram: 1. sort the lsp array",
   "# by highest value first 2. go down the values until we find",
   "# five values that are separated by at least periodepsilon in",
   "# period",
   "# make sure to get only the finite peaks in the periodogram",
   "# this is needed because BLS may produce infs for some peaks",
   "finitepeakind",
   "=",
   "npisfinite",
   "(",
   "lsp",
   ")",
   "finlsp",
   "=",
   "lsp",
   "[",
   "finitepeakind",
   "]",
   "finperiods",
   "=",
   "periods",
   "[",
   "finitepeakind",
   "]",
   "# make sure that finlsp has finite values before we work on it",
   "try",
   ":",
   "bestperiodind",
   "=",
   "npargmax",
   "(",
   "finlsp",
   ")",
   "except",
   "ValueError",
   ":",
   "LOGERROR",
   "(",
   "'no finite periodogram values '",
   "'for this mag series, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "sortedlspind",
   "=",
   "npargsort",
   "(",
   "finlsp",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "sortedlspperiods",
   "=",
   "finperiods",
   "[",
   "sortedlspind",
   "]",
   "sortedlspvals",
   "=",
   "finlsp",
   "[",
   "sortedlspind",
   "]",
   "# now get the nbestpeaks",
   "nbestperiods",
   ",",
   "nbestlspvals",
   ",",
   "peakcount",
   "=",
   "(",
   "[",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "1",
   ")",
   "prevperiod",
   "=",
   "sortedlspperiods",
   "[",
   "0",
   "]",
   "# find the best nbestpeaks in the lsp and their periods",
   "for",
   "period",
   ",",
   "lspval",
   "in",
   "zip",
   "(",
   "sortedlspperiods",
   ",",
   "sortedlspvals",
   ")",
   ":",
   "if",
   "peakcount",
   "==",
   "nbestpeaks",
   ":",
   "break",
   "perioddiff",
   "=",
   "abs",
   "(",
   "period",
   "-",
   "prevperiod",
   ")",
   "bestperiodsdiff",
   "=",
   "[",
   "abs",
   "(",
   "period",
   "-",
   "x",
   ")",
   "for",
   "x",
   "in",
   "nbestperiods",
   "]",
   "# this ensures that this period is different from the last",
   "# period and from all the other existing best periods by",
   "# periodepsilon to make sure we jump to an entire different",
   "# peak in the periodogram",
   "if",
   "(",
   "perioddiff",
   ">",
   "(",
   "periodepsilon",
   "*",
   "prevperiod",
   ")",
   "and",
   "all",
   "(",
   "x",
   ">",
   "(",
   "periodepsilon",
   "*",
   "period",
   ")",
   "for",
   "x",
   "in",
   "bestperiodsdiff",
   ")",
   ")",
   ":",
   "nbestperiods",
   ".",
   "append",
   "(",
   "period",
   ")",
   "nbestlspvals",
   ".",
   "append",
   "(",
   "lspval",
   ")",
   "peakcount",
   "=",
   "peakcount",
   "+",
   "1",
   "prevperiod",
   "=",
   "period",
   "# generate the return dict",
   "resultdict",
   "=",
   "{",
   "'bestperiod'",
   ":",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'bestlspval'",
   ":",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "nbestlspvals",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'lspvals'",
   ":",
   "lsp",
   ",",
   "'frequencies'",
   ":",
   "frequencies",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'blsresult'",
   ":",
   "results",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "nfreq",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "# get stats if requested",
   "if",
   "get_stats",
   ":",
   "resultdict",
   "[",
   "'stats'",
   "]",
   "=",
   "[",
   "]",
   "for",
   "bp",
   "in",
   "nbestperiods",
   ".",
   "copy",
   "(",
   ")",
   ":",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "\"Getting stats for best period: %.6f\"",
   "%",
   "bp",
   ")",
   "this_pstats",
   "=",
   "bls_stats_singleperiod",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "bp",
   ",",
   "magsarefluxes",
   "=",
   "resultdict",
   "[",
   "'kwargs'",
   "]",
   "[",
   "'magsarefluxes'",
   "]",
   ",",
   "sigclip",
   "=",
   "resultdict",
   "[",
   "'kwargs'",
   "]",
   "[",
   "'sigclip'",
   "]",
   ",",
   "nphasebins",
   "=",
   "resultdict",
   "[",
   "'nphasebins'",
   "]",
   ",",
   "mintransitduration",
   "=",
   "resultdict",
   "[",
   "'mintransitduration'",
   "]",
   ",",
   "maxtransitduration",
   "=",
   "resultdict",
   "[",
   "'maxtransitduration'",
   "]",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   ")",
   "resultdict",
   "[",
   "'stats'",
   "]",
   ".",
   "append",
   "(",
   "this_pstats",
   ")",
   "return",
   "resultdict",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "None",
   ",",
   "'nphasebins'",
   ":",
   "None",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}"
  ]
 },
 {
  "idx": "maxmin-275",
  "nl_tokens": [
   "Annotation",
   "filtering",
   "filter"
  ],
  "pl_tokens": [
   "def",
   "f_annotation_filter",
   "(",
   "annotations",
   ",",
   "type_uri",
   ",",
   "number",
   ")",
   ":",
   "filtered",
   "=",
   "[",
   "annotation",
   "for",
   "annotation",
   "in",
   "annotations",
   "if",
   "annotation",
   ".",
   "type_uri",
   "==",
   "type_uri",
   "]",
   "number",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "filtered",
   ")",
   ",",
   "number",
   "]",
   ")",
   "if",
   "number",
   "==",
   "0",
   ":",
   "return",
   "None",
   "else",
   ":",
   "return",
   "filtered",
   "[",
   "number",
   "-",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-276",
  "nl_tokens": [
   "Calculate",
   "the",
   "pairwise",
   "similarity",
   "statistics",
   "a",
   "collection",
   "of",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "pairwise_similarity_statistics",
   "(",
   "src_collection",
   ",",
   "tar_collection",
   ",",
   "metric",
   "=",
   "sim",
   ",",
   "mean_func",
   "=",
   "amean",
   ",",
   "symmetric",
   "=",
   "False",
   ",",
   ")",
   ":",
   "if",
   "not",
   "callable",
   "(",
   "mean_func",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'mean_func must be a function'",
   ")",
   "if",
   "not",
   "callable",
   "(",
   "metric",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'metric must be a function'",
   ")",
   "if",
   "hasattr",
   "(",
   "src_collection",
   ",",
   "'split'",
   ")",
   ":",
   "src_collection",
   "=",
   "src_collection",
   ".",
   "split",
   "(",
   ")",
   "if",
   "not",
   "hasattr",
   "(",
   "src_collection",
   ",",
   "'__iter__'",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'src_collection is neither a string nor iterable'",
   ")",
   "if",
   "hasattr",
   "(",
   "tar_collection",
   ",",
   "'split'",
   ")",
   ":",
   "tar_collection",
   "=",
   "tar_collection",
   ".",
   "split",
   "(",
   ")",
   "if",
   "not",
   "hasattr",
   "(",
   "tar_collection",
   ",",
   "'__iter__'",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'tar_collection is neither a string nor iterable'",
   ")",
   "src_collection",
   "=",
   "list",
   "(",
   "src_collection",
   ")",
   "tar_collection",
   "=",
   "list",
   "(",
   "tar_collection",
   ")",
   "pairwise_values",
   "=",
   "[",
   "]",
   "for",
   "src",
   "in",
   "src_collection",
   ":",
   "for",
   "tar",
   "in",
   "tar_collection",
   ":",
   "pairwise_values",
   ".",
   "append",
   "(",
   "metric",
   "(",
   "src",
   ",",
   "tar",
   ")",
   ")",
   "if",
   "symmetric",
   ":",
   "pairwise_values",
   ".",
   "append",
   "(",
   "metric",
   "(",
   "tar",
   ",",
   "src",
   ")",
   ")",
   "return",
   "(",
   "<mask>",
   "(",
   "pairwise_values",
   ")",
   ",",
   "min",
   "(",
   "pairwise_values",
   ")",
   ",",
   "mean_func",
   "(",
   "pairwise_values",
   ")",
   ",",
   "std",
   "(",
   "pairwise_values",
   ",",
   "mean_func",
   ",",
   "0",
   ")",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-277",
  "nl_tokens": [
   "Optional",
   "baselevels",
   "configuration",
   "."
  ],
  "pl_tokens": [
   "def",
   "baselevels",
   "(",
   "self",
   ")",
   ":",
   "if",
   "\"baselevels\"",
   "not",
   "in",
   "self",
   ".",
   "_raw",
   ":",
   "return",
   "{",
   "}",
   "baselevels",
   "=",
   "self",
   ".",
   "_raw",
   "[",
   "\"baselevels\"",
   "]",
   "minmax",
   "=",
   "{",
   "k",
   ":",
   "v",
   "for",
   "k",
   ",",
   "v",
   "in",
   "baselevels",
   ".",
   "items",
   "(",
   ")",
   "if",
   "k",
   "in",
   "[",
   "\"min\"",
   ",",
   "\"max\"",
   "]",
   "}",
   "if",
   "not",
   "minmax",
   ":",
   "raise",
   "MapcheteConfigError",
   "(",
   "\"no min and max values given for baselevels\"",
   ")",
   "for",
   "v",
   "in",
   "minmax",
   ".",
   "values",
   "(",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "v",
   ",",
   "int",
   ")",
   "or",
   "v",
   "<",
   "0",
   ":",
   "raise",
   "MapcheteConfigError",
   "(",
   "\"invalid baselevel zoom parameter given: %s\"",
   "%",
   "minmax",
   ".",
   "values",
   "(",
   ")",
   ")",
   "zooms",
   "=",
   "list",
   "(",
   "range",
   "(",
   "minmax",
   ".",
   "get",
   "(",
   "\"min\"",
   ",",
   "<mask>",
   "(",
   "self",
   ".",
   "zoom_levels",
   ")",
   ")",
   ",",
   "minmax",
   ".",
   "get",
   "(",
   "\"max\"",
   ",",
   "max",
   "(",
   "self",
   ".",
   "zoom_levels",
   ")",
   ")",
   "+",
   "1",
   ")",
   ")",
   "if",
   "not",
   "set",
   "(",
   "self",
   ".",
   "zoom_levels",
   ")",
   ".",
   "difference",
   "(",
   "set",
   "(",
   "zooms",
   ")",
   ")",
   ":",
   "raise",
   "MapcheteConfigError",
   "(",
   "\"baselevels zooms fully cover process zooms\"",
   ")",
   "return",
   "dict",
   "(",
   "zooms",
   "=",
   "zooms",
   ",",
   "lower",
   "=",
   "baselevels",
   ".",
   "get",
   "(",
   "\"lower\"",
   ",",
   "\"nearest\"",
   ")",
   ",",
   "higher",
   "=",
   "baselevels",
   ".",
   "get",
   "(",
   "\"higher\"",
   ",",
   "\"nearest\"",
   ")",
   ",",
   "tile_pyramid",
   "=",
   "BufferedTilePyramid",
   "(",
   "self",
   ".",
   "output_pyramid",
   ".",
   "grid",
   ",",
   "pixelbuffer",
   "=",
   "self",
   ".",
   "output_pyramid",
   ".",
   "pixelbuffer",
   ",",
   "metatiling",
   "=",
   "self",
   ".",
   "process_pyramid",
   ".",
   "metatiling",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-278",
  "nl_tokens": [
   "Returns",
   "an",
   "iterator",
   "of",
   "Period",
   "tuples",
   "for",
   "every",
   "day",
   "this",
   "schedule",
   "is",
   "in",
   "effect",
   "between",
   "range_start",
   "and",
   "range_end",
   "."
  ],
  "pl_tokens": [
   "def",
   "daily_periods",
   "(",
   "self",
   ",",
   "range_start",
   "=",
   "datetime",
   ".",
   "date",
   ".",
   "<mask>",
   ",",
   "range_end",
   "=",
   "datetime",
   ".",
   "date",
   ".",
   "max",
   ",",
   "exclude_dates",
   "=",
   "tuple",
   "(",
   ")",
   ")",
   ":",
   "tz",
   "=",
   "self",
   ".",
   "timezone",
   "period",
   "=",
   "self",
   ".",
   "period",
   "weekdays",
   "=",
   "self",
   ".",
   "weekdays",
   "current_date",
   "=",
   "max",
   "(",
   "range_start",
   ",",
   "self",
   ".",
   "start_date",
   ")",
   "end_date",
   "=",
   "range_end",
   "if",
   "self",
   ".",
   "end_date",
   ":",
   "end_date",
   "=",
   "min",
   "(",
   "end_date",
   ",",
   "self",
   ".",
   "end_date",
   ")",
   "while",
   "current_date",
   "<=",
   "end_date",
   ":",
   "if",
   "current_date",
   ".",
   "weekday",
   "(",
   ")",
   "in",
   "weekdays",
   "and",
   "current_date",
   "not",
   "in",
   "exclude_dates",
   ":",
   "yield",
   "Period",
   "(",
   "tz",
   ".",
   "localize",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "current_date",
   ",",
   "period",
   ".",
   "start",
   ")",
   ")",
   ",",
   "tz",
   ".",
   "localize",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "current_date",
   ",",
   "period",
   ".",
   "end",
   ")",
   ")",
   ")",
   "current_date",
   "+=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "days",
   "=",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-279",
  "nl_tokens": [
   "Plot",
   "the",
   "temporal",
   "distance",
   "probability",
   "density",
   "function",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_temporal_distance_pdf_horizontal",
   "(",
   "self",
   ",",
   "use_minutes",
   "=",
   "True",
   ",",
   "color",
   "=",
   "\"green\"",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "duration_divider",
   "=",
   "60.0",
   ",",
   "legend_font_size",
   "=",
   "None",
   ",",
   "legend_loc",
   "=",
   "None",
   ")",
   ":",
   "from",
   "matplotlib",
   "import",
   "pyplot",
   "as",
   "plt",
   "plt",
   ".",
   "rc",
   "(",
   "'text'",
   ",",
   "usetex",
   "=",
   "True",
   ")",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "111",
   ")",
   "temporal_distance_split_points_ordered",
   ",",
   "densities",
   ",",
   "delta_peaks",
   "=",
   "self",
   ".",
   "_temporal_distance_pdf",
   "(",
   ")",
   "xs",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "x",
   "in",
   "enumerate",
   "(",
   "temporal_distance_split_points_ordered",
   ")",
   ":",
   "xs",
   ".",
   "append",
   "(",
   "x",
   ")",
   "xs",
   ".",
   "append",
   "(",
   "x",
   ")",
   "xs",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "xs",
   ")",
   "ys",
   "=",
   "[",
   "0",
   "]",
   "for",
   "y",
   "in",
   "densities",
   ":",
   "ys",
   ".",
   "append",
   "(",
   "y",
   ")",
   "ys",
   ".",
   "append",
   "(",
   "y",
   ")",
   "ys",
   ".",
   "append",
   "(",
   "0",
   ")",
   "ys",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "ys",
   ")",
   "# convert data to minutes:",
   "xlabel",
   "=",
   "\"Temporal distance (s)\"",
   "ylabel",
   "=",
   "\"Probability density $P(\\\\tau)$\"",
   "if",
   "use_minutes",
   ":",
   "xs",
   "/=",
   "duration_divider",
   "ys",
   "*=",
   "duration_divider",
   "xlabel",
   "=",
   "\"Temporal distance (min)\"",
   "delta_peaks",
   "=",
   "{",
   "peak",
   "/",
   "60.0",
   ":",
   "mass",
   "for",
   "peak",
   ",",
   "mass",
   "in",
   "delta_peaks",
   ".",
   "items",
   "(",
   ")",
   "}",
   "if",
   "delta_peaks",
   ":",
   "peak_height",
   "=",
   "<mask>",
   "(",
   "ys",
   ")",
   "*",
   "1.4",
   "max_x",
   "=",
   "max",
   "(",
   "xs",
   ")",
   "min_x",
   "=",
   "min",
   "(",
   "xs",
   ")",
   "now_max_x",
   "=",
   "max",
   "(",
   "xs",
   ")",
   "+",
   "0.3",
   "*",
   "(",
   "max_x",
   "-",
   "min_x",
   ")",
   "now_min_x",
   "=",
   "min_x",
   "-",
   "0.1",
   "*",
   "(",
   "max_x",
   "-",
   "min_x",
   ")",
   "text_x_offset",
   "=",
   "0.1",
   "*",
   "(",
   "now_max_x",
   "-",
   "max_x",
   ")",
   "for",
   "loc",
   ",",
   "mass",
   "in",
   "delta_peaks",
   ".",
   "items",
   "(",
   ")",
   ":",
   "text",
   "=",
   "\"$P(\\\\mathrm{walk}) = \"",
   "+",
   "(",
   "\"%.2f$\"",
   "%",
   "(",
   "mass",
   ")",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "[",
   "0",
   ",",
   "peak_height",
   "]",
   ",",
   "[",
   "loc",
   ",",
   "loc",
   "]",
   ",",
   "color",
   "=",
   "color",
   ",",
   "lw",
   "=",
   "5",
   ",",
   "label",
   "=",
   "text",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "ys",
   ",",
   "xs",
   ",",
   "\"k-\"",
   ")",
   "if",
   "delta_peaks",
   ":",
   "tot_delta_peak_mass",
   "=",
   "sum",
   "(",
   "delta_peaks",
   ".",
   "values",
   "(",
   ")",
   ")",
   "fill_label",
   "=",
   "\"$P(\\\\mathrm{PT}) = %.2f$\"",
   "%",
   "(",
   "1",
   "-",
   "tot_delta_peak_mass",
   ")",
   "else",
   ":",
   "fill_label",
   "=",
   "None",
   "ax",
   ".",
   "fill_betweenx",
   "(",
   "xs",
   ",",
   "ys",
   ",",
   "color",
   "=",
   "color",
   ",",
   "alpha",
   "=",
   "0.2",
   ",",
   "label",
   "=",
   "fill_label",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "xlabel",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "ylabel",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "left",
   "=",
   "0",
   ",",
   "right",
   "=",
   "max",
   "(",
   "ys",
   ")",
   "*",
   "1.2",
   ")",
   "if",
   "delta_peaks",
   ":",
   "if",
   "legend_font_size",
   "is",
   "None",
   ":",
   "legend_font_size",
   "=",
   "12",
   "if",
   "legend_loc",
   "is",
   "None",
   ":",
   "legend_loc",
   "=",
   "\"best\"",
   "ax",
   ".",
   "legend",
   "(",
   "loc",
   "=",
   "legend_loc",
   ",",
   "prop",
   "=",
   "{",
   "'size'",
   ":",
   "legend_font_size",
   "}",
   ")",
   "if",
   "True",
   ":",
   "line_tyles",
   "=",
   "[",
   "\"-.\"",
   ",",
   "\"--\"",
   ",",
   "\"-\"",
   "]",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "to_plot_funcs",
   "=",
   "[",
   "self",
   ".",
   "max_temporal_distance",
   ",",
   "self",
   ".",
   "mean_temporal_distance",
   ",",
   "self",
   ".",
   "min_temporal_distance",
   "]",
   "xmin",
   ",",
   "xmax",
   "=",
   "ax",
   ".",
   "get_xlim",
   "(",
   ")",
   "for",
   "to_plot_func",
   ",",
   "ls",
   "in",
   "zip",
   "(",
   "to_plot_funcs",
   ",",
   "line_tyles",
   ")",
   ":",
   "y",
   "=",
   "to_plot_func",
   "(",
   ")",
   "/",
   "duration_divider",
   "assert",
   "y",
   "<",
   "float",
   "(",
   "'inf'",
   ")",
   "# factor of 10 just to be safe that the lines cover the whole region.",
   "ax",
   ".",
   "plot",
   "(",
   "[",
   "xmin",
   ",",
   "xmax",
   "*",
   "10",
   "]",
   ",",
   "[",
   "y",
   ",",
   "y",
   "]",
   ",",
   "color",
   "=",
   "\"black\"",
   ",",
   "ls",
   "=",
   "ls",
   ",",
   "lw",
   "=",
   "1",
   ")",
   "return",
   "ax",
   ".",
   "figure"
  ]
 },
 {
  "idx": "maxmin-280",
  "nl_tokens": [
   "Calculate",
   "the",
   "total",
   "SNR",
   "of",
   "a",
   "transit",
   "assuming",
   "gaussian",
   "uncertainties",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_snr_of_dip",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "modeltimes",
   ",",
   "modelmags",
   ",",
   "atol_normalization",
   "=",
   "1e-8",
   ",",
   "indsforrms",
   "=",
   "None",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "verbose",
   "=",
   "True",
   ",",
   "transitdepth",
   "=",
   "None",
   ",",
   "npoints_in_transit",
   "=",
   "None",
   ")",
   ":",
   "if",
   "magsarefluxes",
   ":",
   "if",
   "not",
   "np",
   ".",
   "isclose",
   "(",
   "np",
   ".",
   "nanmedian",
   "(",
   "modelmags",
   ")",
   ",",
   "1",
   ",",
   "atol",
   "=",
   "atol_normalization",
   ")",
   ":",
   "raise",
   "AssertionError",
   "(",
   "'snr calculation assumes modelmags are '",
   "'median-normalized'",
   ")",
   "else",
   ":",
   "raise",
   "NotImplementedError",
   "(",
   "'need to implement a method for identifying in-transit points when'",
   "'mags are mags, and not fluxes'",
   ")",
   "if",
   "not",
   "transitdepth",
   ":",
   "# calculate transit depth from whatever model magnitudes are passed.",
   "transitdepth",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "modelmags",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "modelmags",
   ")",
   ")",
   "# generally, mags (data) and modelmags are at different cadence.",
   "# interpolate modelmags onto the cadence of mags.",
   "if",
   "not",
   "len",
   "(",
   "mags",
   ")",
   "==",
   "len",
   "(",
   "modelmags",
   ")",
   ":",
   "from",
   "scipy",
   ".",
   "interpolate",
   "import",
   "interp1d",
   "fn",
   "=",
   "interp1d",
   "(",
   "modeltimes",
   ",",
   "modelmags",
   ",",
   "kind",
   "=",
   "'cubic'",
   ",",
   "bounds_error",
   "=",
   "True",
   ",",
   "fill_value",
   "=",
   "np",
   ".",
   "nan",
   ")",
   "modelmags",
   "=",
   "fn",
   "(",
   "times",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'interpolated model timeseries onto the data timeseries'",
   ")",
   "subtractedmags",
   "=",
   "mags",
   "-",
   "modelmags",
   "if",
   "isinstance",
   "(",
   "indsforrms",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "subtractedrms",
   "=",
   "np",
   ".",
   "std",
   "(",
   "subtractedmags",
   "[",
   "indsforrms",
   "]",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using selected points to measure RMS'",
   ")",
   "else",
   ":",
   "subtractedrms",
   "=",
   "np",
   ".",
   "std",
   "(",
   "subtractedmags",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using all points to measure RMS'",
   ")",
   "def",
   "_get_npoints_in_transit",
   "(",
   "modelmags",
   ")",
   ":",
   "# assumes median-normalized fluxes are input",
   "if",
   "np",
   ".",
   "nanmedian",
   "(",
   "modelmags",
   ")",
   "==",
   "1",
   ":",
   "return",
   "len",
   "(",
   "modelmags",
   "[",
   "(",
   "modelmags",
   "!=",
   "1",
   ")",
   "]",
   ")",
   "else",
   ":",
   "raise",
   "NotImplementedError",
   "if",
   "not",
   "npoints_in_transit",
   ":",
   "npoints_in_transit",
   "=",
   "_get_npoints_in_transit",
   "(",
   "modelmags",
   ")",
   "snr",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "npoints_in_transit",
   ")",
   "*",
   "transitdepth",
   "/",
   "subtractedrms",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'\\npoints in transit: {:d}'",
   ".",
   "format",
   "(",
   "npoints_in_transit",
   ")",
   "+",
   "'\\ndepth: {:.2e}'",
   ".",
   "format",
   "(",
   "transitdepth",
   ")",
   "+",
   "'\\nrms in residual: {:.2e}'",
   ".",
   "format",
   "(",
   "subtractedrms",
   ")",
   "+",
   "'\\n\\t SNR: {:.2e}'",
   ".",
   "format",
   "(",
   "snr",
   ")",
   ")",
   "return",
   "snr",
   ",",
   "transitdepth",
   ",",
   "subtractedrms"
  ]
 },
 {
  "idx": "maxmin-281",
  "nl_tokens": [
   "Create",
   "a",
   "new",
   "image",
   "of",
   "the",
   "same",
   "class",
   "as",
   "the",
   "reference",
   "image"
  ],
  "pl_tokens": [
   "def",
   "new_img_like",
   "(",
   "ref_niimg",
   ",",
   "data",
   ",",
   "affine",
   "=",
   "None",
   ",",
   "copy_header",
   "=",
   "False",
   ")",
   ":",
   "# Hand-written loading code to avoid too much memory consumption",
   "if",
   "not",
   "(",
   "hasattr",
   "(",
   "ref_niimg",
   ",",
   "'get_data'",
   ")",
   "and",
   "hasattr",
   "(",
   "ref_niimg",
   ",",
   "'get_affine'",
   ")",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "ref_niimg",
   ",",
   "_basestring",
   ")",
   ":",
   "ref_niimg",
   "=",
   "nib",
   ".",
   "load",
   "(",
   "ref_niimg",
   ")",
   "elif",
   "operator",
   ".",
   "isSequenceType",
   "(",
   "ref_niimg",
   ")",
   ":",
   "ref_niimg",
   "=",
   "nib",
   ".",
   "load",
   "(",
   "ref_niimg",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "raise",
   "TypeError",
   "(",
   "(",
   "'The reference image should be a niimg, %r '",
   "'was passed'",
   ")",
   "%",
   "ref_niimg",
   ")",
   "if",
   "affine",
   "is",
   "None",
   ":",
   "affine",
   "=",
   "ref_niimg",
   ".",
   "get_affine",
   "(",
   ")",
   "if",
   "data",
   ".",
   "dtype",
   "==",
   "bool",
   ":",
   "default_dtype",
   "=",
   "np",
   ".",
   "int8",
   "if",
   "(",
   "LooseVersion",
   "(",
   "nib",
   ".",
   "__version__",
   ")",
   ">=",
   "LooseVersion",
   "(",
   "'1.2.0'",
   ")",
   "and",
   "isinstance",
   "(",
   "ref_niimg",
   ",",
   "nib",
   ".",
   "freesurfer",
   ".",
   "mghformat",
   ".",
   "MGHImage",
   ")",
   ")",
   ":",
   "default_dtype",
   "=",
   "np",
   ".",
   "uint8",
   "data",
   "=",
   "as_ndarray",
   "(",
   "data",
   ",",
   "dtype",
   "=",
   "default_dtype",
   ")",
   "header",
   "=",
   "None",
   "if",
   "copy_header",
   ":",
   "header",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "ref_niimg",
   ".",
   "get_header",
   "(",
   ")",
   ")",
   "header",
   "[",
   "'scl_slope'",
   "]",
   "=",
   "0.",
   "header",
   "[",
   "'scl_inter'",
   "]",
   "=",
   "0.",
   "header",
   "[",
   "'glmax'",
   "]",
   "=",
   "0.",
   "header",
   "[",
   "'cal_max'",
   "]",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "data",
   ")",
   "if",
   "data",
   ".",
   "size",
   ">",
   "0",
   "else",
   "0.",
   "header",
   "[",
   "'cal_max'",
   "]",
   "=",
   "np",
   ".",
   "min",
   "(",
   "data",
   ")",
   "if",
   "data",
   ".",
   "size",
   ">",
   "0",
   "else",
   "0.",
   "return",
   "ref_niimg",
   ".",
   "__class__",
   "(",
   "data",
   ",",
   "affine",
   ",",
   "header",
   "=",
   "header",
   ")"
  ]
 },
 {
  "idx": "maxmin-282",
  "nl_tokens": [
   "let",
   "s",
   "keep",
   "the",
   "chunkMs",
   "as",
   "high",
   "as",
   "we",
   "reasonably",
   "can",
   ".",
   "50ms",
   "is",
   "good",
   ".",
   "Things",
   "get",
   "flakey",
   "at",
   "lower",
   "numbers",
   "like",
   "10ms",
   ".",
   "IMPORTANT!",
   "for",
   "this",
   "to",
   "work",
   "prevent",
   "0s",
   "from",
   "averaging",
   "in",
   "so",
   "keep",
   "bin",
   "sizes",
   "well",
   "above",
   "the",
   "data",
   "resolution",
   "."
  ],
  "pl_tokens": [
   "def",
   "phasicTonic",
   "(",
   "self",
   ",",
   "m1",
   "=",
   "None",
   ",",
   "m2",
   "=",
   "None",
   ",",
   "chunkMs",
   "=",
   "50",
   ",",
   "quietPercentile",
   "=",
   "10",
   ",",
   "histResolution",
   "=",
   ".5",
   ",",
   "plotToo",
   "=",
   "False",
   ")",
   ":",
   "# prepare sectioning values to be used later",
   "m1",
   "=",
   "0",
   "if",
   "m1",
   "is",
   "None",
   "else",
   "m1",
   "*",
   "self",
   ".",
   "pointsPerSec",
   "m2",
   "=",
   "len",
   "(",
   "abf",
   ".",
   "sweepY",
   ")",
   "if",
   "m2",
   "is",
   "None",
   "else",
   "m2",
   "*",
   "self",
   ".",
   "pointsPerSec",
   "m1",
   ",",
   "m2",
   "=",
   "int",
   "(",
   "m1",
   ")",
   ",",
   "int",
   "(",
   "m2",
   ")",
   "# prepare histogram values to be used later",
   "padding",
   "=",
   "200",
   "# pA or mV of maximum expected deviation",
   "chunkPoints",
   "=",
   "int",
   "(",
   "chunkMs",
   "*",
   "self",
   ".",
   "pointsPerMs",
   ")",
   "histBins",
   "=",
   "int",
   "(",
   "(",
   "padding",
   "*",
   "2",
   ")",
   "/",
   "histResolution",
   ")",
   "# center the data at 0 using peak histogram, not the mean",
   "Y",
   "=",
   "self",
   ".",
   "sweepY",
   "[",
   "m1",
   ":",
   "m2",
   "]",
   "hist",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "Y",
   ",",
   "bins",
   "=",
   "2",
   "*",
   "padding",
   ")",
   "Yoffset",
   "=",
   "bins",
   "[",
   "np",
   ".",
   "where",
   "(",
   "hist",
   "==",
   "<mask>",
   "(",
   "hist",
   ")",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "]",
   "Y",
   "=",
   "Y",
   "-",
   "Yoffset",
   "# we don't have to, but PDF math is easier",
   "# calculate all histogram",
   "nChunks",
   "=",
   "int",
   "(",
   "len",
   "(",
   "Y",
   ")",
   "/",
   "chunkPoints",
   ")",
   "hist",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "Y",
   ",",
   "bins",
   "=",
   "histBins",
   ",",
   "range",
   "=",
   "(",
   "-",
   "padding",
   ",",
   "padding",
   ")",
   ")",
   "hist",
   "=",
   "hist",
   "/",
   "len",
   "(",
   "Y",
   ")",
   "# count as a fraction of total",
   "Xs",
   "=",
   "bins",
   "[",
   "1",
   ":",
   "]",
   "# get baseline data from chunks with smallest variance",
   "chunks",
   "=",
   "np",
   ".",
   "reshape",
   "(",
   "Y",
   "[",
   ":",
   "nChunks",
   "*",
   "chunkPoints",
   "]",
   ",",
   "(",
   "nChunks",
   ",",
   "chunkPoints",
   ")",
   ")",
   "variances",
   "=",
   "np",
   ".",
   "var",
   "(",
   "chunks",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "percentiles",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "len",
   "(",
   "variances",
   ")",
   ")",
   "for",
   "i",
   ",",
   "variance",
   "in",
   "enumerate",
   "(",
   "variances",
   ")",
   ":",
   "percentiles",
   "[",
   "i",
   "]",
   "=",
   "sorted",
   "(",
   "variances",
   ")",
   ".",
   "index",
   "(",
   "variance",
   ")",
   "/",
   "len",
   "(",
   "variances",
   ")",
   "*",
   "100",
   "blData",
   "=",
   "chunks",
   "[",
   "np",
   ".",
   "where",
   "(",
   "percentiles",
   "<=",
   "quietPercentile",
   ")",
   "[",
   "0",
   "]",
   "]",
   ".",
   "flatten",
   "(",
   ")",
   "# generate the standard curve and pull it to the histogram height",
   "sigma",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "var",
   "(",
   "blData",
   ")",
   ")",
   "center",
   "=",
   "np",
   ".",
   "average",
   "(",
   "blData",
   ")",
   "+",
   "histResolution",
   "/",
   "2",
   "blCurve",
   "=",
   "mlab",
   ".",
   "normpdf",
   "(",
   "Xs",
   ",",
   "center",
   ",",
   "sigma",
   ")",
   "blCurve",
   "=",
   "blCurve",
   "*",
   "max",
   "(",
   "hist",
   ")",
   "/",
   "max",
   "(",
   "blCurve",
   ")",
   "# determine the phasic current by subtracting-out the baseline",
   "#diff=hist-blCurve",
   "diff",
   "=",
   "hist",
   "IGNORE_DISTANCE",
   "=",
   "5",
   "# KEEP THIS FIXED, NOT A FUNCTION OF VARIANCE",
   "ignrCenter",
   "=",
   "len",
   "(",
   "Xs",
   ")",
   "/",
   "2",
   "ignrPad",
   "=",
   "IGNORE_DISTANCE",
   "/",
   "histResolution",
   "ignr1",
   ",",
   "ignt2",
   "=",
   "int",
   "(",
   "ignrCenter",
   "-",
   "ignrPad",
   ")",
   ",",
   "int",
   "(",
   "ignrCenter",
   "+",
   "ignrPad",
   ")",
   "diff",
   "[",
   "ignr1",
   ":",
   "ignt2",
   "]",
   "=",
   "0",
   "# optionally graph all this",
   "if",
   "plotToo",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "15",
   ",",
   "5",
   ")",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "Y",
   ")",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "7",
   ",",
   "7",
   ")",
   ")",
   "ax1",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "211",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "abf",
   ".",
   "ID",
   "+",
   "\" phasic analysis\"",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "\"fraction\"",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "Xs",
   ",",
   "hist",
   ",",
   "'-'",
   ",",
   "alpha",
   "=",
   ".8",
   ",",
   "color",
   "=",
   "'b'",
   ",",
   "lw",
   "=",
   "3",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "Xs",
   ",",
   "blCurve",
   ",",
   "lw",
   "=",
   "3",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "color",
   "=",
   "'r'",
   ")",
   "plt",
   ".",
   "margins",
   "(",
   "0",
   ",",
   ".1",
   ")",
   "plt",
   ".",
   "subplot",
   "(",
   "212",
   ",",
   "sharex",
   "=",
   "ax1",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "\"baseline subtracted\"",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "\"fraction\"",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "\"data points (%s)\"",
   "%",
   "abf",
   ".",
   "units",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "Xs",
   ",",
   "diff",
   ",",
   "'-'",
   ",",
   "alpha",
   "=",
   ".8",
   ",",
   "color",
   "=",
   "'b'",
   ",",
   "lw",
   "=",
   "3",
   ")",
   "plt",
   ".",
   "axhline",
   "(",
   "0",
   ",",
   "lw",
   "=",
   "3",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "color",
   "=",
   "'r'",
   ")",
   "plt",
   ".",
   "axvline",
   "(",
   "0",
   ",",
   "lw",
   "=",
   "3",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "color",
   "=",
   "'k'",
   ")",
   "plt",
   ".",
   "margins",
   "(",
   "0",
   ",",
   ".1",
   ")",
   "plt",
   ".",
   "axis",
   "(",
   "[",
   "-",
   "50",
   ",",
   "50",
   ",",
   "None",
   ",",
   "None",
   "]",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "print",
   "(",
   "np",
   ".",
   "sum",
   "(",
   "np",
   ".",
   "split",
   "(",
   "diff",
   ",",
   "2",
   ")",
   ",",
   "1",
   ")",
   ")",
   "return",
   "diff",
   "/",
   "len",
   "(",
   "Y",
   ")",
   "*",
   "abf",
   ".",
   "pointsPerSec"
  ]
 },
 {
  "idx": "maxmin-283",
  "nl_tokens": [
   "Create",
   "a",
   "string",
   "representation",
   "for",
   "each",
   "item",
   "in",
   "a",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "_list_itemstrs",
   "(",
   "list_",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "items",
   "=",
   "list",
   "(",
   "list_",
   ")",
   "kwargs",
   "[",
   "'_return_info'",
   "]",
   "=",
   "True",
   "_tups",
   "=",
   "[",
   "repr2",
   "(",
   "item",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "for",
   "item",
   "in",
   "items",
   "]",
   "itemstrs",
   "=",
   "[",
   "t",
   "[",
   "0",
   "]",
   "for",
   "t",
   "in",
   "_tups",
   "]",
   "max_height",
   "=",
   "<mask>",
   "(",
   "[",
   "t",
   "[",
   "1",
   "]",
   "[",
   "'max_height'",
   "]",
   "for",
   "t",
   "in",
   "_tups",
   "]",
   ")",
   "if",
   "_tups",
   "else",
   "0",
   "_leaf_info",
   "=",
   "{",
   "'max_height'",
   ":",
   "max_height",
   "+",
   "1",
   ",",
   "}",
   "sort",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'sort'",
   ",",
   "None",
   ")",
   "if",
   "sort",
   "is",
   "None",
   ":",
   "# Force orderings on sets.",
   "sort",
   "=",
   "isinstance",
   "(",
   "list_",
   ",",
   "(",
   "set",
   ",",
   "frozenset",
   ")",
   ")",
   "if",
   "sort",
   ":",
   "itemstrs",
   "=",
   "_sort_itemstrs",
   "(",
   "items",
   ",",
   "itemstrs",
   ")",
   "return",
   "itemstrs",
   ",",
   "_leaf_info"
  ]
 },
 {
  "idx": "maxmin-284",
  "nl_tokens": [
   "Smooth",
   "(",
   "and",
   "optionally",
   "differentiate",
   ")",
   "with",
   "a",
   "Savitzky",
   "-",
   "Golay",
   "filter",
   "."
  ],
  "pl_tokens": [
   "def",
   "filter_savitzky_golay",
   "(",
   "y",
   ",",
   "window_size",
   "=",
   "5",
   ",",
   "order",
   "=",
   "2",
   ",",
   "deriv",
   "=",
   "0",
   ",",
   "rate",
   "=",
   "1",
   ")",
   ":",
   "try",
   ":",
   "window_size",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "int",
   "(",
   "window_size",
   ")",
   ")",
   "order",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "int",
   "(",
   "order",
   ")",
   ")",
   "except",
   "ValueError",
   ":",
   "raise",
   "ValueError",
   "(",
   "'window_size and order must be integers'",
   ")",
   "if",
   "window_size",
   "%",
   "2",
   "!=",
   "1",
   "or",
   "window_size",
   "<",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "'window_size size must be a positive odd number'",
   ")",
   "if",
   "window_size",
   "<",
   "order",
   "+",
   "2",
   ":",
   "raise",
   "ValueError",
   "(",
   "'window_size is too small for the polynomials order'",
   ")",
   "order_range",
   "=",
   "range",
   "(",
   "order",
   "+",
   "1",
   ")",
   "half_window",
   "=",
   "(",
   "window_size",
   "-",
   "1",
   ")",
   "//",
   "2",
   "# precompute limits",
   "minimum",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "y",
   ")",
   "maximum",
   "=",
   "np",
   ".",
   "max",
   "(",
   "y",
   ")",
   "# precompute coefficients",
   "b",
   "=",
   "np",
   ".",
   "mat",
   "(",
   "[",
   "[",
   "k",
   "**",
   "i",
   "for",
   "i",
   "in",
   "order_range",
   "]",
   "for",
   "k",
   "in",
   "range",
   "(",
   "-",
   "half_window",
   ",",
   "half_window",
   "+",
   "1",
   ")",
   "]",
   ")",
   "m",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "pinv",
   "(",
   "b",
   ")",
   ".",
   "A",
   "[",
   "deriv",
   "]",
   "*",
   "rate",
   "**",
   "deriv",
   "*",
   "math",
   ".",
   "factorial",
   "(",
   "deriv",
   ")",
   "# pad the signal at the extremes with values taken from the original signal",
   "firstvals",
   "=",
   "y",
   "[",
   "0",
   "]",
   "-",
   "np",
   ".",
   "abs",
   "(",
   "y",
   "[",
   "1",
   ":",
   "half_window",
   "+",
   "1",
   "]",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "-",
   "y",
   "[",
   "0",
   "]",
   ")",
   "lastvals",
   "=",
   "y",
   "[",
   "-",
   "1",
   "]",
   "+",
   "np",
   ".",
   "abs",
   "(",
   "y",
   "[",
   "-",
   "half_window",
   "-",
   "1",
   ":",
   "-",
   "1",
   "]",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "-",
   "y",
   "[",
   "-",
   "1",
   "]",
   ")",
   "y",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "firstvals",
   ",",
   "y",
   ",",
   "lastvals",
   ")",
   ")",
   "return",
   "np",
   ".",
   "clip",
   "(",
   "np",
   ".",
   "convolve",
   "(",
   "m",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "y",
   ",",
   "mode",
   "=",
   "'valid'",
   ")",
   ",",
   "minimum",
   ",",
   "maximum",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-285",
  "nl_tokens": [
   "See",
   "the",
   "function",
   "description",
   "in",
   "base",
   ".",
   "py"
  ],
  "pl_tokens": [
   "def",
   "closenessScores",
   "(",
   "self",
   ",",
   "expValues",
   ",",
   "actValues",
   ",",
   "fractional",
   "=",
   "True",
   ")",
   ":",
   "expValue",
   "=",
   "expValues",
   "[",
   "0",
   "]",
   "actValue",
   "=",
   "actValues",
   "[",
   "0",
   "]",
   "if",
   "self",
   ".",
   "periodic",
   ":",
   "expValue",
   "=",
   "expValue",
   "%",
   "self",
   ".",
   "maxval",
   "actValue",
   "=",
   "actValue",
   "%",
   "self",
   ".",
   "maxval",
   "err",
   "=",
   "abs",
   "(",
   "expValue",
   "-",
   "actValue",
   ")",
   "if",
   "self",
   ".",
   "periodic",
   ":",
   "err",
   "=",
   "<mask>",
   "(",
   "err",
   ",",
   "self",
   ".",
   "maxval",
   "-",
   "err",
   ")",
   "if",
   "fractional",
   ":",
   "pctErr",
   "=",
   "float",
   "(",
   "err",
   ")",
   "/",
   "(",
   "self",
   ".",
   "maxval",
   "-",
   "self",
   ".",
   "minval",
   ")",
   "pctErr",
   "=",
   "min",
   "(",
   "1.0",
   ",",
   "pctErr",
   ")",
   "closeness",
   "=",
   "1.0",
   "-",
   "pctErr",
   "else",
   ":",
   "closeness",
   "=",
   "err",
   "return",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "closeness",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-286",
  "nl_tokens": [
   "This",
   "generates",
   "fake",
   "flare",
   "light",
   "curves",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_flare_lightcurve",
   "(",
   "times",
   ",",
   "mags",
   "=",
   "None",
   ",",
   "errs",
   "=",
   "None",
   ",",
   "paramdists",
   "=",
   "{",
   "# flare peak amplitude from 0.01 mag to 1.0 mag above median.  this",
   "# is tuned for redder bands, flares are much stronger in bluer",
   "# bands, so tune appropriately for your situation.",
   "'amplitude'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.01",
   ",",
   "scale",
   "=",
   "0.99",
   ")",
   ",",
   "# up to 5 flares per LC and at least 1",
   "'nflares'",
   ":",
   "[",
   "1",
   ",",
   "5",
   "]",
   ",",
   "# 10 minutes to 1 hour for rise stdev",
   "'risestdev'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.007",
   ",",
   "scale",
   "=",
   "0.04",
   ")",
   ",",
   "# 1 hour to 4 hours for decay time constant",
   "'decayconst'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.04",
   ",",
   "scale",
   "=",
   "0.163",
   ")",
   "}",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   ")",
   ":",
   "if",
   "mags",
   "is",
   "None",
   ":",
   "mags",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "if",
   "errs",
   "is",
   "None",
   ":",
   "errs",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "nflares",
   "=",
   "npr",
   ".",
   "randint",
   "(",
   "paramdists",
   "[",
   "'nflares'",
   "]",
   "[",
   "0",
   "]",
   ",",
   "high",
   "=",
   "paramdists",
   "[",
   "'nflares'",
   "]",
   "[",
   "1",
   "]",
   ")",
   "# generate random flare peak times based on the number of flares",
   "flarepeaktimes",
   "=",
   "(",
   "npr",
   ".",
   "random",
   "(",
   "size",
   "=",
   "nflares",
   ")",
   "*",
   "(",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "times",
   ".",
   "min",
   "(",
   ")",
   ")",
   "+",
   "times",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# now add the flares to the time-series",
   "params",
   "=",
   "{",
   "'nflares'",
   ":",
   "nflares",
   "}",
   "for",
   "flareind",
   ",",
   "peaktime",
   "in",
   "zip",
   "(",
   "range",
   "(",
   "nflares",
   ")",
   ",",
   "flarepeaktimes",
   ")",
   ":",
   "# choose the amplitude, rise stdev and decay time constant",
   "amp",
   "=",
   "paramdists",
   "[",
   "'amplitude'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "risestdev",
   "=",
   "paramdists",
   "[",
   "'risestdev'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "decayconst",
   "=",
   "paramdists",
   "[",
   "'decayconst'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "# fix the transit depth if it needs to be flipped",
   "if",
   "magsarefluxes",
   "and",
   "amp",
   "<",
   "0.0",
   ":",
   "amp",
   "=",
   "-",
   "amp",
   "elif",
   "not",
   "magsarefluxes",
   "and",
   "amp",
   ">",
   "0.0",
   ":",
   "amp",
   "=",
   "-",
   "amp",
   "# add this flare to the light curve",
   "modelmags",
   ",",
   "ptimes",
   ",",
   "pmags",
   ",",
   "perrs",
   "=",
   "(",
   "flares",
   ".",
   "flare_model",
   "(",
   "[",
   "amp",
   ",",
   "peaktime",
   ",",
   "risestdev",
   ",",
   "decayconst",
   "]",
   ",",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ")",
   ")",
   "# update the mags",
   "mags",
   "=",
   "modelmags",
   "# add the flare params to the modeldict",
   "params",
   "[",
   "flareind",
   "]",
   "=",
   "{",
   "'peaktime'",
   ":",
   "peaktime",
   ",",
   "'amplitude'",
   ":",
   "amp",
   ",",
   "'risestdev'",
   ":",
   "risestdev",
   ",",
   "'decayconst'",
   ":",
   "decayconst",
   "}",
   "#",
   "# done with all flares",
   "#",
   "# return a dict with everything",
   "modeldict",
   "=",
   "{",
   "'vartype'",
   ":",
   "'flare'",
   ",",
   "'params'",
   ":",
   "params",
   ",",
   "'times'",
   ":",
   "times",
   ",",
   "'mags'",
   ":",
   "mags",
   ",",
   "'errs'",
   ":",
   "errs",
   ",",
   "'varperiod'",
   ":",
   "None",
   ",",
   "# FIXME: this is complicated because we can have multiple flares",
   "# figure out a good way to handle this upstream",
   "'varamplitude'",
   ":",
   "[",
   "params",
   "[",
   "x",
   "]",
   "[",
   "'amplitude'",
   "]",
   "for",
   "x",
   "in",
   "range",
   "(",
   "params",
   "[",
   "'nflares'",
   "]",
   ")",
   "]",
   ",",
   "}",
   "return",
   "modeldict"
  ]
 },
 {
  "idx": "maxmin-287",
  "nl_tokens": [
   "An",
   "integer",
   "/",
   "float",
   "-",
   "valued",
   "enumerable",
   "with",
   "num",
   "items",
   "bounded",
   "between",
   "[",
   "min",
   "max",
   "]",
   ".",
   "Note",
   "that",
   "the",
   "right",
   "endpoint",
   "of",
   "the",
   "interval",
   "includes",
   "max",
   ".",
   "This",
   "is",
   "a",
   "wrapper",
   "around",
   "the",
   "add_enum",
   ".",
   "jump",
   "can",
   "be",
   "a",
   "float",
   "or",
   "int",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_jump",
   "(",
   "self",
   ",",
   "name",
   ",",
   "<mask>",
   ",",
   "max",
   ",",
   "num",
   ",",
   "warp",
   "=",
   "None",
   ",",
   "var_type",
   "=",
   "float",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "var_type",
   ",",
   "type",
   ")",
   ":",
   "if",
   "var_type",
   "==",
   "'int'",
   ":",
   "var_type",
   "=",
   "int",
   "elif",
   "var_type",
   "==",
   "'float'",
   ":",
   "var_type",
   "=",
   "float",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'var_type (%s) is not supported. use '",
   "'\"int\" or \"float\",'",
   "%",
   "(",
   "var_type",
   ")",
   ")",
   "min",
   ",",
   "max",
   "=",
   "map",
   "(",
   "var_type",
   ",",
   "(",
   "min",
   ",",
   "max",
   ")",
   ")",
   "num",
   "=",
   "int",
   "(",
   "num",
   ")",
   "if",
   "not",
   "warp",
   ":",
   "choices",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "min",
   ",",
   "max",
   ",",
   "num",
   "=",
   "num",
   ",",
   "dtype",
   "=",
   "var_type",
   ")",
   "elif",
   "(",
   "min",
   ">=",
   "0",
   ")",
   "and",
   "warp",
   "==",
   "'log'",
   ":",
   "choices",
   "=",
   "np",
   ".",
   "logspace",
   "(",
   "np",
   ".",
   "log10",
   "(",
   "min",
   ")",
   ",",
   "np",
   ".",
   "log10",
   "(",
   "max",
   ")",
   ",",
   "num",
   "=",
   "num",
   ",",
   "dtype",
   "=",
   "var_type",
   ")",
   "elif",
   "(",
   "min",
   "<=",
   "0",
   ")",
   "and",
   "warp",
   "==",
   "'log'",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: log-warping requires min > 0'",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: warp=%s is not supported. use '",
   "'None or \"log\",'",
   "%",
   "(",
   "name",
   ",",
   "warp",
   ")",
   ")",
   "self",
   ".",
   "variables",
   "[",
   "name",
   "]",
   "=",
   "EnumVariable",
   "(",
   "name",
   ",",
   "choices",
   ".",
   "tolist",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-288",
  "nl_tokens": [
   "Format",
   "a",
   "paragraph",
   "of",
   "free",
   "-",
   "form",
   "text",
   "for",
   "inclusion",
   "in",
   "the",
   "help",
   "output",
   "at",
   "the",
   "current",
   "indentation",
   "level",
   "."
  ],
  "pl_tokens": [
   "def",
   "_format_text",
   "(",
   "self",
   ",",
   "text",
   ")",
   ":",
   "text_width",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "width",
   "-",
   "self",
   ".",
   "current_indent",
   ",",
   "11",
   ")",
   "indent",
   "=",
   "\" \"",
   "*",
   "self",
   ".",
   "current_indent",
   "return",
   "textwrap",
   ".",
   "fill",
   "(",
   "text",
   ",",
   "text_width",
   ",",
   "initial_indent",
   "=",
   "indent",
   ",",
   "subsequent_indent",
   "=",
   "indent",
   ")"
  ]
 },
 {
  "idx": "maxmin-289",
  "nl_tokens": [
   ":",
   "param",
   "multi_ts",
   ":",
   ":",
   "return",
   ":"
  ],
  "pl_tokens": [
   "def",
   "compute_max",
   "(",
   "self",
   ",",
   "multi_ts",
   ")",
   ":",
   "if",
   "len",
   "(",
   "multi_ts",
   ")",
   ">",
   "0",
   "and",
   "len",
   "(",
   "multi_ts",
   "[",
   "0",
   "]",
   "[",
   "\"timeline\"",
   "]",
   ")",
   ">",
   "0",
   ":",
   "keys",
   "=",
   "multi_ts",
   "[",
   "0",
   "]",
   "[",
   "\"timeline\"",
   "]",
   "[",
   "0",
   "]",
   "[",
   "\"data\"",
   "]",
   ".",
   "keys",
   "(",
   ")",
   "timelines",
   "=",
   "(",
   "[",
   "res",
   "[",
   "\"timeline\"",
   "]",
   "[",
   "0",
   "]",
   "[",
   "\"data\"",
   "]",
   "[",
   "key",
   "]",
   "for",
   "key",
   "in",
   "keys",
   "]",
   "for",
   "res",
   "in",
   "multi_ts",
   ")",
   "values",
   "=",
   "(",
   "<mask>",
   "(",
   "v",
   ")",
   "for",
   "v",
   "in",
   "zip",
   "(",
   "*",
   "timelines",
   ")",
   ")",
   "return",
   "dict",
   "(",
   "zip",
   "(",
   "keys",
   ",",
   "values",
   ")",
   ")",
   "return",
   "{",
   "}"
  ]
 },
 {
  "idx": "maxmin-290",
  "nl_tokens": [
   "This",
   "generates",
   "fake",
   "EB",
   "light",
   "curves",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_eb_lightcurve",
   "(",
   "times",
   ",",
   "mags",
   "=",
   "None",
   ",",
   "errs",
   "=",
   "None",
   ",",
   "paramdists",
   "=",
   "{",
   "'period'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.2",
   ",",
   "scale",
   "=",
   "99.8",
   ")",
   ",",
   "'pdepth'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "1.0e-4",
   ",",
   "scale",
   "=",
   "0.7",
   ")",
   ",",
   "'pduration'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.01",
   ",",
   "scale",
   "=",
   "0.44",
   ")",
   ",",
   "'depthratio'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.01",
   ",",
   "scale",
   "=",
   "0.99",
   ")",
   ",",
   "'secphase'",
   ":",
   "sps",
   ".",
   "norm",
   "(",
   "loc",
   "=",
   "0.5",
   ",",
   "scale",
   "=",
   "0.1",
   ")",
   "}",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   ")",
   ":",
   "if",
   "mags",
   "is",
   "None",
   ":",
   "mags",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "if",
   "errs",
   "is",
   "None",
   ":",
   "errs",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "# choose the epoch",
   "epoch",
   "=",
   "npr",
   ".",
   "random",
   "(",
   ")",
   "*",
   "(",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "times",
   ".",
   "min",
   "(",
   ")",
   ")",
   "+",
   "times",
   ".",
   "min",
   "(",
   ")",
   "# choose the period, pdepth, duration, depthratio",
   "period",
   "=",
   "paramdists",
   "[",
   "'period'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "pdepth",
   "=",
   "paramdists",
   "[",
   "'pdepth'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "pduration",
   "=",
   "paramdists",
   "[",
   "'pduration'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "depthratio",
   "=",
   "paramdists",
   "[",
   "'depthratio'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "secphase",
   "=",
   "paramdists",
   "[",
   "'secphase'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "# fix the transit depth if it needs to be flipped",
   "if",
   "magsarefluxes",
   "and",
   "pdepth",
   "<",
   "0.0",
   ":",
   "pdepth",
   "=",
   "-",
   "pdepth",
   "elif",
   "not",
   "magsarefluxes",
   "and",
   "pdepth",
   ">",
   "0.0",
   ":",
   "pdepth",
   "=",
   "-",
   "pdepth",
   "# generate the model",
   "modelmags",
   ",",
   "phase",
   ",",
   "ptimes",
   ",",
   "pmags",
   ",",
   "perrs",
   "=",
   "(",
   "eclipses",
   ".",
   "invgauss_eclipses_func",
   "(",
   "[",
   "period",
   ",",
   "epoch",
   ",",
   "pdepth",
   ",",
   "pduration",
   ",",
   "depthratio",
   ",",
   "secphase",
   "]",
   ",",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ")",
   ")",
   "# resort in original time order",
   "timeind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "ptimes",
   ")",
   "mtimes",
   "=",
   "ptimes",
   "[",
   "timeind",
   "]",
   "mmags",
   "=",
   "modelmags",
   "[",
   "timeind",
   "]",
   "merrs",
   "=",
   "perrs",
   "[",
   "timeind",
   "]",
   "# return a dict with everything",
   "modeldict",
   "=",
   "{",
   "'vartype'",
   ":",
   "'EB'",
   ",",
   "'params'",
   ":",
   "{",
   "x",
   ":",
   "np",
   ".",
   "asscalar",
   "(",
   "y",
   ")",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "[",
   "'period'",
   ",",
   "'epoch'",
   ",",
   "'pdepth'",
   ",",
   "'pduration'",
   ",",
   "'depthratio'",
   "]",
   ",",
   "[",
   "period",
   ",",
   "epoch",
   ",",
   "pdepth",
   ",",
   "pduration",
   ",",
   "depthratio",
   "]",
   ")",
   "}",
   ",",
   "'times'",
   ":",
   "mtimes",
   ",",
   "'mags'",
   ":",
   "mmags",
   ",",
   "'errs'",
   ":",
   "merrs",
   ",",
   "'varperiod'",
   ":",
   "period",
   ",",
   "'varamplitude'",
   ":",
   "pdepth",
   ",",
   "}",
   "return",
   "modeldict"
  ]
 },
 {
  "idx": "maxmin-291",
  "nl_tokens": [
   "Generate",
   "plots",
   "and",
   "tables",
   "for",
   "analyzing",
   "a",
   "strategy",
   "s",
   "performance",
   "."
  ],
  "pl_tokens": [
   "def",
   "create_perf_attrib_tear_sheet",
   "(",
   "returns",
   ",",
   "positions",
   ",",
   "factor_returns",
   ",",
   "factor_loadings",
   ",",
   "transactions",
   "=",
   "None",
   ",",
   "pos_in_dollars",
   "=",
   "True",
   ",",
   "return_fig",
   "=",
   "False",
   ",",
   "factor_partitions",
   "=",
   "FACTOR_PARTITIONS",
   ")",
   ":",
   "portfolio_exposures",
   ",",
   "perf_attrib_data",
   "=",
   "perf_attrib",
   ".",
   "perf_attrib",
   "(",
   "returns",
   ",",
   "positions",
   ",",
   "factor_returns",
   ",",
   "factor_loadings",
   ",",
   "transactions",
   ",",
   "pos_in_dollars",
   "=",
   "pos_in_dollars",
   ")",
   "display",
   "(",
   "Markdown",
   "(",
   "\"## Performance Relative to Common Risk Factors\"",
   ")",
   ")",
   "# aggregate perf attrib stats and show summary table",
   "perf_attrib",
   ".",
   "show_perf_attrib_stats",
   "(",
   "returns",
   ",",
   "positions",
   ",",
   "factor_returns",
   ",",
   "factor_loadings",
   ",",
   "transactions",
   ",",
   "pos_in_dollars",
   ")",
   "# one section for the returns plot, and for each factor grouping",
   "# one section for factor returns, and one for risk exposures",
   "vertical_sections",
   "=",
   "1",
   "+",
   "2",
   "*",
   "<mask>",
   "(",
   "len",
   "(",
   "factor_partitions",
   ")",
   ",",
   "1",
   ")",
   "current_section",
   "=",
   "0",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "[",
   "14",
   ",",
   "vertical_sections",
   "*",
   "6",
   "]",
   ")",
   "gs",
   "=",
   "gridspec",
   ".",
   "GridSpec",
   "(",
   "vertical_sections",
   ",",
   "1",
   ",",
   "wspace",
   "=",
   "0.5",
   ",",
   "hspace",
   "=",
   "0.5",
   ")",
   "perf_attrib",
   ".",
   "plot_returns",
   "(",
   "perf_attrib_data",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "gs",
   "[",
   "current_section",
   "]",
   ")",
   ")",
   "current_section",
   "+=",
   "1",
   "if",
   "factor_partitions",
   "is",
   "not",
   "None",
   ":",
   "for",
   "factor_type",
   ",",
   "partitions",
   "in",
   "factor_partitions",
   ".",
   "iteritems",
   "(",
   ")",
   ":",
   "columns_to_select",
   "=",
   "perf_attrib_data",
   ".",
   "columns",
   ".",
   "intersection",
   "(",
   "partitions",
   ")",
   "perf_attrib",
   ".",
   "plot_factor_contribution_to_perf",
   "(",
   "perf_attrib_data",
   "[",
   "columns_to_select",
   "]",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "gs",
   "[",
   "current_section",
   "]",
   ")",
   ",",
   "title",
   "=",
   "(",
   "'Cumulative common {} returns attribution'",
   ")",
   ".",
   "format",
   "(",
   "factor_type",
   ")",
   ")",
   "current_section",
   "+=",
   "1",
   "for",
   "factor_type",
   ",",
   "partitions",
   "in",
   "factor_partitions",
   ".",
   "iteritems",
   "(",
   ")",
   ":",
   "perf_attrib",
   ".",
   "plot_risk_exposures",
   "(",
   "portfolio_exposures",
   "[",
   "portfolio_exposures",
   ".",
   "columns",
   ".",
   "intersection",
   "(",
   "partitions",
   ")",
   "]",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "gs",
   "[",
   "current_section",
   "]",
   ")",
   ",",
   "title",
   "=",
   "'Daily {} factor exposures'",
   ".",
   "format",
   "(",
   "factor_type",
   ")",
   ")",
   "current_section",
   "+=",
   "1",
   "else",
   ":",
   "perf_attrib",
   ".",
   "plot_factor_contribution_to_perf",
   "(",
   "perf_attrib_data",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "gs",
   "[",
   "current_section",
   "]",
   ")",
   ")",
   "current_section",
   "+=",
   "1",
   "perf_attrib",
   ".",
   "plot_risk_exposures",
   "(",
   "portfolio_exposures",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "gs",
   "[",
   "current_section",
   "]",
   ")",
   ")",
   "gs",
   ".",
   "tight_layout",
   "(",
   "fig",
   ")",
   "if",
   "return_fig",
   ":",
   "return",
   "fig"
  ]
 },
 {
  "idx": "maxmin-292",
  "nl_tokens": [
   "Learn",
   "the",
   "transformation",
   "to",
   "shifted",
   "eigenvalues",
   ".",
   "Only",
   "depends",
   "on",
   "the",
   "input",
   "dimension",
   "."
  ],
  "pl_tokens": [
   "def",
   "fit",
   "(",
   "self",
   ",",
   "X",
   ",",
   "y",
   "=",
   "None",
   ")",
   ":",
   "n",
   "=",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "if",
   "X",
   ".",
   "shape",
   "!=",
   "(",
   "n",
   ",",
   "n",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Input must be a square matrix.\"",
   ")",
   "self",
   ".",
   "train_",
   "=",
   "X",
   "memory",
   "=",
   "get_memory",
   "(",
   "self",
   ".",
   "memory",
   ")",
   "lo",
   ",",
   "=",
   "memory",
   ".",
   "cache",
   "(",
   "scipy",
   ".",
   "linalg",
   ".",
   "eigvalsh",
   ")",
   "(",
   "X",
   ",",
   "eigvals",
   "=",
   "(",
   "0",
   ",",
   "0",
   ")",
   ")",
   "self",
   ".",
   "shift_",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "min_eig",
   "-",
   "lo",
   ",",
   "0",
   ")",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-293",
  "nl_tokens": [
   "Convert",
   "heatmaps",
   "to",
   "segmentation",
   "map",
   "."
  ],
  "pl_tokens": [
   "def",
   "from_heatmaps",
   "(",
   "heatmaps",
   ",",
   "class_indices",
   "=",
   "None",
   ",",
   "nb_classes",
   "=",
   "None",
   ")",
   ":",
   "if",
   "class_indices",
   "is",
   "None",
   ":",
   "return",
   "SegmentationMapOnImage",
   "(",
   "heatmaps",
   ".",
   "arr_0to1",
   ",",
   "shape",
   "=",
   "heatmaps",
   ".",
   "shape",
   ")",
   "else",
   ":",
   "ia",
   ".",
   "do_assert",
   "(",
   "nb_classes",
   "is",
   "not",
   "None",
   ")",
   "ia",
   ".",
   "do_assert",
   "(",
   "<mask>",
   "(",
   "class_indices",
   ")",
   ">=",
   "0",
   ")",
   "ia",
   ".",
   "do_assert",
   "(",
   "max",
   "(",
   "class_indices",
   ")",
   "<",
   "nb_classes",
   ")",
   "ia",
   ".",
   "do_assert",
   "(",
   "len",
   "(",
   "class_indices",
   ")",
   "==",
   "heatmaps",
   ".",
   "arr_0to1",
   ".",
   "shape",
   "[",
   "2",
   "]",
   ")",
   "arr_0to1",
   "=",
   "heatmaps",
   ".",
   "arr_0to1",
   "arr_0to1_full",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "arr_0to1",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "arr_0to1",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "nb_classes",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float32",
   ")",
   "for",
   "heatmap_channel",
   ",",
   "mapped_channel",
   "in",
   "enumerate",
   "(",
   "class_indices",
   ")",
   ":",
   "arr_0to1_full",
   "[",
   ":",
   ",",
   ":",
   ",",
   "mapped_channel",
   "]",
   "=",
   "arr_0to1",
   "[",
   ":",
   ",",
   ":",
   ",",
   "heatmap_channel",
   "]",
   "return",
   "SegmentationMapOnImage",
   "(",
   "arr_0to1_full",
   ",",
   "shape",
   "=",
   "heatmaps",
   ".",
   "shape",
   ")"
  ]
 },
 {
  "idx": "maxmin-294",
  "nl_tokens": [
   "Compute",
   "the",
   "neighbors",
   "of",
   "every",
   "pixel",
   "as",
   "a",
   "list",
   "of",
   "the",
   "pixel",
   "index",
   "s",
   "each",
   "pixel",
   "shares",
   "a",
   "vertex",
   "with",
   "."
  ],
  "pl_tokens": [
   "def",
   "voronoi_neighbors_from_pixels_and_ridge_points",
   "(",
   "pixels",
   ",",
   "ridge_points",
   ")",
   ":",
   "pixel_neighbors_size",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "shape",
   "=",
   "(",
   "pixels",
   ")",
   ")",
   "for",
   "ridge_index",
   "in",
   "range",
   "(",
   "ridge_points",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "pair0",
   "=",
   "ridge_points",
   "[",
   "ridge_index",
   ",",
   "0",
   "]",
   "pair1",
   "=",
   "ridge_points",
   "[",
   "ridge_index",
   ",",
   "1",
   "]",
   "pixel_neighbors_size",
   "[",
   "pair0",
   "]",
   "+=",
   "1",
   "pixel_neighbors_size",
   "[",
   "pair1",
   "]",
   "+=",
   "1",
   "pixel_neighbors_index",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "shape",
   "=",
   "(",
   "pixels",
   ")",
   ")",
   "pixel_neighbors",
   "=",
   "-",
   "1",
   "*",
   "np",
   ".",
   "ones",
   "(",
   "shape",
   "=",
   "(",
   "pixels",
   ",",
   "int",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "pixel_neighbors_size",
   ")",
   ")",
   ")",
   ")",
   "for",
   "ridge_index",
   "in",
   "range",
   "(",
   "ridge_points",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "pair0",
   "=",
   "ridge_points",
   "[",
   "ridge_index",
   ",",
   "0",
   "]",
   "pair1",
   "=",
   "ridge_points",
   "[",
   "ridge_index",
   ",",
   "1",
   "]",
   "pixel_neighbors",
   "[",
   "pair0",
   ",",
   "int",
   "(",
   "pixel_neighbors_index",
   "[",
   "pair0",
   "]",
   ")",
   "]",
   "=",
   "pair1",
   "pixel_neighbors",
   "[",
   "pair1",
   ",",
   "int",
   "(",
   "pixel_neighbors_index",
   "[",
   "pair1",
   "]",
   ")",
   "]",
   "=",
   "pair0",
   "pixel_neighbors_index",
   "[",
   "pair0",
   "]",
   "+=",
   "1",
   "pixel_neighbors_index",
   "[",
   "pair1",
   "]",
   "+=",
   "1",
   "return",
   "pixel_neighbors",
   ",",
   "pixel_neighbors_size"
  ]
 },
 {
  "idx": "maxmin-295",
  "nl_tokens": [
   "Create",
   "a",
   ":",
   "class",
   ":",
   "~bokeh",
   ".",
   "plotting",
   ".",
   "figure",
   ".",
   "Figure",
   "to",
   "create",
   "an",
   "H",
   "-",
   "R",
   "diagram",
   "using",
   "the",
   "cluster_name",
   ";",
   "then",
   "show",
   "it",
   "."
  ],
  "pl_tokens": [
   "def",
   "cc_diagram",
   "(",
   "cluster_name",
   ")",
   ":",
   "x",
   ",",
   "y",
   "=",
   "get_hr_data",
   "(",
   "cluster_name",
   ")",
   "y_range",
   "=",
   "[",
   "<mask>",
   "(",
   "y",
   ")",
   "+",
   "0.5",
   ",",
   "min",
   "(",
   "y",
   ")",
   "-",
   "0.25",
   "]",
   "pf",
   "=",
   "figure",
   "(",
   "y_range",
   "=",
   "y_range",
   ",",
   "title",
   "=",
   "cluster_name",
   ")",
   "_diagram",
   "(",
   "x",
   ",",
   "y",
   ",",
   "pf",
   ")",
   "show_with_bokeh_server",
   "(",
   "pf",
   ")"
  ]
 },
 {
  "idx": "maxmin-296",
  "nl_tokens": [
   "Swirl",
   "an",
   "image",
   "randomly",
   "or",
   "non",
   "-",
   "randomly",
   "see",
   "scikit",
   "-",
   "image",
   "swirl",
   "API",
   "<http",
   ":",
   "//",
   "scikit",
   "-",
   "image",
   ".",
   "org",
   "/",
   "docs",
   "/",
   "dev",
   "/",
   "api",
   "/",
   "skimage",
   ".",
   "transform",
   ".",
   "html#skimage",
   ".",
   "transform",
   ".",
   "swirl",
   ">",
   "__",
   "and",
   "example",
   "<http",
   ":",
   "//",
   "scikit",
   "-",
   "image",
   ".",
   "org",
   "/",
   "docs",
   "/",
   "dev",
   "/",
   "auto_examples",
   "/",
   "plot_swirl",
   ".",
   "html",
   ">",
   "__",
   "."
  ],
  "pl_tokens": [
   "def",
   "swirl",
   "(",
   "x",
   ",",
   "center",
   "=",
   "None",
   ",",
   "strength",
   "=",
   "1",
   ",",
   "radius",
   "=",
   "100",
   ",",
   "rotation",
   "=",
   "0",
   ",",
   "output_shape",
   "=",
   "None",
   ",",
   "order",
   "=",
   "1",
   ",",
   "mode",
   "=",
   "'constant'",
   ",",
   "cval",
   "=",
   "0",
   ",",
   "clip",
   "=",
   "True",
   ",",
   "preserve_range",
   "=",
   "False",
   ",",
   "is_random",
   "=",
   "False",
   ")",
   ":",
   "if",
   "radius",
   "==",
   "0",
   ":",
   "raise",
   "AssertionError",
   "(",
   "\"Invalid radius value\"",
   ")",
   "rotation",
   "=",
   "np",
   ".",
   "pi",
   "/",
   "180",
   "*",
   "rotation",
   "if",
   "is_random",
   ":",
   "center_h",
   "=",
   "int",
   "(",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "0",
   ",",
   "x",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "center_w",
   "=",
   "int",
   "(",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "0",
   ",",
   "x",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   "center",
   "=",
   "(",
   "center_h",
   ",",
   "center_w",
   ")",
   "strength",
   "=",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "0",
   ",",
   "strength",
   ")",
   "radius",
   "=",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "1e-10",
   ",",
   "radius",
   ")",
   "rotation",
   "=",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "-",
   "rotation",
   ",",
   "rotation",
   ")",
   "max_v",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   "if",
   "max_v",
   ">",
   "1",
   ":",
   "# Note: the input of this fn should be [-1, 1], rescale is required.",
   "x",
   "=",
   "x",
   "/",
   "max_v",
   "swirled",
   "=",
   "skimage",
   ".",
   "transform",
   ".",
   "swirl",
   "(",
   "x",
   ",",
   "center",
   "=",
   "center",
   ",",
   "strength",
   "=",
   "strength",
   ",",
   "radius",
   "=",
   "radius",
   ",",
   "rotation",
   "=",
   "rotation",
   ",",
   "output_shape",
   "=",
   "output_shape",
   ",",
   "order",
   "=",
   "order",
   ",",
   "mode",
   "=",
   "mode",
   ",",
   "cval",
   "=",
   "cval",
   ",",
   "clip",
   "=",
   "clip",
   ",",
   "preserve_range",
   "=",
   "preserve_range",
   ")",
   "if",
   "max_v",
   ">",
   "1",
   ":",
   "swirled",
   "=",
   "swirled",
   "*",
   "max_v",
   "return",
   "swirled"
  ]
 },
 {
  "idx": "maxmin-297",
  "nl_tokens": [
   "Compute",
   "the",
   "yticks",
   "labels",
   "of",
   "this",
   "grid",
   "used",
   "for",
   "plotting",
   "the",
   "y",
   "-",
   "axis",
   "ticks",
   "when",
   "visualizing",
   "a",
   "regular"
  ],
  "pl_tokens": [
   "def",
   "yticks",
   "(",
   "self",
   ")",
   ":",
   "return",
   "np",
   ".",
   "linspace",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "self",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   ",",
   "4",
   ")"
  ]
 },
 {
  "idx": "maxmin-298",
  "nl_tokens": [
   "return",
   "the",
   "classified",
   "labeling",
   "of",
   "record"
  ],
  "pl_tokens": [
   "def",
   "_recomputeRecordFromKNN",
   "(",
   "self",
   ",",
   "record",
   ")",
   ":",
   "inputs",
   "=",
   "{",
   "\"categoryIn\"",
   ":",
   "[",
   "None",
   "]",
   ",",
   "\"bottomUpIn\"",
   ":",
   "self",
   ".",
   "_getStateAnomalyVector",
   "(",
   "record",
   ")",
   ",",
   "}",
   "outputs",
   "=",
   "{",
   "\"categoriesOut\"",
   ":",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   ")",
   ")",
   ",",
   "\"bestPrototypeIndices\"",
   ":",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   ")",
   ")",
   ",",
   "\"categoryProbabilitiesOut\"",
   ":",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   ")",
   ")",
   "}",
   "# Run inference only to capture state before learning",
   "classifier",
   "=",
   "self",
   ".",
   "htm_prediction_model",
   ".",
   "_getAnomalyClassifier",
   "(",
   ")",
   "knn",
   "=",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "_knn",
   "# Only use points before record to classify and after the wait period.",
   "classifier_indexes",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "getParameter",
   "(",
   "'categoryRecencyList'",
   ")",
   ")",
   "valid_idx",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "(",
   "classifier_indexes",
   ">=",
   "self",
   ".",
   "_autoDetectWaitRecords",
   ")",
   "&",
   "(",
   "classifier_indexes",
   "<",
   "record",
   ".",
   "ROWID",
   ")",
   ")",
   "[",
   "0",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "if",
   "len",
   "(",
   "valid_idx",
   ")",
   "==",
   "0",
   ":",
   "return",
   "None",
   "classifier",
   ".",
   "setParameter",
   "(",
   "'inferenceMode'",
   ",",
   "True",
   ")",
   "classifier",
   ".",
   "setParameter",
   "(",
   "'learningMode'",
   ",",
   "False",
   ")",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "compute",
   "(",
   "inputs",
   ",",
   "outputs",
   ")",
   "classifier",
   ".",
   "setParameter",
   "(",
   "'learningMode'",
   ",",
   "True",
   ")",
   "classifier_distances",
   "=",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "getLatestDistances",
   "(",
   ")",
   "valid_distances",
   "=",
   "classifier_distances",
   "[",
   "valid_idx",
   "]",
   "if",
   "valid_distances",
   ".",
   "<mask>",
   "(",
   ")",
   "<=",
   "self",
   ".",
   "_classificationMaxDist",
   ":",
   "classifier_indexes_prev",
   "=",
   "classifier_indexes",
   "[",
   "valid_idx",
   "]",
   "rowID",
   "=",
   "classifier_indexes_prev",
   "[",
   "valid_distances",
   ".",
   "argmin",
   "(",
   ")",
   "]",
   "indexID",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "classifier_indexes",
   "==",
   "rowID",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "category",
   "=",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "getCategoryList",
   "(",
   ")",
   "[",
   "indexID",
   "]",
   "return",
   "category",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-299",
  "nl_tokens": [
   "Do",
   "the",
   "expiration",
   "of",
   "dictionary",
   "items",
   "."
  ],
  "pl_tokens": [
   "def",
   "expire",
   "(",
   "self",
   ")",
   ":",
   "with",
   "self",
   ".",
   "_lock",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"expdict.expire. timeouts: {0!r}\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "_timeouts",
   ")",
   ")",
   "next_timeout",
   "=",
   "None",
   "for",
   "k",
   "in",
   "self",
   ".",
   "_timeouts",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "ret",
   "=",
   "self",
   ".",
   "_expire_item",
   "(",
   "k",
   ")",
   "if",
   "ret",
   "is",
   "not",
   "None",
   ":",
   "if",
   "next_timeout",
   "is",
   "None",
   ":",
   "next_timeout",
   "=",
   "ret",
   "else",
   ":",
   "next_timeout",
   "=",
   "<mask>",
   "(",
   "next_timeout",
   ",",
   "ret",
   ")",
   "return",
   "next_timeout"
  ]
 },
 {
  "idx": "maxmin-300",
  "nl_tokens": [
   "Return",
   "nearest",
   "parent",
   "permission",
   "for",
   "path",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_permissions",
   "(",
   "self",
   ",",
   "path",
   ")",
   ":",
   "path",
   "=",
   "pathlib",
   ".",
   "PurePosixPath",
   "(",
   "path",
   ")",
   "parents",
   "=",
   "filter",
   "(",
   "lambda",
   "p",
   ":",
   "p",
   ".",
   "is_parent",
   "(",
   "path",
   ")",
   ",",
   "self",
   ".",
   "permissions",
   ")",
   "perm",
   "=",
   "<mask>",
   "(",
   "parents",
   ",",
   "key",
   "=",
   "lambda",
   "p",
   ":",
   "len",
   "(",
   "path",
   ".",
   "relative_to",
   "(",
   "p",
   ".",
   "path",
   ")",
   ".",
   "parts",
   ")",
   ",",
   "default",
   "=",
   "Permission",
   "(",
   ")",
   ",",
   ")",
   "return",
   "perm"
  ]
 },
 {
  "idx": "maxmin-301",
  "nl_tokens": [
   "Builds",
   "a",
   "paired",
   "cluster",
   "from",
   "the",
   "refmapped",
   "data",
   "."
  ],
  "pl_tokens": [
   "def",
   "fetch_cluster_pairs",
   "(",
   "data",
   ",",
   "samfile",
   ",",
   "chrom",
   ",",
   "rstart",
   ",",
   "rend",
   ")",
   ":",
   "## store pairs",
   "rdict",
   "=",
   "{",
   "}",
   "clust",
   "=",
   "[",
   "]",
   "## grab the region and make tuples of info",
   "iterreg",
   "=",
   "samfile",
   ".",
   "fetch",
   "(",
   "chrom",
   ",",
   "rstart",
   ",",
   "rend",
   ")",
   "## use dict to match up read pairs",
   "for",
   "read",
   "in",
   "iterreg",
   ":",
   "if",
   "read",
   ".",
   "qname",
   "not",
   "in",
   "rdict",
   ":",
   "rdict",
   "[",
   "read",
   ".",
   "qname",
   "]",
   "=",
   "[",
   "read",
   "]",
   "else",
   ":",
   "rdict",
   "[",
   "read",
   ".",
   "qname",
   "]",
   ".",
   "append",
   "(",
   "read",
   ")",
   "## sort dict keys so highest derep is first ('seed')",
   "sfunc",
   "=",
   "lambda",
   "x",
   ":",
   "int",
   "(",
   "x",
   ".",
   "split",
   "(",
   "\";size=\"",
   ")",
   "[",
   "1",
   "]",
   ".",
   "split",
   "(",
   "\";\"",
   ")",
   "[",
   "0",
   "]",
   ")",
   "rkeys",
   "=",
   "sorted",
   "(",
   "rdict",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "key",
   "=",
   "sfunc",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "## get blocks from the seed for filtering, bail out if seed is not paired",
   "try",
   ":",
   "read1",
   ",",
   "read2",
   "=",
   "rdict",
   "[",
   "rkeys",
   "[",
   "0",
   "]",
   "]",
   "except",
   "ValueError",
   ":",
   "return",
   "0",
   "## the starting blocks for the seed",
   "poss",
   "=",
   "read1",
   ".",
   "get_reference_positions",
   "(",
   ")",
   "+",
   "read2",
   ".",
   "get_reference_positions",
   "(",
   ")",
   "seed_r1start",
   "=",
   "<mask>",
   "(",
   "poss",
   ")",
   "seed_r2end",
   "=",
   "max",
   "(",
   "poss",
   ")",
   "## store the seed -------------------------------------------",
   "## Simplify. R1 and R2 are always on opposite strands, but the",
   "## orientation is variable. We revcomp and order the reads to",
   "## preserve genomic order.",
   "reads_overlap",
   "=",
   "False",
   "if",
   "read1",
   ".",
   "is_reverse",
   ":",
   "if",
   "read2",
   ".",
   "aend",
   ">",
   "read1",
   ".",
   "get_blocks",
   "(",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ":",
   "reads_overlap",
   "=",
   "True",
   "seq",
   "=",
   "read2",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "revcomp",
   "(",
   "read1",
   ".",
   "seq",
   ")",
   "else",
   ":",
   "seq",
   "=",
   "read2",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "read1",
   ".",
   "seq",
   "else",
   ":",
   "if",
   "read1",
   ".",
   "aend",
   ">",
   "read2",
   ".",
   "get_blocks",
   "(",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ":",
   "reads_overlap",
   "=",
   "True",
   "seq",
   "=",
   "read1",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "revcomp",
   "(",
   "read2",
   ".",
   "seq",
   ")",
   "else",
   ":",
   "seq",
   "=",
   "read1",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "read2",
   ".",
   "seq",
   "## store, could write orient but just + for now.",
   "size",
   "=",
   "sfunc",
   "(",
   "rkeys",
   "[",
   "0",
   "]",
   ")",
   "clust",
   ".",
   "append",
   "(",
   "\">{}:{}:{};size={};*\\n{}\"",
   ".",
   "format",
   "(",
   "chrom",
   ",",
   "seed_r1start",
   ",",
   "seed_r2end",
   ",",
   "size",
   ",",
   "seq",
   ")",
   ")",
   "## If there's only one hit in this region then rkeys will only have",
   "## one element and the call to `rkeys[1:]` will raise. Test for this.",
   "if",
   "len",
   "(",
   "rkeys",
   ")",
   ">",
   "1",
   ":",
   "## store the hits to the seed -------------------------------",
   "for",
   "key",
   "in",
   "rkeys",
   "[",
   "1",
   ":",
   "]",
   ":",
   "skip",
   "=",
   "False",
   "try",
   ":",
   "read1",
   ",",
   "read2",
   "=",
   "rdict",
   "[",
   "key",
   "]",
   "except",
   "ValueError",
   ":",
   "## enter values that will make this read get skipped",
   "read1",
   "=",
   "rdict",
   "[",
   "key",
   "]",
   "[",
   "0",
   "]",
   "read2",
   "=",
   "read1",
   "skip",
   "=",
   "True",
   "## orient reads and filter out ones that will not align well b/c",
   "## they do not overlap enough with the seed",
   "poss",
   "=",
   "read1",
   ".",
   "get_reference_positions",
   "(",
   ")",
   "+",
   "read2",
   ".",
   "get_reference_positions",
   "(",
   ")",
   "minpos",
   "=",
   "min",
   "(",
   "poss",
   ")",
   "maxpos",
   "=",
   "max",
   "(",
   "poss",
   ")",
   "## skip if more than one hit location",
   "if",
   "read1",
   ".",
   "has_tag",
   "(",
   "\"SA\"",
   ")",
   "or",
   "read2",
   ".",
   "has_tag",
   "(",
   "\"SA\"",
   ")",
   ":",
   "skip",
   "=",
   "True",
   "## store if read passes ",
   "if",
   "(",
   "abs",
   "(",
   "minpos",
   "-",
   "seed_r1start",
   ")",
   "<",
   "50",
   ")",
   "and",
   "(",
   "abs",
   "(",
   "maxpos",
   "-",
   "seed_r2end",
   ")",
   "<",
   "50",
   ")",
   "and",
   "(",
   "not",
   "skip",
   ")",
   ":",
   "## store the seq",
   "if",
   "read1",
   ".",
   "is_reverse",
   ":",
   "## do reads overlap",
   "if",
   "read2",
   ".",
   "aend",
   ">",
   "read1",
   ".",
   "get_blocks",
   "(",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ":",
   "reads_overlap",
   "=",
   "True",
   "seq",
   "=",
   "read2",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "revcomp",
   "(",
   "read1",
   ".",
   "seq",
   ")",
   "else",
   ":",
   "seq",
   "=",
   "read2",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "read1",
   ".",
   "seq",
   "else",
   ":",
   "if",
   "read1",
   ".",
   "aend",
   ">",
   "read2",
   ".",
   "get_blocks",
   "(",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ":",
   "reads_overlap",
   "=",
   "True",
   "seq",
   "=",
   "read1",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "revcomp",
   "(",
   "read2",
   ".",
   "seq",
   ")",
   "else",
   ":",
   "seq",
   "=",
   "read1",
   ".",
   "seq",
   "+",
   "\"nnnn\"",
   "+",
   "read2",
   ".",
   "seq",
   "## store, could write orient but just + for now.",
   "size",
   "=",
   "sfunc",
   "(",
   "key",
   ")",
   "clust",
   ".",
   "append",
   "(",
   "\">{}:{}:{};size={};+\\n{}\"",
   ".",
   "format",
   "(",
   "chrom",
   ",",
   "minpos",
   ",",
   "maxpos",
   ",",
   "size",
   ",",
   "seq",
   ")",
   ")",
   "else",
   ":",
   "## seq is excluded, though, we could save it and return",
   "## it as a separate cluster that will be aligned separately.",
   "pass",
   "## merge the pairs prior to returning them",
   "## Remember, we already tested for quality scores, so",
   "## merge_after_pysam will generate arbitrarily high scores",
   "## It would be nice to do something here like test if",
   "## the average insert length + 2 stdv is > 2*read len",
   "## so you can switch off merging for mostly non-overlapping data",
   "if",
   "reads_overlap",
   ":",
   "if",
   "data",
   ".",
   "_hackersonly",
   "[",
   "\"refmap_merge_PE\"",
   "]",
   ":",
   "clust",
   "=",
   "merge_after_pysam",
   "(",
   "data",
   ",",
   "clust",
   ")",
   "#clust = merge_pair_pipes(data, clust)",
   "return",
   "clust"
  ]
 },
 {
  "idx": "maxmin-302",
  "nl_tokens": [
   "strcmp",
   "symbolic",
   "model",
   "."
  ],
  "pl_tokens": [
   "def",
   "strcmp",
   "(",
   "state",
   ",",
   "s1",
   ",",
   "s2",
   ")",
   ":",
   "cpu",
   "=",
   "state",
   ".",
   "cpu",
   "if",
   "issymbolic",
   "(",
   "s1",
   ")",
   ":",
   "raise",
   "ConcretizeArgument",
   "(",
   "state",
   ".",
   "cpu",
   ",",
   "1",
   ")",
   "if",
   "issymbolic",
   "(",
   "s2",
   ")",
   ":",
   "raise",
   "ConcretizeArgument",
   "(",
   "state",
   ".",
   "cpu",
   ",",
   "2",
   ")",
   "s1_zero_idx",
   "=",
   "_find_zero",
   "(",
   "cpu",
   ",",
   "state",
   ".",
   "constraints",
   ",",
   "s1",
   ")",
   "s2_zero_idx",
   "=",
   "_find_zero",
   "(",
   "cpu",
   ",",
   "state",
   ".",
   "constraints",
   ",",
   "s2",
   ")",
   "min_zero_idx",
   "=",
   "<mask>",
   "(",
   "s1_zero_idx",
   ",",
   "s2_zero_idx",
   ")",
   "ret",
   "=",
   "None",
   "for",
   "offset",
   "in",
   "range",
   "(",
   "min_zero_idx",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   ":",
   "s1char",
   "=",
   "ZEXTEND",
   "(",
   "cpu",
   ".",
   "read_int",
   "(",
   "s1",
   "+",
   "offset",
   ",",
   "8",
   ")",
   ",",
   "cpu",
   ".",
   "address_bit_size",
   ")",
   "s2char",
   "=",
   "ZEXTEND",
   "(",
   "cpu",
   ".",
   "read_int",
   "(",
   "s2",
   "+",
   "offset",
   ",",
   "8",
   ")",
   ",",
   "cpu",
   ".",
   "address_bit_size",
   ")",
   "if",
   "issymbolic",
   "(",
   "s1char",
   ")",
   "or",
   "issymbolic",
   "(",
   "s2char",
   ")",
   ":",
   "if",
   "ret",
   "is",
   "None",
   "or",
   "(",
   "not",
   "issymbolic",
   "(",
   "ret",
   ")",
   "and",
   "ret",
   "==",
   "0",
   ")",
   ":",
   "ret",
   "=",
   "s1char",
   "-",
   "s2char",
   "else",
   ":",
   "ret",
   "=",
   "ITEBV",
   "(",
   "cpu",
   ".",
   "address_bit_size",
   ",",
   "s1char",
   "!=",
   "s2char",
   ",",
   "s1char",
   "-",
   "s2char",
   ",",
   "ret",
   ")",
   "else",
   ":",
   "if",
   "s1char",
   "!=",
   "s2char",
   ":",
   "ret",
   "=",
   "s1char",
   "-",
   "s2char",
   "elif",
   "ret",
   "is",
   "None",
   ":",
   "ret",
   "=",
   "0",
   "return",
   "ret"
  ]
 },
 {
  "idx": "maxmin-303",
  "nl_tokens": [
   "Converts",
   "a",
   "numpy",
   "array",
   "to",
   "PIL",
   "image",
   "object",
   "(",
   "uint8",
   "format",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "array_to_img",
   "(",
   "x",
   ",",
   "dim_ordering",
   "=",
   "(",
   "0",
   ",",
   "1",
   ",",
   "2",
   ")",
   ",",
   "scale",
   "=",
   "True",
   ")",
   ":",
   "# if dim_ordering == 'default':",
   "#     dim_ordering = K.image_dim_ordering()",
   "# if dim_ordering == 'th':  # theano",
   "#     x = x.transpose(1, 2, 0)",
   "x",
   "=",
   "x",
   ".",
   "transpose",
   "(",
   "dim_ordering",
   ")",
   "if",
   "scale",
   ":",
   "x",
   "+=",
   "<mask>",
   "(",
   "-",
   "np",
   ".",
   "min",
   "(",
   "x",
   ")",
   ",",
   "0",
   ")",
   "x_max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "if",
   "x_max",
   "!=",
   "0",
   ":",
   "# tl.logging.info(x_max)",
   "# x /= x_max",
   "x",
   "=",
   "x",
   "/",
   "x_max",
   "x",
   "*=",
   "255",
   "if",
   "x",
   ".",
   "shape",
   "[",
   "2",
   "]",
   "==",
   "3",
   ":",
   "# RGB",
   "return",
   "PIL",
   ".",
   "Image",
   ".",
   "fromarray",
   "(",
   "x",
   ".",
   "astype",
   "(",
   "'uint8'",
   ")",
   ",",
   "'RGB'",
   ")",
   "elif",
   "x",
   ".",
   "shape",
   "[",
   "2",
   "]",
   "==",
   "1",
   ":",
   "# grayscale",
   "return",
   "PIL",
   ".",
   "Image",
   ".",
   "fromarray",
   "(",
   "x",
   "[",
   ":",
   ",",
   ":",
   ",",
   "0",
   "]",
   ".",
   "astype",
   "(",
   "'uint8'",
   ")",
   ",",
   "'L'",
   ")",
   "else",
   ":",
   "raise",
   "Exception",
   "(",
   "'Unsupported channel number: '",
   ",",
   "x",
   ".",
   "shape",
   "[",
   "2",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-304",
  "nl_tokens": [
   "Find",
   "an",
   "approximately",
   "random",
   "point",
   "in",
   "the",
   "flux",
   "cone",
   "."
  ],
  "pl_tokens": [
   "def",
   "_random_point",
   "(",
   "self",
   ")",
   ":",
   "idx",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "self",
   ".",
   "n_warmup",
   ",",
   "size",
   "=",
   "<mask>",
   "(",
   "2",
   ",",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "self",
   ".",
   "n_warmup",
   ")",
   ")",
   ")",
   ")",
   "return",
   "self",
   ".",
   "warmup",
   "[",
   "idx",
   ",",
   ":",
   "]",
   ".",
   "mean",
   "(",
   "axis",
   "=",
   "0",
   ")"
  ]
 },
 {
  "idx": "maxmin-305",
  "nl_tokens": [
   "Returns",
   "a",
   "Fastq",
   "object",
   ".",
   "qual_scores",
   "expected",
   "to",
   "be",
   "a",
   "list",
   "of",
   "numbers",
   "like",
   "you",
   "would",
   "get",
   "in",
   "a",
   ".",
   "qual",
   "file"
  ],
  "pl_tokens": [
   "def",
   "to_Fastq",
   "(",
   "self",
   ",",
   "qual_scores",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ")",
   "!=",
   "len",
   "(",
   "qual_scores",
   ")",
   ":",
   "raise",
   "Error",
   "(",
   "'Error making Fastq from Fasta, lengths differ.'",
   ",",
   "self",
   ".",
   "id",
   ")",
   "return",
   "Fastq",
   "(",
   "self",
   ".",
   "id",
   ",",
   "self",
   ".",
   "seq",
   ",",
   "''",
   ".",
   "join",
   "(",
   "[",
   "chr",
   "(",
   "<mask>",
   "(",
   "0",
   ",",
   "min",
   "(",
   "x",
   ",",
   "93",
   ")",
   ")",
   "+",
   "33",
   ")",
   "for",
   "x",
   "in",
   "qual_scores",
   "]",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-306",
  "nl_tokens": [
   "Prediction",
   "polynomial",
   "to",
   "line",
   "spectral",
   "frequencies",
   "."
  ],
  "pl_tokens": [
   "def",
   "poly2lsf",
   "(",
   "a",
   ")",
   ":",
   "#Line spectral frequencies are not defined for complex polynomials.",
   "# Normalize the polynomial",
   "a",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "a",
   ")",
   "if",
   "a",
   "[",
   "0",
   "]",
   "!=",
   "1",
   ":",
   "a",
   "/=",
   "a",
   "[",
   "0",
   "]",
   "if",
   "<mask>",
   "(",
   "numpy",
   ".",
   "abs",
   "(",
   "numpy",
   ".",
   "roots",
   "(",
   "a",
   ")",
   ")",
   ")",
   ">=",
   "1.0",
   ":",
   "error",
   "(",
   "'The polynomial must have all roots inside of the unit circle.'",
   ")",
   "# Form the sum and differnce filters",
   "p",
   "=",
   "len",
   "(",
   "a",
   ")",
   "-",
   "1",
   "# The leading one in the polynomial is not used",
   "a1",
   "=",
   "numpy",
   ".",
   "concatenate",
   "(",
   "(",
   "a",
   ",",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "0",
   "]",
   ")",
   ")",
   ")",
   "a2",
   "=",
   "a1",
   "[",
   "-",
   "1",
   ":",
   ":",
   "-",
   "1",
   "]",
   "P1",
   "=",
   "a1",
   "-",
   "a2",
   "# Difference filter",
   "Q1",
   "=",
   "a1",
   "+",
   "a2",
   "# Sum Filter",
   "# If order is even, remove the known root at z = 1 for P1 and z = -1 for Q1",
   "# If odd, remove both the roots from P1",
   "if",
   "p",
   "%",
   "2",
   ":",
   "# Odd order",
   "P",
   ",",
   "r",
   "=",
   "deconvolve",
   "(",
   "P1",
   ",",
   "[",
   "1",
   ",",
   "0",
   ",",
   "-",
   "1",
   "]",
   ")",
   "Q",
   "=",
   "Q1",
   "else",
   ":",
   "# Even order",
   "P",
   ",",
   "r",
   "=",
   "deconvolve",
   "(",
   "P1",
   ",",
   "[",
   "1",
   ",",
   "-",
   "1",
   "]",
   ")",
   "Q",
   ",",
   "r",
   "=",
   "deconvolve",
   "(",
   "Q1",
   ",",
   "[",
   "1",
   ",",
   "1",
   "]",
   ")",
   "rP",
   "=",
   "numpy",
   ".",
   "roots",
   "(",
   "P",
   ")",
   "rQ",
   "=",
   "numpy",
   ".",
   "roots",
   "(",
   "Q",
   ")",
   "aP",
   "=",
   "numpy",
   ".",
   "angle",
   "(",
   "rP",
   "[",
   "1",
   ":",
   ":",
   "2",
   "]",
   ")",
   "aQ",
   "=",
   "numpy",
   ".",
   "angle",
   "(",
   "rQ",
   "[",
   "1",
   ":",
   ":",
   "2",
   "]",
   ")",
   "lsf",
   "=",
   "sorted",
   "(",
   "numpy",
   ".",
   "concatenate",
   "(",
   "(",
   "-",
   "aP",
   ",",
   "-",
   "aQ",
   ")",
   ")",
   ")",
   "return",
   "lsf"
  ]
 },
 {
  "idx": "maxmin-307",
  "nl_tokens": [
   "Copy",
   "stream",
   "to",
   "buffer"
  ],
  "pl_tokens": [
   "def",
   "memcopy",
   "(",
   "self",
   ",",
   "stream",
   ",",
   "offset",
   "=",
   "0",
   ",",
   "length",
   "=",
   "float",
   "(",
   "\"inf\"",
   ")",
   ")",
   ":",
   "data",
   "=",
   "[",
   "ord",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "list",
   "(",
   "stream",
   ")",
   "]",
   "size",
   "=",
   "<mask>",
   "(",
   "length",
   ",",
   "len",
   "(",
   "data",
   ")",
   ",",
   "self",
   ".",
   "m_size",
   ")",
   "buff",
   "=",
   "cast",
   "(",
   "self",
   ".",
   "m_buf",
   ",",
   "POINTER",
   "(",
   "c_uint8",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "size",
   ")",
   ":",
   "buff",
   "[",
   "offset",
   "+",
   "i",
   "]",
   "=",
   "data",
   "[",
   "i",
   "]"
  ]
 },
 {
  "idx": "maxmin-308",
  "nl_tokens": [
   "Return",
   "course",
   "run",
   "with",
   "start",
   "date",
   "closest",
   "to",
   "now",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_closest_course_run",
   "(",
   "course_runs",
   ")",
   ":",
   "if",
   "len",
   "(",
   "course_runs",
   ")",
   "==",
   "1",
   ":",
   "return",
   "course_runs",
   "[",
   "0",
   "]",
   "now",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "now",
   "(",
   "pytz",
   ".",
   "UTC",
   ")",
   "# course runs with no start date should be considered last.",
   "never",
   "=",
   "now",
   "-",
   "datetime",
   ".",
   "timedelta",
   "(",
   "days",
   "=",
   "3650",
   ")",
   "return",
   "<mask>",
   "(",
   "course_runs",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "abs",
   "(",
   "get_course_run_start",
   "(",
   "x",
   ",",
   "never",
   ")",
   "-",
   "now",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-309",
  "nl_tokens": [
   "a",
   "simple",
   "plotting",
   "routine",
   "to",
   "plot",
   "the",
   "PSD",
   "versus",
   "frequency",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot",
   "(",
   "self",
   ",",
   "filename",
   "=",
   "None",
   ",",
   "norm",
   "=",
   "False",
   ",",
   "ylim",
   "=",
   "None",
   ",",
   "sides",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kargs",
   ")",
   ":",
   "import",
   "pylab",
   "from",
   "pylab",
   "import",
   "ylim",
   "as",
   "plt_ylim",
   "#First, check that psd attribute is up-to-date",
   "# just to get the PSD to be recomputed if needed",
   "_",
   "=",
   "self",
   ".",
   "psd",
   "# check that the input sides parameter is correct if provided",
   "if",
   "sides",
   "is",
   "not",
   "None",
   ":",
   "if",
   "sides",
   "not",
   "in",
   "self",
   ".",
   "_sides_choices",
   ":",
   "raise",
   "errors",
   ".",
   "SpectrumChoiceError",
   "(",
   "sides",
   ",",
   "self",
   ".",
   "_sides_choices",
   ")",
   "# if sides is provided but identical to the current psd, nothing to do.",
   "# if sides not provided, let us use self.sides",
   "if",
   "sides",
   "is",
   "None",
   "or",
   "sides",
   "==",
   "self",
   ".",
   "sides",
   ":",
   "frequencies",
   "=",
   "self",
   ".",
   "frequencies",
   "(",
   ")",
   "psd",
   "=",
   "self",
   ".",
   "psd",
   "sides",
   "=",
   "self",
   ".",
   "sides",
   "elif",
   "sides",
   "is",
   "not",
   "None",
   ":",
   "# if sides argument is different from the attribute, we need to",
   "# create a new PSD/Freq ; indeed we do not want to change the",
   "# attribute itself",
   "# if data is complex, one-sided is wrong in any case.",
   "if",
   "self",
   ".",
   "datatype",
   "==",
   "'complex'",
   ":",
   "if",
   "sides",
   "==",
   "'onesided'",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"sides cannot be one-sided with complex data\"",
   ")",
   "logging",
   ".",
   "debug",
   "(",
   "\"sides is different from the one provided. Converting PSD\"",
   ")",
   "frequencies",
   "=",
   "self",
   ".",
   "frequencies",
   "(",
   "sides",
   "=",
   "sides",
   ")",
   "psd",
   "=",
   "self",
   ".",
   "get_converted_psd",
   "(",
   "sides",
   ")",
   "if",
   "len",
   "(",
   "psd",
   ")",
   "!=",
   "len",
   "(",
   "frequencies",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"PSD length is %s and freq length is %s\"",
   "%",
   "(",
   "len",
   "(",
   "psd",
   ")",
   ",",
   "len",
   "(",
   "frequencies",
   ")",
   ")",
   ")",
   "if",
   "'ax'",
   "in",
   "list",
   "(",
   "kargs",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ":",
   "save_ax",
   "=",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   "pylab",
   ".",
   "sca",
   "(",
   "kargs",
   "[",
   "'ax'",
   "]",
   ")",
   "rollback",
   "=",
   "True",
   "del",
   "kargs",
   "[",
   "'ax'",
   "]",
   "else",
   ":",
   "rollback",
   "=",
   "False",
   "if",
   "norm",
   ":",
   "pylab",
   ".",
   "plot",
   "(",
   "frequencies",
   ",",
   "10",
   "*",
   "stools",
   ".",
   "log10",
   "(",
   "psd",
   "/",
   "<mask>",
   "(",
   "psd",
   ")",
   ")",
   ",",
   "*",
   "*",
   "kargs",
   ")",
   "else",
   ":",
   "pylab",
   ".",
   "plot",
   "(",
   "frequencies",
   ",",
   "10",
   "*",
   "stools",
   ".",
   "log10",
   "(",
   "psd",
   ")",
   ",",
   "*",
   "*",
   "kargs",
   ")",
   "pylab",
   ".",
   "xlabel",
   "(",
   "'Frequency'",
   ")",
   "pylab",
   ".",
   "ylabel",
   "(",
   "'Power (dB)'",
   ")",
   "pylab",
   ".",
   "grid",
   "(",
   "True",
   ")",
   "if",
   "ylim",
   ":",
   "plt_ylim",
   "(",
   "ylim",
   ")",
   "if",
   "sides",
   "==",
   "'onesided'",
   ":",
   "pylab",
   ".",
   "xlim",
   "(",
   "0",
   ",",
   "self",
   ".",
   "sampling",
   "/",
   "2.",
   ")",
   "elif",
   "sides",
   "==",
   "'twosided'",
   ":",
   "pylab",
   ".",
   "xlim",
   "(",
   "0",
   ",",
   "self",
   ".",
   "sampling",
   ")",
   "elif",
   "sides",
   "==",
   "'centerdc'",
   ":",
   "pylab",
   ".",
   "xlim",
   "(",
   "-",
   "self",
   ".",
   "sampling",
   "/",
   "2.",
   ",",
   "self",
   ".",
   "sampling",
   "/",
   "2.",
   ")",
   "if",
   "filename",
   ":",
   "pylab",
   ".",
   "savefig",
   "(",
   "filename",
   ")",
   "if",
   "rollback",
   ":",
   "pylab",
   ".",
   "sca",
   "(",
   "save_ax",
   ")",
   "del",
   "psd",
   ",",
   "frequencies"
  ]
 },
 {
  "idx": "maxmin-310",
  "nl_tokens": [
   "Scatter",
   "plot",
   "of",
   "score",
   "vs",
   "each",
   "param"
  ],
  "pl_tokens": [
   "def",
   "plot_4",
   "(",
   "data",
   ",",
   "*",
   "args",
   ")",
   ":",
   "params",
   "=",
   "nonconstant_parameters",
   "(",
   "data",
   ")",
   "scores",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "d",
   "[",
   "'mean_test_score'",
   "]",
   "for",
   "d",
   "in",
   "data",
   "]",
   ")",
   "order",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "scores",
   ")",
   "for",
   "key",
   "in",
   "params",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "if",
   "params",
   "[",
   "key",
   "]",
   ".",
   "dtype",
   "==",
   "np",
   ".",
   "dtype",
   "(",
   "'bool'",
   ")",
   ":",
   "params",
   "[",
   "key",
   "]",
   "=",
   "params",
   "[",
   "key",
   "]",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "int",
   ")",
   "p_list",
   "=",
   "[",
   "]",
   "for",
   "key",
   "in",
   "params",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "x",
   "=",
   "params",
   "[",
   "key",
   "]",
   "[",
   "order",
   "]",
   "y",
   "=",
   "scores",
   "[",
   "order",
   "]",
   "params",
   "=",
   "params",
   ".",
   "loc",
   "[",
   "order",
   "]",
   "try",
   ":",
   "radius",
   "=",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "x",
   ")",
   ")",
   "/",
   "100.0",
   "except",
   ":",
   "print",
   "(",
   "\"error making plot4 for '%s'\"",
   "%",
   "key",
   ")",
   "continue",
   "p_list",
   ".",
   "append",
   "(",
   "build_scatter_tooltip",
   "(",
   "x",
   "=",
   "x",
   ",",
   "y",
   "=",
   "y",
   ",",
   "radius",
   "=",
   "radius",
   ",",
   "add_line",
   "=",
   "False",
   ",",
   "tt",
   "=",
   "params",
   ",",
   "xlabel",
   "=",
   "key",
   ",",
   "title",
   "=",
   "'Score vs %s'",
   "%",
   "key",
   ")",
   ")",
   "return",
   "p_list"
  ]
 },
 {
  "idx": "maxmin-311",
  "nl_tokens": [
   "Check",
   "if",
   "line",
   "contains",
   "a",
   "redundant",
   "virtual",
   "function",
   "-",
   "specifier",
   "."
  ],
  "pl_tokens": [
   "def",
   "CheckRedundantVirtual",
   "(",
   "filename",
   ",",
   "clean_lines",
   ",",
   "linenum",
   ",",
   "error",
   ")",
   ":",
   "# Look for \"virtual\" on current line.",
   "line",
   "=",
   "clean_lines",
   ".",
   "elided",
   "[",
   "linenum",
   "]",
   "virtual",
   "=",
   "Match",
   "(",
   "r'^(.*)(\\bvirtual\\b)(.*)$'",
   ",",
   "line",
   ")",
   "if",
   "not",
   "virtual",
   ":",
   "return",
   "# Ignore \"virtual\" keywords that are near access-specifiers.  These",
   "# are only used in class base-specifier and do not apply to member",
   "# functions.",
   "if",
   "(",
   "Search",
   "(",
   "r'\\b(public|protected|private)\\s+$'",
   ",",
   "virtual",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   "or",
   "Match",
   "(",
   "r'^\\s+(public|protected|private)\\b'",
   ",",
   "virtual",
   ".",
   "group",
   "(",
   "3",
   ")",
   ")",
   ")",
   ":",
   "return",
   "# Ignore the \"virtual\" keyword from virtual base classes.  Usually",
   "# there is a column on the same line in these cases (virtual base",
   "# classes are rare in google3 because multiple inheritance is rare).",
   "if",
   "Match",
   "(",
   "r'^.*[^:]:[^:].*$'",
   ",",
   "line",
   ")",
   ":",
   "return",
   "# Look for the next opening parenthesis.  This is the start of the",
   "# parameter list (possibly on the next line shortly after virtual).",
   "# TODO(unknown): doesn't work if there are virtual functions with",
   "# decltype() or other things that use parentheses, but csearch suggests",
   "# that this is rare.",
   "end_col",
   "=",
   "-",
   "1",
   "end_line",
   "=",
   "-",
   "1",
   "start_col",
   "=",
   "len",
   "(",
   "virtual",
   ".",
   "group",
   "(",
   "2",
   ")",
   ")",
   "for",
   "start_line",
   "in",
   "xrange",
   "(",
   "linenum",
   ",",
   "<mask>",
   "(",
   "linenum",
   "+",
   "3",
   ",",
   "clean_lines",
   ".",
   "NumLines",
   "(",
   ")",
   ")",
   ")",
   ":",
   "line",
   "=",
   "clean_lines",
   ".",
   "elided",
   "[",
   "start_line",
   "]",
   "[",
   "start_col",
   ":",
   "]",
   "parameter_list",
   "=",
   "Match",
   "(",
   "r'^([^(]*)\\('",
   ",",
   "line",
   ")",
   "if",
   "parameter_list",
   ":",
   "# Match parentheses to find the end of the parameter list",
   "(",
   "_",
   ",",
   "end_line",
   ",",
   "end_col",
   ")",
   "=",
   "CloseExpression",
   "(",
   "clean_lines",
   ",",
   "start_line",
   ",",
   "start_col",
   "+",
   "len",
   "(",
   "parameter_list",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   ")",
   "break",
   "start_col",
   "=",
   "0",
   "if",
   "end_col",
   "<",
   "0",
   ":",
   "return",
   "# Couldn't find end of parameter list, give up",
   "# Look for \"override\" or \"final\" after the parameter list",
   "# (possibly on the next few lines).",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "end_line",
   ",",
   "min",
   "(",
   "end_line",
   "+",
   "3",
   ",",
   "clean_lines",
   ".",
   "NumLines",
   "(",
   ")",
   ")",
   ")",
   ":",
   "line",
   "=",
   "clean_lines",
   ".",
   "elided",
   "[",
   "i",
   "]",
   "[",
   "end_col",
   ":",
   "]",
   "match",
   "=",
   "Search",
   "(",
   "r'\\b(override|final)\\b'",
   ",",
   "line",
   ")",
   "if",
   "match",
   ":",
   "error",
   "(",
   "filename",
   ",",
   "linenum",
   ",",
   "'readability/inheritance'",
   ",",
   "4",
   ",",
   "(",
   "'\"virtual\" is redundant since function is '",
   "'already declared as \"%s\"'",
   "%",
   "match",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   ")",
   "# Set end_col to check whole lines after we are done with the",
   "# first line.",
   "end_col",
   "=",
   "0",
   "if",
   "Search",
   "(",
   "r'[^\\w]\\s*$'",
   ",",
   "line",
   ")",
   ":",
   "break"
  ]
 },
 {
  "idx": "maxmin-312",
  "nl_tokens": [
   "Builds",
   "a",
   "single",
   "end",
   "cluster",
   "from",
   "the",
   "refmapped",
   "data",
   "."
  ],
  "pl_tokens": [
   "def",
   "fetch_cluster_se",
   "(",
   "data",
   ",",
   "samfile",
   ",",
   "chrom",
   ",",
   "rstart",
   ",",
   "rend",
   ")",
   ":",
   "## If SE then we enforce the minimum overlap distance to avoid the",
   "## staircase syndrome of multiple reads overlapping just a little.",
   "overlap_buffer",
   "=",
   "data",
   ".",
   "_hackersonly",
   "[",
   "\"min_SE_refmap_overlap\"",
   "]",
   "## the *_buff variables here are because we have to play patty",
   "## cake here with the rstart/rend vals because we want pysam to",
   "## enforce the buffer for SE, but we want the reference sequence",
   "## start and end positions to print correctly for downstream.",
   "rstart_buff",
   "=",
   "rstart",
   "+",
   "overlap_buffer",
   "rend_buff",
   "=",
   "rend",
   "-",
   "overlap_buffer",
   "## Reads that map to only very short segements of the reference",
   "## sequence will return buffer end values that are before the",
   "## start values causing pysam to complain. Very short mappings.",
   "if",
   "rstart_buff",
   ">",
   "rend_buff",
   ":",
   "tmp",
   "=",
   "rstart_buff",
   "rstart_buff",
   "=",
   "rend_buff",
   "rend_buff",
   "=",
   "tmp",
   "## Buffering can't make start and end equal or pysam returns nothing.",
   "if",
   "rstart_buff",
   "==",
   "rend_buff",
   ":",
   "rend_buff",
   "+=",
   "1",
   "## store pairs",
   "rdict",
   "=",
   "{",
   "}",
   "clust",
   "=",
   "[",
   "]",
   "iterreg",
   "=",
   "[",
   "]",
   "iterreg",
   "=",
   "samfile",
   ".",
   "fetch",
   "(",
   "chrom",
   ",",
   "rstart_buff",
   ",",
   "rend_buff",
   ")",
   "## use dict to match up read pairs",
   "for",
   "read",
   "in",
   "iterreg",
   ":",
   "if",
   "read",
   ".",
   "qname",
   "not",
   "in",
   "rdict",
   ":",
   "rdict",
   "[",
   "read",
   ".",
   "qname",
   "]",
   "=",
   "read",
   "## sort dict keys so highest derep is first ('seed')",
   "sfunc",
   "=",
   "lambda",
   "x",
   ":",
   "int",
   "(",
   "x",
   ".",
   "split",
   "(",
   "\";size=\"",
   ")",
   "[",
   "1",
   "]",
   ".",
   "split",
   "(",
   "\";\"",
   ")",
   "[",
   "0",
   "]",
   ")",
   "rkeys",
   "=",
   "sorted",
   "(",
   "rdict",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "key",
   "=",
   "sfunc",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "## get blocks from the seed for filtering, bail out if seed is not paired",
   "try",
   ":",
   "read1",
   "=",
   "rdict",
   "[",
   "rkeys",
   "[",
   "0",
   "]",
   "]",
   "except",
   "ValueError",
   ":",
   "LOGGER",
   ".",
   "error",
   "(",
   "\"Found bad cluster, skipping - key:{} rdict:{}\"",
   ".",
   "format",
   "(",
   "rkeys",
   "[",
   "0",
   "]",
   ",",
   "rdict",
   ")",
   ")",
   "return",
   "\"\"",
   "## the starting blocks for the seed",
   "poss",
   "=",
   "read1",
   ".",
   "get_reference_positions",
   "(",
   "full_length",
   "=",
   "True",
   ")",
   "seed_r1start",
   "=",
   "<mask>",
   "(",
   "poss",
   ")",
   "seed_r1end",
   "=",
   "max",
   "(",
   "poss",
   ")",
   "## store the seed -------------------------------------------",
   "if",
   "read1",
   ".",
   "is_reverse",
   ":",
   "seq",
   "=",
   "revcomp",
   "(",
   "read1",
   ".",
   "seq",
   ")",
   "else",
   ":",
   "seq",
   "=",
   "read1",
   ".",
   "seq",
   "## store, could write orient but just + for now.",
   "size",
   "=",
   "sfunc",
   "(",
   "rkeys",
   "[",
   "0",
   "]",
   ")",
   "clust",
   ".",
   "append",
   "(",
   "\">{}:{}:{};size={};*\\n{}\"",
   ".",
   "format",
   "(",
   "chrom",
   ",",
   "seed_r1start",
   ",",
   "seed_r1end",
   ",",
   "size",
   ",",
   "seq",
   ")",
   ")",
   "## If there's only one hit in this region then rkeys will only have",
   "## one element and the call to `rkeys[1:]` will raise. Test for this.",
   "if",
   "len",
   "(",
   "rkeys",
   ")",
   ">",
   "1",
   ":",
   "## store the hits to the seed -------------------------------",
   "for",
   "key",
   "in",
   "rkeys",
   "[",
   "1",
   ":",
   "]",
   ":",
   "skip",
   "=",
   "False",
   "try",
   ":",
   "read1",
   "=",
   "rdict",
   "[",
   "key",
   "]",
   "except",
   "ValueError",
   ":",
   "## enter values that will make this read get skipped",
   "read1",
   "=",
   "rdict",
   "[",
   "key",
   "]",
   "[",
   "0",
   "]",
   "skip",
   "=",
   "True",
   "## orient reads only if not skipping",
   "if",
   "not",
   "skip",
   ":",
   "poss",
   "=",
   "read1",
   ".",
   "get_reference_positions",
   "(",
   "full_length",
   "=",
   "True",
   ")",
   "minpos",
   "=",
   "min",
   "(",
   "poss",
   ")",
   "maxpos",
   "=",
   "max",
   "(",
   "poss",
   ")",
   "## store the seq",
   "if",
   "read1",
   ".",
   "is_reverse",
   ":",
   "seq",
   "=",
   "revcomp",
   "(",
   "read1",
   ".",
   "seq",
   ")",
   "else",
   ":",
   "seq",
   "=",
   "read1",
   ".",
   "seq",
   "## store, could write orient but just + for now.",
   "size",
   "=",
   "sfunc",
   "(",
   "key",
   ")",
   "clust",
   ".",
   "append",
   "(",
   "\">{}:{}:{};size={};+\\n{}\"",
   ".",
   "format",
   "(",
   "chrom",
   ",",
   "minpos",
   ",",
   "maxpos",
   ",",
   "size",
   ",",
   "seq",
   ")",
   ")",
   "else",
   ":",
   "## seq is excluded, though, we could save it and return",
   "## it as a separate cluster that will be aligned separately.",
   "pass",
   "return",
   "clust"
  ]
 },
 {
  "idx": "maxmin-313",
  "nl_tokens": [
   "Call",
   "the",
   "interfaces",
   ".",
   "IOHandler",
   ".",
   "prepare",
   "method",
   "and",
   "remove",
   "the",
   "handler",
   "from",
   "unprepared",
   "handler",
   "list",
   "when",
   "done",
   "."
  ],
  "pl_tokens": [
   "def",
   "_prepare_io_handler",
   "(",
   "self",
   ",",
   "handler",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\" preparing handler: {0!r}\"",
   ".",
   "format",
   "(",
   "handler",
   ")",
   ")",
   "ret",
   "=",
   "handler",
   ".",
   "prepare",
   "(",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"   prepare result: {0!r}\"",
   ".",
   "format",
   "(",
   "ret",
   ")",
   ")",
   "if",
   "isinstance",
   "(",
   "ret",
   ",",
   "HandlerReady",
   ")",
   ":",
   "del",
   "self",
   ".",
   "_unprepared_handlers",
   "[",
   "handler",
   "]",
   "prepared",
   "=",
   "True",
   "elif",
   "isinstance",
   "(",
   "ret",
   ",",
   "PrepareAgain",
   ")",
   ":",
   "if",
   "ret",
   ".",
   "timeout",
   "is",
   "not",
   "None",
   ":",
   "if",
   "self",
   ".",
   "_timeout",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "_timeout",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_timeout",
   ",",
   "ret",
   ".",
   "timeout",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_timeout",
   "=",
   "ret",
   ".",
   "timeout",
   "prepared",
   "=",
   "False",
   "else",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Unexpected result type from prepare()\"",
   ")",
   "return",
   "prepared"
  ]
 },
 {
  "idx": "maxmin-314",
  "nl_tokens": [
   "Get",
   "the",
   "width",
   "of",
   "a",
   "bounding",
   "box",
   "encapsulating",
   "the",
   "line",
   "."
  ],
  "pl_tokens": [
   "def",
   "width",
   "(",
   "self",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   "<=",
   "1",
   ":",
   "return",
   "0",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "xx",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "self",
   ".",
   "xx",
   ")"
  ]
 },
 {
  "idx": "maxmin-315",
  "nl_tokens": [
   "Its",
   "actually",
   "quite",
   "complicated",
   "to",
   "cover",
   "every",
   "case",
   ":",
   ")",
   "http",
   ":",
   "//",
   "www",
   ".",
   "javascriptkit",
   ".",
   "com",
   "/",
   "jsref",
   "/",
   "escapesequence",
   ".",
   "shtml"
  ],
  "pl_tokens": [
   "def",
   "do_escape",
   "(",
   "source",
   ",",
   "n",
   ")",
   ":",
   "if",
   "not",
   "n",
   "+",
   "1",
   "<",
   "len",
   "(",
   "source",
   ")",
   ":",
   "return",
   "''",
   "# not possible here but can be possible in general case.",
   "if",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   "in",
   "LINE_TERMINATOR",
   ":",
   "if",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   "==",
   "CR",
   "and",
   "n",
   "+",
   "2",
   "<",
   "len",
   "(",
   "source",
   ")",
   "and",
   "source",
   "[",
   "n",
   "+",
   "2",
   "]",
   "==",
   "LF",
   ":",
   "return",
   "source",
   "[",
   "n",
   ":",
   "n",
   "+",
   "3",
   "]",
   ",",
   "n",
   "+",
   "3",
   "return",
   "source",
   "[",
   "n",
   ":",
   "n",
   "+",
   "2",
   "]",
   ",",
   "n",
   "+",
   "2",
   "if",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   "in",
   "ESCAPE_CHARS",
   ":",
   "return",
   "source",
   "[",
   "n",
   ":",
   "n",
   "+",
   "2",
   "]",
   ",",
   "n",
   "+",
   "2",
   "if",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   "in",
   "{",
   "'x'",
   ",",
   "'u'",
   "}",
   ":",
   "char",
   ",",
   "length",
   "=",
   "(",
   "'u'",
   ",",
   "4",
   ")",
   "if",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   "==",
   "'u'",
   "else",
   "(",
   "'x'",
   ",",
   "2",
   ")",
   "n",
   "+=",
   "2",
   "end",
   "=",
   "parse_num",
   "(",
   "source",
   ",",
   "n",
   ",",
   "HEX",
   ")",
   "if",
   "end",
   "-",
   "n",
   "<",
   "length",
   ":",
   "raise",
   "SyntaxError",
   "(",
   "'Invalid escape sequence!'",
   ")",
   "#if length==4:",
   "#    return unichr(int(source[n:n+4], 16)), n+4 # <- this was a very bad way of solving this problem :)",
   "return",
   "source",
   "[",
   "n",
   "-",
   "2",
   ":",
   "n",
   "+",
   "length",
   "]",
   ",",
   "n",
   "+",
   "length",
   "if",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   "in",
   "OCTAL",
   ":",
   "n",
   "+=",
   "1",
   "end",
   "=",
   "parse_num",
   "(",
   "source",
   ",",
   "n",
   ",",
   "OCTAL",
   ")",
   "end",
   "=",
   "<mask>",
   "(",
   "end",
   ",",
   "n",
   "+",
   "3",
   ")",
   "# cant be longer than 3",
   "# now the max allowed is 377 ( in octal) and 255 in decimal",
   "max_num",
   "=",
   "255",
   "num",
   "=",
   "0",
   "len_parsed",
   "=",
   "0",
   "for",
   "e",
   "in",
   "source",
   "[",
   "n",
   ":",
   "end",
   "]",
   ":",
   "cand",
   "=",
   "8",
   "*",
   "num",
   "+",
   "int",
   "(",
   "e",
   ")",
   "if",
   "cand",
   ">",
   "max_num",
   ":",
   "break",
   "num",
   "=",
   "cand",
   "len_parsed",
   "+=",
   "1",
   "# we have to return in a different form because python may want to parse more...",
   "# for example '\\777' will be parsed by python as a whole while js will use only \\77",
   "return",
   "'\\\\'",
   "+",
   "hex",
   "(",
   "num",
   ")",
   "[",
   "1",
   ":",
   "]",
   ",",
   "n",
   "+",
   "len_parsed",
   "return",
   "source",
   "[",
   "n",
   "+",
   "1",
   "]",
   ",",
   "n",
   "+",
   "2"
  ]
 },
 {
  "idx": "maxmin-316",
  "nl_tokens": [
   "Tuple",
   "(",
   "importance",
   "end",
   "-",
   "time",
   ")",
   ".",
   "Smaller",
   "values",
   "are",
   "more",
   "important",
   "."
  ],
  "pl_tokens": [
   "def",
   "_importance_of_task",
   "(",
   "task",
   ")",
   ":",
   "# The status of a job is going to be determined by the roll-up of its tasks.",
   "# A FAILURE or CANCELED task means the job has FAILED.",
   "# If none, then any RUNNING task, the job is still RUNNING.",
   "# If none, then the job status is SUCCESS.",
   "#",
   "# Thus the dominant task for each job is one that exemplifies its",
   "# status:",
   "#",
   "# 1- The first (FAILURE or CANCELED) task, or if none",
   "# 2- The first RUNNING task, or if none",
   "# 3- The first SUCCESS task.",
   "importance",
   "=",
   "{",
   "'FAILURE'",
   ":",
   "0",
   ",",
   "'CANCELED'",
   ":",
   "0",
   ",",
   "'RUNNING'",
   ":",
   "1",
   ",",
   "'SUCCESS'",
   ":",
   "2",
   "}",
   "return",
   "(",
   "importance",
   "[",
   "task",
   ".",
   "get_field",
   "(",
   "'task-status'",
   ")",
   "]",
   ",",
   "task",
   ".",
   "get_field",
   "(",
   "'end-time'",
   ",",
   "datetime",
   ".",
   "datetime",
   ".",
   "<mask>",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-317",
  "nl_tokens": [
   "Return",
   "a",
   "str",
   "of",
   "decimal",
   "with",
   "two",
   "digits",
   "after",
   "a",
   "decimal",
   "mark",
   "."
  ],
  "pl_tokens": [
   "def",
   "money",
   "(",
   "<mask>",
   "=",
   "0",
   ",",
   "max",
   "=",
   "10",
   ")",
   ":",
   "value",
   "=",
   "random",
   ".",
   "choice",
   "(",
   "range",
   "(",
   "min",
   "*",
   "100",
   ",",
   "max",
   "*",
   "100",
   ")",
   ")",
   "return",
   "\"%1.2f\"",
   "%",
   "(",
   "float",
   "(",
   "value",
   ")",
   "/",
   "100",
   ")"
  ]
 },
 {
  "idx": "maxmin-318",
  "nl_tokens": [
   ":",
   "param",
   "unicode",
   "path",
   ":",
   "Path",
   "to",
   "file",
   "or",
   "directory"
  ],
  "pl_tokens": [
   "def",
   "GetMTime",
   "(",
   "path",
   ")",
   ":",
   "_AssertIsLocal",
   "(",
   "path",
   ")",
   "if",
   "os",
   ".",
   "path",
   ".",
   "isdir",
   "(",
   "path",
   ")",
   ":",
   "files",
   "=",
   "FindFiles",
   "(",
   "path",
   ")",
   "if",
   "len",
   "(",
   "files",
   ")",
   ">",
   "0",
   ":",
   "return",
   "<mask>",
   "(",
   "map",
   "(",
   "os",
   ".",
   "path",
   ".",
   "getmtime",
   ",",
   "files",
   ")",
   ")",
   "return",
   "os",
   ".",
   "path",
   ".",
   "getmtime",
   "(",
   "path",
   ")"
  ]
 },
 {
  "idx": "maxmin-319",
  "nl_tokens": [
   "Point",
   "area",
   "palette",
   "(",
   "continuous",
   ")",
   "with",
   "area",
   "proportional",
   "to",
   "value",
   "."
  ],
  "pl_tokens": [
   "def",
   "abs_area",
   "(",
   "<mask>",
   ")",
   ":",
   "def",
   "abs_area_palette",
   "(",
   "x",
   ")",
   ":",
   "return",
   "rescale",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   ")",
   ",",
   "to",
   "=",
   "(",
   "0",
   ",",
   "max",
   ")",
   ",",
   "_from",
   "=",
   "(",
   "0",
   ",",
   "1",
   ")",
   ")",
   "return",
   "abs_area_palette"
  ]
 },
 {
  "idx": "maxmin-320",
  "nl_tokens": [
   "Constructs",
   "a",
   "list",
   "of",
   "booleans",
   "where",
   "an",
   "item",
   "is",
   "True",
   "if",
   "its",
   "position",
   "is",
   "in",
   "indices",
   "otherwise",
   "it",
   "is",
   "False",
   "."
  ],
  "pl_tokens": [
   "def",
   "boolmask",
   "(",
   "indices",
   ",",
   "maxval",
   "=",
   "None",
   ")",
   ":",
   "if",
   "maxval",
   "is",
   "None",
   ":",
   "indices",
   "=",
   "list",
   "(",
   "indices",
   ")",
   "maxval",
   "=",
   "<mask>",
   "(",
   "indices",
   ")",
   "+",
   "1",
   "mask",
   "=",
   "[",
   "False",
   "]",
   "*",
   "maxval",
   "for",
   "index",
   "in",
   "indices",
   ":",
   "mask",
   "[",
   "index",
   "]",
   "=",
   "True",
   "return",
   "mask"
  ]
 },
 {
  "idx": "maxmin-321",
  "nl_tokens": [
   "m1",
   "and",
   "m2",
   "if",
   "given",
   "are",
   "in",
   "seconds",
   ".",
   "returns",
   "[",
   "#",
   "EPSCs",
   "#",
   "IPSCs",
   "]"
  ],
  "pl_tokens": [
   "def",
   "analyzeSweep",
   "(",
   "abf",
   ",",
   "sweep",
   ",",
   "m1",
   "=",
   "None",
   ",",
   "m2",
   "=",
   "None",
   ",",
   "plotToo",
   "=",
   "False",
   ")",
   ":",
   "abf",
   ".",
   "setsweep",
   "(",
   "sweep",
   ")",
   "if",
   "m1",
   "is",
   "None",
   ":",
   "m1",
   "=",
   "0",
   "else",
   ":",
   "m1",
   "=",
   "m1",
   "*",
   "abf",
   ".",
   "pointsPerSec",
   "if",
   "m2",
   "is",
   "None",
   ":",
   "m2",
   "=",
   "-",
   "1",
   "else",
   ":",
   "m2",
   "=",
   "m2",
   "*",
   "abf",
   ".",
   "pointsPerSec",
   "# obtain X and Y",
   "Yorig",
   "=",
   "abf",
   ".",
   "sweepY",
   "[",
   "int",
   "(",
   "m1",
   ")",
   ":",
   "int",
   "(",
   "m2",
   ")",
   "]",
   "X",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "Yorig",
   ")",
   ")",
   "/",
   "abf",
   ".",
   "pointsPerSec",
   "Ylpf",
   "=",
   "linear_gaussian",
   "(",
   "Yorig",
   ",",
   "sigmaSize",
   "=",
   "abf",
   ".",
   "pointsPerMs",
   "*",
   "300",
   ",",
   "forwardOnly",
   "=",
   "False",
   ")",
   "Yflat",
   "=",
   "Yorig",
   "-",
   "Ylpf",
   "EPSCs",
   ",",
   "IPSCs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "if",
   "plotToo",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "15",
   ",",
   "6",
   ")",
   ")",
   "ax1",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "211",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "\"%s sweep %d\"",
   "%",
   "(",
   "abf",
   ".",
   "ID",
   ",",
   "sweep",
   ")",
   ")",
   "plt",
   ".",
   "grid",
   "(",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "X",
   ",",
   "Yorig",
   ",",
   "alpha",
   "=",
   ".5",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "X",
   ",",
   "Ylpf",
   ",",
   "'k'",
   ",",
   "alpha",
   "=",
   ".5",
   ",",
   "lw",
   "=",
   "2",
   ")",
   "plt",
   ".",
   "margins",
   "(",
   "0",
   ",",
   ".2",
   ")",
   "plt",
   ".",
   "subplot",
   "(",
   "212",
   ",",
   "sharex",
   "=",
   "ax1",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "\"gaussian baseline subtraction\"",
   ")",
   "plt",
   ".",
   "grid",
   "(",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "X",
   ",",
   "Yflat",
   ",",
   "alpha",
   "=",
   ".5",
   ")",
   "plt",
   ".",
   "axhline",
   "(",
   "0",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "alpha",
   "=",
   ".5",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "# TEST GAUSS",
   "hist",
   ",",
   "bin_edges",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "Yflat",
   ",",
   "density",
   "=",
   "True",
   ",",
   "bins",
   "=",
   "200",
   ")",
   "peakPa",
   "=",
   "bin_edges",
   "[",
   "np",
   ".",
   "where",
   "(",
   "hist",
   "==",
   "<mask>",
   "(",
   "hist",
   ")",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "1",
   "]",
   "if",
   "plotToo",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "plt",
   ".",
   "grid",
   "(",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "bin_edges",
   "[",
   "1",
   ":",
   "]",
   ",",
   "hist",
   ",",
   "alpha",
   "=",
   ".5",
   ")",
   "plt",
   ".",
   "axvline",
   "(",
   "0",
   ",",
   "color",
   "=",
   "'k'",
   ")",
   "plt",
   ".",
   "axvline",
   "(",
   "peakPa",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "ls",
   "=",
   "'--'",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "alpha",
   "=",
   ".5",
   ")",
   "plt",
   ".",
   "semilogy",
   "(",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "\"sweep data distribution\"",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "\"power\"",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "\"pA deviation\"",
   ")",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "return",
   "peakPa"
  ]
 },
 {
  "idx": "maxmin-322",
  "nl_tokens": [
   "Rescale",
   "numeric",
   "vector",
   "to",
   "have",
   "specified",
   "minimum",
   "and",
   "maximum",
   "."
  ],
  "pl_tokens": [
   "def",
   "rescale",
   "(",
   "x",
   ",",
   "to",
   "=",
   "(",
   "0",
   ",",
   "1",
   ")",
   ",",
   "_from",
   "=",
   "None",
   ")",
   ":",
   "if",
   "_from",
   "is",
   "None",
   ":",
   "_from",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "return",
   "np",
   ".",
   "interp",
   "(",
   "x",
   ",",
   "_from",
   ",",
   "to",
   ")"
  ]
 },
 {
  "idx": "maxmin-323",
  "nl_tokens": [
   "Parameters",
   "----------",
   "new_label",
   ":",
   "LabelTime"
  ],
  "pl_tokens": [
   "def",
   "update_pareto_optimal_tuples",
   "(",
   "self",
   ",",
   "new_label",
   ")",
   ":",
   "assert",
   "(",
   "isinstance",
   "(",
   "new_label",
   ",",
   "LabelTime",
   ")",
   ")",
   "if",
   "self",
   ".",
   "_labels",
   ":",
   "assert",
   "(",
   "new_label",
   ".",
   "departure_time",
   "<=",
   "self",
   ".",
   "_labels",
   "[",
   "-",
   "1",
   "]",
   ".",
   "departure_time",
   ")",
   "best_later_departing_arrival_time",
   "=",
   "self",
   ".",
   "_labels",
   "[",
   "-",
   "1",
   "]",
   ".",
   "arrival_time_target",
   "else",
   ":",
   "best_later_departing_arrival_time",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "walk_to_target_arrival_time",
   "=",
   "new_label",
   ".",
   "departure_time",
   "+",
   "self",
   ".",
   "_walk_to_target_duration",
   "best_arrival_time",
   "=",
   "<mask>",
   "(",
   "walk_to_target_arrival_time",
   ",",
   "best_later_departing_arrival_time",
   ",",
   "new_label",
   ".",
   "arrival_time_target",
   ")",
   "# this should be changed to get constant time insertions / additions",
   "# (with time-indexing)",
   "if",
   "(",
   "new_label",
   ".",
   "arrival_time_target",
   "<",
   "walk_to_target_arrival_time",
   "and",
   "new_label",
   ".",
   "arrival_time_target",
   "<",
   "best_later_departing_arrival_time",
   ")",
   ":",
   "self",
   ".",
   "_labels",
   ".",
   "append",
   "(",
   "LabelTime",
   "(",
   "new_label",
   ".",
   "departure_time",
   ",",
   "best_arrival_time",
   ")",
   ")",
   "return",
   "True",
   "else",
   ":",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-324",
  "nl_tokens": [
   "Update",
   "the",
   "inhibition",
   "radius",
   ".",
   "The",
   "inhibition",
   "radius",
   "is",
   "a",
   "measure",
   "of",
   "the",
   "square",
   "(",
   "or",
   "hypersquare",
   ")",
   "of",
   "columns",
   "that",
   "each",
   "a",
   "column",
   "is",
   "connected",
   "to",
   "on",
   "average",
   ".",
   "Since",
   "columns",
   "are",
   "are",
   "not",
   "connected",
   "to",
   "each",
   "other",
   "directly",
   "we",
   "determine",
   "this",
   "quantity",
   "by",
   "first",
   "figuring",
   "out",
   "how",
   "many",
   "*",
   "inputs",
   "*",
   "a",
   "column",
   "is",
   "connected",
   "to",
   "and",
   "then",
   "multiplying",
   "it",
   "by",
   "the",
   "total",
   "number",
   "of",
   "columns",
   "that",
   "exist",
   "for",
   "each",
   "input",
   ".",
   "For",
   "multiple",
   "dimension",
   "the",
   "aforementioned",
   "calculations",
   "are",
   "averaged",
   "over",
   "all",
   "dimensions",
   "of",
   "inputs",
   "and",
   "columns",
   ".",
   "This",
   "value",
   "is",
   "meaningless",
   "if",
   "global",
   "inhibition",
   "is",
   "enabled",
   "."
  ],
  "pl_tokens": [
   "def",
   "_updateInhibitionRadius",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_globalInhibition",
   ":",
   "self",
   ".",
   "_inhibitionRadius",
   "=",
   "int",
   "(",
   "self",
   ".",
   "_columnDimensions",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "return",
   "avgConnectedSpan",
   "=",
   "numpy",
   ".",
   "average",
   "(",
   "[",
   "self",
   ".",
   "_avgConnectedSpanForColumnND",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "self",
   ".",
   "_numColumns",
   ")",
   "]",
   ")",
   "columnsPerInput",
   "=",
   "self",
   ".",
   "_avgColumnsPerInput",
   "(",
   ")",
   "diameter",
   "=",
   "avgConnectedSpan",
   "*",
   "columnsPerInput",
   "radius",
   "=",
   "(",
   "diameter",
   "-",
   "1",
   ")",
   "/",
   "2.0",
   "radius",
   "=",
   "max",
   "(",
   "1.0",
   ",",
   "radius",
   ")",
   "self",
   ".",
   "_inhibitionRadius",
   "=",
   "int",
   "(",
   "radius",
   "+",
   "0.5",
   ")"
  ]
 },
 {
  "idx": "maxmin-325",
  "nl_tokens": [
   "Calculate",
   "breaks",
   "in",
   "data",
   "space",
   "and",
   "return",
   "them",
   "in",
   "transformed",
   "space",
   "."
  ],
  "pl_tokens": [
   "def",
   "breaks",
   "(",
   "self",
   ",",
   "limits",
   ")",
   ":",
   "# clip the breaks to the domain,",
   "# e.g. probabilities will be in [0, 1] domain",
   "vmin",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "domain",
   "[",
   "0",
   "]",
   ",",
   "limits",
   "[",
   "0",
   "]",
   "]",
   ")",
   "vmax",
   "=",
   "np",
   ".",
   "min",
   "(",
   "[",
   "self",
   ".",
   "domain",
   "[",
   "1",
   "]",
   ",",
   "limits",
   "[",
   "1",
   "]",
   "]",
   ")",
   "breaks",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "self",
   ".",
   "breaks_",
   "(",
   "[",
   "vmin",
   ",",
   "vmax",
   "]",
   ")",
   ")",
   "# Some methods(mpl_breaks, extended_breaks) that",
   "# calculate breaks take the limits as guide posts and",
   "# not hard limits.",
   "breaks",
   "=",
   "breaks",
   ".",
   "compress",
   "(",
   "(",
   "breaks",
   ">=",
   "self",
   ".",
   "domain",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "breaks",
   "<=",
   "self",
   ".",
   "domain",
   "[",
   "1",
   "]",
   ")",
   ")",
   "return",
   "breaks"
  ]
 },
 {
  "idx": "maxmin-326",
  "nl_tokens": [
   "Returns",
   "index",
   "/",
   "key",
   "of",
   "the",
   "item",
   "with",
   "the",
   "largest",
   "value",
   "."
  ],
  "pl_tokens": [
   "def",
   "argmax",
   "(",
   "indexable",
   ",",
   "key",
   "=",
   "None",
   ")",
   ":",
   "if",
   "key",
   "is",
   "None",
   "and",
   "isinstance",
   "(",
   "indexable",
   ",",
   "collections_abc",
   ".",
   "Mapping",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "indexable",
   ".",
   "items",
   "(",
   ")",
   ",",
   "key",
   "=",
   "operator",
   ".",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "elif",
   "hasattr",
   "(",
   "indexable",
   ",",
   "'index'",
   ")",
   ":",
   "if",
   "key",
   "is",
   "None",
   ":",
   "return",
   "indexable",
   ".",
   "index",
   "(",
   "max",
   "(",
   "indexable",
   ")",
   ")",
   "else",
   ":",
   "return",
   "indexable",
   ".",
   "index",
   "(",
   "max",
   "(",
   "indexable",
   ",",
   "key",
   "=",
   "key",
   ")",
   ")",
   "else",
   ":",
   "# less efficient, but catch all solution",
   "return",
   "argsort",
   "(",
   "indexable",
   ",",
   "key",
   "=",
   "key",
   ")",
   "[",
   "-",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-327",
  "nl_tokens": [
   "Returns",
   "a",
   "list",
   "of",
   "Period",
   "tuples",
   "for",
   "each",
   "period",
   "represented",
   "in",
   "an",
   "<exception",
   ">",
   "that",
   "falls",
   "between",
   "range_start",
   "and",
   "range_end",
   "."
  ],
  "pl_tokens": [
   "def",
   "exception_periods",
   "(",
   "self",
   ",",
   "range_start",
   "=",
   "datetime",
   ".",
   "date",
   ".",
   "<mask>",
   ",",
   "range_end",
   "=",
   "datetime",
   ".",
   "date",
   ".",
   "max",
   ")",
   ":",
   "periods",
   "=",
   "[",
   "]",
   "for",
   "exception_date",
   ",",
   "exception_times",
   "in",
   "self",
   ".",
   "exceptions",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "exception_date",
   ">=",
   "range_start",
   "and",
   "exception_date",
   "<=",
   "range_end",
   ":",
   "for",
   "exception_time",
   "in",
   "exception_times",
   ":",
   "periods",
   ".",
   "append",
   "(",
   "Period",
   "(",
   "self",
   ".",
   "timezone",
   ".",
   "localize",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "exception_date",
   ",",
   "exception_time",
   ".",
   "start",
   ")",
   ")",
   ",",
   "self",
   ".",
   "timezone",
   ".",
   "localize",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "exception_date",
   ",",
   "exception_time",
   ".",
   "end",
   ")",
   ")",
   ")",
   ")",
   "periods",
   ".",
   "sort",
   "(",
   ")",
   "return",
   "periods"
  ]
 },
 {
  "idx": "maxmin-328",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "calculate",
   "enthalpy",
   "of",
   "vaporization",
   "for",
   "a",
   "pure",
   "fluid",
   "from",
   "an",
   "equation",
   "of",
   "state",
   "without",
   "iteration",
   ".",
   "..",
   "math",
   "::",
   "\\",
   "frac",
   "{",
   "dP^",
   "{",
   "sat",
   "}}",
   "{",
   "dT",
   "}",
   "=",
   "\\",
   "frac",
   "{",
   "\\",
   "Delta",
   "H_",
   "{",
   "vap",
   "}}",
   "{",
   "T",
   "(",
   "V_g",
   "-",
   "V_l",
   ")",
   "}",
   "Results",
   "above",
   "the",
   "critical",
   "temperature",
   "are",
   "meaningless",
   ".",
   "A",
   "first",
   "-",
   "order",
   "polynomial",
   "is",
   "used",
   "to",
   "extrapolate",
   "under",
   "0",
   ".",
   "32",
   "Tc",
   ";",
   "however",
   "there",
   "is",
   "normally",
   "not",
   "a",
   "volume",
   "solution",
   "to",
   "the",
   "EOS",
   "which",
   "can",
   "produce",
   "that",
   "low",
   "of",
   "a",
   "pressure",
   ".",
   "Parameters",
   "----------",
   "T",
   ":",
   "float",
   "Temperature",
   "[",
   "K",
   "]"
  ],
  "pl_tokens": [
   "def",
   "Hvap",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "Psat",
   "=",
   "self",
   ".",
   "Psat",
   "(",
   "T",
   ")",
   "dPsat_dT",
   "=",
   "self",
   ".",
   "dPsat_dT",
   "(",
   "T",
   ")",
   "a_alpha",
   "=",
   "self",
   ".",
   "a_alpha_and_derivatives",
   "(",
   "T",
   ",",
   "full",
   "=",
   "False",
   ")",
   "Vs",
   "=",
   "self",
   ".",
   "volume_solutions",
   "(",
   "T",
   ",",
   "Psat",
   ",",
   "self",
   ".",
   "b",
   ",",
   "self",
   ".",
   "delta",
   ",",
   "self",
   ".",
   "epsilon",
   ",",
   "a_alpha",
   ")",
   "# Assume we can safely take the Vmax as gas, Vmin as l on the saturation line",
   "Vs",
   "=",
   "[",
   "i",
   ".",
   "real",
   "for",
   "i",
   "in",
   "Vs",
   "]",
   "V_l",
   ",",
   "V_g",
   "=",
   "<mask>",
   "(",
   "Vs",
   ")",
   ",",
   "max",
   "(",
   "Vs",
   ")",
   "return",
   "dPsat_dT",
   "*",
   "T",
   "*",
   "(",
   "V_g",
   "-",
   "V_l",
   ")"
  ]
 },
 {
  "idx": "maxmin-329",
  "nl_tokens": [
   "Record",
   "the",
   "best",
   "score",
   "for",
   "a",
   "swarm",
   "s",
   "generation",
   "index",
   "(",
   "x",
   ")",
   "Returns",
   "list",
   "of",
   "swarmIds",
   "to",
   "terminate",
   "."
  ],
  "pl_tokens": [
   "def",
   "recordDataPoint",
   "(",
   "self",
   ",",
   "swarmId",
   ",",
   "generation",
   ",",
   "errScore",
   ")",
   ":",
   "terminatedSwarms",
   "=",
   "[",
   "]",
   "# Append score to existing swarm.",
   "if",
   "swarmId",
   "in",
   "self",
   ".",
   "swarmScores",
   ":",
   "entry",
   "=",
   "self",
   ".",
   "swarmScores",
   "[",
   "swarmId",
   "]",
   "assert",
   "(",
   "len",
   "(",
   "entry",
   ")",
   "==",
   "generation",
   ")",
   "entry",
   ".",
   "append",
   "(",
   "errScore",
   ")",
   "entry",
   "=",
   "self",
   ".",
   "swarmBests",
   "[",
   "swarmId",
   "]",
   "entry",
   ".",
   "append",
   "(",
   "<mask>",
   "(",
   "errScore",
   ",",
   "entry",
   "[",
   "-",
   "1",
   "]",
   ")",
   ")",
   "assert",
   "(",
   "len",
   "(",
   "self",
   ".",
   "swarmBests",
   "[",
   "swarmId",
   "]",
   ")",
   "==",
   "len",
   "(",
   "self",
   ".",
   "swarmScores",
   "[",
   "swarmId",
   "]",
   ")",
   ")",
   "else",
   ":",
   "# Create list of scores for a new swarm",
   "assert",
   "(",
   "generation",
   "==",
   "0",
   ")",
   "self",
   ".",
   "swarmScores",
   "[",
   "swarmId",
   "]",
   "=",
   "[",
   "errScore",
   "]",
   "self",
   ".",
   "swarmBests",
   "[",
   "swarmId",
   "]",
   "=",
   "[",
   "errScore",
   "]",
   "# If the current swarm hasn't completed at least MIN_GENERATIONS, it should",
   "# not be candidate for maturation or termination. This prevents the initial",
   "# allocation of particles in PSO from killing off a field combination too",
   "# early.",
   "if",
   "generation",
   "+",
   "1",
   "<",
   "self",
   ".",
   "MATURITY_WINDOW",
   ":",
   "return",
   "terminatedSwarms",
   "# If the swarm has completed more than MAX_GENERATIONS, it should be marked",
   "# as mature, regardless of how its value is changing.",
   "if",
   "self",
   ".",
   "MAX_GENERATIONS",
   "is",
   "not",
   "None",
   "and",
   "generation",
   ">",
   "self",
   ".",
   "MAX_GENERATIONS",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'Swarm %s has matured (more than %d generations). Stopping'",
   "%",
   "(",
   "swarmId",
   ",",
   "self",
   ".",
   "MAX_GENERATIONS",
   ")",
   ")",
   "terminatedSwarms",
   ".",
   "append",
   "(",
   "swarmId",
   ")",
   "if",
   "self",
   ".",
   "_isTerminationEnabled",
   ":",
   "terminatedSwarms",
   ".",
   "extend",
   "(",
   "self",
   ".",
   "_getTerminatedSwarms",
   "(",
   "generation",
   ")",
   ")",
   "# Return which swarms to kill when we've reached maturity",
   "# If there is no change in the swarm's best for some time,",
   "# Mark it dead",
   "cumulativeBestScores",
   "=",
   "self",
   ".",
   "swarmBests",
   "[",
   "swarmId",
   "]",
   "if",
   "cumulativeBestScores",
   "[",
   "-",
   "1",
   "]",
   "==",
   "cumulativeBestScores",
   "[",
   "-",
   "self",
   ".",
   "MATURITY_WINDOW",
   "]",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'Swarm %s has matured (no change in %d generations).'",
   "'Stopping...'",
   "%",
   "(",
   "swarmId",
   ",",
   "self",
   ".",
   "MATURITY_WINDOW",
   ")",
   ")",
   "terminatedSwarms",
   ".",
   "append",
   "(",
   "swarmId",
   ")",
   "self",
   ".",
   "terminatedSwarms",
   "=",
   "self",
   ".",
   "terminatedSwarms",
   ".",
   "union",
   "(",
   "terminatedSwarms",
   ")",
   "return",
   "terminatedSwarms"
  ]
 },
 {
  "idx": "maxmin-330",
  "nl_tokens": [
   "Print",
   "a",
   "list",
   "of",
   "lists",
   "as",
   "a",
   "table",
   "so",
   "that",
   "columns",
   "line",
   "up",
   "nicely",
   ".",
   "header",
   "if",
   "specified",
   "will",
   "be",
   "printed",
   "as",
   "the",
   "first",
   "row",
   ".",
   "numfmt",
   "is",
   "the",
   "format",
   "for",
   "all",
   "numbers",
   ";",
   "you",
   "might",
   "want",
   "e",
   ".",
   "g",
   ".",
   "%6",
   ".",
   "2f",
   ".",
   "(",
   "If",
   "you",
   "want",
   "different",
   "formats",
   "in",
   "different",
   "columns",
   "don",
   "t",
   "use",
   "print_table",
   ".",
   ")",
   "sep",
   "is",
   "the",
   "separator",
   "between",
   "columns",
   "."
  ],
  "pl_tokens": [
   "def",
   "print_table",
   "(",
   "table",
   ",",
   "header",
   "=",
   "None",
   ",",
   "sep",
   "=",
   "'   '",
   ",",
   "numfmt",
   "=",
   "'%g'",
   ")",
   ":",
   "justs",
   "=",
   "[",
   "if_",
   "(",
   "isnumber",
   "(",
   "x",
   ")",
   ",",
   "'rjust'",
   ",",
   "'ljust'",
   ")",
   "for",
   "x",
   "in",
   "table",
   "[",
   "0",
   "]",
   "]",
   "if",
   "header",
   ":",
   "table",
   "=",
   "[",
   "header",
   "]",
   "+",
   "table",
   "table",
   "=",
   "[",
   "[",
   "if_",
   "(",
   "isnumber",
   "(",
   "x",
   ")",
   ",",
   "lambda",
   ":",
   "numfmt",
   "%",
   "x",
   ",",
   "lambda",
   ":",
   "x",
   ")",
   "for",
   "x",
   "in",
   "row",
   "]",
   "for",
   "row",
   "in",
   "table",
   "]",
   "maxlen",
   "=",
   "lambda",
   "seq",
   ":",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "seq",
   ")",
   ")",
   "sizes",
   "=",
   "map",
   "(",
   "maxlen",
   ",",
   "zip",
   "(",
   "*",
   "[",
   "map",
   "(",
   "str",
   ",",
   "row",
   ")",
   "for",
   "row",
   "in",
   "table",
   "]",
   ")",
   ")",
   "for",
   "row",
   "in",
   "table",
   ":",
   "print",
   "sep",
   ".",
   "join",
   "(",
   "getattr",
   "(",
   "str",
   "(",
   "x",
   ")",
   ",",
   "j",
   ")",
   "(",
   "size",
   ")",
   "for",
   "(",
   "j",
   ",",
   "size",
   ",",
   "x",
   ")",
   "in",
   "zip",
   "(",
   "justs",
   ",",
   "sizes",
   ",",
   "row",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-331",
  "nl_tokens": [
   "Print",
   "column",
   "headers",
   "and",
   "rows",
   "as",
   "a",
   "reStructuredText",
   "table",
   "."
  ],
  "pl_tokens": [
   "def",
   "print_table",
   "(",
   "col_tuple",
   ",",
   "row_tuples",
   ")",
   ":",
   "col_widths",
   "=",
   "[",
   "<mask>",
   "(",
   "len",
   "(",
   "str",
   "(",
   "row",
   "[",
   "col",
   "]",
   ")",
   ")",
   "for",
   "row",
   "in",
   "[",
   "col_tuple",
   "]",
   "+",
   "row_tuples",
   ")",
   "for",
   "col",
   "in",
   "range",
   "(",
   "len",
   "(",
   "col_tuple",
   ")",
   ")",
   "]",
   "format_str",
   "=",
   "' '",
   ".",
   "join",
   "(",
   "'{{:<{}}}'",
   ".",
   "format",
   "(",
   "col_width",
   ")",
   "for",
   "col_width",
   "in",
   "col_widths",
   ")",
   "header_border",
   "=",
   "' '",
   ".",
   "join",
   "(",
   "'='",
   "*",
   "col_width",
   "for",
   "col_width",
   "in",
   "col_widths",
   ")",
   "print",
   "(",
   "header_border",
   ")",
   "print",
   "(",
   "format_str",
   ".",
   "format",
   "(",
   "*",
   "col_tuple",
   ")",
   ")",
   "print",
   "(",
   "header_border",
   ")",
   "for",
   "row_tuple",
   "in",
   "row_tuples",
   ":",
   "print",
   "(",
   "format_str",
   ".",
   "format",
   "(",
   "*",
   "row_tuple",
   ")",
   ")",
   "print",
   "(",
   "header_border",
   ")",
   "print",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-332",
  "nl_tokens": [
   "Get",
   "result",
   "for",
   "the",
   "statement",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_result",
   "(",
   "self",
   ",",
   "course_grade",
   ")",
   ":",
   "return",
   "Result",
   "(",
   "score",
   "=",
   "Score",
   "(",
   "scaled",
   "=",
   "course_grade",
   ".",
   "percent",
   ",",
   "raw",
   "=",
   "course_grade",
   ".",
   "percent",
   "*",
   "100",
   ",",
   "<mask>",
   "=",
   "MIN_SCORE",
   ",",
   "max",
   "=",
   "MAX_SCORE",
   ",",
   ")",
   ",",
   "success",
   "=",
   "course_grade",
   ".",
   "passed",
   ",",
   "completion",
   "=",
   "course_grade",
   ".",
   "passed",
   ")"
  ]
 },
 {
  "idx": "maxmin-333",
  "nl_tokens": [
   "Define",
   "delay",
   "adjustment",
   "policy"
  ],
  "pl_tokens": [
   "def",
   "_adjust_delay",
   "(",
   "self",
   ",",
   "slot",
   ",",
   "response",
   ")",
   ":",
   "if",
   "response",
   ".",
   "status",
   "in",
   "self",
   ".",
   "retry_http_codes",
   ":",
   "new_delay",
   "=",
   "<mask>",
   "(",
   "slot",
   ".",
   "delay",
   ",",
   "1",
   ")",
   "*",
   "4",
   "new_delay",
   "=",
   "max",
   "(",
   "new_delay",
   ",",
   "self",
   ".",
   "mindelay",
   ")",
   "new_delay",
   "=",
   "min",
   "(",
   "new_delay",
   ",",
   "self",
   ".",
   "maxdelay",
   ")",
   "slot",
   ".",
   "delay",
   "=",
   "new_delay",
   "self",
   ".",
   "stats",
   ".",
   "inc_value",
   "(",
   "'delay_count'",
   ")",
   "elif",
   "response",
   ".",
   "status",
   "==",
   "200",
   ":",
   "new_delay",
   "=",
   "max",
   "(",
   "slot",
   ".",
   "delay",
   "/",
   "2",
   ",",
   "self",
   ".",
   "mindelay",
   ")",
   "if",
   "new_delay",
   "<",
   "0.01",
   ":",
   "new_delay",
   "=",
   "0",
   "slot",
   ".",
   "delay",
   "=",
   "new_delay"
  ]
 },
 {
  "idx": "maxmin-334",
  "nl_tokens": [
   "Accumulate",
   "a",
   "list",
   "of",
   "values",
   "values",
   "into",
   "the",
   "frequency",
   "counts",
   "freqCounts",
   "and",
   "return",
   "the",
   "updated",
   "frequency",
   "counts"
  ],
  "pl_tokens": [
   "def",
   "_accumulateFrequencyCounts",
   "(",
   "values",
   ",",
   "freqCounts",
   "=",
   "None",
   ")",
   ":",
   "# How big does our freqCounts vector need to be?",
   "values",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "values",
   ")",
   "numEntries",
   "=",
   "values",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "1",
   "if",
   "freqCounts",
   "is",
   "not",
   "None",
   ":",
   "numEntries",
   "=",
   "max",
   "(",
   "numEntries",
   ",",
   "freqCounts",
   ".",
   "size",
   ")",
   "# Where do we accumulate the results?",
   "if",
   "freqCounts",
   "is",
   "not",
   "None",
   ":",
   "if",
   "freqCounts",
   ".",
   "size",
   "!=",
   "numEntries",
   ":",
   "newCounts",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "numEntries",
   ",",
   "dtype",
   "=",
   "'int32'",
   ")",
   "newCounts",
   "[",
   "0",
   ":",
   "freqCounts",
   ".",
   "size",
   "]",
   "=",
   "freqCounts",
   "else",
   ":",
   "newCounts",
   "=",
   "freqCounts",
   "else",
   ":",
   "newCounts",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "numEntries",
   ",",
   "dtype",
   "=",
   "'int32'",
   ")",
   "# Accumulate the new values",
   "for",
   "v",
   "in",
   "values",
   ":",
   "newCounts",
   "[",
   "v",
   "]",
   "+=",
   "1",
   "return",
   "newCounts"
  ]
 },
 {
  "idx": "maxmin-335",
  "nl_tokens": [
   "Isolate",
   "change",
   "clusters",
   "by",
   "eliminating",
   "ranges",
   "with",
   "no",
   "changes",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_grouped_opcodes",
   "(",
   "self",
   ",",
   "n",
   "=",
   "3",
   ")",
   ":",
   "codes",
   "=",
   "self",
   ".",
   "get_opcodes",
   "(",
   ")",
   "if",
   "not",
   "codes",
   ":",
   "codes",
   "=",
   "[",
   "(",
   "\"equal\"",
   ",",
   "0",
   ",",
   "1",
   ",",
   "0",
   ",",
   "1",
   ")",
   "]",
   "# Fixup leading and trailing groups if they show no changes.",
   "if",
   "codes",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'equal'",
   ":",
   "tag",
   ",",
   "i1",
   ",",
   "i2",
   ",",
   "j1",
   ",",
   "j2",
   "=",
   "codes",
   "[",
   "0",
   "]",
   "codes",
   "[",
   "0",
   "]",
   "=",
   "tag",
   ",",
   "<mask>",
   "(",
   "i1",
   ",",
   "i2",
   "-",
   "n",
   ")",
   ",",
   "i2",
   ",",
   "max",
   "(",
   "j1",
   ",",
   "j2",
   "-",
   "n",
   ")",
   ",",
   "j2",
   "if",
   "codes",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'equal'",
   ":",
   "tag",
   ",",
   "i1",
   ",",
   "i2",
   ",",
   "j1",
   ",",
   "j2",
   "=",
   "codes",
   "[",
   "-",
   "1",
   "]",
   "codes",
   "[",
   "-",
   "1",
   "]",
   "=",
   "tag",
   ",",
   "i1",
   ",",
   "min",
   "(",
   "i2",
   ",",
   "i1",
   "+",
   "n",
   ")",
   ",",
   "j1",
   ",",
   "min",
   "(",
   "j2",
   ",",
   "j1",
   "+",
   "n",
   ")",
   "nn",
   "=",
   "n",
   "+",
   "n",
   "group",
   "=",
   "[",
   "]",
   "for",
   "tag",
   ",",
   "i1",
   ",",
   "i2",
   ",",
   "j1",
   ",",
   "j2",
   "in",
   "codes",
   ":",
   "# End the current group and start a new one whenever",
   "# there is a large range with no changes.",
   "if",
   "tag",
   "==",
   "'equal'",
   "and",
   "i2",
   "-",
   "i1",
   ">",
   "nn",
   ":",
   "group",
   ".",
   "append",
   "(",
   "(",
   "tag",
   ",",
   "i1",
   ",",
   "min",
   "(",
   "i2",
   ",",
   "i1",
   "+",
   "n",
   ")",
   ",",
   "j1",
   ",",
   "min",
   "(",
   "j2",
   ",",
   "j1",
   "+",
   "n",
   ")",
   ")",
   ")",
   "yield",
   "group",
   "group",
   "=",
   "[",
   "]",
   "i1",
   ",",
   "j1",
   "=",
   "max",
   "(",
   "i1",
   ",",
   "i2",
   "-",
   "n",
   ")",
   ",",
   "max",
   "(",
   "j1",
   ",",
   "j2",
   "-",
   "n",
   ")",
   "group",
   ".",
   "append",
   "(",
   "(",
   "tag",
   ",",
   "i1",
   ",",
   "i2",
   ",",
   "j1",
   ",",
   "j2",
   ")",
   ")",
   "if",
   "group",
   "and",
   "not",
   "(",
   "len",
   "(",
   "group",
   ")",
   "==",
   "1",
   "and",
   "group",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'equal'",
   ")",
   ":",
   "yield",
   "group"
  ]
 },
 {
  "idx": "maxmin-336",
  "nl_tokens": [
   "Update",
   "gapfilling",
   "model",
   "with",
   "switches",
   "and",
   "the",
   "indicator",
   "objective",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_switches_and_objective",
   "(",
   "self",
   ")",
   ":",
   "constraints",
   "=",
   "list",
   "(",
   ")",
   "big_m",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "abs",
   "(",
   "b",
   ")",
   "for",
   "b",
   "in",
   "r",
   ".",
   "bounds",
   ")",
   "for",
   "r",
   "in",
   "self",
   ".",
   "model",
   ".",
   "reactions",
   ")",
   "prob",
   "=",
   "self",
   ".",
   "model",
   ".",
   "problem",
   "for",
   "rxn",
   "in",
   "self",
   ".",
   "model",
   ".",
   "reactions",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "rxn",
   ",",
   "'gapfilling_type'",
   ")",
   ":",
   "continue",
   "indicator",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "name",
   "=",
   "'indicator_{}'",
   ".",
   "format",
   "(",
   "rxn",
   ".",
   "id",
   ")",
   ",",
   "lb",
   "=",
   "0",
   ",",
   "ub",
   "=",
   "1",
   ",",
   "type",
   "=",
   "'binary'",
   ")",
   "if",
   "rxn",
   ".",
   "id",
   "in",
   "self",
   ".",
   "penalties",
   ":",
   "indicator",
   ".",
   "cost",
   "=",
   "self",
   ".",
   "penalties",
   "[",
   "rxn",
   ".",
   "id",
   "]",
   "else",
   ":",
   "indicator",
   ".",
   "cost",
   "=",
   "self",
   ".",
   "penalties",
   "[",
   "rxn",
   ".",
   "gapfilling_type",
   "]",
   "indicator",
   ".",
   "rxn_id",
   "=",
   "rxn",
   ".",
   "id",
   "self",
   ".",
   "indicators",
   ".",
   "append",
   "(",
   "indicator",
   ")",
   "# if z = 1 v_i is allowed non-zero",
   "# v_i - Mz <= 0   and   v_i + Mz >= 0",
   "constraint_lb",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "rxn",
   ".",
   "flux_expression",
   "-",
   "big_m",
   "*",
   "indicator",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "'constraint_lb_{}'",
   ".",
   "format",
   "(",
   "rxn",
   ".",
   "id",
   ")",
   ",",
   "sloppy",
   "=",
   "True",
   ")",
   "constraint_ub",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "rxn",
   ".",
   "flux_expression",
   "+",
   "big_m",
   "*",
   "indicator",
   ",",
   "lb",
   "=",
   "0",
   ",",
   "name",
   "=",
   "'constraint_ub_{}'",
   ".",
   "format",
   "(",
   "rxn",
   ".",
   "id",
   ")",
   ",",
   "sloppy",
   "=",
   "True",
   ")",
   "constraints",
   ".",
   "extend",
   "(",
   "[",
   "constraint_lb",
   ",",
   "constraint_ub",
   "]",
   ")",
   "self",
   ".",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "self",
   ".",
   "indicators",
   ")",
   "self",
   ".",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "constraints",
   ",",
   "sloppy",
   "=",
   "True",
   ")",
   "self",
   ".",
   "model",
   ".",
   "objective",
   "=",
   "prob",
   ".",
   "Objective",
   "(",
   "Zero",
   ",",
   "direction",
   "=",
   "'min'",
   ",",
   "sloppy",
   "=",
   "True",
   ")",
   "self",
   ".",
   "model",
   ".",
   "objective",
   ".",
   "set_linear_coefficients",
   "(",
   "{",
   "i",
   ":",
   "1",
   "for",
   "i",
   "in",
   "self",
   ".",
   "indicators",
   "}",
   ")",
   "self",
   ".",
   "update_costs",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-337",
  "nl_tokens": [
   "Create",
   "fiji",
   "-",
   "macros",
   "for",
   "stitching",
   "all",
   "channels",
   "and",
   "z",
   "-",
   "stacks",
   "for",
   "a",
   "well",
   "."
  ],
  "pl_tokens": [
   "def",
   "stitch_macro",
   "(",
   "path",
   ",",
   "output_folder",
   "=",
   "None",
   ")",
   ":",
   "output_folder",
   "=",
   "output_folder",
   "or",
   "path",
   "debug",
   "(",
   "'stitching '",
   "+",
   "path",
   "+",
   "' to '",
   "+",
   "output_folder",
   ")",
   "fields",
   "=",
   "glob",
   "(",
   "_pattern",
   "(",
   "path",
   ",",
   "_field",
   ")",
   ")",
   "# assume we have rectangle of fields",
   "xs",
   "=",
   "[",
   "attribute",
   "(",
   "field",
   ",",
   "'X'",
   ")",
   "for",
   "field",
   "in",
   "fields",
   "]",
   "ys",
   "=",
   "[",
   "attribute",
   "(",
   "field",
   ",",
   "'Y'",
   ")",
   "for",
   "field",
   "in",
   "fields",
   "]",
   "x_min",
   ",",
   "x_max",
   "=",
   "<mask>",
   "(",
   "xs",
   ")",
   ",",
   "max",
   "(",
   "xs",
   ")",
   "y_min",
   ",",
   "y_max",
   "=",
   "min",
   "(",
   "ys",
   ")",
   ",",
   "max",
   "(",
   "ys",
   ")",
   "fields_column",
   "=",
   "len",
   "(",
   "set",
   "(",
   "xs",
   ")",
   ")",
   "fields_row",
   "=",
   "len",
   "(",
   "set",
   "(",
   "ys",
   ")",
   ")",
   "# assume all fields are the same",
   "# and get properties from images in first field",
   "images",
   "=",
   "glob",
   "(",
   "_pattern",
   "(",
   "fields",
   "[",
   "0",
   "]",
   ",",
   "_image",
   ")",
   ")",
   "# assume attributes are the same on all images",
   "attr",
   "=",
   "attributes",
   "(",
   "images",
   "[",
   "0",
   "]",
   ")",
   "# find all channels and z-stacks",
   "channels",
   "=",
   "[",
   "]",
   "z_stacks",
   "=",
   "[",
   "]",
   "for",
   "image",
   "in",
   "images",
   ":",
   "channel",
   "=",
   "attribute_as_str",
   "(",
   "image",
   ",",
   "'C'",
   ")",
   "if",
   "channel",
   "not",
   "in",
   "channels",
   ":",
   "channels",
   ".",
   "append",
   "(",
   "channel",
   ")",
   "z",
   "=",
   "attribute_as_str",
   "(",
   "image",
   ",",
   "'Z'",
   ")",
   "if",
   "z",
   "not",
   "in",
   "z_stacks",
   ":",
   "z_stacks",
   ".",
   "append",
   "(",
   "z",
   ")",
   "debug",
   "(",
   "'channels '",
   "+",
   "str",
   "(",
   "channels",
   ")",
   ")",
   "debug",
   "(",
   "'z-stacks '",
   "+",
   "str",
   "(",
   "z_stacks",
   ")",
   ")",
   "# create macro",
   "_",
   ",",
   "extension",
   "=",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "images",
   "[",
   "-",
   "1",
   "]",
   ")",
   "if",
   "extension",
   "==",
   "'.tif'",
   ":",
   "# assume .ome.tif",
   "extension",
   "=",
   "'.ome.tif'",
   "macros",
   "=",
   "[",
   "]",
   "output_files",
   "=",
   "[",
   "]",
   "for",
   "Z",
   "in",
   "z_stacks",
   ":",
   "for",
   "C",
   "in",
   "channels",
   ":",
   "filenames",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "_field",
   "+",
   "'--X{xx}--Y{yy}'",
   ",",
   "_image",
   "+",
   "'--L'",
   "+",
   "attr",
   ".",
   "L",
   "+",
   "'--S'",
   "+",
   "attr",
   ".",
   "S",
   "+",
   "'--U'",
   "+",
   "attr",
   ".",
   "U",
   "+",
   "'--V'",
   "+",
   "attr",
   ".",
   "V",
   "+",
   "'--J'",
   "+",
   "attr",
   ".",
   "J",
   "+",
   "'--E'",
   "+",
   "attr",
   ".",
   "E",
   "+",
   "'--O'",
   "+",
   "attr",
   ".",
   "O",
   "+",
   "'--X{xx}--Y{yy}'",
   "+",
   "'--T'",
   "+",
   "attr",
   ".",
   "T",
   "+",
   "'--Z'",
   "+",
   "Z",
   "+",
   "'--C'",
   "+",
   "C",
   "+",
   "extension",
   ")",
   "debug",
   "(",
   "'filenames '",
   "+",
   "filenames",
   ")",
   "cur_attr",
   "=",
   "attributes",
   "(",
   "filenames",
   ")",
   ".",
   "_asdict",
   "(",
   ")",
   "f",
   "=",
   "'stitched--U{U}--V{V}--C{C}--Z{Z}.png'",
   ".",
   "format",
   "(",
   "*",
   "*",
   "cur_attr",
   ")",
   "output",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "output_folder",
   ",",
   "f",
   ")",
   "debug",
   "(",
   "'output '",
   "+",
   "output",
   ")",
   "output_files",
   ".",
   "append",
   "(",
   "output",
   ")",
   "if",
   "os",
   ".",
   "path",
   ".",
   "isfile",
   "(",
   "output",
   ")",
   ":",
   "# file already exists",
   "print",
   "(",
   "'leicaexperiment stitched file already'",
   "' exists {}'",
   ".",
   "format",
   "(",
   "output",
   ")",
   ")",
   "continue",
   "macros",
   ".",
   "append",
   "(",
   "fijibin",
   ".",
   "macro",
   ".",
   "stitch",
   "(",
   "path",
   ",",
   "filenames",
   ",",
   "fields_column",
   ",",
   "fields_row",
   ",",
   "output_filename",
   "=",
   "output",
   ",",
   "x_start",
   "=",
   "x_min",
   ",",
   "y_start",
   "=",
   "y_min",
   ")",
   ")",
   "return",
   "(",
   "output_files",
   ",",
   "macros",
   ")"
  ]
 },
 {
  "idx": "maxmin-338",
  "nl_tokens": [
   "Ks",
   "as",
   "an",
   "array",
   "and",
   "type",
   "-",
   "checked",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_Ks",
   "(",
   "self",
   ")",
   ":",
   "Ks",
   "=",
   "as_integer_type",
   "(",
   "self",
   ".",
   "Ks",
   ")",
   "if",
   "Ks",
   ".",
   "ndim",
   "!=",
   "1",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Ks should be 1-dim, got shape {}\"",
   ".",
   "format",
   "(",
   "Ks",
   ".",
   "shape",
   ")",
   ")",
   "if",
   "Ks",
   ".",
   "<mask>",
   "(",
   ")",
   "<",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Ks should be positive; got {}\"",
   ".",
   "format",
   "(",
   "Ks",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "return",
   "Ks"
  ]
 },
 {
  "idx": "maxmin-339",
  "nl_tokens": [
   "Convert",
   "weird",
   "TIF",
   "files",
   "into",
   "web",
   "-",
   "friendly",
   "versions",
   ".",
   "Auto",
   "contrast",
   "is",
   "applied",
   "(",
   "saturating",
   "lower",
   "and",
   "upper",
   "0",
   ".",
   "1%",
   ")",
   ".",
   "make",
   "saveAs",
   "True",
   "to",
   "save",
   "as",
   ".",
   "TIF",
   ".",
   "png",
   "make",
   "saveAs",
   "False",
   "and",
   "it",
   "won",
   "t",
   "save",
   "at",
   "all",
   "make",
   "saveAs",
   "someFile",
   ".",
   "jpg",
   "to",
   "save",
   "it",
   "as",
   "a",
   "different",
   "path",
   "/",
   "format"
  ],
  "pl_tokens": [
   "def",
   "convert",
   "(",
   "fname",
   ",",
   "saveAs",
   "=",
   "True",
   ",",
   "showToo",
   "=",
   "False",
   ")",
   ":",
   "# load the image",
   "#im = Image.open(fname) #PIL can't handle 12-bit TIFs well",
   "im",
   "=",
   "ndimage",
   ".",
   "imread",
   "(",
   "fname",
   ")",
   "#scipy does better with it",
   "im",
   "=",
   "np",
   ".",
   "array",
   "(",
   "im",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "# now it's a numpy array",
   "# do all image enhancement here",
   "cutoffLow",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "im",
   ",",
   ".01",
   ")",
   "cutoffHigh",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "im",
   ",",
   "99.99",
   ")",
   "im",
   "[",
   "np",
   ".",
   "where",
   "(",
   "im",
   "<",
   "cutoffLow",
   ")",
   "]",
   "=",
   "cutoffLow",
   "im",
   "[",
   "np",
   ".",
   "where",
   "(",
   "im",
   ">",
   "cutoffHigh",
   ")",
   "]",
   "=",
   "cutoffHigh",
   "# IMAGE FORMATTING",
   "im",
   "-=",
   "np",
   ".",
   "<mask>",
   "(",
   "im",
   ")",
   "#auto contrast",
   "im",
   "/=",
   "np",
   ".",
   "max",
   "(",
   "im",
   ")",
   "#normalize",
   "im",
   "*=",
   "255",
   "#stretch contrast (8-bit)",
   "im",
   "=",
   "Image",
   ".",
   "fromarray",
   "(",
   "im",
   ")",
   "# IMAGE DRAWING",
   "msg",
   "=",
   "\"%s\\n\"",
   "%",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "fname",
   ")",
   "msg",
   "+=",
   "\"%s\\n\"",
   "%",
   "cm",
   ".",
   "epochToString",
   "(",
   "os",
   ".",
   "path",
   ".",
   "getmtime",
   "(",
   "fname",
   ")",
   ")",
   "d",
   "=",
   "ImageDraw",
   ".",
   "Draw",
   "(",
   "im",
   ")",
   "fnt",
   "=",
   "ImageFont",
   ".",
   "truetype",
   "(",
   "\"arial.ttf\"",
   ",",
   "20",
   ")",
   "d",
   ".",
   "text",
   "(",
   "(",
   "6",
   ",",
   "6",
   ")",
   ",",
   "msg",
   ",",
   "font",
   "=",
   "fnt",
   ",",
   "fill",
   "=",
   "0",
   ")",
   "d",
   ".",
   "text",
   "(",
   "(",
   "4",
   ",",
   "4",
   ")",
   ",",
   "msg",
   ",",
   "font",
   "=",
   "fnt",
   ",",
   "fill",
   "=",
   "255",
   ")",
   "if",
   "showToo",
   ":",
   "im",
   ".",
   "show",
   "(",
   ")",
   "if",
   "saveAs",
   "is",
   "False",
   ":",
   "return",
   "if",
   "saveAs",
   "is",
   "True",
   ":",
   "saveAs",
   "=",
   "fname",
   "+",
   "\".png\"",
   "im",
   ".",
   "convert",
   "(",
   "'RGB'",
   ")",
   ".",
   "save",
   "(",
   "saveAs",
   ")",
   "return",
   "saveAs"
  ]
 },
 {
  "idx": "maxmin-340",
  "nl_tokens": [
   "Calculate",
   "the",
   "adc",
   "value",
   "that",
   "corresponds",
   "to",
   "a",
   "specific",
   "bin",
   "boundary",
   "diameter",
   "in",
   "microns",
   "."
  ],
  "pl_tokens": [
   "def",
   "calculate_bin_boundary",
   "(",
   "self",
   ",",
   "bb",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "enumerate",
   "(",
   "OPC_LOOKUP",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "abs",
   "(",
   "x",
   "[",
   "1",
   "]",
   "-",
   "bb",
   ")",
   ")",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-341",
  "nl_tokens": [
   "Develop",
   "a",
   "postcard",
   "region",
   "around",
   "the",
   "target",
   "star",
   ".",
   "Other",
   "stars",
   "in",
   "this",
   "postcard",
   "will",
   "be",
   "used",
   "as",
   "possible",
   "reference",
   "stars",
   ".",
   "Args",
   ":",
   "npix",
   ":",
   "The",
   "size",
   "of",
   "the",
   "postcard",
   "region",
   ".",
   "The",
   "region",
   "will",
   "be",
   "a",
   "square",
   "with",
   "sides",
   "npix",
   "pixels",
   "(",
   "default",
   ":",
   "300",
   ")",
   "shape",
   ":",
   "The",
   "size",
   "of",
   "each",
   "individual",
   "image",
   ".",
   "For",
   "Kepler",
   "/",
   "K2",
   "FFIs",
   "this",
   "should",
   "never",
   "need",
   "to",
   "be",
   "changed",
   "from",
   "the",
   "default",
   "but",
   "will",
   "be",
   "different",
   "for",
   "e",
   ".",
   "g",
   ".",
   "TESS",
   "FFIs",
   "(",
   "default",
   ":",
   "(",
   "1070",
   "1132",
   ")",
   ")",
   "buffer_size",
   ":",
   "The",
   "number",
   "of",
   "pixels",
   "at",
   "the",
   "edge",
   "of",
   "the",
   "detector",
   "to",
   "avoid",
   "(",
   "default",
   ":",
   "15",
   ")"
  ],
  "pl_tokens": [
   "def",
   "make_postcard",
   "(",
   "self",
   ",",
   "npix",
   "=",
   "300",
   ",",
   "shape",
   "=",
   "(",
   "1070",
   ",",
   "1132",
   ")",
   ",",
   "buffer_size",
   "=",
   "15",
   ")",
   ":",
   "source",
   "=",
   "self",
   ".",
   "kic",
   "client",
   "=",
   "kplr",
   ".",
   "API",
   "(",
   ")",
   "targ",
   "=",
   "client",
   ".",
   "target",
   "(",
   "source",
   ")",
   "channel",
   "=",
   "[",
   "targ",
   ".",
   "params",
   "[",
   "'Channel_0'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Channel_1'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Channel_2'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Channel_3'",
   "]",
   "]",
   "col",
   "=",
   "[",
   "targ",
   ".",
   "params",
   "[",
   "'Column_0'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Column_1'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Column_2'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Column_3'",
   "]",
   "]",
   "row",
   "=",
   "[",
   "targ",
   ".",
   "params",
   "[",
   "'Row_0'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Row_1'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Row_2'",
   "]",
   ",",
   "targ",
   ".",
   "params",
   "[",
   "'Row_3'",
   "]",
   "]",
   "if",
   "None",
   "in",
   "row",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Star not on detector all quarters!'",
   ")",
   "if",
   "None",
   "in",
   "col",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Star not on detector all quarters!'",
   ")",
   "center",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "npix",
   "/",
   "2",
   ",",
   "npix",
   "/",
   "2",
   "]",
   ")",
   "# If star close to edge, shift frame so that we have the full npix by npix",
   "# In this case, postcard will not be centered on target star",
   "if",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "col",
   ")",
   "<",
   "npix",
   "/",
   "2",
   ")",
   ":",
   "jump",
   "=",
   "npix",
   "/",
   "2",
   "-",
   "np",
   ".",
   "min",
   "(",
   "col",
   ")",
   "+",
   "buffer_size",
   "col",
   "+=",
   "jump",
   "center",
   "[",
   "1",
   "]",
   "-=",
   "jump",
   "if",
   "(",
   "np",
   ".",
   "min",
   "(",
   "row",
   ")",
   "<",
   "npix",
   "/",
   "2",
   ")",
   ":",
   "jump",
   "=",
   "npix",
   "/",
   "2",
   "-",
   "np",
   ".",
   "min",
   "(",
   "row",
   ")",
   "+",
   "buffer_size",
   "row",
   "+=",
   "jump",
   "center",
   "[",
   "0",
   "]",
   "-=",
   "jump",
   "if",
   "(",
   "np",
   ".",
   "max",
   "(",
   "row",
   ")",
   ">",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "npix",
   "/",
   "2",
   ")",
   ":",
   "jump",
   "=",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "npix",
   "/",
   "2",
   "-",
   "np",
   ".",
   "max",
   "(",
   "row",
   ")",
   "-",
   "buffer_size",
   "row",
   "+=",
   "jump",
   "center",
   "[",
   "0",
   "]",
   "-=",
   "jump",
   "if",
   "(",
   "np",
   ".",
   "max",
   "(",
   "col",
   ")",
   ">",
   "shape",
   "[",
   "1",
   "]",
   "-",
   "npix",
   "/",
   "2",
   ")",
   ":",
   "jump",
   "=",
   "shape",
   "[",
   "1",
   "]",
   "-",
   "npix",
   "/",
   "2",
   "-",
   "np",
   ".",
   "max",
   "(",
   "col",
   ")",
   "-",
   "buffer_size",
   "col",
   "+=",
   "jump",
   "center",
   "[",
   "1",
   "]",
   "-=",
   "jump",
   "fin_arr",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ",",
   "npix",
   ",",
   "npix",
   ")",
   ")",
   "for",
   "icount",
   ",",
   "iname",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "obs_filenames",
   ")",
   ":",
   "a",
   "=",
   "fits",
   ".",
   "open",
   "(",
   "self",
   ".",
   "ffi_dir",
   "+",
   "iname",
   ")",
   "quarter",
   "=",
   "a",
   "[",
   "0",
   "]",
   ".",
   "header",
   "[",
   "'quarter'",
   "]",
   "if",
   "int",
   "(",
   "quarter",
   ")",
   "==",
   "0",
   ":",
   "season",
   "=",
   "3",
   "else",
   ":",
   "season",
   "=",
   "(",
   "int",
   "(",
   "quarter",
   ")",
   "-",
   "2",
   ")",
   "%",
   "4",
   "#season_arr[icount] = season",
   "img",
   "=",
   "a",
   "[",
   "channel",
   "[",
   "season",
   "]",
   "]",
   ".",
   "data",
   "img",
   "-=",
   "np",
   ".",
   "median",
   "(",
   "img",
   ")",
   "ymin",
   "=",
   "int",
   "(",
   "max",
   "(",
   "[",
   "int",
   "(",
   "row",
   "[",
   "season",
   "]",
   ")",
   "-",
   "npix",
   "/",
   "2",
   ",",
   "0",
   "]",
   ")",
   ")",
   "ymax",
   "=",
   "int",
   "(",
   "min",
   "(",
   "[",
   "int",
   "(",
   "row",
   "[",
   "season",
   "]",
   ")",
   "+",
   "npix",
   "/",
   "2",
   ",",
   "img",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "]",
   ")",
   ")",
   "xmin",
   "=",
   "int",
   "(",
   "max",
   "(",
   "[",
   "int",
   "(",
   "col",
   "[",
   "season",
   "]",
   ")",
   "-",
   "npix",
   "/",
   "2",
   ",",
   "0",
   "]",
   ")",
   ")",
   "xmax",
   "=",
   "int",
   "(",
   "min",
   "(",
   "[",
   "int",
   "(",
   "col",
   "[",
   "season",
   "]",
   ")",
   "+",
   "npix",
   "/",
   "2",
   ",",
   "img",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   ")",
   ")",
   "pimg",
   "=",
   "img",
   "[",
   "ymin",
   ":",
   "ymax",
   ",",
   "xmin",
   ":",
   "xmax",
   "]",
   "fin_arr",
   "[",
   "icount",
   ",",
   ":",
   ",",
   ":",
   "]",
   "=",
   "pimg",
   "self",
   ".",
   "postcard",
   "=",
   "fin_arr",
   "self",
   ".",
   "integrated_postcard",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "self",
   ".",
   "postcard",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "self",
   ".",
   "center",
   "=",
   "center"
  ]
 },
 {
  "idx": "maxmin-342",
  "nl_tokens": [
   "Calculates",
   "the",
   "3D",
   "psf",
   "at",
   "a",
   "particular",
   "z",
   "pixel",
   "height"
  ],
  "pl_tokens": [
   "def",
   "psf_slice",
   "(",
   "self",
   ",",
   "zint",
   ",",
   "size",
   "=",
   "11",
   ",",
   "zoffset",
   "=",
   "0.",
   ",",
   "getextent",
   "=",
   "False",
   ")",
   ":",
   "# calculate the current pixel value in 1/k, making sure we are above the slab",
   "zint",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_p2k",
   "(",
   "self",
   ".",
   "_tz",
   "(",
   "zint",
   ")",
   ")",
   ",",
   "0",
   ")",
   "offset",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "zoffset",
   "*",
   "(",
   "zint",
   ">",
   "0",
   ")",
   ",",
   "0",
   ",",
   "0",
   "]",
   ")",
   "scale",
   "=",
   "[",
   "self",
   ".",
   "param_dict",
   "[",
   "self",
   ".",
   "zscale",
   "]",
   ",",
   "1.0",
   ",",
   "1.0",
   "]",
   "# create the coordinate vectors for where to actually calculate the",
   "tile",
   "=",
   "util",
   ".",
   "Tile",
   "(",
   "left",
   "=",
   "0",
   ",",
   "size",
   "=",
   "size",
   ",",
   "centered",
   "=",
   "True",
   ")",
   "vecs",
   "=",
   "tile",
   ".",
   "coords",
   "(",
   "form",
   "=",
   "'flat'",
   ")",
   "vecs",
   "=",
   "[",
   "self",
   ".",
   "_p2k",
   "(",
   "s",
   "*",
   "i",
   "+",
   "o",
   ")",
   "for",
   "i",
   ",",
   "s",
   ",",
   "o",
   "in",
   "zip",
   "(",
   "vecs",
   ",",
   "scale",
   ",",
   "offset",
   ")",
   "]",
   "psf",
   "=",
   "self",
   ".",
   "psffunc",
   "(",
   "*",
   "vecs",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "zint",
   "=",
   "zint",
   ",",
   "*",
   "*",
   "self",
   ".",
   "pack_args",
   "(",
   ")",
   ")",
   ".",
   "T",
   "vec",
   "=",
   "tile",
   ".",
   "coords",
   "(",
   "form",
   "=",
   "'meshed'",
   ")",
   "# create a smoothly varying point spread function by cutting off the psf",
   "# at a certain value and smoothly taking it to zero",
   "if",
   "self",
   ".",
   "cutoffval",
   "is",
   "not",
   "None",
   "and",
   "not",
   "self",
   ".",
   "cutbyval",
   ":",
   "# find the edges of the PSF",
   "edge",
   "=",
   "psf",
   ">",
   "psf",
   ".",
   "max",
   "(",
   ")",
   "*",
   "self",
   ".",
   "cutoffval",
   "dd",
   "=",
   "nd",
   ".",
   "morphology",
   ".",
   "distance_transform_edt",
   "(",
   "~",
   "edge",
   ")",
   "# calculate the new PSF and normalize it to the new support",
   "psf",
   "=",
   "psf",
   "*",
   "np",
   ".",
   "exp",
   "(",
   "-",
   "dd",
   "**",
   "4",
   ")",
   "psf",
   "/=",
   "psf",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "getextent",
   ":",
   "# the size is determined by the edge plus a 2 pad for the",
   "# exponential damping to zero at the edge",
   "size",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "(",
   "vec",
   "*",
   "edge",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "(",
   "1",
   ",",
   "2",
   ",",
   "3",
   ")",
   ")",
   "-",
   "2",
   ",",
   "(",
   "vec",
   "*",
   "edge",
   ")",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "(",
   "1",
   ",",
   "2",
   ",",
   "3",
   ")",
   ")",
   "+",
   "2",
   ",",
   "]",
   ")",
   ".",
   "T",
   "return",
   "psf",
   ",",
   "vec",
   ",",
   "size",
   "return",
   "psf",
   ",",
   "vec",
   "# perform a cut by value instead",
   "if",
   "self",
   ".",
   "cutoffval",
   "is",
   "not",
   "None",
   "and",
   "self",
   ".",
   "cutbyval",
   ":",
   "cutval",
   "=",
   "self",
   ".",
   "cutoffval",
   "*",
   "psf",
   ".",
   "max",
   "(",
   ")",
   "dd",
   "=",
   "(",
   "psf",
   "-",
   "cutval",
   ")",
   "/",
   "cutval",
   "dd",
   "[",
   "dd",
   ">",
   "0",
   "]",
   "=",
   "0.",
   "# calculate the new PSF and normalize it to the new support",
   "psf",
   "=",
   "psf",
   "*",
   "np",
   ".",
   "exp",
   "(",
   "-",
   "(",
   "dd",
   "/",
   "self",
   ".",
   "cutfallrate",
   ")",
   "**",
   "4",
   ")",
   "psf",
   "/=",
   "psf",
   ".",
   "sum",
   "(",
   ")",
   "# let the small values determine the edges",
   "edge",
   "=",
   "psf",
   ">",
   "cutval",
   "*",
   "self",
   ".",
   "cutedgeval",
   "if",
   "getextent",
   ":",
   "# the size is determined by the edge plus a 2 pad for the",
   "# exponential damping to zero at the edge",
   "size",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "(",
   "vec",
   "*",
   "edge",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "(",
   "1",
   ",",
   "2",
   ",",
   "3",
   ")",
   ")",
   "-",
   "2",
   ",",
   "(",
   "vec",
   "*",
   "edge",
   ")",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "(",
   "1",
   ",",
   "2",
   ",",
   "3",
   ")",
   ")",
   "+",
   "2",
   ",",
   "]",
   ")",
   ".",
   "T",
   "return",
   "psf",
   ",",
   "vec",
   ",",
   "size",
   "return",
   "psf",
   ",",
   "vec",
   "return",
   "psf",
   ",",
   "vec"
  ]
 },
 {
  "idx": "maxmin-343",
  "nl_tokens": [
   "Given",
   "a",
   "string",
   "key",
   "a",
   "corresponding",
   "node",
   "in",
   "the",
   "hash",
   "ring",
   "is",
   "returned",
   "along",
   "with",
   "it",
   "s",
   "position",
   "in",
   "the",
   "ring",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_node_pos",
   "(",
   "self",
   ",",
   "key",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "ring",
   ")",
   "==",
   "0",
   ":",
   "return",
   "[",
   "None",
   ",",
   "None",
   "]",
   "crc",
   "=",
   "self",
   ".",
   "hash_method",
   "(",
   "b",
   "(",
   "key",
   ")",
   ")",
   "idx",
   "=",
   "bisect",
   ".",
   "bisect",
   "(",
   "self",
   ".",
   "sorted_keys",
   ",",
   "crc",
   ")",
   "# prevents out of range index",
   "idx",
   "=",
   "<mask>",
   "(",
   "idx",
   ",",
   "(",
   "self",
   ".",
   "replicas",
   "*",
   "len",
   "(",
   "self",
   ".",
   "nodes",
   ")",
   ")",
   "-",
   "1",
   ")",
   "return",
   "[",
   "self",
   ".",
   "ring",
   "[",
   "self",
   ".",
   "sorted_keys",
   "[",
   "idx",
   "]",
   "]",
   ",",
   "idx",
   "]"
  ]
 },
 {
  "idx": "maxmin-344",
  "nl_tokens": [
   "Return",
   "the",
   "longest",
   "common",
   "subsequence",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "lcsseq",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "lengths",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "np_int",
   ")",
   "# row 0 and column 0 are initialized to 0 already",
   "for",
   "i",
   ",",
   "src_char",
   "in",
   "enumerate",
   "(",
   "src",
   ")",
   ":",
   "for",
   "j",
   ",",
   "tar_char",
   "in",
   "enumerate",
   "(",
   "tar",
   ")",
   ":",
   "if",
   "src_char",
   "==",
   "tar_char",
   ":",
   "lengths",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "+",
   "1",
   "]",
   "=",
   "lengths",
   "[",
   "i",
   ",",
   "j",
   "]",
   "+",
   "1",
   "else",
   ":",
   "lengths",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "+",
   "1",
   "]",
   "=",
   "<mask>",
   "(",
   "lengths",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "]",
   ",",
   "lengths",
   "[",
   "i",
   ",",
   "j",
   "+",
   "1",
   "]",
   ")",
   "# read the substring out from the matrix",
   "result",
   "=",
   "''",
   "i",
   ",",
   "j",
   "=",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "while",
   "i",
   "!=",
   "0",
   "and",
   "j",
   "!=",
   "0",
   ":",
   "if",
   "lengths",
   "[",
   "i",
   ",",
   "j",
   "]",
   "==",
   "lengths",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "]",
   ":",
   "i",
   "-=",
   "1",
   "elif",
   "lengths",
   "[",
   "i",
   ",",
   "j",
   "]",
   "==",
   "lengths",
   "[",
   "i",
   ",",
   "j",
   "-",
   "1",
   "]",
   ":",
   "j",
   "-=",
   "1",
   "else",
   ":",
   "result",
   "=",
   "src",
   "[",
   "i",
   "-",
   "1",
   "]",
   "+",
   "result",
   "i",
   "-=",
   "1",
   "j",
   "-=",
   "1",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-345",
  "nl_tokens": [
   "Iteratively",
   "finds",
   "the",
   "maximum",
   "value",
   "for",
   "a",
   "symbol",
   "within",
   "given",
   "constraints",
   ".",
   ":",
   "param",
   "X",
   ":",
   "a",
   "symbol",
   "or",
   "expression",
   ":",
   "param",
   "M",
   ":",
   "maximum",
   "number",
   "of",
   "iterations",
   "allowed"
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "constraints",
   ",",
   "X",
   ":",
   "BitVec",
   ",",
   "M",
   "=",
   "10000",
   ")",
   ":",
   "assert",
   "isinstance",
   "(",
   "X",
   ",",
   "BitVec",
   ")",
   "return",
   "self",
   ".",
   "optimize",
   "(",
   "constraints",
   ",",
   "X",
   ",",
   "'maximize'",
   ",",
   "M",
   ")"
  ]
 },
 {
  "idx": "maxmin-346",
  "nl_tokens": [
   "Sorts",
   "and",
   "removes",
   "overlaps"
  ],
  "pl_tokens": [
   "def",
   "condense_ranges",
   "(",
   "cls",
   ",",
   "ranges",
   ")",
   ":",
   "result",
   "=",
   "[",
   "]",
   "if",
   "ranges",
   ":",
   "ranges",
   ".",
   "sort",
   "(",
   "key",
   "=",
   "lambda",
   "tup",
   ":",
   "tup",
   "[",
   "0",
   "]",
   ")",
   "result",
   ".",
   "append",
   "(",
   "ranges",
   "[",
   "0",
   "]",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "ranges",
   ")",
   ")",
   ":",
   "if",
   "result",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   "+",
   "1",
   ">=",
   "ranges",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   ":",
   "result",
   "[",
   "-",
   "1",
   "]",
   "=",
   "(",
   "result",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   ",",
   "<mask>",
   "(",
   "result",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   ",",
   "ranges",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   ")",
   ")",
   "else",
   ":",
   "result",
   ".",
   "append",
   "(",
   "ranges",
   "[",
   "i",
   "]",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-347",
  "nl_tokens": [
   "NBASE",
   "=",
   "1000",
   "ndigits",
   "=",
   "total",
   "number",
   "of",
   "base",
   "-",
   "NBASE",
   "digits",
   "weight",
   "=",
   "base",
   "-",
   "NBASE",
   "weight",
   "of",
   "first",
   "digit",
   "sign",
   "=",
   "0x0000",
   "if",
   "positive",
   "0x4000",
   "if",
   "negative",
   "0xC000",
   "if",
   "nan",
   "dscale",
   "=",
   "decimal",
   "digits",
   "after",
   "decimal",
   "place"
  ],
  "pl_tokens": [
   "def",
   "numeric",
   "(",
   "_",
   ",",
   "n",
   ")",
   ":",
   "try",
   ":",
   "nt",
   "=",
   "n",
   ".",
   "as_tuple",
   "(",
   ")",
   "except",
   "AttributeError",
   ":",
   "raise",
   "TypeError",
   "(",
   "'numeric field requires Decimal value (got %r)'",
   "%",
   "n",
   ")",
   "digits",
   "=",
   "[",
   "]",
   "if",
   "isinstance",
   "(",
   "nt",
   ".",
   "exponent",
   ",",
   "str",
   ")",
   ":",
   "# NaN, Inf, -Inf",
   "ndigits",
   "=",
   "0",
   "weight",
   "=",
   "0",
   "sign",
   "=",
   "0xC000",
   "dscale",
   "=",
   "0",
   "else",
   ":",
   "decdigits",
   "=",
   "list",
   "(",
   "reversed",
   "(",
   "nt",
   ".",
   "digits",
   "+",
   "(",
   "nt",
   ".",
   "exponent",
   "%",
   "4",
   ")",
   "*",
   "(",
   "0",
   ",",
   ")",
   ")",
   ")",
   "weight",
   "=",
   "0",
   "while",
   "decdigits",
   ":",
   "if",
   "any",
   "(",
   "decdigits",
   "[",
   ":",
   "4",
   "]",
   ")",
   ":",
   "break",
   "weight",
   "+=",
   "1",
   "del",
   "decdigits",
   "[",
   ":",
   "4",
   "]",
   "while",
   "decdigits",
   ":",
   "digits",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "ndig",
   "(",
   "decdigits",
   "[",
   ":",
   "4",
   "]",
   ")",
   ")",
   "del",
   "decdigits",
   "[",
   ":",
   "4",
   "]",
   "ndigits",
   "=",
   "len",
   "(",
   "digits",
   ")",
   "weight",
   "+=",
   "nt",
   ".",
   "exponent",
   "//",
   "4",
   "+",
   "ndigits",
   "-",
   "1",
   "sign",
   "=",
   "nt",
   ".",
   "sign",
   "*",
   "0x4000",
   "dscale",
   "=",
   "-",
   "<mask>",
   "(",
   "0",
   ",",
   "nt",
   ".",
   "exponent",
   ")",
   "data",
   "=",
   "[",
   "ndigits",
   ",",
   "weight",
   ",",
   "sign",
   ",",
   "dscale",
   "]",
   "+",
   "digits",
   "return",
   "(",
   "'ihhHH%dH'",
   "%",
   "ndigits",
   ",",
   "[",
   "2",
   "*",
   "len",
   "(",
   "data",
   ")",
   "]",
   "+",
   "data",
   ")"
  ]
 },
 {
  "idx": "maxmin-348",
  "nl_tokens": [
   "Make",
   "phylip",
   "and",
   "nexus",
   "formats",
   ".",
   "This",
   "is",
   "hackish",
   "since",
   "I",
   "m",
   "recycling",
   "the",
   "code",
   "whole",
   "-",
   "hog",
   "from",
   "pyrad",
   "V3",
   ".",
   "Probably",
   "could",
   "be",
   "good",
   "to",
   "go",
   "back",
   "through",
   "and",
   "clean",
   "up",
   "the",
   "conversion",
   "code",
   "some",
   "time",
   "."
  ],
  "pl_tokens": [
   "def",
   "make",
   "(",
   "assembly",
   ",",
   "samples",
   ")",
   ":",
   "## get the longest name",
   "longname",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "assembly",
   ".",
   "samples",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "names",
   "=",
   "[",
   "i",
   ".",
   "name",
   "for",
   "i",
   "in",
   "samples",
   "]",
   "partitions",
   "=",
   "makephy",
   "(",
   "assembly",
   ",",
   "samples",
   ",",
   "longname",
   ")",
   "makenex",
   "(",
   "assembly",
   ",",
   "names",
   ",",
   "longname",
   ",",
   "partitions",
   ")"
  ]
 },
 {
  "idx": "maxmin-349",
  "nl_tokens": [
   "Returns",
   "the",
   "number",
   "of",
   "confirmations",
   "for",
   "given",
   ":",
   "class",
   ":",
   "Transaction",
   "<monero",
   ".",
   "transaction",
   ".",
   "Transaction",
   ">",
   "or",
   ":",
   "class",
   ":",
   "Payment",
   "<monero",
   ".",
   "transaction",
   ".",
   "Payment",
   ">",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "confirmations",
   "(",
   "self",
   ",",
   "txn_or_pmt",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "txn_or_pmt",
   ",",
   "Payment",
   ")",
   ":",
   "txn",
   "=",
   "txn_or_pmt",
   ".",
   "transaction",
   "else",
   ":",
   "txn",
   "=",
   "txn_or_pmt",
   "try",
   ":",
   "return",
   "<mask>",
   "(",
   "0",
   ",",
   "self",
   ".",
   "height",
   "(",
   ")",
   "-",
   "txn",
   ".",
   "height",
   ")",
   "except",
   "TypeError",
   ":",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-350",
  "nl_tokens": [
   "Logs",
   "an",
   "error",
   "if",
   "no",
   "Copyright",
   "message",
   "appears",
   "at",
   "the",
   "top",
   "of",
   "the",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "CheckForCopyright",
   "(",
   "filename",
   ",",
   "lines",
   ",",
   "error",
   ")",
   ":",
   "# We'll say it should occur by line 10. Don't forget there's a",
   "# dummy line at the front.",
   "for",
   "line",
   "in",
   "range",
   "(",
   "1",
   ",",
   "<mask>",
   "(",
   "len",
   "(",
   "lines",
   ")",
   ",",
   "11",
   ")",
   ")",
   ":",
   "if",
   "re",
   ".",
   "search",
   "(",
   "r'Copyright'",
   ",",
   "lines",
   "[",
   "line",
   "]",
   ",",
   "re",
   ".",
   "I",
   ")",
   ":",
   "break",
   "else",
   ":",
   "# means no copyright line was found",
   "error",
   "(",
   "filename",
   ",",
   "0",
   ",",
   "'legal/copyright'",
   ",",
   "5",
   ",",
   "'No copyright message found.  '",
   "'You should have a line: \"Copyright [year] <Copyright Owner>\"'",
   ")"
  ]
 },
 {
  "idx": "maxmin-351",
  "nl_tokens": [
   "Format",
   "x",
   "as",
   "[",
   "-",
   "]",
   "d",
   ".",
   "dddE",
   "[",
   "+",
   "-",
   "]",
   "ddd",
   "with",
   "digs",
   "digits",
   "after",
   "the",
   "point",
   "and",
   "exactly",
   "one",
   "digit",
   "before",
   ".",
   "If",
   "digs",
   "is",
   "<",
   "=",
   "0",
   "one",
   "digit",
   "is",
   "kept",
   "and",
   "the",
   "point",
   "is",
   "suppressed",
   "."
  ],
  "pl_tokens": [
   "def",
   "sci",
   "(",
   "x",
   ",",
   "digs",
   ")",
   ":",
   "if",
   "type",
   "(",
   "x",
   ")",
   "!=",
   "type",
   "(",
   "''",
   ")",
   ":",
   "x",
   "=",
   "repr",
   "(",
   "x",
   ")",
   "sign",
   ",",
   "intpart",
   ",",
   "fraction",
   ",",
   "expo",
   "=",
   "extract",
   "(",
   "x",
   ")",
   "if",
   "not",
   "intpart",
   ":",
   "while",
   "fraction",
   "and",
   "fraction",
   "[",
   "0",
   "]",
   "==",
   "'0'",
   ":",
   "fraction",
   "=",
   "fraction",
   "[",
   "1",
   ":",
   "]",
   "expo",
   "=",
   "expo",
   "-",
   "1",
   "if",
   "fraction",
   ":",
   "intpart",
   ",",
   "fraction",
   "=",
   "fraction",
   "[",
   "0",
   "]",
   ",",
   "fraction",
   "[",
   "1",
   ":",
   "]",
   "expo",
   "=",
   "expo",
   "-",
   "1",
   "else",
   ":",
   "intpart",
   "=",
   "'0'",
   "else",
   ":",
   "expo",
   "=",
   "expo",
   "+",
   "len",
   "(",
   "intpart",
   ")",
   "-",
   "1",
   "intpart",
   ",",
   "fraction",
   "=",
   "intpart",
   "[",
   "0",
   "]",
   ",",
   "intpart",
   "[",
   "1",
   ":",
   "]",
   "+",
   "fraction",
   "digs",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "digs",
   ")",
   "intpart",
   ",",
   "fraction",
   "=",
   "roundfrac",
   "(",
   "intpart",
   ",",
   "fraction",
   ",",
   "digs",
   ")",
   "if",
   "len",
   "(",
   "intpart",
   ")",
   ">",
   "1",
   ":",
   "intpart",
   ",",
   "fraction",
   ",",
   "expo",
   "=",
   "intpart",
   "[",
   "0",
   "]",
   ",",
   "intpart",
   "[",
   "1",
   ":",
   "]",
   "+",
   "fraction",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "expo",
   "+",
   "len",
   "(",
   "intpart",
   ")",
   "-",
   "1",
   "s",
   "=",
   "sign",
   "+",
   "intpart",
   "if",
   "digs",
   ">",
   "0",
   ":",
   "s",
   "=",
   "s",
   "+",
   "'.'",
   "+",
   "fraction",
   "e",
   "=",
   "repr",
   "(",
   "abs",
   "(",
   "expo",
   ")",
   ")",
   "e",
   "=",
   "'0'",
   "*",
   "(",
   "3",
   "-",
   "len",
   "(",
   "e",
   ")",
   ")",
   "+",
   "e",
   "if",
   "expo",
   "<",
   "0",
   ":",
   "e",
   "=",
   "'-'",
   "+",
   "e",
   "else",
   ":",
   "e",
   "=",
   "'+'",
   "+",
   "e",
   "return",
   "s",
   "+",
   "'e'",
   "+",
   "e"
  ]
 },
 {
  "idx": "maxmin-352",
  "nl_tokens": [
   "Updates",
   "the",
   "minimum",
   "duty",
   "cycles",
   ".",
   "The",
   "minimum",
   "duty",
   "cycles",
   "are",
   "determined",
   "locally",
   ".",
   "Each",
   "column",
   "s",
   "minimum",
   "duty",
   "cycles",
   "are",
   "set",
   "to",
   "be",
   "a",
   "percent",
   "of",
   "the",
   "maximum",
   "duty",
   "cycles",
   "in",
   "the",
   "column",
   "s",
   "neighborhood",
   ".",
   "Unlike",
   "_updateMinDutyCyclesGlobal",
   "here",
   "the",
   "values",
   "can",
   "be",
   "quite",
   "different",
   "for",
   "different",
   "columns",
   "."
  ],
  "pl_tokens": [
   "def",
   "_updateMinDutyCyclesLocal",
   "(",
   "self",
   ")",
   ":",
   "for",
   "column",
   "in",
   "xrange",
   "(",
   "self",
   ".",
   "_numColumns",
   ")",
   ":",
   "neighborhood",
   "=",
   "self",
   ".",
   "_getColumnNeighborhood",
   "(",
   "column",
   ")",
   "maxActiveDuty",
   "=",
   "self",
   ".",
   "_activeDutyCycles",
   "[",
   "neighborhood",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "maxOverlapDuty",
   "=",
   "self",
   ".",
   "_overlapDutyCycles",
   "[",
   "neighborhood",
   "]",
   ".",
   "max",
   "(",
   ")",
   "self",
   ".",
   "_minOverlapDutyCycles",
   "[",
   "column",
   "]",
   "=",
   "(",
   "maxOverlapDuty",
   "*",
   "self",
   ".",
   "_minPctOverlapDutyCycles",
   ")"
  ]
 },
 {
  "idx": "maxmin-353",
  "nl_tokens": [
   "Wait",
   "until",
   "notified",
   "or",
   "until",
   "a",
   "timeout",
   "occurs",
   "."
  ],
  "pl_tokens": [
   "def",
   "wait",
   "(",
   "self",
   ",",
   "timeout",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "_is_owned",
   "(",
   ")",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"cannot wait on un-acquired lock\"",
   ")",
   "waiter",
   "=",
   "_allocate_lock",
   "(",
   ")",
   "waiter",
   ".",
   "acquire",
   "(",
   ")",
   "self",
   ".",
   "__waiters",
   ".",
   "append",
   "(",
   "waiter",
   ")",
   "saved_state",
   "=",
   "self",
   ".",
   "_release_save",
   "(",
   ")",
   "try",
   ":",
   "# restore state no matter what (e.g., KeyboardInterrupt)",
   "if",
   "timeout",
   "is",
   "None",
   ":",
   "waiter",
   ".",
   "acquire",
   "(",
   ")",
   "if",
   "__debug__",
   ":",
   "self",
   ".",
   "_note",
   "(",
   "\"%s.wait(): got it\"",
   ",",
   "self",
   ")",
   "else",
   ":",
   "# Balancing act:  We can't afford a pure busy loop, so we",
   "# have to sleep; but if we sleep the whole timeout time,",
   "# we'll be unresponsive.  The scheme here sleeps very",
   "# little at first, longer as time goes on, but never longer",
   "# than 20 times per second (or the timeout time remaining).",
   "endtime",
   "=",
   "_time",
   "(",
   ")",
   "+",
   "timeout",
   "delay",
   "=",
   "0.0005",
   "# 500 us -> initial delay of 1 ms",
   "while",
   "True",
   ":",
   "gotit",
   "=",
   "waiter",
   ".",
   "acquire",
   "(",
   "0",
   ")",
   "if",
   "gotit",
   ":",
   "break",
   "remaining",
   "=",
   "endtime",
   "-",
   "_time",
   "(",
   ")",
   "if",
   "remaining",
   "<=",
   "0",
   ":",
   "break",
   "delay",
   "=",
   "<mask>",
   "(",
   "delay",
   "*",
   "2",
   ",",
   "remaining",
   ",",
   ".05",
   ")",
   "_sleep",
   "(",
   "delay",
   ")",
   "if",
   "not",
   "gotit",
   ":",
   "if",
   "__debug__",
   ":",
   "self",
   ".",
   "_note",
   "(",
   "\"%s.wait(%s): timed out\"",
   ",",
   "self",
   ",",
   "timeout",
   ")",
   "try",
   ":",
   "self",
   ".",
   "__waiters",
   ".",
   "remove",
   "(",
   "waiter",
   ")",
   "except",
   "ValueError",
   ":",
   "pass",
   "else",
   ":",
   "if",
   "__debug__",
   ":",
   "self",
   ".",
   "_note",
   "(",
   "\"%s.wait(%s): got it\"",
   ",",
   "self",
   ",",
   "timeout",
   ")",
   "finally",
   ":",
   "self",
   ".",
   "_acquire_restore",
   "(",
   "saved_state",
   ")"
  ]
 },
 {
  "idx": "maxmin-354",
  "nl_tokens": [
   "Return",
   "parameter",
   "names",
   "if",
   "the",
   "parameters",
   "are",
   "shareable",
   "among",
   "cells",
   "."
  ],
  "pl_tokens": [
   "def",
   "shareable_parameters",
   "(",
   "cells",
   ")",
   ":",
   "result",
   "=",
   "[",
   "]",
   "for",
   "c",
   "in",
   "cells",
   ".",
   "values",
   "(",
   ")",
   ":",
   "params",
   "=",
   "c",
   ".",
   "formula",
   ".",
   "parameters",
   "for",
   "i",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "result",
   ")",
   ",",
   "len",
   "(",
   "params",
   ")",
   ")",
   ")",
   ":",
   "if",
   "params",
   "[",
   "i",
   "]",
   "!=",
   "result",
   "[",
   "i",
   "]",
   ":",
   "return",
   "None",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "result",
   ")",
   ",",
   "len",
   "(",
   "params",
   ")",
   ")",
   ":",
   "result",
   ".",
   "append",
   "(",
   "params",
   "[",
   "i",
   "]",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-355",
  "nl_tokens": [
   "Calculate",
   "error",
   "bars",
   "from",
   "scikit",
   "-",
   "learn",
   "RandomForest",
   "estimators",
   "."
  ],
  "pl_tokens": [
   "def",
   "random_forest_error",
   "(",
   "forest",
   ",",
   "X_train",
   ",",
   "X_test",
   ",",
   "inbag",
   "=",
   "None",
   ",",
   "calibrate",
   "=",
   "True",
   ",",
   "memory_constrained",
   "=",
   "False",
   ",",
   "memory_limit",
   "=",
   "None",
   ")",
   ":",
   "if",
   "inbag",
   "is",
   "None",
   ":",
   "inbag",
   "=",
   "calc_inbag",
   "(",
   "X_train",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "forest",
   ")",
   "pred",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "tree",
   ".",
   "predict",
   "(",
   "X_test",
   ")",
   "for",
   "tree",
   "in",
   "forest",
   "]",
   ")",
   ".",
   "T",
   "pred_mean",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "pred",
   ",",
   "0",
   ")",
   "pred_centered",
   "=",
   "pred",
   "-",
   "pred_mean",
   "n_trees",
   "=",
   "forest",
   ".",
   "n_estimators",
   "V_IJ",
   "=",
   "_core_computation",
   "(",
   "X_train",
   ",",
   "X_test",
   ",",
   "inbag",
   ",",
   "pred_centered",
   ",",
   "n_trees",
   ",",
   "memory_constrained",
   ",",
   "memory_limit",
   ")",
   "V_IJ_unbiased",
   "=",
   "_bias_correction",
   "(",
   "V_IJ",
   ",",
   "inbag",
   ",",
   "pred_centered",
   ",",
   "n_trees",
   ")",
   "# Correct for cases where resampling is done without replacement:",
   "if",
   "np",
   ".",
   "<mask>",
   "(",
   "inbag",
   ")",
   "==",
   "1",
   ":",
   "variance_inflation",
   "=",
   "1",
   "/",
   "(",
   "1",
   "-",
   "np",
   ".",
   "mean",
   "(",
   "inbag",
   ")",
   ")",
   "**",
   "2",
   "V_IJ_unbiased",
   "*=",
   "variance_inflation",
   "if",
   "not",
   "calibrate",
   ":",
   "return",
   "V_IJ_unbiased",
   "if",
   "V_IJ_unbiased",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "<=",
   "20",
   ":",
   "print",
   "(",
   "\"No calibration with n_samples <= 20\"",
   ")",
   "return",
   "V_IJ_unbiased",
   "if",
   "calibrate",
   ":",
   "calibration_ratio",
   "=",
   "2",
   "n_sample",
   "=",
   "np",
   ".",
   "ceil",
   "(",
   "n_trees",
   "/",
   "calibration_ratio",
   ")",
   "new_forest",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "forest",
   ")",
   "new_forest",
   ".",
   "estimators_",
   "=",
   "np",
   ".",
   "random",
   ".",
   "permutation",
   "(",
   "new_forest",
   ".",
   "estimators_",
   ")",
   "[",
   ":",
   "int",
   "(",
   "n_sample",
   ")",
   "]",
   "new_forest",
   ".",
   "n_estimators",
   "=",
   "int",
   "(",
   "n_sample",
   ")",
   "results_ss",
   "=",
   "random_forest_error",
   "(",
   "new_forest",
   ",",
   "X_train",
   ",",
   "X_test",
   ",",
   "calibrate",
   "=",
   "False",
   ",",
   "memory_constrained",
   "=",
   "memory_constrained",
   ",",
   "memory_limit",
   "=",
   "memory_limit",
   ")",
   "# Use this second set of variance estimates",
   "# to estimate scale of Monte Carlo noise",
   "sigma2_ss",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "(",
   "results_ss",
   "-",
   "V_IJ_unbiased",
   ")",
   "**",
   "2",
   ")",
   "delta",
   "=",
   "n_sample",
   "/",
   "n_trees",
   "sigma2",
   "=",
   "(",
   "delta",
   "**",
   "2",
   "+",
   "(",
   "1",
   "-",
   "delta",
   ")",
   "**",
   "2",
   ")",
   "/",
   "(",
   "2",
   "*",
   "(",
   "1",
   "-",
   "delta",
   ")",
   "**",
   "2",
   ")",
   "*",
   "sigma2_ss",
   "# Use Monte Carlo noise scale estimate for empirical Bayes calibration",
   "V_IJ_calibrated",
   "=",
   "calibrateEB",
   "(",
   "V_IJ_unbiased",
   ",",
   "sigma2",
   ")",
   "return",
   "V_IJ_calibrated"
  ]
 },
 {
  "idx": "maxmin-356",
  "nl_tokens": [
   "Merge",
   "sorted",
   "chunk",
   "files",
   "into",
   "a",
   "sorted",
   "output",
   "file"
  ],
  "pl_tokens": [
   "def",
   "_mergeFiles",
   "(",
   "key",
   ",",
   "chunkCount",
   ",",
   "outputFile",
   ",",
   "fields",
   ")",
   ":",
   "title",
   "(",
   ")",
   "# Open all chun files",
   "files",
   "=",
   "[",
   "FileRecordStream",
   "(",
   "'chunk_%d.csv'",
   "%",
   "i",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "chunkCount",
   ")",
   "]",
   "# Open output file",
   "with",
   "FileRecordStream",
   "(",
   "outputFile",
   ",",
   "write",
   "=",
   "True",
   ",",
   "fields",
   "=",
   "fields",
   ")",
   "as",
   "o",
   ":",
   "# Open all chunk files",
   "files",
   "=",
   "[",
   "FileRecordStream",
   "(",
   "'chunk_%d.csv'",
   "%",
   "i",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "chunkCount",
   ")",
   "]",
   "records",
   "=",
   "[",
   "f",
   ".",
   "getNextRecord",
   "(",
   ")",
   "for",
   "f",
   "in",
   "files",
   "]",
   "# This loop will run until all files are exhausted",
   "while",
   "not",
   "all",
   "(",
   "r",
   "is",
   "None",
   "for",
   "r",
   "in",
   "records",
   ")",
   ":",
   "# Cleanup None values (files that were exhausted)",
   "indices",
   "=",
   "[",
   "i",
   "for",
   "i",
   ",",
   "r",
   "in",
   "enumerate",
   "(",
   "records",
   ")",
   "if",
   "r",
   "is",
   "not",
   "None",
   "]",
   "records",
   "=",
   "[",
   "records",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "indices",
   "]",
   "files",
   "=",
   "[",
   "files",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "indices",
   "]",
   "# Find the current record",
   "r",
   "=",
   "<mask>",
   "(",
   "records",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "*",
   "key",
   ")",
   ")",
   "# Write it to the file",
   "o",
   ".",
   "appendRecord",
   "(",
   "r",
   ")",
   "# Find the index of file that produced the current record",
   "index",
   "=",
   "records",
   ".",
   "index",
   "(",
   "r",
   ")",
   "# Read a new record from the file",
   "records",
   "[",
   "index",
   "]",
   "=",
   "files",
   "[",
   "index",
   "]",
   ".",
   "getNextRecord",
   "(",
   ")",
   "# Cleanup chunk files",
   "for",
   "i",
   ",",
   "f",
   "in",
   "enumerate",
   "(",
   "files",
   ")",
   ":",
   "f",
   ".",
   "close",
   "(",
   ")",
   "os",
   ".",
   "remove",
   "(",
   "'chunk_%d.csv'",
   "%",
   "i",
   ")"
  ]
 },
 {
  "idx": "maxmin-357",
  "nl_tokens": [
   "Get",
   "trip",
   "counts",
   "per",
   "day",
   "between",
   "the",
   "start",
   "and",
   "end",
   "day",
   "of",
   "the",
   "feed",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_trip_counts_per_day",
   "(",
   "self",
   ")",
   ":",
   "query",
   "=",
   "\"SELECT date, count(*) AS number_of_trips FROM day_trips GROUP BY date\"",
   "# this yields the actual data",
   "trip_counts_per_day",
   "=",
   "pd",
   ".",
   "read_sql_query",
   "(",
   "query",
   ",",
   "self",
   ".",
   "conn",
   ",",
   "index_col",
   "=",
   "\"date\"",
   ")",
   "# the rest is simply code for filling out \"gaps\" in the time span",
   "# (necessary for some visualizations)",
   "max_day",
   "=",
   "trip_counts_per_day",
   ".",
   "index",
   ".",
   "<mask>",
   "(",
   ")",
   "min_day",
   "=",
   "trip_counts_per_day",
   ".",
   "index",
   ".",
   "min",
   "(",
   ")",
   "min_date",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "strptime",
   "(",
   "min_day",
   ",",
   "'%Y-%m-%d'",
   ")",
   "max_date",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "strptime",
   "(",
   "max_day",
   ",",
   "'%Y-%m-%d'",
   ")",
   "num_days",
   "=",
   "(",
   "max_date",
   "-",
   "min_date",
   ")",
   ".",
   "days",
   "dates",
   "=",
   "[",
   "min_date",
   "+",
   "datetime",
   ".",
   "timedelta",
   "(",
   "days",
   "=",
   "x",
   ")",
   "for",
   "x",
   "in",
   "range",
   "(",
   "num_days",
   "+",
   "1",
   ")",
   "]",
   "trip_counts",
   "=",
   "[",
   "]",
   "date_strings",
   "=",
   "[",
   "]",
   "for",
   "date",
   "in",
   "dates",
   ":",
   "date_string",
   "=",
   "date",
   ".",
   "strftime",
   "(",
   "\"%Y-%m-%d\"",
   ")",
   "date_strings",
   ".",
   "append",
   "(",
   "date_string",
   ")",
   "try",
   ":",
   "value",
   "=",
   "trip_counts_per_day",
   ".",
   "loc",
   "[",
   "date_string",
   ",",
   "'number_of_trips'",
   "]",
   "except",
   "KeyError",
   ":",
   "# set value to 0 if dsut is not present, i.e. when no trips",
   "# take place on that day",
   "value",
   "=",
   "0",
   "trip_counts",
   ".",
   "append",
   "(",
   "value",
   ")",
   "# check that all date_strings are included (move this to tests?)",
   "for",
   "date_string",
   "in",
   "trip_counts_per_day",
   ".",
   "index",
   ":",
   "assert",
   "date_string",
   "in",
   "date_strings",
   "data",
   "=",
   "{",
   "\"date\"",
   ":",
   "dates",
   ",",
   "\"date_str\"",
   ":",
   "date_strings",
   ",",
   "\"trip_counts\"",
   ":",
   "trip_counts",
   "}",
   "return",
   "pd",
   ".",
   "DataFrame",
   "(",
   "data",
   ")"
  ]
 },
 {
  "idx": "maxmin-358",
  "nl_tokens": [
   "Produces",
   "a",
   "stock",
   "/",
   "out",
   "-",
   "of",
   "-",
   "the",
   "-",
   "box",
   "TidyPy",
   "configuration",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_default_config",
   "(",
   ")",
   ":",
   "config",
   "=",
   "{",
   "}",
   "for",
   "name",
   ",",
   "cls",
   "in",
   "iteritems",
   "(",
   "get_tools",
   "(",
   ")",
   ")",
   ":",
   "config",
   "[",
   "name",
   "]",
   "=",
   "cls",
   ".",
   "get_default_config",
   "(",
   ")",
   "try",
   ":",
   "workers",
   "=",
   "multiprocessing",
   ".",
   "cpu_count",
   "(",
   ")",
   "-",
   "1",
   "except",
   "NotImplementedError",
   ":",
   "# pragma: no cover",
   "workers",
   "=",
   "1",
   "workers",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "min",
   "(",
   "4",
   ",",
   "workers",
   ")",
   ")",
   "config",
   ".",
   "update",
   "(",
   "{",
   "'exclude'",
   ":",
   "[",
   "]",
   ",",
   "'merge-issues'",
   ":",
   "True",
   ",",
   "'workers'",
   ":",
   "workers",
   ",",
   "'requested_reports'",
   ":",
   "[",
   "{",
   "'type'",
   ":",
   "'console'",
   ",",
   "}",
   ",",
   "]",
   ",",
   "'disabled'",
   ":",
   "[",
   "]",
   ",",
   "'noqa'",
   ":",
   "True",
   ",",
   "'extends'",
   ":",
   "[",
   "]",
   ",",
   "'ignore-missing-extends'",
   ":",
   "False",
   ",",
   "}",
   ")",
   "return",
   "config"
  ]
 },
 {
  "idx": "maxmin-359",
  "nl_tokens": [
   "Get",
   "the",
   "height",
   "of",
   "a",
   "bounding",
   "box",
   "encapsulating",
   "the",
   "line",
   "."
  ],
  "pl_tokens": [
   "def",
   "height",
   "(",
   "self",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   "<=",
   "1",
   ":",
   "return",
   "0",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "yy",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "self",
   ".",
   "yy",
   ")"
  ]
 },
 {
  "idx": "maxmin-360",
  "nl_tokens": [
   "Return",
   "the",
   "shape",
   "that",
   "would",
   "result",
   "from",
   "broadcasting",
   "the",
   "inputs"
  ],
  "pl_tokens": [
   "def",
   "_broadcast_shape",
   "(",
   "*",
   "args",
   ")",
   ":",
   "#TODO: currently incorrect result if a Sequence is provided as an input",
   "shapes",
   "=",
   "[",
   "a",
   ".",
   "shape",
   "if",
   "hasattr",
   "(",
   "type",
   "(",
   "a",
   ")",
   ",",
   "'__array_interface__'",
   ")",
   "else",
   "(",
   ")",
   "for",
   "a",
   "in",
   "args",
   "]",
   "ndim",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "sh",
   ")",
   "for",
   "sh",
   "in",
   "shapes",
   ")",
   "# new common ndim after broadcasting",
   "for",
   "i",
   ",",
   "sh",
   "in",
   "enumerate",
   "(",
   "shapes",
   ")",
   ":",
   "if",
   "len",
   "(",
   "sh",
   ")",
   "<",
   "ndim",
   ":",
   "shapes",
   "[",
   "i",
   "]",
   "=",
   "(",
   "1",
   ",",
   ")",
   "*",
   "(",
   "ndim",
   "-",
   "len",
   "(",
   "sh",
   ")",
   ")",
   "+",
   "sh",
   "return",
   "tuple",
   "(",
   "max",
   "(",
   "sh",
   "[",
   "ax",
   "]",
   "for",
   "sh",
   "in",
   "shapes",
   ")",
   "for",
   "ax",
   "in",
   "range",
   "(",
   "ndim",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-361",
  "nl_tokens": [
   "Identify",
   "the",
   "expected",
   "flux",
   "value",
   "at",
   "the",
   "time",
   "of",
   "each",
   "observation",
   "based",
   "on",
   "the",
   "Kepler",
   "long",
   "-",
   "cadence",
   "data",
   "to",
   "ensure",
   "variations",
   "observed",
   "are",
   "not",
   "the",
   "effects",
   "of",
   "a",
   "single",
   "large",
   "starspot",
   ".",
   "Only",
   "works",
   "if",
   "the",
   "target",
   "star",
   "was",
   "targeted",
   "for",
   "long",
   "or",
   "short",
   "cadence",
   "observations",
   "during",
   "the",
   "primary",
   "mission",
   "."
  ],
  "pl_tokens": [
   "def",
   "define_spotsignal",
   "(",
   "self",
   ")",
   ":",
   "client",
   "=",
   "kplr",
   ".",
   "API",
   "(",
   ")",
   "star",
   "=",
   "client",
   ".",
   "star",
   "(",
   "self",
   ".",
   "kic",
   ")",
   "lcs",
   "=",
   "star",
   ".",
   "get_light_curves",
   "(",
   "short_cadence",
   "=",
   "False",
   ")",
   "time",
   ",",
   "flux",
   ",",
   "ferr",
   ",",
   "qual",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   ",",
   "[",
   "]",
   ",",
   "[",
   "]",
   "for",
   "lc",
   "in",
   "lcs",
   ":",
   "with",
   "lc",
   ".",
   "open",
   "(",
   ")",
   "as",
   "f",
   ":",
   "hdu_data",
   "=",
   "f",
   "[",
   "1",
   "]",
   ".",
   "data",
   "time",
   ".",
   "append",
   "(",
   "hdu_data",
   "[",
   "\"time\"",
   "]",
   ")",
   "flux",
   ".",
   "append",
   "(",
   "hdu_data",
   "[",
   "\"pdcsap_flux\"",
   "]",
   ")",
   "ferr",
   ".",
   "append",
   "(",
   "hdu_data",
   "[",
   "\"pdcsap_flux_err\"",
   "]",
   ")",
   "qual",
   ".",
   "append",
   "(",
   "hdu_data",
   "[",
   "\"sap_quality\"",
   "]",
   ")",
   "tout",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "fout",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "eout",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "flux",
   ")",
   ")",
   ":",
   "t",
   "=",
   "time",
   "[",
   "i",
   "]",
   "[",
   "qual",
   "[",
   "i",
   "]",
   "==",
   "0",
   "]",
   "f",
   "=",
   "flux",
   "[",
   "i",
   "]",
   "[",
   "qual",
   "[",
   "i",
   "]",
   "==",
   "0",
   "]",
   "e",
   "=",
   "ferr",
   "[",
   "i",
   "]",
   "[",
   "qual",
   "[",
   "i",
   "]",
   "==",
   "0",
   "]",
   "t",
   "=",
   "t",
   "[",
   "np",
   ".",
   "isfinite",
   "(",
   "f",
   ")",
   "]",
   "e",
   "=",
   "e",
   "[",
   "np",
   ".",
   "isfinite",
   "(",
   "f",
   ")",
   "]",
   "f",
   "=",
   "f",
   "[",
   "np",
   ".",
   "isfinite",
   "(",
   "f",
   ")",
   "]",
   "e",
   "/=",
   "np",
   ".",
   "median",
   "(",
   "f",
   ")",
   "f",
   "/=",
   "np",
   ".",
   "median",
   "(",
   "f",
   ")",
   "tout",
   "=",
   "np",
   ".",
   "append",
   "(",
   "tout",
   ",",
   "t",
   "[",
   "50",
   ":",
   "]",
   "+",
   "54833",
   ")",
   "fout",
   "=",
   "np",
   ".",
   "append",
   "(",
   "fout",
   ",",
   "f",
   "[",
   "50",
   ":",
   "]",
   ")",
   "eout",
   "=",
   "np",
   ".",
   "append",
   "(",
   "eout",
   ",",
   "e",
   "[",
   "50",
   ":",
   "]",
   ")",
   "self",
   ".",
   "spot_signal",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "52",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "times",
   ")",
   ")",
   ":",
   "if",
   "self",
   ".",
   "times",
   "[",
   "i",
   "]",
   "<",
   "55000",
   ":",
   "self",
   ".",
   "spot_signal",
   "[",
   "i",
   "]",
   "=",
   "1.0",
   "else",
   ":",
   "self",
   ".",
   "spot_signal",
   "[",
   "i",
   "]",
   "=",
   "fout",
   "[",
   "np",
   ".",
   "abs",
   "(",
   "self",
   ".",
   "times",
   "[",
   "i",
   "]",
   "-",
   "tout",
   ")",
   "==",
   "np",
   ".",
   "<mask>",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "self",
   ".",
   "times",
   "[",
   "i",
   "]",
   "-",
   "tout",
   ")",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-362",
  "nl_tokens": [
   "Return",
   "the",
   "Daitch",
   "-",
   "Mokotoff",
   "Soundex",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "6",
   ",",
   "zero_pad",
   "=",
   "True",
   ")",
   ":",
   "dms",
   "=",
   "[",
   "''",
   "]",
   "# initialize empty code list",
   "# Require a max_length of at least 6 and not more than 64",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "6",
   ",",
   "max_length",
   ")",
   ",",
   "64",
   ")",
   "else",
   ":",
   "max_length",
   "=",
   "64",
   "# uppercase, normalize, decompose, and filter non-A-Z",
   "word",
   "=",
   "unicode_normalize",
   "(",
   "'NFKD'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "upper",
   "(",
   ")",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "word",
   "=",
   "''",
   ".",
   "join",
   "(",
   "c",
   "for",
   "c",
   "in",
   "word",
   "if",
   "c",
   "in",
   "self",
   ".",
   "_uc_set",
   ")",
   "# Nothing to convert, return base case",
   "if",
   "not",
   "word",
   ":",
   "if",
   "zero_pad",
   ":",
   "return",
   "{",
   "'0'",
   "*",
   "max_length",
   "}",
   "return",
   "{",
   "'0'",
   "}",
   "pos",
   "=",
   "0",
   "while",
   "pos",
   "<",
   "len",
   "(",
   "word",
   ")",
   ":",
   "# Iterate through _dms_order, which specifies the possible",
   "# substrings for which codes exist in the Daitch-Mokotoff coding",
   "for",
   "sstr",
   "in",
   "self",
   ".",
   "_dms_order",
   "[",
   "word",
   "[",
   "pos",
   "]",
   "]",
   ":",
   "# pragma: no branch",
   "if",
   "word",
   "[",
   "pos",
   ":",
   "]",
   ".",
   "startswith",
   "(",
   "sstr",
   ")",
   ":",
   "# Having determined a valid substring start, retrieve the",
   "# code",
   "dm_val",
   "=",
   "self",
   ".",
   "_dms_table",
   "[",
   "sstr",
   "]",
   "# Having retried the code (triple), determine the correct",
   "# positional variant (first, pre-vocalic, elsewhere)",
   "if",
   "pos",
   "==",
   "0",
   ":",
   "dm_val",
   "=",
   "dm_val",
   "[",
   "0",
   "]",
   "elif",
   "(",
   "pos",
   "+",
   "len",
   "(",
   "sstr",
   ")",
   "<",
   "len",
   "(",
   "word",
   ")",
   "and",
   "word",
   "[",
   "pos",
   "+",
   "len",
   "(",
   "sstr",
   ")",
   "]",
   "in",
   "self",
   ".",
   "_uc_v_set",
   ")",
   ":",
   "dm_val",
   "=",
   "dm_val",
   "[",
   "1",
   "]",
   "else",
   ":",
   "dm_val",
   "=",
   "dm_val",
   "[",
   "2",
   "]",
   "# Build the code strings",
   "if",
   "isinstance",
   "(",
   "dm_val",
   ",",
   "tuple",
   ")",
   ":",
   "dms",
   "=",
   "[",
   "_",
   "+",
   "text_type",
   "(",
   "dm_val",
   "[",
   "0",
   "]",
   ")",
   "for",
   "_",
   "in",
   "dms",
   "]",
   "+",
   "[",
   "_",
   "+",
   "text_type",
   "(",
   "dm_val",
   "[",
   "1",
   "]",
   ")",
   "for",
   "_",
   "in",
   "dms",
   "]",
   "else",
   ":",
   "dms",
   "=",
   "[",
   "_",
   "+",
   "text_type",
   "(",
   "dm_val",
   ")",
   "for",
   "_",
   "in",
   "dms",
   "]",
   "pos",
   "+=",
   "len",
   "(",
   "sstr",
   ")",
   "break",
   "# Filter out double letters and _ placeholders",
   "dms",
   "=",
   "(",
   "''",
   ".",
   "join",
   "(",
   "c",
   "for",
   "c",
   "in",
   "self",
   ".",
   "_delete_consecutive_repeats",
   "(",
   "_",
   ")",
   "if",
   "c",
   "!=",
   "'_'",
   ")",
   "for",
   "_",
   "in",
   "dms",
   ")",
   "# Trim codes and return set",
   "if",
   "zero_pad",
   ":",
   "dms",
   "=",
   "(",
   "(",
   "_",
   "+",
   "(",
   "'0'",
   "*",
   "max_length",
   ")",
   ")",
   "[",
   ":",
   "max_length",
   "]",
   "for",
   "_",
   "in",
   "dms",
   ")",
   "else",
   ":",
   "dms",
   "=",
   "(",
   "_",
   "[",
   ":",
   "max_length",
   "]",
   "for",
   "_",
   "in",
   "dms",
   ")",
   "return",
   "set",
   "(",
   "dms",
   ")"
  ]
 },
 {
  "idx": "maxmin-363",
  "nl_tokens": [
   "Calculate",
   "the",
   "enthalpy",
   "of",
   "the",
   "compound",
   "phase",
   "at",
   "the",
   "specified",
   "temperature",
   "."
  ],
  "pl_tokens": [
   "def",
   "H",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "result",
   "=",
   "self",
   ".",
   "DHref",
   "for",
   "Tmax",
   "in",
   "sorted",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   ":",
   "result",
   "+=",
   "self",
   ".",
   "_Cp_records",
   "[",
   "str",
   "(",
   "Tmax",
   ")",
   "]",
   ".",
   "H",
   "(",
   "T",
   ")",
   "if",
   "T",
   "<=",
   "Tmax",
   ":",
   "return",
   "result",
   "+",
   "self",
   ".",
   "H_mag",
   "(",
   "T",
   ")",
   "# Extrapolate beyond the upper limit by using a constant heat capacity.",
   "Tmax",
   "=",
   "<mask>",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "result",
   "+=",
   "self",
   ".",
   "Cp",
   "(",
   "Tmax",
   ")",
   "*",
   "(",
   "T",
   "-",
   "Tmax",
   ")",
   "return",
   "result",
   "+",
   "self",
   ".",
   "H_mag",
   "(",
   "T",
   ")"
  ]
 },
 {
  "idx": "maxmin-364",
  "nl_tokens": [
   "Returns",
   "min",
   "(",
   "arr",
   "[",
   "start",
   "]",
   "...",
   "arr",
   "[",
   "end",
   "]",
   ")"
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "start",
   "=",
   "0",
   ",",
   "end",
   "=",
   "None",
   ")",
   ":",
   "return",
   "super",
   "(",
   "MinSegmentTree",
   ",",
   "self",
   ")",
   ".",
   "reduce",
   "(",
   "start",
   ",",
   "end",
   ")"
  ]
 },
 {
  "idx": "maxmin-365",
  "nl_tokens": [
   "Return",
   "the",
   "multiprocessing",
   ".",
   "Pool",
   "instance",
   "or",
   "create",
   "it",
   "if",
   "not",
   "done",
   "yet",
   "."
  ],
  "pl_tokens": [
   "def",
   "pool",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_pool",
   "is",
   "None",
   ":",
   "processes",
   "=",
   "self",
   ".",
   "processes",
   "if",
   "processes",
   "is",
   "not",
   "None",
   "and",
   "processes",
   "<",
   "0",
   ":",
   "try",
   ":",
   "# cpu count includes the hyperthreads, e.g. 8 for 4 cores + hyperthreading",
   "processes",
   "=",
   "multiprocessing",
   ".",
   "cpu_count",
   "(",
   ")",
   "-",
   "abs",
   "(",
   "processes",
   ")",
   "processes",
   "=",
   "<mask>",
   "(",
   "processes",
   ",",
   "1",
   ")",
   "except",
   "(",
   "ImportError",
   ",",
   "NotImplementedError",
   ")",
   ":",
   "processes",
   "=",
   "None",
   "self",
   ".",
   "_pool",
   "=",
   "multiprocessing",
   ".",
   "Pool",
   "(",
   "processes",
   ",",
   "initializer",
   "=",
   "_Pool_initialize_worker",
   ",",
   "initargs",
   "=",
   "(",
   "self",
   ".",
   "augseq",
   ",",
   "self",
   ".",
   "seed",
   ")",
   ",",
   "maxtasksperchild",
   "=",
   "self",
   ".",
   "maxtasksperchild",
   ")",
   "return",
   "self",
   ".",
   "_pool"
  ]
 },
 {
  "idx": "maxmin-366",
  "nl_tokens": [
   "Normalised",
   "data",
   "points",
   "using",
   "numpy",
   "."
  ],
  "pl_tokens": [
   "def",
   "_normalised_numpy",
   "(",
   "self",
   ")",
   ":",
   "dx",
   "=",
   "(",
   "self",
   ".",
   "screen",
   ".",
   "width",
   "/",
   "float",
   "(",
   "len",
   "(",
   "self",
   ".",
   "points",
   ")",
   ")",
   ")",
   "oy",
   "=",
   "(",
   "self",
   ".",
   "screen",
   ".",
   "height",
   ")",
   "points",
   "=",
   "np",
   ".",
   "array",
   "(",
   "self",
   ".",
   "points",
   ")",
   "-",
   "self",
   ".",
   "minimum",
   "points",
   "=",
   "points",
   "*",
   "4.0",
   "/",
   "self",
   ".",
   "extents",
   "*",
   "self",
   ".",
   "size",
   ".",
   "y",
   "for",
   "x",
   ",",
   "y",
   "in",
   "enumerate",
   "(",
   "points",
   ")",
   ":",
   "yield",
   "Point",
   "(",
   "(",
   "dx",
   "*",
   "x",
   ",",
   "<mask>",
   "(",
   "oy",
   ",",
   "oy",
   "-",
   "y",
   ")",
   ",",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-367",
  "nl_tokens": [
   "Rotates",
   "the",
   "queued",
   "texts",
   "and",
   "determines",
   "display",
   "time",
   "."
  ],
  "pl_tokens": [
   "def",
   "update",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "delay",
   ">",
   "0",
   ":",
   "# It takes a while for the popup to appear.",
   "self",
   ".",
   "delay",
   "-=",
   "1",
   "return",
   "if",
   "self",
   ".",
   "fi",
   "==",
   "0",
   ":",
   "# Only one text in queue, displayed infinitely.",
   "if",
   "len",
   "(",
   "self",
   ".",
   "q",
   ")",
   "==",
   "1",
   ":",
   "self",
   ".",
   "fn",
   "=",
   "float",
   "(",
   "\"inf\"",
   ")",
   "# Else, display time depends on text length.",
   "else",
   ":",
   "self",
   ".",
   "fn",
   "=",
   "len",
   "(",
   "self",
   ".",
   "q",
   "[",
   "self",
   ".",
   "i",
   "]",
   ")",
   "/",
   "self",
   ".",
   "speed",
   "self",
   ".",
   "fn",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "fn",
   ",",
   "self",
   ".",
   "mf",
   ")",
   "self",
   ".",
   "fi",
   "+=",
   "1",
   "if",
   "self",
   ".",
   "fi",
   ">",
   "self",
   ".",
   "fn",
   ":",
   "# Rotate to the next text in queue.",
   "self",
   ".",
   "fi",
   "=",
   "0",
   "self",
   ".",
   "i",
   "=",
   "(",
   "self",
   ".",
   "i",
   "+",
   "1",
   ")",
   "%",
   "len",
   "(",
   "self",
   ".",
   "q",
   ")"
  ]
 },
 {
  "idx": "maxmin-368",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "process",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "__ccore",
   "is",
   "True",
   ":",
   "ccore_metric",
   "=",
   "metric_wrapper",
   ".",
   "create_instance",
   "(",
   "self",
   ".",
   "__metric",
   ")",
   "self",
   ".",
   "__clusters",
   ",",
   "self",
   ".",
   "__medians",
   "=",
   "wrapper",
   ".",
   "kmedians",
   "(",
   "self",
   ".",
   "__pointer_data",
   ",",
   "self",
   ".",
   "__medians",
   ",",
   "self",
   ".",
   "__tolerance",
   ",",
   "self",
   ".",
   "__itermax",
   ",",
   "ccore_metric",
   ".",
   "get_pointer",
   "(",
   ")",
   ")",
   "else",
   ":",
   "changes",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "# Check for dimension\r",
   "if",
   "len",
   "(",
   "self",
   ".",
   "__pointer_data",
   "[",
   "0",
   "]",
   ")",
   "!=",
   "len",
   "(",
   "self",
   ".",
   "__medians",
   "[",
   "0",
   "]",
   ")",
   ":",
   "raise",
   "NameError",
   "(",
   "'Dimension of the input data and dimension of the initial medians must be equal.'",
   ")",
   "iterations",
   "=",
   "0",
   "while",
   "changes",
   ">",
   "self",
   ".",
   "__tolerance",
   "and",
   "iterations",
   "<",
   "self",
   ".",
   "__itermax",
   ":",
   "self",
   ".",
   "__clusters",
   "=",
   "self",
   ".",
   "__update_clusters",
   "(",
   ")",
   "updated_centers",
   "=",
   "self",
   ".",
   "__update_medians",
   "(",
   ")",
   "changes",
   "=",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "__metric",
   "(",
   "self",
   ".",
   "__medians",
   "[",
   "index",
   "]",
   ",",
   "updated_centers",
   "[",
   "index",
   "]",
   ")",
   "for",
   "index",
   "in",
   "range",
   "(",
   "len",
   "(",
   "updated_centers",
   ")",
   ")",
   "]",
   ")",
   "self",
   ".",
   "__medians",
   "=",
   "updated_centers",
   "iterations",
   "+=",
   "1",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-369",
  "nl_tokens": [
   "Given",
   "model",
   "params",
   "figure",
   "out",
   "the",
   "correct",
   "resolution",
   "for",
   "the",
   "RandomDistributed",
   "encoder",
   ".",
   "Modifies",
   "params",
   "in",
   "place",
   "."
  ],
  "pl_tokens": [
   "def",
   "_setRandomEncoderResolution",
   "(",
   "minResolution",
   "=",
   "0.001",
   ")",
   ":",
   "encoder",
   "=",
   "(",
   "model_params",
   ".",
   "MODEL_PARAMS",
   "[",
   "\"modelParams\"",
   "]",
   "[",
   "\"sensorParams\"",
   "]",
   "[",
   "\"encoders\"",
   "]",
   "[",
   "\"value\"",
   "]",
   ")",
   "if",
   "encoder",
   "[",
   "\"type\"",
   "]",
   "==",
   "\"RandomDistributedScalarEncoder\"",
   ":",
   "rangePadding",
   "=",
   "abs",
   "(",
   "_INPUT_MAX",
   "-",
   "_INPUT_MIN",
   ")",
   "*",
   "0.2",
   "minValue",
   "=",
   "_INPUT_MIN",
   "-",
   "rangePadding",
   "maxValue",
   "=",
   "_INPUT_MAX",
   "+",
   "rangePadding",
   "resolution",
   "=",
   "<mask>",
   "(",
   "minResolution",
   ",",
   "(",
   "maxValue",
   "-",
   "minValue",
   ")",
   "/",
   "encoder",
   ".",
   "pop",
   "(",
   "\"numBuckets\"",
   ")",
   ")",
   "encoder",
   "[",
   "\"resolution\"",
   "]",
   "=",
   "resolution"
  ]
 },
 {
  "idx": "maxmin-370",
  "nl_tokens": [
   "docstring",
   "for",
   "_randone"
  ],
  "pl_tokens": [
   "def",
   "_randone",
   "(",
   "d",
   ",",
   "limit",
   "=",
   "20",
   ",",
   "grouprefs",
   "=",
   "None",
   ")",
   ":",
   "if",
   "grouprefs",
   "is",
   "None",
   ":",
   "grouprefs",
   "=",
   "{",
   "}",
   "ret",
   "=",
   "''",
   "for",
   "i",
   "in",
   "d",
   ":",
   "if",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "IN",
   ":",
   "ret",
   "+=",
   "choice",
   "(",
   "_in",
   "(",
   "i",
   "[",
   "1",
   "]",
   ")",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "LITERAL",
   ":",
   "ret",
   "+=",
   "unichr",
   "(",
   "i",
   "[",
   "1",
   "]",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "CATEGORY",
   ":",
   "ret",
   "+=",
   "choice",
   "(",
   "CATEGORIES",
   ".",
   "get",
   "(",
   "i",
   "[",
   "1",
   "]",
   ",",
   "[",
   "''",
   "]",
   ")",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "ANY",
   ":",
   "ret",
   "+=",
   "choice",
   "(",
   "CATEGORIES",
   "[",
   "'category_any'",
   "]",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "MAX_REPEAT",
   "or",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "MIN_REPEAT",
   ":",
   "if",
   "i",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   "+",
   "1",
   "-",
   "i",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ">=",
   "limit",
   ":",
   "<mask>",
   ",",
   "max",
   "=",
   "i",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ",",
   "i",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   "+",
   "limit",
   "-",
   "1",
   "else",
   ":",
   "min",
   ",",
   "max",
   "=",
   "i",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ",",
   "i",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   "for",
   "_",
   "in",
   "range",
   "(",
   "randint",
   "(",
   "min",
   ",",
   "max",
   ")",
   ")",
   ":",
   "ret",
   "+=",
   "_randone",
   "(",
   "list",
   "(",
   "i",
   "[",
   "1",
   "]",
   "[",
   "2",
   "]",
   ")",
   ",",
   "limit",
   ",",
   "grouprefs",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "BRANCH",
   ":",
   "ret",
   "+=",
   "_randone",
   "(",
   "choice",
   "(",
   "i",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   ")",
   ",",
   "limit",
   ",",
   "grouprefs",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "SUBPATTERN",
   "or",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "ASSERT",
   ":",
   "subexpr",
   "=",
   "i",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   "if",
   "IS_PY36_OR_GREATER",
   "and",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "SUBPATTERN",
   ":",
   "subexpr",
   "=",
   "i",
   "[",
   "1",
   "]",
   "[",
   "3",
   "]",
   "subp",
   "=",
   "_randone",
   "(",
   "subexpr",
   ",",
   "limit",
   ",",
   "grouprefs",
   ")",
   "if",
   "i",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ":",
   "grouprefs",
   "[",
   "i",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   "]",
   "=",
   "subp",
   "ret",
   "+=",
   "subp",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "AT",
   ":",
   "continue",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "NOT_LITERAL",
   ":",
   "c",
   "=",
   "list",
   "(",
   "CATEGORIES",
   "[",
   "'category_any'",
   "]",
   ")",
   "if",
   "unichr",
   "(",
   "i",
   "[",
   "1",
   "]",
   ")",
   "in",
   "c",
   ":",
   "c",
   ".",
   "remove",
   "(",
   "unichr",
   "(",
   "i",
   "[",
   "1",
   "]",
   ")",
   ")",
   "ret",
   "+=",
   "choice",
   "(",
   "c",
   ")",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "GROUPREF",
   ":",
   "ret",
   "+=",
   "grouprefs",
   "[",
   "i",
   "[",
   "1",
   "]",
   "]",
   "elif",
   "i",
   "[",
   "0",
   "]",
   "==",
   "sre_parse",
   ".",
   "ASSERT_NOT",
   ":",
   "pass",
   "else",
   ":",
   "print",
   "(",
   "'[!] cannot handle expression \"%s\"'",
   "%",
   "str",
   "(",
   "i",
   ")",
   ")",
   "return",
   "ret"
  ]
 },
 {
  "idx": "maxmin-371",
  "nl_tokens": [
   "perform",
   "AP",
   "detection",
   "on",
   "current",
   "sweep",
   "."
  ],
  "pl_tokens": [
   "def",
   "detectSweep",
   "(",
   "self",
   ",",
   "sweep",
   "=",
   "0",
   ")",
   ":",
   "if",
   "self",
   ".",
   "APs",
   "is",
   "False",
   ":",
   "# indicates detection never happened",
   "self",
   ".",
   "APs",
   "=",
   "[",
   "]",
   "# now indicates detection occured",
   "# delete every AP from this sweep from the existing array",
   "for",
   "i",
   ",",
   "ap",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "APs",
   ")",
   ":",
   "if",
   "ap",
   "[",
   "\"sweep\"",
   "]",
   "==",
   "sweep",
   ":",
   "self",
   ".",
   "APs",
   "[",
   "i",
   "]",
   "=",
   "None",
   "if",
   "self",
   ".",
   "APs",
   ".",
   "count",
   "(",
   "None",
   ")",
   ":",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"deleting %d existing APs from memory\"",
   ",",
   "self",
   ".",
   "APs",
   ".",
   "count",
   "(",
   "None",
   ")",
   ")",
   "while",
   "None",
   "in",
   "self",
   ".",
   "APs",
   ":",
   "self",
   ".",
   "APs",
   ".",
   "remove",
   "(",
   "None",
   ")",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"initiating AP detection (%d already in memory)\"",
   ",",
   "len",
   "(",
   "self",
   ".",
   "APs",
   ")",
   ")",
   "self",
   ".",
   "abf",
   ".",
   "derivative",
   "=",
   "True",
   "self",
   ".",
   "abf",
   ".",
   "setsweep",
   "(",
   "sweep",
   ")",
   "# detect potential AP (Is) by a dV/dT threshold crossing",
   "Is",
   "=",
   "cm",
   ".",
   "where_cross",
   "(",
   "self",
   ".",
   "abf",
   ".",
   "sweepD",
   ",",
   "self",
   ".",
   "detect_over",
   ")",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"initial AP detection: %d APs\"",
   "%",
   "len",
   "(",
   "Is",
   ")",
   ")",
   "# eliminate APs where dV/dT doesn't cross below -10 V/S within 2 ms",
   "for",
   "i",
   ",",
   "I",
   "in",
   "enumerate",
   "(",
   "Is",
   ")",
   ":",
   "if",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "abf",
   ".",
   "sweepD",
   "[",
   "I",
   ":",
   "I",
   "+",
   "2",
   "*",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "]",
   ")",
   ">",
   "-",
   "10",
   ":",
   "Is",
   "[",
   "i",
   "]",
   "=",
   "0",
   "Is",
   "=",
   "Is",
   "[",
   "np",
   ".",
   "nonzero",
   "(",
   "Is",
   ")",
   "]",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"after lower threshold checking: %d APs\"",
   "%",
   "len",
   "(",
   "Is",
   ")",
   ")",
   "# walk 1ms backwards and find point of +10 V/S threshold crossing",
   "for",
   "i",
   ",",
   "I",
   "in",
   "enumerate",
   "(",
   "Is",
   ")",
   ":",
   "stepBack",
   "=",
   "0",
   "while",
   "(",
   "self",
   ".",
   "abf",
   ".",
   "sweepD",
   "[",
   "I",
   "-",
   "stepBack",
   "]",
   ")",
   ">",
   "10",
   "and",
   "stepBack",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "<",
   "1",
   ":",
   "#2ms max",
   "stepBack",
   "+=",
   "1",
   "Is",
   "[",
   "i",
   "]",
   "-=",
   "stepBack",
   "# analyze each AP",
   "sweepAPs",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "I",
   "in",
   "enumerate",
   "(",
   "Is",
   ")",
   ":",
   "try",
   ":",
   "timeInSweep",
   "=",
   "I",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerSec",
   "if",
   "timeInSweep",
   "<",
   "self",
   ".",
   "detect_time1",
   "or",
   "timeInSweep",
   ">",
   "self",
   ".",
   "detect_time2",
   ":",
   "continue",
   "# skip because it's not within the marks",
   "ap",
   "=",
   "{",
   "}",
   "# create the AP entry",
   "ap",
   "[",
   "\"sweep\"",
   "]",
   "=",
   "sweep",
   "# number of the sweep containing this AP",
   "ap",
   "[",
   "\"I\"",
   "]",
   "=",
   "I",
   "# index sweep point of start of AP (10 mV/ms threshold crossing)",
   "ap",
   "[",
   "\"Tsweep\"",
   "]",
   "=",
   "I",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerSec",
   "# time in the sweep of index crossing (sec)",
   "ap",
   "[",
   "\"T\"",
   "]",
   "=",
   "ap",
   "[",
   "\"Tsweep\"",
   "]",
   "+",
   "self",
   ".",
   "abf",
   ".",
   "sweepInterval",
   "*",
   "sweep",
   "# time in the experiment",
   "ap",
   "[",
   "\"Vthreshold\"",
   "]",
   "=",
   "self",
   ".",
   "abf",
   ".",
   "sweepY",
   "[",
   "I",
   "]",
   "# threshold at rate of -10mV/ms",
   "# determine how many points from the start dV/dt goes below -10 (from a 5ms chunk)",
   "chunk",
   "=",
   "self",
   ".",
   "abf",
   ".",
   "sweepD",
   "[",
   "I",
   ":",
   "I",
   "+",
   "5",
   "*",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "]",
   "# give it 5ms to cross once",
   "I_toNegTen",
   "=",
   "np",
   ".",
   "where",
   "(",
   "chunk",
   "<",
   "-",
   "10",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "chunk",
   "=",
   "self",
   ".",
   "abf",
   ".",
   "sweepD",
   "[",
   "I",
   "+",
   "I_toNegTen",
   ":",
   "I",
   "+",
   "I_toNegTen",
   "+",
   "10",
   "*",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "]",
   "# give it 30ms to cross back",
   "if",
   "not",
   "max",
   "(",
   "chunk",
   ")",
   ">",
   "-",
   "10",
   ":",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"skipping unreal AP at T=%f\"",
   "%",
   "ap",
   "[",
   "\"T\"",
   "]",
   ")",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"^^^ can you confirm this is legit?\"",
   ")",
   "continue",
   "# probably a pre-AP \"bump\" to be ignored",
   "I_recover",
   "=",
   "np",
   ".",
   "where",
   "(",
   "chunk",
   ">",
   "-",
   "10",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I_toNegTen",
   "+",
   "I",
   "# point where trace returns to above -10 V/S",
   "ap",
   "[",
   "\"dVfastIs\"",
   "]",
   "=",
   "[",
   "I",
   ",",
   "I_recover",
   "]",
   "# span of the fast component of the dV/dt trace",
   "ap",
   "[",
   "\"dVfastMS\"",
   "]",
   "=",
   "(",
   "I_recover",
   "-",
   "I",
   ")",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "# time (in ms) of this fast AP component",
   "# determine derivative min/max from a 2ms chunk which we expect to capture the fast AP",
   "chunk",
   "=",
   "self",
   ".",
   "abf",
   ".",
   "sweepD",
   "[",
   "ap",
   "[",
   "\"dVfastIs\"",
   "]",
   "[",
   "0",
   "]",
   ":",
   "ap",
   "[",
   "\"dVfastIs\"",
   "]",
   "[",
   "1",
   "]",
   "]",
   "ap",
   "[",
   "\"dVmax\"",
   "]",
   "=",
   "np",
   ".",
   "max",
   "(",
   "chunk",
   ")",
   "ap",
   "[",
   "\"dVmaxI\"",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "chunk",
   "==",
   "ap",
   "[",
   "\"dVmax\"",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "ap",
   "[",
   "\"dVmin\"",
   "]",
   "=",
   "np",
   ".",
   "min",
   "(",
   "chunk",
   ")",
   "ap",
   "[",
   "\"dVminI\"",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "chunk",
   "==",
   "ap",
   "[",
   "\"dVmin\"",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "if",
   "ap",
   "[",
   "\"dVmax\"",
   "]",
   "<",
   "10",
   "or",
   "ap",
   "[",
   "\"dVmin\"",
   "]",
   ">",
   "-",
   "10",
   ":",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"throwing out AP with low dV/dt to be an AP\"",
   ")",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"^^^ can you confirm this is legit?\"",
   ")",
   "continue",
   "# before determining AP shape stats, see where trace recovers to threshold",
   "chunkSize",
   "=",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "*",
   "10",
   "#AP shape may be 10ms",
   "if",
   "len",
   "(",
   "Is",
   ")",
   "-",
   "1",
   ">",
   "i",
   "and",
   "Is",
   "[",
   "i",
   "+",
   "1",
   "]",
   "<",
   "(",
   "I",
   "+",
   "chunkSize",
   ")",
   ":",
   "# if slow AP runs into next AP",
   "chunkSize",
   "=",
   "Is",
   "[",
   "i",
   "+",
   "1",
   "]",
   "-",
   "I",
   "# chop it down",
   "if",
   "chunkSize",
   "<",
   "(",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "*",
   "2",
   ")",
   ":",
   "continue",
   "# next AP is so soon, it's >500 Hz. Can't be real.",
   "ap",
   "[",
   "\"VslowIs\"",
   "]",
   "=",
   "[",
   "I",
   ",",
   "I",
   "+",
   "chunkSize",
   "]",
   "# time range of slow AP dynamics",
   "chunk",
   "=",
   "self",
   ".",
   "abf",
   ".",
   "sweepY",
   "[",
   "I",
   ":",
   "I",
   "+",
   "chunkSize",
   "]",
   "# determine AP peak and minimum",
   "ap",
   "[",
   "\"Vmax\"",
   "]",
   "=",
   "np",
   ".",
   "max",
   "(",
   "chunk",
   ")",
   "ap",
   "[",
   "\"VmaxI\"",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "chunk",
   "==",
   "ap",
   "[",
   "\"Vmax\"",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "chunkForMin",
   "=",
   "np",
   ".",
   "copy",
   "(",
   "chunk",
   ")",
   "# so we can destroy it",
   "chunkForMin",
   "[",
   ":",
   "ap",
   "[",
   "\"VmaxI\"",
   "]",
   "-",
   "I",
   "]",
   "=",
   "np",
   ".",
   "inf",
   "# minimum won't be before peak now",
   "ap",
   "[",
   "\"Vmin\"",
   "]",
   "=",
   "np",
   ".",
   "min",
   "(",
   "chunkForMin",
   ")",
   "# supposedly the minimum is the AHP",
   "ap",
   "[",
   "\"VminI\"",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "chunkForMin",
   "==",
   "ap",
   "[",
   "\"Vmin\"",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "if",
   "ap",
   "[",
   "\"VminI\"",
   "]",
   "<",
   "ap",
   "[",
   "\"VmaxI\"",
   "]",
   ":",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"-------------------------------\"",
   ")",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"how is the AHP before the peak?\"",
   ")",
   "#TODO: start chunk at the peak",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"-------------------------------\"",
   ")",
   "#print((I+len(chunk))-ap[\"VminI\"],len(chunk))",
   "if",
   "(",
   "len",
   "(",
   "chunk",
   ")",
   ")",
   "-",
   "(",
   "(",
   "I",
   "+",
   "len",
   "(",
   "chunk",
   ")",
   ")",
   "-",
   "ap",
   "[",
   "\"VminI\"",
   "]",
   ")",
   "<",
   "10",
   ":",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"-------------------------------\"",
   ")",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"HP too close for comfort!\"",
   ")",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"-------------------------------\"",
   ")",
   "ap",
   "[",
   "\"msRiseTime\"",
   "]",
   "=",
   "(",
   "ap",
   "[",
   "\"VmaxI\"",
   "]",
   "-",
   "I",
   ")",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "# time from threshold to peak",
   "ap",
   "[",
   "\"msFallTime\"",
   "]",
   "=",
   "(",
   "ap",
   "[",
   "\"VminI\"",
   "]",
   "-",
   "ap",
   "[",
   "\"VmaxI\"",
   "]",
   ")",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "# time from peak to nadir",
   "# determine halfwidth",
   "ap",
   "[",
   "\"Vhalf\"",
   "]",
   "=",
   "np",
   ".",
   "average",
   "(",
   "[",
   "ap",
   "[",
   "\"Vmax\"",
   "]",
   ",",
   "ap",
   "[",
   "\"Vthreshold\"",
   "]",
   "]",
   ")",
   "# half way from threshold to peak",
   "ap",
   "[",
   "\"VhalfI1\"",
   "]",
   "=",
   "cm",
   ".",
   "where_cross",
   "(",
   "chunk",
   ",",
   "ap",
   "[",
   "\"Vhalf\"",
   "]",
   ")",
   "[",
   "0",
   "]",
   "+",
   "I",
   "# time it's first crossed",
   "ap",
   "[",
   "\"VhalfI2\"",
   "]",
   "=",
   "cm",
   ".",
   "where_cross",
   "(",
   "-",
   "chunk",
   ",",
   "-",
   "ap",
   "[",
   "\"Vhalf\"",
   "]",
   ")",
   "[",
   "1",
   "]",
   "+",
   "I",
   "# time it's second crossed",
   "ap",
   "[",
   "\"msHalfwidth\"",
   "]",
   "=",
   "(",
   "ap",
   "[",
   "\"VhalfI2\"",
   "]",
   "-",
   "ap",
   "[",
   "\"VhalfI1\"",
   "]",
   ")",
   "/",
   "self",
   ".",
   "abf",
   ".",
   "pointsPerMs",
   "# time between crossings",
   "# AP error checking goes here",
   "# TODO:",
   "# if we got this far, add the AP to the list",
   "sweepAPs",
   ".",
   "extend",
   "(",
   "[",
   "ap",
   "]",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"crashed analyzing AP %d of %d\"",
   ",",
   "i",
   ",",
   "len",
   "(",
   "Is",
   ")",
   ")",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "cm",
   ".",
   "exceptionToString",
   "(",
   "e",
   ")",
   ")",
   "#cm.pause()",
   "#cm.waitFor(30)",
   "#self.log.error(\"EXCEPTION!:\\n%s\"%str(sys.exc_info()))",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"finished analyzing sweep. Found %d APs\"",
   ",",
   "len",
   "(",
   "sweepAPs",
   ")",
   ")",
   "self",
   ".",
   "APs",
   ".",
   "extend",
   "(",
   "sweepAPs",
   ")",
   "self",
   ".",
   "abf",
   ".",
   "derivative",
   "=",
   "False"
  ]
 },
 {
  "idx": "maxmin-372",
  "nl_tokens": [
   "Compute",
   "an",
   "approximate",
   "basis",
   "for",
   "the",
   "nullspace",
   "of",
   "A",
   ".",
   "The",
   "algorithm",
   "used",
   "by",
   "this",
   "function",
   "is",
   "based",
   "on",
   "the",
   "singular",
   "value",
   "decomposition",
   "of",
   "A",
   "."
  ],
  "pl_tokens": [
   "def",
   "nullspace",
   "(",
   "A",
   ",",
   "atol",
   "=",
   "1e-13",
   ",",
   "rtol",
   "=",
   "0",
   ")",
   ":",
   "A",
   "=",
   "np",
   ".",
   "atleast_2d",
   "(",
   "A",
   ")",
   "u",
   ",",
   "s",
   ",",
   "vh",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "svd",
   "(",
   "A",
   ")",
   "tol",
   "=",
   "<mask>",
   "(",
   "atol",
   ",",
   "rtol",
   "*",
   "s",
   "[",
   "0",
   "]",
   ")",
   "nnz",
   "=",
   "(",
   "s",
   ">=",
   "tol",
   ")",
   ".",
   "sum",
   "(",
   ")",
   "ns",
   "=",
   "vh",
   "[",
   "nnz",
   ":",
   "]",
   ".",
   "conj",
   "(",
   ")",
   ".",
   "T",
   "return",
   "ns"
  ]
 },
 {
  "idx": "maxmin-373",
  "nl_tokens": [
   "Parses",
   "the",
   "date",
   "from",
   "a",
   "url",
   "and",
   "uses",
   "it",
   "in",
   "the",
   "query",
   ".",
   "For",
   "objects",
   "which",
   "are",
   "unique",
   "for",
   "date",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_object",
   "(",
   "self",
   ",",
   "url",
   ",",
   "month_format",
   "=",
   "'%b'",
   ",",
   "day_format",
   "=",
   "'%d'",
   ")",
   ":",
   "params",
   "=",
   "self",
   ".",
   "get_params",
   "(",
   "url",
   ")",
   "try",
   ":",
   "year",
   "=",
   "params",
   "[",
   "self",
   ".",
   "_meta",
   ".",
   "year_part",
   "]",
   "month",
   "=",
   "params",
   "[",
   "self",
   ".",
   "_meta",
   ".",
   "month_part",
   "]",
   "day",
   "=",
   "params",
   "[",
   "self",
   ".",
   "_meta",
   ".",
   "day_part",
   "]",
   "except",
   "KeyError",
   ":",
   "try",
   ":",
   "# named lookups failed, so try to get the date using the first",
   "# three parameters",
   "year",
   ",",
   "month",
   ",",
   "day",
   "=",
   "params",
   "[",
   "'_0'",
   "]",
   ",",
   "params",
   "[",
   "'_1'",
   "]",
   ",",
   "params",
   "[",
   "'_2'",
   "]",
   "except",
   "KeyError",
   ":",
   "raise",
   "OEmbedException",
   "(",
   "'Error extracting date from url parameters'",
   ")",
   "try",
   ":",
   "tt",
   "=",
   "time",
   ".",
   "strptime",
   "(",
   "'%s-%s-%s'",
   "%",
   "(",
   "year",
   ",",
   "month",
   ",",
   "day",
   ")",
   ",",
   "'%s-%s-%s'",
   "%",
   "(",
   "'%Y'",
   ",",
   "month_format",
   ",",
   "day_format",
   ")",
   ")",
   "date",
   "=",
   "datetime",
   ".",
   "date",
   "(",
   "*",
   "tt",
   "[",
   ":",
   "3",
   "]",
   ")",
   "except",
   "ValueError",
   ":",
   "raise",
   "OEmbedException",
   "(",
   "'Error parsing date from: %s'",
   "%",
   "url",
   ")",
   "# apply the date-specific lookups",
   "if",
   "isinstance",
   "(",
   "self",
   ".",
   "_meta",
   ".",
   "model",
   ".",
   "_meta",
   ".",
   "get_field",
   "(",
   "self",
   ".",
   "_meta",
   ".",
   "date_field",
   ")",
   ",",
   "DateTimeField",
   ")",
   ":",
   "min_date",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "date",
   ",",
   "datetime",
   ".",
   "time",
   ".",
   "<mask>",
   ")",
   "max_date",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "date",
   ",",
   "datetime",
   ".",
   "time",
   ".",
   "max",
   ")",
   "query",
   "=",
   "{",
   "'%s__range'",
   "%",
   "self",
   ".",
   "_meta",
   ".",
   "date_field",
   ":",
   "(",
   "min_date",
   ",",
   "max_date",
   ")",
   "}",
   "else",
   ":",
   "query",
   "=",
   "{",
   "self",
   ".",
   "_meta",
   ".",
   "date_field",
   ":",
   "date",
   "}",
   "# apply the regular search lookups",
   "for",
   "key",
   ",",
   "value",
   "in",
   "self",
   ".",
   "_meta",
   ".",
   "fields_to_match",
   ".",
   "iteritems",
   "(",
   ")",
   ":",
   "try",
   ":",
   "query",
   "[",
   "value",
   "]",
   "=",
   "params",
   "[",
   "key",
   "]",
   "except",
   "KeyError",
   ":",
   "raise",
   "OEmbedException",
   "(",
   "'%s was not found in the urlpattern parameters.  Valid names are: %s'",
   "%",
   "(",
   "key",
   ",",
   "', '",
   ".",
   "join",
   "(",
   "params",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ")",
   ")",
   "try",
   ":",
   "obj",
   "=",
   "self",
   ".",
   "get_queryset",
   "(",
   ")",
   ".",
   "get",
   "(",
   "*",
   "*",
   "query",
   ")",
   "except",
   "self",
   ".",
   "_meta",
   ".",
   "model",
   ".",
   "DoesNotExist",
   ":",
   "raise",
   "OEmbedException",
   "(",
   "'Requested object not found'",
   ")",
   "return",
   "obj"
  ]
 },
 {
  "idx": "maxmin-374",
  "nl_tokens": [
   "Update",
   "priorities",
   "of",
   "sampled",
   "transitions",
   "."
  ],
  "pl_tokens": [
   "def",
   "update_priorities",
   "(",
   "self",
   ",",
   "idxes",
   ",",
   "priorities",
   ")",
   ":",
   "assert",
   "len",
   "(",
   "idxes",
   ")",
   "==",
   "len",
   "(",
   "priorities",
   ")",
   "for",
   "idx",
   ",",
   "priority",
   "in",
   "zip",
   "(",
   "idxes",
   ",",
   "priorities",
   ")",
   ":",
   "assert",
   "priority",
   ">",
   "0",
   "assert",
   "0",
   "<=",
   "idx",
   "<",
   "len",
   "(",
   "self",
   ".",
   "_storage",
   ")",
   "self",
   ".",
   "_it_sum",
   "[",
   "idx",
   "]",
   "=",
   "priority",
   "**",
   "self",
   ".",
   "_alpha",
   "self",
   ".",
   "_it_min",
   "[",
   "idx",
   "]",
   "=",
   "priority",
   "**",
   "self",
   ".",
   "_alpha",
   "self",
   ".",
   "_max_priority",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_max_priority",
   ",",
   "priority",
   ")"
  ]
 },
 {
  "idx": "maxmin-375",
  "nl_tokens": [
   "Takes",
   "as",
   "input",
   "a",
   "list",
   "or",
   "tuple",
   "of",
   "two",
   "elements",
   ".",
   "First",
   "the",
   "value",
   "returned",
   "by",
   "incrementing",
   "by",
   "stepsize",
   "followed",
   "by",
   "the",
   "value",
   "returned",
   "after",
   "a",
   "stepsize",
   "decrement",
   "."
  ],
  "pl_tokens": [
   "def",
   "_update_state",
   "(",
   "self",
   ",",
   "vals",
   ")",
   ":",
   "self",
   ".",
   "_steps_complete",
   "+=",
   "1",
   "if",
   "self",
   ".",
   "_steps_complete",
   "==",
   "self",
   ".",
   "max_steps",
   ":",
   "self",
   ".",
   "_termination_info",
   "=",
   "(",
   "False",
   ",",
   "self",
   ".",
   "_best_val",
   ",",
   "self",
   ".",
   "_arg",
   ")",
   "return",
   "StopIteration",
   "arg_inc",
   ",",
   "arg_dec",
   "=",
   "vals",
   "best_val",
   "=",
   "<mask>",
   "(",
   "arg_inc",
   ",",
   "arg_dec",
   ",",
   "self",
   ".",
   "_best_val",
   ")",
   "if",
   "best_val",
   "==",
   "self",
   ".",
   "_best_val",
   ":",
   "self",
   ".",
   "_termination_info",
   "=",
   "(",
   "True",
   ",",
   "best_val",
   ",",
   "self",
   ".",
   "_arg",
   ")",
   "return",
   "StopIteration",
   "self",
   ".",
   "_arg",
   "+=",
   "self",
   ".",
   "stepsize",
   "if",
   "(",
   "arg_dec",
   ">",
   "arg_inc",
   ")",
   "else",
   "-",
   "self",
   ".",
   "stepsize",
   "self",
   ".",
   "_best_val",
   "=",
   "best_val",
   "return",
   "[",
   "{",
   "self",
   ".",
   "key",
   ":",
   "self",
   ".",
   "_arg",
   "+",
   "self",
   ".",
   "stepsize",
   "}",
   ",",
   "{",
   "self",
   ".",
   "key",
   ":",
   "self",
   ".",
   "_arg",
   "-",
   "self",
   ".",
   "stepsize",
   "}",
   "]"
  ]
 },
 {
  "idx": "maxmin-376",
  "nl_tokens": [
   "Selects",
   "bytes",
   "from",
   "memory",
   ".",
   "Attempts",
   "to",
   "do",
   "so",
   "faster",
   "than",
   "via",
   "read_bytes",
   "."
  ],
  "pl_tokens": [
   "def",
   "_raw_read",
   "(",
   "self",
   ",",
   "where",
   ":",
   "int",
   ",",
   "size",
   "=",
   "1",
   ")",
   "->",
   "bytes",
   ":",
   "map",
   "=",
   "self",
   ".",
   "memory",
   ".",
   "map_containing",
   "(",
   "where",
   ")",
   "start",
   "=",
   "map",
   ".",
   "_get_offset",
   "(",
   "where",
   ")",
   "mapType",
   "=",
   "type",
   "(",
   "map",
   ")",
   "if",
   "mapType",
   "is",
   "FileMap",
   ":",
   "end",
   "=",
   "map",
   ".",
   "_get_offset",
   "(",
   "where",
   "+",
   "size",
   ")",
   "if",
   "end",
   ">",
   "map",
   ".",
   "_mapped_size",
   ":",
   "logger",
   ".",
   "warning",
   "(",
   "f\"Missing {end - map._mapped_size} bytes at the end of {map._filename}\"",
   ")",
   "raw_data",
   "=",
   "map",
   ".",
   "_data",
   "[",
   "map",
   ".",
   "_get_offset",
   "(",
   "where",
   ")",
   ":",
   "<mask>",
   "(",
   "end",
   ",",
   "map",
   ".",
   "_mapped_size",
   ")",
   "]",
   "if",
   "len",
   "(",
   "raw_data",
   ")",
   "<",
   "end",
   ":",
   "raw_data",
   "+=",
   "b'\\x00'",
   "*",
   "(",
   "end",
   "-",
   "len",
   "(",
   "raw_data",
   ")",
   ")",
   "data",
   "=",
   "b''",
   "for",
   "offset",
   "in",
   "sorted",
   "(",
   "map",
   ".",
   "_overlay",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ":",
   "data",
   "+=",
   "raw_data",
   "[",
   "len",
   "(",
   "data",
   ")",
   ":",
   "offset",
   "]",
   "data",
   "+=",
   "map",
   ".",
   "_overlay",
   "[",
   "offset",
   "]",
   "data",
   "+=",
   "raw_data",
   "[",
   "len",
   "(",
   "data",
   ")",
   ":",
   "]",
   "elif",
   "mapType",
   "is",
   "AnonMap",
   ":",
   "data",
   "=",
   "bytes",
   "(",
   "map",
   ".",
   "_data",
   "[",
   "start",
   ":",
   "start",
   "+",
   "size",
   "]",
   ")",
   "else",
   ":",
   "data",
   "=",
   "b''",
   ".",
   "join",
   "(",
   "self",
   ".",
   "memory",
   "[",
   "where",
   ":",
   "where",
   "+",
   "size",
   "]",
   ")",
   "assert",
   "len",
   "(",
   "data",
   ")",
   "==",
   "size",
   ",",
   "'Raw read resulted in wrong data read which should never happen'",
   "return",
   "data"
  ]
 },
 {
  "idx": "maxmin-377",
  "nl_tokens": [
   "Get",
   "responses",
   "on",
   "unix",
   "-",
   "like",
   "system",
   ".",
   "Use",
   "select",
   "to",
   "wait",
   "for",
   "output",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_responses_unix",
   "(",
   "self",
   ",",
   "timeout_sec",
   ")",
   ":",
   "timeout_time_sec",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "+",
   "timeout_sec",
   "responses",
   "=",
   "[",
   "]",
   "while",
   "True",
   ":",
   "select_timeout",
   "=",
   "timeout_time_sec",
   "-",
   "time",
   ".",
   "time",
   "(",
   ")",
   "# I prefer to not pass a negative value to select",
   "if",
   "select_timeout",
   "<=",
   "0",
   ":",
   "select_timeout",
   "=",
   "0",
   "events",
   ",",
   "_",
   ",",
   "_",
   "=",
   "select",
   ".",
   "select",
   "(",
   "self",
   ".",
   "read_list",
   ",",
   "[",
   "]",
   ",",
   "[",
   "]",
   ",",
   "select_timeout",
   ")",
   "responses_list",
   "=",
   "None",
   "# to avoid infinite loop if using Python 2",
   "try",
   ":",
   "for",
   "fileno",
   "in",
   "events",
   ":",
   "# new data is ready to read",
   "if",
   "fileno",
   "==",
   "self",
   ".",
   "stdout_fileno",
   ":",
   "self",
   ".",
   "gdb_process",
   ".",
   "stdout",
   ".",
   "flush",
   "(",
   ")",
   "raw_output",
   "=",
   "self",
   ".",
   "gdb_process",
   ".",
   "stdout",
   ".",
   "read",
   "(",
   ")",
   "stream",
   "=",
   "\"stdout\"",
   "elif",
   "fileno",
   "==",
   "self",
   ".",
   "stderr_fileno",
   ":",
   "self",
   ".",
   "gdb_process",
   ".",
   "stderr",
   ".",
   "flush",
   "(",
   ")",
   "raw_output",
   "=",
   "self",
   ".",
   "gdb_process",
   ".",
   "stderr",
   ".",
   "read",
   "(",
   ")",
   "stream",
   "=",
   "\"stderr\"",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Developer error. Got unexpected file number %d\"",
   "%",
   "fileno",
   ")",
   "responses_list",
   "=",
   "self",
   ".",
   "_get_responses_list",
   "(",
   "raw_output",
   ",",
   "stream",
   ")",
   "responses",
   "+=",
   "responses_list",
   "except",
   "IOError",
   ":",
   "# only occurs in python 2.7",
   "pass",
   "if",
   "timeout_sec",
   "==",
   "0",
   ":",
   "# just exit immediately",
   "break",
   "elif",
   "responses_list",
   "and",
   "self",
   ".",
   "_allow_overwrite_timeout_times",
   ":",
   "# update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb",
   "timeout_time_sec",
   "=",
   "<mask>",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "+",
   "self",
   ".",
   "time_to_check_for_additional_output_sec",
   ",",
   "timeout_time_sec",
   ",",
   ")",
   "elif",
   "time",
   ".",
   "time",
   "(",
   ")",
   ">",
   "timeout_time_sec",
   ":",
   "break",
   "return",
   "responses"
  ]
 },
 {
  "idx": "maxmin-378",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__find_optimal_kvalue",
   "(",
   "self",
   ")",
   ":",
   "optimal_elbow_value",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "__elbows",
   ")",
   "self",
   ".",
   "__kvalue",
   "=",
   "self",
   ".",
   "__elbows",
   ".",
   "index",
   "(",
   "optimal_elbow_value",
   ")",
   "+",
   "1",
   "+",
   "self",
   ".",
   "__kmin"
  ]
 },
 {
  "idx": "maxmin-379",
  "nl_tokens": [
   "Projective",
   "transform",
   "by",
   "given",
   "coordinates",
   "usually",
   "4",
   "coordinates",
   "."
  ],
  "pl_tokens": [
   "def",
   "projective_transform_by_points",
   "(",
   "x",
   ",",
   "src",
   ",",
   "dst",
   ",",
   "map_args",
   "=",
   "None",
   ",",
   "output_shape",
   "=",
   "None",
   ",",
   "order",
   "=",
   "1",
   ",",
   "mode",
   "=",
   "'constant'",
   ",",
   "cval",
   "=",
   "0.0",
   ",",
   "clip",
   "=",
   "True",
   ",",
   "preserve_range",
   "=",
   "False",
   ")",
   ":",
   "if",
   "map_args",
   "is",
   "None",
   ":",
   "map_args",
   "=",
   "{",
   "}",
   "# if type(src) is list:",
   "if",
   "isinstance",
   "(",
   "src",
   ",",
   "list",
   ")",
   ":",
   "# convert to numpy",
   "src",
   "=",
   "np",
   ".",
   "array",
   "(",
   "src",
   ")",
   "# if type(dst) is list:",
   "if",
   "isinstance",
   "(",
   "dst",
   ",",
   "list",
   ")",
   ":",
   "dst",
   "=",
   "np",
   ".",
   "array",
   "(",
   "dst",
   ")",
   "if",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   ">",
   "1",
   ":",
   "# convert to [0, 1]",
   "x",
   "=",
   "x",
   "/",
   "255",
   "m",
   "=",
   "transform",
   ".",
   "ProjectiveTransform",
   "(",
   ")",
   "m",
   ".",
   "estimate",
   "(",
   "dst",
   ",",
   "src",
   ")",
   "warped",
   "=",
   "transform",
   ".",
   "warp",
   "(",
   "x",
   ",",
   "m",
   ",",
   "map_args",
   "=",
   "map_args",
   ",",
   "output_shape",
   "=",
   "output_shape",
   ",",
   "order",
   "=",
   "order",
   ",",
   "mode",
   "=",
   "mode",
   ",",
   "cval",
   "=",
   "cval",
   ",",
   "clip",
   "=",
   "clip",
   ",",
   "preserve_range",
   "=",
   "preserve_range",
   ")",
   "return",
   "warped"
  ]
 },
 {
  "idx": "maxmin-380",
  "nl_tokens": [
   "[",
   "virtual",
   "method",
   "override",
   "]",
   "Save",
   "a",
   "checkpoint",
   "of",
   "the",
   "prediction",
   "output",
   "stream",
   ".",
   "The",
   "checkpoint",
   "comprises",
   "up",
   "to",
   "maxRows",
   "of",
   "the",
   "most",
   "recent",
   "inference",
   "records",
   "."
  ],
  "pl_tokens": [
   "def",
   "checkpoint",
   "(",
   "self",
   ",",
   "checkpointSink",
   ",",
   "maxRows",
   ")",
   ":",
   "checkpointSink",
   ".",
   "truncate",
   "(",
   ")",
   "if",
   "self",
   ".",
   "__dataset",
   "is",
   "None",
   ":",
   "if",
   "self",
   ".",
   "__checkpointCache",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "__checkpointCache",
   ".",
   "seek",
   "(",
   "0",
   ")",
   "shutil",
   ".",
   "copyfileobj",
   "(",
   "self",
   ".",
   "__checkpointCache",
   ",",
   "checkpointSink",
   ")",
   "checkpointSink",
   ".",
   "flush",
   "(",
   ")",
   "return",
   "else",
   ":",
   "# Nothing to checkpoint",
   "return",
   "self",
   ".",
   "__dataset",
   ".",
   "flush",
   "(",
   ")",
   "totalDataRows",
   "=",
   "self",
   ".",
   "__dataset",
   ".",
   "getDataRowCount",
   "(",
   ")",
   "if",
   "totalDataRows",
   "==",
   "0",
   ":",
   "# Nothing to checkpoint",
   "return",
   "# Open reader of prediction file (suppress missingValues conversion)",
   "reader",
   "=",
   "FileRecordStream",
   "(",
   "self",
   ".",
   "__datasetPath",
   ",",
   "missingValues",
   "=",
   "[",
   "]",
   ")",
   "# Create CSV writer for writing checkpoint rows",
   "writer",
   "=",
   "csv",
   ".",
   "writer",
   "(",
   "checkpointSink",
   ")",
   "# Write the header row to checkpoint sink -- just field names",
   "writer",
   ".",
   "writerow",
   "(",
   "reader",
   ".",
   "getFieldNames",
   "(",
   ")",
   ")",
   "# Determine number of rows to checkpoint",
   "numToWrite",
   "=",
   "<mask>",
   "(",
   "maxRows",
   ",",
   "totalDataRows",
   ")",
   "# Skip initial rows to get to the rows that we actually need to checkpoint",
   "numRowsToSkip",
   "=",
   "totalDataRows",
   "-",
   "numToWrite",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "numRowsToSkip",
   ")",
   ":",
   "reader",
   ".",
   "next",
   "(",
   ")",
   "# Write the data rows to checkpoint sink",
   "numWritten",
   "=",
   "0",
   "while",
   "True",
   ":",
   "row",
   "=",
   "reader",
   ".",
   "getNextRecord",
   "(",
   ")",
   "if",
   "row",
   "is",
   "None",
   ":",
   "break",
   "row",
   "=",
   "[",
   "str",
   "(",
   "element",
   ")",
   "for",
   "element",
   "in",
   "row",
   "]",
   "#print \"DEBUG: _BasicPredictionWriter: checkpointing row: %r\" % (row,)",
   "writer",
   ".",
   "writerow",
   "(",
   "row",
   ")",
   "numWritten",
   "+=",
   "1",
   "assert",
   "numWritten",
   "==",
   "numToWrite",
   ",",
   "\"numWritten (%s) != numToWrite (%s)\"",
   "%",
   "(",
   "numWritten",
   ",",
   "numToWrite",
   ")",
   "checkpointSink",
   ".",
   "flush",
   "(",
   ")",
   "return"
  ]
 },
 {
  "idx": "maxmin-381",
  "nl_tokens": [
   "Returns",
   "3",
   "masks",
   "that",
   "trisect",
   "an",
   "image",
   "into",
   "3",
   "triangular",
   "portions",
   "."
  ],
  "pl_tokens": [
   "def",
   "trisect_image",
   "(",
   "imshape",
   ",",
   "edgepts",
   "=",
   "'calc'",
   ")",
   ":",
   "im_x",
   ",",
   "im_y",
   "=",
   "np",
   ".",
   "meshgrid",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "imshape",
   "[",
   "0",
   "]",
   ")",
   ",",
   "np",
   ".",
   "arange",
   "(",
   "imshape",
   "[",
   "1",
   "]",
   ")",
   ",",
   "indexing",
   "=",
   "'ij'",
   ")",
   "if",
   "np",
   ".",
   "size",
   "(",
   "edgepts",
   ")",
   "==",
   "1",
   ":",
   "#Gets equal-area sections, at sqrt(2/3) of the sides",
   "f",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "2.",
   "/",
   "3.",
   ")",
   "if",
   "edgepts",
   "==",
   "'calc'",
   "else",
   "edgepts",
   "# f = np.sqrt(2./3.)",
   "lower_edge",
   "=",
   "(",
   "imshape",
   "[",
   "0",
   "]",
   "*",
   "(",
   "1",
   "-",
   "f",
   ")",
   ",",
   "imshape",
   "[",
   "1",
   "]",
   "*",
   "f",
   ")",
   "upper_edge",
   "=",
   "(",
   "imshape",
   "[",
   "0",
   "]",
   "*",
   "f",
   ",",
   "imshape",
   "[",
   "1",
   "]",
   "*",
   "(",
   "1",
   "-",
   "f",
   ")",
   ")",
   "else",
   ":",
   "upper_edge",
   ",",
   "lower_edge",
   "=",
   "edgepts",
   "#1. Get masks",
   "lower_slope",
   "=",
   "lower_edge",
   "[",
   "1",
   "]",
   "/",
   "<mask>",
   "(",
   "float",
   "(",
   "imshape",
   "[",
   "0",
   "]",
   "-",
   "lower_edge",
   "[",
   "0",
   "]",
   ")",
   ",",
   "1e-9",
   ")",
   "upper_slope",
   "=",
   "(",
   "imshape",
   "[",
   "1",
   "]",
   "-",
   "upper_edge",
   "[",
   "1",
   "]",
   ")",
   "/",
   "float",
   "(",
   "upper_edge",
   "[",
   "0",
   "]",
   ")",
   "#and the edge points are the x or y intercepts",
   "lower_intercept",
   "=",
   "-",
   "lower_slope",
   "*",
   "lower_edge",
   "[",
   "0",
   "]",
   "upper_intercept",
   "=",
   "upper_edge",
   "[",
   "1",
   "]",
   "lower_mask",
   "=",
   "im_y",
   "<",
   "(",
   "im_x",
   "*",
   "lower_slope",
   "+",
   "lower_intercept",
   ")",
   "upper_mask",
   "=",
   "im_y",
   ">",
   "(",
   "im_x",
   "*",
   "upper_slope",
   "+",
   "upper_intercept",
   ")",
   "center_mask",
   "=",
   "-",
   "(",
   "lower_mask",
   "|",
   "upper_mask",
   ")",
   "return",
   "upper_mask",
   ",",
   "center_mask",
   ",",
   "lower_mask"
  ]
 },
 {
  "idx": "maxmin-382",
  "nl_tokens": [
   "groups",
   "together",
   "several",
   "numba",
   "compiled",
   "funcs"
  ],
  "pl_tokens": [
   "def",
   "calculate",
   "(",
   "seqnon",
   ",",
   "mapcol",
   ",",
   "nmask",
   ",",
   "tests",
   ")",
   ":",
   "## create empty matrices",
   "#LOGGER.info(\"tests[0] %s\", tests[0])",
   "#LOGGER.info('seqnon[[tests[0]]] %s', seqnon[[tests[0]]])",
   "mats",
   "=",
   "chunk_to_matrices",
   "(",
   "seqnon",
   ",",
   "mapcol",
   ",",
   "nmask",
   ")",
   "## empty svdscores for each arrangement of seqchunk",
   "svds",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "3",
   ",",
   "16",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   "qscores",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "3",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   "ranks",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "3",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   "for",
   "test",
   "in",
   "range",
   "(",
   "3",
   ")",
   ":",
   "## get svd scores",
   "svds",
   "[",
   "test",
   "]",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "svd",
   "(",
   "mats",
   "[",
   "test",
   "]",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float64",
   ")",
   ")",
   "[",
   "1",
   "]",
   "ranks",
   "[",
   "test",
   "]",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "matrix_rank",
   "(",
   "mats",
   "[",
   "test",
   "]",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float64",
   ")",
   ")",
   "## get minrank, or 11",
   "minrank",
   "=",
   "int",
   "(",
   "<mask>",
   "(",
   "11",
   ",",
   "ranks",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "for",
   "test",
   "in",
   "range",
   "(",
   "3",
   ")",
   ":",
   "qscores",
   "[",
   "test",
   "]",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "sum",
   "(",
   "svds",
   "[",
   "test",
   ",",
   "minrank",
   ":",
   "]",
   "**",
   "2",
   ")",
   ")",
   "## sort to find the best qorder",
   "best",
   "=",
   "np",
   ".",
   "where",
   "(",
   "qscores",
   "==",
   "qscores",
   ".",
   "min",
   "(",
   ")",
   ")",
   "[",
   "0",
   "]",
   "#best = qscores[qscores == qscores.min()][0]",
   "bidx",
   "=",
   "tests",
   "[",
   "best",
   "]",
   "[",
   "0",
   "]",
   "qsnps",
   "=",
   "count_snps",
   "(",
   "mats",
   "[",
   "best",
   "]",
   "[",
   "0",
   "]",
   ")",
   "return",
   "bidx",
   ",",
   "qsnps"
  ]
 },
 {
  "idx": "maxmin-383",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "calculate",
   "molar",
   "volume",
   "of",
   "the",
   "liquid",
   "phase",
   "along",
   "the",
   "saturation",
   "line",
   ".",
   "Parameters",
   "----------",
   "T",
   ":",
   "float",
   "Temperature",
   "[",
   "K",
   "]"
  ],
  "pl_tokens": [
   "def",
   "V_l_sat",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "Psat",
   "=",
   "self",
   ".",
   "Psat",
   "(",
   "T",
   ")",
   "a_alpha",
   "=",
   "self",
   ".",
   "a_alpha_and_derivatives",
   "(",
   "T",
   ",",
   "full",
   "=",
   "False",
   ")",
   "Vs",
   "=",
   "self",
   ".",
   "volume_solutions",
   "(",
   "T",
   ",",
   "Psat",
   ",",
   "self",
   ".",
   "b",
   ",",
   "self",
   ".",
   "delta",
   ",",
   "self",
   ".",
   "epsilon",
   ",",
   "a_alpha",
   ")",
   "# Assume we can safely take the Vmax as gas, Vmin as l on the saturation line",
   "return",
   "<mask>",
   "(",
   "[",
   "i",
   ".",
   "real",
   "for",
   "i",
   "in",
   "Vs",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-384",
  "nl_tokens": [
   "Identify",
   "the",
   "kind",
   "of",
   "release",
   "by",
   "comparing",
   "to",
   "existing",
   "ones",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_bump",
   "(",
   "target",
   ",",
   "tag",
   ")",
   ":",
   "tmp",
   "=",
   "tag",
   ".",
   "split",
   "(",
   "\".\"",
   ")",
   "existing",
   "=",
   "[",
   "intify",
   "(",
   "basename",
   "(",
   "f",
   ")",
   ")",
   "for",
   "f",
   "in",
   "glob",
   "(",
   "join",
   "(",
   "target",
   ",",
   "\"[0-9]*.md\"",
   ")",
   ")",
   "]",
   "latest",
   "=",
   "<mask>",
   "(",
   "existing",
   ")",
   "if",
   "int",
   "(",
   "tmp",
   "[",
   "0",
   "]",
   ")",
   ">",
   "latest",
   "[",
   "0",
   "]",
   ":",
   "return",
   "\"major\"",
   "elif",
   "int",
   "(",
   "tmp",
   "[",
   "1",
   "]",
   ")",
   ">",
   "latest",
   "[",
   "1",
   "]",
   ":",
   "return",
   "\"minor\"",
   "else",
   ":",
   "return",
   "\"patch\""
  ]
 },
 {
  "idx": "maxmin-385",
  "nl_tokens": [
   "Inserts",
   "all",
   "given",
   "nifti",
   "files",
   "from",
   "file_list",
   "into",
   "one",
   "dataset",
   "in",
   "fname",
   ".",
   "This",
   "will",
   "not",
   "check",
   "if",
   "the",
   "dimensionality",
   "of",
   "all",
   "files",
   "match",
   "."
  ],
  "pl_tokens": [
   "def",
   "insert_volumes_in_one_dataset",
   "(",
   "file_path",
   ",",
   "h5path",
   ",",
   "file_list",
   ",",
   "newshape",
   "=",
   "None",
   ",",
   "concat_axis",
   "=",
   "0",
   ",",
   "dtype",
   "=",
   "None",
   ",",
   "append",
   "=",
   "True",
   ")",
   ":",
   "def",
   "isalambda",
   "(",
   "v",
   ")",
   ":",
   "return",
   "isinstance",
   "(",
   "v",
   ",",
   "type",
   "(",
   "lambda",
   ":",
   "None",
   ")",
   ")",
   "and",
   "v",
   ".",
   "__name__",
   "==",
   "'<lambda>'",
   "mode",
   "=",
   "'w'",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "file_path",
   ")",
   ":",
   "if",
   "append",
   ":",
   "mode",
   "=",
   "'a'",
   "#loading the metadata into spatialimages",
   "imgs",
   "=",
   "[",
   "nib",
   ".",
   "load",
   "(",
   "vol",
   ")",
   "for",
   "vol",
   "in",
   "file_list",
   "]",
   "#getting the shapes of all volumes",
   "shapes",
   "=",
   "[",
   "np",
   ".",
   "array",
   "(",
   "img",
   ".",
   "get_shape",
   "(",
   ")",
   ")",
   "for",
   "img",
   "in",
   "imgs",
   "]",
   "#getting the reshaped shapes",
   "if",
   "newshape",
   "is",
   "not",
   "None",
   ":",
   "if",
   "isalambda",
   "(",
   "newshape",
   ")",
   ":",
   "nushapes",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "newshape",
   "(",
   "shape",
   ")",
   "for",
   "shape",
   "in",
   "shapes",
   "]",
   ")",
   "else",
   ":",
   "nushapes",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "shape",
   "for",
   "shape",
   "in",
   "shapes",
   "]",
   ")",
   "#checking if concat_axis is available in this new shapes",
   "for",
   "nushape",
   "in",
   "nushapes",
   ":",
   "assert",
   "(",
   "len",
   "(",
   "nushape",
   ")",
   "-",
   "1",
   "<",
   "concat_axis",
   ")",
   "#calculate the shape of the new dataset",
   "n_dims",
   "=",
   "nushapes",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "ds_shape",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "n_dims",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int",
   ")",
   "for",
   "a",
   "in",
   "list",
   "(",
   "range",
   "(",
   "n_dims",
   ")",
   ")",
   ":",
   "if",
   "a",
   "==",
   "concat_axis",
   ":",
   "ds_shape",
   "[",
   "a",
   "]",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "nushapes",
   "[",
   ":",
   ",",
   "concat_axis",
   "]",
   ")",
   "else",
   ":",
   "ds_shape",
   "[",
   "a",
   "]",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "nushapes",
   "[",
   ":",
   ",",
   "a",
   "]",
   ")",
   "#get the type of the new dataset",
   "#dtypes = [img.get_data_dtype() for img in imgs]",
   "if",
   "dtype",
   "is",
   "None",
   ":",
   "dtype",
   "=",
   "imgs",
   "[",
   "0",
   "]",
   ".",
   "get_data_dtype",
   "(",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "file_path",
   ",",
   "mode",
   ")",
   "as",
   "f",
   ":",
   "try",
   ":",
   "ic",
   "=",
   "0",
   "h5grp",
   "=",
   "f",
   ".",
   "create_group",
   "(",
   "os",
   ".",
   "path",
   ".",
   "dirname",
   "(",
   "h5path",
   ")",
   ")",
   "h5ds",
   "=",
   "h5grp",
   ".",
   "create_dataset",
   "(",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "h5path",
   ")",
   ",",
   "ds_shape",
   ",",
   "dtype",
   ")",
   "for",
   "img",
   "in",
   "imgs",
   ":",
   "#get the shape of the current image",
   "nushape",
   "=",
   "nushapes",
   "[",
   "ic",
   ",",
   ":",
   "]",
   "def",
   "append_to_dataset",
   "(",
   "h5ds",
   ",",
   "idx",
   ",",
   "data",
   ",",
   "concat_axis",
   ")",
   ":",
   "\"\"\"\n                    @param h5ds: H5py DataSet\n                    @param idx: int\n                    @param data: ndarray\n                    @param concat_axis: int\n                    @return:\n                    \"\"\"",
   "shape",
   "=",
   "data",
   ".",
   "shape",
   "ndims",
   "=",
   "len",
   "(",
   "shape",
   ")",
   "if",
   "ndims",
   "==",
   "1",
   ":",
   "if",
   "concat_axis",
   "==",
   "0",
   ":",
   "h5ds",
   "[",
   "idx",
   "]",
   "=",
   "data",
   "elif",
   "ndims",
   "==",
   "2",
   ":",
   "if",
   "concat_axis",
   "==",
   "0",
   ":",
   "h5ds",
   "[",
   "idx",
   "]",
   "=",
   "data",
   "elif",
   "concat_axis",
   "==",
   "1",
   ":",
   "h5ds",
   "[",
   "idx",
   "]",
   "=",
   "data",
   "elif",
   "ndims",
   "==",
   "3",
   ":",
   "if",
   "concat_axis",
   "==",
   "0",
   ":",
   "h5ds",
   "[",
   "idx",
   "]",
   "=",
   "data",
   "elif",
   "concat_axis",
   "==",
   "1",
   ":",
   "h5ds",
   "[",
   "idx",
   "]",
   "=",
   "data",
   "elif",
   "concat_axis",
   "==",
   "2",
   ":",
   "h5ds",
   "[",
   "idx",
   "]",
   "=",
   "data",
   "#appending the reshaped image into the dataset",
   "append_to_dataset",
   "(",
   "h5ds",
   ",",
   "ic",
   ",",
   "np",
   ".",
   "reshape",
   "(",
   "img",
   ".",
   "get_data",
   "(",
   ")",
   ",",
   "tuple",
   "(",
   "nushape",
   ")",
   ")",
   ",",
   "concat_axis",
   ")",
   "ic",
   "+=",
   "1",
   "except",
   "ValueError",
   "as",
   "ve",
   ":",
   "raise",
   "Exception",
   "(",
   "'Error creating group {} in hdf file {}'",
   ".",
   "format",
   "(",
   "h5path",
   ",",
   "file_path",
   ")",
   ")",
   "from",
   "ve"
  ]
 },
 {
  "idx": "maxmin-386",
  "nl_tokens": [
   "Find",
   "min",
   "and",
   "max",
   "values",
   "of",
   "every",
   "feature",
   "."
  ],
  "pl_tokens": [
   "def",
   "fit",
   "(",
   "self",
   ",",
   "X",
   ",",
   "y",
   "=",
   "None",
   ")",
   ":",
   "# Check that X have correct shape",
   "X",
   "=",
   "check_array",
   "(",
   "X",
   ")",
   "self",
   ".",
   "_x_min",
   "=",
   "X",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "# axis=0 will find the minimum values \u200b\u200bby columns (for each feature)",
   "self",
   ".",
   "_x_max",
   "=",
   "X",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "# axis=0 will find the minimum values \u200b\u200bby columns (for each feature)",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-387",
  "nl_tokens": [
   "Create",
   "an",
   "s",
   "-",
   "plane",
   "pole",
   "-",
   "zero",
   "plot",
   ".",
   "As",
   "input",
   "the",
   "function",
   "uses",
   "the",
   "numerator",
   "and",
   "denominator",
   "s",
   "-",
   "domain",
   "system",
   "function",
   "coefficient",
   "ndarrays",
   "b",
   "and",
   "a",
   "respectively",
   ".",
   "Assumed",
   "to",
   "be",
   "stored",
   "in",
   "descending",
   "powers",
   "of",
   "s",
   ".",
   "Parameters",
   "----------",
   "b",
   ":",
   "numerator",
   "coefficient",
   "ndarray",
   ".",
   "a",
   ":",
   "denominator",
   "coefficient",
   "ndarray",
   ".",
   "auto_scale",
   ":",
   "True",
   "size",
   ":",
   "[",
   "xmin",
   "xmax",
   "ymin",
   "ymax",
   "]",
   "plot",
   "scaling",
   "when",
   "scale",
   "=",
   "False",
   "Returns",
   "-------",
   "(",
   "M",
   "N",
   ")",
   ":",
   "tuple",
   "of",
   "zero",
   "and",
   "pole",
   "counts",
   "+",
   "plot",
   "window",
   "Notes",
   "-----",
   "This",
   "function",
   "tries",
   "to",
   "identify",
   "repeated",
   "poles",
   "and",
   "zeros",
   "and",
   "will",
   "place",
   "the",
   "multiplicity",
   "number",
   "above",
   "and",
   "to",
   "the",
   "right",
   "of",
   "the",
   "pole",
   "or",
   "zero",
   ".",
   "The",
   "difficulty",
   "is",
   "setting",
   "the",
   "tolerance",
   "for",
   "this",
   "detection",
   ".",
   "Currently",
   "it",
   "is",
   "set",
   "at",
   "1e",
   "-",
   "3",
   "via",
   "the",
   "function",
   "signal",
   ".",
   "unique_roots",
   ".",
   "Examples",
   "--------",
   ">>>",
   "#",
   "Here",
   "the",
   "plot",
   "is",
   "generated",
   "using",
   "auto_scale",
   ">>>",
   "splane",
   "(",
   "b",
   "a",
   ")",
   ">>>",
   "#",
   "Here",
   "the",
   "plot",
   "is",
   "generated",
   "using",
   "manual",
   "scaling",
   ">>>",
   "splane",
   "(",
   "b",
   "a",
   "False",
   "[",
   "-",
   "10",
   "1",
   "-",
   "10",
   "10",
   "]",
   ")"
  ],
  "pl_tokens": [
   "def",
   "splane",
   "(",
   "b",
   ",",
   "a",
   ",",
   "auto_scale",
   "=",
   "True",
   ",",
   "size",
   "=",
   "[",
   "-",
   "1",
   ",",
   "1",
   ",",
   "-",
   "1",
   ",",
   "1",
   "]",
   ")",
   ":",
   "M",
   "=",
   "len",
   "(",
   "b",
   ")",
   "-",
   "1",
   "N",
   "=",
   "len",
   "(",
   "a",
   ")",
   "-",
   "1",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "5",
   ",",
   "5",
   ")",
   ")",
   "#plt.axis('equal')",
   "N_roots",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0.0",
   "]",
   ")",
   "if",
   "M",
   ">",
   "0",
   ":",
   "N_roots",
   "=",
   "np",
   ".",
   "roots",
   "(",
   "b",
   ")",
   "D_roots",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0.0",
   "]",
   ")",
   "if",
   "N",
   ">",
   "0",
   ":",
   "D_roots",
   "=",
   "np",
   ".",
   "roots",
   "(",
   "a",
   ")",
   "if",
   "auto_scale",
   ":",
   "size",
   "[",
   "0",
   "]",
   "=",
   "<mask>",
   "(",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "real",
   "(",
   "N_roots",
   ")",
   ")",
   ",",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "real",
   "(",
   "D_roots",
   ")",
   ")",
   ")",
   "-",
   "0.5",
   "size",
   "[",
   "1",
   "]",
   "=",
   "max",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "real",
   "(",
   "N_roots",
   ")",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "real",
   "(",
   "D_roots",
   ")",
   ")",
   ")",
   "+",
   "0.5",
   "size",
   "[",
   "1",
   "]",
   "=",
   "max",
   "(",
   "size",
   "[",
   "1",
   "]",
   ",",
   "0.5",
   ")",
   "size",
   "[",
   "2",
   "]",
   "=",
   "min",
   "(",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "imag",
   "(",
   "N_roots",
   ")",
   ")",
   ",",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "imag",
   "(",
   "D_roots",
   ")",
   ")",
   ")",
   "-",
   "0.5",
   "size",
   "[",
   "3",
   "]",
   "=",
   "max",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "imag",
   "(",
   "N_roots",
   ")",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "imag",
   "(",
   "D_roots",
   ")",
   ")",
   ")",
   "+",
   "0.5",
   "plt",
   ".",
   "plot",
   "(",
   "[",
   "size",
   "[",
   "0",
   "]",
   ",",
   "size",
   "[",
   "1",
   "]",
   "]",
   ",",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "'k--'",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "[",
   "size",
   "[",
   "2",
   "]",
   ",",
   "size",
   "[",
   "3",
   "]",
   "]",
   ",",
   "'r--'",
   ")",
   "# Plot labels if multiplicity greater than 1",
   "x_scale",
   "=",
   "size",
   "[",
   "1",
   "]",
   "-",
   "size",
   "[",
   "0",
   "]",
   "y_scale",
   "=",
   "size",
   "[",
   "3",
   "]",
   "-",
   "size",
   "[",
   "2",
   "]",
   "x_off",
   "=",
   "0.03",
   "y_off",
   "=",
   "0.01",
   "if",
   "M",
   ">",
   "0",
   ":",
   "#N_roots = np.roots(b)",
   "N_uniq",
   ",",
   "N_mult",
   "=",
   "signal",
   ".",
   "unique_roots",
   "(",
   "N_roots",
   ",",
   "tol",
   "=",
   "1e-3",
   ",",
   "rtype",
   "=",
   "'avg'",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "np",
   ".",
   "real",
   "(",
   "N_uniq",
   ")",
   ",",
   "np",
   ".",
   "imag",
   "(",
   "N_uniq",
   ")",
   ",",
   "'ko'",
   ",",
   "mfc",
   "=",
   "'None'",
   ",",
   "ms",
   "=",
   "8",
   ")",
   "idx_N_mult",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "N_mult",
   ">",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "for",
   "k",
   "in",
   "range",
   "(",
   "len",
   "(",
   "idx_N_mult",
   ")",
   ")",
   ":",
   "x_loc",
   "=",
   "np",
   ".",
   "real",
   "(",
   "N_uniq",
   "[",
   "idx_N_mult",
   "[",
   "k",
   "]",
   "]",
   ")",
   "+",
   "x_off",
   "*",
   "x_scale",
   "y_loc",
   "=",
   "np",
   ".",
   "imag",
   "(",
   "N_uniq",
   "[",
   "idx_N_mult",
   "[",
   "k",
   "]",
   "]",
   ")",
   "+",
   "y_off",
   "*",
   "y_scale",
   "plt",
   ".",
   "text",
   "(",
   "x_loc",
   ",",
   "y_loc",
   ",",
   "str",
   "(",
   "N_mult",
   "[",
   "idx_N_mult",
   "[",
   "k",
   "]",
   "]",
   ")",
   ",",
   "ha",
   "=",
   "'center'",
   ",",
   "va",
   "=",
   "'bottom'",
   ",",
   "fontsize",
   "=",
   "10",
   ")",
   "if",
   "N",
   ">",
   "0",
   ":",
   "#D_roots = np.roots(a)",
   "D_uniq",
   ",",
   "D_mult",
   "=",
   "signal",
   ".",
   "unique_roots",
   "(",
   "D_roots",
   ",",
   "tol",
   "=",
   "1e-3",
   ",",
   "rtype",
   "=",
   "'avg'",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "np",
   ".",
   "real",
   "(",
   "D_uniq",
   ")",
   ",",
   "np",
   ".",
   "imag",
   "(",
   "D_uniq",
   ")",
   ",",
   "'kx'",
   ",",
   "ms",
   "=",
   "8",
   ")",
   "idx_D_mult",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "D_mult",
   ">",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "for",
   "k",
   "in",
   "range",
   "(",
   "len",
   "(",
   "idx_D_mult",
   ")",
   ")",
   ":",
   "x_loc",
   "=",
   "np",
   ".",
   "real",
   "(",
   "D_uniq",
   "[",
   "idx_D_mult",
   "[",
   "k",
   "]",
   "]",
   ")",
   "+",
   "x_off",
   "*",
   "x_scale",
   "y_loc",
   "=",
   "np",
   ".",
   "imag",
   "(",
   "D_uniq",
   "[",
   "idx_D_mult",
   "[",
   "k",
   "]",
   "]",
   ")",
   "+",
   "y_off",
   "*",
   "y_scale",
   "plt",
   ".",
   "text",
   "(",
   "x_loc",
   ",",
   "y_loc",
   ",",
   "str",
   "(",
   "D_mult",
   "[",
   "idx_D_mult",
   "[",
   "k",
   "]",
   "]",
   ")",
   ",",
   "ha",
   "=",
   "'center'",
   ",",
   "va",
   "=",
   "'bottom'",
   ",",
   "fontsize",
   "=",
   "10",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'Real Part'",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'Imaginary Part'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'Pole-Zero Plot'",
   ")",
   "#plt.grid()",
   "plt",
   ".",
   "axis",
   "(",
   "np",
   ".",
   "array",
   "(",
   "size",
   ")",
   ")",
   "return",
   "M",
   ",",
   "N"
  ]
 },
 {
  "idx": "maxmin-388",
  "nl_tokens": [
   "Moves",
   "the",
   "layer",
   "down",
   "in",
   "the",
   "stacking",
   "order",
   "."
  ],
  "pl_tokens": [
   "def",
   "down",
   "(",
   "self",
   ")",
   ":",
   "i",
   "=",
   "self",
   ".",
   "index",
   "(",
   ")",
   "if",
   "i",
   "!=",
   "None",
   ":",
   "del",
   "self",
   ".",
   "canvas",
   ".",
   "layers",
   "[",
   "i",
   "]",
   "i",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "i",
   "-",
   "1",
   ")",
   "self",
   ".",
   "canvas",
   ".",
   "layers",
   ".",
   "insert",
   "(",
   "i",
   ",",
   "self",
   ")"
  ]
 },
 {
  "idx": "maxmin-389",
  "nl_tokens": [
   "distributes",
   "cluster",
   "()",
   "function",
   "to",
   "an",
   "ipyclient",
   "to",
   "make",
   "sure",
   "it",
   "runs",
   "on",
   "a",
   "high",
   "memory",
   "node",
   "."
  ],
  "pl_tokens": [
   "def",
   "call_cluster",
   "(",
   "data",
   ",",
   "noreverse",
   ",",
   "ipyclient",
   ")",
   ":",
   "## Find host with the most engines, for now just using first.",
   "lbview",
   "=",
   "ipyclient",
   ".",
   "load_balanced_view",
   "(",
   ")",
   "## request engine data, skips busy engines.    ",
   "asyncs",
   "=",
   "{",
   "}",
   "for",
   "eid",
   "in",
   "ipyclient",
   ".",
   "ids",
   ":",
   "engine",
   "=",
   "ipyclient",
   "[",
   "eid",
   "]",
   "if",
   "not",
   "engine",
   ".",
   "outstanding",
   ":",
   "asyncs",
   "[",
   "eid",
   "]",
   "=",
   "engine",
   ".",
   "apply",
   "(",
   "socket",
   ".",
   "gethostname",
   ")",
   "## get results",
   "hosts",
   "=",
   "{",
   "}",
   "for",
   "key",
   "in",
   "asyncs",
   ":",
   "hosts",
   "[",
   "key",
   "]",
   "=",
   "asyncs",
   "[",
   "key",
   "]",
   ".",
   "get",
   "(",
   ")",
   "## count them",
   "results",
   "=",
   "{",
   "}",
   "for",
   "eid",
   ",",
   "hostname",
   "in",
   "hosts",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "hostname",
   "in",
   "results",
   ":",
   "results",
   "[",
   "hostname",
   "]",
   ".",
   "append",
   "(",
   "eid",
   ")",
   "else",
   ":",
   "results",
   "[",
   "hostname",
   "]",
   "=",
   "[",
   "eid",
   "]",
   "## which is largest",
   "hosts",
   "=",
   "sorted",
   "(",
   "results",
   ".",
   "items",
   "(",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   "[",
   "1",
   "]",
   ")",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "_",
   ",",
   "eids",
   "=",
   "hosts",
   "[",
   "0",
   "]",
   "bighost",
   "=",
   "ipyclient",
   "[",
   "eids",
   "[",
   "0",
   "]",
   "]",
   "## nthreads is len eids, or ipcluster.threads, unless ipcluster.threads ",
   "## is really small, then we assume threads should not apply here.",
   "##    ipyrad -p params.txt -s 6 -c 20 would give:",
   "##    min(20, max(2, 10)) = 8",
   "## while ",
   "##    ipyrad -p params.txt -s 6 -c 20 -t 4 would give:",
   "##    min(20, max(4, 10)) = 10",
   "## and ",
   "##    ipyrad -p params.txt -s 6 -c 20 -t 15 would give:",
   "##    min(20, max(15, 10)) = 15",
   "## and",
   "##    ipyrad -p params.txt -s 6 -c 16 --MPI (on 2 X 8-core nodes) would give:",
   "##    min(8, max(2, 10)) = 8",
   "nthreads",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "eids",
   ")",
   ",",
   "max",
   "(",
   "data",
   ".",
   "_ipcluster",
   "[",
   "\"threads\"",
   "]",
   ",",
   "10",
   ")",
   ")",
   "## submit job to the host with the most",
   "async",
   "=",
   "bighost",
   ".",
   "apply",
   "(",
   "cluster",
   ",",
   "*",
   "(",
   "data",
   ",",
   "noreverse",
   ",",
   "nthreads",
   ")",
   ")",
   "#async = lbview.apply(cluster, *(data, noreverse, nthreads))",
   "## track progress",
   "prog",
   "=",
   "0",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "printstr",
   "=",
   "\" clustering across     | {} | s6 |\"",
   "while",
   "1",
   ":",
   "if",
   "async",
   ".",
   "stdout",
   ":",
   "prog",
   "=",
   "int",
   "(",
   "async",
   ".",
   "stdout",
   ".",
   "split",
   "(",
   ")",
   "[",
   "-",
   "1",
   "]",
   ")",
   "elapsed",
   "=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "seconds",
   "=",
   "int",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")",
   ")",
   "progressbar",
   "(",
   "100",
   ",",
   "prog",
   ",",
   "printstr",
   ".",
   "format",
   "(",
   "elapsed",
   ")",
   ",",
   "spacer",
   "=",
   "data",
   ".",
   "_spacer",
   ")",
   "if",
   "async",
   ".",
   "ready",
   "(",
   ")",
   ":",
   "progressbar",
   "(",
   "100",
   ",",
   "prog",
   ",",
   "printstr",
   ".",
   "format",
   "(",
   "elapsed",
   ")",
   ",",
   "spacer",
   "=",
   "data",
   ".",
   "_spacer",
   ")",
   "print",
   "(",
   "\"\"",
   ")",
   "break",
   "else",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "0.5",
   ")",
   "## store log result",
   "ipyclient",
   ".",
   "wait",
   "(",
   ")",
   "data",
   ".",
   "stats_files",
   ".",
   "s6",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   ",",
   "\"s6_cluster_stats.txt\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-390",
  "nl_tokens": [
   "Plots",
   "a",
   "probability",
   "distribution",
   "for",
   "the",
   "event",
   "of",
   "making",
   "a",
   "profitable",
   "trade",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_prob_profit_trade",
   "(",
   "round_trips",
   ",",
   "ax",
   "=",
   "None",
   ")",
   ":",
   "x",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "1.",
   ",",
   "500",
   ")",
   "round_trips",
   "[",
   "'profitable'",
   "]",
   "=",
   "round_trips",
   ".",
   "pnl",
   ">",
   "0",
   "dist",
   "=",
   "sp",
   ".",
   "stats",
   ".",
   "beta",
   "(",
   "round_trips",
   ".",
   "profitable",
   ".",
   "sum",
   "(",
   ")",
   ",",
   "(",
   "~",
   "round_trips",
   ".",
   "profitable",
   ")",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "y",
   "=",
   "dist",
   ".",
   "pdf",
   "(",
   "x",
   ")",
   "lower_perc",
   "=",
   "dist",
   ".",
   "ppf",
   "(",
   ".025",
   ")",
   "upper_perc",
   "=",
   "dist",
   ".",
   "ppf",
   "(",
   ".975",
   ")",
   "lower_plot",
   "=",
   "dist",
   ".",
   "ppf",
   "(",
   ".001",
   ")",
   "upper_plot",
   "=",
   "dist",
   ".",
   "ppf",
   "(",
   ".999",
   ")",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "x",
   ",",
   "y",
   ")",
   "ax",
   ".",
   "axvline",
   "(",
   "lower_perc",
   ",",
   "color",
   "=",
   "'0.5'",
   ")",
   "ax",
   ".",
   "axvline",
   "(",
   "upper_perc",
   ",",
   "color",
   "=",
   "'0.5'",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "'Probability of making a profitable decision'",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "'Belief'",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "lower_plot",
   ",",
   "upper_plot",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "(",
   "0",
   ",",
   "y",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "1.",
   ")",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-391",
  "nl_tokens": [
   "Fill",
   "the",
   "entire",
   "strip",
   "with",
   "RGB",
   "color",
   "tuple"
  ],
  "pl_tokens": [
   "def",
   "fill",
   "(",
   "self",
   ",",
   "color",
   ",",
   "start",
   "=",
   "0",
   ",",
   "end",
   "=",
   "-",
   "1",
   ")",
   ":",
   "start",
   "=",
   "<mask>",
   "(",
   "start",
   ",",
   "0",
   ")",
   "if",
   "end",
   "<",
   "0",
   "or",
   "end",
   ">=",
   "self",
   ".",
   "numLEDs",
   ":",
   "end",
   "=",
   "self",
   ".",
   "numLEDs",
   "-",
   "1",
   "for",
   "led",
   "in",
   "range",
   "(",
   "start",
   ",",
   "end",
   "+",
   "1",
   ")",
   ":",
   "# since 0-index include end in range",
   "self",
   ".",
   "_set_base",
   "(",
   "led",
   ",",
   "color",
   ")"
  ]
 },
 {
  "idx": "maxmin-392",
  "nl_tokens": [
   "This",
   "calculates",
   "various",
   "phased",
   "LC",
   "features",
   "for",
   "the",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "phasedlc_features",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "period",
   ",",
   "nbrtimes",
   "=",
   "None",
   ",",
   "nbrmags",
   "=",
   "None",
   ",",
   "nbrerrs",
   "=",
   "None",
   ")",
   ":",
   "# get the finite values",
   "finind",
   "=",
   "np",
   ".",
   "isfinite",
   "(",
   "times",
   ")",
   "&",
   "np",
   ".",
   "isfinite",
   "(",
   "mags",
   ")",
   "&",
   "np",
   ".",
   "isfinite",
   "(",
   "errs",
   ")",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   "=",
   "times",
   "[",
   "finind",
   "]",
   ",",
   "mags",
   "[",
   "finind",
   "]",
   ",",
   "errs",
   "[",
   "finind",
   "]",
   "# get nonzero errors",
   "nzind",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "ferrs",
   ")",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   "=",
   "ftimes",
   "[",
   "nzind",
   "]",
   ",",
   "fmags",
   "[",
   "nzind",
   "]",
   ",",
   "ferrs",
   "[",
   "nzind",
   "]",
   "# only operate on LC if enough points",
   "if",
   "ftimes",
   ".",
   "size",
   ">",
   "49",
   ":",
   "# get the MAD of the unphased light curve",
   "lightcurve_median",
   "=",
   "np",
   ".",
   "median",
   "(",
   "fmags",
   ")",
   "lightcurve_mad",
   "=",
   "np",
   ".",
   "median",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "fmags",
   "-",
   "lightcurve_median",
   ")",
   ")",
   "# get p2p for raw lightcurve",
   "p2p_unphasedlc",
   "=",
   "lightcurve_ptp_measures",
   "(",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   ")",
   "inveta_unphasedlc",
   "=",
   "1.0",
   "/",
   "p2p_unphasedlc",
   "[",
   "'eta_normal'",
   "]",
   "# phase the light curve with the given period, assume epoch is",
   "# times.min()",
   "phasedlc",
   "=",
   "lcmath",
   ".",
   "phase_magseries_with_errs",
   "(",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   ",",
   "period",
   ",",
   "ftimes",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "wrap",
   "=",
   "False",
   ")",
   "phase",
   "=",
   "phasedlc",
   "[",
   "'phase'",
   "]",
   "pmags",
   "=",
   "phasedlc",
   "[",
   "'mags'",
   "]",
   "perrs",
   "=",
   "phasedlc",
   "[",
   "'errs'",
   "]",
   "# get ptp measures for best period",
   "ptp_bestperiod",
   "=",
   "lightcurve_ptp_measures",
   "(",
   "phase",
   ",",
   "pmags",
   ",",
   "perrs",
   ")",
   "# phase the light curve with the given periodx2, assume epoch is",
   "# times.min()",
   "phasedlc",
   "=",
   "lcmath",
   ".",
   "phase_magseries_with_errs",
   "(",
   "ftimes",
   ",",
   "fmags",
   ",",
   "ferrs",
   ",",
   "period",
   "*",
   "2.0",
   ",",
   "ftimes",
   ".",
   "min",
   "(",
   ")",
   ",",
   "wrap",
   "=",
   "False",
   ")",
   "phasex2",
   "=",
   "phasedlc",
   "[",
   "'phase'",
   "]",
   "pmagsx2",
   "=",
   "phasedlc",
   "[",
   "'mags'",
   "]",
   "perrsx2",
   "=",
   "phasedlc",
   "[",
   "'errs'",
   "]",
   "# get ptp measures for best periodx2",
   "ptp_bestperiodx2",
   "=",
   "lightcurve_ptp_measures",
   "(",
   "phasex2",
   ",",
   "pmagsx2",
   ",",
   "perrsx2",
   ")",
   "# eta_phasedlc_bestperiod - calculate eta for the phased LC with best",
   "# period",
   "inveta_bestperiod",
   "=",
   "1.0",
   "/",
   "ptp_bestperiod",
   "[",
   "'eta_normal'",
   "]",
   "# eta_phasedlc_bestperiodx2 - calculate eta for the phased LC with best",
   "#                             period x 2",
   "inveta_bestperiodx2",
   "=",
   "1.0",
   "/",
   "ptp_bestperiodx2",
   "[",
   "'eta_normal'",
   "]",
   "# eta_phased_ratio_eta_raw - eta for best period phased LC / eta for raw",
   "# LC",
   "inveta_ratio_phased_unphased",
   "=",
   "inveta_bestperiod",
   "/",
   "inveta_unphasedlc",
   "# eta_phasedx2_ratio_eta_raw - eta for best periodx2 phased LC/eta for",
   "# raw LC",
   "inveta_ratio_phasedx2_unphased",
   "=",
   "inveta_bestperiodx2",
   "/",
   "inveta_unphasedlc",
   "# freq_model_max_delta_mags - absval of magdiff btw model phased LC",
   "#                             maxima using period x 2. look at points",
   "#                             more than 10 points away for maxima",
   "phasedx2_maxval_ind",
   "=",
   "argrelmax",
   "(",
   "pmagsx2",
   ",",
   "order",
   "=",
   "10",
   ")",
   "if",
   "phasedx2_maxval_ind",
   "[",
   "0",
   "]",
   ".",
   "size",
   ">",
   "1",
   ":",
   "phasedx2_magdiff_maxval",
   "=",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "diff",
   "(",
   "pmagsx2",
   "[",
   "phasedx2_maxval_ind",
   "[",
   "0",
   "]",
   "]",
   ")",
   ")",
   ")",
   ")",
   "else",
   ":",
   "phasedx2_magdiff_maxval",
   "=",
   "np",
   ".",
   "nan",
   "# freq_model_min_delta_mags - absval of magdiff btw model phased LC",
   "#                             minima using period x 2. look at points",
   "#                             more than 10 points away for minima",
   "phasedx2_minval_ind",
   "=",
   "argrelmin",
   "(",
   "pmagsx2",
   ",",
   "order",
   "=",
   "10",
   ")",
   "if",
   "phasedx2_minval_ind",
   "[",
   "0",
   "]",
   ".",
   "size",
   ">",
   "1",
   ":",
   "phasedx2_magdiff_minval",
   "=",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "diff",
   "(",
   "pmagsx2",
   "[",
   "phasedx2_minval_ind",
   "[",
   "0",
   "]",
   "]",
   ")",
   ")",
   ")",
   ")",
   "else",
   ":",
   "phasedx2_magdiff_minval",
   "=",
   "np",
   ".",
   "nan",
   "# p2p_scatter_pfold_over_mad - MAD of successive absolute mag diffs of",
   "#                              the phased LC using best period divided",
   "#                              by the MAD of the unphased LC",
   "phased_magdiff",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "pmags",
   ")",
   "phased_magdiff_median",
   "=",
   "np",
   ".",
   "median",
   "(",
   "phased_magdiff",
   ")",
   "phased_magdiff_mad",
   "=",
   "np",
   ".",
   "median",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "phased_magdiff",
   "-",
   "phased_magdiff_median",
   ")",
   ")",
   "phasedx2_magdiff",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "pmagsx2",
   ")",
   "phasedx2_magdiff_median",
   "=",
   "np",
   ".",
   "median",
   "(",
   "phasedx2_magdiff",
   ")",
   "phasedx2_magdiff_mad",
   "=",
   "np",
   ".",
   "median",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "phasedx2_magdiff",
   "-",
   "phasedx2_magdiff_median",
   ")",
   ")",
   "phased_magdiffmad_unphased_mad_ratio",
   "=",
   "phased_magdiff_mad",
   "/",
   "lightcurve_mad",
   "phasedx2_magdiffmad_unphased_mad_ratio",
   "=",
   "(",
   "phasedx2_magdiff_mad",
   "/",
   "lightcurve_mad",
   ")",
   "# get the percentiles of the slopes of the adjacent mags for phasedx2",
   "phasedx2_slopes",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "pmagsx2",
   ")",
   "/",
   "np",
   ".",
   "diff",
   "(",
   "phasex2",
   ")",
   "phasedx2_slope_percentiles",
   "=",
   "np",
   ".",
   "ravel",
   "(",
   "np",
   ".",
   "nanpercentile",
   "(",
   "phasedx2_slopes",
   ",",
   "[",
   "10.0",
   ",",
   "90.0",
   "]",
   ")",
   ")",
   "phasedx2_slope_10percentile",
   "=",
   "phasedx2_slope_percentiles",
   "[",
   "0",
   "]",
   "phasedx2_slope_90percentile",
   "=",
   "phasedx2_slope_percentiles",
   "[",
   "1",
   "]",
   "# check if nbrtimes, _mags, _errs are available",
   "if",
   "(",
   "(",
   "nbrtimes",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "nbrmags",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "nbrerrs",
   "is",
   "not",
   "None",
   ")",
   ")",
   ":",
   "# get the finite values",
   "nfinind",
   "=",
   "(",
   "np",
   ".",
   "isfinite",
   "(",
   "nbrtimes",
   ")",
   "&",
   "np",
   ".",
   "isfinite",
   "(",
   "nbrmags",
   ")",
   "&",
   "np",
   ".",
   "isfinite",
   "(",
   "nbrerrs",
   ")",
   ")",
   "nftimes",
   ",",
   "nfmags",
   ",",
   "nferrs",
   "=",
   "(",
   "nbrtimes",
   "[",
   "nfinind",
   "]",
   ",",
   "nbrmags",
   "[",
   "nfinind",
   "]",
   ",",
   "nbrerrs",
   "[",
   "nfinind",
   "]",
   ")",
   "# get nonzero errors",
   "nnzind",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "nferrs",
   ")",
   "nftimes",
   ",",
   "nfmags",
   ",",
   "nferrs",
   "=",
   "(",
   "nftimes",
   "[",
   "nnzind",
   "]",
   ",",
   "nfmags",
   "[",
   "nnzind",
   "]",
   ",",
   "nferrs",
   "[",
   "nnzind",
   "]",
   ")",
   "# only operate on LC if enough points",
   "if",
   "nftimes",
   ".",
   "size",
   ">",
   "49",
   ":",
   "# get the phased light curve using the same period and epoch as",
   "# the actual object",
   "nphasedlc",
   "=",
   "lcmath",
   ".",
   "phase_magseries_with_errs",
   "(",
   "nftimes",
   ",",
   "nfmags",
   ",",
   "nferrs",
   ",",
   "period",
   ",",
   "ftimes",
   ".",
   "min",
   "(",
   ")",
   ",",
   "wrap",
   "=",
   "False",
   ")",
   "# normalize the object and neighbor phased mags",
   "norm_pmags",
   "=",
   "pmags",
   "-",
   "np",
   ".",
   "median",
   "(",
   "pmags",
   ")",
   "norm_npmags",
   "=",
   "nphasedlc",
   "[",
   "'mags'",
   "]",
   "-",
   "np",
   ".",
   "median",
   "(",
   "nphasedlc",
   "[",
   "'mags'",
   "]",
   ")",
   "# phase bin them both so we can compare LCs easily",
   "phabinned_objectlc",
   "=",
   "lcmath",
   ".",
   "phase_bin_magseries",
   "(",
   "phase",
   ",",
   "norm_pmags",
   ",",
   "minbinelems",
   "=",
   "1",
   ")",
   "phabinned_nbrlc",
   "=",
   "lcmath",
   ".",
   "phase_bin_magseries",
   "(",
   "nphasedlc",
   "[",
   "'phase'",
   "]",
   ",",
   "norm_npmags",
   ",",
   "minbinelems",
   "=",
   "1",
   ")",
   "absdiffs",
   "=",
   "[",
   "]",
   "for",
   "pha",
   ",",
   "phamag",
   "in",
   "zip",
   "(",
   "phabinned_objectlc",
   "[",
   "'binnedphases'",
   "]",
   ",",
   "phabinned_objectlc",
   "[",
   "'binnedmags'",
   "]",
   ")",
   ":",
   "try",
   ":",
   "# get the matching phase from the neighbor phased LC",
   "phadiffs",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "pha",
   "-",
   "phabinned_nbrlc",
   "[",
   "'binnedphases'",
   "]",
   ")",
   "minphadiffind",
   "=",
   "np",
   ".",
   "where",
   "(",
   "(",
   "phadiffs",
   "<",
   "1.0e-4",
   ")",
   "&",
   "(",
   "phadiffs",
   "==",
   "np",
   ".",
   "min",
   "(",
   "phadiffs",
   ")",
   ")",
   ")",
   "absmagdiff",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "phamag",
   "-",
   "phabinned_nbrlc",
   "[",
   "'binnedmags'",
   "]",
   "[",
   "minphadiffind",
   "]",
   ")",
   "if",
   "absmagdiff",
   ".",
   "size",
   ">",
   "0",
   ":",
   "absdiffs",
   ".",
   "append",
   "(",
   "absmagdiff",
   ".",
   "min",
   "(",
   ")",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "continue",
   "# sum of absdiff between the normalized to 0.0 phased LC of this",
   "# object and that of the closest neighbor phased with the same",
   "# period and epoch",
   "if",
   "len",
   "(",
   "absdiffs",
   ")",
   ">",
   "0",
   ":",
   "sum_nbr_phasedlc_magdiff",
   "=",
   "sum",
   "(",
   "absdiffs",
   ")",
   "else",
   ":",
   "sum_nbr_phasedlc_magdiff",
   "=",
   "np",
   ".",
   "nan",
   "else",
   ":",
   "sum_nbr_phasedlc_magdiff",
   "=",
   "np",
   ".",
   "nan",
   "else",
   ":",
   "sum_nbr_phasedlc_magdiff",
   "=",
   "np",
   ".",
   "nan",
   "return",
   "{",
   "'inveta_unphasedlc'",
   ":",
   "inveta_unphasedlc",
   ",",
   "'inveta_bestperiod'",
   ":",
   "inveta_bestperiod",
   ",",
   "'inveta_bestperiodx2'",
   ":",
   "inveta_bestperiodx2",
   ",",
   "'inveta_ratio_phased_unphased'",
   ":",
   "inveta_ratio_phased_unphased",
   ",",
   "'inveta_ratio_phasedx2_unphased'",
   ":",
   "inveta_ratio_phasedx2_unphased",
   ",",
   "'phasedx2_magdiff_maxima'",
   ":",
   "phasedx2_magdiff_maxval",
   ",",
   "'phasedx2_magdiff_minina'",
   ":",
   "phasedx2_magdiff_minval",
   ",",
   "'phased_unphased_magdiff_mad_ratio'",
   ":",
   "(",
   "phased_magdiffmad_unphased_mad_ratio",
   ")",
   ",",
   "'phasedx2_unphased_magdiff_mad_ratio'",
   ":",
   "(",
   "phasedx2_magdiffmad_unphased_mad_ratio",
   ")",
   ",",
   "'phasedx2_slope_10percentile'",
   ":",
   "phasedx2_slope_10percentile",
   ",",
   "'phasedx2_slope_90percentile'",
   ":",
   "phasedx2_slope_90percentile",
   ",",
   "'sum_nbr_phasedlc_magdiff'",
   ":",
   "sum_nbr_phasedlc_magdiff",
   ",",
   "}",
   "else",
   ":",
   "return",
   "{",
   "'inveta_unphasedlc'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'inveta_bestperiod'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'inveta_bestperiodx2'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'inveta_ratio_phased_unphased'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'inveta_ratio_phasedx2_unphased'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'phasedx2_magdiff_maxima'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'phasedx2_magdiff_minina'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'phased_unphased_magdiff_mad_ratio'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'phasedx2_unphased_magdiff_mad_ratio'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'phasedx2_slope_10percentile'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'phasedx2_slope_90percentile'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'sum_nbr_phasedlc_magdiff'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "}"
  ]
 },
 {
  "idx": "maxmin-393",
  "nl_tokens": [
   "Compute",
   "the",
   "max",
   "along",
   "a",
   "1D",
   "array",
   "like",
   "ma",
   ".",
   "mean",
   "but",
   "with",
   "a",
   "representativity",
   "coefficient",
   ":",
   "if",
   "ma",
   ".",
   "count",
   "(",
   "a",
   ")",
   "/",
   "ma",
   ".",
   "size",
   "(",
   "a",
   ")",
   ">",
   "=",
   "rep",
   "then",
   "the",
   "result",
   "is",
   "a",
   "masked",
   "value"
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "a",
   ",",
   "rep",
   "=",
   "0.75",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "return",
   "rfunc",
   "(",
   "a",
   ",",
   "ma",
   ".",
   "max",
   ",",
   "rep",
   ",",
   "*",
   "*",
   "kwargs",
   ")"
  ]
 },
 {
  "idx": "maxmin-394",
  "nl_tokens": [
   "Provide",
   "a",
   "common",
   "interface",
   "for",
   "single",
   "or",
   "multiple",
   "knockouts",
   "."
  ],
  "pl_tokens": [
   "def",
   "_multi_deletion",
   "(",
   "model",
   ",",
   "entity",
   ",",
   "element_lists",
   ",",
   "method",
   "=",
   "\"fba\"",
   ",",
   "solution",
   "=",
   "None",
   ",",
   "processes",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "solver",
   "=",
   "sutil",
   ".",
   "interface_to_str",
   "(",
   "model",
   ".",
   "problem",
   ".",
   "__name__",
   ")",
   "if",
   "method",
   "==",
   "\"moma\"",
   "and",
   "solver",
   "not",
   "in",
   "sutil",
   ".",
   "qp_solvers",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Cannot use MOMA since '{}' is not QP-capable.\"",
   "\"Please choose a different solver or use FBA only.\"",
   ".",
   "format",
   "(",
   "solver",
   ")",
   ")",
   "if",
   "processes",
   "is",
   "None",
   ":",
   "processes",
   "=",
   "CONFIGURATION",
   ".",
   "processes",
   "with",
   "model",
   ":",
   "if",
   "\"moma\"",
   "in",
   "method",
   ":",
   "add_moma",
   "(",
   "model",
   ",",
   "solution",
   "=",
   "solution",
   ",",
   "linear",
   "=",
   "\"linear\"",
   "in",
   "method",
   ")",
   "elif",
   "\"room\"",
   "in",
   "method",
   ":",
   "add_room",
   "(",
   "model",
   ",",
   "solution",
   "=",
   "solution",
   ",",
   "linear",
   "=",
   "\"linear\"",
   "in",
   "method",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "args",
   "=",
   "set",
   "(",
   "[",
   "frozenset",
   "(",
   "comb",
   ")",
   "for",
   "comb",
   "in",
   "product",
   "(",
   "*",
   "element_lists",
   ")",
   "]",
   ")",
   "processes",
   "=",
   "<mask>",
   "(",
   "processes",
   ",",
   "len",
   "(",
   "args",
   ")",
   ")",
   "def",
   "extract_knockout_results",
   "(",
   "result_iter",
   ")",
   ":",
   "result",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "[",
   "(",
   "frozenset",
   "(",
   "ids",
   ")",
   ",",
   "growth",
   ",",
   "status",
   ")",
   "for",
   "(",
   "ids",
   ",",
   "growth",
   ",",
   "status",
   ")",
   "in",
   "result_iter",
   "]",
   ",",
   "columns",
   "=",
   "[",
   "'ids'",
   ",",
   "'growth'",
   ",",
   "'status'",
   "]",
   ")",
   "result",
   ".",
   "set_index",
   "(",
   "'ids'",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "return",
   "result",
   "if",
   "processes",
   ">",
   "1",
   ":",
   "worker",
   "=",
   "dict",
   "(",
   "gene",
   "=",
   "_gene_deletion_worker",
   ",",
   "reaction",
   "=",
   "_reaction_deletion_worker",
   ")",
   "[",
   "entity",
   "]",
   "chunk_size",
   "=",
   "len",
   "(",
   "args",
   ")",
   "//",
   "processes",
   "pool",
   "=",
   "multiprocessing",
   ".",
   "Pool",
   "(",
   "processes",
   ",",
   "initializer",
   "=",
   "_init_worker",
   ",",
   "initargs",
   "=",
   "(",
   "model",
   ",",
   ")",
   ")",
   "results",
   "=",
   "extract_knockout_results",
   "(",
   "pool",
   ".",
   "imap_unordered",
   "(",
   "worker",
   ",",
   "args",
   ",",
   "chunksize",
   "=",
   "chunk_size",
   ")",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "else",
   ":",
   "worker",
   "=",
   "dict",
   "(",
   "gene",
   "=",
   "_gene_deletion",
   ",",
   "reaction",
   "=",
   "_reaction_deletion",
   ")",
   "[",
   "entity",
   "]",
   "results",
   "=",
   "extract_knockout_results",
   "(",
   "map",
   "(",
   "partial",
   "(",
   "worker",
   ",",
   "model",
   ")",
   ",",
   "args",
   ")",
   ")",
   "return",
   "results"
  ]
 },
 {
  "idx": "maxmin-395",
  "nl_tokens": [
   "Calculate",
   "the",
   "distances",
   "from",
   "inputPattern",
   "to",
   "all",
   "stored",
   "patterns",
   ".",
   "All",
   "distances",
   "are",
   "between",
   "0",
   ".",
   "0",
   "and",
   "1",
   ".",
   "0"
  ],
  "pl_tokens": [
   "def",
   "_calcDistance",
   "(",
   "self",
   ",",
   "inputPattern",
   ",",
   "distanceNorm",
   "=",
   "None",
   ")",
   ":",
   "if",
   "distanceNorm",
   "is",
   "None",
   ":",
   "distanceNorm",
   "=",
   "self",
   ".",
   "distanceNorm",
   "# Sparse memory",
   "if",
   "self",
   ".",
   "useSparseMemory",
   ":",
   "if",
   "self",
   ".",
   "_protoSizes",
   "is",
   "None",
   ":",
   "self",
   ".",
   "_protoSizes",
   "=",
   "self",
   ".",
   "_Memory",
   ".",
   "rowSums",
   "(",
   ")",
   "overlapsWithProtos",
   "=",
   "self",
   ".",
   "_Memory",
   ".",
   "rightVecSumAtNZ",
   "(",
   "inputPattern",
   ")",
   "inputPatternSum",
   "=",
   "inputPattern",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "self",
   ".",
   "distanceMethod",
   "==",
   "\"rawOverlap\"",
   ":",
   "dist",
   "=",
   "inputPattern",
   ".",
   "sum",
   "(",
   ")",
   "-",
   "overlapsWithProtos",
   "elif",
   "self",
   ".",
   "distanceMethod",
   "==",
   "\"pctOverlapOfInput\"",
   ":",
   "dist",
   "=",
   "inputPatternSum",
   "-",
   "overlapsWithProtos",
   "if",
   "inputPatternSum",
   ">",
   "0",
   ":",
   "dist",
   "/=",
   "inputPatternSum",
   "elif",
   "self",
   ".",
   "distanceMethod",
   "==",
   "\"pctOverlapOfProto\"",
   ":",
   "overlapsWithProtos",
   "/=",
   "self",
   ".",
   "_protoSizes",
   "dist",
   "=",
   "1.0",
   "-",
   "overlapsWithProtos",
   "elif",
   "self",
   ".",
   "distanceMethod",
   "==",
   "\"pctOverlapOfLarger\"",
   ":",
   "maxVal",
   "=",
   "numpy",
   ".",
   "maximum",
   "(",
   "self",
   ".",
   "_protoSizes",
   ",",
   "inputPatternSum",
   ")",
   "if",
   "maxVal",
   ".",
   "all",
   "(",
   ")",
   ">",
   "0",
   ":",
   "overlapsWithProtos",
   "/=",
   "maxVal",
   "dist",
   "=",
   "1.0",
   "-",
   "overlapsWithProtos",
   "elif",
   "self",
   ".",
   "distanceMethod",
   "==",
   "\"norm\"",
   ":",
   "dist",
   "=",
   "self",
   ".",
   "_Memory",
   ".",
   "vecLpDist",
   "(",
   "self",
   ".",
   "distanceNorm",
   ",",
   "inputPattern",
   ")",
   "distMax",
   "=",
   "dist",
   ".",
   "<mask>",
   "(",
   ")",
   "if",
   "distMax",
   ">",
   "0",
   ":",
   "dist",
   "/=",
   "distMax",
   "else",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Unimplemented distance method %s\"",
   "%",
   "self",
   ".",
   "distanceMethod",
   ")",
   "# Dense memory",
   "else",
   ":",
   "if",
   "self",
   ".",
   "distanceMethod",
   "==",
   "\"norm\"",
   ":",
   "dist",
   "=",
   "numpy",
   ".",
   "power",
   "(",
   "numpy",
   ".",
   "abs",
   "(",
   "self",
   ".",
   "_M",
   "-",
   "inputPattern",
   ")",
   ",",
   "self",
   ".",
   "distanceNorm",
   ")",
   "dist",
   "=",
   "dist",
   ".",
   "sum",
   "(",
   "1",
   ")",
   "dist",
   "=",
   "numpy",
   ".",
   "power",
   "(",
   "dist",
   ",",
   "1.0",
   "/",
   "self",
   ".",
   "distanceNorm",
   ")",
   "dist",
   "/=",
   "dist",
   ".",
   "max",
   "(",
   ")",
   "else",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Not implemented yet for dense storage....\"",
   ")",
   "return",
   "dist"
  ]
 },
 {
  "idx": "maxmin-396",
  "nl_tokens": [
   "Find",
   "the",
   "root",
   "of",
   "the",
   "path",
   "-",
   ">",
   "The",
   "node",
   "with",
   "the",
   "lowest",
   "out",
   "degree",
   "if",
   "multiple",
   ":",
   "root",
   "is",
   "the",
   "one",
   "with",
   "the",
   "highest",
   "out",
   "degree",
   "among",
   "those",
   "with",
   "lowest",
   "out",
   "degree",
   ":",
   "param",
   "pybel",
   ".",
   "BELGraph",
   "graph",
   ":",
   "A",
   "BEL",
   "Graph",
   ":",
   "param",
   "list",
   "[",
   "tuple",
   "]",
   "path_nodes",
   ":",
   "A",
   "list",
   "of",
   "nodes",
   "in",
   "their",
   "order",
   "in",
   "a",
   "path",
   ":",
   "return",
   ":",
   "A",
   "pair",
   "of",
   "the",
   "graph",
   ":",
   "graph",
   "of",
   "the",
   "path",
   "and",
   "the",
   "root",
   "node",
   ":",
   "rtype",
   ":",
   "tuple",
   "[",
   "pybel",
   ".",
   "BELGraph",
   "tuple",
   "]"
  ],
  "pl_tokens": [
   "def",
   "find_root_in_path",
   "(",
   "graph",
   ",",
   "path_nodes",
   ")",
   ":",
   "path_graph",
   "=",
   "graph",
   ".",
   "subgraph",
   "(",
   "path_nodes",
   ")",
   "# node_in_degree_tuple: list of tuples with (node,in_degree_of_node) in ascending order",
   "node_in_degree_tuple",
   "=",
   "sorted",
   "(",
   "[",
   "(",
   "n",
   ",",
   "d",
   ")",
   "for",
   "n",
   ",",
   "d",
   "in",
   "path_graph",
   ".",
   "in_degree",
   "(",
   ")",
   ".",
   "items",
   "(",
   ")",
   "]",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "# node_out_degree_tuple: ordered list of tuples with (node,in_degree_of_node) in descending order",
   "node_out_degree_tuple",
   "=",
   "sorted",
   "(",
   "[",
   "(",
   "n",
   ",",
   "d",
   ")",
   "for",
   "n",
   ",",
   "d",
   "in",
   "path_graph",
   ".",
   "out_degree",
   "(",
   ")",
   ".",
   "items",
   "(",
   ")",
   "]",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "1",
   ")",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "# In case all have the same in degree it needs to be reference before",
   "tied_root_index",
   "=",
   "0",
   "# Get index where the min in_degree stops (in case they are duplicates)",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "(",
   "len",
   "(",
   "node_in_degree_tuple",
   ")",
   "-",
   "1",
   ")",
   ")",
   ":",
   "if",
   "node_in_degree_tuple",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   "<",
   "node_in_degree_tuple",
   "[",
   "i",
   "+",
   "1",
   "]",
   "[",
   "1",
   "]",
   ":",
   "tied_root_index",
   "=",
   "i",
   "break",
   "# If there are multiple nodes with minimum in_degree take the one with max out degree",
   "# (in case multiple have the same out degree pick one random)",
   "if",
   "tied_root_index",
   "!=",
   "0",
   ":",
   "root_tuple",
   "=",
   "<mask>",
   "(",
   "node_out_degree_tuple",
   "[",
   ":",
   "tied_root_index",
   "]",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "else",
   ":",
   "root_tuple",
   "=",
   "node_in_degree_tuple",
   "[",
   "0",
   "]",
   "return",
   "path_graph",
   ",",
   "root_tuple",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-397",
  "nl_tokens": [
   "Computes",
   "the",
   "average",
   "on",
   "-",
   "time",
   "of",
   "the",
   "outputs",
   "that",
   "are",
   "on",
   "at",
   "each",
   "time",
   "step",
   "and",
   "then",
   "averages",
   "this",
   "over",
   "all",
   "time",
   "steps",
   "."
  ],
  "pl_tokens": [
   "def",
   "averageOnTimePerTimestep",
   "(",
   "vectors",
   ",",
   "numSamples",
   "=",
   "None",
   ")",
   ":",
   "# Special case given a 1 dimensional vector: it represents a single column",
   "if",
   "vectors",
   ".",
   "ndim",
   "==",
   "1",
   ":",
   "vectors",
   ".",
   "shape",
   "=",
   "(",
   "-",
   "1",
   ",",
   "1",
   ")",
   "numTimeSteps",
   "=",
   "len",
   "(",
   "vectors",
   ")",
   "numElements",
   "=",
   "len",
   "(",
   "vectors",
   "[",
   "0",
   "]",
   ")",
   "# How many samples will we look at?",
   "if",
   "numSamples",
   "is",
   "not",
   "None",
   ":",
   "import",
   "pdb",
   "pdb",
   ".",
   "set_trace",
   "(",
   ")",
   "# Test this....",
   "countOn",
   "=",
   "numpy",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "numElements",
   ",",
   "numSamples",
   ")",
   "vectors",
   "=",
   "vectors",
   "[",
   ":",
   ",",
   "countOn",
   "]",
   "# Fill in each non-zero of vectors with the on-time that that output was",
   "#  on for.",
   "durations",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "vectors",
   ".",
   "shape",
   ",",
   "dtype",
   "=",
   "'int32'",
   ")",
   "for",
   "col",
   "in",
   "xrange",
   "(",
   "vectors",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ":",
   "_fillInOnTimes",
   "(",
   "vectors",
   "[",
   ":",
   ",",
   "col",
   "]",
   ",",
   "durations",
   "[",
   ":",
   ",",
   "col",
   "]",
   ")",
   "# Compute the average on time for each time step",
   "sums",
   "=",
   "vectors",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "sums",
   ".",
   "clip",
   "(",
   "<mask>",
   "=",
   "1",
   ",",
   "max",
   "=",
   "numpy",
   ".",
   "inf",
   ",",
   "out",
   "=",
   "sums",
   ")",
   "avgDurations",
   "=",
   "durations",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ",",
   "dtype",
   "=",
   "'float64'",
   ")",
   "/",
   "sums",
   "avgOnTime",
   "=",
   "avgDurations",
   ".",
   "sum",
   "(",
   ")",
   "/",
   "(",
   "avgDurations",
   ">",
   "0",
   ")",
   ".",
   "sum",
   "(",
   ")",
   "# Generate the frequency counts for each duration",
   "freqCounts",
   "=",
   "_accumulateFrequencyCounts",
   "(",
   "avgDurations",
   ")",
   "return",
   "(",
   "avgOnTime",
   ",",
   "freqCounts",
   ")"
  ]
 },
 {
  "idx": "maxmin-398",
  "nl_tokens": [
   "Compute",
   "the",
   "intersection",
   "bounding",
   "box",
   "of",
   "this",
   "bounding",
   "box",
   "and",
   "another",
   "one",
   "."
  ],
  "pl_tokens": [
   "def",
   "intersection",
   "(",
   "self",
   ",",
   "other",
   ",",
   "default",
   "=",
   "None",
   ")",
   ":",
   "x1_i",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "x1",
   ",",
   "other",
   ".",
   "x1",
   ")",
   "y1_i",
   "=",
   "max",
   "(",
   "self",
   ".",
   "y1",
   ",",
   "other",
   ".",
   "y1",
   ")",
   "x2_i",
   "=",
   "min",
   "(",
   "self",
   ".",
   "x2",
   ",",
   "other",
   ".",
   "x2",
   ")",
   "y2_i",
   "=",
   "min",
   "(",
   "self",
   ".",
   "y2",
   ",",
   "other",
   ".",
   "y2",
   ")",
   "if",
   "x1_i",
   ">",
   "x2_i",
   "or",
   "y1_i",
   ">",
   "y2_i",
   ":",
   "return",
   "default",
   "else",
   ":",
   "return",
   "BoundingBox",
   "(",
   "x1",
   "=",
   "x1_i",
   ",",
   "y1",
   "=",
   "y1_i",
   ",",
   "x2",
   "=",
   "x2_i",
   ",",
   "y2",
   "=",
   "y2_i",
   ")"
  ]
 },
 {
  "idx": "maxmin-399",
  "nl_tokens": [
   "Set",
   "pixel",
   "at",
   "(",
   "x",
   "y",
   ")",
   "point",
   "."
  ],
  "pl_tokens": [
   "def",
   "set",
   "(",
   "self",
   ",",
   "point",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "point",
   ",",
   "Point",
   ")",
   ":",
   "point",
   "=",
   "Point",
   "(",
   "point",
   ")",
   "rx",
   "=",
   "self",
   ".",
   "round",
   "(",
   "point",
   ".",
   "x",
   ")",
   "ry",
   "=",
   "self",
   ".",
   "round",
   "(",
   "point",
   ".",
   "y",
   ")",
   "item",
   "=",
   "Point",
   "(",
   "(",
   "rx",
   ">>",
   "1",
   ",",
   "<mask>",
   "(",
   "ry",
   ">>",
   "2",
   ",",
   "self",
   ".",
   "size",
   ".",
   "y",
   ")",
   ")",
   ")",
   "self",
   ".",
   "screen",
   "[",
   "item",
   "]",
   "|=",
   "self",
   ".",
   "pixels",
   "[",
   "ry",
   "&",
   "3",
   "]",
   "[",
   "rx",
   "&",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-400",
  "nl_tokens": [
   "Generate",
   "a",
   "transaction",
   "list",
   "report",
   "."
  ],
  "pl_tokens": [
   "def",
   "income_statement",
   "(",
   "self",
   ",",
   "start",
   "=",
   "datetime",
   ".",
   "<mask>",
   ",",
   "end",
   "=",
   "datetime",
   ".",
   "max",
   ",",
   "format",
   "=",
   "ReportFormat",
   ".",
   "printout",
   ",",
   "component_path",
   "=",
   "\"\"",
   ",",
   "output_path",
   "=",
   "None",
   ")",
   ":",
   "rpt",
   "=",
   "IncomeStatement",
   "(",
   "self",
   ",",
   "start",
   ",",
   "end",
   ",",
   "component_path",
   ",",
   "output_path",
   ")",
   "return",
   "rpt",
   ".",
   "render",
   "(",
   "format",
   ")"
  ]
 },
 {
  "idx": "maxmin-401",
  "nl_tokens": [
   "Round",
   "a",
   "datetime",
   "object",
   "to",
   "a",
   "multiple",
   "of",
   "a",
   "timedelta",
   "dt",
   ":",
   "datetime",
   ".",
   "datetime",
   "object",
   "default",
   "now",
   "."
  ],
  "pl_tokens": [
   "def",
   "__round_time",
   "(",
   "self",
   ",",
   "dt",
   ")",
   ":",
   "round_to",
   "=",
   "self",
   ".",
   "_resolution",
   ".",
   "total_seconds",
   "(",
   ")",
   "seconds",
   "=",
   "(",
   "dt",
   "-",
   "dt",
   ".",
   "<mask>",
   ")",
   ".",
   "seconds",
   "rounding",
   "=",
   "(",
   "seconds",
   "+",
   "round_to",
   "/",
   "2",
   ")",
   "//",
   "round_to",
   "*",
   "round_to",
   "return",
   "dt",
   "+",
   "timedelta",
   "(",
   "0",
   ",",
   "rounding",
   "-",
   "seconds",
   ",",
   "-",
   "dt",
   ".",
   "microsecond",
   ")"
  ]
 },
 {
  "idx": "maxmin-402",
  "nl_tokens": [
   "Adds",
   "a",
   "track",
   "at",
   "a",
   "specific",
   "index",
   "in",
   "the",
   "queue",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_at",
   "(",
   "self",
   ",",
   "index",
   ":",
   "int",
   ",",
   "requester",
   ":",
   "int",
   ",",
   "track",
   ":",
   "dict",
   ")",
   ":",
   "self",
   ".",
   "queue",
   ".",
   "insert",
   "(",
   "<mask>",
   "(",
   "index",
   ",",
   "len",
   "(",
   "self",
   ".",
   "queue",
   ")",
   "-",
   "1",
   ")",
   ",",
   "AudioTrack",
   "(",
   ")",
   ".",
   "build",
   "(",
   "track",
   ",",
   "requester",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-403",
  "nl_tokens": [
   "Return",
   "the",
   "MRA",
   "comparison",
   "rating",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "6",
   "if",
   "src",
   "==",
   "''",
   "or",
   "tar",
   "==",
   "''",
   ":",
   "return",
   "0",
   "src",
   "=",
   "list",
   "(",
   "mra",
   "(",
   "src",
   ")",
   ")",
   "tar",
   "=",
   "list",
   "(",
   "mra",
   "(",
   "tar",
   ")",
   ")",
   "if",
   "abs",
   "(",
   "len",
   "(",
   "src",
   ")",
   "-",
   "len",
   "(",
   "tar",
   ")",
   ")",
   ">",
   "2",
   ":",
   "return",
   "0",
   "length_sum",
   "=",
   "len",
   "(",
   "src",
   ")",
   "+",
   "len",
   "(",
   "tar",
   ")",
   "if",
   "length_sum",
   "<",
   "5",
   ":",
   "min_rating",
   "=",
   "5",
   "elif",
   "length_sum",
   "<",
   "8",
   ":",
   "min_rating",
   "=",
   "4",
   "elif",
   "length_sum",
   "<",
   "12",
   ":",
   "min_rating",
   "=",
   "3",
   "else",
   ":",
   "min_rating",
   "=",
   "2",
   "for",
   "_",
   "in",
   "range",
   "(",
   "2",
   ")",
   ":",
   "new_src",
   "=",
   "[",
   "]",
   "new_tar",
   "=",
   "[",
   "]",
   "minlen",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "minlen",
   ")",
   ":",
   "if",
   "src",
   "[",
   "i",
   "]",
   "!=",
   "tar",
   "[",
   "i",
   "]",
   ":",
   "new_src",
   ".",
   "append",
   "(",
   "src",
   "[",
   "i",
   "]",
   ")",
   "new_tar",
   ".",
   "append",
   "(",
   "tar",
   "[",
   "i",
   "]",
   ")",
   "src",
   "=",
   "new_src",
   "+",
   "src",
   "[",
   "minlen",
   ":",
   "]",
   "tar",
   "=",
   "new_tar",
   "+",
   "tar",
   "[",
   "minlen",
   ":",
   "]",
   "src",
   ".",
   "reverse",
   "(",
   ")",
   "tar",
   ".",
   "reverse",
   "(",
   ")",
   "similarity",
   "=",
   "6",
   "-",
   "max",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   "if",
   "similarity",
   ">=",
   "min_rating",
   ":",
   "return",
   "similarity",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-404",
  "nl_tokens": [
   "return",
   "probability",
   "of",
   "base",
   "call"
  ],
  "pl_tokens": [
   "def",
   "get_binom",
   "(",
   "base1",
   ",",
   "base2",
   ",",
   "estE",
   ",",
   "estH",
   ")",
   ":",
   "prior_homo",
   "=",
   "(",
   "1.",
   "-",
   "estH",
   ")",
   "/",
   "2.",
   "prior_hete",
   "=",
   "estH",
   "## calculate probs",
   "bsum",
   "=",
   "base1",
   "+",
   "base2",
   "hetprob",
   "=",
   "scipy",
   ".",
   "misc",
   ".",
   "comb",
   "(",
   "bsum",
   ",",
   "base1",
   ")",
   "/",
   "(",
   "2.",
   "**",
   "(",
   "bsum",
   ")",
   ")",
   "homoa",
   "=",
   "scipy",
   ".",
   "stats",
   ".",
   "binom",
   ".",
   "pmf",
   "(",
   "base2",
   ",",
   "bsum",
   ",",
   "estE",
   ")",
   "homob",
   "=",
   "scipy",
   ".",
   "stats",
   ".",
   "binom",
   ".",
   "pmf",
   "(",
   "base1",
   ",",
   "bsum",
   ",",
   "estE",
   ")",
   "## calculate probs",
   "hetprob",
   "*=",
   "prior_hete",
   "homoa",
   "*=",
   "prior_homo",
   "homob",
   "*=",
   "prior_homo",
   "## final ",
   "probabilities",
   "=",
   "[",
   "homoa",
   ",",
   "homob",
   ",",
   "hetprob",
   "]",
   "bestprob",
   "=",
   "<mask>",
   "(",
   "probabilities",
   ")",
   "/",
   "float",
   "(",
   "sum",
   "(",
   "probabilities",
   ")",
   ")",
   "## return",
   "if",
   "hetprob",
   ">",
   "homoa",
   ":",
   "return",
   "True",
   ",",
   "bestprob",
   "else",
   ":",
   "return",
   "False",
   ",",
   "bestprob"
  ]
 },
 {
  "idx": "maxmin-405",
  "nl_tokens": [
   "Generate",
   "a",
   "temporal",
   "dataset",
   "containing",
   "sequences",
   "that",
   "overlap",
   "one",
   "or",
   "more",
   "elements",
   "with",
   "other",
   "sequences",
   ".",
   "Parameters",
   ":",
   "----------------------------------------------------",
   "filename",
   ":",
   "name",
   "of",
   "the",
   "file",
   "to",
   "produce",
   "including",
   "extension",
   ".",
   "It",
   "will",
   "be",
   "created",
   "in",
   "a",
   "datasets",
   "sub",
   "-",
   "directory",
   "within",
   "the",
   "directory",
   "containing",
   "this",
   "script",
   ".",
   "numSequences",
   ":",
   "how",
   "many",
   "sequences",
   "to",
   "generate",
   "elementsPerSeq",
   ":",
   "length",
   "of",
   "each",
   "sequence",
   "numRepeats",
   ":",
   "how",
   "many",
   "times",
   "to",
   "repeat",
   "each",
   "sequence",
   "in",
   "the",
   "output",
   "hub",
   ":",
   "sub",
   "-",
   "sequence",
   "to",
   "place",
   "within",
   "each",
   "other",
   "sequence",
   "hubOffset",
   ":",
   "where",
   "within",
   "each",
   "sequence",
   "to",
   "place",
   "the",
   "hub",
   "resets",
   ":",
   "if",
   "True",
   "turn",
   "on",
   "reset",
   "at",
   "start",
   "of",
   "each",
   "sequence"
  ],
  "pl_tokens": [
   "def",
   "_generateOverlapping",
   "(",
   "filename",
   "=",
   "\"overlap.csv\"",
   ",",
   "numSequences",
   "=",
   "2",
   ",",
   "elementsPerSeq",
   "=",
   "3",
   ",",
   "numRepeats",
   "=",
   "10",
   ",",
   "hub",
   "=",
   "[",
   "0",
   ",",
   "1",
   "]",
   ",",
   "hubOffset",
   "=",
   "1",
   ",",
   "resets",
   "=",
   "False",
   ")",
   ":",
   "# Check for conflicts in arguments",
   "assert",
   "(",
   "hubOffset",
   "+",
   "len",
   "(",
   "hub",
   ")",
   "<=",
   "elementsPerSeq",
   ")",
   "# Create the output file",
   "scriptDir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "dirname",
   "(",
   "__file__",
   ")",
   "pathname",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "scriptDir",
   ",",
   "'datasets'",
   ",",
   "filename",
   ")",
   "print",
   "\"Creating %s...\"",
   "%",
   "(",
   "pathname",
   ")",
   "fields",
   "=",
   "[",
   "(",
   "'reset'",
   ",",
   "'int'",
   ",",
   "'R'",
   ")",
   ",",
   "(",
   "'field1'",
   ",",
   "'string'",
   ",",
   "''",
   ")",
   ",",
   "(",
   "'field2'",
   ",",
   "'float'",
   ",",
   "''",
   ")",
   "]",
   "outFile",
   "=",
   "FileRecordStream",
   "(",
   "pathname",
   ",",
   "write",
   "=",
   "True",
   ",",
   "fields",
   "=",
   "fields",
   ")",
   "# Create the sequences with the hub in the middle",
   "sequences",
   "=",
   "[",
   "]",
   "nextElemIdx",
   "=",
   "<mask>",
   "(",
   "hub",
   ")",
   "+",
   "1",
   "for",
   "_",
   "in",
   "range",
   "(",
   "numSequences",
   ")",
   ":",
   "seq",
   "=",
   "[",
   "]",
   "for",
   "j",
   "in",
   "range",
   "(",
   "hubOffset",
   ")",
   ":",
   "seq",
   ".",
   "append",
   "(",
   "nextElemIdx",
   ")",
   "nextElemIdx",
   "+=",
   "1",
   "for",
   "j",
   "in",
   "hub",
   ":",
   "seq",
   ".",
   "append",
   "(",
   "j",
   ")",
   "j",
   "=",
   "hubOffset",
   "+",
   "len",
   "(",
   "hub",
   ")",
   "while",
   "j",
   "<",
   "elementsPerSeq",
   ":",
   "seq",
   ".",
   "append",
   "(",
   "nextElemIdx",
   ")",
   "nextElemIdx",
   "+=",
   "1",
   "j",
   "+=",
   "1",
   "sequences",
   ".",
   "append",
   "(",
   "seq",
   ")",
   "# Write out the sequences in random order",
   "seqIdxs",
   "=",
   "[",
   "]",
   "for",
   "_",
   "in",
   "range",
   "(",
   "numRepeats",
   ")",
   ":",
   "seqIdxs",
   "+=",
   "range",
   "(",
   "numSequences",
   ")",
   "random",
   ".",
   "shuffle",
   "(",
   "seqIdxs",
   ")",
   "for",
   "seqIdx",
   "in",
   "seqIdxs",
   ":",
   "reset",
   "=",
   "int",
   "(",
   "resets",
   ")",
   "seq",
   "=",
   "sequences",
   "[",
   "seqIdx",
   "]",
   "for",
   "(",
   "x",
   ")",
   "in",
   "seq",
   ":",
   "outFile",
   ".",
   "appendRecord",
   "(",
   "[",
   "reset",
   ",",
   "str",
   "(",
   "x",
   ")",
   ",",
   "x",
   "]",
   ")",
   "reset",
   "=",
   "0",
   "outFile",
   ".",
   "close",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-406",
  "nl_tokens": [
   "Process",
   "a",
   "2D",
   "array",
   "(",
   "from",
   "PSFLab",
   ".",
   "mat",
   "file",
   ")",
   "containing",
   "a",
   "x",
   "-",
   "z",
   "PSF",
   "slice",
   "."
  ],
  "pl_tokens": [
   "def",
   "convert_PSFLab_xz",
   "(",
   "data",
   ",",
   "x_step",
   "=",
   "0.5",
   ",",
   "z_step",
   "=",
   "0.5",
   ",",
   "normalize",
   "=",
   "False",
   ")",
   ":",
   "z_len",
   ",",
   "x_len",
   "=",
   "data",
   ".",
   "shape",
   "hdata",
   "=",
   "data",
   "[",
   ":",
   ",",
   "(",
   "x_len",
   "-",
   "1",
   ")",
   "//",
   "2",
   ":",
   "]",
   "x",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "hdata",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "*",
   "x_step",
   "z",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "-",
   "(",
   "z_len",
   "-",
   "1",
   ")",
   "/",
   "2",
   ",",
   "(",
   "z_len",
   "-",
   "1",
   ")",
   "/",
   "2",
   "+",
   "1",
   ")",
   "*",
   "z_step",
   "if",
   "normalize",
   ":",
   "hdata",
   "/=",
   "hdata",
   ".",
   "<mask>",
   "(",
   ")",
   "# normalize to 1 at peak",
   "return",
   "x",
   ",",
   "z",
   ",",
   "hdata",
   ",",
   "hdata",
   "[",
   ":",
   ",",
   "0",
   "]",
   ".",
   "argmax",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-407",
  "nl_tokens": [
   "The",
   "range",
   "of",
   "connectedSynapses",
   "per",
   "column",
   "averaged",
   "for",
   "each",
   "dimension",
   ".",
   "This",
   "value",
   "is",
   "used",
   "to",
   "calculate",
   "the",
   "inhibition",
   "radius",
   ".",
   "This",
   "variation",
   "of",
   "the",
   "function",
   "only",
   "supports",
   "a",
   "2",
   "dimensional",
   "column",
   "topology",
   "."
  ],
  "pl_tokens": [
   "def",
   "_avgConnectedSpanForColumn2D",
   "(",
   "self",
   ",",
   "columnIndex",
   ")",
   ":",
   "assert",
   "(",
   "self",
   ".",
   "_inputDimensions",
   ".",
   "size",
   "==",
   "2",
   ")",
   "connected",
   "=",
   "self",
   ".",
   "_connectedSynapses",
   "[",
   "columnIndex",
   "]",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   "=",
   "connected",
   ".",
   "reshape",
   "(",
   "self",
   ".",
   "_inputDimensions",
   ")",
   ".",
   "nonzero",
   "(",
   ")",
   "if",
   "rows",
   ".",
   "size",
   "==",
   "0",
   "and",
   "cols",
   ".",
   "size",
   "==",
   "0",
   ":",
   "return",
   "0",
   "rowSpan",
   "=",
   "rows",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "rows",
   ".",
   "min",
   "(",
   ")",
   "+",
   "1",
   "colSpan",
   "=",
   "cols",
   ".",
   "max",
   "(",
   ")",
   "-",
   "cols",
   ".",
   "min",
   "(",
   ")",
   "+",
   "1",
   "return",
   "numpy",
   ".",
   "average",
   "(",
   "[",
   "rowSpan",
   ",",
   "colSpan",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-408",
  "nl_tokens": [
   "write",
   "the",
   "nexus",
   "output",
   "file",
   "from",
   "the",
   "tmparr",
   "[",
   "seqarray",
   "]",
   "and",
   "tmparr",
   "[",
   "maparr",
   "]"
  ],
  "pl_tokens": [
   "def",
   "write_nex",
   "(",
   "data",
   ",",
   "sidx",
   ",",
   "pnames",
   ")",
   ":",
   "## grab seq data from tmparr",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "tmparrs",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "\"tmp-{}.h5\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "name",
   ")",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "tmparrs",
   ",",
   "'r'",
   ")",
   "as",
   "io5",
   ":",
   "seqarr",
   "=",
   "io5",
   "[",
   "\"seqarr\"",
   "]",
   "## trim to size b/c it was made longer than actual",
   "end",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "seqarr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "end",
   ")",
   ":",
   "end",
   "=",
   "end",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "end",
   "=",
   "seqarr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "## write to nexus",
   "data",
   ".",
   "outfiles",
   ".",
   "nex",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".nex\"",
   ")",
   "with",
   "open",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "nex",
   ",",
   "'w'",
   ")",
   "as",
   "out",
   ":",
   "## write nexus seq header",
   "out",
   ".",
   "write",
   "(",
   "NEXHEADER",
   ".",
   "format",
   "(",
   "seqarr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "end",
   ")",
   ")",
   "## grab a big block of data",
   "chunksize",
   "=",
   "100000",
   "# this should be a multiple of 100",
   "for",
   "bidx",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "end",
   ",",
   "chunksize",
   ")",
   ":",
   "bigblock",
   "=",
   "seqarr",
   "[",
   ":",
   ",",
   "bidx",
   ":",
   "bidx",
   "+",
   "chunksize",
   "]",
   "lend",
   "=",
   "end",
   "-",
   "bidx",
   "#LOGGER.info(\"BIG: %s %s %s %s\", bigblock.shape, bidx, lend, end)",
   "## write interleaved seqs 100 chars with longname+2 before",
   "tmpout",
   "=",
   "[",
   "]",
   "for",
   "block",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "min",
   "(",
   "chunksize",
   ",",
   "lend",
   ")",
   ",",
   "100",
   ")",
   ":",
   "stop",
   "=",
   "min",
   "(",
   "block",
   "+",
   "100",
   ",",
   "end",
   ")",
   "for",
   "idx",
   ",",
   "name",
   "in",
   "enumerate",
   "(",
   "pnames",
   ")",
   ":",
   "seqdat",
   "=",
   "bigblock",
   "[",
   "idx",
   ",",
   "block",
   ":",
   "stop",
   "]",
   "tmpout",
   ".",
   "append",
   "(",
   "\"  {}{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\"",
   ".",
   "join",
   "(",
   "seqdat",
   ")",
   ")",
   ")",
   "tmpout",
   ".",
   "append",
   "(",
   "\"\\n\"",
   ")",
   "## print intermediate result and clear",
   "if",
   "any",
   "(",
   "tmpout",
   ")",
   ":",
   "out",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "tmpout",
   ")",
   ")",
   "## closer",
   "out",
   ".",
   "write",
   "(",
   "NEXCLOSER",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"finished writing nex in: %s\"",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")"
  ]
 },
 {
  "idx": "maxmin-409",
  "nl_tokens": [
   "Parses",
   "a",
   "block",
   "of",
   "text",
   "rendering",
   "links",
   "that",
   "occur",
   "on",
   "their",
   "own",
   "line",
   "normally",
   "but",
   "rendering",
   "inline",
   "links",
   "using",
   "a",
   "special",
   "template",
   "dir"
  ],
  "pl_tokens": [
   "def",
   "parse_data",
   "(",
   "self",
   ",",
   "text",
   ",",
   "maxwidth",
   ",",
   "maxheight",
   ",",
   "template_dir",
   ",",
   "context",
   ",",
   "urlize_all_links",
   ")",
   ":",
   "block_parser",
   "=",
   "TextBlockParser",
   "(",
   ")",
   "lines",
   "=",
   "text",
   ".",
   "splitlines",
   "(",
   ")",
   "parsed",
   "=",
   "[",
   "]",
   "for",
   "line",
   "in",
   "lines",
   ":",
   "if",
   "STANDALONE_URL_RE",
   ".",
   "match",
   "(",
   "line",
   ")",
   ":",
   "user_url",
   "=",
   "line",
   ".",
   "strip",
   "(",
   ")",
   "try",
   ":",
   "resource",
   "=",
   "oembed",
   ".",
   "site",
   ".",
   "embed",
   "(",
   "user_url",
   ",",
   "maxwidth",
   "=",
   "maxwidth",
   ",",
   "maxheight",
   "=",
   "maxheight",
   ")",
   "context",
   "[",
   "'minwidth'",
   "]",
   "=",
   "<mask>",
   "(",
   "maxwidth",
   ",",
   "resource",
   ".",
   "width",
   ")",
   "context",
   "[",
   "'minheight'",
   "]",
   "=",
   "min",
   "(",
   "maxheight",
   ",",
   "resource",
   ".",
   "height",
   ")",
   "except",
   "OEmbedException",
   ":",
   "if",
   "urlize_all_links",
   ":",
   "line",
   "=",
   "'<a href=\"%(LINK)s\">%(LINK)s</a>'",
   "%",
   "{",
   "'LINK'",
   ":",
   "user_url",
   "}",
   "else",
   ":",
   "context",
   "[",
   "'minwidth'",
   "]",
   "=",
   "min",
   "(",
   "maxwidth",
   ",",
   "resource",
   ".",
   "width",
   ")",
   "context",
   "[",
   "'minheight'",
   "]",
   "=",
   "min",
   "(",
   "maxheight",
   ",",
   "resource",
   ".",
   "height",
   ")",
   "line",
   "=",
   "self",
   ".",
   "render_oembed",
   "(",
   "resource",
   ",",
   "user_url",
   ",",
   "template_dir",
   "=",
   "template_dir",
   ",",
   "context",
   "=",
   "context",
   ")",
   "else",
   ":",
   "line",
   "=",
   "block_parser",
   ".",
   "parse",
   "(",
   "line",
   ",",
   "maxwidth",
   ",",
   "maxheight",
   ",",
   "'inline'",
   ",",
   "context",
   ",",
   "urlize_all_links",
   ")",
   "parsed",
   ".",
   "append",
   "(",
   "line",
   ")",
   "return",
   "mark_safe",
   "(",
   "'\\n'",
   ".",
   "join",
   "(",
   "parsed",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-410",
  "nl_tokens": [
   "get",
   "stats",
   "&",
   "show",
   "them"
  ],
  "pl_tokens": [
   "def",
   "report",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "_output",
   ".",
   "write",
   "(",
   "'\\r'",
   ")",
   "sort_by",
   "=",
   "'avg'",
   "results",
   "=",
   "{",
   "}",
   "for",
   "key",
   ",",
   "latencies",
   "in",
   "self",
   ".",
   "_latencies_by_method",
   ".",
   "items",
   "(",
   ")",
   ":",
   "result",
   "=",
   "{",
   "}",
   "result",
   "[",
   "'count'",
   "]",
   "=",
   "len",
   "(",
   "latencies",
   ")",
   "result",
   "[",
   "'avg'",
   "]",
   "=",
   "sum",
   "(",
   "latencies",
   ")",
   "/",
   "len",
   "(",
   "latencies",
   ")",
   "result",
   "[",
   "'min'",
   "]",
   "=",
   "<mask>",
   "(",
   "latencies",
   ")",
   "result",
   "[",
   "'max'",
   "]",
   "=",
   "max",
   "(",
   "latencies",
   ")",
   "latencies",
   "=",
   "sorted",
   "(",
   "latencies",
   ")",
   "result",
   "[",
   "'p90'",
   "]",
   "=",
   "percentile",
   "(",
   "latencies",
   ",",
   "0.90",
   ")",
   "result",
   "[",
   "'p95'",
   "]",
   "=",
   "percentile",
   "(",
   "latencies",
   ",",
   "0.95",
   ")",
   "result",
   "[",
   "'p99'",
   "]",
   "=",
   "percentile",
   "(",
   "latencies",
   ",",
   "0.99",
   ")",
   "result",
   "[",
   "'p999'",
   "]",
   "=",
   "percentile",
   "(",
   "latencies",
   ",",
   "0.999",
   ")",
   "results",
   "[",
   "key",
   "]",
   "=",
   "result",
   "headers",
   "=",
   "[",
   "'method'",
   ",",
   "'count'",
   ",",
   "'avg'",
   ",",
   "'min'",
   ",",
   "'max'",
   ",",
   "'p90'",
   ",",
   "'p95'",
   ",",
   "'p99'",
   ",",
   "'p999'",
   "]",
   "data",
   "=",
   "[",
   "]",
   "results",
   "=",
   "sorted",
   "(",
   "results",
   ".",
   "items",
   "(",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "it",
   ":",
   "it",
   "[",
   "1",
   "]",
   "[",
   "sort_by",
   "]",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "def",
   "row",
   "(",
   "key",
   ",",
   "res",
   ")",
   ":",
   "data",
   "=",
   "[",
   "key",
   "]",
   "+",
   "[",
   "res",
   "[",
   "header",
   "]",
   "for",
   "header",
   "in",
   "headers",
   "[",
   "1",
   ":",
   "]",
   "]",
   "return",
   "tuple",
   "(",
   "data",
   ")",
   "data",
   "=",
   "[",
   "row",
   "(",
   "key",
   ",",
   "result",
   ")",
   "for",
   "key",
   ",",
   "result",
   "in",
   "results",
   "]",
   "self",
   ".",
   "_output",
   ".",
   "write",
   "(",
   "'%s\\n'",
   "%",
   "tabulate",
   "(",
   "data",
   ",",
   "headers",
   "=",
   "headers",
   ")",
   ")",
   "self",
   ".",
   "_output",
   ".",
   "flush",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-411",
  "nl_tokens": [
   "Generate",
   "table",
   "of",
   "contents",
   "for",
   "array",
   "of",
   "section",
   "names",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_toc",
   "(",
   "sections",
   ",",
   "maxdepth",
   "=",
   "0",
   ")",
   ":",
   "if",
   "not",
   "sections",
   ":",
   "return",
   "[",
   "]",
   "outer",
   "=",
   "<mask>",
   "(",
   "n",
   "for",
   "n",
   ",",
   "t",
   "in",
   "sections",
   ")",
   "refs",
   "=",
   "[",
   "]",
   "for",
   "ind",
   ",",
   "sec",
   "in",
   "sections",
   ":",
   "if",
   "maxdepth",
   "and",
   "ind",
   "-",
   "outer",
   "+",
   "1",
   ">",
   "maxdepth",
   ":",
   "continue",
   "ref",
   "=",
   "sec",
   ".",
   "lower",
   "(",
   ")",
   "ref",
   "=",
   "ref",
   ".",
   "replace",
   "(",
   "'`'",
   ",",
   "''",
   ")",
   "ref",
   "=",
   "ref",
   ".",
   "replace",
   "(",
   "' '",
   ",",
   "'-'",
   ")",
   "ref",
   "=",
   "ref",
   ".",
   "replace",
   "(",
   "'?'",
   ",",
   "''",
   ")",
   "refs",
   ".",
   "append",
   "(",
   "\"    \"",
   "*",
   "(",
   "ind",
   "-",
   "outer",
   ")",
   "+",
   "\"- [%s](#%s)\"",
   "%",
   "(",
   "sec",
   ",",
   "ref",
   ")",
   ")",
   "return",
   "refs"
  ]
 },
 {
  "idx": "maxmin-412",
  "nl_tokens": [
   "generate",
   "word",
   "pairs",
   "for",
   "the",
   "TextRank",
   "graph"
  ],
  "pl_tokens": [
   "def",
   "get_tiles",
   "(",
   "graf",
   ",",
   "size",
   "=",
   "3",
   ")",
   ":",
   "keeps",
   "=",
   "list",
   "(",
   "filter",
   "(",
   "lambda",
   "w",
   ":",
   "w",
   ".",
   "word_id",
   ">",
   "0",
   ",",
   "graf",
   ")",
   ")",
   "keeps_len",
   "=",
   "len",
   "(",
   "keeps",
   ")",
   "for",
   "i",
   "in",
   "iter",
   "(",
   "range",
   "(",
   "0",
   ",",
   "keeps_len",
   "-",
   "1",
   ")",
   ")",
   ":",
   "w0",
   "=",
   "keeps",
   "[",
   "i",
   "]",
   "for",
   "j",
   "in",
   "iter",
   "(",
   "range",
   "(",
   "i",
   "+",
   "1",
   ",",
   "<mask>",
   "(",
   "keeps_len",
   ",",
   "i",
   "+",
   "1",
   "+",
   "size",
   ")",
   ")",
   ")",
   ":",
   "w1",
   "=",
   "keeps",
   "[",
   "j",
   "]",
   "if",
   "(",
   "w1",
   ".",
   "idx",
   "-",
   "w0",
   ".",
   "idx",
   ")",
   "<=",
   "size",
   ":",
   "yield",
   "(",
   "w0",
   ".",
   "root",
   ",",
   "w1",
   ".",
   "root",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-413",
  "nl_tokens": [
   "Perform",
   "a",
   "vector",
   "services",
   "query",
   "using",
   "the",
   "QUERY",
   "API",
   "(",
   "https",
   ":",
   "//",
   "gbdxdocs",
   ".",
   "digitalglobe",
   ".",
   "com",
   "/",
   "docs",
   "/",
   "vs",
   "-",
   "query",
   "-",
   "list",
   "-",
   "vector",
   "-",
   "items",
   "-",
   "returns",
   "-",
   "default",
   "-",
   "fields",
   ")"
  ],
  "pl_tokens": [
   "def",
   "query",
   "(",
   "self",
   ",",
   "searchAreaWkt",
   ",",
   "query",
   ",",
   "count",
   "=",
   "100",
   ",",
   "ttl",
   "=",
   "'5m'",
   ",",
   "index",
   "=",
   "default_index",
   ")",
   ":",
   "if",
   "count",
   "<",
   "1000",
   ":",
   "# issue a single page query",
   "search_area_polygon",
   "=",
   "from_wkt",
   "(",
   "searchAreaWkt",
   ")",
   "left",
   ",",
   "lower",
   ",",
   "right",
   ",",
   "upper",
   "=",
   "search_area_polygon",
   ".",
   "bounds",
   "params",
   "=",
   "{",
   "\"q\"",
   ":",
   "query",
   ",",
   "\"count\"",
   ":",
   "<mask>",
   "(",
   "count",
   ",",
   "1000",
   ")",
   ",",
   "\"left\"",
   ":",
   "left",
   ",",
   "\"right\"",
   ":",
   "right",
   ",",
   "\"lower\"",
   ":",
   "lower",
   ",",
   "\"upper\"",
   ":",
   "upper",
   "}",
   "url",
   "=",
   "self",
   ".",
   "query_index_url",
   "%",
   "index",
   "if",
   "index",
   "else",
   "self",
   ".",
   "query_url",
   "r",
   "=",
   "self",
   ".",
   "gbdx_connection",
   ".",
   "get",
   "(",
   "url",
   ",",
   "params",
   "=",
   "params",
   ")",
   "r",
   ".",
   "raise_for_status",
   "(",
   ")",
   "return",
   "r",
   ".",
   "json",
   "(",
   ")",
   "else",
   ":",
   "return",
   "list",
   "(",
   "self",
   ".",
   "query_iteratively",
   "(",
   "searchAreaWkt",
   ",",
   "query",
   ",",
   "count",
   ",",
   "ttl",
   ",",
   "index",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-414",
  "nl_tokens": [
   "This",
   "function",
   "handles",
   "the",
   "retrival",
   "of",
   "a",
   "mixtures",
   "s",
   "liquidus",
   "point",
   "."
  ],
  "pl_tokens": [
   "def",
   "Tliquidus",
   "(",
   "Tms",
   "=",
   "None",
   ",",
   "ws",
   "=",
   "None",
   ",",
   "xs",
   "=",
   "None",
   ",",
   "CASRNs",
   "=",
   "None",
   ",",
   "AvailableMethods",
   "=",
   "False",
   ",",
   "Method",
   "=",
   "None",
   ")",
   ":",
   "# pragma: no cover",
   "def",
   "list_methods",
   "(",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "]",
   "if",
   "none_and_length_check",
   "(",
   "[",
   "Tms",
   "]",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "'Maximum'",
   ")",
   "methods",
   ".",
   "append",
   "(",
   "'Simple'",
   ")",
   "methods",
   ".",
   "append",
   "(",
   "'None'",
   ")",
   "return",
   "methods",
   "if",
   "AvailableMethods",
   ":",
   "return",
   "list_methods",
   "(",
   ")",
   "if",
   "not",
   "Method",
   ":",
   "Method",
   "=",
   "list_methods",
   "(",
   ")",
   "[",
   "0",
   "]",
   "# This is the calculate, given the method section",
   "if",
   "Method",
   "==",
   "'Maximum'",
   ":",
   "_Tliq",
   "=",
   "<mask>",
   "(",
   "Tms",
   ")",
   "elif",
   "Method",
   "==",
   "'Simple'",
   ":",
   "_Tliq",
   "=",
   "mixing_simple",
   "(",
   "xs",
   ",",
   "Tms",
   ")",
   "elif",
   "Method",
   "==",
   "'None'",
   ":",
   "return",
   "None",
   "else",
   ":",
   "raise",
   "Exception",
   "(",
   "'Failure in in function'",
   ")",
   "return",
   "_Tliq"
  ]
 },
 {
  "idx": "maxmin-415",
  "nl_tokens": [
   "Generate",
   "a",
   "hash",
   "from",
   "a",
   "potentially",
   "long",
   "file",
   ".",
   "Digesting",
   "will",
   "obey",
   ":",
   "const",
   ":",
   "CHUNK_SIZE",
   "to",
   "conserve",
   "memory",
   "."
  ],
  "pl_tokens": [
   "def",
   "hashFile",
   "(",
   "handle",
   ",",
   "want_hex",
   "=",
   "False",
   ",",
   "limit",
   "=",
   "None",
   ",",
   "chunk_size",
   "=",
   "CHUNK_SIZE",
   ")",
   ":",
   "fhash",
   ",",
   "read",
   "=",
   "hashlib",
   ".",
   "sha1",
   "(",
   ")",
   ",",
   "0",
   "if",
   "isinstance",
   "(",
   "handle",
   ",",
   "basestring",
   ")",
   ":",
   "handle",
   "=",
   "file",
   "(",
   "handle",
   ",",
   "'rb'",
   ")",
   "if",
   "limit",
   ":",
   "chunk_size",
   "=",
   "<mask>",
   "(",
   "chunk_size",
   ",",
   "limit",
   ")",
   "# Chunked digest generation (conserve memory)",
   "for",
   "block",
   "in",
   "iter",
   "(",
   "lambda",
   ":",
   "handle",
   ".",
   "read",
   "(",
   "chunk_size",
   ")",
   ",",
   "''",
   ")",
   ":",
   "fhash",
   ".",
   "update",
   "(",
   "block",
   ")",
   "read",
   "+=",
   "chunk_size",
   "if",
   "0",
   "<",
   "limit",
   "<=",
   "read",
   ":",
   "break",
   "return",
   "want_hex",
   "and",
   "fhash",
   ".",
   "hexdigest",
   "(",
   ")",
   "or",
   "fhash",
   ".",
   "digest",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-416",
  "nl_tokens": [
   "Format",
   "traceback",
   "showing",
   "line",
   "number",
   "and",
   "surrounding",
   "source",
   "."
  ],
  "pl_tokens": [
   "def",
   "simple_traceback",
   "(",
   "ex",
   ",",
   "source",
   ")",
   ":",
   "exc_type",
   ",",
   "exc_value",
   ",",
   "exc_tb",
   "=",
   "sys",
   ".",
   "exc_info",
   "(",
   ")",
   "exc",
   "=",
   "traceback",
   ".",
   "format_exception",
   "(",
   "exc_type",
   ",",
   "exc_value",
   ",",
   "exc_tb",
   ")",
   "source_arr",
   "=",
   "source",
   ".",
   "splitlines",
   "(",
   ")",
   "# Defaults...",
   "exc_location",
   "=",
   "exc",
   "[",
   "-",
   "2",
   "]",
   "for",
   "i",
   ",",
   "err",
   "in",
   "enumerate",
   "(",
   "exc",
   ")",
   ":",
   "if",
   "'exec source in ns'",
   "in",
   "err",
   ":",
   "exc_location",
   "=",
   "exc",
   "[",
   "i",
   "+",
   "1",
   "]",
   "break",
   "# extract line number from traceback",
   "fn",
   "=",
   "exc_location",
   ".",
   "split",
   "(",
   "','",
   ")",
   "[",
   "0",
   "]",
   "[",
   "8",
   ":",
   "-",
   "1",
   "]",
   "line_number",
   "=",
   "int",
   "(",
   "exc_location",
   ".",
   "split",
   "(",
   "','",
   ")",
   "[",
   "1",
   "]",
   ".",
   "replace",
   "(",
   "'line'",
   ",",
   "''",
   ")",
   ".",
   "strip",
   "(",
   ")",
   ")",
   "# Build error messages",
   "err_msgs",
   "=",
   "[",
   "]",
   "# code around the error",
   "err_where",
   "=",
   "' '",
   ".",
   "join",
   "(",
   "exc",
   "[",
   "i",
   "-",
   "1",
   "]",
   ".",
   "split",
   "(",
   "','",
   ")",
   "[",
   "1",
   ":",
   "]",
   ")",
   ".",
   "strip",
   "(",
   ")",
   "# 'line 37 in blah\"",
   "err_msgs",
   ".",
   "append",
   "(",
   "'Error in the Shoebot script at %s:'",
   "%",
   "err_where",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "<mask>",
   "(",
   "0",
   ",",
   "line_number",
   "-",
   "5",
   ")",
   ",",
   "line_number",
   ")",
   ":",
   "if",
   "fn",
   "==",
   "\"<string>\"",
   ":",
   "line",
   "=",
   "source_arr",
   "[",
   "i",
   "]",
   "else",
   ":",
   "line",
   "=",
   "linecache",
   ".",
   "getline",
   "(",
   "fn",
   ",",
   "i",
   "+",
   "1",
   ")",
   "err_msgs",
   ".",
   "append",
   "(",
   "'%s: %s'",
   "%",
   "(",
   "i",
   "+",
   "1",
   ",",
   "line",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   ")",
   "err_msgs",
   ".",
   "append",
   "(",
   "'  %s^ %s'",
   "%",
   "(",
   "len",
   "(",
   "str",
   "(",
   "i",
   ")",
   ")",
   "*",
   "' '",
   ",",
   "exc",
   "[",
   "-",
   "1",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   ")",
   "err_msgs",
   ".",
   "append",
   "(",
   "''",
   ")",
   "# traceback",
   "err_msgs",
   ".",
   "append",
   "(",
   "exc",
   "[",
   "0",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   "for",
   "err",
   "in",
   "exc",
   "[",
   "3",
   ":",
   "]",
   ":",
   "err_msgs",
   ".",
   "append",
   "(",
   "err",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   "return",
   "'\\n'",
   ".",
   "join",
   "(",
   "err_msgs",
   ")"
  ]
 },
 {
  "idx": "maxmin-417",
  "nl_tokens": [
   "A",
   "loop",
   "iteration",
   "-",
   "check",
   "any",
   "scheduled",
   "events",
   "and",
   "I",
   "/",
   "O",
   "available",
   "and",
   "run",
   "the",
   "handlers",
   "."
  ],
  "pl_tokens": [
   "def",
   "loop_iteration",
   "(",
   "self",
   ",",
   "timeout",
   "=",
   "60",
   ")",
   ":",
   "if",
   "self",
   ".",
   "check_events",
   "(",
   ")",
   ":",
   "return",
   "0",
   "next_timeout",
   ",",
   "sources_handled",
   "=",
   "self",
   ".",
   "_call_timeout_handlers",
   "(",
   ")",
   "if",
   "self",
   ".",
   "_quit",
   ":",
   "return",
   "sources_handled",
   "if",
   "next_timeout",
   "is",
   "not",
   "None",
   ":",
   "timeout",
   "=",
   "<mask>",
   "(",
   "next_timeout",
   ",",
   "timeout",
   ")",
   "readable",
   ",",
   "writable",
   ",",
   "next_timeout",
   "=",
   "self",
   ".",
   "_prepare_handlers",
   "(",
   ")",
   "if",
   "next_timeout",
   "is",
   "not",
   "None",
   ":",
   "timeout",
   "=",
   "min",
   "(",
   "next_timeout",
   ",",
   "timeout",
   ")",
   "if",
   "not",
   "readable",
   "and",
   "not",
   "writable",
   ":",
   "readable",
   ",",
   "writable",
   ",",
   "_unused",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   ",",
   "None",
   "time",
   ".",
   "sleep",
   "(",
   "timeout",
   ")",
   "else",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"select({0!r}, {1!r}, [], {2!r})\"",
   ".",
   "format",
   "(",
   "readable",
   ",",
   "writable",
   ",",
   "timeout",
   ")",
   ")",
   "readable",
   ",",
   "writable",
   ",",
   "_unused",
   "=",
   "select",
   ".",
   "select",
   "(",
   "readable",
   ",",
   "writable",
   ",",
   "[",
   "]",
   ",",
   "timeout",
   ")",
   "for",
   "handler",
   "in",
   "readable",
   ":",
   "handler",
   ".",
   "handle_read",
   "(",
   ")",
   "sources_handled",
   "+=",
   "1",
   "for",
   "handler",
   "in",
   "writable",
   ":",
   "handler",
   ".",
   "handle_write",
   "(",
   ")",
   "sources_handled",
   "+=",
   "1",
   "return",
   "sources_handled"
  ]
 },
 {
  "idx": "maxmin-418",
  "nl_tokens": [
   "Moves",
   "the",
   "layer",
   "up",
   "in",
   "the",
   "stacking",
   "order",
   "."
  ],
  "pl_tokens": [
   "def",
   "up",
   "(",
   "self",
   ")",
   ":",
   "i",
   "=",
   "self",
   ".",
   "index",
   "(",
   ")",
   "if",
   "i",
   "!=",
   "None",
   ":",
   "del",
   "self",
   ".",
   "canvas",
   ".",
   "layers",
   "[",
   "i",
   "]",
   "i",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "self",
   ".",
   "canvas",
   ".",
   "layers",
   ")",
   ",",
   "i",
   "+",
   "1",
   ")",
   "self",
   ".",
   "canvas",
   ".",
   "layers",
   ".",
   "insert",
   "(",
   "i",
   ",",
   "self",
   ")"
  ]
 },
 {
  "idx": "maxmin-419",
  "nl_tokens": [
   "Solves",
   "a",
   "symbolic",
   ":",
   "class",
   ":",
   "~manticore",
   ".",
   "core",
   ".",
   "smtlib",
   ".",
   "expression",
   ".",
   "Expression",
   "into",
   "its",
   "maximum",
   "solution"
  ],
  "pl_tokens": [
   "def",
   "solve_max",
   "(",
   "self",
   ",",
   "expr",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "expr",
   ",",
   "int",
   ")",
   ":",
   "return",
   "expr",
   "expr",
   "=",
   "self",
   ".",
   "migrate_expression",
   "(",
   "expr",
   ")",
   "return",
   "self",
   ".",
   "_solver",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "expr",
   ")"
  ]
 },
 {
  "idx": "maxmin-420",
  "nl_tokens": [
   "Returns",
   "colors",
   "that",
   "are",
   "next",
   "to",
   "each",
   "other",
   "on",
   "the",
   "wheel",
   "."
  ],
  "pl_tokens": [
   "def",
   "analogous",
   "(",
   "clr",
   ",",
   "angle",
   "=",
   "10",
   ",",
   "contrast",
   "=",
   "0.25",
   ")",
   ":",
   "contrast",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "min",
   "(",
   "contrast",
   ",",
   "1.0",
   ")",
   ")",
   "clr",
   "=",
   "color",
   "(",
   "clr",
   ")",
   "colors",
   "=",
   "colorlist",
   "(",
   "clr",
   ")",
   "for",
   "i",
   ",",
   "j",
   "in",
   "[",
   "(",
   "1",
   ",",
   "2.2",
   ")",
   ",",
   "(",
   "2",
   ",",
   "1",
   ")",
   ",",
   "(",
   "-",
   "1",
   ",",
   "-",
   "0.5",
   ")",
   ",",
   "(",
   "-",
   "2",
   ",",
   "1",
   ")",
   "]",
   ":",
   "c",
   "=",
   "clr",
   ".",
   "rotate_ryb",
   "(",
   "angle",
   "*",
   "i",
   ")",
   "t",
   "=",
   "0.44",
   "-",
   "j",
   "*",
   "0.1",
   "if",
   "clr",
   ".",
   "brightness",
   "-",
   "contrast",
   "*",
   "j",
   "<",
   "t",
   ":",
   "c",
   ".",
   "brightness",
   "=",
   "t",
   "else",
   ":",
   "c",
   ".",
   "brightness",
   "=",
   "clr",
   ".",
   "brightness",
   "-",
   "contrast",
   "*",
   "j",
   "c",
   ".",
   "saturation",
   "-=",
   "0.05",
   "colors",
   ".",
   "append",
   "(",
   "c",
   ")",
   "return",
   "colors"
  ]
 },
 {
  "idx": "maxmin-421",
  "nl_tokens": [
   "Return",
   "the",
   "IBM",
   "Alpha",
   "Search",
   "Inquiry",
   "System",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "14",
   ")",
   ":",
   "alpha",
   "=",
   "[",
   "''",
   "]",
   "pos",
   "=",
   "0",
   "word",
   "=",
   "unicode_normalize",
   "(",
   "'NFKD'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "upper",
   "(",
   ")",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "word",
   "=",
   "''",
   ".",
   "join",
   "(",
   "c",
   "for",
   "c",
   "in",
   "word",
   "if",
   "c",
   "in",
   "self",
   ".",
   "_uc_set",
   ")",
   "# Clamp max_length to [4, 64]",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "4",
   ",",
   "max_length",
   ")",
   ",",
   "64",
   ")",
   "else",
   ":",
   "max_length",
   "=",
   "64",
   "# Do special processing for initial substrings",
   "for",
   "k",
   "in",
   "self",
   ".",
   "_alpha_sis_initials_order",
   ":",
   "if",
   "word",
   ".",
   "startswith",
   "(",
   "k",
   ")",
   ":",
   "alpha",
   "[",
   "0",
   "]",
   "+=",
   "self",
   ".",
   "_alpha_sis_initials",
   "[",
   "k",
   "]",
   "pos",
   "+=",
   "len",
   "(",
   "k",
   ")",
   "break",
   "# Add a '0' if alpha is still empty",
   "if",
   "not",
   "alpha",
   "[",
   "0",
   "]",
   ":",
   "alpha",
   "[",
   "0",
   "]",
   "+=",
   "'0'",
   "# Whether or not any special initial codes were encoded, iterate",
   "# through the length of the word in the main encoding loop",
   "while",
   "pos",
   "<",
   "len",
   "(",
   "word",
   ")",
   ":",
   "orig_pos",
   "=",
   "pos",
   "for",
   "k",
   "in",
   "self",
   ".",
   "_alpha_sis_basic_order",
   ":",
   "if",
   "word",
   "[",
   "pos",
   ":",
   "]",
   ".",
   "startswith",
   "(",
   "k",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "self",
   ".",
   "_alpha_sis_basic",
   "[",
   "k",
   "]",
   ",",
   "tuple",
   ")",
   ":",
   "newalpha",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_alpha_sis_basic",
   "[",
   "k",
   "]",
   ")",
   ")",
   ":",
   "newalpha",
   "+=",
   "[",
   "_",
   "+",
   "self",
   ".",
   "_alpha_sis_basic",
   "[",
   "k",
   "]",
   "[",
   "i",
   "]",
   "for",
   "_",
   "in",
   "alpha",
   "]",
   "alpha",
   "=",
   "newalpha",
   "else",
   ":",
   "alpha",
   "=",
   "[",
   "_",
   "+",
   "self",
   ".",
   "_alpha_sis_basic",
   "[",
   "k",
   "]",
   "for",
   "_",
   "in",
   "alpha",
   "]",
   "pos",
   "+=",
   "len",
   "(",
   "k",
   ")",
   "break",
   "if",
   "pos",
   "==",
   "orig_pos",
   ":",
   "alpha",
   "=",
   "[",
   "_",
   "+",
   "'_'",
   "for",
   "_",
   "in",
   "alpha",
   "]",
   "pos",
   "+=",
   "1",
   "# Trim doublets and placeholders",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "alpha",
   ")",
   ")",
   ":",
   "pos",
   "=",
   "1",
   "while",
   "pos",
   "<",
   "len",
   "(",
   "alpha",
   "[",
   "i",
   "]",
   ")",
   ":",
   "if",
   "alpha",
   "[",
   "i",
   "]",
   "[",
   "pos",
   "]",
   "==",
   "alpha",
   "[",
   "i",
   "]",
   "[",
   "pos",
   "-",
   "1",
   "]",
   ":",
   "alpha",
   "[",
   "i",
   "]",
   "=",
   "alpha",
   "[",
   "i",
   "]",
   "[",
   ":",
   "pos",
   "]",
   "+",
   "alpha",
   "[",
   "i",
   "]",
   "[",
   "pos",
   "+",
   "1",
   ":",
   "]",
   "pos",
   "+=",
   "1",
   "alpha",
   "=",
   "(",
   "_",
   ".",
   "replace",
   "(",
   "'_'",
   ",",
   "''",
   ")",
   "for",
   "_",
   "in",
   "alpha",
   ")",
   "# Trim codes and return tuple",
   "alpha",
   "=",
   "(",
   "(",
   "_",
   "+",
   "(",
   "'0'",
   "*",
   "max_length",
   ")",
   ")",
   "[",
   ":",
   "max_length",
   "]",
   "for",
   "_",
   "in",
   "alpha",
   ")",
   "return",
   "tuple",
   "(",
   "alpha",
   ")"
  ]
 },
 {
  "idx": "maxmin-422",
  "nl_tokens": [
   "Constructs",
   "a",
   "path",
   "between",
   "the",
   "given",
   "list",
   "of",
   "points",
   "."
  ],
  "pl_tokens": [
   "def",
   "findpath",
   "(",
   "self",
   ",",
   "points",
   ",",
   "curvature",
   "=",
   "1.0",
   ")",
   ":",
   "# The list of points consists of Point objects,",
   "# but it shouldn't crash on something straightforward",
   "# as someone supplying a list of (x,y)-tuples.",
   "for",
   "i",
   ",",
   "pt",
   "in",
   "enumerate",
   "(",
   "points",
   ")",
   ":",
   "if",
   "type",
   "(",
   "pt",
   ")",
   "==",
   "TupleType",
   ":",
   "points",
   "[",
   "i",
   "]",
   "=",
   "Point",
   "(",
   "pt",
   "[",
   "0",
   "]",
   ",",
   "pt",
   "[",
   "1",
   "]",
   ")",
   "if",
   "len",
   "(",
   "points",
   ")",
   "==",
   "0",
   ":",
   "return",
   "None",
   "if",
   "len",
   "(",
   "points",
   ")",
   "==",
   "1",
   ":",
   "path",
   "=",
   "self",
   ".",
   "BezierPath",
   "(",
   "None",
   ")",
   "path",
   ".",
   "moveto",
   "(",
   "points",
   "[",
   "0",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "0",
   "]",
   ".",
   "y",
   ")",
   "return",
   "path",
   "if",
   "len",
   "(",
   "points",
   ")",
   "==",
   "2",
   ":",
   "path",
   "=",
   "self",
   ".",
   "BezierPath",
   "(",
   "None",
   ")",
   "path",
   ".",
   "moveto",
   "(",
   "points",
   "[",
   "0",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "0",
   "]",
   ".",
   "y",
   ")",
   "path",
   ".",
   "lineto",
   "(",
   "points",
   "[",
   "1",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "1",
   "]",
   ".",
   "y",
   ")",
   "return",
   "path",
   "# Zero curvature means straight lines.",
   "curvature",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "min",
   "(",
   "1",
   ",",
   "curvature",
   ")",
   ")",
   "if",
   "curvature",
   "==",
   "0",
   ":",
   "path",
   "=",
   "self",
   ".",
   "BezierPath",
   "(",
   "None",
   ")",
   "path",
   ".",
   "moveto",
   "(",
   "points",
   "[",
   "0",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "0",
   "]",
   ".",
   "y",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "points",
   ")",
   ")",
   ":",
   "path",
   ".",
   "lineto",
   "(",
   "points",
   "[",
   "i",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "i",
   "]",
   ".",
   "y",
   ")",
   "return",
   "path",
   "curvature",
   "=",
   "4",
   "+",
   "(",
   "1.0",
   "-",
   "curvature",
   ")",
   "*",
   "40",
   "dx",
   "=",
   "{",
   "0",
   ":",
   "0",
   ",",
   "len",
   "(",
   "points",
   ")",
   "-",
   "1",
   ":",
   "0",
   "}",
   "dy",
   "=",
   "{",
   "0",
   ":",
   "0",
   ",",
   "len",
   "(",
   "points",
   ")",
   "-",
   "1",
   ":",
   "0",
   "}",
   "bi",
   "=",
   "{",
   "1",
   ":",
   "-",
   "0.25",
   "}",
   "ax",
   "=",
   "{",
   "1",
   ":",
   "(",
   "points",
   "[",
   "2",
   "]",
   ".",
   "x",
   "-",
   "points",
   "[",
   "0",
   "]",
   ".",
   "x",
   "-",
   "dx",
   "[",
   "0",
   "]",
   ")",
   "/",
   "4",
   "}",
   "ay",
   "=",
   "{",
   "1",
   ":",
   "(",
   "points",
   "[",
   "2",
   "]",
   ".",
   "y",
   "-",
   "points",
   "[",
   "0",
   "]",
   ".",
   "y",
   "-",
   "dy",
   "[",
   "0",
   "]",
   ")",
   "/",
   "4",
   "}",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   ",",
   "len",
   "(",
   "points",
   ")",
   "-",
   "1",
   ")",
   ":",
   "bi",
   "[",
   "i",
   "]",
   "=",
   "-",
   "1",
   "/",
   "(",
   "curvature",
   "+",
   "bi",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   "ax",
   "[",
   "i",
   "]",
   "=",
   "-",
   "(",
   "points",
   "[",
   "i",
   "+",
   "1",
   "]",
   ".",
   "x",
   "-",
   "points",
   "[",
   "i",
   "-",
   "1",
   "]",
   ".",
   "x",
   "-",
   "ax",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   "*",
   "bi",
   "[",
   "i",
   "]",
   "ay",
   "[",
   "i",
   "]",
   "=",
   "-",
   "(",
   "points",
   "[",
   "i",
   "+",
   "1",
   "]",
   ".",
   "y",
   "-",
   "points",
   "[",
   "i",
   "-",
   "1",
   "]",
   ".",
   "y",
   "-",
   "ay",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   "*",
   "bi",
   "[",
   "i",
   "]",
   "r",
   "=",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "points",
   ")",
   "-",
   "1",
   ")",
   "r",
   ".",
   "reverse",
   "(",
   ")",
   "for",
   "i",
   "in",
   "r",
   ":",
   "dx",
   "[",
   "i",
   "]",
   "=",
   "ax",
   "[",
   "i",
   "]",
   "+",
   "dx",
   "[",
   "i",
   "+",
   "1",
   "]",
   "*",
   "bi",
   "[",
   "i",
   "]",
   "dy",
   "[",
   "i",
   "]",
   "=",
   "ay",
   "[",
   "i",
   "]",
   "+",
   "dy",
   "[",
   "i",
   "+",
   "1",
   "]",
   "*",
   "bi",
   "[",
   "i",
   "]",
   "path",
   "=",
   "self",
   ".",
   "BezierPath",
   "(",
   "None",
   ")",
   "path",
   ".",
   "moveto",
   "(",
   "points",
   "[",
   "0",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "0",
   "]",
   ".",
   "y",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "points",
   ")",
   "-",
   "1",
   ")",
   ":",
   "path",
   ".",
   "curveto",
   "(",
   "points",
   "[",
   "i",
   "]",
   ".",
   "x",
   "+",
   "dx",
   "[",
   "i",
   "]",
   ",",
   "points",
   "[",
   "i",
   "]",
   ".",
   "y",
   "+",
   "dy",
   "[",
   "i",
   "]",
   ",",
   "points",
   "[",
   "i",
   "+",
   "1",
   "]",
   ".",
   "x",
   "-",
   "dx",
   "[",
   "i",
   "+",
   "1",
   "]",
   ",",
   "points",
   "[",
   "i",
   "+",
   "1",
   "]",
   ".",
   "y",
   "-",
   "dy",
   "[",
   "i",
   "+",
   "1",
   "]",
   ",",
   "points",
   "[",
   "i",
   "+",
   "1",
   "]",
   ".",
   "x",
   ",",
   "points",
   "[",
   "i",
   "+",
   "1",
   "]",
   ".",
   "y",
   ")",
   "return",
   "path"
  ]
 },
 {
  "idx": "maxmin-423",
  "nl_tokens": [
   "Returns",
   "an",
   "iterator",
   "of",
   "Period",
   "tuples",
   "for",
   "continuous",
   "stretches",
   "of",
   "time",
   "during",
   "which",
   "this",
   "event",
   "is",
   "in",
   "effect",
   "between",
   "range_start",
   "and",
   "range_end",
   "."
  ],
  "pl_tokens": [
   "def",
   "intervals",
   "(",
   "self",
   ",",
   "range_start",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "<mask>",
   ",",
   "range_end",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "max",
   ")",
   ":",
   "# At the moment the algorithm works on periods split by calendar day, one at a time,",
   "# merging them if they're continuous; to avoid looping infinitely for infinitely long",
   "# periods, it splits periods as soon as they reach 60 days.",
   "# This algorithm could likely be improved to get rid of this restriction and improve",
   "# efficiency, so code should not rely on this behaviour.",
   "current_period",
   "=",
   "None",
   "max_continuous_days",
   "=",
   "60",
   "range_start",
   "=",
   "self",
   ".",
   "to_timezone",
   "(",
   "range_start",
   ")",
   "range_end",
   "=",
   "self",
   ".",
   "to_timezone",
   "(",
   "range_end",
   ")",
   "for",
   "period",
   "in",
   "self",
   ".",
   "_daily_periods",
   "(",
   "range_start",
   ".",
   "date",
   "(",
   ")",
   ",",
   "range_end",
   ".",
   "date",
   "(",
   ")",
   ")",
   ":",
   "if",
   "period",
   ".",
   "end",
   "<",
   "range_start",
   "or",
   "period",
   ".",
   "start",
   ">",
   "range_end",
   ":",
   "continue",
   "if",
   "current_period",
   "is",
   "None",
   ":",
   "current_period",
   "=",
   "period",
   "else",
   ":",
   "if",
   "(",
   "(",
   "(",
   "period",
   ".",
   "start",
   "<",
   "current_period",
   ".",
   "end",
   ")",
   "or",
   "(",
   "period",
   ".",
   "start",
   "-",
   "current_period",
   ".",
   "end",
   ")",
   "<=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "minutes",
   "=",
   "1",
   ")",
   ")",
   "and",
   "(",
   "current_period",
   ".",
   "end",
   "-",
   "current_period",
   ".",
   "start",
   ")",
   "<",
   "datetime",
   ".",
   "timedelta",
   "(",
   "days",
   "=",
   "max_continuous_days",
   ")",
   ")",
   ":",
   "# Merge",
   "current_period",
   "=",
   "Period",
   "(",
   "current_period",
   ".",
   "start",
   ",",
   "period",
   ".",
   "end",
   ")",
   "else",
   ":",
   "yield",
   "current_period",
   "current_period",
   "=",
   "period",
   "if",
   "current_period",
   ":",
   "yield",
   "current_period"
  ]
 },
 {
  "idx": "maxmin-424",
  "nl_tokens": [
   "Projection",
   "onto",
   "the",
   "probability",
   "simplex"
  ],
  "pl_tokens": [
   "def",
   "simplex",
   "(",
   "x",
   ",",
   "rho",
   ")",
   ":",
   "# sort the elements in descending order",
   "u",
   "=",
   "np",
   ".",
   "flipud",
   "(",
   "np",
   ".",
   "sort",
   "(",
   "x",
   ".",
   "ravel",
   "(",
   ")",
   ")",
   ")",
   "lambdas",
   "=",
   "(",
   "1",
   "-",
   "np",
   ".",
   "cumsum",
   "(",
   "u",
   ")",
   ")",
   "/",
   "(",
   "1.",
   "+",
   "np",
   ".",
   "arange",
   "(",
   "u",
   ".",
   "size",
   ")",
   ")",
   "ix",
   "=",
   "np",
   ".",
   "where",
   "(",
   "u",
   "+",
   "lambdas",
   ">",
   "0",
   ")",
   "[",
   "0",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "return",
   "np",
   ".",
   "maximum",
   "(",
   "x",
   "+",
   "lambdas",
   "[",
   "ix",
   "]",
   ",",
   "0",
   ")"
  ]
 },
 {
  "idx": "maxmin-425",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "initialize",
   "the",
   "object",
   "by",
   "precomputing",
   "any",
   "values",
   "which",
   "may",
   "be",
   "used",
   "repeatedly",
   "and",
   "by",
   "retrieving",
   "mixture",
   "-",
   "specific",
   "variables",
   ".",
   "All",
   "data",
   "are",
   "stored",
   "as",
   "attributes",
   ".",
   "This",
   "method",
   "also",
   "sets",
   ":",
   "obj",
   ":",
   "Tmin",
   ":",
   "obj",
   ":",
   "Tmax",
   "and",
   ":",
   "obj",
   ":",
   "all_methods",
   "as",
   "a",
   "set",
   "of",
   "methods",
   "which",
   "should",
   "work",
   "to",
   "calculate",
   "the",
   "property",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "MIXING_LOG_MOLAR",
   ",",
   "MIXING_LOG_MASS",
   "]",
   "if",
   "len",
   "(",
   "self",
   ".",
   "CASs",
   ")",
   ">",
   "1",
   "and",
   "'7732-18-5'",
   "in",
   "self",
   ".",
   "CASs",
   ":",
   "wCASs",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "self",
   ".",
   "CASs",
   "if",
   "i",
   "!=",
   "'7732-18-5'",
   "]",
   "if",
   "all",
   "(",
   "[",
   "i",
   "in",
   "_Laliberte_Viscosity_ParametersDict",
   "for",
   "i",
   "in",
   "wCASs",
   "]",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "LALIBERTE_MU",
   ")",
   "self",
   ".",
   "wCASs",
   "=",
   "wCASs",
   "self",
   ".",
   "index_w",
   "=",
   "self",
   ".",
   "CASs",
   ".",
   "index",
   "(",
   "'7732-18-5'",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "Tmins",
   "=",
   "[",
   "i",
   ".",
   "Tmin",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ViscosityLiquids",
   "if",
   "i",
   ".",
   "Tmin",
   "]",
   "Tmaxs",
   "=",
   "[",
   "i",
   ".",
   "Tmax",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ViscosityLiquids",
   "if",
   "i",
   ".",
   "Tmax",
   "]",
   "if",
   "Tmins",
   ":",
   "self",
   ".",
   "Tmin",
   "=",
   "<mask>",
   "(",
   "Tmins",
   ")",
   "if",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmax",
   "=",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-426",
  "nl_tokens": [
   "This",
   "calculates",
   "the",
   "generalized",
   "Lomb",
   "-",
   "Scargle",
   "periodogram",
   "."
  ],
  "pl_tokens": [
   "def",
   "pgen_lsp",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "startp",
   "=",
   "None",
   ",",
   "endp",
   "=",
   "None",
   ",",
   "stepsize",
   "=",
   "1.0e-4",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "nbestpeaks",
   "=",
   "5",
   ",",
   "periodepsilon",
   "=",
   "0.1",
   ",",
   "sigclip",
   "=",
   "10.0",
   ",",
   "nworkers",
   "=",
   "None",
   ",",
   "workchunksize",
   "=",
   "None",
   ",",
   "glspfunc",
   "=",
   "_glsp_worker_withtau",
   ",",
   "verbose",
   "=",
   "True",
   ")",
   ":",
   "# get rid of nans first and sigclip",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# get rid of zero errs",
   "nzind",
   "=",
   "npnonzero",
   "(",
   "serrs",
   ")",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "stimes",
   "[",
   "nzind",
   "]",
   ",",
   "smags",
   "[",
   "nzind",
   "]",
   ",",
   "serrs",
   "[",
   "nzind",
   "]",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# get the frequencies to use",
   "if",
   "startp",
   ":",
   "endf",
   "=",
   "1.0",
   "/",
   "startp",
   "else",
   ":",
   "# default start period is 0.1 day",
   "endf",
   "=",
   "1.0",
   "/",
   "0.1",
   "if",
   "endp",
   ":",
   "startf",
   "=",
   "1.0",
   "/",
   "endp",
   "else",
   ":",
   "# default end period is length of time series",
   "startf",
   "=",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# if we're not using autofreq, then use the provided frequencies",
   "if",
   "not",
   "autofreq",
   ":",
   "omegas",
   "=",
   "2",
   "*",
   "pi_value",
   "*",
   "nparange",
   "(",
   "startf",
   ",",
   "endf",
   ",",
   "stepsize",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using %s frequency points, start P = %.3f, end P = %.3f'",
   "%",
   "(",
   "omegas",
   ".",
   "size",
   ",",
   "1.0",
   "/",
   "endf",
   ",",
   "1.0",
   "/",
   "startf",
   ")",
   ")",
   "else",
   ":",
   "# this gets an automatic grid of frequencies to use",
   "freqs",
   "=",
   "get_frequency_grid",
   "(",
   "stimes",
   ",",
   "minfreq",
   "=",
   "startf",
   ",",
   "maxfreq",
   "=",
   "endf",
   ")",
   "omegas",
   "=",
   "2",
   "*",
   "pi_value",
   "*",
   "freqs",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using autofreq with %s frequency points, '",
   "'start P = %.3f, end P = %.3f'",
   "%",
   "(",
   "omegas",
   ".",
   "size",
   ",",
   "1.0",
   "/",
   "freqs",
   ".",
   "max",
   "(",
   ")",
   ",",
   "1.0",
   "/",
   "freqs",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "# map to parallel workers",
   "if",
   "(",
   "not",
   "nworkers",
   ")",
   "or",
   "(",
   "nworkers",
   ">",
   "NCPUS",
   ")",
   ":",
   "nworkers",
   "=",
   "NCPUS",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using %s workers...'",
   "%",
   "nworkers",
   ")",
   "pool",
   "=",
   "Pool",
   "(",
   "nworkers",
   ")",
   "tasks",
   "=",
   "[",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "x",
   ")",
   "for",
   "x",
   "in",
   "omegas",
   "]",
   "if",
   "workchunksize",
   ":",
   "lsp",
   "=",
   "pool",
   ".",
   "map",
   "(",
   "glspfunc",
   ",",
   "tasks",
   ",",
   "chunksize",
   "=",
   "workchunksize",
   ")",
   "else",
   ":",
   "lsp",
   "=",
   "pool",
   ".",
   "map",
   "(",
   "glspfunc",
   ",",
   "tasks",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "del",
   "pool",
   "lsp",
   "=",
   "nparray",
   "(",
   "lsp",
   ")",
   "periods",
   "=",
   "2.0",
   "*",
   "pi_value",
   "/",
   "omegas",
   "# find the nbestpeaks for the periodogram: 1. sort the lsp array by",
   "# highest value first 2. go down the values until we find five",
   "# values that are separated by at least periodepsilon in period",
   "# make sure to filter out non-finite values of lsp",
   "finitepeakind",
   "=",
   "npisfinite",
   "(",
   "lsp",
   ")",
   "finlsp",
   "=",
   "lsp",
   "[",
   "finitepeakind",
   "]",
   "finperiods",
   "=",
   "periods",
   "[",
   "finitepeakind",
   "]",
   "# make sure that finlsp has finite values before we work on it",
   "try",
   ":",
   "bestperiodind",
   "=",
   "npargmax",
   "(",
   "finlsp",
   ")",
   "except",
   "ValueError",
   ":",
   "LOGERROR",
   "(",
   "'no finite periodogram values '",
   "'for this mag series, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'omegas'",
   ":",
   "omegas",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'gls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   "}",
   "}",
   "sortedlspind",
   "=",
   "npargsort",
   "(",
   "finlsp",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "sortedlspperiods",
   "=",
   "finperiods",
   "[",
   "sortedlspind",
   "]",
   "sortedlspvals",
   "=",
   "finlsp",
   "[",
   "sortedlspind",
   "]",
   "# now get the nbestpeaks",
   "nbestperiods",
   ",",
   "nbestlspvals",
   ",",
   "peakcount",
   "=",
   "(",
   "[",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "1",
   ")",
   "prevperiod",
   "=",
   "sortedlspperiods",
   "[",
   "0",
   "]",
   "# find the best nbestpeaks in the lsp and their periods",
   "for",
   "period",
   ",",
   "lspval",
   "in",
   "zip",
   "(",
   "sortedlspperiods",
   ",",
   "sortedlspvals",
   ")",
   ":",
   "if",
   "peakcount",
   "==",
   "nbestpeaks",
   ":",
   "break",
   "perioddiff",
   "=",
   "abs",
   "(",
   "period",
   "-",
   "prevperiod",
   ")",
   "bestperiodsdiff",
   "=",
   "[",
   "abs",
   "(",
   "period",
   "-",
   "x",
   ")",
   "for",
   "x",
   "in",
   "nbestperiods",
   "]",
   "# print('prevperiod = %s, thisperiod = %s, '",
   "#       'perioddiff = %s, peakcount = %s' %",
   "#       (prevperiod, period, perioddiff, peakcount))",
   "# this ensures that this period is different from the last",
   "# period and from all the other existing best periods by",
   "# periodepsilon to make sure we jump to an entire different peak",
   "# in the periodogram",
   "if",
   "(",
   "perioddiff",
   ">",
   "(",
   "periodepsilon",
   "*",
   "prevperiod",
   ")",
   "and",
   "all",
   "(",
   "x",
   ">",
   "(",
   "periodepsilon",
   "*",
   "period",
   ")",
   "for",
   "x",
   "in",
   "bestperiodsdiff",
   ")",
   ")",
   ":",
   "nbestperiods",
   ".",
   "append",
   "(",
   "period",
   ")",
   "nbestlspvals",
   ".",
   "append",
   "(",
   "lspval",
   ")",
   "peakcount",
   "=",
   "peakcount",
   "+",
   "1",
   "prevperiod",
   "=",
   "period",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'bestlspval'",
   ":",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "nbestlspvals",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'lspvals'",
   ":",
   "lsp",
   ",",
   "'omegas'",
   ":",
   "omegas",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'method'",
   ":",
   "'gls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   "}",
   "}",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'omegas'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'gls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   "}",
   "}"
  ]
 },
 {
  "idx": "maxmin-427",
  "nl_tokens": [
   "Create",
   "a",
   "log",
   "transform",
   "class",
   "for",
   "*",
   "base",
   "*"
  ],
  "pl_tokens": [
   "def",
   "log_trans",
   "(",
   "base",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# transform function",
   "if",
   "base",
   "is",
   "None",
   ":",
   "name",
   "=",
   "'log'",
   "base",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "1",
   ")",
   "transform",
   "=",
   "np",
   ".",
   "log",
   "elif",
   "base",
   "==",
   "10",
   ":",
   "name",
   "=",
   "'log10'",
   "transform",
   "=",
   "np",
   ".",
   "log10",
   "elif",
   "base",
   "==",
   "2",
   ":",
   "name",
   "=",
   "'log2'",
   "transform",
   "=",
   "np",
   ".",
   "log2",
   "else",
   ":",
   "name",
   "=",
   "'log{}'",
   ".",
   "format",
   "(",
   "base",
   ")",
   "def",
   "transform",
   "(",
   "x",
   ")",
   ":",
   "return",
   "np",
   ".",
   "log",
   "(",
   "x",
   ")",
   "/",
   "np",
   ".",
   "log",
   "(",
   "base",
   ")",
   "# inverse function",
   "def",
   "inverse",
   "(",
   "x",
   ")",
   ":",
   "try",
   ":",
   "return",
   "base",
   "**",
   "x",
   "except",
   "TypeError",
   ":",
   "return",
   "[",
   "base",
   "**",
   "val",
   "for",
   "val",
   "in",
   "x",
   "]",
   "if",
   "'domain'",
   "not",
   "in",
   "kwargs",
   ":",
   "kwargs",
   "[",
   "'domain'",
   "]",
   "=",
   "(",
   "sys",
   ".",
   "float_info",
   ".",
   "<mask>",
   ",",
   "np",
   ".",
   "inf",
   ")",
   "if",
   "'breaks'",
   "not",
   "in",
   "kwargs",
   ":",
   "kwargs",
   "[",
   "'breaks'",
   "]",
   "=",
   "log_breaks",
   "(",
   "base",
   "=",
   "base",
   ")",
   "kwargs",
   "[",
   "'base'",
   "]",
   "=",
   "base",
   "kwargs",
   "[",
   "'_format'",
   "]",
   "=",
   "log_format",
   "(",
   "base",
   ")",
   "_trans",
   "=",
   "trans_new",
   "(",
   "name",
   ",",
   "transform",
   ",",
   "inverse",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "if",
   "'minor_breaks'",
   "not",
   "in",
   "kwargs",
   ":",
   "n",
   "=",
   "int",
   "(",
   "base",
   ")",
   "-",
   "2",
   "_trans",
   ".",
   "minor_breaks",
   "=",
   "trans_minor_breaks",
   "(",
   "_trans",
   ",",
   "n",
   "=",
   "n",
   ")",
   "return",
   "_trans"
  ]
 },
 {
  "idx": "maxmin-428",
  "nl_tokens": [
   "checks",
   "for",
   "too",
   "many",
   "internal",
   "indels",
   "in",
   "muscle",
   "aligned",
   "clusters"
  ],
  "pl_tokens": [
   "def",
   "aligned_indel_filter",
   "(",
   "clust",
   ",",
   "max_internal_indels",
   ")",
   ":",
   "## make into list",
   "lclust",
   "=",
   "clust",
   ".",
   "split",
   "(",
   ")",
   "## paired or not",
   "try",
   ":",
   "seq1",
   "=",
   "[",
   "i",
   ".",
   "split",
   "(",
   "\"nnnn\"",
   ")",
   "[",
   "0",
   "]",
   "for",
   "i",
   "in",
   "lclust",
   "[",
   "1",
   ":",
   ":",
   "2",
   "]",
   "]",
   "seq2",
   "=",
   "[",
   "i",
   ".",
   "split",
   "(",
   "\"nnnn\"",
   ")",
   "[",
   "1",
   "]",
   "for",
   "i",
   "in",
   "lclust",
   "[",
   "1",
   ":",
   ":",
   "2",
   "]",
   "]",
   "intindels1",
   "=",
   "[",
   "i",
   ".",
   "rstrip",
   "(",
   "\"-\"",
   ")",
   ".",
   "lstrip",
   "(",
   "\"-\"",
   ")",
   ".",
   "count",
   "(",
   "\"-\"",
   ")",
   "for",
   "i",
   "in",
   "seq1",
   "]",
   "intindels2",
   "=",
   "[",
   "i",
   ".",
   "rstrip",
   "(",
   "\"-\"",
   ")",
   ".",
   "lstrip",
   "(",
   "\"-\"",
   ")",
   ".",
   "count",
   "(",
   "\"-\"",
   ")",
   "for",
   "i",
   "in",
   "seq2",
   "]",
   "intindels",
   "=",
   "intindels1",
   "+",
   "intindels2",
   "if",
   "<mask>",
   "(",
   "intindels",
   ")",
   ">",
   "max_internal_indels",
   ":",
   "return",
   "1",
   "except",
   "IndexError",
   ":",
   "seq1",
   "=",
   "lclust",
   "[",
   "1",
   ":",
   ":",
   "2",
   "]",
   "intindels",
   "=",
   "[",
   "i",
   ".",
   "rstrip",
   "(",
   "\"-\"",
   ")",
   ".",
   "lstrip",
   "(",
   "\"-\"",
   ")",
   ".",
   "count",
   "(",
   "\"-\"",
   ")",
   "for",
   "i",
   "in",
   "seq1",
   "]",
   "if",
   "max",
   "(",
   "intindels",
   ")",
   ">",
   "max_internal_indels",
   ":",
   "return",
   "1",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-429",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "longest",
   "common",
   "subsequence",
   "similarity",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "1.0",
   "elif",
   "not",
   "src",
   "or",
   "not",
   "tar",
   ":",
   "return",
   "0.0",
   "return",
   "len",
   "(",
   "self",
   ".",
   "lcsseq",
   "(",
   "src",
   ",",
   "tar",
   ")",
   ")",
   "/",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-430",
  "nl_tokens": [
   "If",
   "intervals",
   "intersect",
   "returns",
   "their",
   "intersection",
   "otherwise",
   "returns",
   "None"
  ],
  "pl_tokens": [
   "def",
   "intersection",
   "(",
   "self",
   ",",
   "i",
   ")",
   ":",
   "if",
   "self",
   ".",
   "intersects",
   "(",
   "i",
   ")",
   ":",
   "return",
   "Interval",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "start",
   ",",
   "i",
   ".",
   "start",
   ")",
   ",",
   "min",
   "(",
   "self",
   ".",
   "end",
   ",",
   "i",
   ".",
   "end",
   ")",
   ")",
   "else",
   ":",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-431",
  "nl_tokens": [
   "Multitapering",
   "spectral",
   "estimation"
  ],
  "pl_tokens": [
   "def",
   "pmtm",
   "(",
   "x",
   ",",
   "NW",
   "=",
   "None",
   ",",
   "k",
   "=",
   "None",
   ",",
   "NFFT",
   "=",
   "None",
   ",",
   "e",
   "=",
   "None",
   ",",
   "v",
   "=",
   "None",
   ",",
   "method",
   "=",
   "'adapt'",
   ",",
   "show",
   "=",
   "False",
   ")",
   ":",
   "assert",
   "method",
   "in",
   "[",
   "'adapt'",
   ",",
   "'eigen'",
   ",",
   "'unity'",
   "]",
   "N",
   "=",
   "len",
   "(",
   "x",
   ")",
   "# if dpss not provided, compute them",
   "if",
   "e",
   "is",
   "None",
   "and",
   "v",
   "is",
   "None",
   ":",
   "if",
   "NW",
   "is",
   "not",
   "None",
   ":",
   "[",
   "tapers",
   ",",
   "eigenvalues",
   "]",
   "=",
   "dpss",
   "(",
   "N",
   ",",
   "NW",
   ",",
   "k",
   "=",
   "k",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"NW must be provided (e.g. 2.5, 3, 3.5, 4\"",
   ")",
   "elif",
   "e",
   "is",
   "not",
   "None",
   "and",
   "v",
   "is",
   "not",
   "None",
   ":",
   "eigenvalues",
   "=",
   "e",
   "[",
   ":",
   "]",
   "tapers",
   "=",
   "v",
   "[",
   ":",
   "]",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"if e provided, v must be provided as well and viceversa.\"",
   ")",
   "nwin",
   "=",
   "len",
   "(",
   "eigenvalues",
   ")",
   "# length of the eigen values vector to be used later",
   "# set the NFFT",
   "if",
   "NFFT",
   "==",
   "None",
   ":",
   "NFFT",
   "=",
   "<mask>",
   "(",
   "256",
   ",",
   "2",
   "**",
   "nextpow2",
   "(",
   "N",
   ")",
   ")",
   "Sk_complex",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "np",
   ".",
   "multiply",
   "(",
   "tapers",
   ".",
   "transpose",
   "(",
   ")",
   ",",
   "x",
   ")",
   ",",
   "NFFT",
   ")",
   "Sk",
   "=",
   "abs",
   "(",
   "Sk_complex",
   ")",
   "**",
   "2",
   "# si nfft smaller thqn N, cut otherwise add wero.",
   "# compute",
   "if",
   "method",
   "in",
   "[",
   "'eigen'",
   ",",
   "'unity'",
   "]",
   ":",
   "if",
   "method",
   "==",
   "'unity'",
   ":",
   "weights",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "nwin",
   ",",
   "1",
   ")",
   ")",
   "elif",
   "method",
   "==",
   "'eigen'",
   ":",
   "# The S_k spectrum can be weighted by the eigenvalues, as in Park et al.",
   "weights",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "_x",
   "/",
   "float",
   "(",
   "i",
   "+",
   "1",
   ")",
   "for",
   "i",
   ",",
   "_x",
   "in",
   "enumerate",
   "(",
   "eigenvalues",
   ")",
   "]",
   ")",
   "weights",
   "=",
   "weights",
   ".",
   "reshape",
   "(",
   "nwin",
   ",",
   "1",
   ")",
   "elif",
   "method",
   "==",
   "'adapt'",
   ":",
   "# This version uses the equations from [2] (P&W pp 368-370).",
   "# Wrap the data modulo nfft if N > nfft",
   "sig2",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "x",
   ",",
   "x",
   ")",
   "/",
   "float",
   "(",
   "N",
   ")",
   "Sk",
   "=",
   "abs",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "np",
   ".",
   "multiply",
   "(",
   "tapers",
   ".",
   "transpose",
   "(",
   ")",
   ",",
   "x",
   ")",
   ",",
   "NFFT",
   ")",
   ")",
   "**",
   "2",
   "Sk",
   "=",
   "Sk",
   ".",
   "transpose",
   "(",
   ")",
   "S",
   "=",
   "(",
   "Sk",
   "[",
   ":",
   ",",
   "0",
   "]",
   "+",
   "Sk",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "/",
   "2",
   "# Initial spectrum estimate",
   "S",
   "=",
   "S",
   ".",
   "reshape",
   "(",
   "NFFT",
   ",",
   "1",
   ")",
   "Stemp",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "NFFT",
   ",",
   "1",
   ")",
   ")",
   "S1",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "NFFT",
   ",",
   "1",
   ")",
   ")",
   "# Set tolerance for acceptance of spectral estimate:",
   "tol",
   "=",
   "0.0005",
   "*",
   "sig2",
   "/",
   "float",
   "(",
   "NFFT",
   ")",
   "i",
   "=",
   "0",
   "a",
   "=",
   "sig2",
   "*",
   "(",
   "1",
   "-",
   "eigenvalues",
   ")",
   "# converges very quickly but for safety; set i<100",
   "while",
   "sum",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "S",
   "-",
   "S1",
   ")",
   ")",
   "/",
   "NFFT",
   ">",
   "tol",
   "and",
   "i",
   "<",
   "100",
   ":",
   "i",
   "=",
   "i",
   "+",
   "1",
   "# calculate weights",
   "b1",
   "=",
   "np",
   ".",
   "multiply",
   "(",
   "S",
   ",",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "1",
   ",",
   "nwin",
   ")",
   ")",
   ")",
   "b2",
   "=",
   "np",
   ".",
   "multiply",
   "(",
   "S",
   ",",
   "eigenvalues",
   ".",
   "transpose",
   "(",
   ")",
   ")",
   "+",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "NFFT",
   ",",
   "1",
   ")",
   ")",
   "*",
   "a",
   ".",
   "transpose",
   "(",
   ")",
   "b",
   "=",
   "b1",
   "/",
   "b2",
   "# calculate new spectral estimate",
   "wk",
   "=",
   "(",
   "b",
   "**",
   "2",
   ")",
   "*",
   "(",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "NFFT",
   ",",
   "1",
   ")",
   ")",
   "*",
   "eigenvalues",
   ".",
   "transpose",
   "(",
   ")",
   ")",
   "S1",
   "=",
   "sum",
   "(",
   "wk",
   ".",
   "transpose",
   "(",
   ")",
   "*",
   "Sk",
   ".",
   "transpose",
   "(",
   ")",
   ")",
   "/",
   "sum",
   "(",
   "wk",
   ".",
   "transpose",
   "(",
   ")",
   ")",
   "S1",
   "=",
   "S1",
   ".",
   "reshape",
   "(",
   "NFFT",
   ",",
   "1",
   ")",
   "Stemp",
   "=",
   "S1",
   "S1",
   "=",
   "S",
   "S",
   "=",
   "Stemp",
   "# swap S and S1",
   "weights",
   "=",
   "wk",
   "if",
   "show",
   "is",
   "True",
   ":",
   "from",
   "pylab",
   "import",
   "semilogy",
   "if",
   "method",
   "==",
   "\"adapt\"",
   ":",
   "Sk",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "Sk",
   "*",
   "weights",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "else",
   ":",
   "Sk",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "Sk",
   "*",
   "weights",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "semilogy",
   "(",
   "Sk",
   ")",
   "return",
   "Sk_complex",
   ",",
   "weights",
   ",",
   "eigenvalues"
  ]
 },
 {
  "idx": "maxmin-432",
  "nl_tokens": [
   "Generate",
   "a",
   "bounding",
   "box",
   "encapsulating",
   "the",
   "line",
   "string",
   "."
  ],
  "pl_tokens": [
   "def",
   "to_bounding_box",
   "(",
   "self",
   ")",
   ":",
   "from",
   ".",
   "bbs",
   "import",
   "BoundingBox",
   "# we don't have to mind the case of len(.) == 1 here, because",
   "# zero-sized BBs are considered valid",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coords",
   ")",
   "==",
   "0",
   ":",
   "return",
   "None",
   "return",
   "BoundingBox",
   "(",
   "x1",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "xx",
   ")",
   ",",
   "y1",
   "=",
   "np",
   ".",
   "min",
   "(",
   "self",
   ".",
   "yy",
   ")",
   ",",
   "x2",
   "=",
   "np",
   ".",
   "max",
   "(",
   "self",
   ".",
   "xx",
   ")",
   ",",
   "y2",
   "=",
   "np",
   ".",
   "max",
   "(",
   "self",
   ".",
   "yy",
   ")",
   ",",
   "label",
   "=",
   "self",
   ".",
   "label",
   ")"
  ]
 },
 {
  "idx": "maxmin-433",
  "nl_tokens": [
   "used",
   "when",
   "allocating",
   "memory",
   "ingame"
  ],
  "pl_tokens": [
   "def",
   "mem_size",
   "(",
   "self",
   ")",
   ":",
   "data_len",
   "=",
   "self",
   ".",
   "_data_mem_size",
   "node_count",
   "=",
   "len",
   "(",
   "list",
   "(",
   "self",
   ".",
   "xml_doc",
   ".",
   "iter",
   "(",
   "tag",
   "=",
   "etree",
   ".",
   "Element",
   ")",
   ")",
   ")",
   "if",
   "self",
   ".",
   "compressed",
   ":",
   "size",
   "=",
   "52",
   "*",
   "node_count",
   "+",
   "data_len",
   "+",
   "630",
   "else",
   ":",
   "tags_len",
   "=",
   "0",
   "for",
   "e",
   "in",
   "self",
   ".",
   "xml_doc",
   ".",
   "iter",
   "(",
   "tag",
   "=",
   "etree",
   ".",
   "Element",
   ")",
   ":",
   "e_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "e",
   ".",
   "tag",
   ")",
   ",",
   "8",
   ")",
   "e_len",
   "=",
   "(",
   "e_len",
   "+",
   "3",
   ")",
   "&",
   "~",
   "3",
   "tags_len",
   "+=",
   "e_len",
   "size",
   "=",
   "56",
   "*",
   "node_count",
   "+",
   "data_len",
   "+",
   "630",
   "+",
   "tags_len",
   "# debugging",
   "#print('nodes:{} ({}) data:{} ({})'.format(node_count,hex(node_count), data_len, hex(data_len)))",
   "return",
   "(",
   "size",
   "+",
   "8",
   ")",
   "&",
   "~",
   "7"
  ]
 },
 {
  "idx": "maxmin-434",
  "nl_tokens": [
   "Search",
   "game",
   "to",
   "determine",
   "best",
   "action",
   ";",
   "use",
   "alpha",
   "-",
   "beta",
   "pruning",
   ".",
   "This",
   "version",
   "cuts",
   "off",
   "search",
   "and",
   "uses",
   "an",
   "evaluation",
   "function",
   "."
  ],
  "pl_tokens": [
   "def",
   "alphabeta_search",
   "(",
   "state",
   ",",
   "game",
   ",",
   "d",
   "=",
   "4",
   ",",
   "cutoff_test",
   "=",
   "None",
   ",",
   "eval_fn",
   "=",
   "None",
   ")",
   ":",
   "player",
   "=",
   "game",
   ".",
   "to_move",
   "(",
   "state",
   ")",
   "def",
   "max_value",
   "(",
   "state",
   ",",
   "alpha",
   ",",
   "beta",
   ",",
   "depth",
   ")",
   ":",
   "if",
   "cutoff_test",
   "(",
   "state",
   ",",
   "depth",
   ")",
   ":",
   "return",
   "eval_fn",
   "(",
   "state",
   ")",
   "v",
   "=",
   "-",
   "infinity",
   "for",
   "a",
   "in",
   "game",
   ".",
   "actions",
   "(",
   "state",
   ")",
   ":",
   "v",
   "=",
   "<mask>",
   "(",
   "v",
   ",",
   "min_value",
   "(",
   "game",
   ".",
   "result",
   "(",
   "state",
   ",",
   "a",
   ")",
   ",",
   "alpha",
   ",",
   "beta",
   ",",
   "depth",
   "+",
   "1",
   ")",
   ")",
   "if",
   "v",
   ">=",
   "beta",
   ":",
   "return",
   "v",
   "alpha",
   "=",
   "max",
   "(",
   "alpha",
   ",",
   "v",
   ")",
   "return",
   "v",
   "def",
   "min_value",
   "(",
   "state",
   ",",
   "alpha",
   ",",
   "beta",
   ",",
   "depth",
   ")",
   ":",
   "if",
   "cutoff_test",
   "(",
   "state",
   ",",
   "depth",
   ")",
   ":",
   "return",
   "eval_fn",
   "(",
   "state",
   ")",
   "v",
   "=",
   "infinity",
   "for",
   "a",
   "in",
   "game",
   ".",
   "actions",
   "(",
   "state",
   ")",
   ":",
   "v",
   "=",
   "min",
   "(",
   "v",
   ",",
   "max_value",
   "(",
   "game",
   ".",
   "result",
   "(",
   "state",
   ",",
   "a",
   ")",
   ",",
   "alpha",
   ",",
   "beta",
   ",",
   "depth",
   "+",
   "1",
   ")",
   ")",
   "if",
   "v",
   "<=",
   "alpha",
   ":",
   "return",
   "v",
   "beta",
   "=",
   "min",
   "(",
   "beta",
   ",",
   "v",
   ")",
   "return",
   "v",
   "# Body of alphabeta_search starts here:",
   "# The default test cuts off at depth d or at a terminal state",
   "cutoff_test",
   "=",
   "(",
   "cutoff_test",
   "or",
   "(",
   "lambda",
   "state",
   ",",
   "depth",
   ":",
   "depth",
   ">",
   "d",
   "or",
   "game",
   ".",
   "terminal_test",
   "(",
   "state",
   ")",
   ")",
   ")",
   "eval_fn",
   "=",
   "eval_fn",
   "or",
   "(",
   "lambda",
   "state",
   ":",
   "game",
   ".",
   "utility",
   "(",
   "state",
   ",",
   "player",
   ")",
   ")",
   "return",
   "argmax",
   "(",
   "game",
   ".",
   "actions",
   "(",
   "state",
   ")",
   ",",
   "lambda",
   "a",
   ":",
   "min_value",
   "(",
   "game",
   ".",
   "result",
   "(",
   "state",
   ",",
   "a",
   ")",
   ",",
   "-",
   "infinity",
   ",",
   "infinity",
   ",",
   "0",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-435",
  "nl_tokens": [
   "Calibrate",
   "noisy",
   "variance",
   "estimates",
   "with",
   "empirical",
   "Bayes",
   "."
  ],
  "pl_tokens": [
   "def",
   "calibrateEB",
   "(",
   "variances",
   ",",
   "sigma2",
   ")",
   ":",
   "if",
   "(",
   "sigma2",
   "<=",
   "0",
   "or",
   "<mask>",
   "(",
   "variances",
   ")",
   "==",
   "max",
   "(",
   "variances",
   ")",
   ")",
   ":",
   "return",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "variances",
   ",",
   "0",
   ")",
   ")",
   "sigma",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "sigma2",
   ")",
   "eb_prior",
   "=",
   "gfit",
   "(",
   "variances",
   ",",
   "sigma",
   ")",
   "# Set up a partial execution of the function",
   "part",
   "=",
   "functools",
   ".",
   "partial",
   "(",
   "gbayes",
   ",",
   "g_est",
   "=",
   "eb_prior",
   ",",
   "sigma",
   "=",
   "sigma",
   ")",
   "if",
   "len",
   "(",
   "variances",
   ")",
   ">=",
   "200",
   ":",
   "# Interpolate to speed up computations:",
   "calib_x",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "variances",
   ",",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "102",
   ",",
   "2",
   ")",
   ")",
   "calib_y",
   "=",
   "list",
   "(",
   "map",
   "(",
   "part",
   ",",
   "calib_x",
   ")",
   ")",
   "calib_all",
   "=",
   "np",
   ".",
   "interp",
   "(",
   "variances",
   ",",
   "calib_x",
   ",",
   "calib_y",
   ")",
   "else",
   ":",
   "calib_all",
   "=",
   "list",
   "(",
   "map",
   "(",
   "part",
   ",",
   "variances",
   ")",
   ")",
   "return",
   "np",
   ".",
   "asarray",
   "(",
   "calib_all",
   ")"
  ]
 },
 {
  "idx": "maxmin-436",
  "nl_tokens": [
   "Renders",
   "an",
   "ASCII",
   "-",
   "table",
   "of",
   "the",
   "synchronization",
   "statistics",
   "stats",
   "example",
   "output",
   ":"
  ],
  "pl_tokens": [
   "def",
   "describeStats",
   "(",
   "stats",
   ",",
   "stream",
   ",",
   "title",
   "=",
   "None",
   ",",
   "details",
   "=",
   "True",
   ",",
   "totals",
   "=",
   "True",
   ",",
   "gettext",
   "=",
   "None",
   ")",
   ":",
   "from",
   ".",
   "import",
   "state",
   "modeStringLut",
   "=",
   "dict",
   "(",
   "(",
   "(",
   "constants",
   ".",
   "SYNCTYPE_TWO_WAY",
   ",",
   "'<>'",
   ")",
   ",",
   "(",
   "constants",
   ".",
   "SYNCTYPE_SLOW_SYNC",
   ",",
   "'SS'",
   ")",
   ",",
   "(",
   "constants",
   ".",
   "SYNCTYPE_ONE_WAY_FROM_CLIENT",
   ",",
   "'->'",
   ")",
   ",",
   "(",
   "constants",
   ".",
   "SYNCTYPE_REFRESH_FROM_CLIENT",
   ",",
   "'=>'",
   ")",
   ",",
   "(",
   "constants",
   ".",
   "SYNCTYPE_ONE_WAY_FROM_SERVER",
   ",",
   "'<-'",
   ")",
   ",",
   "(",
   "constants",
   ".",
   "SYNCTYPE_REFRESH_FROM_SERVER",
   ",",
   "'<='",
   ")",
   ",",
   ")",
   ")",
   "if",
   "gettext",
   "is",
   "not",
   "None",
   ":",
   "_",
   "=",
   "gettext",
   "else",
   ":",
   "_",
   "=",
   "lambda",
   "s",
   ":",
   "s",
   "# todo: this does not handle the case where the title is wider than the table.",
   "wSrc",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Source'",
   ")",
   ")",
   "wMode",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Mode'",
   ")",
   ")",
   "wCon",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Conflicts'",
   ")",
   ")",
   "wCol",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Col'",
   ")",
   ")",
   "wMrg",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Mrg'",
   ")",
   ")",
   "wHereAdd",
   "=",
   "wPeerAdd",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Add'",
   ")",
   ")",
   "wHereMod",
   "=",
   "wPeerMod",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Mod'",
   ")",
   ")",
   "wHereDel",
   "=",
   "wPeerDel",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Del'",
   ")",
   ")",
   "wHereErr",
   "=",
   "wPeerErr",
   "=",
   "len",
   "(",
   "_",
   "(",
   "'Err'",
   ")",
   ")",
   "totLoc",
   "=",
   "0",
   "totRem",
   "=",
   "0",
   "totErr",
   "=",
   "0",
   "totCol",
   "=",
   "0",
   "totMrg",
   "=",
   "0",
   "for",
   "key",
   "in",
   "stats",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "wSrc",
   "=",
   "<mask>",
   "(",
   "wSrc",
   ",",
   "len",
   "(",
   "key",
   ")",
   ")",
   "wMode",
   "=",
   "max",
   "(",
   "wMode",
   ",",
   "len",
   "(",
   "modeStringLut",
   ".",
   "get",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "mode",
   ")",
   ")",
   ")",
   "wCol",
   "=",
   "max",
   "(",
   "wCol",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "conflicts",
   ")",
   ")",
   ")",
   "wMrg",
   "=",
   "max",
   "(",
   "wMrg",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "merged",
   ")",
   ")",
   ")",
   "wHereAdd",
   "=",
   "max",
   "(",
   "wHereAdd",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereAdd",
   ")",
   ")",
   ")",
   "wPeerAdd",
   "=",
   "max",
   "(",
   "wPeerAdd",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerAdd",
   ")",
   ")",
   ")",
   "wHereMod",
   "=",
   "max",
   "(",
   "wHereMod",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereMod",
   ")",
   ")",
   ")",
   "wPeerMod",
   "=",
   "max",
   "(",
   "wPeerMod",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerMod",
   ")",
   ")",
   ")",
   "wHereDel",
   "=",
   "max",
   "(",
   "wHereDel",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereDel",
   ")",
   ")",
   ")",
   "wPeerDel",
   "=",
   "max",
   "(",
   "wPeerDel",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerDel",
   ")",
   ")",
   ")",
   "wHereErr",
   "=",
   "max",
   "(",
   "wHereErr",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereErr",
   ")",
   ")",
   ")",
   "wPeerErr",
   "=",
   "max",
   "(",
   "wPeerErr",
   ",",
   "len",
   "(",
   "num2str",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerErr",
   ")",
   ")",
   ")",
   "totLoc",
   "+=",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereAdd",
   "+",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereMod",
   "+",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereDel",
   "totRem",
   "+=",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerAdd",
   "+",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerMod",
   "+",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerDel",
   "totErr",
   "+=",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereErr",
   "+",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerErr",
   "totCol",
   "+=",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "conflicts",
   "totMrg",
   "+=",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "merged",
   "# TODO: i'm 100% sure there is a python library that can do this for me...",
   "if",
   "wCon",
   ">",
   "wCol",
   "+",
   "3",
   "+",
   "wMrg",
   ":",
   "diff",
   "=",
   "wCon",
   "-",
   "(",
   "wCol",
   "+",
   "3",
   "+",
   "wMrg",
   ")",
   "wCol",
   "+=",
   "diff",
   "/",
   "2",
   "wMrg",
   "=",
   "wCon",
   "-",
   "3",
   "-",
   "wCol",
   "else",
   ":",
   "wCon",
   "=",
   "wCol",
   "+",
   "3",
   "+",
   "wMrg",
   "if",
   "details",
   ":",
   "tWid",
   "=",
   "(",
   "wSrc",
   "+",
   "3",
   "+",
   "wMode",
   "+",
   "3",
   "+",
   "wHereAdd",
   "+",
   "wHereMod",
   "+",
   "wHereDel",
   "+",
   "wHereErr",
   "+",
   "9",
   "+",
   "3",
   "+",
   "wPeerAdd",
   "+",
   "wPeerMod",
   "+",
   "wPeerDel",
   "+",
   "wPeerErr",
   "+",
   "9",
   "+",
   "3",
   "+",
   "wCon",
   ")",
   "else",
   ":",
   "if",
   "title",
   "is",
   "None",
   ":",
   "tWid",
   "=",
   "0",
   "else",
   ":",
   "tWid",
   "=",
   "len",
   "(",
   "title",
   ")",
   "if",
   "totals",
   ":",
   "# TODO: oh dear. from an i18n POV, this is *horrible*!...",
   "sumlist",
   "=",
   "[",
   "]",
   "for",
   "val",
   ",",
   "singular",
   ",",
   "plural",
   "in",
   "[",
   "(",
   "totLoc",
   ",",
   "_",
   "(",
   "'local change'",
   ")",
   ",",
   "_",
   "(",
   "'local changes'",
   ")",
   ")",
   ",",
   "(",
   "totRem",
   ",",
   "_",
   "(",
   "'remote change'",
   ")",
   ",",
   "_",
   "(",
   "'remote changes'",
   ")",
   ")",
   ",",
   "(",
   "totErr",
   ",",
   "_",
   "(",
   "'error'",
   ")",
   ",",
   "_",
   "(",
   "'errors'",
   ")",
   ")",
   ",",
   "]",
   ":",
   "if",
   "val",
   "==",
   "1",
   ":",
   "sumlist",
   ".",
   "append",
   "(",
   "num2str",
   "(",
   "val",
   ")",
   "+",
   "' '",
   "+",
   "singular",
   ")",
   "elif",
   "val",
   ">",
   "1",
   ":",
   "sumlist",
   ".",
   "append",
   "(",
   "num2str",
   "(",
   "val",
   ")",
   "+",
   "' '",
   "+",
   "plural",
   ")",
   "if",
   "len",
   "(",
   "sumlist",
   ")",
   "<=",
   "0",
   ":",
   "sumlist",
   "=",
   "_",
   "(",
   "'No changes'",
   ")",
   "elif",
   "len",
   "(",
   "sumlist",
   ")",
   "==",
   "1",
   ":",
   "sumlist",
   "=",
   "sumlist",
   "[",
   "0",
   "]",
   "else",
   ":",
   "sumlist",
   "=",
   "', '",
   ".",
   "join",
   "(",
   "sumlist",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   "+",
   "' '",
   "+",
   "_",
   "(",
   "'and'",
   ")",
   "+",
   "' '",
   "+",
   "sumlist",
   "[",
   "-",
   "1",
   "]",
   "if",
   "totMrg",
   ">",
   "0",
   "or",
   "totCol",
   ">",
   "0",
   ":",
   "sumlist",
   "+=",
   "': '",
   "if",
   "totMrg",
   "==",
   "1",
   ":",
   "sumlist",
   "+=",
   "num2str",
   "(",
   "totMrg",
   ")",
   "+",
   "' '",
   "+",
   "_",
   "(",
   "'merge'",
   ")",
   "elif",
   "totMrg",
   ">",
   "1",
   ":",
   "sumlist",
   "+=",
   "num2str",
   "(",
   "totMrg",
   ")",
   "+",
   "' '",
   "+",
   "_",
   "(",
   "'merges'",
   ")",
   "if",
   "totMrg",
   ">",
   "0",
   "and",
   "totCol",
   ">",
   "0",
   ":",
   "sumlist",
   "+=",
   "' '",
   "+",
   "_",
   "(",
   "'and'",
   ")",
   "+",
   "' '",
   "if",
   "totCol",
   "==",
   "1",
   ":",
   "sumlist",
   "+=",
   "num2str",
   "(",
   "totCol",
   ")",
   "+",
   "' '",
   "+",
   "_",
   "(",
   "'conflict'",
   ")",
   "elif",
   "totCol",
   ">",
   "1",
   ":",
   "sumlist",
   "+=",
   "num2str",
   "(",
   "totCol",
   ")",
   "+",
   "' '",
   "+",
   "_",
   "(",
   "'conflicts'",
   ")",
   "sumlist",
   "+=",
   "'.'",
   "if",
   "len",
   "(",
   "sumlist",
   ")",
   ">",
   "tWid",
   ":",
   "wSrc",
   "+=",
   "len",
   "(",
   "sumlist",
   ")",
   "-",
   "tWid",
   "tWid",
   "=",
   "len",
   "(",
   "sumlist",
   ")",
   "if",
   "title",
   "is",
   "not",
   "None",
   ":",
   "stream",
   ".",
   "write",
   "(",
   "'+-'",
   "+",
   "'-'",
   "*",
   "tWid",
   "+",
   "'-+\\n'",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "'| {0: ^{w}}'",
   ".",
   "format",
   "(",
   "title",
   ",",
   "w",
   "=",
   "tWid",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' |\\n'",
   ")",
   "hline",
   "=",
   "'+-'",
   "+",
   "'-'",
   "*",
   "wSrc",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wMode",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "(",
   "wHereAdd",
   "+",
   "wHereMod",
   "+",
   "wHereDel",
   "+",
   "wHereErr",
   "+",
   "9",
   ")",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "(",
   "wPeerAdd",
   "+",
   "wPeerMod",
   "+",
   "wPeerDel",
   "+",
   "wPeerErr",
   "+",
   "9",
   ")",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wCon",
   "+",
   "'-+\\n'",
   "if",
   "details",
   ":",
   "stream",
   ".",
   "write",
   "(",
   "hline",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "'| '",
   "+",
   "' '",
   "*",
   "wSrc",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | '",
   "+",
   "' '",
   "*",
   "wMode",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Local'",
   ")",
   ",",
   "w",
   "=",
   "(",
   "wHereAdd",
   "+",
   "wHereMod",
   "+",
   "wHereDel",
   "+",
   "wHereErr",
   "+",
   "9",
   ")",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Remote'",
   ")",
   ",",
   "w",
   "=",
   "(",
   "wPeerAdd",
   "+",
   "wPeerMod",
   "+",
   "wPeerDel",
   "+",
   "wPeerErr",
   "+",
   "9",
   ")",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Conflicts'",
   ")",
   ",",
   "w",
   "=",
   "wCon",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' |\\n'",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "'| {0: >{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Source'",
   ")",
   ",",
   "w",
   "=",
   "wSrc",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: >{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Mode'",
   ")",
   ",",
   "w",
   "=",
   "wMode",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Add'",
   ")",
   ",",
   "w",
   "=",
   "wHereAdd",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Mod'",
   ")",
   ",",
   "w",
   "=",
   "wHereMod",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Del'",
   ")",
   ",",
   "w",
   "=",
   "wHereDel",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Err'",
   ")",
   ",",
   "w",
   "=",
   "wHereErr",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Add'",
   ")",
   ",",
   "w",
   "=",
   "wPeerAdd",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Mod'",
   ")",
   ",",
   "w",
   "=",
   "wPeerMod",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Del'",
   ")",
   ",",
   "w",
   "=",
   "wPeerDel",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Err'",
   ")",
   ",",
   "w",
   "=",
   "wPeerErr",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Col'",
   ")",
   ",",
   "w",
   "=",
   "wCol",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "_",
   "(",
   "'Mrg'",
   ")",
   ",",
   "w",
   "=",
   "wMrg",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' |\\n'",
   ")",
   "hsline",
   "=",
   "'+-'",
   "+",
   "'-'",
   "*",
   "wSrc",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wMode",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wHereAdd",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wHereMod",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wHereDel",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wHereErr",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wPeerAdd",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wPeerMod",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wPeerDel",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wPeerErr",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wCol",
   "+",
   "'-+-'",
   "+",
   "'-'",
   "*",
   "wMrg",
   "+",
   "'-+\\n'",
   "stream",
   ".",
   "write",
   "(",
   "hsline",
   ")",
   "def",
   "numcol",
   "(",
   "val",
   ",",
   "wid",
   ")",
   ":",
   "if",
   "val",
   "==",
   "0",
   ":",
   "return",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "'-'",
   ",",
   "w",
   "=",
   "wid",
   ")",
   "return",
   "' | {0: >{w}}'",
   ".",
   "format",
   "(",
   "num2str",
   "(",
   "val",
   ")",
   ",",
   "w",
   "=",
   "wid",
   ")",
   "for",
   "key",
   "in",
   "sorted",
   "(",
   "stats",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "k",
   ":",
   "str",
   "(",
   "k",
   ")",
   ".",
   "lower",
   "(",
   ")",
   ")",
   ":",
   "stream",
   ".",
   "write",
   "(",
   "'| {0: >{w}}'",
   ".",
   "format",
   "(",
   "key",
   ",",
   "w",
   "=",
   "wSrc",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' | {0: ^{w}}'",
   ".",
   "format",
   "(",
   "modeStringLut",
   ".",
   "get",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "mode",
   ")",
   ",",
   "w",
   "=",
   "wMode",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereAdd",
   ",",
   "wHereAdd",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereMod",
   ",",
   "wHereMod",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereDel",
   ",",
   "wHereDel",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "hereErr",
   ",",
   "wHereErr",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerAdd",
   ",",
   "wPeerAdd",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerMod",
   ",",
   "wPeerMod",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerDel",
   ",",
   "wPeerDel",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "peerErr",
   ",",
   "wPeerErr",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "conflicts",
   ",",
   "wCol",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "numcol",
   "(",
   "stats",
   "[",
   "key",
   "]",
   ".",
   "merged",
   ",",
   "wMrg",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' |\\n'",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "hsline",
   ")",
   "if",
   "totals",
   ":",
   "if",
   "title",
   "is",
   "None",
   "and",
   "not",
   "details",
   ":",
   "stream",
   ".",
   "write",
   "(",
   "'+-'",
   "+",
   "'-'",
   "*",
   "tWid",
   "+",
   "'-+\\n'",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "'| {0: ^{w}}'",
   ".",
   "format",
   "(",
   "sumlist",
   ",",
   "w",
   "=",
   "tWid",
   ")",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "' |\\n'",
   ")",
   "stream",
   ".",
   "write",
   "(",
   "'+-'",
   "+",
   "'-'",
   "*",
   "tWid",
   "+",
   "'-+\\n'",
   ")",
   "return"
  ]
 },
 {
  "idx": "maxmin-437",
  "nl_tokens": [
   "Return",
   "the",
   "separator",
   "that",
   "preceding",
   "format",
   "i",
   "or",
   "for",
   "i",
   "==",
   "0",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_separator",
   "(",
   "self",
   ",",
   "i",
   ")",
   ":",
   "return",
   "i",
   "and",
   "self",
   ".",
   "separator",
   "[",
   "<mask>",
   "(",
   "i",
   "-",
   "1",
   ",",
   "len",
   "(",
   "self",
   ".",
   "separator",
   ")",
   "-",
   "1",
   ")",
   "]",
   "or",
   "''"
  ]
 },
 {
  "idx": "maxmin-438",
  "nl_tokens": [
   "Calculates",
   "string",
   "edit",
   "distance",
   "between",
   "string",
   "1",
   "and",
   "string",
   "2",
   ".",
   "Deletion",
   "insertion",
   "substitution",
   "and",
   "transposition",
   "all",
   "increase",
   "edit",
   "distance",
   "."
  ],
  "pl_tokens": [
   "def",
   "edit_distance",
   "(",
   "s1",
   ",",
   "s2",
   ")",
   ":",
   "d",
   "=",
   "{",
   "}",
   "lenstr1",
   "=",
   "len",
   "(",
   "s1",
   ")",
   "lenstr2",
   "=",
   "len",
   "(",
   "s2",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "-",
   "1",
   ",",
   "lenstr1",
   "+",
   "1",
   ")",
   ":",
   "d",
   "[",
   "(",
   "i",
   ",",
   "-",
   "1",
   ")",
   "]",
   "=",
   "i",
   "+",
   "1",
   "for",
   "j",
   "in",
   "xrange",
   "(",
   "-",
   "1",
   ",",
   "lenstr2",
   "+",
   "1",
   ")",
   ":",
   "d",
   "[",
   "(",
   "-",
   "1",
   ",",
   "j",
   ")",
   "]",
   "=",
   "j",
   "+",
   "1",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "lenstr1",
   ")",
   ":",
   "for",
   "j",
   "in",
   "xrange",
   "(",
   "lenstr2",
   ")",
   ":",
   "if",
   "s1",
   "[",
   "i",
   "]",
   "==",
   "s2",
   "[",
   "j",
   "]",
   ":",
   "cost",
   "=",
   "0",
   "else",
   ":",
   "cost",
   "=",
   "1",
   "d",
   "[",
   "(",
   "i",
   ",",
   "j",
   ")",
   "]",
   "=",
   "<mask>",
   "(",
   "d",
   "[",
   "(",
   "i",
   "-",
   "1",
   ",",
   "j",
   ")",
   "]",
   "+",
   "1",
   ",",
   "# deletion",
   "d",
   "[",
   "(",
   "i",
   ",",
   "j",
   "-",
   "1",
   ")",
   "]",
   "+",
   "1",
   ",",
   "# insertion",
   "d",
   "[",
   "(",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   ")",
   "]",
   "+",
   "cost",
   ",",
   "# substitution",
   ")",
   "if",
   "i",
   "and",
   "j",
   "and",
   "s1",
   "[",
   "i",
   "]",
   "==",
   "s2",
   "[",
   "j",
   "-",
   "1",
   "]",
   "and",
   "s1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "s2",
   "[",
   "j",
   "]",
   ":",
   "d",
   "[",
   "(",
   "i",
   ",",
   "j",
   ")",
   "]",
   "=",
   "min",
   "(",
   "d",
   "[",
   "(",
   "i",
   ",",
   "j",
   ")",
   "]",
   ",",
   "d",
   "[",
   "i",
   "-",
   "2",
   ",",
   "j",
   "-",
   "2",
   "]",
   "+",
   "cost",
   ")",
   "# transposition",
   "return",
   "d",
   "[",
   "lenstr1",
   "-",
   "1",
   ",",
   "lenstr2",
   "-",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-439",
  "nl_tokens": [
   "Move",
   "n",
   "questions",
   "back",
   "in",
   "the",
   "questionnaire",
   "by",
   "removing",
   "the",
   "last",
   "n",
   "answers",
   "."
  ],
  "pl_tokens": [
   "def",
   "go_back",
   "(",
   "self",
   ",",
   "n",
   "=",
   "1",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "can_go_back",
   ":",
   "return",
   "N",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "self",
   ".",
   "answers",
   ")",
   "-",
   "abs",
   "(",
   "n",
   ")",
   ",",
   "0",
   ")",
   "self",
   ".",
   "answers",
   "=",
   "OrderedDict",
   "(",
   "islice",
   "(",
   "self",
   ".",
   "answers",
   ".",
   "items",
   "(",
   ")",
   ",",
   "N",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-440",
  "nl_tokens": [
   "Returns",
   "an",
   "estimate",
   "for",
   "the",
   "maximum",
   "amount",
   "of",
   "memory",
   "to",
   "be",
   "consumed",
   "by",
   "numpy",
   "arrays",
   "."
  ],
  "pl_tokens": [
   "def",
   "guess_array_memory_usage",
   "(",
   "bam_readers",
   ",",
   "dtype",
   ",",
   "use_strand",
   "=",
   "False",
   ")",
   ":",
   "ARRAY_COUNT",
   "=",
   "5",
   "if",
   "not",
   "isinstance",
   "(",
   "bam_readers",
   ",",
   "list",
   ")",
   ":",
   "bam_readers",
   "=",
   "[",
   "bam_readers",
   "]",
   "if",
   "isinstance",
   "(",
   "dtype",
   ",",
   "basestring",
   ")",
   ":",
   "dtype",
   "=",
   "NUMPY_DTYPES",
   ".",
   "get",
   "(",
   "dtype",
   ",",
   "None",
   ")",
   "use_strand",
   "=",
   "use_strand",
   "+",
   "1",
   "#if false, factor of 1, if true, factor of 2",
   "dtypes",
   "=",
   "guess_numpy_dtypes_from_idxstats",
   "(",
   "bam_readers",
   ",",
   "default",
   "=",
   "None",
   ",",
   "force_dtype",
   "=",
   "False",
   ")",
   "if",
   "not",
   "[",
   "dt",
   "for",
   "dt",
   "in",
   "dtypes",
   "if",
   "dt",
   "is",
   "not",
   "None",
   "]",
   ":",
   "#found no info from idx",
   "dtypes",
   "=",
   "guess_numpy_dtypes_from_idxstats",
   "(",
   "bam_readers",
   ",",
   "default",
   "=",
   "dtype",
   "or",
   "numpy",
   ".",
   "uint64",
   ",",
   "force_dtype",
   "=",
   "True",
   ")",
   "elif",
   "dtype",
   ":",
   "dtypes",
   "=",
   "[",
   "dtype",
   "if",
   "dt",
   "else",
   "None",
   "for",
   "dt",
   "in",
   "dtypes",
   "]",
   "read_groups",
   "=",
   "[",
   "]",
   "no_read_group",
   "=",
   "False",
   "for",
   "bam",
   "in",
   "bam_readers",
   ":",
   "rgs",
   "=",
   "bam",
   ".",
   "get_read_groups",
   "(",
   ")",
   "if",
   "rgs",
   ":",
   "for",
   "rg",
   "in",
   "rgs",
   ":",
   "if",
   "rg",
   "not",
   "in",
   "read_groups",
   ":",
   "read_groups",
   ".",
   "append",
   "(",
   "rg",
   ")",
   "else",
   ":",
   "no_read_group",
   "=",
   "True",
   "read_groups",
   "=",
   "len",
   "(",
   "read_groups",
   ")",
   "+",
   "no_read_group",
   "max_ref_size",
   "=",
   "0",
   "array_byte_overhead",
   "=",
   "sys",
   ".",
   "getsizeof",
   "(",
   "numpy",
   ".",
   "zeros",
   "(",
   "(",
   "0",
   ")",
   ",",
   "dtype",
   "=",
   "numpy",
   ".",
   "uint64",
   ")",
   ")",
   "array_count",
   "=",
   "ARRAY_COUNT",
   "*",
   "use_strand",
   "*",
   "read_groups",
   "for",
   "bam",
   "in",
   "bam_readers",
   ":",
   "for",
   "i",
   ",",
   "(",
   "name",
   ",",
   "length",
   ")",
   "in",
   "enumerate",
   "(",
   "bam",
   ".",
   "get_references",
   "(",
   ")",
   ")",
   ":",
   "if",
   "dtypes",
   "[",
   "i",
   "]",
   "is",
   "not",
   "None",
   ":",
   "max_ref_size",
   "=",
   "<mask>",
   "(",
   "max_ref_size",
   ",",
   "(",
   "length",
   "+",
   "length",
   "*",
   "dtypes",
   "[",
   "i",
   "]",
   "(",
   ")",
   ".",
   "nbytes",
   "*",
   "array_count",
   "+",
   "(",
   "array_byte_overhead",
   "*",
   "(",
   "array_count",
   "+",
   "1",
   ")",
   ")",
   ")",
   ")",
   "return",
   "max_ref_size"
  ]
 },
 {
  "idx": "maxmin-441",
  "nl_tokens": [
   "Determine",
   "the",
   "minimum",
   "and",
   "maximum",
   "possible",
   "flux",
   "value",
   "for",
   "each",
   "reaction",
   "."
  ],
  "pl_tokens": [
   "def",
   "flux_variability_analysis",
   "(",
   "model",
   ",",
   "reaction_list",
   "=",
   "None",
   ",",
   "loopless",
   "=",
   "False",
   ",",
   "fraction_of_optimum",
   "=",
   "1.0",
   ",",
   "pfba_factor",
   "=",
   "None",
   ",",
   "processes",
   "=",
   "None",
   ")",
   ":",
   "if",
   "reaction_list",
   "is",
   "None",
   ":",
   "reaction_ids",
   "=",
   "[",
   "r",
   ".",
   "id",
   "for",
   "r",
   "in",
   "model",
   ".",
   "reactions",
   "]",
   "else",
   ":",
   "reaction_ids",
   "=",
   "[",
   "r",
   ".",
   "id",
   "for",
   "r",
   "in",
   "model",
   ".",
   "reactions",
   ".",
   "get_by_any",
   "(",
   "reaction_list",
   ")",
   "]",
   "if",
   "processes",
   "is",
   "None",
   ":",
   "processes",
   "=",
   "CONFIGURATION",
   ".",
   "processes",
   "num_reactions",
   "=",
   "len",
   "(",
   "reaction_ids",
   ")",
   "processes",
   "=",
   "<mask>",
   "(",
   "processes",
   ",",
   "num_reactions",
   ")",
   "fva_result",
   "=",
   "DataFrame",
   "(",
   "{",
   "\"minimum\"",
   ":",
   "zeros",
   "(",
   "num_reactions",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   ",",
   "\"maximum\"",
   ":",
   "zeros",
   "(",
   "num_reactions",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "}",
   ",",
   "index",
   "=",
   "reaction_ids",
   ")",
   "prob",
   "=",
   "model",
   ".",
   "problem",
   "with",
   "model",
   ":",
   "# Safety check before setting up FVA.",
   "model",
   ".",
   "slim_optimize",
   "(",
   "error_value",
   "=",
   "None",
   ",",
   "message",
   "=",
   "\"There is no optimal solution for the \"",
   "\"chosen objective!\"",
   ")",
   "# Add the previous objective as a variable to the model then set it to",
   "# zero. This also uses the fraction to create the lower/upper bound for",
   "# the old objective.",
   "# TODO: Use utility function here (fix_objective_as_constraint)?",
   "if",
   "model",
   ".",
   "solver",
   ".",
   "objective",
   ".",
   "direction",
   "==",
   "\"max\"",
   ":",
   "fva_old_objective",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "\"fva_old_objective\"",
   ",",
   "lb",
   "=",
   "fraction_of_optimum",
   "*",
   "model",
   ".",
   "solver",
   ".",
   "objective",
   ".",
   "value",
   ")",
   "else",
   ":",
   "fva_old_objective",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "\"fva_old_objective\"",
   ",",
   "ub",
   "=",
   "fraction_of_optimum",
   "*",
   "model",
   ".",
   "solver",
   ".",
   "objective",
   ".",
   "value",
   ")",
   "fva_old_obj_constraint",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "model",
   ".",
   "solver",
   ".",
   "objective",
   ".",
   "expression",
   "-",
   "fva_old_objective",
   ",",
   "lb",
   "=",
   "0",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "\"fva_old_objective_constraint\"",
   ")",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "[",
   "fva_old_objective",
   ",",
   "fva_old_obj_constraint",
   "]",
   ")",
   "if",
   "pfba_factor",
   "is",
   "not",
   "None",
   ":",
   "if",
   "pfba_factor",
   "<",
   "1.",
   ":",
   "warn",
   "(",
   "\"The 'pfba_factor' should be larger or equal to 1.\"",
   ",",
   "UserWarning",
   ")",
   "with",
   "model",
   ":",
   "add_pfba",
   "(",
   "model",
   ",",
   "fraction_of_optimum",
   "=",
   "0",
   ")",
   "ub",
   "=",
   "model",
   ".",
   "slim_optimize",
   "(",
   "error_value",
   "=",
   "None",
   ")",
   "flux_sum",
   "=",
   "prob",
   ".",
   "Variable",
   "(",
   "\"flux_sum\"",
   ",",
   "ub",
   "=",
   "pfba_factor",
   "*",
   "ub",
   ")",
   "flux_sum_constraint",
   "=",
   "prob",
   ".",
   "Constraint",
   "(",
   "model",
   ".",
   "solver",
   ".",
   "objective",
   ".",
   "expression",
   "-",
   "flux_sum",
   ",",
   "lb",
   "=",
   "0",
   ",",
   "ub",
   "=",
   "0",
   ",",
   "name",
   "=",
   "\"flux_sum_constraint\"",
   ")",
   "model",
   ".",
   "add_cons_vars",
   "(",
   "[",
   "flux_sum",
   ",",
   "flux_sum_constraint",
   "]",
   ")",
   "model",
   ".",
   "objective",
   "=",
   "Zero",
   "# This will trigger the reset as well",
   "for",
   "what",
   "in",
   "(",
   "\"minimum\"",
   ",",
   "\"maximum\"",
   ")",
   ":",
   "if",
   "processes",
   ">",
   "1",
   ":",
   "# We create and destroy a new pool here in order to set the",
   "# objective direction for all reactions. This creates a",
   "# slight overhead but seems the most clean.",
   "chunk_size",
   "=",
   "len",
   "(",
   "reaction_ids",
   ")",
   "//",
   "processes",
   "pool",
   "=",
   "multiprocessing",
   ".",
   "Pool",
   "(",
   "processes",
   ",",
   "initializer",
   "=",
   "_init_worker",
   ",",
   "initargs",
   "=",
   "(",
   "model",
   ",",
   "loopless",
   ",",
   "what",
   "[",
   ":",
   "3",
   "]",
   ")",
   ")",
   "for",
   "rxn_id",
   ",",
   "value",
   "in",
   "pool",
   ".",
   "imap_unordered",
   "(",
   "_fva_step",
   ",",
   "reaction_ids",
   ",",
   "chunksize",
   "=",
   "chunk_size",
   ")",
   ":",
   "fva_result",
   ".",
   "at",
   "[",
   "rxn_id",
   ",",
   "what",
   "]",
   "=",
   "value",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "else",
   ":",
   "_init_worker",
   "(",
   "model",
   ",",
   "loopless",
   ",",
   "what",
   "[",
   ":",
   "3",
   "]",
   ")",
   "for",
   "rxn_id",
   ",",
   "value",
   "in",
   "map",
   "(",
   "_fva_step",
   ",",
   "reaction_ids",
   ")",
   ":",
   "fva_result",
   ".",
   "at",
   "[",
   "rxn_id",
   ",",
   "what",
   "]",
   "=",
   "value",
   "return",
   "fva_result",
   "[",
   "[",
   "\"minimum\"",
   ",",
   "\"maximum\"",
   "]",
   "]"
  ]
 },
 {
  "idx": "maxmin-442",
  "nl_tokens": [
   "Return",
   "the",
   "normalized",
   "Editex",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "cost",
   "=",
   "(",
   "0",
   ",",
   "1",
   ",",
   "2",
   ")",
   ",",
   "local",
   "=",
   "False",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "mismatch_cost",
   "=",
   "cost",
   "[",
   "2",
   "]",
   "return",
   "self",
   ".",
   "dist_abs",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "cost",
   ",",
   "local",
   ")",
   "/",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   "*",
   "mismatch_cost",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "*",
   "mismatch_cost",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-443",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__insert_for_noneleaf_node",
   "(",
   "self",
   ",",
   "entry",
   ",",
   "search_node",
   ")",
   ":",
   "node_amount_updation",
   "=",
   "False",
   "min_key",
   "=",
   "lambda",
   "child_node",
   ":",
   "child_node",
   ".",
   "get_distance",
   "(",
   "search_node",
   ",",
   "self",
   ".",
   "__type_measurement",
   ")",
   "nearest_child_node",
   "=",
   "<mask>",
   "(",
   "search_node",
   ".",
   "successors",
   ",",
   "key",
   "=",
   "min_key",
   ")",
   "child_node_updation",
   "=",
   "self",
   ".",
   "__recursive_insert",
   "(",
   "entry",
   ",",
   "nearest_child_node",
   ")",
   "# Update clustering feature of none-leaf node.\r",
   "search_node",
   ".",
   "feature",
   "+=",
   "entry",
   "# Check branch factor, probably some leaf has been splitted and threshold has been exceeded.\r",
   "if",
   "(",
   "len",
   "(",
   "search_node",
   ".",
   "successors",
   ")",
   ">",
   "self",
   ".",
   "__branch_factor",
   ")",
   ":",
   "# Check if it's aleady root then new root should be created (height is increased in this case).\r",
   "if",
   "(",
   "search_node",
   "is",
   "self",
   ".",
   "__root",
   ")",
   ":",
   "self",
   ".",
   "__root",
   "=",
   "non_leaf_node",
   "(",
   "search_node",
   ".",
   "feature",
   ",",
   "None",
   ",",
   "[",
   "search_node",
   "]",
   ",",
   "None",
   ")",
   "search_node",
   ".",
   "parent",
   "=",
   "self",
   ".",
   "__root",
   "# Update statistics\r",
   "self",
   ".",
   "__amount_nodes",
   "+=",
   "1",
   "self",
   ".",
   "__height",
   "+=",
   "1",
   "[",
   "new_node1",
   ",",
   "new_node2",
   "]",
   "=",
   "self",
   ".",
   "__split_nonleaf_node",
   "(",
   "search_node",
   ")",
   "# Update parent list of successors\r",
   "parent",
   "=",
   "search_node",
   ".",
   "parent",
   "parent",
   ".",
   "successors",
   ".",
   "remove",
   "(",
   "search_node",
   ")",
   "parent",
   ".",
   "successors",
   ".",
   "append",
   "(",
   "new_node1",
   ")",
   "parent",
   ".",
   "successors",
   ".",
   "append",
   "(",
   "new_node2",
   ")",
   "# Update statistics\r",
   "self",
   ".",
   "__amount_nodes",
   "+=",
   "1",
   "node_amount_updation",
   "=",
   "True",
   "elif",
   "(",
   "child_node_updation",
   "is",
   "True",
   ")",
   ":",
   "# Splitting has been finished, check for possibility to merge (at least we have already two children).\r",
   "if",
   "(",
   "self",
   ".",
   "__merge_nearest_successors",
   "(",
   "search_node",
   ")",
   "is",
   "True",
   ")",
   ":",
   "self",
   ".",
   "__amount_nodes",
   "-=",
   "1",
   "return",
   "node_amount_updation"
  ]
 },
 {
  "idx": "maxmin-444",
  "nl_tokens": [
   "Split",
   "the",
   "extension",
   "from",
   "a",
   "pathname",
   "."
  ],
  "pl_tokens": [
   "def",
   "_splitext",
   "(",
   "p",
   ",",
   "sep",
   ",",
   "altsep",
   ",",
   "extsep",
   ")",
   ":",
   "sepIndex",
   "=",
   "p",
   ".",
   "rfind",
   "(",
   "sep",
   ")",
   "if",
   "altsep",
   ":",
   "altsepIndex",
   "=",
   "p",
   ".",
   "rfind",
   "(",
   "altsep",
   ")",
   "sepIndex",
   "=",
   "<mask>",
   "(",
   "sepIndex",
   ",",
   "altsepIndex",
   ")",
   "dotIndex",
   "=",
   "p",
   ".",
   "rfind",
   "(",
   "extsep",
   ")",
   "if",
   "dotIndex",
   ">",
   "sepIndex",
   ":",
   "# skip all leading dots",
   "filenameIndex",
   "=",
   "sepIndex",
   "+",
   "1",
   "while",
   "filenameIndex",
   "<",
   "dotIndex",
   ":",
   "if",
   "p",
   "[",
   "filenameIndex",
   "]",
   "!=",
   "extsep",
   ":",
   "return",
   "p",
   "[",
   ":",
   "dotIndex",
   "]",
   ",",
   "p",
   "[",
   "dotIndex",
   ":",
   "]",
   "filenameIndex",
   "+=",
   "1",
   "return",
   "p",
   ",",
   "''"
  ]
 },
 {
  "idx": "maxmin-445",
  "nl_tokens": [
   "Mechanism",
   "function",
   "."
  ],
  "pl_tokens": [
   "def",
   "mechanism",
   "(",
   "self",
   ",",
   "x",
   ",",
   "par",
   ")",
   ":",
   "list_coeff",
   "=",
   "self",
   ".",
   "polycause",
   "[",
   "par",
   "]",
   "result",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "self",
   ".",
   "points",
   ",",
   "1",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "points",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "self",
   ".",
   "d",
   "+",
   "1",
   ")",
   ":",
   "result",
   "[",
   "i",
   ",",
   "0",
   "]",
   "+=",
   "list_coeff",
   "[",
   "j",
   "]",
   "*",
   "np",
   ".",
   "power",
   "(",
   "x",
   "[",
   "i",
   "]",
   ",",
   "j",
   ")",
   "result",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "<mask>",
   "(",
   "result",
   "[",
   "i",
   ",",
   "0",
   "]",
   ",",
   "1",
   ")",
   "result",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "max",
   "(",
   "result",
   "[",
   "i",
   ",",
   "0",
   "]",
   ",",
   "-",
   "1",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-446",
  "nl_tokens": [
   "Redefine",
   "the",
   "causes",
   "of",
   "the",
   "graph",
   "."
  ],
  "pl_tokens": [
   "def",
   "init_variables",
   "(",
   "self",
   ",",
   "verbose",
   "=",
   "False",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "1",
   ",",
   "self",
   ".",
   "nodes",
   ")",
   ":",
   "nb_parents",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "parents_max",
   ",",
   "j",
   "]",
   ")",
   "+",
   "1",
   ")",
   "for",
   "i",
   "in",
   "np",
   ".",
   "random",
   ".",
   "choice",
   "(",
   "range",
   "(",
   "0",
   ",",
   "j",
   ")",
   ",",
   "nb_parents",
   ",",
   "replace",
   "=",
   "False",
   ")",
   ":",
   "self",
   ".",
   "adjacency_matrix",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "1",
   "try",
   ":",
   "self",
   ".",
   "g",
   "=",
   "nx",
   ".",
   "DiGraph",
   "(",
   "self",
   ".",
   "adjacency_matrix",
   ")",
   "assert",
   "not",
   "list",
   "(",
   "nx",
   ".",
   "simple_cycles",
   "(",
   "self",
   ".",
   "g",
   ")",
   ")",
   "except",
   "AssertionError",
   ":",
   "if",
   "verbose",
   ":",
   "print",
   "(",
   "\"Regenerating, graph non valid...\"",
   ")",
   "self",
   ".",
   "init_variables",
   "(",
   ")",
   "# Mechanisms",
   "self",
   ".",
   "cfunctions",
   "=",
   "[",
   "self",
   ".",
   "mechanism",
   "(",
   "int",
   "(",
   "sum",
   "(",
   "self",
   ".",
   "adjacency_matrix",
   "[",
   ":",
   ",",
   "i",
   "]",
   ")",
   ")",
   ",",
   "self",
   ".",
   "points",
   ",",
   "self",
   ".",
   "noise",
   ",",
   "noise_coeff",
   "=",
   "self",
   ".",
   "noise_coeff",
   ")",
   "if",
   "sum",
   "(",
   "self",
   ".",
   "adjacency_matrix",
   "[",
   ":",
   ",",
   "i",
   "]",
   ")",
   "else",
   "self",
   ".",
   "initial_generator",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "nodes",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-447",
  "nl_tokens": [
   "A",
   "Cherrypy",
   "wsgiserver",
   "-",
   "compatible",
   "wrapper",
   "."
  ],
  "pl_tokens": [
   "def",
   "CherryPyWSGIServer",
   "(",
   "bind_addr",
   ",",
   "wsgi_app",
   ",",
   "numthreads",
   "=",
   "10",
   ",",
   "server_name",
   "=",
   "None",
   ",",
   "<mask>",
   "=",
   "-",
   "1",
   ",",
   "request_queue_size",
   "=",
   "5",
   ",",
   "timeout",
   "=",
   "10",
   ",",
   "shutdown_timeout",
   "=",
   "5",
   ")",
   ":",
   "max_threads",
   "=",
   "max",
   "if",
   "max_threads",
   "<",
   "0",
   ":",
   "max_threads",
   "=",
   "0",
   "return",
   "Rocket",
   "(",
   "bind_addr",
   ",",
   "'wsgi'",
   ",",
   "{",
   "'wsgi_app'",
   ":",
   "wsgi_app",
   "}",
   ",",
   "min_threads",
   "=",
   "numthreads",
   ",",
   "max_threads",
   "=",
   "max_threads",
   ",",
   "queue_size",
   "=",
   "request_queue_size",
   ",",
   "timeout",
   "=",
   "timeout",
   ")"
  ]
 },
 {
  "idx": "maxmin-448",
  "nl_tokens": [
   "This",
   "generates",
   "fake",
   "planet",
   "transit",
   "light",
   "curves",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_transit_lightcurve",
   "(",
   "times",
   ",",
   "mags",
   "=",
   "None",
   ",",
   "errs",
   "=",
   "None",
   ",",
   "paramdists",
   "=",
   "{",
   "'transitperiod'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.1",
   ",",
   "scale",
   "=",
   "49.9",
   ")",
   ",",
   "'transitdepth'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "1.0e-4",
   ",",
   "scale",
   "=",
   "2.0e-2",
   ")",
   ",",
   "'transitduration'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.01",
   ",",
   "scale",
   "=",
   "0.29",
   ")",
   "}",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   ")",
   ":",
   "if",
   "mags",
   "is",
   "None",
   ":",
   "mags",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "if",
   "errs",
   "is",
   "None",
   ":",
   "errs",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "# choose the epoch",
   "epoch",
   "=",
   "npr",
   ".",
   "random",
   "(",
   ")",
   "*",
   "(",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "times",
   ".",
   "min",
   "(",
   ")",
   ")",
   "+",
   "times",
   ".",
   "min",
   "(",
   ")",
   "# choose the period, depth, duration",
   "period",
   "=",
   "paramdists",
   "[",
   "'transitperiod'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "depth",
   "=",
   "paramdists",
   "[",
   "'transitdepth'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "duration",
   "=",
   "paramdists",
   "[",
   "'transitduration'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "# figure out the ingress duration",
   "ingduration",
   "=",
   "npr",
   ".",
   "random",
   "(",
   ")",
   "*",
   "(",
   "0.5",
   "*",
   "duration",
   "-",
   "0.05",
   "*",
   "duration",
   ")",
   "+",
   "0.05",
   "*",
   "duration",
   "# fix the transit depth if it needs to be flipped",
   "if",
   "magsarefluxes",
   "and",
   "depth",
   "<",
   "0.0",
   ":",
   "depth",
   "=",
   "-",
   "depth",
   "elif",
   "not",
   "magsarefluxes",
   "and",
   "depth",
   ">",
   "0.0",
   ":",
   "depth",
   "=",
   "-",
   "depth",
   "# generate the model",
   "modelmags",
   ",",
   "phase",
   ",",
   "ptimes",
   ",",
   "pmags",
   ",",
   "perrs",
   "=",
   "(",
   "transits",
   ".",
   "trapezoid_transit_func",
   "(",
   "[",
   "period",
   ",",
   "epoch",
   ",",
   "depth",
   ",",
   "duration",
   ",",
   "ingduration",
   "]",
   ",",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ")",
   ")",
   "# resort in original time order",
   "timeind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "ptimes",
   ")",
   "mtimes",
   "=",
   "ptimes",
   "[",
   "timeind",
   "]",
   "mmags",
   "=",
   "modelmags",
   "[",
   "timeind",
   "]",
   "merrs",
   "=",
   "perrs",
   "[",
   "timeind",
   "]",
   "# return a dict with everything",
   "modeldict",
   "=",
   "{",
   "'vartype'",
   ":",
   "'planet'",
   ",",
   "'params'",
   ":",
   "{",
   "x",
   ":",
   "np",
   ".",
   "asscalar",
   "(",
   "y",
   ")",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "[",
   "'transitperiod'",
   ",",
   "'transitepoch'",
   ",",
   "'transitdepth'",
   ",",
   "'transitduration'",
   ",",
   "'ingressduration'",
   "]",
   ",",
   "[",
   "period",
   ",",
   "epoch",
   ",",
   "depth",
   ",",
   "duration",
   ",",
   "ingduration",
   "]",
   ")",
   "}",
   ",",
   "'times'",
   ":",
   "mtimes",
   ",",
   "'mags'",
   ":",
   "mmags",
   ",",
   "'errs'",
   ":",
   "merrs",
   ",",
   "# these are standard keys that help with later characterization of",
   "# variability as a function period, variability amplitude, object mag,",
   "# ndet, etc.",
   "'varperiod'",
   ":",
   "period",
   ",",
   "'varamplitude'",
   ":",
   "depth",
   "}",
   "return",
   "modeldict"
  ]
 },
 {
  "idx": "maxmin-449",
  "nl_tokens": [
   "[",
   "Fig",
   ".",
   "3",
   ".",
   "26",
   "]"
  ],
  "pl_tokens": [
   "def",
   "recursive_best_first_search",
   "(",
   "problem",
   ",",
   "h",
   "=",
   "None",
   ")",
   ":",
   "h",
   "=",
   "memoize",
   "(",
   "h",
   "or",
   "problem",
   ".",
   "h",
   ",",
   "'h'",
   ")",
   "def",
   "RBFS",
   "(",
   "problem",
   ",",
   "node",
   ",",
   "flimit",
   ")",
   ":",
   "if",
   "problem",
   ".",
   "goal_test",
   "(",
   "node",
   ".",
   "state",
   ")",
   ":",
   "return",
   "node",
   ",",
   "0",
   "# (The second value is immaterial)",
   "successors",
   "=",
   "node",
   ".",
   "expand",
   "(",
   "problem",
   ")",
   "if",
   "len",
   "(",
   "successors",
   ")",
   "==",
   "0",
   ":",
   "return",
   "None",
   ",",
   "infinity",
   "for",
   "s",
   "in",
   "successors",
   ":",
   "s",
   ".",
   "f",
   "=",
   "<mask>",
   "(",
   "s",
   ".",
   "path_cost",
   "+",
   "h",
   "(",
   "s",
   ")",
   ",",
   "node",
   ".",
   "f",
   ")",
   "while",
   "True",
   ":",
   "successors",
   ".",
   "sort",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "cmp",
   "(",
   "x",
   ".",
   "f",
   ",",
   "y",
   ".",
   "f",
   ")",
   ")",
   "# Order by lowest f value",
   "best",
   "=",
   "successors",
   "[",
   "0",
   "]",
   "if",
   "best",
   ".",
   "f",
   ">",
   "flimit",
   ":",
   "return",
   "None",
   ",",
   "best",
   ".",
   "f",
   "if",
   "len",
   "(",
   "successors",
   ")",
   ">",
   "1",
   ":",
   "alternative",
   "=",
   "successors",
   "[",
   "1",
   "]",
   ".",
   "f",
   "else",
   ":",
   "alternative",
   "=",
   "infinity",
   "result",
   ",",
   "best",
   ".",
   "f",
   "=",
   "RBFS",
   "(",
   "problem",
   ",",
   "best",
   ",",
   "min",
   "(",
   "flimit",
   ",",
   "alternative",
   ")",
   ")",
   "if",
   "result",
   "is",
   "not",
   "None",
   ":",
   "return",
   "result",
   ",",
   "best",
   ".",
   "f",
   "node",
   "=",
   "Node",
   "(",
   "problem",
   ".",
   "initial",
   ")",
   "node",
   ".",
   "f",
   "=",
   "h",
   "(",
   "node",
   ")",
   "result",
   ",",
   "bestf",
   "=",
   "RBFS",
   "(",
   "problem",
   ",",
   "node",
   ",",
   "infinity",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-450",
  "nl_tokens": [
   "Generate",
   "a",
   "transaction",
   "list",
   "report",
   "."
  ],
  "pl_tokens": [
   "def",
   "transaction_list",
   "(",
   "self",
   ",",
   "start",
   "=",
   "datetime",
   ".",
   "<mask>",
   ",",
   "end",
   "=",
   "datetime",
   ".",
   "max",
   ",",
   "format",
   "=",
   "ReportFormat",
   ".",
   "printout",
   ",",
   "component_path",
   "=",
   "\"\"",
   ",",
   "output_path",
   "=",
   "None",
   ")",
   ":",
   "rpt",
   "=",
   "TransactionList",
   "(",
   "self",
   ",",
   "start",
   ",",
   "end",
   ",",
   "component_path",
   ",",
   "output_path",
   ")",
   "return",
   "rpt",
   ".",
   "render",
   "(",
   "format",
   ")"
  ]
 },
 {
  "idx": "maxmin-451",
  "nl_tokens": [
   "Algorithm",
   "from",
   "https",
   ":",
   "//",
   "www",
   ".",
   "python",
   ".",
   "org",
   "/",
   "dev",
   "/",
   "peps",
   "/",
   "pep",
   "-",
   "0257",
   "/"
  ],
  "pl_tokens": [
   "def",
   "doc",
   "(",
   "self",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "__doc__",
   ":",
   "return",
   "\"\"",
   "lines",
   "=",
   "self",
   ".",
   "__doc__",
   ".",
   "expandtabs",
   "(",
   ")",
   ".",
   "splitlines",
   "(",
   ")",
   "# Determine minimum indentation (first line doesn't count):",
   "indent",
   "=",
   "sys",
   ".",
   "maxsize",
   "for",
   "line",
   "in",
   "lines",
   "[",
   "1",
   ":",
   "]",
   ":",
   "stripped",
   "=",
   "line",
   ".",
   "lstrip",
   "(",
   ")",
   "if",
   "stripped",
   ":",
   "indent",
   "=",
   "<mask>",
   "(",
   "indent",
   ",",
   "len",
   "(",
   "line",
   ")",
   "-",
   "len",
   "(",
   "stripped",
   ")",
   ")",
   "# Remove indentation (first line is special):",
   "trimmed",
   "=",
   "[",
   "lines",
   "[",
   "0",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "]",
   "if",
   "indent",
   "<",
   "sys",
   ".",
   "maxsize",
   ":",
   "for",
   "line",
   "in",
   "lines",
   "[",
   "1",
   ":",
   "]",
   ":",
   "trimmed",
   ".",
   "append",
   "(",
   "line",
   "[",
   "indent",
   ":",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   "# Strip off trailing and leading blank lines:",
   "while",
   "trimmed",
   "and",
   "not",
   "trimmed",
   "[",
   "-",
   "1",
   "]",
   ":",
   "trimmed",
   ".",
   "pop",
   "(",
   ")",
   "while",
   "trimmed",
   "and",
   "not",
   "trimmed",
   "[",
   "0",
   "]",
   ":",
   "trimmed",
   ".",
   "pop",
   "(",
   "0",
   ")",
   "# Return a single string:",
   "return",
   "'\\n'",
   ".",
   "join",
   "(",
   "trimmed",
   ")"
  ]
 },
 {
  "idx": "maxmin-452",
  "nl_tokens": [
   "Load",
   "a",
   "keyring",
   "specified",
   "in",
   "the",
   "config",
   "file",
   "or",
   "infer",
   "the",
   "best",
   "available",
   "."
  ],
  "pl_tokens": [
   "def",
   "init_backend",
   "(",
   "limit",
   "=",
   "None",
   ")",
   ":",
   "# save the limit for the chainer to honor",
   "backend",
   ".",
   "_limit",
   "=",
   "limit",
   "# get all keyrings passing the limit filter",
   "keyrings",
   "=",
   "filter",
   "(",
   "limit",
   ",",
   "backend",
   ".",
   "get_all_keyring",
   "(",
   ")",
   ")",
   "set_keyring",
   "(",
   "load_env",
   "(",
   ")",
   "or",
   "load_config",
   "(",
   ")",
   "or",
   "<mask>",
   "(",
   "keyrings",
   ",",
   "default",
   "=",
   "fail",
   ".",
   "Keyring",
   "(",
   ")",
   ",",
   "key",
   "=",
   "backend",
   ".",
   "by_priority",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-453",
  "nl_tokens": [
   "Returns",
   "the",
   "smallest",
   "possible",
   "range",
   "spanning",
   "both",
   "this",
   "range",
   "and",
   "other",
   ".",
   "Raises",
   ":",
   "exc",
   ":",
   "ValueError",
   "if",
   "the",
   "ranges",
   "do",
   "not",
   "belong",
   "to",
   "the",
   "same",
   ":",
   "class",
   ":",
   "Buffer",
   "."
  ],
  "pl_tokens": [
   "def",
   "join",
   "(",
   "self",
   ",",
   "other",
   ")",
   ":",
   "if",
   "self",
   ".",
   "source_buffer",
   "!=",
   "other",
   ".",
   "source_buffer",
   ":",
   "raise",
   "ValueError",
   "if",
   "self",
   ".",
   "expanded_from",
   "==",
   "other",
   ".",
   "expanded_from",
   ":",
   "expanded_from",
   "=",
   "self",
   ".",
   "expanded_from",
   "else",
   ":",
   "expanded_from",
   "=",
   "None",
   "return",
   "Range",
   "(",
   "self",
   ".",
   "source_buffer",
   ",",
   "<mask>",
   "(",
   "self",
   ".",
   "begin_pos",
   ",",
   "other",
   ".",
   "begin_pos",
   ")",
   ",",
   "max",
   "(",
   "self",
   ".",
   "end_pos",
   ",",
   "other",
   ".",
   "end_pos",
   ")",
   ",",
   "expanded_from",
   "=",
   "expanded_from",
   ")"
  ]
 },
 {
  "idx": "maxmin-454",
  "nl_tokens": [
   "function",
   "that",
   "takes",
   "a",
   "dictionary",
   "mapping",
   "names",
   "to",
   "sequences",
   "and",
   "a",
   "locus",
   "number",
   "and",
   "writes",
   "it",
   "as",
   "a",
   "NEXUS",
   "file",
   "with",
   "a",
   "mrbayes",
   "analysis",
   "block",
   "given",
   "a",
   "set",
   "of",
   "mcmc",
   "arguments",
   "."
  ],
  "pl_tokens": [
   "def",
   "_write_nex",
   "(",
   "self",
   ",",
   "mdict",
   ",",
   "nlocus",
   ")",
   ":",
   "## create matrix as a string",
   "max_name_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "mdict",
   "]",
   ")",
   "namestring",
   "=",
   "\"{:<\"",
   "+",
   "str",
   "(",
   "max_name_len",
   "+",
   "1",
   ")",
   "+",
   "\"} {}\\n\"",
   "matrix",
   "=",
   "\"\"",
   "for",
   "i",
   "in",
   "mdict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "matrix",
   "+=",
   "namestring",
   ".",
   "format",
   "(",
   "i",
   "[",
   "0",
   "]",
   ",",
   "i",
   "[",
   "1",
   "]",
   ")",
   "## ensure dir",
   "minidir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "realpath",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "self",
   ".",
   "workdir",
   ",",
   "self",
   ".",
   "name",
   ")",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "minidir",
   ")",
   ":",
   "os",
   ".",
   "makedirs",
   "(",
   "minidir",
   ")",
   "## write nexus block",
   "handle",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "minidir",
   ",",
   "\"{}.nex\"",
   ".",
   "format",
   "(",
   "nlocus",
   ")",
   ")",
   "with",
   "open",
   "(",
   "handle",
   ",",
   "'w'",
   ")",
   "as",
   "outnex",
   ":",
   "outnex",
   ".",
   "write",
   "(",
   "NEXBLOCK",
   ".",
   "format",
   "(",
   "*",
   "*",
   "{",
   "\"ntax\"",
   ":",
   "len",
   "(",
   "mdict",
   ")",
   ",",
   "\"nchar\"",
   ":",
   "len",
   "(",
   "mdict",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ",",
   "\"matrix\"",
   ":",
   "matrix",
   ",",
   "\"ngen\"",
   ":",
   "self",
   ".",
   "params",
   ".",
   "mb_mcmc_ngen",
   ",",
   "\"sfreq\"",
   ":",
   "self",
   ".",
   "params",
   ".",
   "mb_mcmc_sample_freq",
   ",",
   "\"burnin\"",
   ":",
   "self",
   ".",
   "params",
   ".",
   "mb_mcmc_burnin",
   ",",
   "}",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-455",
  "nl_tokens": [
   "Rescale",
   "numeric",
   "vector",
   "to",
   "have",
   "specified",
   "minimum",
   "midpoint",
   "and",
   "maximum",
   "."
  ],
  "pl_tokens": [
   "def",
   "rescale_mid",
   "(",
   "x",
   ",",
   "to",
   "=",
   "(",
   "0",
   ",",
   "1",
   ")",
   ",",
   "_from",
   "=",
   "None",
   ",",
   "mid",
   "=",
   "0",
   ")",
   ":",
   "array_like",
   "=",
   "True",
   "try",
   ":",
   "len",
   "(",
   "x",
   ")",
   "except",
   "TypeError",
   ":",
   "array_like",
   "=",
   "False",
   "x",
   "=",
   "[",
   "x",
   "]",
   "if",
   "not",
   "hasattr",
   "(",
   "x",
   ",",
   "'dtype'",
   ")",
   ":",
   "x",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "x",
   ")",
   "if",
   "_from",
   "is",
   "None",
   ":",
   "_from",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "]",
   ")",
   "else",
   ":",
   "_from",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "_from",
   ")",
   "if",
   "(",
   "zero_range",
   "(",
   "_from",
   ")",
   "or",
   "zero_range",
   "(",
   "to",
   ")",
   ")",
   ":",
   "out",
   "=",
   "np",
   ".",
   "repeat",
   "(",
   "np",
   ".",
   "mean",
   "(",
   "to",
   ")",
   ",",
   "len",
   "(",
   "x",
   ")",
   ")",
   "else",
   ":",
   "extent",
   "=",
   "2",
   "*",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "_from",
   "-",
   "mid",
   ")",
   ")",
   "out",
   "=",
   "(",
   "x",
   "-",
   "mid",
   ")",
   "/",
   "extent",
   "*",
   "np",
   ".",
   "diff",
   "(",
   "to",
   ")",
   "+",
   "np",
   ".",
   "mean",
   "(",
   "to",
   ")",
   "if",
   "not",
   "array_like",
   ":",
   "out",
   "=",
   "out",
   "[",
   "0",
   "]",
   "return",
   "out"
  ]
 },
 {
  "idx": "maxmin-456",
  "nl_tokens": [
   "Calculates",
   "the",
   "net",
   "difference",
   "between",
   "positive",
   "/",
   "negative",
   "phasic",
   "events",
   "Returns",
   "return",
   "the",
   "phasic",
   "difference",
   "value",
   "of",
   "the",
   "current",
   "sweep",
   "."
  ],
  "pl_tokens": [
   "def",
   "phasicNet",
   "(",
   "self",
   ",",
   "biggestEvent",
   "=",
   "50",
   ",",
   "m1",
   "=",
   ".5",
   ",",
   "m2",
   "=",
   "None",
   ")",
   ":",
   "# determine marks (between which we will analyze)",
   "m1",
   "=",
   "0",
   "if",
   "m1",
   "is",
   "None",
   "else",
   "self",
   ".",
   "pointsPerSec",
   "*",
   "m1",
   "m2",
   "=",
   "-",
   "1",
   "if",
   "m2",
   "is",
   "None",
   "else",
   "self",
   ".",
   "pointsPerSec",
   "*",
   "m2",
   "# acquire the baseline-subtracted sweep",
   "Y",
   "=",
   "self",
   ".",
   "sweepYsmartbase",
   "(",
   ")",
   "[",
   "int",
   "(",
   "m1",
   ")",
   ":",
   "int",
   "(",
   "m2",
   ")",
   "]",
   "# create the histogram",
   "nBins",
   "=",
   "1000",
   "hist",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "Y",
   ",",
   "bins",
   "=",
   "nBins",
   ",",
   "range",
   "=",
   "[",
   "-",
   "biggestEvent",
   ",",
   "biggestEvent",
   "]",
   ",",
   "density",
   "=",
   "True",
   ")",
   "histSmooth",
   "=",
   "swhlab",
   ".",
   "common",
   ".",
   "lowpass",
   "(",
   "hist",
   ")",
   "# normalize height to 1",
   "#TODO: should it be normalized first or not?",
   "#YES if reporting the ratio of the up/down area, NO if reporting the up-down difference",
   "#hist,histSmooth=hist/max(histSmooth),histSmooth/max(histSmooth)",
   "# center the peak at 0 pA",
   "peakI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "histSmooth",
   "==",
   "<mask>",
   "(",
   "histSmooth",
   ")",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "hist",
   "=",
   "np",
   ".",
   "roll",
   "(",
   "hist",
   ",",
   "int",
   "(",
   "nBins",
   "/",
   "2",
   "-",
   "peakI",
   ")",
   ")",
   "histSmooth",
   "=",
   "np",
   ".",
   "roll",
   "(",
   "histSmooth",
   ",",
   "int",
   "(",
   "nBins",
   "/",
   "2",
   "-",
   "peakI",
   ")",
   ")",
   "# calculate our mirrored difference",
   "downward",
   ",",
   "upward",
   "=",
   "np",
   ".",
   "split",
   "(",
   "histSmooth",
   ",",
   "2",
   ")",
   "downward",
   "=",
   "downward",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "diff",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "upward",
   "-",
   "downward",
   ")",
   "# convert our \"pA/time\" to \"pA/sec\"",
   "diff",
   "=",
   "diff",
   "/",
   "(",
   "len",
   "(",
   "Y",
   ")",
   "/",
   "self",
   ".",
   "pointsPerSec",
   ")",
   "return",
   "diff"
  ]
 },
 {
  "idx": "maxmin-457",
  "nl_tokens": [
   "Gets",
   "within",
   "-",
   "bag",
   "distances",
   "for",
   "each",
   "bag",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_rhos",
   "(",
   "X",
   ",",
   "indices",
   ",",
   "Ks",
   ",",
   "max_K",
   ",",
   "save_all_Ks",
   ",",
   "min_dist",
   ")",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"Getting within-bag distances...\"",
   ")",
   "if",
   "max_K",
   ">=",
   "X",
   ".",
   "n_pts",
   ".",
   "<mask>",
   "(",
   ")",
   ":",
   "msg",
   "=",
   "\"asked for K = {}, but there's a bag with only {} points\"",
   "raise",
   "ValueError",
   "(",
   "msg",
   ".",
   "format",
   "(",
   "max_K",
   ",",
   "X",
   ".",
   "n_pts",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "# need to throw away the closest neighbor, which will always be self",
   "# thus K=1 corresponds to column 1 in the result array",
   "which_Ks",
   "=",
   "slice",
   "(",
   "1",
   ",",
   "None",
   ")",
   "if",
   "save_all_Ks",
   "else",
   "Ks",
   "indices",
   "=",
   "plog",
   "(",
   "indices",
   ",",
   "name",
   "=",
   "\"within-bag distances\"",
   ")",
   "rhos",
   "=",
   "[",
   "None",
   "]",
   "*",
   "len",
   "(",
   "X",
   ")",
   "for",
   "i",
   ",",
   "(",
   "idx",
   ",",
   "bag",
   ")",
   "in",
   "enumerate",
   "(",
   "zip",
   "(",
   "indices",
   ",",
   "X",
   ")",
   ")",
   ":",
   "r",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "idx",
   ".",
   "nn_index",
   "(",
   "bag",
   ",",
   "max_K",
   "+",
   "1",
   ")",
   "[",
   "1",
   "]",
   "[",
   ":",
   ",",
   "which_Ks",
   "]",
   ")",
   "np",
   ".",
   "maximum",
   "(",
   "min_dist",
   ",",
   "r",
   ",",
   "out",
   "=",
   "r",
   ")",
   "rhos",
   "[",
   "i",
   "]",
   "=",
   "r",
   "return",
   "rhos"
  ]
 },
 {
  "idx": "maxmin-458",
  "nl_tokens": [
   "Return",
   "the",
   "eudex",
   "phonetic",
   "hash",
   "of",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "8",
   ")",
   ":",
   "# Lowercase input & filter unknown characters",
   "word",
   "=",
   "''",
   ".",
   "join",
   "(",
   "char",
   "for",
   "char",
   "in",
   "word",
   ".",
   "lower",
   "(",
   ")",
   "if",
   "char",
   "in",
   "self",
   ".",
   "_initial_phones",
   ")",
   "if",
   "not",
   "word",
   ":",
   "word",
   "=",
   "'\u00f7'",
   "# Perform initial eudex coding of each character",
   "values",
   "=",
   "[",
   "self",
   ".",
   "_initial_phones",
   "[",
   "word",
   "[",
   "0",
   "]",
   "]",
   "]",
   "values",
   "+=",
   "[",
   "self",
   ".",
   "_trailing_phones",
   "[",
   "char",
   "]",
   "for",
   "char",
   "in",
   "word",
   "[",
   "1",
   ":",
   "]",
   "]",
   "# Right-shift by one to determine if second instance should be skipped",
   "shifted_values",
   "=",
   "[",
   "_",
   ">>",
   "1",
   "for",
   "_",
   "in",
   "values",
   "]",
   "condensed_values",
   "=",
   "[",
   "values",
   "[",
   "0",
   "]",
   "]",
   "for",
   "n",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "shifted_values",
   ")",
   ")",
   ":",
   "if",
   "shifted_values",
   "[",
   "n",
   "]",
   "!=",
   "shifted_values",
   "[",
   "n",
   "-",
   "1",
   "]",
   ":",
   "condensed_values",
   ".",
   "append",
   "(",
   "values",
   "[",
   "n",
   "]",
   ")",
   "# Add padding after first character & trim beyond max_length",
   "values",
   "=",
   "(",
   "[",
   "condensed_values",
   "[",
   "0",
   "]",
   "]",
   "+",
   "[",
   "0",
   "]",
   "*",
   "<mask>",
   "(",
   "0",
   ",",
   "max_length",
   "-",
   "len",
   "(",
   "condensed_values",
   ")",
   ")",
   "+",
   "condensed_values",
   "[",
   "1",
   ":",
   "max_length",
   "]",
   ")",
   "# Combine individual character values into eudex hash",
   "hash_value",
   "=",
   "0",
   "for",
   "val",
   "in",
   "values",
   ":",
   "hash_value",
   "=",
   "(",
   "hash_value",
   "<<",
   "8",
   ")",
   "|",
   "val",
   "return",
   "hash_value"
  ]
 },
 {
  "idx": "maxmin-459",
  "nl_tokens": [
   "Return",
   "a",
   "value",
   "check",
   "function",
   "which",
   "raises",
   "a",
   "ValueError",
   "if",
   "the",
   "supplied",
   "value",
   "when",
   "cast",
   "as",
   "type",
   "is",
   "less",
   "than",
   "or",
   "equal",
   "to",
   "min",
   "or",
   "greater",
   "than",
   "or",
   "equal",
   "to",
   "max",
   "."
  ],
  "pl_tokens": [
   "def",
   "number_range_exclusive",
   "(",
   "<mask>",
   ",",
   "max",
   ",",
   "type",
   "=",
   "float",
   ")",
   ":",
   "def",
   "checker",
   "(",
   "v",
   ")",
   ":",
   "if",
   "type",
   "(",
   "v",
   ")",
   "<=",
   "min",
   "or",
   "type",
   "(",
   "v",
   ")",
   ">=",
   "max",
   ":",
   "raise",
   "ValueError",
   "(",
   "v",
   ")",
   "return",
   "checker"
  ]
 },
 {
  "idx": "maxmin-460",
  "nl_tokens": [
   "Prepare",
   "the",
   "activity",
   "for",
   "execution",
   "."
  ],
  "pl_tokens": [
   "def",
   "prepare_to_run",
   "(",
   "self",
   ",",
   "clock",
   ",",
   "period_count",
   ")",
   ":",
   "if",
   "self",
   ".",
   "start_period_ix",
   "==",
   "-",
   "1",
   "and",
   "self",
   ".",
   "start_datetime",
   "!=",
   "datetime",
   ".",
   "<mask>",
   ":",
   "# Set the Start period index",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "period_count",
   ")",
   ":",
   "if",
   "clock",
   ".",
   "get_datetime_at_period_ix",
   "(",
   "i",
   ")",
   ">",
   "self",
   ".",
   "start_datetime",
   ":",
   "self",
   ".",
   "start_period_ix",
   "=",
   "i",
   "break",
   "if",
   "self",
   ".",
   "start_period_ix",
   "==",
   "-",
   "1",
   ":",
   "self",
   ".",
   "start_period_ix",
   "=",
   "0",
   "if",
   "self",
   ".",
   "period_count",
   "==",
   "-",
   "1",
   "and",
   "self",
   ".",
   "end_datetime",
   "!=",
   "datetime",
   ".",
   "max",
   ":",
   "# Set the Start date",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "period_count",
   ")",
   ":",
   "if",
   "clock",
   ".",
   "get_datetime_at_period_ix",
   "(",
   "i",
   ")",
   ">",
   "self",
   ".",
   "end_datetime",
   ":",
   "self",
   ".",
   "period_count",
   "=",
   "i",
   "-",
   "self",
   ".",
   "start_period_ix",
   "break",
   "if",
   "self",
   ".",
   "period_count",
   "!=",
   "-",
   "1",
   ":",
   "self",
   ".",
   "end_period_ix",
   "=",
   "self",
   ".",
   "start_period_ix",
   "+",
   "self",
   ".",
   "period_count",
   "else",
   ":",
   "self",
   ".",
   "end_period_ix",
   "=",
   "self",
   ".",
   "start_period_ix",
   "+",
   "period_count"
  ]
 },
 {
  "idx": "maxmin-461",
  "nl_tokens": [
   "This",
   "function",
   "will",
   "attempt",
   "to",
   "identify",
   "1",
   "sigma",
   "errors",
   "assuming",
   "your",
   "function",
   "is",
   "a",
   "chi^2",
   ".",
   "For",
   "this",
   "the",
   "1",
   "-",
   "sigma",
   "is",
   "bracketed",
   ".",
   "If",
   "you",
   "were",
   "smart",
   "enough",
   "to",
   "build",
   "a",
   "cache",
   "list",
   "of",
   "[",
   "x",
   "y",
   "]",
   "into",
   "your",
   "function",
   "you",
   "can",
   "pass",
   "it",
   "here",
   ".",
   "The",
   "values",
   "bracketing",
   "1",
   "sigma",
   "will",
   "be",
   "used",
   "as",
   "starting",
   "values",
   ".",
   "If",
   "no",
   "such",
   "values",
   "exist",
   "e",
   ".",
   "g",
   ".",
   "because",
   "all",
   "values",
   "were",
   "very",
   "close",
   "to",
   "the",
   "optimum",
   "(",
   "good",
   "starting",
   "values",
   ")",
   "the",
   "bracket",
   "is",
   "expanded",
   "."
  ],
  "pl_tokens": [
   "def",
   "cache2errors",
   "(",
   "function",
   ",",
   "cache",
   ",",
   "disp",
   "=",
   "0",
   ",",
   "ftol",
   "=",
   "0.05",
   ")",
   ":",
   "vals",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "sorted",
   "(",
   "cache",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   ")",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "' --- cache2errors --- '",
   ",",
   "vals",
   "vi",
   "=",
   "vals",
   "[",
   ":",
   ",",
   "1",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "def",
   "renormedfunc",
   "(",
   "x",
   ")",
   ":",
   "y",
   "=",
   "function",
   "(",
   "x",
   ")",
   "cache",
   ".",
   "append",
   "(",
   "[",
   "x",
   ",",
   "y",
   "]",
   ")",
   "if",
   "disp",
   ">",
   "1",
   ":",
   "print",
   "'    renormed:'",
   ",",
   "x",
   ",",
   "y",
   ",",
   "y",
   "-",
   "(",
   "vi",
   "+",
   "1",
   ")",
   "return",
   "y",
   "-",
   "(",
   "vi",
   "+",
   "1",
   ")",
   "vals",
   "[",
   ":",
   ",",
   "1",
   "]",
   "-=",
   "vi",
   "+",
   "1",
   "lowmask",
   "=",
   "vals",
   "[",
   ":",
   ",",
   "1",
   "]",
   "<",
   "0",
   "highmask",
   "=",
   "vals",
   "[",
   ":",
   ",",
   "1",
   "]",
   ">",
   "0",
   "indices",
   "=",
   "numpy",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "vals",
   ")",
   ")",
   "b",
   ",",
   "vb",
   "=",
   "vals",
   "[",
   "indices",
   "[",
   "lowmask",
   "]",
   "[",
   "0",
   "]",
   ",",
   ":",
   "]",
   "c",
   ",",
   "vc",
   "=",
   "vals",
   "[",
   "indices",
   "[",
   "lowmask",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   ":",
   "]",
   "if",
   "any",
   "(",
   "vals",
   "[",
   ":",
   ",",
   "0",
   "]",
   "[",
   "highmask",
   "]",
   "<",
   "b",
   ")",
   ":",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'already have bracket'",
   "a",
   ",",
   "va",
   "=",
   "vals",
   "[",
   "indices",
   "[",
   "highmask",
   "]",
   "[",
   "vals",
   "[",
   ":",
   ",",
   "0",
   "]",
   "[",
   "highmask",
   "]",
   "<",
   "b",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   ":",
   "]",
   "else",
   ":",
   "a",
   "=",
   "b",
   "va",
   "=",
   "vb",
   "while",
   "b",
   ">",
   "-",
   "50",
   ":",
   "a",
   "=",
   "b",
   "-",
   "max",
   "(",
   "vals",
   "[",
   "-",
   "1",
   ",",
   "0",
   "]",
   "-",
   "vals",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "1",
   ")",
   "va",
   "=",
   "renormedfunc",
   "(",
   "a",
   ")",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'going further left: %.1f [%.1f] --> %.1f [%.1f]'",
   "%",
   "(",
   "b",
   ",",
   "vb",
   ",",
   "a",
   ",",
   "va",
   ")",
   "if",
   "va",
   ">",
   "0",
   ":",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'found outer part'",
   "break",
   "else",
   ":",
   "# need to go further",
   "b",
   "=",
   "a",
   "vb",
   "=",
   "va",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'left  bracket'",
   ",",
   "a",
   ",",
   "b",
   ",",
   "va",
   ",",
   "vb",
   "if",
   "va",
   ">",
   "0",
   "and",
   "vb",
   "<",
   "0",
   ":",
   "leftroot",
   "=",
   "scipy",
   ".",
   "optimize",
   ".",
   "brentq",
   "(",
   "renormedfunc",
   ",",
   "a",
   ",",
   "b",
   ",",
   "rtol",
   "=",
   "ftol",
   ")",
   "else",
   ":",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'WARNING: border problem found.'",
   "leftroot",
   "=",
   "a",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'left  root'",
   ",",
   "leftroot",
   "if",
   "any",
   "(",
   "vals",
   "[",
   ":",
   ",",
   "0",
   "]",
   "[",
   "highmask",
   "]",
   ">",
   "c",
   ")",
   ":",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'already have bracket'",
   "d",
   ",",
   "vd",
   "=",
   "vals",
   "[",
   "indices",
   "[",
   "highmask",
   "]",
   "[",
   "vals",
   "[",
   ":",
   ",",
   "0",
   "]",
   "[",
   "highmask",
   "]",
   ">",
   "c",
   "]",
   "[",
   "0",
   "]",
   ",",
   ":",
   "]",
   "else",
   ":",
   "d",
   "=",
   "c",
   "vd",
   "=",
   "vc",
   "while",
   "c",
   "<",
   "50",
   ":",
   "d",
   "=",
   "c",
   "+",
   "max",
   "(",
   "vals",
   "[",
   "-",
   "1",
   ",",
   "0",
   "]",
   "-",
   "vals",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "1",
   ")",
   "vd",
   "=",
   "renormedfunc",
   "(",
   "d",
   ")",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'going further right: %.1f [%.1f] --> %.1f [%.1f]'",
   "%",
   "(",
   "c",
   ",",
   "vc",
   ",",
   "d",
   ",",
   "vd",
   ")",
   "if",
   "vd",
   ">",
   "0",
   ":",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'found outer part'",
   "break",
   "else",
   ":",
   "# need to go further",
   "c",
   "=",
   "d",
   "vc",
   "=",
   "vd",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'right bracket'",
   ",",
   "c",
   ",",
   "d",
   ",",
   "vc",
   ",",
   "vd",
   "if",
   "vd",
   ">",
   "0",
   "and",
   "vc",
   "<",
   "0",
   ":",
   "rightroot",
   "=",
   "scipy",
   ".",
   "optimize",
   ".",
   "brentq",
   "(",
   "renormedfunc",
   ",",
   "c",
   ",",
   "d",
   ",",
   "rtol",
   "=",
   "ftol",
   ")",
   "else",
   ":",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'WARNING: border problem found.'",
   "rightroot",
   "=",
   "d",
   "if",
   "disp",
   ">",
   "0",
   ":",
   "print",
   "'right root'",
   ",",
   "rightroot",
   "assert",
   "leftroot",
   "<",
   "rightroot",
   "if",
   "disp",
   ">",
   "2",
   ":",
   "fullvals",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "sorted",
   "(",
   "cache",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   ")",
   "fullvals",
   "[",
   ":",
   ",",
   "1",
   "]",
   "-=",
   "vi",
   "+",
   "1",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "fullvals",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "fullvals",
   "[",
   ":",
   ",",
   "1",
   "]",
   ",",
   "'s'",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "vals",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "vals",
   "[",
   ":",
   ",",
   "1",
   "]",
   ",",
   "'o'",
   ")",
   "plt",
   ".",
   "xlim",
   "(",
   "a",
   ",",
   "d",
   ")",
   "plt",
   ".",
   "ylim",
   "(",
   "min",
   "(",
   "va",
   ",",
   "vb",
   ",",
   "vc",
   ",",
   "vd",
   ")",
   ",",
   "max",
   "(",
   "va",
   ",",
   "vb",
   ",",
   "vc",
   ",",
   "vd",
   ")",
   ")",
   "ymin",
   ",",
   "ymax",
   "=",
   "plt",
   ".",
   "ylim",
   "(",
   ")",
   "plt",
   ".",
   "vlines",
   "(",
   "[",
   "leftroot",
   ",",
   "rightroot",
   "]",
   ",",
   "ymin",
   ",",
   "ymax",
   ",",
   "linestyles",
   "=",
   "'dotted'",
   ")",
   "plt",
   ".",
   "savefig",
   "(",
   "'cache_brent.pdf'",
   ")",
   "return",
   "leftroot",
   ",",
   "rightroot"
  ]
 },
 {
  "idx": "maxmin-462",
  "nl_tokens": [
   "A",
   "dask",
   "relay",
   "function",
   "to",
   "fill",
   "chroms",
   "for",
   "all",
   "samples"
  ],
  "pl_tokens": [
   "def",
   "dask_chroms",
   "(",
   "data",
   ",",
   "samples",
   ")",
   ":",
   "## example concatenating with dask",
   "h5s",
   "=",
   "[",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "across",
   ",",
   "s",
   ".",
   "name",
   "+",
   "\".tmp.h5\"",
   ")",
   "for",
   "s",
   "in",
   "samples",
   "]",
   "handles",
   "=",
   "[",
   "h5py",
   ".",
   "File",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "h5s",
   "]",
   "dsets",
   "=",
   "[",
   "i",
   "[",
   "'/ichrom'",
   "]",
   "for",
   "i",
   "in",
   "handles",
   "]",
   "arrays",
   "=",
   "[",
   "da",
   ".",
   "from_array",
   "(",
   "dset",
   ",",
   "chunks",
   "=",
   "(",
   "10000",
   ",",
   "3",
   ")",
   ")",
   "for",
   "dset",
   "in",
   "dsets",
   "]",
   "stack",
   "=",
   "da",
   ".",
   "stack",
   "(",
   "arrays",
   ",",
   "axis",
   "=",
   "2",
   ")",
   "## max chrom (should we check for variable hits? if so, things can get wonk)",
   "maxchrom",
   "=",
   "da",
   ".",
   "<mask>",
   "(",
   "stack",
   ",",
   "axis",
   "=",
   "2",
   ")",
   "[",
   ":",
   ",",
   "0",
   "]",
   "## max pos",
   "maxpos",
   "=",
   "da",
   ".",
   "max",
   "(",
   "stack",
   ",",
   "axis",
   "=",
   "2",
   ")",
   "[",
   ":",
   ",",
   "2",
   "]",
   "## min pos",
   "mask",
   "=",
   "stack",
   "==",
   "0",
   "stack",
   "[",
   "mask",
   "]",
   "=",
   "9223372036854775807",
   "## max int64 value",
   "minpos",
   "=",
   "da",
   ".",
   "min",
   "(",
   "stack",
   ",",
   "axis",
   "=",
   "2",
   ")",
   "[",
   ":",
   ",",
   "1",
   "]",
   "final",
   "=",
   "da",
   ".",
   "stack",
   "(",
   "[",
   "maxchrom",
   ",",
   "minpos",
   ",",
   "maxpos",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "final",
   ".",
   "to_hdf5",
   "(",
   "data",
   ".",
   "clust_database",
   ",",
   "\"/chroms\"",
   ")",
   "## close the h5 handles",
   "_",
   "=",
   "[",
   "i",
   ".",
   "close",
   "(",
   ")",
   "for",
   "i",
   "in",
   "handles",
   "]"
  ]
 },
 {
  "idx": "maxmin-463",
  "nl_tokens": [
   "Convert",
   "line",
   "spectral",
   "frequencies",
   "to",
   "prediction",
   "filter",
   "coefficients"
  ],
  "pl_tokens": [
   "def",
   "lsf2poly",
   "(",
   "lsf",
   ")",
   ":",
   "#   Reference: A.M. Kondoz, \"Digital Speech: Coding for Low Bit Rate Communications",
   "#   Systems\" John Wiley & Sons 1994 ,Chapter 4",
   "# Line spectral frequencies must be real.",
   "lsf",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "lsf",
   ")",
   "if",
   "<mask>",
   "(",
   "lsf",
   ")",
   ">",
   "numpy",
   ".",
   "pi",
   "or",
   "min",
   "(",
   "lsf",
   ")",
   "<",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Line spectral frequencies must be between 0 and pi.'",
   ")",
   "p",
   "=",
   "len",
   "(",
   "lsf",
   ")",
   "# model order",
   "# Form zeros using the LSFs and unit amplitudes",
   "z",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "1.j",
   "*",
   "lsf",
   ")",
   "# Separate the zeros to those belonging to P and Q",
   "rQ",
   "=",
   "z",
   "[",
   "0",
   ":",
   ":",
   "2",
   "]",
   "rP",
   "=",
   "z",
   "[",
   "1",
   ":",
   ":",
   "2",
   "]",
   "# Include the conjugates as well",
   "rQ",
   "=",
   "numpy",
   ".",
   "concatenate",
   "(",
   "(",
   "rQ",
   ",",
   "rQ",
   ".",
   "conjugate",
   "(",
   ")",
   ")",
   ")",
   "rP",
   "=",
   "numpy",
   ".",
   "concatenate",
   "(",
   "(",
   "rP",
   ",",
   "rP",
   ".",
   "conjugate",
   "(",
   ")",
   ")",
   ")",
   "# Form the polynomials P and Q, note that these should be real",
   "Q",
   "=",
   "numpy",
   ".",
   "poly",
   "(",
   "rQ",
   ")",
   "P",
   "=",
   "numpy",
   ".",
   "poly",
   "(",
   "rP",
   ")",
   "# Form the sum and difference filters by including known roots at z = 1 and",
   "# z = -1",
   "if",
   "p",
   "%",
   "2",
   ":",
   "# Odd order: z = +1 and z = -1 are roots of the difference filter, P1(z)",
   "P1",
   "=",
   "numpy",
   ".",
   "convolve",
   "(",
   "P",
   ",",
   "[",
   "1",
   ",",
   "0",
   ",",
   "-",
   "1",
   "]",
   ")",
   "Q1",
   "=",
   "Q",
   "else",
   ":",
   "# Even order: z = -1 is a root of the sum filter, Q1(z) and z = 1 is a",
   "# root of the difference filter, P1(z)",
   "P1",
   "=",
   "numpy",
   ".",
   "convolve",
   "(",
   "P",
   ",",
   "[",
   "1",
   ",",
   "-",
   "1",
   "]",
   ")",
   "Q1",
   "=",
   "numpy",
   ".",
   "convolve",
   "(",
   "Q",
   ",",
   "[",
   "1",
   ",",
   "1",
   "]",
   ")",
   "# Prediction polynomial is formed by averaging P1 and Q1",
   "a",
   "=",
   ".5",
   "*",
   "(",
   "P1",
   "+",
   "Q1",
   ")",
   "return",
   "a",
   "[",
   "0",
   ":",
   "-",
   "1",
   ":",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-464",
  "nl_tokens": [
   "Given",
   "a",
   "series",
   "of",
   "anomaly",
   "scores",
   "compute",
   "the",
   "likelihood",
   "for",
   "each",
   "score",
   ".",
   "This",
   "function",
   "should",
   "be",
   "called",
   "once",
   "on",
   "a",
   "bunch",
   "of",
   "historical",
   "anomaly",
   "scores",
   "for",
   "an",
   "initial",
   "estimate",
   "of",
   "the",
   "distribution",
   ".",
   "It",
   "should",
   "be",
   "called",
   "again",
   "every",
   "so",
   "often",
   "(",
   "say",
   "every",
   "50",
   "records",
   ")",
   "to",
   "update",
   "the",
   "estimate",
   "."
  ],
  "pl_tokens": [
   "def",
   "estimateAnomalyLikelihoods",
   "(",
   "anomalyScores",
   ",",
   "averagingWindow",
   "=",
   "10",
   ",",
   "skipRecords",
   "=",
   "0",
   ",",
   "verbosity",
   "=",
   "0",
   ")",
   ":",
   "if",
   "verbosity",
   ">",
   "1",
   ":",
   "print",
   "(",
   "\"In estimateAnomalyLikelihoods.\"",
   ")",
   "print",
   "(",
   "\"Number of anomaly scores:\"",
   ",",
   "len",
   "(",
   "anomalyScores",
   ")",
   ")",
   "print",
   "(",
   "\"Skip records=\"",
   ",",
   "skipRecords",
   ")",
   "print",
   "(",
   "\"First 20:\"",
   ",",
   "anomalyScores",
   "[",
   "0",
   ":",
   "<mask>",
   "(",
   "20",
   ",",
   "len",
   "(",
   "anomalyScores",
   ")",
   ")",
   "]",
   ")",
   "if",
   "len",
   "(",
   "anomalyScores",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Must have at least one anomalyScore\"",
   ")",
   "# Compute averaged anomaly scores",
   "aggRecordList",
   ",",
   "historicalValues",
   ",",
   "total",
   "=",
   "_anomalyScoreMovingAverage",
   "(",
   "anomalyScores",
   ",",
   "windowSize",
   "=",
   "averagingWindow",
   ",",
   "verbosity",
   "=",
   "verbosity",
   ")",
   "s",
   "=",
   "[",
   "r",
   "[",
   "2",
   "]",
   "for",
   "r",
   "in",
   "aggRecordList",
   "]",
   "dataValues",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "s",
   ")",
   "# Estimate the distribution of anomaly scores based on aggregated records",
   "if",
   "len",
   "(",
   "aggRecordList",
   ")",
   "<=",
   "skipRecords",
   ":",
   "distributionParams",
   "=",
   "nullDistribution",
   "(",
   "verbosity",
   "=",
   "verbosity",
   ")",
   "else",
   ":",
   "distributionParams",
   "=",
   "estimateNormal",
   "(",
   "dataValues",
   "[",
   "skipRecords",
   ":",
   "]",
   ")",
   "# HACK ALERT! The HTMPredictionModel currently does not handle constant",
   "# metric values very well (time of day encoder changes sometimes lead to",
   "# unstable SDR's even though the metric is constant). Until this is",
   "# resolved, we explicitly detect and handle completely flat metric values by",
   "# reporting them as not anomalous.",
   "s",
   "=",
   "[",
   "r",
   "[",
   "1",
   "]",
   "for",
   "r",
   "in",
   "aggRecordList",
   "]",
   "# Only do this if the values are numeric",
   "if",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "r",
   "[",
   "1",
   "]",
   ",",
   "numbers",
   ".",
   "Number",
   ")",
   "for",
   "r",
   "in",
   "aggRecordList",
   "]",
   ")",
   ":",
   "metricValues",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "s",
   ")",
   "metricDistribution",
   "=",
   "estimateNormal",
   "(",
   "metricValues",
   "[",
   "skipRecords",
   ":",
   "]",
   ",",
   "performLowerBoundCheck",
   "=",
   "False",
   ")",
   "if",
   "metricDistribution",
   "[",
   "\"variance\"",
   "]",
   "<",
   "1.5e-5",
   ":",
   "distributionParams",
   "=",
   "nullDistribution",
   "(",
   "verbosity",
   "=",
   "verbosity",
   ")",
   "# Estimate likelihoods based on this distribution",
   "likelihoods",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "dataValues",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "for",
   "i",
   ",",
   "s",
   "in",
   "enumerate",
   "(",
   "dataValues",
   ")",
   ":",
   "likelihoods",
   "[",
   "i",
   "]",
   "=",
   "tailProbability",
   "(",
   "s",
   ",",
   "distributionParams",
   ")",
   "# Filter likelihood values",
   "filteredLikelihoods",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "_filterLikelihoods",
   "(",
   "likelihoods",
   ")",
   ")",
   "params",
   "=",
   "{",
   "\"distribution\"",
   ":",
   "distributionParams",
   ",",
   "\"movingAverage\"",
   ":",
   "{",
   "\"historicalValues\"",
   ":",
   "historicalValues",
   ",",
   "\"total\"",
   ":",
   "total",
   ",",
   "\"windowSize\"",
   ":",
   "averagingWindow",
   ",",
   "}",
   ",",
   "\"historicalLikelihoods\"",
   ":",
   "list",
   "(",
   "likelihoods",
   "[",
   "-",
   "min",
   "(",
   "averagingWindow",
   ",",
   "len",
   "(",
   "likelihoods",
   ")",
   ")",
   ":",
   "]",
   ")",
   ",",
   "}",
   "if",
   "verbosity",
   ">",
   "1",
   ":",
   "print",
   "(",
   "\"Discovered params=\"",
   ")",
   "print",
   "(",
   "params",
   ")",
   "print",
   "(",
   "\"Number of likelihoods:\"",
   ",",
   "len",
   "(",
   "likelihoods",
   ")",
   ")",
   "print",
   "(",
   "\"First 20 likelihoods:\"",
   ",",
   "(",
   "filteredLikelihoods",
   "[",
   "0",
   ":",
   "min",
   "(",
   "20",
   ",",
   "len",
   "(",
   "filteredLikelihoods",
   ")",
   ")",
   "]",
   ")",
   ")",
   "print",
   "(",
   "\"leaving estimateAnomalyLikelihoods\"",
   ")",
   "return",
   "(",
   "filteredLikelihoods",
   ",",
   "aggRecordList",
   ",",
   "params",
   ")"
  ]
 },
 {
  "idx": "maxmin-465",
  "nl_tokens": [
   "Format",
   "the",
   "exception",
   "part",
   "of",
   "a",
   "traceback",
   "."
  ],
  "pl_tokens": [
   "def",
   "format_exception_only",
   "(",
   "etype",
   ",",
   "value",
   ")",
   ":",
   "# An instance should not have a meaningful value parameter, but",
   "# sometimes does, particularly for string exceptions, such as",
   "# >>> raise string1, string2  # deprecated",
   "#",
   "# Clear these out first because issubtype(string1, SyntaxError)",
   "# would raise another exception and mask the original problem.",
   "if",
   "(",
   "isinstance",
   "(",
   "etype",
   ",",
   "BaseException",
   ")",
   "or",
   "#        isinstance(etype, types.InstanceType) or",
   "etype",
   "is",
   "None",
   "or",
   "type",
   "(",
   "etype",
   ")",
   "is",
   "str",
   ")",
   ":",
   "return",
   "[",
   "_format_final_exc_line",
   "(",
   "etype",
   ",",
   "value",
   ")",
   "]",
   "stype",
   "=",
   "etype",
   ".",
   "__name__",
   "if",
   "not",
   "issubclass",
   "(",
   "etype",
   ",",
   "SyntaxError",
   ")",
   ":",
   "return",
   "[",
   "_format_final_exc_line",
   "(",
   "stype",
   ",",
   "value",
   ")",
   "]",
   "# It was a syntax error; show exactly where the problem was found.",
   "lines",
   "=",
   "[",
   "]",
   "try",
   ":",
   "msg",
   ",",
   "(",
   "filename",
   ",",
   "lineno",
   ",",
   "offset",
   ",",
   "badline",
   ")",
   "=",
   "value",
   ".",
   "args",
   "except",
   "Exception",
   ":",
   "pass",
   "else",
   ":",
   "filename",
   "=",
   "filename",
   "or",
   "\"<string>\"",
   "lines",
   ".",
   "append",
   "(",
   "'  File \"%s\", line %d\\n'",
   "%",
   "(",
   "filename",
   ",",
   "lineno",
   ")",
   ")",
   "if",
   "badline",
   "is",
   "not",
   "None",
   ":",
   "lines",
   ".",
   "append",
   "(",
   "'    %s\\n'",
   "%",
   "badline",
   ".",
   "strip",
   "(",
   ")",
   ")",
   "if",
   "offset",
   "is",
   "not",
   "None",
   ":",
   "caretspace",
   "=",
   "badline",
   ".",
   "rstrip",
   "(",
   "'\\n'",
   ")",
   "offset",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "caretspace",
   ")",
   ",",
   "offset",
   ")",
   "-",
   "1",
   "caretspace",
   "=",
   "caretspace",
   "[",
   ":",
   "offset",
   "]",
   ".",
   "lstrip",
   "(",
   ")",
   "# non-space whitespace (likes tabs) must be kept for alignment",
   "caretspace",
   "=",
   "(",
   "(",
   "c",
   ".",
   "isspace",
   "(",
   ")",
   "and",
   "c",
   "or",
   "' '",
   ")",
   "for",
   "c",
   "in",
   "caretspace",
   ")",
   "lines",
   ".",
   "append",
   "(",
   "'    %s^\\n'",
   "%",
   "''",
   ".",
   "join",
   "(",
   "caretspace",
   ")",
   ")",
   "value",
   "=",
   "msg",
   "lines",
   ".",
   "append",
   "(",
   "_format_final_exc_line",
   "(",
   "stype",
   ",",
   "value",
   ")",
   ")",
   "return",
   "lines"
  ]
 },
 {
  "idx": "maxmin-466",
  "nl_tokens": [
   "Render",
   "the",
   "segmentation",
   "map",
   "as",
   "an",
   "RGB",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw",
   "(",
   "self",
   ",",
   "size",
   "=",
   "None",
   ",",
   "background_threshold",
   "=",
   "0.01",
   ",",
   "background_class_id",
   "=",
   "None",
   ",",
   "colors",
   "=",
   "None",
   ",",
   "return_foreground_mask",
   "=",
   "False",
   ")",
   ":",
   "arr",
   "=",
   "self",
   ".",
   "get_arr_int",
   "(",
   "background_threshold",
   "=",
   "background_threshold",
   ",",
   "background_class_id",
   "=",
   "background_class_id",
   ")",
   "nb_classes",
   "=",
   "1",
   "+",
   "np",
   ".",
   "<mask>",
   "(",
   "arr",
   ")",
   "segmap_drawn",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "arr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "arr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "3",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "uint8",
   ")",
   "if",
   "colors",
   "is",
   "None",
   ":",
   "colors",
   "=",
   "SegmentationMapOnImage",
   ".",
   "DEFAULT_SEGMENT_COLORS",
   "ia",
   ".",
   "do_assert",
   "(",
   "nb_classes",
   "<=",
   "len",
   "(",
   "colors",
   ")",
   ",",
   "\"Can't draw all %d classes as it would exceed the maximum number of %d available colors.\"",
   "%",
   "(",
   "nb_classes",
   ",",
   "len",
   "(",
   "colors",
   ")",
   ",",
   ")",
   ")",
   "ids_in_map",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "arr",
   ")",
   "for",
   "c",
   ",",
   "color",
   "in",
   "zip",
   "(",
   "sm",
   ".",
   "xrange",
   "(",
   "nb_classes",
   ")",
   ",",
   "colors",
   ")",
   ":",
   "if",
   "c",
   "in",
   "ids_in_map",
   ":",
   "class_mask",
   "=",
   "(",
   "arr",
   "==",
   "c",
   ")",
   "segmap_drawn",
   "[",
   "class_mask",
   "]",
   "=",
   "color",
   "if",
   "return_foreground_mask",
   ":",
   "background_class_id",
   "=",
   "0",
   "if",
   "background_class_id",
   "is",
   "None",
   "else",
   "background_class_id",
   "foreground_mask",
   "=",
   "(",
   "arr",
   "!=",
   "background_class_id",
   ")",
   "else",
   ":",
   "foreground_mask",
   "=",
   "None",
   "if",
   "size",
   "is",
   "not",
   "None",
   ":",
   "segmap_drawn",
   "=",
   "ia",
   ".",
   "imresize_single_image",
   "(",
   "segmap_drawn",
   ",",
   "size",
   ",",
   "interpolation",
   "=",
   "\"nearest\"",
   ")",
   "if",
   "foreground_mask",
   "is",
   "not",
   "None",
   ":",
   "foreground_mask",
   "=",
   "ia",
   ".",
   "imresize_single_image",
   "(",
   "foreground_mask",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   ",",
   "size",
   ",",
   "interpolation",
   "=",
   "\"nearest\"",
   ")",
   ">",
   "0",
   "if",
   "foreground_mask",
   "is",
   "not",
   "None",
   ":",
   "return",
   "segmap_drawn",
   ",",
   "foreground_mask",
   "return",
   "segmap_drawn"
  ]
 },
 {
  "idx": "maxmin-467",
  "nl_tokens": [
   "Return",
   "Snowball",
   "Danish",
   "stem",
   "."
  ],
  "pl_tokens": [
   "def",
   "stem",
   "(",
   "self",
   ",",
   "word",
   ")",
   ":",
   "# lowercase, normalize, and compose",
   "word",
   "=",
   "normalize",
   "(",
   "'NFC'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "lower",
   "(",
   ")",
   ")",
   ")",
   "r1_start",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "3",
   ",",
   "self",
   ".",
   "_sb_r1",
   "(",
   "word",
   ")",
   ")",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   "# Step 1",
   "_r1",
   "=",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   "if",
   "_r1",
   "[",
   "-",
   "7",
   ":",
   "]",
   "==",
   "'erendes'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "7",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "6",
   ":",
   "]",
   "in",
   "{",
   "'erende'",
   ",",
   "'hedens'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "6",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "5",
   ":",
   "]",
   "in",
   "{",
   "'ethed'",
   ",",
   "'erede'",
   ",",
   "'heden'",
   ",",
   "'heder'",
   ",",
   "'endes'",
   ",",
   "'ernes'",
   ",",
   "'erens'",
   ",",
   "'erets'",
   ",",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "5",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "4",
   ":",
   "]",
   "in",
   "{",
   "'ered'",
   ",",
   "'ende'",
   ",",
   "'erne'",
   ",",
   "'eren'",
   ",",
   "'erer'",
   ",",
   "'heds'",
   ",",
   "'enes'",
   ",",
   "'eres'",
   ",",
   "'eret'",
   ",",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "3",
   ":",
   "]",
   "in",
   "{",
   "'hed'",
   ",",
   "'ene'",
   ",",
   "'ere'",
   ",",
   "'ens'",
   ",",
   "'ers'",
   ",",
   "'ets'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'en'",
   ",",
   "'er'",
   ",",
   "'es'",
   ",",
   "'et'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'e'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'s'",
   ":",
   "if",
   "len",
   "(",
   "word",
   ")",
   ">",
   "1",
   "and",
   "word",
   "[",
   "-",
   "2",
   "]",
   "in",
   "self",
   ".",
   "_s_endings",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# Step 2",
   "if",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'gd'",
   ",",
   "'dt'",
   ",",
   "'gt'",
   ",",
   "'kt'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# Step 3",
   "if",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'igst'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "_r1",
   "=",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   "repeat_step2",
   "=",
   "False",
   "if",
   "_r1",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'elig'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "repeat_step2",
   "=",
   "True",
   "elif",
   "_r1",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'l\u00f8st':",
   "",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "elif",
   "_r1",
   "[",
   "-",
   "3",
   ":",
   "]",
   "in",
   "{",
   "'lig'",
   ",",
   "'els'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "repeat_step2",
   "=",
   "True",
   "elif",
   "_r1",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'ig'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "repeat_step2",
   "=",
   "True",
   "if",
   "repeat_step2",
   ":",
   "if",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   "[",
   "-",
   "2",
   ":",
   "]",
   "in",
   "{",
   "'gd'",
   ",",
   "'dt'",
   ",",
   "'gt'",
   ",",
   "'kt'",
   "}",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# Step 4",
   "if",
   "(",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "1",
   "and",
   "len",
   "(",
   "word",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "1",
   "]",
   "==",
   "word",
   "[",
   "-",
   "2",
   "]",
   "and",
   "word",
   "[",
   "-",
   "1",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "return",
   "word"
  ]
 },
 {
  "idx": "maxmin-468",
  "nl_tokens": [
   "Get",
   "support",
   "size",
   "and",
   "drift",
   "polynomial",
   "for",
   "current",
   "set",
   "of",
   "params"
  ],
  "pl_tokens": [
   "def",
   "characterize_psf",
   "(",
   "self",
   ")",
   ":",
   "# there may be an issue with the support and characterization--",
   "# it might be best to do the characterization with the same support",
   "# as the calculated psf.",
   "l",
   ",",
   "u",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "zrange",
   "[",
   "0",
   "]",
   ",",
   "self",
   ".",
   "param_dict",
   "[",
   "'psf-zslab'",
   "]",
   ")",
   ",",
   "self",
   ".",
   "zrange",
   "[",
   "1",
   "]",
   "size_l",
   ",",
   "drift_l",
   "=",
   "self",
   ".",
   "measure_size_drift",
   "(",
   "l",
   ")",
   "size_u",
   ",",
   "drift_u",
   "=",
   "self",
   ".",
   "measure_size_drift",
   "(",
   "u",
   ")",
   "# must be odd for now or have a better system for getting the center",
   "self",
   ".",
   "support",
   "=",
   "util",
   ".",
   "oddify",
   "(",
   "2",
   "*",
   "self",
   ".",
   "support_factor",
   "*",
   "size_u",
   ".",
   "astype",
   "(",
   "'int'",
   ")",
   ")",
   "self",
   ".",
   "drift_poly",
   "=",
   "np",
   ".",
   "polyfit",
   "(",
   "[",
   "l",
   ",",
   "u",
   "]",
   ",",
   "[",
   "drift_l",
   ",",
   "drift_u",
   "]",
   ",",
   "1",
   ")",
   "if",
   "self",
   ".",
   "cutoffval",
   "is",
   "not",
   "None",
   ":",
   "psf",
   ",",
   "vec",
   ",",
   "size_l",
   "=",
   "self",
   ".",
   "psf_slice",
   "(",
   "l",
   ",",
   "size",
   "=",
   "51",
   ",",
   "zoffset",
   "=",
   "drift_l",
   ",",
   "getextent",
   "=",
   "True",
   ")",
   "psf",
   ",",
   "vec",
   ",",
   "size_u",
   "=",
   "self",
   ".",
   "psf_slice",
   "(",
   "u",
   ",",
   "size",
   "=",
   "51",
   ",",
   "zoffset",
   "=",
   "drift_u",
   ",",
   "getextent",
   "=",
   "True",
   ")",
   "ss",
   "=",
   "[",
   "np",
   ".",
   "abs",
   "(",
   "i",
   ")",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "for",
   "i",
   "in",
   "[",
   "size_l",
   ",",
   "size_u",
   "]",
   "]",
   "self",
   ".",
   "support",
   "=",
   "util",
   ".",
   "oddify",
   "(",
   "util",
   ".",
   "amax",
   "(",
   "*",
   "ss",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-469",
  "nl_tokens": [
   "reads",
   "in",
   ".",
   "loci",
   "and",
   "builds",
   "alleles",
   "from",
   "case",
   "characters"
  ],
  "pl_tokens": [
   "def",
   "make",
   "(",
   "data",
   ",",
   "samples",
   ")",
   ":",
   "#read in loci file",
   "outfile",
   "=",
   "open",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".alleles\"",
   ")",
   ",",
   "'w'",
   ")",
   "lines",
   "=",
   "open",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "data",
   ".",
   "name",
   "+",
   "\".loci\"",
   ")",
   ",",
   "'r'",
   ")",
   "## Get the longest sample name for pretty printing",
   "longname",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "data",
   ".",
   "samples",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "## Padding between name and sequence in output file. This should be the ",
   "## same as write_outfiles.write_tmp_loci.name_padding",
   "name_padding",
   "=",
   "5",
   "writing",
   "=",
   "[",
   "]",
   "loc",
   "=",
   "0",
   "for",
   "line",
   "in",
   "lines",
   ":",
   "if",
   "\">\"",
   "in",
   "line",
   ":",
   "name",
   ",",
   "seq",
   "=",
   "line",
   ".",
   "split",
   "(",
   "\" \"",
   ")",
   "[",
   "0",
   "]",
   ",",
   "line",
   ".",
   "split",
   "(",
   "\" \"",
   ")",
   "[",
   "-",
   "1",
   "]",
   "allele1",
   ",",
   "allele2",
   "=",
   "splitalleles",
   "(",
   "seq",
   ".",
   "strip",
   "(",
   ")",
   ")",
   "## Format the output string. the \"-2\" below accounts for the additional",
   "## 2 characters added to the sample name that don't get added to the",
   "## snpsites line, so you gotta bump this line back 2 to make it",
   "## line up right.",
   "writing",
   ".",
   "append",
   "(",
   "name",
   "+",
   "\"_0\"",
   "+",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "name",
   ")",
   "-",
   "2",
   "+",
   "name_padding",
   ")",
   "+",
   "allele1",
   ")",
   "writing",
   ".",
   "append",
   "(",
   "name",
   "+",
   "\"_1\"",
   "+",
   "\" \"",
   "*",
   "(",
   "longname",
   "-",
   "len",
   "(",
   "name",
   ")",
   "-",
   "2",
   "+",
   "name_padding",
   ")",
   "+",
   "allele2",
   ")",
   "else",
   ":",
   "writing",
   ".",
   "append",
   "(",
   "line",
   ".",
   "strip",
   "(",
   ")",
   ")",
   "loc",
   "+=",
   "1",
   "## print every 10K loci \"",
   "if",
   "not",
   "loc",
   "%",
   "10000",
   ":",
   "outfile",
   ".",
   "write",
   "(",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "writing",
   ")",
   "+",
   "\"\\n\"",
   ")",
   "writing",
   "=",
   "[",
   "]",
   "outfile",
   ".",
   "write",
   "(",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "writing",
   ")",
   ")",
   "outfile",
   ".",
   "close",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-470",
  "nl_tokens": [
   "Return",
   "the",
   "NCD",
   "between",
   "two",
   "strings",
   "using",
   "zlib",
   "compression",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "src",
   "=",
   "src",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   "tar",
   "=",
   "tar",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   "self",
   ".",
   "_compressor",
   ".",
   "compress",
   "(",
   "src",
   ")",
   "src_comp",
   "=",
   "self",
   ".",
   "_compressor",
   ".",
   "flush",
   "(",
   "zlib",
   ".",
   "Z_FULL_FLUSH",
   ")",
   "self",
   ".",
   "_compressor",
   ".",
   "compress",
   "(",
   "tar",
   ")",
   "tar_comp",
   "=",
   "self",
   ".",
   "_compressor",
   ".",
   "flush",
   "(",
   "zlib",
   ".",
   "Z_FULL_FLUSH",
   ")",
   "self",
   ".",
   "_compressor",
   ".",
   "compress",
   "(",
   "src",
   "+",
   "tar",
   ")",
   "concat_comp",
   "=",
   "self",
   ".",
   "_compressor",
   ".",
   "flush",
   "(",
   "zlib",
   ".",
   "Z_FULL_FLUSH",
   ")",
   "self",
   ".",
   "_compressor",
   ".",
   "compress",
   "(",
   "tar",
   "+",
   "src",
   ")",
   "concat_comp2",
   "=",
   "self",
   ".",
   "_compressor",
   ".",
   "flush",
   "(",
   "zlib",
   ".",
   "Z_FULL_FLUSH",
   ")",
   "return",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "concat_comp",
   ")",
   ",",
   "len",
   "(",
   "concat_comp2",
   ")",
   ")",
   "-",
   "min",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")",
   ")",
   "/",
   "max",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-471",
  "nl_tokens": [
   "maxSearchSeconds",
   ":",
   "float",
   "searchIntervalSeconds",
   ":",
   "float",
   "Check",
   "if",
   "control",
   "disappears",
   "every",
   "searchIntervalSeconds",
   "seconds",
   "in",
   "maxSearchSeconds",
   "seconds",
   ".",
   "Return",
   "bool",
   "True",
   "if",
   "control",
   "disappears",
   "."
  ],
  "pl_tokens": [
   "def",
   "Disappears",
   "(",
   "self",
   ",",
   "maxSearchSeconds",
   ":",
   "float",
   "=",
   "5",
   ",",
   "searchIntervalSeconds",
   ":",
   "float",
   "=",
   "SEARCH_INTERVAL",
   ",",
   "printIfNotDisappear",
   ":",
   "bool",
   "=",
   "False",
   ")",
   "->",
   "bool",
   ":",
   "global",
   "DEBUG_EXIST_DISAPPEAR",
   "start",
   "=",
   "ProcessTime",
   "(",
   ")",
   "while",
   "True",
   ":",
   "temp",
   "=",
   "DEBUG_EXIST_DISAPPEAR",
   "DEBUG_EXIST_DISAPPEAR",
   "=",
   "False",
   "# do not print for Exists",
   "if",
   "not",
   "self",
   ".",
   "Exists",
   "(",
   "0",
   ",",
   "0",
   ",",
   "False",
   ")",
   ":",
   "DEBUG_EXIST_DISAPPEAR",
   "=",
   "temp",
   "return",
   "True",
   "DEBUG_EXIST_DISAPPEAR",
   "=",
   "temp",
   "remain",
   "=",
   "start",
   "+",
   "maxSearchSeconds",
   "-",
   "ProcessTime",
   "(",
   ")",
   "if",
   "remain",
   ">",
   "0",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "<mask>",
   "(",
   "remain",
   ",",
   "searchIntervalSeconds",
   ")",
   ")",
   "else",
   ":",
   "if",
   "printIfNotDisappear",
   "or",
   "DEBUG_EXIST_DISAPPEAR",
   ":",
   "Logger",
   ".",
   "ColorfullyWriteLine",
   "(",
   "self",
   ".",
   "GetColorfulSearchPropertiesStr",
   "(",
   ")",
   "+",
   "'<Color=Red> does not disappear.</Color>'",
   ")",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-472",
  "nl_tokens": [
   "Add",
   "the",
   "label",
   "labelName",
   "to",
   "each",
   "record",
   "with",
   "record",
   "ROWID",
   "in",
   "range",
   "from",
   "start",
   "to",
   "end",
   "noninclusive",
   "of",
   "end",
   "."
  ],
  "pl_tokens": [
   "def",
   "addLabel",
   "(",
   "self",
   ",",
   "start",
   ",",
   "end",
   ",",
   "labelName",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for 'addLabel'. \"",
   "\"Model has no saved records.\"",
   ")",
   "startID",
   "=",
   "self",
   ".",
   "saved_states",
   "[",
   "0",
   "]",
   ".",
   "ROWID",
   "clippedStart",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "start",
   "-",
   "startID",
   ")",
   "clippedEnd",
   "=",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   ",",
   "end",
   "-",
   "startID",
   ")",
   ")",
   "if",
   "clippedEnd",
   "<=",
   "clippedStart",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for 'addLabel'.\"",
   ",",
   "debugInfo",
   "=",
   "{",
   "'requestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "start",
   ",",
   "'endRecordID'",
   ":",
   "end",
   "}",
   ",",
   "'clippedRequestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "clippedStart",
   ",",
   "'endRecordID'",
   ":",
   "clippedEnd",
   "}",
   ",",
   "'validRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "startID",
   ",",
   "'endRecordID'",
   ":",
   "self",
   ".",
   "saved_states",
   "[",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "-",
   "1",
   "]",
   ".",
   "ROWID",
   "}",
   ",",
   "'numRecordsStored'",
   ":",
   "len",
   "(",
   "self",
   ".",
   "saved_states",
   ")",
   "}",
   ")",
   "# Add label to range [clippedStart, clippedEnd)",
   "for",
   "state",
   "in",
   "self",
   ".",
   "saved_states",
   "[",
   "clippedStart",
   ":",
   "clippedEnd",
   "]",
   ":",
   "if",
   "labelName",
   "not",
   "in",
   "state",
   ".",
   "anomalyLabel",
   ":",
   "state",
   ".",
   "anomalyLabel",
   ".",
   "append",
   "(",
   "labelName",
   ")",
   "state",
   ".",
   "setByUser",
   "=",
   "True",
   "self",
   ".",
   "_addRecordToKNN",
   "(",
   "state",
   ")",
   "assert",
   "len",
   "(",
   "self",
   ".",
   "saved_categories",
   ")",
   ">",
   "0",
   "# Recompute [end, ...)",
   "for",
   "state",
   "in",
   "self",
   ".",
   "saved_states",
   "[",
   "clippedEnd",
   ":",
   "]",
   ":",
   "self",
   ".",
   "_updateState",
   "(",
   "state",
   ")"
  ]
 },
 {
  "idx": "maxmin-473",
  "nl_tokens": [
   "z",
   "value",
   "as",
   "like",
   "a",
   "seed"
  ],
  "pl_tokens": [
   "def",
   "snoise2d",
   "(",
   "size",
   ",",
   "z",
   "=",
   "0.0",
   ",",
   "scale",
   "=",
   "0.05",
   ",",
   "octaves",
   "=",
   "1",
   ",",
   "persistence",
   "=",
   "0.25",
   ",",
   "lacunarity",
   "=",
   "2.0",
   ")",
   ":",
   "import",
   "noise",
   "data",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "size",
   ",",
   "dtype",
   "=",
   "'float32'",
   ")",
   "for",
   "y",
   "in",
   "range",
   "(",
   "size",
   "[",
   "0",
   "]",
   ")",
   ":",
   "for",
   "x",
   "in",
   "range",
   "(",
   "size",
   "[",
   "1",
   "]",
   ")",
   ":",
   "v",
   "=",
   "noise",
   ".",
   "snoise3",
   "(",
   "x",
   "*",
   "scale",
   ",",
   "y",
   "*",
   "scale",
   ",",
   "z",
   ",",
   "octaves",
   "=",
   "octaves",
   ",",
   "persistence",
   "=",
   "persistence",
   ",",
   "lacunarity",
   "=",
   "lacunarity",
   ")",
   "data",
   "[",
   "x",
   ",",
   "y",
   "]",
   "=",
   "v",
   "data",
   "=",
   "data",
   "*",
   "0.5",
   "+",
   "0.5",
   "if",
   "__debug__",
   ":",
   "assert",
   "data",
   ".",
   "<mask>",
   "(",
   ")",
   ">=",
   "0.",
   "and",
   "data",
   ".",
   "max",
   "(",
   ")",
   "<=",
   "1.0",
   "return",
   "data"
  ]
 },
 {
  "idx": "maxmin-474",
  "nl_tokens": [
   "Remix",
   "the",
   "channels",
   "of",
   "an",
   "audio",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "remix",
   "(",
   "self",
   ",",
   "remix_dictionary",
   "=",
   "None",
   ",",
   "num_output_channels",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "(",
   "isinstance",
   "(",
   "remix_dictionary",
   ",",
   "dict",
   ")",
   "or",
   "remix_dictionary",
   "is",
   "None",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"remix_dictionary must be a dictionary or None.\"",
   ")",
   "if",
   "remix_dictionary",
   "is",
   "not",
   "None",
   ":",
   "if",
   "not",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "i",
   ",",
   "int",
   ")",
   "and",
   "i",
   ">",
   "0",
   "for",
   "i",
   "in",
   "remix_dictionary",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"remix dictionary must have positive integer keys.\"",
   ")",
   "if",
   "not",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "v",
   ",",
   "list",
   ")",
   "for",
   "v",
   "in",
   "remix_dictionary",
   ".",
   "values",
   "(",
   ")",
   "]",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"remix dictionary values must be lists.\"",
   ")",
   "for",
   "v_list",
   "in",
   "remix_dictionary",
   ".",
   "values",
   "(",
   ")",
   ":",
   "if",
   "not",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "v",
   ",",
   "int",
   ")",
   "and",
   "v",
   ">",
   "0",
   "for",
   "v",
   "in",
   "v_list",
   "]",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"elements of remix dictionary values must \"",
   "\"be positive integers\"",
   ")",
   "if",
   "not",
   "(",
   "(",
   "isinstance",
   "(",
   "num_output_channels",
   ",",
   "int",
   ")",
   "and",
   "num_output_channels",
   ">",
   "0",
   ")",
   "or",
   "num_output_channels",
   "is",
   "None",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"num_output_channels must be a positive integer or None.\"",
   ")",
   "effect_args",
   "=",
   "[",
   "'remix'",
   "]",
   "if",
   "remix_dictionary",
   "is",
   "None",
   ":",
   "effect_args",
   ".",
   "append",
   "(",
   "'-'",
   ")",
   "else",
   ":",
   "if",
   "num_output_channels",
   "is",
   "None",
   ":",
   "num_output_channels",
   "=",
   "<mask>",
   "(",
   "remix_dictionary",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "for",
   "channel",
   "in",
   "range",
   "(",
   "1",
   ",",
   "num_output_channels",
   "+",
   "1",
   ")",
   ":",
   "if",
   "channel",
   "in",
   "remix_dictionary",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "out_channel",
   "=",
   "','",
   ".",
   "join",
   "(",
   "[",
   "str",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "remix_dictionary",
   "[",
   "channel",
   "]",
   "]",
   ")",
   "else",
   ":",
   "out_channel",
   "=",
   "'0'",
   "effect_args",
   ".",
   "append",
   "(",
   "out_channel",
   ")",
   "self",
   ".",
   "effects",
   ".",
   "extend",
   "(",
   "effect_args",
   ")",
   "self",
   ".",
   "effects_log",
   ".",
   "append",
   "(",
   "'remix'",
   ")",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-475",
  "nl_tokens": [
   "Compute",
   "a",
   "cubic",
   "Bezier",
   "approximation",
   "of",
   "an",
   "elliptical",
   "arc",
   "."
  ],
  "pl_tokens": [
   "def",
   "bezier_arc",
   "(",
   "x1",
   ",",
   "y1",
   ",",
   "x2",
   ",",
   "y2",
   ",",
   "start_angle",
   "=",
   "0",
   ",",
   "extent",
   "=",
   "90",
   ")",
   ":",
   "x1",
   ",",
   "y1",
   ",",
   "x2",
   ",",
   "y2",
   "=",
   "<mask>",
   "(",
   "x1",
   ",",
   "x2",
   ")",
   ",",
   "max",
   "(",
   "y1",
   ",",
   "y2",
   ")",
   ",",
   "max",
   "(",
   "x1",
   ",",
   "x2",
   ")",
   ",",
   "min",
   "(",
   "y1",
   ",",
   "y2",
   ")",
   "if",
   "abs",
   "(",
   "extent",
   ")",
   "<=",
   "90",
   ":",
   "frag_angle",
   "=",
   "float",
   "(",
   "extent",
   ")",
   "nfrag",
   "=",
   "1",
   "else",
   ":",
   "nfrag",
   "=",
   "int",
   "(",
   "ceil",
   "(",
   "abs",
   "(",
   "extent",
   ")",
   "/",
   "90.",
   ")",
   ")",
   "if",
   "nfrag",
   "==",
   "0",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "'Invalid value for extent: %r'",
   "%",
   "extent",
   ")",
   "return",
   "[",
   "]",
   "frag_angle",
   "=",
   "float",
   "(",
   "extent",
   ")",
   "/",
   "nfrag",
   "x_cen",
   "=",
   "(",
   "x1",
   "+",
   "x2",
   ")",
   "/",
   "2.",
   "y_cen",
   "=",
   "(",
   "y1",
   "+",
   "y2",
   ")",
   "/",
   "2.",
   "rx",
   "=",
   "(",
   "x2",
   "-",
   "x1",
   ")",
   "/",
   "2.",
   "ry",
   "=",
   "(",
   "y2",
   "-",
   "y1",
   ")",
   "/",
   "2.",
   "half_angle",
   "=",
   "radians",
   "(",
   "frag_angle",
   ")",
   "/",
   "2",
   "kappa",
   "=",
   "abs",
   "(",
   "4.",
   "/",
   "3.",
   "*",
   "(",
   "1.",
   "-",
   "cos",
   "(",
   "half_angle",
   ")",
   ")",
   "/",
   "sin",
   "(",
   "half_angle",
   ")",
   ")",
   "if",
   "frag_angle",
   "<",
   "0",
   ":",
   "sign",
   "=",
   "-",
   "1",
   "else",
   ":",
   "sign",
   "=",
   "1",
   "point_list",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "nfrag",
   ")",
   ":",
   "theta0",
   "=",
   "radians",
   "(",
   "start_angle",
   "+",
   "i",
   "*",
   "frag_angle",
   ")",
   "theta1",
   "=",
   "radians",
   "(",
   "start_angle",
   "+",
   "(",
   "i",
   "+",
   "1",
   ")",
   "*",
   "frag_angle",
   ")",
   "c0",
   "=",
   "cos",
   "(",
   "theta0",
   ")",
   "c1",
   "=",
   "cos",
   "(",
   "theta1",
   ")",
   "s0",
   "=",
   "sin",
   "(",
   "theta0",
   ")",
   "s1",
   "=",
   "sin",
   "(",
   "theta1",
   ")",
   "if",
   "frag_angle",
   ">",
   "0",
   ":",
   "signed_kappa",
   "=",
   "-",
   "kappa",
   "else",
   ":",
   "signed_kappa",
   "=",
   "kappa",
   "point_list",
   ".",
   "append",
   "(",
   "(",
   "x_cen",
   "+",
   "rx",
   "*",
   "c0",
   ",",
   "y_cen",
   "-",
   "ry",
   "*",
   "s0",
   ",",
   "x_cen",
   "+",
   "rx",
   "*",
   "(",
   "c0",
   "+",
   "signed_kappa",
   "*",
   "s0",
   ")",
   ",",
   "y_cen",
   "-",
   "ry",
   "*",
   "(",
   "s0",
   "-",
   "signed_kappa",
   "*",
   "c0",
   ")",
   ",",
   "x_cen",
   "+",
   "rx",
   "*",
   "(",
   "c1",
   "-",
   "signed_kappa",
   "*",
   "s1",
   ")",
   ",",
   "y_cen",
   "-",
   "ry",
   "*",
   "(",
   "s1",
   "+",
   "signed_kappa",
   "*",
   "c1",
   ")",
   ",",
   "x_cen",
   "+",
   "rx",
   "*",
   "c1",
   ",",
   "y_cen",
   "-",
   "ry",
   "*",
   "s1",
   ")",
   ")",
   "return",
   "point_list"
  ]
 },
 {
  "idx": "maxmin-476",
  "nl_tokens": [
   "Generates",
   "a",
   "frequency",
   "count",
   "of",
   "each",
   "rating",
   "on",
   "the",
   "scale",
   "ratings",
   "is",
   "a",
   "list",
   "of",
   "scores",
   "Returns",
   "a",
   "list",
   "of",
   "frequencies"
  ],
  "pl_tokens": [
   "def",
   "histogram",
   "(",
   "ratings",
   ",",
   "min_rating",
   "=",
   "None",
   ",",
   "max_rating",
   "=",
   "None",
   ")",
   ":",
   "ratings",
   "=",
   "[",
   "int",
   "(",
   "r",
   ")",
   "for",
   "r",
   "in",
   "ratings",
   "]",
   "if",
   "min_rating",
   "is",
   "None",
   ":",
   "min_rating",
   "=",
   "<mask>",
   "(",
   "ratings",
   ")",
   "if",
   "max_rating",
   "is",
   "None",
   ":",
   "max_rating",
   "=",
   "max",
   "(",
   "ratings",
   ")",
   "num_ratings",
   "=",
   "int",
   "(",
   "max_rating",
   "-",
   "min_rating",
   "+",
   "1",
   ")",
   "hist_ratings",
   "=",
   "[",
   "0",
   "for",
   "x",
   "in",
   "range",
   "(",
   "num_ratings",
   ")",
   "]",
   "for",
   "r",
   "in",
   "ratings",
   ":",
   "hist_ratings",
   "[",
   "r",
   "-",
   "min_rating",
   "]",
   "+=",
   "1",
   "return",
   "hist_ratings"
  ]
 },
 {
  "idx": "maxmin-477",
  "nl_tokens": [
   "r",
   "Calculates",
   "vapor",
   "pressure",
   "of",
   "a",
   "chemical",
   "using",
   "the",
   "TRC",
   "Extended",
   "Antoine",
   "equation",
   ".",
   "Parameters",
   "are",
   "chemical",
   "dependent",
   "and",
   "said",
   "to",
   "be",
   "from",
   "the",
   "Thermodynamics",
   "Research",
   "Center",
   "(",
   "TRC",
   ")",
   "at",
   "Texas",
   "A&M",
   ".",
   "Coefficients",
   "for",
   "various",
   "chemicals",
   "can",
   "be",
   "found",
   "in",
   "[",
   "1",
   "]",
   "_",
   "."
  ],
  "pl_tokens": [
   "def",
   "TRC_Antoine_extended",
   "(",
   "T",
   ",",
   "Tc",
   ",",
   "to",
   ",",
   "A",
   ",",
   "B",
   ",",
   "C",
   ",",
   "n",
   ",",
   "E",
   ",",
   "F",
   ")",
   ":",
   "x",
   "=",
   "<mask>",
   "(",
   "(",
   "T",
   "-",
   "to",
   "-",
   "273.15",
   ")",
   "/",
   "Tc",
   ",",
   "0.",
   ")",
   "return",
   "10.",
   "**",
   "(",
   "A",
   "-",
   "B",
   "/",
   "(",
   "T",
   "+",
   "C",
   ")",
   "+",
   "0.43429",
   "*",
   "x",
   "**",
   "n",
   "+",
   "E",
   "*",
   "x",
   "**",
   "8",
   "+",
   "F",
   "*",
   "x",
   "**",
   "12",
   ")"
  ]
 },
 {
  "idx": "maxmin-478",
  "nl_tokens": [
   "Compute",
   "the",
   "union",
   "bounding",
   "box",
   "of",
   "this",
   "bounding",
   "box",
   "and",
   "another",
   "one",
   "."
  ],
  "pl_tokens": [
   "def",
   "union",
   "(",
   "self",
   ",",
   "other",
   ")",
   ":",
   "return",
   "BoundingBox",
   "(",
   "x1",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "x1",
   ",",
   "other",
   ".",
   "x1",
   ")",
   ",",
   "y1",
   "=",
   "min",
   "(",
   "self",
   ".",
   "y1",
   ",",
   "other",
   ".",
   "y1",
   ")",
   ",",
   "x2",
   "=",
   "max",
   "(",
   "self",
   ".",
   "x2",
   ",",
   "other",
   ".",
   "x2",
   ")",
   ",",
   "y2",
   "=",
   "max",
   "(",
   "self",
   ".",
   "y2",
   ",",
   "other",
   ".",
   "y2",
   ")",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-479",
  "nl_tokens": [
   "Lowest",
   "value",
   "of",
   "input",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "imgmin",
   "(",
   "self",
   ")",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "self",
   ",",
   "'_imgmin'",
   ")",
   ":",
   "imgmin",
   "=",
   "_np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "images",
   "[",
   "0",
   "]",
   ")",
   "for",
   "img",
   "in",
   "self",
   ".",
   "images",
   ":",
   "imin",
   "=",
   "_np",
   ".",
   "min",
   "(",
   "img",
   ")",
   "if",
   "imin",
   ">",
   "imgmin",
   ":",
   "imgmin",
   "=",
   "imin",
   "self",
   ".",
   "_imgmin",
   "=",
   "imgmin",
   "return",
   "_np",
   ".",
   "min",
   "(",
   "self",
   ".",
   "image",
   ")"
  ]
 },
 {
  "idx": "maxmin-480",
  "nl_tokens": [
   "Pad",
   "short",
   "rows",
   "to",
   "the",
   "length",
   "of",
   "the",
   "longest",
   "row",
   "to",
   "help",
   "render",
   "jagged",
   "CSV",
   "files"
  ],
  "pl_tokens": [
   "def",
   "normalize_cols",
   "(",
   "table",
   ")",
   ":",
   "longest_row_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "row",
   ")",
   "for",
   "row",
   "in",
   "table",
   "]",
   ")",
   "for",
   "row",
   "in",
   "table",
   ":",
   "while",
   "len",
   "(",
   "row",
   ")",
   "<",
   "longest_row_len",
   ":",
   "row",
   ".",
   "append",
   "(",
   "''",
   ")",
   "return",
   "table"
  ]
 },
 {
  "idx": "maxmin-481",
  "nl_tokens": [
   "Resolve",
   "the",
   "points",
   "to",
   "make",
   "a",
   "line",
   "between",
   "two",
   "points",
   "."
  ],
  "pl_tokens": [
   "def",
   "line",
   "(",
   "self",
   ",",
   "p1",
   ",",
   "p2",
   ",",
   "resolution",
   "=",
   "1",
   ")",
   ":",
   "xdiff",
   "=",
   "<mask>",
   "(",
   "p1",
   ".",
   "x",
   ",",
   "p2",
   ".",
   "x",
   ")",
   "-",
   "min",
   "(",
   "p1",
   ".",
   "x",
   ",",
   "p2",
   ".",
   "x",
   ")",
   "ydiff",
   "=",
   "max",
   "(",
   "p1",
   ".",
   "y",
   ",",
   "p2",
   ".",
   "y",
   ")",
   "-",
   "min",
   "(",
   "p1",
   ".",
   "y",
   ",",
   "p2",
   ".",
   "y",
   ")",
   "xdir",
   "=",
   "[",
   "-",
   "1",
   ",",
   "1",
   "]",
   "[",
   "int",
   "(",
   "p1",
   ".",
   "x",
   "<=",
   "p2",
   ".",
   "x",
   ")",
   "]",
   "ydir",
   "=",
   "[",
   "-",
   "1",
   ",",
   "1",
   "]",
   "[",
   "int",
   "(",
   "p1",
   ".",
   "y",
   "<=",
   "p2",
   ".",
   "y",
   ")",
   "]",
   "r",
   "=",
   "int",
   "(",
   "round",
   "(",
   "max",
   "(",
   "xdiff",
   ",",
   "ydiff",
   ")",
   ")",
   ")",
   "if",
   "r",
   "==",
   "0",
   ":",
   "return",
   "for",
   "i",
   "in",
   "range",
   "(",
   "(",
   "r",
   "+",
   "1",
   ")",
   "*",
   "resolution",
   ")",
   ":",
   "x",
   "=",
   "p1",
   ".",
   "x",
   "y",
   "=",
   "p1",
   ".",
   "y",
   "if",
   "xdiff",
   ":",
   "x",
   "+=",
   "(",
   "float",
   "(",
   "i",
   ")",
   "*",
   "xdiff",
   ")",
   "/",
   "r",
   "*",
   "xdir",
   "/",
   "resolution",
   "if",
   "ydiff",
   ":",
   "y",
   "+=",
   "(",
   "float",
   "(",
   "i",
   ")",
   "*",
   "ydiff",
   ")",
   "/",
   "r",
   "*",
   "ydir",
   "/",
   "resolution",
   "yield",
   "Point",
   "(",
   "(",
   "x",
   ",",
   "y",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-482",
  "nl_tokens": [
   "Sonify",
   "multi",
   "-",
   "level",
   "segmentations"
  ],
  "pl_tokens": [
   "def",
   "multi_segment",
   "(",
   "annotation",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "length",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# Pentatonic scale, because why not",
   "PENT",
   "=",
   "[",
   "1",
   ",",
   "32.",
   "/",
   "27",
   ",",
   "4.",
   "/",
   "3",
   ",",
   "3.",
   "/",
   "2",
   ",",
   "16.",
   "/",
   "9",
   "]",
   "DURATION",
   "=",
   "0.1",
   "h_int",
   ",",
   "_",
   "=",
   "hierarchy_flatten",
   "(",
   "annotation",
   ")",
   "if",
   "length",
   "is",
   "None",
   ":",
   "length",
   "=",
   "int",
   "(",
   "sr",
   "*",
   "(",
   "<mask>",
   "(",
   "np",
   ".",
   "max",
   "(",
   "_",
   ")",
   "for",
   "_",
   "in",
   "h_int",
   ")",
   "+",
   "1.",
   "/",
   "DURATION",
   ")",
   "+",
   "1",
   ")",
   "y",
   "=",
   "0.0",
   "for",
   "ints",
   ",",
   "(",
   "oc",
   ",",
   "scale",
   ")",
   "in",
   "zip",
   "(",
   "h_int",
   ",",
   "product",
   "(",
   "range",
   "(",
   "3",
   ",",
   "3",
   "+",
   "len",
   "(",
   "h_int",
   ")",
   ")",
   ",",
   "PENT",
   ")",
   ")",
   ":",
   "click",
   "=",
   "mkclick",
   "(",
   "440.0",
   "*",
   "scale",
   "*",
   "oc",
   ",",
   "sr",
   "=",
   "sr",
   ",",
   "duration",
   "=",
   "DURATION",
   ")",
   "y",
   "=",
   "y",
   "+",
   "filter_kwargs",
   "(",
   "mir_eval",
   ".",
   "sonify",
   ".",
   "clicks",
   ",",
   "np",
   ".",
   "unique",
   "(",
   "ints",
   ")",
   ",",
   "fs",
   "=",
   "sr",
   ",",
   "length",
   "=",
   "length",
   ",",
   "click",
   "=",
   "click",
   ")",
   "return",
   "y"
  ]
 },
 {
  "idx": "maxmin-483",
  "nl_tokens": [
   "axis",
   "is",
   "the",
   "axis",
   "to",
   "chop",
   "it",
   "off",
   ".",
   "if",
   "self",
   ".",
   "altreduce",
   "is",
   "set",
   "the",
   "results",
   "will",
   "be",
   "reduced",
   "with",
   "altreduce",
   "and",
   "returned",
   "otherwise",
   "will",
   "be",
   "saved",
   "to",
   "out",
   "then",
   "return",
   "out",
   "."
  ],
  "pl_tokens": [
   "def",
   "call",
   "(",
   "self",
   ",",
   "args",
   ",",
   "axis",
   "=",
   "0",
   ",",
   "out",
   "=",
   "None",
   ",",
   "chunksize",
   "=",
   "1024",
   "*",
   "1024",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "self",
   ".",
   "altreduce",
   "is",
   "not",
   "None",
   ":",
   "ret",
   "=",
   "[",
   "None",
   "]",
   "else",
   ":",
   "if",
   "out",
   "is",
   "None",
   ":",
   "if",
   "self",
   ".",
   "outdtype",
   "is",
   "not",
   "None",
   ":",
   "dtype",
   "=",
   "self",
   ".",
   "outdtype",
   "else",
   ":",
   "try",
   ":",
   "dtype",
   "=",
   "numpy",
   ".",
   "result_type",
   "(",
   "*",
   "[",
   "args",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ins",
   "]",
   "*",
   "2",
   ")",
   "except",
   ":",
   "dtype",
   "=",
   "None",
   "out",
   "=",
   "sharedmem",
   ".",
   "empty",
   "(",
   "numpy",
   ".",
   "broadcast",
   "(",
   "*",
   "[",
   "args",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ins",
   "]",
   "*",
   "2",
   ")",
   ".",
   "shape",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "if",
   "axis",
   "!=",
   "0",
   ":",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ins",
   ":",
   "args",
   "[",
   "i",
   "]",
   "=",
   "numpy",
   ".",
   "rollaxis",
   "(",
   "args",
   "[",
   "i",
   "]",
   ",",
   "axis",
   ")",
   "out",
   "=",
   "numpy",
   ".",
   "rollaxis",
   "(",
   "out",
   ",",
   "axis",
   ")",
   "size",
   "=",
   "numpy",
   ".",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "args",
   "[",
   "i",
   "]",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ins",
   "]",
   ")",
   "with",
   "sharedmem",
   ".",
   "MapReduce",
   "(",
   ")",
   "as",
   "pool",
   ":",
   "def",
   "work",
   "(",
   "i",
   ")",
   ":",
   "sl",
   "=",
   "slice",
   "(",
   "i",
   ",",
   "i",
   "+",
   "chunksize",
   ")",
   "myargs",
   "=",
   "args",
   "[",
   ":",
   "]",
   "for",
   "j",
   "in",
   "self",
   ".",
   "ins",
   ":",
   "try",
   ":",
   "tmp",
   "=",
   "myargs",
   "[",
   "j",
   "]",
   "[",
   "sl",
   "]",
   "a",
   ",",
   "b",
   ",",
   "c",
   "=",
   "sl",
   ".",
   "indices",
   "(",
   "len",
   "(",
   "args",
   "[",
   "j",
   "]",
   ")",
   ")",
   "myargs",
   "[",
   "j",
   "]",
   "=",
   "tmp",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "print",
   "tmp",
   "print",
   "j",
   ",",
   "e",
   "pass",
   "if",
   "b",
   "==",
   "a",
   ":",
   "return",
   "None",
   "rt",
   "=",
   "self",
   ".",
   "ufunc",
   "(",
   "*",
   "myargs",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "if",
   "self",
   ".",
   "altreduce",
   "is",
   "not",
   "None",
   ":",
   "return",
   "rt",
   "else",
   ":",
   "out",
   "[",
   "sl",
   "]",
   "=",
   "rt",
   "def",
   "reduce",
   "(",
   "rt",
   ")",
   ":",
   "if",
   "self",
   ".",
   "altreduce",
   "is",
   "None",
   ":",
   "return",
   "if",
   "ret",
   "[",
   "0",
   "]",
   "is",
   "None",
   ":",
   "ret",
   "[",
   "0",
   "]",
   "=",
   "rt",
   "elif",
   "rt",
   "is",
   "not",
   "None",
   ":",
   "ret",
   "[",
   "0",
   "]",
   "=",
   "self",
   ".",
   "altreduce",
   "(",
   "ret",
   "[",
   "0",
   "]",
   ",",
   "rt",
   ")",
   "pool",
   ".",
   "map",
   "(",
   "work",
   ",",
   "range",
   "(",
   "0",
   ",",
   "size",
   ",",
   "chunksize",
   ")",
   ",",
   "reduce",
   "=",
   "reduce",
   ")",
   "if",
   "self",
   ".",
   "altreduce",
   "is",
   "None",
   ":",
   "if",
   "axis",
   "!=",
   "0",
   ":",
   "out",
   "=",
   "numpy",
   ".",
   "rollaxis",
   "(",
   "out",
   ",",
   "0",
   ",",
   "axis",
   "+",
   "1",
   ")",
   "return",
   "out",
   "else",
   ":",
   "return",
   "ret",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-484",
  "nl_tokens": [
   "Determine",
   "if",
   "distance",
   "over",
   "antimeridian",
   "is",
   "shorter",
   "than",
   "normal",
   "distance",
   "."
  ],
  "pl_tokens": [
   "def",
   "_shift_required",
   "(",
   "tiles",
   ")",
   ":",
   "if",
   "tiles",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ".",
   "tile_pyramid",
   ".",
   "is_global",
   ":",
   "# get set of tile columns",
   "tile_cols",
   "=",
   "sorted",
   "(",
   "list",
   "(",
   "set",
   "(",
   "[",
   "t",
   "[",
   "0",
   "]",
   ".",
   "col",
   "for",
   "t",
   "in",
   "tiles",
   "]",
   ")",
   ")",
   ")",
   "# if tile columns are an unbroken sequence, tiles are connected and are not",
   "# passing the Antimeridian",
   "if",
   "tile_cols",
   "==",
   "list",
   "(",
   "range",
   "(",
   "<mask>",
   "(",
   "tile_cols",
   ")",
   ",",
   "max",
   "(",
   "tile_cols",
   ")",
   "+",
   "1",
   ")",
   ")",
   ":",
   "return",
   "False",
   "else",
   ":",
   "# look at column gaps and try to determine the smallest distance",
   "def",
   "gen_groups",
   "(",
   "items",
   ")",
   ":",
   "\"\"\"Groups tile columns by sequence.\"\"\"",
   "j",
   "=",
   "items",
   "[",
   "0",
   "]",
   "group",
   "=",
   "[",
   "j",
   "]",
   "for",
   "i",
   "in",
   "items",
   "[",
   "1",
   ":",
   "]",
   ":",
   "# item is next in expected sequence",
   "if",
   "i",
   "==",
   "j",
   "+",
   "1",
   ":",
   "group",
   ".",
   "append",
   "(",
   "i",
   ")",
   "# gap occured, so yield existing group and create new one",
   "else",
   ":",
   "yield",
   "group",
   "group",
   "=",
   "[",
   "i",
   "]",
   "j",
   "=",
   "i",
   "yield",
   "group",
   "groups",
   "=",
   "list",
   "(",
   "gen_groups",
   "(",
   "tile_cols",
   ")",
   ")",
   "# in case there is only one group, don't shift",
   "if",
   "len",
   "(",
   "groups",
   ")",
   "==",
   "1",
   ":",
   "return",
   "False",
   "# distance between first column of first group and last column of last group",
   "normal_distance",
   "=",
   "groups",
   "[",
   "-",
   "1",
   "]",
   "[",
   "-",
   "1",
   "]",
   "-",
   "groups",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "# distance between last column of first group and last column of first group",
   "# but crossing the antimeridian",
   "antimeridian_distance",
   "=",
   "(",
   "groups",
   "[",
   "0",
   "]",
   "[",
   "-",
   "1",
   "]",
   "+",
   "tiles",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ".",
   "tile_pyramid",
   ".",
   "matrix_width",
   "(",
   "tiles",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ".",
   "zoom",
   ")",
   ")",
   "-",
   "groups",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "# return whether distance over antimeridian is shorter",
   "return",
   "antimeridian_distance",
   "<",
   "normal_distance",
   "else",
   ":",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-485",
  "nl_tokens": [
   "Convert",
   "a",
   "dictionary",
   "of",
   "configuration",
   "values",
   "into",
   "a",
   "sequence",
   "of",
   "BlockadeContainerConfig",
   "instances"
  ],
  "pl_tokens": [
   "def",
   "from_dict",
   "(",
   "name",
   ",",
   "values",
   ")",
   ":",
   "# determine the number of instances of this container",
   "count",
   "=",
   "1",
   "count_value",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'count'",
   ",",
   "1",
   ")",
   "if",
   "isinstance",
   "(",
   "count_value",
   ",",
   "int",
   ")",
   ":",
   "count",
   "=",
   "<mask>",
   "(",
   "count_value",
   ",",
   "1",
   ")",
   "def",
   "with_index",
   "(",
   "name",
   ",",
   "idx",
   ")",
   ":",
   "if",
   "name",
   "and",
   "idx",
   ":",
   "return",
   "'%s_%d'",
   "%",
   "(",
   "name",
   ",",
   "idx",
   ")",
   "return",
   "name",
   "def",
   "get_instance",
   "(",
   "n",
   ",",
   "idx",
   "=",
   "None",
   ")",
   ":",
   "return",
   "BlockadeContainerConfig",
   "(",
   "with_index",
   "(",
   "n",
   ",",
   "idx",
   ")",
   ",",
   "values",
   "[",
   "'image'",
   "]",
   ",",
   "command",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'command'",
   ")",
   ",",
   "links",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'links'",
   ")",
   ",",
   "volumes",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'volumes'",
   ")",
   ",",
   "publish_ports",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'ports'",
   ")",
   ",",
   "expose_ports",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'expose'",
   ")",
   ",",
   "environment",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'environment'",
   ")",
   ",",
   "hostname",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'hostname'",
   ")",
   ",",
   "dns",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'dns'",
   ")",
   ",",
   "start_delay",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'start_delay'",
   ",",
   "0",
   ")",
   ",",
   "neutral",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'neutral'",
   ",",
   "False",
   ")",
   ",",
   "holy",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'holy'",
   ",",
   "False",
   ")",
   ",",
   "container_name",
   "=",
   "with_index",
   "(",
   "values",
   ".",
   "get",
   "(",
   "'container_name'",
   ")",
   ",",
   "idx",
   ")",
   ",",
   "cap_add",
   "=",
   "values",
   ".",
   "get",
   "(",
   "'cap_add'",
   ")",
   ")",
   "if",
   "count",
   "==",
   "1",
   ":",
   "yield",
   "get_instance",
   "(",
   "name",
   ")",
   "else",
   ":",
   "for",
   "idx",
   "in",
   "range",
   "(",
   "1",
   ",",
   "count",
   "+",
   "1",
   ")",
   ":",
   "# TODO: configurable name/index format",
   "yield",
   "get_instance",
   "(",
   "name",
   ",",
   "idx",
   ")"
  ]
 },
 {
  "idx": "maxmin-486",
  "nl_tokens": [
   "Adds",
   "options",
   "to",
   ":",
   "func",
   ":",
   "scipy",
   ".",
   "fftpack",
   ".",
   "rfft",
   ":"
  ],
  "pl_tokens": [
   "def",
   "fft",
   "(",
   "values",
   ",",
   "freq",
   "=",
   "None",
   ",",
   "timestamps",
   "=",
   "None",
   ",",
   "fill_missing",
   "=",
   "False",
   ")",
   ":",
   "# ======================================",
   "# Get frequency",
   "# ======================================",
   "if",
   "freq",
   "is",
   "None",
   ":",
   "from",
   ".",
   ".",
   "import",
   "qt",
   "freq",
   "=",
   "qt",
   ".",
   "getDouble",
   "(",
   "title",
   "=",
   "'Fourier Analysis'",
   ",",
   "text",
   "=",
   "'Frequency samples taken at:'",
   ",",
   "<mask>",
   "=",
   "0",
   ",",
   "decimals",
   "=",
   "2",
   ",",
   "value",
   "=",
   "1.0",
   ")",
   "freq",
   "=",
   "freq",
   ".",
   "input",
   "if",
   "fill_missing",
   ":",
   "(",
   "t_x",
   ",",
   "x_filled",
   ")",
   "=",
   "fill_missing_timestamps",
   "(",
   "timestamps",
   ",",
   "values",
   ")",
   "else",
   ":",
   "x_filled",
   "=",
   "values",
   "num_samples",
   "=",
   "_np",
   ".",
   "size",
   "(",
   "x_filled",
   ")",
   "xfft",
   "=",
   "_sp",
   ".",
   "fftpack",
   ".",
   "rfft",
   "(",
   "x_filled",
   ")",
   "factor",
   "=",
   "freq",
   "/",
   "num_samples",
   "num_fft",
   "=",
   "_np",
   ".",
   "size",
   "(",
   "xfft",
   ")",
   "f",
   "=",
   "factor",
   "*",
   "_np",
   ".",
   "linspace",
   "(",
   "1",
   ",",
   "num_fft",
   ",",
   "num_fft",
   ")",
   "xpow",
   "=",
   "_np",
   ".",
   "abs",
   "(",
   "xfft",
   "*",
   "_np",
   ".",
   "conj",
   "(",
   "xfft",
   ")",
   ")",
   "# ======================================",
   "# No DC term",
   "# ======================================",
   "xpow",
   "=",
   "xpow",
   "[",
   "1",
   ":",
   "]",
   "f",
   "=",
   "f",
   "[",
   "1",
   ":",
   "]",
   "return",
   "(",
   "f",
   ",",
   "xpow",
   ")"
  ]
 },
 {
  "idx": "maxmin-487",
  "nl_tokens": [
   "Scans",
   "through",
   "all",
   "local",
   ".",
   "crt",
   "files",
   "and",
   "displays",
   "the",
   "expiration",
   "dates",
   "."
  ],
  "pl_tokens": [
   "def",
   "list_expiration_dates",
   "(",
   "self",
   ",",
   "base",
   "=",
   "'roles/all/ssl'",
   ")",
   ":",
   "max_fn_len",
   "=",
   "0",
   "max_date_len",
   "=",
   "0",
   "data",
   "=",
   "[",
   "]",
   "for",
   "fn",
   "in",
   "os",
   ".",
   "listdir",
   "(",
   "base",
   ")",
   ":",
   "fqfn",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "base",
   ",",
   "fn",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "isfile",
   "(",
   "fqfn",
   ")",
   ":",
   "continue",
   "if",
   "not",
   "fn",
   ".",
   "endswith",
   "(",
   "'.crt'",
   ")",
   ":",
   "continue",
   "expiration_date",
   "=",
   "self",
   ".",
   "get_expiration_date",
   "(",
   "fqfn",
   ")",
   "max_fn_len",
   "=",
   "<mask>",
   "(",
   "max_fn_len",
   ",",
   "len",
   "(",
   "fn",
   ")",
   ")",
   "max_date_len",
   "=",
   "max",
   "(",
   "max_date_len",
   ",",
   "len",
   "(",
   "str",
   "(",
   "expiration_date",
   ")",
   ")",
   ")",
   "data",
   ".",
   "append",
   "(",
   "(",
   "fn",
   ",",
   "expiration_date",
   ")",
   ")",
   "print",
   "(",
   "'%s %s %s'",
   "%",
   "(",
   "'Filename'",
   ".",
   "ljust",
   "(",
   "max_fn_len",
   ")",
   ",",
   "'Expiration Date'",
   ".",
   "ljust",
   "(",
   "max_date_len",
   ")",
   ",",
   "'Expired'",
   ")",
   ")",
   "now",
   "=",
   "datetime",
   ".",
   "now",
   "(",
   ")",
   ".",
   "replace",
   "(",
   "tzinfo",
   "=",
   "pytz",
   ".",
   "UTC",
   ")",
   "for",
   "fn",
   ",",
   "dt",
   "in",
   "sorted",
   "(",
   "data",
   ")",
   ":",
   "if",
   "dt",
   "is",
   "None",
   ":",
   "expired",
   "=",
   "'?'",
   "elif",
   "dt",
   "<",
   "now",
   ":",
   "expired",
   "=",
   "'YES'",
   "else",
   ":",
   "expired",
   "=",
   "'NO'",
   "print",
   "(",
   "'%s %s %s'",
   "%",
   "(",
   "fn",
   ".",
   "ljust",
   "(",
   "max_fn_len",
   ")",
   ",",
   "str",
   "(",
   "dt",
   ")",
   ".",
   "ljust",
   "(",
   "max_date_len",
   ")",
   ",",
   "expired",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-488",
  "nl_tokens": [
   "return",
   "the",
   "average",
   "of",
   "part",
   "of",
   "the",
   "current",
   "sweep",
   "."
  ],
  "pl_tokens": [
   "def",
   "average",
   "(",
   "self",
   ",",
   "t1",
   "=",
   "0",
   ",",
   "t2",
   "=",
   "None",
   ",",
   "setsweep",
   "=",
   "False",
   ")",
   ":",
   "if",
   "setsweep",
   ":",
   "self",
   ".",
   "setsweep",
   "(",
   "setsweep",
   ")",
   "if",
   "t2",
   "is",
   "None",
   "or",
   "t2",
   ">",
   "self",
   ".",
   "sweepLength",
   ":",
   "t2",
   "=",
   "self",
   ".",
   "sweepLength",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"resetting t2 to [%f]\"",
   ",",
   "t2",
   ")",
   "t1",
   "=",
   "<mask>",
   "(",
   "t1",
   ",",
   "0",
   ")",
   "if",
   "t1",
   ">",
   "t2",
   ":",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"t1 cannot be larger than t2\"",
   ")",
   "return",
   "False",
   "I1",
   ",",
   "I2",
   "=",
   "int",
   "(",
   "t1",
   "*",
   "self",
   ".",
   "pointsPerSec",
   ")",
   ",",
   "int",
   "(",
   "t2",
   "*",
   "self",
   ".",
   "pointsPerSec",
   ")",
   "if",
   "I1",
   "==",
   "I2",
   ":",
   "return",
   "np",
   ".",
   "nan",
   "return",
   "np",
   ".",
   "average",
   "(",
   "self",
   ".",
   "sweepY",
   "[",
   "I1",
   ":",
   "I2",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-489",
  "nl_tokens": [
   "Plot",
   "the",
   "window",
   "in",
   "the",
   "frequency",
   "domain"
  ],
  "pl_tokens": [
   "def",
   "plot_frequencies",
   "(",
   "self",
   ",",
   "mindB",
   "=",
   "None",
   ",",
   "maxdB",
   "=",
   "None",
   ",",
   "norm",
   "=",
   "True",
   ")",
   ":",
   "from",
   "pylab",
   "import",
   "plot",
   ",",
   "title",
   ",",
   "xlim",
   ",",
   "grid",
   ",",
   "ylim",
   ",",
   "xlabel",
   ",",
   "ylabel",
   "# recompute the response",
   "self",
   ".",
   "compute_response",
   "(",
   "norm",
   "=",
   "norm",
   ")",
   "plot",
   "(",
   "self",
   ".",
   "frequencies",
   ",",
   "self",
   ".",
   "response",
   ")",
   "title",
   "(",
   "\"ENBW=%2.1f\"",
   "%",
   "(",
   "self",
   ".",
   "enbw",
   ")",
   ")",
   "ylabel",
   "(",
   "'Frequency response (dB)'",
   ")",
   "xlabel",
   "(",
   "'Fraction of sampling frequency'",
   ")",
   "# define the plot limits",
   "xlim",
   "(",
   "-",
   "0.5",
   ",",
   "0.5",
   ")",
   "y0",
   ",",
   "y1",
   "=",
   "ylim",
   "(",
   ")",
   "if",
   "mindB",
   ":",
   "y0",
   "=",
   "mindB",
   "if",
   "maxdB",
   "is",
   "not",
   "None",
   ":",
   "y1",
   "=",
   "maxdB",
   "else",
   ":",
   "y1",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "response",
   ")",
   "ylim",
   "(",
   "y0",
   ",",
   "y1",
   ")",
   "grid",
   "(",
   "True",
   ")"
  ]
 },
 {
  "idx": "maxmin-490",
  "nl_tokens": [
   "Returns",
   "a",
   "function",
   "F",
   "(",
   "x",
   "y",
   "z",
   ")",
   "that",
   "interpolates",
   "any",
   "values",
   "on",
   "the",
   "grid",
   "."
  ],
  "pl_tokens": [
   "def",
   "_interpolationFunctionFactory",
   "(",
   "self",
   ",",
   "spline_order",
   "=",
   "None",
   ",",
   "cval",
   "=",
   "None",
   ")",
   ":",
   "# for scipy >=0.9: should use scipy.interpolate.griddata",
   "# http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html#scipy.interpolate.griddata",
   "# (does it work for nD?)",
   "import",
   "scipy",
   ".",
   "ndimage",
   "if",
   "spline_order",
   "is",
   "None",
   ":",
   "# must be compatible with whatever :func:`scipy.ndimage.spline_filter` takes.",
   "spline_order",
   "=",
   "self",
   ".",
   "interpolation_spline_order",
   "if",
   "cval",
   "is",
   "None",
   ":",
   "cval",
   "=",
   "self",
   ".",
   "interpolation_cval",
   "data",
   "=",
   "self",
   ".",
   "grid",
   "if",
   "cval",
   "is",
   "None",
   ":",
   "cval",
   "=",
   "data",
   ".",
   "<mask>",
   "(",
   ")",
   "try",
   ":",
   "# masked arrays, fill with min: should keep spline happy",
   "_data",
   "=",
   "data",
   ".",
   "filled",
   "(",
   "cval",
   ")",
   "except",
   "AttributeError",
   ":",
   "_data",
   "=",
   "data",
   "coeffs",
   "=",
   "scipy",
   ".",
   "ndimage",
   ".",
   "spline_filter",
   "(",
   "_data",
   ",",
   "order",
   "=",
   "spline_order",
   ")",
   "x0",
   "=",
   "self",
   ".",
   "origin",
   "dx",
   "=",
   "self",
   ".",
   "delta",
   "def",
   "_transform",
   "(",
   "cnew",
   ",",
   "c0",
   ",",
   "dc",
   ")",
   ":",
   "return",
   "(",
   "numpy",
   ".",
   "atleast_1d",
   "(",
   "cnew",
   ")",
   "-",
   "c0",
   ")",
   "/",
   "dc",
   "def",
   "interpolatedF",
   "(",
   "*",
   "coordinates",
   ")",
   ":",
   "\"\"\"B-spline function over the data grid(x,y,z).\n\n            interpolatedF([x1,x2,...],[y1,y2,...],[z1,z2,...]) -> F[x1,y1,z1],F[x2,y2,z2],...\n\n            Example usage for resampling::\n              >>> XX,YY,ZZ = numpy.mgrid[40:75:0.5, 96:150:0.5, 20:50:0.5]\n              >>> FF = _interpolationFunction(XX,YY,ZZ)\n            \"\"\"",
   "_coordinates",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "_transform",
   "(",
   "coordinates",
   "[",
   "i",
   "]",
   ",",
   "x0",
   "[",
   "i",
   "]",
   ",",
   "dx",
   "[",
   "i",
   "]",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "coordinates",
   ")",
   ")",
   "]",
   ")",
   "return",
   "scipy",
   ".",
   "ndimage",
   ".",
   "map_coordinates",
   "(",
   "coeffs",
   ",",
   "_coordinates",
   ",",
   "prefilter",
   "=",
   "False",
   ",",
   "mode",
   "=",
   "'nearest'",
   ",",
   "cval",
   "=",
   "cval",
   ")",
   "# mode='wrap' would be ideal but is broken: https://github.com/scipy/scipy/issues/1323",
   "return",
   "interpolatedF"
  ]
 },
 {
  "idx": "maxmin-491",
  "nl_tokens": [
   "Tiles",
   "open",
   "figures",
   "."
  ],
  "pl_tokens": [
   "def",
   "tile",
   "(",
   ")",
   ":",
   "figs",
   "=",
   "plt",
   ".",
   "get_fignums",
   "(",
   ")",
   "# Keep track of x, y, size for figures",
   "x",
   "=",
   "0",
   "y",
   "=",
   "0",
   "# maxy    = 0",
   "toppad",
   "=",
   "21",
   "size",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0",
   ",",
   "0",
   "]",
   ")",
   "if",
   "(",
   "len",
   "(",
   "figs",
   ")",
   "!=",
   "0",
   ")",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figs",
   "[",
   "0",
   "]",
   ")",
   "screen",
   "=",
   "fig",
   ".",
   "canvas",
   ".",
   "window",
   ".",
   "get_screen",
   "(",
   ")",
   "screenx",
   "=",
   "screen",
   ".",
   "get_monitor_geometry",
   "(",
   "screen",
   ".",
   "get_primary_monitor",
   "(",
   ")",
   ")",
   "screenx",
   "=",
   "screenx",
   "[",
   "2",
   "]",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figs",
   "[",
   "0",
   "]",
   ")",
   "fig",
   ".",
   "canvas",
   ".",
   "manager",
   ".",
   "window",
   ".",
   "move",
   "(",
   "x",
   ",",
   "y",
   ")",
   "maxy",
   "=",
   "np",
   ".",
   "array",
   "(",
   "fig",
   ".",
   "canvas",
   ".",
   "manager",
   ".",
   "window",
   ".",
   "get_position",
   "(",
   ")",
   ")",
   "[",
   "1",
   "]",
   "size",
   "=",
   "np",
   ".",
   "array",
   "(",
   "fig",
   ".",
   "canvas",
   ".",
   "manager",
   ".",
   "window",
   ".",
   "get_size",
   "(",
   ")",
   ")",
   "y",
   "=",
   "maxy",
   "x",
   "+=",
   "size",
   "[",
   "0",
   "]",
   "+",
   "1",
   "for",
   "fig",
   "in",
   "figs",
   "[",
   "1",
   ":",
   "]",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "fig",
   ")",
   "size",
   "=",
   "np",
   ".",
   "array",
   "(",
   "fig",
   ".",
   "canvas",
   ".",
   "manager",
   ".",
   "window",
   ".",
   "get_size",
   "(",
   ")",
   ")",
   "if",
   "(",
   "x",
   "+",
   "size",
   "[",
   "0",
   "]",
   ">",
   "screenx",
   ")",
   ":",
   "x",
   "=",
   "0",
   "y",
   "=",
   "maxy",
   "maxy",
   "=",
   "y",
   "+",
   "size",
   "[",
   "1",
   "]",
   "+",
   "toppad",
   "else",
   ":",
   "maxy",
   "=",
   "<mask>",
   "(",
   "maxy",
   ",",
   "y",
   "+",
   "size",
   "[",
   "1",
   "]",
   "+",
   "toppad",
   ")",
   "fig",
   ".",
   "canvas",
   ".",
   "manager",
   ".",
   "window",
   ".",
   "move",
   "(",
   "x",
   ",",
   "y",
   ")",
   "x",
   "+=",
   "size",
   "[",
   "0",
   "]",
   "+",
   "1"
  ]
 },
 {
  "idx": "maxmin-492",
  "nl_tokens": [
   "Return",
   "the",
   "interal",
   "_topDownMappingM",
   "matrix",
   "used",
   "for",
   "handling",
   "the",
   "bucketInfo",
   "()",
   "and",
   "topDownCompute",
   "()",
   "methods",
   ".",
   "This",
   "is",
   "a",
   "matrix",
   "one",
   "row",
   "per",
   "category",
   "(",
   "bucket",
   ")",
   "where",
   "each",
   "row",
   "contains",
   "the",
   "encoded",
   "output",
   "for",
   "that",
   "category",
   "."
  ],
  "pl_tokens": [
   "def",
   "_getTopDownMapping",
   "(",
   "self",
   ")",
   ":",
   "# Do we need to build up our reverse mapping table?",
   "if",
   "self",
   ".",
   "_topDownMappingM",
   "is",
   "None",
   ":",
   "# The input scalar value corresponding to each possible output encoding",
   "if",
   "self",
   ".",
   "periodic",
   ":",
   "self",
   ".",
   "_topDownValues",
   "=",
   "numpy",
   ".",
   "arange",
   "(",
   "self",
   ".",
   "minval",
   "+",
   "self",
   ".",
   "resolution",
   "/",
   "2.0",
   ",",
   "self",
   ".",
   "maxval",
   ",",
   "self",
   ".",
   "resolution",
   ")",
   "else",
   ":",
   "#Number of values is (max-min)/resolutions",
   "self",
   ".",
   "_topDownValues",
   "=",
   "numpy",
   ".",
   "arange",
   "(",
   "self",
   ".",
   "minval",
   ",",
   "self",
   ".",
   "maxval",
   "+",
   "self",
   ".",
   "resolution",
   "/",
   "2.0",
   ",",
   "self",
   ".",
   "resolution",
   ")",
   "# Each row represents an encoded output pattern",
   "numCategories",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_topDownValues",
   ")",
   "self",
   ".",
   "_topDownMappingM",
   "=",
   "SM32",
   "(",
   "numCategories",
   ",",
   "self",
   ".",
   "n",
   ")",
   "outputSpace",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "self",
   ".",
   "n",
   ",",
   "dtype",
   "=",
   "GetNTAReal",
   "(",
   ")",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "numCategories",
   ")",
   ":",
   "value",
   "=",
   "self",
   ".",
   "_topDownValues",
   "[",
   "i",
   "]",
   "value",
   "=",
   "<mask>",
   "(",
   "value",
   ",",
   "self",
   ".",
   "minval",
   ")",
   "value",
   "=",
   "min",
   "(",
   "value",
   ",",
   "self",
   ".",
   "maxval",
   ")",
   "self",
   ".",
   "encodeIntoArray",
   "(",
   "value",
   ",",
   "outputSpace",
   ",",
   "learn",
   "=",
   "False",
   ")",
   "self",
   ".",
   "_topDownMappingM",
   ".",
   "setRowFromDense",
   "(",
   "i",
   ",",
   "outputSpace",
   ")",
   "return",
   "self",
   ".",
   "_topDownMappingM"
  ]
 },
 {
  "idx": "maxmin-493",
  "nl_tokens": [
   "Determine",
   "the",
   "geometry",
   "of",
   "the",
   "rectangular",
   "grid",
   "by",
   "overlaying",
   "it",
   "over",
   "a",
   "grid",
   "of",
   "coordinates",
   "such",
   "that",
   "its",
   "\\",
   "outer",
   "-",
   "most",
   "pixels",
   "align",
   "with",
   "the",
   "grid",
   "s",
   "outer",
   "most",
   "coordinates",
   "plus",
   "a",
   "small",
   "buffer",
   "."
  ],
  "pl_tokens": [
   "def",
   "geometry_from_grid",
   "(",
   "self",
   ",",
   "grid",
   ",",
   "buffer",
   "=",
   "1e-8",
   ")",
   ":",
   "y_min",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "-",
   "buffer",
   "y_max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "+",
   "buffer",
   "x_min",
   "=",
   "np",
   ".",
   "min",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "-",
   "buffer",
   "x_max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "+",
   "buffer",
   "pixel_scales",
   "=",
   "(",
   "float",
   "(",
   "(",
   "y_max",
   "-",
   "y_min",
   ")",
   "/",
   "self",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ",",
   "float",
   "(",
   "(",
   "x_max",
   "-",
   "x_min",
   ")",
   "/",
   "self",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   "origin",
   "=",
   "(",
   "(",
   "y_max",
   "+",
   "y_min",
   ")",
   "/",
   "2.0",
   ",",
   "(",
   "x_max",
   "+",
   "x_min",
   ")",
   "/",
   "2.0",
   ")",
   "pixel_neighbors",
   ",",
   "pixel_neighbors_size",
   "=",
   "self",
   ".",
   "neighbors_from_pixelization",
   "(",
   ")",
   "return",
   "self",
   ".",
   "Geometry",
   "(",
   "shape",
   "=",
   "self",
   ".",
   "shape",
   ",",
   "pixel_scales",
   "=",
   "pixel_scales",
   ",",
   "origin",
   "=",
   "origin",
   ",",
   "pixel_neighbors",
   "=",
   "pixel_neighbors",
   ",",
   "pixel_neighbors_size",
   "=",
   "pixel_neighbors_size",
   ")"
  ]
 },
 {
  "idx": "maxmin-494",
  "nl_tokens": [
   "Connect",
   "the",
   "parsed",
   "rows",
   "."
  ],
  "pl_tokens": [
   "def",
   "_connect_rows",
   "(",
   "self",
   ",",
   "connections",
   ")",
   ":",
   "for",
   "connection",
   "in",
   "connections",
   ":",
   "from_row_id",
   "=",
   "self",
   ".",
   "_to_id",
   "(",
   "connection",
   "[",
   "FROM",
   "]",
   "[",
   "ID",
   "]",
   ")",
   "from_row",
   "=",
   "self",
   ".",
   "_id_cache",
   "[",
   "from_row_id",
   "]",
   "from_row_start_index",
   "=",
   "connection",
   "[",
   "FROM",
   "]",
   ".",
   "get",
   "(",
   "START",
   ",",
   "DEFAULT_START",
   ")",
   "from_row_number_of_possible_meshes",
   "=",
   "from_row",
   ".",
   "number_of_produced_meshes",
   "-",
   "from_row_start_index",
   "to_row_id",
   "=",
   "self",
   ".",
   "_to_id",
   "(",
   "connection",
   "[",
   "TO",
   "]",
   "[",
   "ID",
   "]",
   ")",
   "to_row",
   "=",
   "self",
   ".",
   "_id_cache",
   "[",
   "to_row_id",
   "]",
   "to_row_start_index",
   "=",
   "connection",
   "[",
   "TO",
   "]",
   ".",
   "get",
   "(",
   "START",
   ",",
   "DEFAULT_START",
   ")",
   "to_row_number_of_possible_meshes",
   "=",
   "to_row",
   ".",
   "number_of_consumed_meshes",
   "-",
   "to_row_start_index",
   "meshes",
   "=",
   "<mask>",
   "(",
   "from_row_number_of_possible_meshes",
   ",",
   "to_row_number_of_possible_meshes",
   ")",
   "# TODO: test all kinds of connections",
   "number_of_meshes",
   "=",
   "connection",
   ".",
   "get",
   "(",
   "MESHES",
   ",",
   "meshes",
   ")",
   "from_row_stop_index",
   "=",
   "from_row_start_index",
   "+",
   "number_of_meshes",
   "to_row_stop_index",
   "=",
   "to_row_start_index",
   "+",
   "number_of_meshes",
   "assert",
   "0",
   "<=",
   "from_row_start_index",
   "<=",
   "from_row_stop_index",
   "produced_meshes",
   "=",
   "from_row",
   ".",
   "produced_meshes",
   "[",
   "from_row_start_index",
   ":",
   "from_row_stop_index",
   "]",
   "assert",
   "0",
   "<=",
   "to_row_start_index",
   "<=",
   "to_row_stop_index",
   "consumed_meshes",
   "=",
   "to_row",
   ".",
   "consumed_meshes",
   "[",
   "to_row_start_index",
   ":",
   "to_row_stop_index",
   "]",
   "assert",
   "len",
   "(",
   "produced_meshes",
   ")",
   "==",
   "len",
   "(",
   "consumed_meshes",
   ")",
   "mesh_pairs",
   "=",
   "zip",
   "(",
   "produced_meshes",
   ",",
   "consumed_meshes",
   ")",
   "for",
   "produced_mesh",
   ",",
   "consumed_mesh",
   "in",
   "mesh_pairs",
   ":",
   "produced_mesh",
   ".",
   "connect_to",
   "(",
   "consumed_mesh",
   ")"
  ]
 },
 {
  "idx": "maxmin-495",
  "nl_tokens": [
   "write",
   "the",
   "geno",
   "output",
   "formerly",
   "used",
   "by",
   "admixture",
   "still",
   "supported",
   "by",
   "adegenet",
   "perhaps",
   ".",
   "Also",
   "sNMF",
   "still",
   "likes",
   ".",
   "geno",
   "."
  ],
  "pl_tokens": [
   "def",
   "write_geno",
   "(",
   "data",
   ",",
   "sidx",
   ")",
   ":",
   "## grab snp and bis data from tmparr",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "tmparrs",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "\"tmp-{}.h5\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "name",
   ")",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "tmparrs",
   ",",
   "'r'",
   ")",
   "as",
   "io5",
   ":",
   "snparr",
   "=",
   "io5",
   "[",
   "\"snparr\"",
   "]",
   "bisarr",
   "=",
   "io5",
   "[",
   "\"bisarr\"",
   "]",
   "## trim to size b/c it was made longer than actual",
   "bend",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "bisarr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "bend",
   ")",
   ":",
   "bend",
   "=",
   "bend",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "bend",
   "=",
   "bisarr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "send",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "snparr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "send",
   ")",
   ":",
   "send",
   "=",
   "send",
   ".",
   "min",
   "(",
   ")",
   "else",
   ":",
   "send",
   "=",
   "snparr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "## get most common base at each SNP as a pseudo-reference",
   "## and record 0,1,2 or missing=9 for counts of the ref allele",
   "snpref",
   "=",
   "reftrick",
   "(",
   "snparr",
   "[",
   ":",
   ",",
   ":",
   "send",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "int8",
   ")",
   ",",
   "GETCONS",
   ")",
   ".",
   "view",
   "(",
   "\"S1\"",
   ")",
   "bisref",
   "=",
   "reftrick",
   "(",
   "bisarr",
   "[",
   ":",
   ",",
   ":",
   "bend",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "int8",
   ")",
   ",",
   "GETCONS",
   ")",
   ".",
   "view",
   "(",
   "\"S1\"",
   ")",
   "## geno matrix to fill (9 is empty)",
   "snpgeno",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "snparr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "send",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "uint8",
   ")",
   "snpgeno",
   ".",
   "fill",
   "(",
   "9",
   ")",
   "bisgeno",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "bisarr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "bend",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "uint8",
   ")",
   "bisgeno",
   ".",
   "fill",
   "(",
   "9",
   ")",
   "##--------------------------------------------------------------------",
   "## fill in complete hits (match to first column ref base)",
   "mask2",
   "=",
   "np",
   ".",
   "array",
   "(",
   "snparr",
   "[",
   ":",
   ",",
   ":",
   "send",
   "]",
   "==",
   "snpref",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "snpgeno",
   "[",
   "mask2",
   "]",
   "=",
   "2",
   "## fill in single hits (heteros) match to hetero of first+second column",
   "ambref",
   "=",
   "np",
   ".",
   "apply_along_axis",
   "(",
   "lambda",
   "x",
   ":",
   "TRANSFULL",
   "[",
   "tuple",
   "(",
   "x",
   ")",
   "]",
   ",",
   "1",
   ",",
   "snpref",
   "[",
   ":",
   ",",
   ":",
   "2",
   "]",
   ")",
   "mask1",
   "=",
   "np",
   ".",
   "array",
   "(",
   "snparr",
   "[",
   ":",
   ",",
   ":",
   "send",
   "]",
   "==",
   "ambref",
   ")",
   "snpgeno",
   "[",
   "mask1",
   "]",
   "=",
   "1",
   "## fill in zero hits, meaning a perfect match to the second column base",
   "## anything else is left at 9 (missing), b/c it's either missing or it",
   "## is not bi-allelic. ",
   "mask0",
   "=",
   "np",
   ".",
   "array",
   "(",
   "snparr",
   "[",
   ":",
   ",",
   ":",
   "send",
   "]",
   "==",
   "snpref",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "snpgeno",
   "[",
   "mask0",
   "]",
   "=",
   "0",
   "##--------------------------------------------------------------------",
   "## fill in complete hits",
   "mask2",
   "=",
   "np",
   ".",
   "array",
   "(",
   "bisarr",
   "[",
   ":",
   ",",
   ":",
   "bend",
   "]",
   "==",
   "bisref",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "bisgeno",
   "[",
   "mask2",
   "]",
   "=",
   "2",
   "## fill in single hits (heteros)",
   "ambref",
   "=",
   "np",
   ".",
   "apply_along_axis",
   "(",
   "lambda",
   "x",
   ":",
   "TRANSFULL",
   "[",
   "tuple",
   "(",
   "x",
   ")",
   "]",
   ",",
   "1",
   ",",
   "bisref",
   "[",
   ":",
   ",",
   ":",
   "2",
   "]",
   ")",
   "mask1",
   "=",
   "np",
   ".",
   "array",
   "(",
   "bisarr",
   "[",
   ":",
   ",",
   ":",
   "bend",
   "]",
   "==",
   "ambref",
   ")",
   "bisgeno",
   "[",
   "mask1",
   "]",
   "=",
   "1",
   "## fill in zero hits (match to second base)",
   "mask0",
   "=",
   "np",
   ".",
   "array",
   "(",
   "bisarr",
   "[",
   ":",
   ",",
   ":",
   "bend",
   "]",
   "==",
   "bisref",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "bisgeno",
   "[",
   "mask0",
   "]",
   "=",
   "0",
   "##---------------------------------------------------------------------",
   "## print to files",
   "np",
   ".",
   "savetxt",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "geno",
   ",",
   "snpgeno",
   ".",
   "T",
   ",",
   "delimiter",
   "=",
   "\"\"",
   ",",
   "fmt",
   "=",
   "\"%d\"",
   ")",
   "np",
   ".",
   "savetxt",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "ugeno",
   ",",
   "bisgeno",
   ".",
   "T",
   ",",
   "delimiter",
   "=",
   "\"\"",
   ",",
   "fmt",
   "=",
   "\"%d\"",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"finished writing geno in: %s\"",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")"
  ]
 },
 {
  "idx": "maxmin-496",
  "nl_tokens": [
   "Cyan",
   "magenta",
   "yellow",
   "black",
   "to",
   "red",
   "green",
   "blue",
   ".",
   "ReportLab",
   "http",
   ":",
   "//",
   "www",
   ".",
   "koders",
   ".",
   "com",
   "/",
   "python",
   "/",
   "fid5C006F554616848C01AC7CB96C21426B69D2E5A9",
   ".",
   "aspx",
   "Results",
   "will",
   "differ",
   "from",
   "the",
   "way",
   "NSColor",
   "converts",
   "color",
   "spaces",
   "."
  ],
  "pl_tokens": [
   "def",
   "cmyk_to_rgb",
   "(",
   "c",
   ",",
   "m",
   ",",
   "y",
   ",",
   "k",
   ")",
   ":",
   "r",
   "=",
   "1.0",
   "-",
   "<mask>",
   "(",
   "1.0",
   ",",
   "c",
   "+",
   "k",
   ")",
   "g",
   "=",
   "1.0",
   "-",
   "min",
   "(",
   "1.0",
   ",",
   "m",
   "+",
   "k",
   ")",
   "b",
   "=",
   "1.0",
   "-",
   "min",
   "(",
   "1.0",
   ",",
   "y",
   "+",
   "k",
   ")",
   "return",
   "r",
   ",",
   "g",
   ",",
   "b"
  ]
 },
 {
  "idx": "maxmin-497",
  "nl_tokens": [
   "This",
   "is",
   "a",
   "helper",
   "function",
   "for",
   "centroid",
   "detrending",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_legendre_deg_ctd",
   "(",
   "npts",
   ")",
   ":",
   "from",
   "scipy",
   ".",
   "interpolate",
   "import",
   "interp1d",
   "degs",
   "=",
   "nparray",
   "(",
   "[",
   "4",
   ",",
   "5",
   ",",
   "6",
   ",",
   "10",
   ",",
   "15",
   "]",
   ")",
   "pts",
   "=",
   "nparray",
   "(",
   "[",
   "1e2",
   ",",
   "3e2",
   ",",
   "5e2",
   ",",
   "1e3",
   ",",
   "3e3",
   "]",
   ")",
   "fn",
   "=",
   "interp1d",
   "(",
   "pts",
   ",",
   "degs",
   ",",
   "kind",
   "=",
   "'linear'",
   ",",
   "bounds_error",
   "=",
   "False",
   ",",
   "fill_value",
   "=",
   "(",
   "<mask>",
   "(",
   "degs",
   ")",
   ",",
   "max",
   "(",
   "degs",
   ")",
   ")",
   ")",
   "legendredeg",
   "=",
   "int",
   "(",
   "npfloor",
   "(",
   "fn",
   "(",
   "npts",
   ")",
   ")",
   ")",
   "return",
   "legendredeg"
  ]
 },
 {
  "idx": "maxmin-498",
  "nl_tokens": [
   "Compute",
   "the",
   "(",
   "scaled",
   ")",
   "signal",
   "in",
   "each",
   "pixel",
   "where",
   "the",
   "signal",
   "is",
   "the",
   "sum",
   "of",
   "its",
   "datas_",
   "-",
   "pixel",
   "fluxes",
   ".",
   "\\",
   "These",
   "pixel",
   "-",
   "signals",
   "are",
   "used",
   "to",
   "compute",
   "the",
   "effective",
   "regularization",
   "weight",
   "of",
   "each",
   "pixel",
   "."
  ],
  "pl_tokens": [
   "def",
   "weighted_pixel_signals_from_images",
   "(",
   "pixels",
   ",",
   "signal_scale",
   ",",
   "regular_to_pix",
   ",",
   "galaxy_image",
   ")",
   ":",
   "pixel_signals",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "pixels",
   ",",
   ")",
   ")",
   "pixel_sizes",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "pixels",
   ",",
   ")",
   ")",
   "for",
   "regular_index",
   "in",
   "range",
   "(",
   "galaxy_image",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "pixel_signals",
   "[",
   "regular_to_pix",
   "[",
   "regular_index",
   "]",
   "]",
   "+=",
   "galaxy_image",
   "[",
   "regular_index",
   "]",
   "pixel_sizes",
   "[",
   "regular_to_pix",
   "[",
   "regular_index",
   "]",
   "]",
   "+=",
   "1",
   "pixel_signals",
   "/=",
   "pixel_sizes",
   "pixel_signals",
   "/=",
   "np",
   ".",
   "<mask>",
   "(",
   "pixel_signals",
   ")",
   "return",
   "pixel_signals",
   "**",
   "signal_scale"
  ]
 },
 {
  "idx": "maxmin-499",
  "nl_tokens": [
   "Create",
   "a",
   "model",
   "object",
   "from",
   "the",
   "data",
   "set",
   "for",
   "the",
   "property",
   "specified",
   "by",
   "the",
   "supplied",
   "symbol",
   "using",
   "the",
   "specified",
   "polynomial",
   "degree",
   "."
  ],
  "pl_tokens": [
   "def",
   "create",
   "(",
   "dataset",
   ",",
   "symbol",
   ",",
   "degree",
   ")",
   ":",
   "x_vals",
   "=",
   "dataset",
   ".",
   "data",
   "[",
   "'T'",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "y_vals",
   "=",
   "dataset",
   ".",
   "data",
   "[",
   "symbol",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "coeffs",
   "=",
   "np",
   ".",
   "polyfit",
   "(",
   "x_vals",
   ",",
   "y_vals",
   ",",
   "degree",
   ")",
   "result",
   "=",
   "PolynomialModelT",
   "(",
   "dataset",
   ".",
   "material",
   ",",
   "dataset",
   ".",
   "names_dict",
   "[",
   "symbol",
   "]",
   ",",
   "symbol",
   ",",
   "dataset",
   ".",
   "display_symbols_dict",
   "[",
   "symbol",
   "]",
   ",",
   "dataset",
   ".",
   "units_dict",
   "[",
   "symbol",
   "]",
   ",",
   "None",
   ",",
   "[",
   "dataset",
   ".",
   "name",
   "]",
   ",",
   "coeffs",
   ")",
   "result",
   ".",
   "state_schema",
   "[",
   "'T'",
   "]",
   "[",
   "'min'",
   "]",
   "=",
   "float",
   "(",
   "<mask>",
   "(",
   "x_vals",
   ")",
   ")",
   "result",
   ".",
   "state_schema",
   "[",
   "'T'",
   "]",
   "[",
   "'max'",
   "]",
   "=",
   "float",
   "(",
   "max",
   "(",
   "x_vals",
   ")",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-500",
  "nl_tokens": [
   "Compute",
   "updated",
   "probabilities",
   "for",
   "anomalyScores",
   "using",
   "the",
   "given",
   "params",
   "."
  ],
  "pl_tokens": [
   "def",
   "updateAnomalyLikelihoods",
   "(",
   "anomalyScores",
   ",",
   "params",
   ",",
   "verbosity",
   "=",
   "0",
   ")",
   ":",
   "if",
   "verbosity",
   ">",
   "3",
   ":",
   "print",
   "(",
   "\"In updateAnomalyLikelihoods.\"",
   ")",
   "print",
   "(",
   "\"Number of anomaly scores:\"",
   ",",
   "len",
   "(",
   "anomalyScores",
   ")",
   ")",
   "print",
   "(",
   "\"First 20:\"",
   ",",
   "anomalyScores",
   "[",
   "0",
   ":",
   "<mask>",
   "(",
   "20",
   ",",
   "len",
   "(",
   "anomalyScores",
   ")",
   ")",
   "]",
   ")",
   "print",
   "(",
   "\"Params:\"",
   ",",
   "params",
   ")",
   "if",
   "len",
   "(",
   "anomalyScores",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Must have at least one anomalyScore\"",
   ")",
   "if",
   "not",
   "isValidEstimatorParams",
   "(",
   "params",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"'params' is not a valid params structure\"",
   ")",
   "# For backward compatibility.",
   "if",
   "\"historicalLikelihoods\"",
   "not",
   "in",
   "params",
   ":",
   "params",
   "[",
   "\"historicalLikelihoods\"",
   "]",
   "=",
   "[",
   "1.0",
   "]",
   "# Compute moving averages of these new scores using the previous values",
   "# as well as likelihood for these scores using the old estimator",
   "historicalValues",
   "=",
   "params",
   "[",
   "\"movingAverage\"",
   "]",
   "[",
   "\"historicalValues\"",
   "]",
   "total",
   "=",
   "params",
   "[",
   "\"movingAverage\"",
   "]",
   "[",
   "\"total\"",
   "]",
   "windowSize",
   "=",
   "params",
   "[",
   "\"movingAverage\"",
   "]",
   "[",
   "\"windowSize\"",
   "]",
   "aggRecordList",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "anomalyScores",
   ")",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "likelihoods",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "anomalyScores",
   ")",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "for",
   "i",
   ",",
   "v",
   "in",
   "enumerate",
   "(",
   "anomalyScores",
   ")",
   ":",
   "newAverage",
   ",",
   "historicalValues",
   ",",
   "total",
   "=",
   "(",
   "MovingAverage",
   ".",
   "compute",
   "(",
   "historicalValues",
   ",",
   "total",
   ",",
   "v",
   "[",
   "2",
   "]",
   ",",
   "windowSize",
   ")",
   ")",
   "aggRecordList",
   "[",
   "i",
   "]",
   "=",
   "newAverage",
   "likelihoods",
   "[",
   "i",
   "]",
   "=",
   "tailProbability",
   "(",
   "newAverage",
   ",",
   "params",
   "[",
   "\"distribution\"",
   "]",
   ")",
   "# Filter the likelihood values. First we prepend the historical likelihoods",
   "# to the current set. Then we filter the values.  We peel off the likelihoods",
   "# to return and the last windowSize values to store for later.",
   "likelihoods2",
   "=",
   "params",
   "[",
   "\"historicalLikelihoods\"",
   "]",
   "+",
   "list",
   "(",
   "likelihoods",
   ")",
   "filteredLikelihoods",
   "=",
   "_filterLikelihoods",
   "(",
   "likelihoods2",
   ")",
   "likelihoods",
   "[",
   ":",
   "]",
   "=",
   "filteredLikelihoods",
   "[",
   "-",
   "len",
   "(",
   "likelihoods",
   ")",
   ":",
   "]",
   "historicalLikelihoods",
   "=",
   "likelihoods2",
   "[",
   "-",
   "min",
   "(",
   "windowSize",
   ",",
   "len",
   "(",
   "likelihoods2",
   ")",
   ")",
   ":",
   "]",
   "# Update the estimator",
   "newParams",
   "=",
   "{",
   "\"distribution\"",
   ":",
   "params",
   "[",
   "\"distribution\"",
   "]",
   ",",
   "\"movingAverage\"",
   ":",
   "{",
   "\"historicalValues\"",
   ":",
   "historicalValues",
   ",",
   "\"total\"",
   ":",
   "total",
   ",",
   "\"windowSize\"",
   ":",
   "windowSize",
   ",",
   "}",
   ",",
   "\"historicalLikelihoods\"",
   ":",
   "historicalLikelihoods",
   ",",
   "}",
   "assert",
   "len",
   "(",
   "newParams",
   "[",
   "\"historicalLikelihoods\"",
   "]",
   ")",
   "<=",
   "windowSize",
   "if",
   "verbosity",
   ">",
   "3",
   ":",
   "print",
   "(",
   "\"Number of likelihoods:\"",
   ",",
   "len",
   "(",
   "likelihoods",
   ")",
   ")",
   "print",
   "(",
   "\"First 20 likelihoods:\"",
   ",",
   "likelihoods",
   "[",
   "0",
   ":",
   "min",
   "(",
   "20",
   ",",
   "len",
   "(",
   "likelihoods",
   ")",
   ")",
   "]",
   ")",
   "print",
   "(",
   "\"Leaving updateAnomalyLikelihoods.\"",
   ")",
   "return",
   "(",
   "likelihoods",
   ",",
   "aggRecordList",
   ",",
   "newParams",
   ")"
  ]
 },
 {
  "idx": "maxmin-501",
  "nl_tokens": [
   "Add",
   "lines",
   "to",
   "the",
   "block",
   "."
  ],
  "pl_tokens": [
   "def",
   "add",
   "(",
   "self",
   ",",
   "string",
   ",",
   "start",
   ",",
   "end",
   ",",
   "line",
   ")",
   ":",
   "if",
   "string",
   ".",
   "strip",
   "(",
   ")",
   ":",
   "# Only add if not entirely whitespace.",
   "self",
   ".",
   "start_lineno",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "start_lineno",
   ",",
   "start",
   "[",
   "0",
   "]",
   ")",
   "self",
   ".",
   "end_lineno",
   "=",
   "max",
   "(",
   "self",
   ".",
   "end_lineno",
   ",",
   "end",
   "[",
   "0",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-502",
  "nl_tokens": [
   "Yield",
   "CPU",
   ".",
   "This",
   "will",
   "choose",
   "another",
   "process",
   "from",
   "the",
   "running",
   "list",
   "and",
   "change",
   "current",
   "running",
   "process",
   ".",
   "May",
   "give",
   "the",
   "same",
   "cpu",
   "if",
   "only",
   "one",
   "running",
   "process",
   "."
  ],
  "pl_tokens": [
   "def",
   "sched",
   "(",
   "self",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "procs",
   ")",
   ">",
   "1",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"SCHED:\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tProcess: {self.procs!r}\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tRunning: {self.running!r}\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tRWait: {self.rwait!r}\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tTWait: {self.twait!r}\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tTimers: {self.timers!r}\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tCurrent clock: {self.clocks}\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tCurrent cpu: {self._current}\"",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "running",
   ")",
   "==",
   "0",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"None running checking if there is some process waiting for a timeout\"",
   ")",
   "if",
   "all",
   "(",
   "[",
   "x",
   "is",
   "None",
   "for",
   "x",
   "in",
   "self",
   ".",
   "timers",
   "]",
   ")",
   ":",
   "raise",
   "Deadlock",
   "(",
   ")",
   "self",
   ".",
   "clocks",
   "=",
   "<mask>",
   "(",
   "x",
   "for",
   "x",
   "in",
   "self",
   ".",
   "timers",
   "if",
   "x",
   "is",
   "not",
   "None",
   ")",
   "+",
   "1",
   "self",
   ".",
   "check_timers",
   "(",
   ")",
   "assert",
   "len",
   "(",
   "self",
   ".",
   "running",
   ")",
   "!=",
   "0",
   ",",
   "\"DEADLOCK!\"",
   "self",
   ".",
   "_current",
   "=",
   "self",
   ".",
   "running",
   "[",
   "0",
   "]",
   "return",
   "next_index",
   "=",
   "(",
   "self",
   ".",
   "running",
   ".",
   "index",
   "(",
   "self",
   ".",
   "_current",
   ")",
   "+",
   "1",
   ")",
   "%",
   "len",
   "(",
   "self",
   ".",
   "running",
   ")",
   "next_running_idx",
   "=",
   "self",
   ".",
   "running",
   "[",
   "next_index",
   "]",
   "if",
   "len",
   "(",
   "self",
   ".",
   "procs",
   ")",
   ">",
   "1",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "f\"\\tTransfer control from process {self._current} to {next_running_idx}\"",
   ")",
   "self",
   ".",
   "_current",
   "=",
   "next_running_idx"
  ]
 },
 {
  "idx": "maxmin-503",
  "nl_tokens": [
   "Effective",
   "process",
   "bounds",
   "required",
   "to",
   "initialize",
   "inputs",
   "."
  ],
  "pl_tokens": [
   "def",
   "effective_bounds",
   "(",
   "self",
   ")",
   ":",
   "return",
   "snap_bounds",
   "(",
   "bounds",
   "=",
   "clip_bounds",
   "(",
   "bounds",
   "=",
   "self",
   ".",
   "init_bounds",
   ",",
   "clip",
   "=",
   "self",
   ".",
   "process_pyramid",
   ".",
   "bounds",
   ")",
   ",",
   "pyramid",
   "=",
   "self",
   ".",
   "process_pyramid",
   ",",
   "zoom",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "baselevels",
   "[",
   "\"zooms\"",
   "]",
   ")",
   "if",
   "self",
   ".",
   "baselevels",
   "else",
   "min",
   "(",
   "self",
   ".",
   "init_zoom_levels",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-504",
  "nl_tokens": [
   "write",
   "a",
   "map",
   "file",
   "with",
   "linkage",
   "information",
   "for",
   "SNPs",
   "file"
  ],
  "pl_tokens": [
   "def",
   "write_snps_map",
   "(",
   "data",
   ")",
   ":",
   "## grab map data from tmparr",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "tmparrs",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "\"tmp-{}.h5\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "name",
   ")",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "tmparrs",
   ",",
   "'r'",
   ")",
   "as",
   "io5",
   ":",
   "maparr",
   "=",
   "io5",
   "[",
   "\"maparr\"",
   "]",
   "[",
   ":",
   "]",
   "## get last data ",
   "end",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "maparr",
   "[",
   ":",
   "]",
   "==",
   "0",
   ",",
   "axis",
   "=",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "end",
   ")",
   ":",
   "end",
   "=",
   "end",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "end",
   "=",
   "maparr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "## write to map file (this is too slow...)",
   "outchunk",
   "=",
   "[",
   "]",
   "with",
   "open",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "snpsmap",
   ",",
   "'w'",
   ")",
   "as",
   "out",
   ":",
   "for",
   "idx",
   "in",
   "xrange",
   "(",
   "end",
   ")",
   ":",
   "## build to list",
   "line",
   "=",
   "maparr",
   "[",
   "idx",
   ",",
   ":",
   "]",
   "#print(line)",
   "outchunk",
   ".",
   "append",
   "(",
   "\"{}\\trad{}_snp{}\\t{}\\t{}\\n\"",
   ".",
   "format",
   "(",
   "line",
   "[",
   "0",
   "]",
   ",",
   "line",
   "[",
   "1",
   "]",
   ",",
   "line",
   "[",
   "2",
   "]",
   ",",
   "0",
   ",",
   "line",
   "[",
   "3",
   "]",
   ")",
   ")",
   "## clear list",
   "if",
   "not",
   "idx",
   "%",
   "10000",
   ":",
   "out",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "outchunk",
   ")",
   ")",
   "outchunk",
   "=",
   "[",
   "]",
   "## write remaining",
   "out",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "outchunk",
   ")",
   ")",
   "LOGGER",
   ".",
   "debug",
   "(",
   "\"finished writing snps_map in: %s\"",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")"
  ]
 },
 {
  "idx": "maxmin-505",
  "nl_tokens": [
   "Plays",
   "the",
   "first",
   "track",
   "in",
   "the",
   "queue",
   "if",
   "any",
   "or",
   "plays",
   "a",
   "track",
   "from",
   "the",
   "specified",
   "index",
   "in",
   "the",
   "queue",
   "."
  ],
  "pl_tokens": [
   "async",
   "def",
   "play",
   "(",
   "self",
   ",",
   "track_index",
   ":",
   "int",
   "=",
   "0",
   ",",
   "ignore_shuffle",
   ":",
   "bool",
   "=",
   "False",
   ")",
   ":",
   "if",
   "self",
   ".",
   "repeat",
   "and",
   "self",
   ".",
   "current",
   ":",
   "self",
   ".",
   "queue",
   ".",
   "append",
   "(",
   "self",
   ".",
   "current",
   ")",
   "self",
   ".",
   "previous",
   "=",
   "self",
   ".",
   "current",
   "self",
   ".",
   "current",
   "=",
   "None",
   "self",
   ".",
   "position",
   "=",
   "0",
   "self",
   ".",
   "paused",
   "=",
   "False",
   "if",
   "not",
   "self",
   ".",
   "queue",
   ":",
   "await",
   "self",
   ".",
   "stop",
   "(",
   ")",
   "await",
   "self",
   ".",
   "_lavalink",
   ".",
   "dispatch_event",
   "(",
   "QueueEndEvent",
   "(",
   "self",
   ")",
   ")",
   "else",
   ":",
   "if",
   "self",
   ".",
   "shuffle",
   "and",
   "not",
   "ignore_shuffle",
   ":",
   "track",
   "=",
   "self",
   ".",
   "queue",
   ".",
   "pop",
   "(",
   "randrange",
   "(",
   "len",
   "(",
   "self",
   ".",
   "queue",
   ")",
   ")",
   ")",
   "else",
   ":",
   "track",
   "=",
   "self",
   ".",
   "queue",
   ".",
   "pop",
   "(",
   "<mask>",
   "(",
   "track_index",
   ",",
   "len",
   "(",
   "self",
   ".",
   "queue",
   ")",
   "-",
   "1",
   ")",
   ")",
   "self",
   ".",
   "current",
   "=",
   "track",
   "await",
   "self",
   ".",
   "_lavalink",
   ".",
   "ws",
   ".",
   "send",
   "(",
   "op",
   "=",
   "'play'",
   ",",
   "guildId",
   "=",
   "self",
   ".",
   "guild_id",
   ",",
   "track",
   "=",
   "track",
   ".",
   "track",
   ")",
   "await",
   "self",
   ".",
   "_lavalink",
   ".",
   "dispatch_event",
   "(",
   "TrackStartEvent",
   "(",
   "self",
   ",",
   "track",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-506",
  "nl_tokens": [
   "Get",
   "proper",
   "ticker",
   "from",
   "generic",
   "ticker"
  ],
  "pl_tokens": [
   "def",
   "fut_ticker",
   "(",
   "gen_ticker",
   ":",
   "str",
   ",",
   "dt",
   ",",
   "freq",
   ":",
   "str",
   ",",
   "log",
   "=",
   "logs",
   ".",
   "LOG_LEVEL",
   ")",
   "->",
   "str",
   ":",
   "logger",
   "=",
   "logs",
   ".",
   "get_logger",
   "(",
   "fut_ticker",
   ",",
   "level",
   "=",
   "log",
   ")",
   "dt",
   "=",
   "pd",
   ".",
   "Timestamp",
   "(",
   "dt",
   ")",
   "t_info",
   "=",
   "gen_ticker",
   ".",
   "split",
   "(",
   ")",
   "asset",
   "=",
   "t_info",
   "[",
   "-",
   "1",
   "]",
   "if",
   "asset",
   "in",
   "[",
   "'Index'",
   ",",
   "'Curncy'",
   ",",
   "'Comdty'",
   "]",
   ":",
   "ticker",
   "=",
   "' '",
   ".",
   "join",
   "(",
   "t_info",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   "prefix",
   ",",
   "idx",
   ",",
   "postfix",
   "=",
   "ticker",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "int",
   "(",
   "ticker",
   "[",
   "-",
   "1",
   "]",
   ")",
   "-",
   "1",
   ",",
   "asset",
   "elif",
   "asset",
   "==",
   "'Equity'",
   ":",
   "ticker",
   "=",
   "t_info",
   "[",
   "0",
   "]",
   "prefix",
   ",",
   "idx",
   ",",
   "postfix",
   "=",
   "ticker",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "int",
   "(",
   "ticker",
   "[",
   "-",
   "1",
   "]",
   ")",
   "-",
   "1",
   ",",
   "' '",
   ".",
   "join",
   "(",
   "t_info",
   "[",
   "1",
   ":",
   "]",
   ")",
   "else",
   ":",
   "logger",
   ".",
   "error",
   "(",
   "f'unkonwn asset type for ticker: {gen_ticker}'",
   ")",
   "return",
   "''",
   "month_ext",
   "=",
   "4",
   "if",
   "asset",
   "==",
   "'Comdty'",
   "else",
   "2",
   "months",
   "=",
   "pd",
   ".",
   "date_range",
   "(",
   "start",
   "=",
   "dt",
   ",",
   "periods",
   "=",
   "<mask>",
   "(",
   "idx",
   "+",
   "month_ext",
   ",",
   "3",
   ")",
   ",",
   "freq",
   "=",
   "freq",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f'pulling expiry dates for months: {months}'",
   ")",
   "def",
   "to_fut",
   "(",
   "month",
   ")",
   ":",
   "return",
   "prefix",
   "+",
   "const",
   ".",
   "Futures",
   "[",
   "month",
   ".",
   "strftime",
   "(",
   "'%b'",
   ")",
   "]",
   "+",
   "month",
   ".",
   "strftime",
   "(",
   "'%y'",
   ")",
   "[",
   "-",
   "1",
   "]",
   "+",
   "' '",
   "+",
   "postfix",
   "fut",
   "=",
   "[",
   "to_fut",
   "(",
   "m",
   ")",
   "for",
   "m",
   "in",
   "months",
   "]",
   "logger",
   ".",
   "debug",
   "(",
   "f'trying futures: {fut}'",
   ")",
   "# noinspection PyBroadException",
   "try",
   ":",
   "fut_matu",
   "=",
   "bdp",
   "(",
   "tickers",
   "=",
   "fut",
   ",",
   "flds",
   "=",
   "'last_tradeable_dt'",
   ",",
   "cache",
   "=",
   "True",
   ")",
   "except",
   "Exception",
   "as",
   "e1",
   ":",
   "logger",
   ".",
   "error",
   "(",
   "f'error downloading futures contracts (1st trial) {e1}:\\n{fut}'",
   ")",
   "# noinspection PyBroadException",
   "try",
   ":",
   "fut",
   "=",
   "fut",
   "[",
   ":",
   "-",
   "1",
   "]",
   "logger",
   ".",
   "debug",
   "(",
   "f'trying futures (2nd trial): {fut}'",
   ")",
   "fut_matu",
   "=",
   "bdp",
   "(",
   "tickers",
   "=",
   "fut",
   ",",
   "flds",
   "=",
   "'last_tradeable_dt'",
   ",",
   "cache",
   "=",
   "True",
   ")",
   "except",
   "Exception",
   "as",
   "e2",
   ":",
   "logger",
   ".",
   "error",
   "(",
   "f'error downloading futures contracts (2nd trial) {e2}:\\n{fut}'",
   ")",
   "return",
   "''",
   "sub_fut",
   "=",
   "fut_matu",
   "[",
   "pd",
   ".",
   "DatetimeIndex",
   "(",
   "fut_matu",
   ".",
   "last_tradeable_dt",
   ")",
   ">",
   "dt",
   "]",
   "logger",
   ".",
   "debug",
   "(",
   "f'futures full chain:\\n{fut_matu.to_string()}'",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "f'getting index {idx} from:\\n{sub_fut.to_string()}'",
   ")",
   "return",
   "sub_fut",
   ".",
   "index",
   ".",
   "values",
   "[",
   "idx",
   "]"
  ]
 },
 {
  "idx": "maxmin-507",
  "nl_tokens": [
   "Convert",
   "IPA",
   "to",
   "features",
   "."
  ],
  "pl_tokens": [
   "def",
   "ipa_to_features",
   "(",
   "ipa",
   ")",
   ":",
   "features",
   "=",
   "[",
   "]",
   "pos",
   "=",
   "0",
   "ipa",
   "=",
   "normalize",
   "(",
   "'NFD'",
   ",",
   "text_type",
   "(",
   "ipa",
   ".",
   "lower",
   "(",
   ")",
   ")",
   ")",
   "maxsymlen",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "_",
   ")",
   "for",
   "_",
   "in",
   "_PHONETIC_FEATURES",
   ")",
   "while",
   "pos",
   "<",
   "len",
   "(",
   "ipa",
   ")",
   ":",
   "found_match",
   "=",
   "False",
   "for",
   "i",
   "in",
   "range",
   "(",
   "maxsymlen",
   ",",
   "0",
   ",",
   "-",
   "1",
   ")",
   ":",
   "if",
   "(",
   "pos",
   "+",
   "i",
   "-",
   "1",
   "<=",
   "len",
   "(",
   "ipa",
   ")",
   "and",
   "ipa",
   "[",
   "pos",
   ":",
   "pos",
   "+",
   "i",
   "]",
   "in",
   "_PHONETIC_FEATURES",
   ")",
   ":",
   "features",
   ".",
   "append",
   "(",
   "_PHONETIC_FEATURES",
   "[",
   "ipa",
   "[",
   "pos",
   ":",
   "pos",
   "+",
   "i",
   "]",
   "]",
   ")",
   "pos",
   "+=",
   "i",
   "found_match",
   "=",
   "True",
   "if",
   "not",
   "found_match",
   ":",
   "features",
   ".",
   "append",
   "(",
   "-",
   "1",
   ")",
   "pos",
   "+=",
   "1",
   "return",
   "features"
  ]
 },
 {
  "idx": "maxmin-508",
  "nl_tokens": [
   "Listens",
   "on",
   "the",
   "pending_result_queue",
   "and",
   "sends",
   "out",
   "results",
   "via",
   "0mq"
  ],
  "pl_tokens": [
   "def",
   "push_results",
   "(",
   "self",
   ",",
   "kill_event",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"[RESULT_PUSH_THREAD] Starting thread\"",
   ")",
   "push_poll_period",
   "=",
   "<mask>",
   "(",
   "10",
   ",",
   "self",
   ".",
   "poll_period",
   ")",
   "/",
   "1000",
   "# push_poll_period must be atleast 10 ms",
   "logger",
   ".",
   "debug",
   "(",
   "\"[RESULT_PUSH_THREAD] push poll period: {}\"",
   ".",
   "format",
   "(",
   "push_poll_period",
   ")",
   ")",
   "last_beat",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "items",
   "=",
   "[",
   "]",
   "while",
   "not",
   "kill_event",
   ".",
   "is_set",
   "(",
   ")",
   ":",
   "try",
   ":",
   "r",
   "=",
   "self",
   ".",
   "pending_result_queue",
   ".",
   "get",
   "(",
   "block",
   "=",
   "True",
   ",",
   "timeout",
   "=",
   "push_poll_period",
   ")",
   "items",
   ".",
   "append",
   "(",
   "r",
   ")",
   "except",
   "queue",
   ".",
   "Empty",
   ":",
   "pass",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "logger",
   ".",
   "exception",
   "(",
   "\"[RESULT_PUSH_THREAD] Got an exception: {}\"",
   ".",
   "format",
   "(",
   "e",
   ")",
   ")",
   "# If we have reached poll_period duration or timer has expired, we send results",
   "if",
   "len",
   "(",
   "items",
   ")",
   ">=",
   "self",
   ".",
   "max_queue_size",
   "or",
   "time",
   ".",
   "time",
   "(",
   ")",
   ">",
   "last_beat",
   "+",
   "push_poll_period",
   ":",
   "last_beat",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "if",
   "items",
   ":",
   "self",
   ".",
   "result_outgoing",
   ".",
   "send_multipart",
   "(",
   "items",
   ")",
   "items",
   "=",
   "[",
   "]",
   "logger",
   ".",
   "critical",
   "(",
   "\"[RESULT_PUSH_THREAD] Exiting\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-509",
  "nl_tokens": [
   "Call",
   "bash",
   "command",
   "cat",
   "and",
   "split",
   "to",
   "split",
   "large",
   "files",
   ".",
   "The",
   "goal",
   "is",
   "to",
   "create",
   "N",
   "splitfiles",
   "where",
   "N",
   "is",
   "a",
   "multiple",
   "of",
   "the",
   "number",
   "of",
   "processors",
   "so",
   "that",
   "each",
   "processor",
   "can",
   "work",
   "on",
   "a",
   "file",
   "in",
   "parallel",
   "."
  ],
  "pl_tokens": [
   "def",
   "zcat_make_temps",
   "(",
   "data",
   ",",
   "raws",
   ",",
   "num",
   ",",
   "tmpdir",
   ",",
   "optim",
   ",",
   "njobs",
   ",",
   "start",
   ")",
   ":",
   "printstr",
   "=",
   "' chunking large files  | {} | s1 |'",
   "## split args",
   "tmpdir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "realpath",
   "(",
   "tmpdir",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"zcat is using optim = %s\"",
   ",",
   "optim",
   ")",
   "## read it, is it gzipped?",
   "catcmd",
   "=",
   "[",
   "\"cat\"",
   "]",
   "if",
   "raws",
   "[",
   "0",
   "]",
   ".",
   "endswith",
   "(",
   "\".gz\"",
   ")",
   ":",
   "catcmd",
   "=",
   "[",
   "\"gunzip\"",
   ",",
   "\"-c\"",
   "]",
   "## get reading commands for r1s, r2s",
   "cmd1",
   "=",
   "catcmd",
   "+",
   "[",
   "raws",
   "[",
   "0",
   "]",
   "]",
   "cmd2",
   "=",
   "catcmd",
   "+",
   "[",
   "raws",
   "[",
   "1",
   "]",
   "]",
   "## second command splits and writes with name prefix",
   "cmd3",
   "=",
   "[",
   "\"split\"",
   ",",
   "\"-a\"",
   ",",
   "\"4\"",
   ",",
   "\"-l\"",
   ",",
   "str",
   "(",
   "int",
   "(",
   "optim",
   ")",
   ")",
   ",",
   "\"-\"",
   ",",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "tmpdir",
   ",",
   "\"chunk1_\"",
   "+",
   "str",
   "(",
   "num",
   ")",
   "+",
   "\"_\"",
   ")",
   "]",
   "cmd4",
   "=",
   "[",
   "\"split\"",
   ",",
   "\"-a\"",
   ",",
   "\"4\"",
   ",",
   "\"-l\"",
   ",",
   "str",
   "(",
   "int",
   "(",
   "optim",
   ")",
   ")",
   ",",
   "\"-\"",
   ",",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "tmpdir",
   ",",
   "\"chunk2_\"",
   "+",
   "str",
   "(",
   "num",
   ")",
   "+",
   "\"_\"",
   ")",
   "]",
   "### run splitter",
   "proc1",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "cmd1",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "sps",
   ".",
   "PIPE",
   ")",
   "proc3",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "cmd3",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "sps",
   ".",
   "PIPE",
   ",",
   "stdin",
   "=",
   "proc1",
   ".",
   "stdout",
   ")",
   "## wrap the actual call so we can kill it if anything goes awry",
   "while",
   "1",
   ":",
   "try",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "proc3",
   ".",
   "poll",
   "(",
   ")",
   ",",
   "int",
   ")",
   ":",
   "elapsed",
   "=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "seconds",
   "=",
   "int",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")",
   ")",
   "done",
   "=",
   "len",
   "(",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "tmpdir",
   ",",
   "'chunk1_*'",
   ")",
   ")",
   ")",
   "progressbar",
   "(",
   "njobs",
   ",",
   "<mask>",
   "(",
   "njobs",
   ",",
   "done",
   ")",
   ",",
   "printstr",
   ".",
   "format",
   "(",
   "elapsed",
   ")",
   ",",
   "spacer",
   "=",
   "data",
   ".",
   "_spacer",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "0.1",
   ")",
   "else",
   ":",
   "res",
   "=",
   "proc3",
   ".",
   "communicate",
   "(",
   ")",
   "[",
   "0",
   "]",
   "proc1",
   ".",
   "stdout",
   ".",
   "close",
   "(",
   ")",
   "break",
   "except",
   "KeyboardInterrupt",
   ":",
   "proc1",
   ".",
   "kill",
   "(",
   ")",
   "proc3",
   ".",
   "kill",
   "(",
   ")",
   "raise",
   "KeyboardInterrupt",
   "(",
   ")",
   "if",
   "proc3",
   ".",
   "returncode",
   ":",
   "raise",
   "IPyradWarningExit",
   "(",
   "\" error in %s: %s\"",
   ",",
   "cmd3",
   ",",
   "res",
   ")",
   "## grab output handles",
   "chunks1",
   "=",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "tmpdir",
   ",",
   "\"chunk1_\"",
   "+",
   "str",
   "(",
   "num",
   ")",
   "+",
   "\"_*\"",
   ")",
   ")",
   "chunks1",
   ".",
   "sort",
   "(",
   ")",
   "if",
   "\"pair\"",
   "in",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"datatype\"",
   "]",
   ":",
   "proc2",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "cmd2",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "sps",
   ".",
   "PIPE",
   ")",
   "proc4",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "cmd4",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "sps",
   ".",
   "PIPE",
   ",",
   "stdin",
   "=",
   "proc2",
   ".",
   "stdout",
   ")",
   "## wrap the actual call so we can kill it if anything goes awry",
   "while",
   "1",
   ":",
   "try",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "proc4",
   ".",
   "poll",
   "(",
   ")",
   ",",
   "int",
   ")",
   ":",
   "elapsed",
   "=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "seconds",
   "=",
   "int",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")",
   ")",
   "done",
   "=",
   "len",
   "(",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "tmpdir",
   ",",
   "'chunk1_*'",
   ")",
   ")",
   ")",
   "progressbar",
   "(",
   "njobs",
   ",",
   "min",
   "(",
   "njobs",
   ",",
   "done",
   ")",
   ",",
   "printstr",
   ".",
   "format",
   "(",
   "elapsed",
   ")",
   ",",
   "data",
   ".",
   "_spacer",
   ")",
   "time",
   ".",
   "sleep",
   "(",
   "0.1",
   ")",
   "else",
   ":",
   "res",
   "=",
   "proc4",
   ".",
   "communicate",
   "(",
   ")",
   "[",
   "0",
   "]",
   "proc2",
   ".",
   "stdout",
   ".",
   "close",
   "(",
   ")",
   "break",
   "except",
   "KeyboardInterrupt",
   ":",
   "proc2",
   ".",
   "kill",
   "(",
   ")",
   "proc4",
   ".",
   "kill",
   "(",
   ")",
   "raise",
   "KeyboardInterrupt",
   "(",
   ")",
   "if",
   "proc4",
   ".",
   "returncode",
   ":",
   "raise",
   "IPyradWarningExit",
   "(",
   "\" error in %s: %s\"",
   ",",
   "cmd4",
   ",",
   "res",
   ")",
   "## grab output handles",
   "chunks2",
   "=",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "tmpdir",
   ",",
   "\"chunk2_\"",
   "+",
   "str",
   "(",
   "num",
   ")",
   "+",
   "\"_*\"",
   ")",
   ")",
   "chunks2",
   ".",
   "sort",
   "(",
   ")",
   "else",
   ":",
   "chunks2",
   "=",
   "[",
   "0",
   "]",
   "*",
   "len",
   "(",
   "chunks1",
   ")",
   "assert",
   "len",
   "(",
   "chunks1",
   ")",
   "==",
   "len",
   "(",
   "chunks2",
   ")",
   ",",
   "\"R1 and R2 files are not the same length.\"",
   "## ensure full progress bar b/c estimates njobs could be off",
   "progressbar",
   "(",
   "10",
   ",",
   "10",
   ",",
   "printstr",
   ".",
   "format",
   "(",
   "elapsed",
   ")",
   ",",
   "spacer",
   "=",
   "data",
   ".",
   "_spacer",
   ")",
   "return",
   "zip",
   "(",
   "chunks1",
   ",",
   "chunks2",
   ")"
  ]
 },
 {
  "idx": "maxmin-510",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__calculate_score",
   "(",
   "self",
   ",",
   "index_point",
   ",",
   "index_cluster",
   ")",
   ":",
   "difference",
   "=",
   "self",
   ".",
   "__calculate_dataset_difference",
   "(",
   "index_point",
   ")",
   "a_score",
   "=",
   "self",
   ".",
   "__calculate_within_cluster_score",
   "(",
   "index_cluster",
   ",",
   "difference",
   ")",
   "b_score",
   "=",
   "self",
   ".",
   "__caclulate_optimal_neighbor_cluster_score",
   "(",
   "index_cluster",
   ",",
   "difference",
   ")",
   "return",
   "(",
   "b_score",
   "-",
   "a_score",
   ")",
   "/",
   "<mask>",
   "(",
   "a_score",
   ",",
   "b_score",
   ")"
  ]
 },
 {
  "idx": "maxmin-511",
  "nl_tokens": [
   "r",
   "Compute",
   "precision",
   "-",
   "recall",
   "statistics",
   "for",
   "directed",
   "graphs",
   ".",
   "Precision",
   "recall",
   "statistics",
   "are",
   "useful",
   "to",
   "compare",
   "algorithms",
   "that",
   "make",
   "predictions",
   "with",
   "a",
   "confidence",
   "score",
   ".",
   "Using",
   "these",
   "statistics",
   "performance",
   "of",
   "an",
   "algorithms",
   "given",
   "a",
   "set",
   "threshold",
   "(",
   "confidence",
   "score",
   ")",
   "can",
   "be",
   "approximated",
   ".",
   "Area",
   "under",
   "the",
   "precision",
   "-",
   "recall",
   "curve",
   "as",
   "well",
   "as",
   "the",
   "coordinates",
   "of",
   "the",
   "precision",
   "recall",
   "curve",
   "are",
   "computed",
   "using",
   "the",
   "scikit",
   "-",
   "learn",
   "library",
   "tools",
   ".",
   "Note",
   "that",
   "unlike",
   "the",
   "AUROC",
   "metric",
   "this",
   "metric",
   "does",
   "not",
   "account",
   "for",
   "class",
   "imbalance",
   "."
  ],
  "pl_tokens": [
   "def",
   "precision_recall",
   "(",
   "target",
   ",",
   "prediction",
   ",",
   "low_confidence_undirected",
   "=",
   "False",
   ")",
   ":",
   "true_labels",
   "=",
   "retrieve_adjacency_matrix",
   "(",
   "target",
   ")",
   "pred",
   "=",
   "retrieve_adjacency_matrix",
   "(",
   "prediction",
   ",",
   "target",
   ".",
   "nodes",
   "(",
   ")",
   "if",
   "isinstance",
   "(",
   "target",
   ",",
   "nx",
   ".",
   "DiGraph",
   ")",
   "else",
   "None",
   ",",
   "weight",
   "=",
   "True",
   ")",
   "if",
   "low_confidence_undirected",
   ":",
   "# Take account of undirected edges by putting them with low confidence",
   "pred",
   "[",
   "pred",
   "==",
   "pred",
   ".",
   "transpose",
   "(",
   ")",
   "]",
   "*=",
   "<mask>",
   "(",
   "min",
   "(",
   "pred",
   "[",
   "np",
   ".",
   "nonzero",
   "(",
   "pred",
   ")",
   "]",
   ")",
   "*",
   ".5",
   ",",
   ".1",
   ")",
   "precision",
   ",",
   "recall",
   ",",
   "_",
   "=",
   "precision_recall_curve",
   "(",
   "true_labels",
   ".",
   "ravel",
   "(",
   ")",
   ",",
   "pred",
   ".",
   "ravel",
   "(",
   ")",
   ")",
   "aupr",
   "=",
   "auc",
   "(",
   "recall",
   ",",
   "precision",
   ",",
   "reorder",
   "=",
   "True",
   ")",
   "return",
   "aupr",
   ",",
   "list",
   "(",
   "zip",
   "(",
   "precision",
   ",",
   "recall",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-512",
  "nl_tokens": [
   "Converts",
   "multiple",
   "input",
   "images",
   "into",
   "a",
   "single",
   "image",
   "showing",
   "them",
   "in",
   "a",
   "grid",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw_grid",
   "(",
   "images",
   ",",
   "rows",
   "=",
   "None",
   ",",
   "cols",
   "=",
   "None",
   ")",
   ":",
   "nb_images",
   "=",
   "len",
   "(",
   "images",
   ")",
   "do_assert",
   "(",
   "nb_images",
   ">",
   "0",
   ")",
   "if",
   "is_np_array",
   "(",
   "images",
   ")",
   ":",
   "do_assert",
   "(",
   "images",
   ".",
   "ndim",
   "==",
   "4",
   ")",
   "else",
   ":",
   "do_assert",
   "(",
   "is_iterable",
   "(",
   "images",
   ")",
   "and",
   "is_np_array",
   "(",
   "images",
   "[",
   "0",
   "]",
   ")",
   "and",
   "images",
   "[",
   "0",
   "]",
   ".",
   "ndim",
   "==",
   "3",
   ")",
   "dts",
   "=",
   "[",
   "image",
   ".",
   "dtype",
   ".",
   "name",
   "for",
   "image",
   "in",
   "images",
   "]",
   "nb_dtypes",
   "=",
   "len",
   "(",
   "set",
   "(",
   "dts",
   ")",
   ")",
   "do_assert",
   "(",
   "nb_dtypes",
   "==",
   "1",
   ",",
   "(",
   "\"All images provided to draw_grid() must have the same dtype, \"",
   "+",
   "\"found %d dtypes (%s)\"",
   ")",
   "%",
   "(",
   "nb_dtypes",
   ",",
   "\", \"",
   ".",
   "join",
   "(",
   "dts",
   ")",
   ")",
   ")",
   "cell_height",
   "=",
   "<mask>",
   "(",
   "[",
   "image",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "for",
   "image",
   "in",
   "images",
   "]",
   ")",
   "cell_width",
   "=",
   "max",
   "(",
   "[",
   "image",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "for",
   "image",
   "in",
   "images",
   "]",
   ")",
   "channels",
   "=",
   "set",
   "(",
   "[",
   "image",
   ".",
   "shape",
   "[",
   "2",
   "]",
   "for",
   "image",
   "in",
   "images",
   "]",
   ")",
   "do_assert",
   "(",
   "len",
   "(",
   "channels",
   ")",
   "==",
   "1",
   ",",
   "\"All images are expected to have the same number of channels, \"",
   "+",
   "\"but got channel set %s with length %d instead.\"",
   "%",
   "(",
   "str",
   "(",
   "channels",
   ")",
   ",",
   "len",
   "(",
   "channels",
   ")",
   ")",
   ")",
   "nb_channels",
   "=",
   "list",
   "(",
   "channels",
   ")",
   "[",
   "0",
   "]",
   "if",
   "rows",
   "is",
   "None",
   "and",
   "cols",
   "is",
   "None",
   ":",
   "rows",
   "=",
   "cols",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "math",
   ".",
   "sqrt",
   "(",
   "nb_images",
   ")",
   ")",
   ")",
   "elif",
   "rows",
   "is",
   "not",
   "None",
   ":",
   "cols",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "nb_images",
   "/",
   "rows",
   ")",
   ")",
   "elif",
   "cols",
   "is",
   "not",
   "None",
   ":",
   "rows",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "nb_images",
   "/",
   "cols",
   ")",
   ")",
   "do_assert",
   "(",
   "rows",
   "*",
   "cols",
   ">=",
   "nb_images",
   ")",
   "width",
   "=",
   "cell_width",
   "*",
   "cols",
   "height",
   "=",
   "cell_height",
   "*",
   "rows",
   "dt",
   "=",
   "images",
   ".",
   "dtype",
   "if",
   "is_np_array",
   "(",
   "images",
   ")",
   "else",
   "images",
   "[",
   "0",
   "]",
   ".",
   "dtype",
   "grid",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "height",
   ",",
   "width",
   ",",
   "nb_channels",
   ")",
   ",",
   "dtype",
   "=",
   "dt",
   ")",
   "cell_idx",
   "=",
   "0",
   "for",
   "row_idx",
   "in",
   "sm",
   ".",
   "xrange",
   "(",
   "rows",
   ")",
   ":",
   "for",
   "col_idx",
   "in",
   "sm",
   ".",
   "xrange",
   "(",
   "cols",
   ")",
   ":",
   "if",
   "cell_idx",
   "<",
   "nb_images",
   ":",
   "image",
   "=",
   "images",
   "[",
   "cell_idx",
   "]",
   "cell_y1",
   "=",
   "cell_height",
   "*",
   "row_idx",
   "cell_y2",
   "=",
   "cell_y1",
   "+",
   "image",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "cell_x1",
   "=",
   "cell_width",
   "*",
   "col_idx",
   "cell_x2",
   "=",
   "cell_x1",
   "+",
   "image",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "grid",
   "[",
   "cell_y1",
   ":",
   "cell_y2",
   ",",
   "cell_x1",
   ":",
   "cell_x2",
   ",",
   ":",
   "]",
   "=",
   "image",
   "cell_idx",
   "+=",
   "1",
   "return",
   "grid"
  ]
 },
 {
  "idx": "maxmin-513",
  "nl_tokens": [
   "Accepts",
   "log",
   "-",
   "values",
   "as",
   "input",
   "exponentiates",
   "them",
   "sums",
   "down",
   "the",
   "rows",
   "(",
   "first",
   "dimension",
   ")",
   "normalizes",
   "and",
   "returns",
   "the",
   "result",
   ".",
   "Handles",
   "underflow",
   "by",
   "rescaling",
   "so",
   "that",
   "the",
   "largest",
   "values",
   "is",
   "exactly",
   "1",
   ".",
   "0",
   "."
  ],
  "pl_tokens": [
   "def",
   "nsum0",
   "(",
   "lx",
   ")",
   ":",
   "lx",
   "=",
   "numpy",
   ".",
   "asarray",
   "(",
   "lx",
   ")",
   "base",
   "=",
   "lx",
   ".",
   "<mask>",
   "(",
   ")",
   "x",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   "-",
   "base",
   ")",
   "ssum",
   "=",
   "x",
   ".",
   "sum",
   "(",
   "0",
   ")",
   "result",
   "=",
   "ssum",
   "/",
   "ssum",
   ".",
   "sum",
   "(",
   ")",
   "conventional",
   "=",
   "(",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   ")",
   ".",
   "sum",
   "(",
   "0",
   ")",
   "/",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   ")",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "assert",
   "similar",
   "(",
   "result",
   ",",
   "conventional",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-514",
  "nl_tokens": [
   "See",
   "comments",
   "in",
   "base",
   "class",
   "."
  ],
  "pl_tokens": [
   "def",
   "newPosition",
   "(",
   "self",
   ",",
   "globalBestPosition",
   ",",
   "rng",
   ")",
   ":",
   "# Compute the mean score per choice.",
   "numChoices",
   "=",
   "len",
   "(",
   "self",
   ".",
   "choices",
   ")",
   "meanScorePerChoice",
   "=",
   "[",
   "]",
   "overallSum",
   "=",
   "0",
   "numResults",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "numChoices",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_resultsPerChoice",
   "[",
   "i",
   "]",
   ")",
   ">",
   "0",
   ":",
   "data",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "self",
   ".",
   "_resultsPerChoice",
   "[",
   "i",
   "]",
   ")",
   "meanScorePerChoice",
   ".",
   "append",
   "(",
   "data",
   ".",
   "mean",
   "(",
   ")",
   ")",
   "overallSum",
   "+=",
   "data",
   ".",
   "sum",
   "(",
   ")",
   "numResults",
   "+=",
   "data",
   ".",
   "size",
   "else",
   ":",
   "meanScorePerChoice",
   ".",
   "append",
   "(",
   "None",
   ")",
   "if",
   "numResults",
   "==",
   "0",
   ":",
   "overallSum",
   "=",
   "1.0",
   "numResults",
   "=",
   "1",
   "# For any choices we don't have a result for yet, set to the overall mean.",
   "for",
   "i",
   "in",
   "range",
   "(",
   "numChoices",
   ")",
   ":",
   "if",
   "meanScorePerChoice",
   "[",
   "i",
   "]",
   "is",
   "None",
   ":",
   "meanScorePerChoice",
   "[",
   "i",
   "]",
   "=",
   "overallSum",
   "/",
   "numResults",
   "# Now, pick a new choice based on the above probabilities. Note that the",
   "#  best result is the lowest result. We want to make it more likely to",
   "#  pick the choice that produced the lowest results. So, we need to invert",
   "#  the scores (someLargeNumber - score).",
   "meanScorePerChoice",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "meanScorePerChoice",
   ")",
   "# Invert meaning.",
   "meanScorePerChoice",
   "=",
   "(",
   "1.1",
   "*",
   "meanScorePerChoice",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "-",
   "meanScorePerChoice",
   "# If you want the scores to quickly converge to the best choice, raise the",
   "# results to a power. This will cause lower scores to become lower",
   "# probability as you see more results, until it eventually should",
   "# assymptote to only choosing the best choice.",
   "if",
   "self",
   ".",
   "_fixEarly",
   ":",
   "meanScorePerChoice",
   "**=",
   "(",
   "numResults",
   "*",
   "self",
   ".",
   "_fixEarlyFactor",
   "/",
   "numChoices",
   ")",
   "# Normalize.",
   "total",
   "=",
   "meanScorePerChoice",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "total",
   "==",
   "0",
   ":",
   "total",
   "=",
   "1.0",
   "meanScorePerChoice",
   "/=",
   "total",
   "# Get distribution and choose one based on those probabilities.",
   "distribution",
   "=",
   "meanScorePerChoice",
   ".",
   "cumsum",
   "(",
   ")",
   "r",
   "=",
   "rng",
   ".",
   "random",
   "(",
   ")",
   "*",
   "distribution",
   "[",
   "-",
   "1",
   "]",
   "choiceIdx",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "r",
   "<=",
   "distribution",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "self",
   ".",
   "_positionIdx",
   "=",
   "choiceIdx",
   "return",
   "self",
   ".",
   "getPosition",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-515",
  "nl_tokens": [
   "Returns",
   "a",
   "masked",
   "array",
   "with",
   "anything",
   "outside",
   "of",
   "values",
   "masked",
   ".",
   "The",
   "minv",
   "and",
   "maxv",
   "parameters",
   "take",
   "precendence",
   "over",
   "any",
   "dict",
   "values",
   ".",
   "The",
   "valid_range",
   "attribute",
   "takes",
   "precendence",
   "over",
   "the",
   "valid_min",
   "and",
   "valid_max",
   "attributes",
   "."
  ],
  "pl_tokens": [
   "def",
   "generic_masked",
   "(",
   "arr",
   ",",
   "attrs",
   "=",
   "None",
   ",",
   "minv",
   "=",
   "None",
   ",",
   "maxv",
   "=",
   "None",
   ",",
   "mask_nan",
   "=",
   "True",
   ")",
   ":",
   "attrs",
   "=",
   "attrs",
   "or",
   "{",
   "}",
   "if",
   "'valid_min'",
   "in",
   "attrs",
   ":",
   "minv",
   "=",
   "safe_attribute_typing",
   "(",
   "arr",
   ".",
   "dtype",
   ",",
   "attrs",
   "[",
   "'valid_min'",
   "]",
   ")",
   "if",
   "'valid_max'",
   "in",
   "attrs",
   ":",
   "maxv",
   "=",
   "safe_attribute_typing",
   "(",
   "arr",
   ".",
   "dtype",
   ",",
   "attrs",
   "[",
   "'valid_max'",
   "]",
   ")",
   "if",
   "'valid_range'",
   "in",
   "attrs",
   ":",
   "vr",
   "=",
   "attrs",
   "[",
   "'valid_range'",
   "]",
   "minv",
   "=",
   "safe_attribute_typing",
   "(",
   "arr",
   ".",
   "dtype",
   ",",
   "vr",
   "[",
   "0",
   "]",
   ")",
   "maxv",
   "=",
   "safe_attribute_typing",
   "(",
   "arr",
   ".",
   "dtype",
   ",",
   "vr",
   "[",
   "1",
   "]",
   ")",
   "# Get the min/max of values that the hardware supports",
   "try",
   ":",
   "info",
   "=",
   "np",
   ".",
   "iinfo",
   "(",
   "arr",
   ".",
   "dtype",
   ")",
   "except",
   "ValueError",
   ":",
   "info",
   "=",
   "np",
   ".",
   "finfo",
   "(",
   "arr",
   ".",
   "dtype",
   ")",
   "minv",
   "=",
   "minv",
   "if",
   "minv",
   "is",
   "not",
   "None",
   "else",
   "info",
   ".",
   "<mask>",
   "maxv",
   "=",
   "maxv",
   "if",
   "maxv",
   "is",
   "not",
   "None",
   "else",
   "info",
   ".",
   "max",
   "if",
   "mask_nan",
   "is",
   "True",
   ":",
   "arr",
   "=",
   "np",
   ".",
   "ma",
   ".",
   "fix_invalid",
   "(",
   "arr",
   ")",
   "return",
   "np",
   ".",
   "ma",
   ".",
   "masked_outside",
   "(",
   "arr",
   ",",
   "minv",
   ",",
   "maxv",
   ")"
  ]
 },
 {
  "idx": "maxmin-516",
  "nl_tokens": [
   "Initializes",
   "the",
   "probability",
   "of",
   "read",
   "origin",
   "according",
   "to",
   "the",
   "alignment",
   "profile"
  ],
  "pl_tokens": [
   "def",
   "prepare",
   "(",
   "self",
   ",",
   "pseudocount",
   "=",
   "0.0",
   ",",
   "lenfile",
   "=",
   "None",
   ",",
   "read_length",
   "=",
   "100",
   ")",
   ":",
   "if",
   "self",
   ".",
   "probability",
   ".",
   "num_groups",
   ">",
   "0",
   ":",
   "self",
   ".",
   "grp_conv_mat",
   "=",
   "lil_matrix",
   "(",
   "(",
   "self",
   ".",
   "probability",
   ".",
   "num_loci",
   ",",
   "self",
   ".",
   "probability",
   ".",
   "num_groups",
   ")",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "self",
   ".",
   "probability",
   ".",
   "num_groups",
   ")",
   ":",
   "self",
   ".",
   "grp_conv_mat",
   "[",
   "self",
   ".",
   "probability",
   ".",
   "groups",
   "[",
   "i",
   "]",
   ",",
   "i",
   "]",
   "=",
   "1.0",
   "self",
   ".",
   "grp_conv_mat",
   "=",
   "self",
   ".",
   "grp_conv_mat",
   ".",
   "tocsc",
   "(",
   ")",
   "self",
   ".",
   "t2t_mat",
   "=",
   "eye",
   "(",
   "self",
   ".",
   "probability",
   ".",
   "num_loci",
   ",",
   "self",
   ".",
   "probability",
   ".",
   "num_loci",
   ")",
   "self",
   ".",
   "t2t_mat",
   "=",
   "self",
   ".",
   "t2t_mat",
   ".",
   "tolil",
   "(",
   ")",
   "for",
   "tid_list",
   "in",
   "self",
   ".",
   "probability",
   ".",
   "groups",
   ":",
   "for",
   "ii",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "tid_list",
   ")",
   ")",
   ":",
   "for",
   "jj",
   "in",
   "xrange",
   "(",
   "ii",
   ")",
   ":",
   "i",
   "=",
   "tid_list",
   "[",
   "ii",
   "]",
   "j",
   "=",
   "tid_list",
   "[",
   "jj",
   "]",
   "self",
   ".",
   "t2t_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "1",
   "self",
   ".",
   "t2t_mat",
   "[",
   "j",
   ",",
   "i",
   "]",
   "=",
   "1",
   "self",
   ".",
   "t2t_mat",
   "=",
   "self",
   ".",
   "t2t_mat",
   ".",
   "tocsc",
   "(",
   ")",
   "if",
   "lenfile",
   "is",
   "not",
   "None",
   ":",
   "hid",
   "=",
   "dict",
   "(",
   "zip",
   "(",
   "self",
   ".",
   "probability",
   ".",
   "hname",
   ",",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "self",
   ".",
   "probability",
   ".",
   "hname",
   ")",
   ")",
   ")",
   ")",
   "self",
   ".",
   "target_lengths",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "self",
   ".",
   "probability",
   ".",
   "num_loci",
   ",",
   "self",
   ".",
   "probability",
   ".",
   "num_haplotypes",
   ")",
   ")",
   "if",
   "self",
   ".",
   "probability",
   ".",
   "num_haplotypes",
   ">",
   "1",
   ":",
   "with",
   "open",
   "(",
   "lenfile",
   ")",
   "as",
   "fh",
   ":",
   "for",
   "curline",
   "in",
   "fh",
   ":",
   "item",
   "=",
   "curline",
   ".",
   "rstrip",
   "(",
   ")",
   ".",
   "split",
   "(",
   "\"\\t\"",
   ")",
   "locus",
   ",",
   "hap",
   "=",
   "item",
   "[",
   "0",
   "]",
   ".",
   "split",
   "(",
   "\"_\"",
   ")",
   "self",
   ".",
   "target_lengths",
   "[",
   "self",
   ".",
   "probability",
   ".",
   "lid",
   "[",
   "locus",
   "]",
   ",",
   "hid",
   "[",
   "hap",
   "]",
   "]",
   "=",
   "<mask>",
   "(",
   "float",
   "(",
   "item",
   "[",
   "1",
   "]",
   ")",
   "-",
   "read_length",
   "+",
   "1.0",
   ",",
   "1.0",
   ")",
   "elif",
   "self",
   ".",
   "probability",
   ".",
   "num_haplotypes",
   ">",
   "0",
   ":",
   "with",
   "open",
   "(",
   "lenfile",
   ")",
   "as",
   "fh",
   ":",
   "for",
   "curline",
   "in",
   "fh",
   ":",
   "item",
   "=",
   "curline",
   ".",
   "rstrip",
   "(",
   ")",
   ".",
   "split",
   "(",
   "\"\\t\"",
   ")",
   "self",
   ".",
   "target_lengths",
   "[",
   "self",
   ".",
   "probability",
   ".",
   "lid",
   "[",
   "item",
   "[",
   "0",
   "]",
   "]",
   ",",
   "0",
   "]",
   "=",
   "max",
   "(",
   "float",
   "(",
   "item",
   "[",
   "1",
   "]",
   ")",
   "-",
   "read_length",
   "+",
   "1.0",
   ",",
   "1.0",
   ")",
   "else",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "'There is something wrong with your emase-format alignment file.'",
   ")",
   "self",
   ".",
   "target_lengths",
   "=",
   "self",
   ".",
   "target_lengths",
   ".",
   "transpose",
   "(",
   ")",
   "#self.target_lengths = self.target_lengths.transpose() / read_length  # lengths in terms of read counts",
   "if",
   "not",
   "np",
   ".",
   "all",
   "(",
   "self",
   ".",
   "target_lengths",
   ">",
   "0.0",
   ")",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "'There exist transcripts missing length information.'",
   ")",
   "self",
   ".",
   "probability",
   ".",
   "normalize_reads",
   "(",
   "axis",
   "=",
   "APM",
   ".",
   "Axis",
   ".",
   "READ",
   ")",
   "# Initialize alignment probability matrix",
   "self",
   ".",
   "allelic_expression",
   "=",
   "self",
   ".",
   "probability",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "APM",
   ".",
   "Axis",
   ".",
   "READ",
   ")",
   "if",
   "self",
   ".",
   "target_lengths",
   "is",
   "not",
   "None",
   ":",
   "# allelic_expression will be at depth-level",
   "self",
   ".",
   "allelic_expression",
   "=",
   "np",
   ".",
   "divide",
   "(",
   "self",
   ".",
   "allelic_expression",
   ",",
   "self",
   ".",
   "target_lengths",
   ")",
   "if",
   "pseudocount",
   ">",
   "0.0",
   ":",
   "# pseudocount is at depth-level",
   "orig_allelic_expression_sum",
   "=",
   "self",
   ".",
   "allelic_expression",
   ".",
   "sum",
   "(",
   ")",
   "nzloci",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "self",
   ".",
   "allelic_expression",
   ")",
   "[",
   "1",
   "]",
   "self",
   ".",
   "allelic_expression",
   "[",
   ":",
   ",",
   "nzloci",
   "]",
   "+=",
   "pseudocount",
   "self",
   ".",
   "allelic_expression",
   "*=",
   "(",
   "orig_allelic_expression_sum",
   "/",
   "self",
   ".",
   "allelic_expression",
   ".",
   "sum",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-517",
  "nl_tokens": [
   "Input",
   "RGB",
   "image",
   "[",
   "0~255",
   "]",
   "return",
   "HSV",
   "image",
   "[",
   "0~1",
   "]",
   "."
  ],
  "pl_tokens": [
   "def",
   "rgb_to_hsv",
   "(",
   "rgb",
   ")",
   ":",
   "# Translated from source of colorsys.rgb_to_hsv",
   "# r,g,b should be a numpy arrays with values between 0 and 255",
   "# rgb_to_hsv returns an array of floats between 0.0 and 1.0.",
   "rgb",
   "=",
   "rgb",
   ".",
   "astype",
   "(",
   "'float'",
   ")",
   "hsv",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "rgb",
   ")",
   "# in case an RGBA array was passed, just copy the A channel",
   "hsv",
   "[",
   "...",
   ",",
   "3",
   ":",
   "]",
   "=",
   "rgb",
   "[",
   "...",
   ",",
   "3",
   ":",
   "]",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "rgb",
   "[",
   "...",
   ",",
   "0",
   "]",
   ",",
   "rgb",
   "[",
   "...",
   ",",
   "1",
   "]",
   ",",
   "rgb",
   "[",
   "...",
   ",",
   "2",
   "]",
   "maxc",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "rgb",
   "[",
   "...",
   ",",
   ":",
   "3",
   "]",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "minc",
   "=",
   "np",
   ".",
   "min",
   "(",
   "rgb",
   "[",
   "...",
   ",",
   ":",
   "3",
   "]",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "hsv",
   "[",
   "...",
   ",",
   "2",
   "]",
   "=",
   "maxc",
   "mask",
   "=",
   "maxc",
   "!=",
   "minc",
   "hsv",
   "[",
   "mask",
   ",",
   "1",
   "]",
   "=",
   "(",
   "maxc",
   "-",
   "minc",
   ")",
   "[",
   "mask",
   "]",
   "/",
   "maxc",
   "[",
   "mask",
   "]",
   "rc",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "r",
   ")",
   "gc",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "g",
   ")",
   "bc",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "b",
   ")",
   "rc",
   "[",
   "mask",
   "]",
   "=",
   "(",
   "maxc",
   "-",
   "r",
   ")",
   "[",
   "mask",
   "]",
   "/",
   "(",
   "maxc",
   "-",
   "minc",
   ")",
   "[",
   "mask",
   "]",
   "gc",
   "[",
   "mask",
   "]",
   "=",
   "(",
   "maxc",
   "-",
   "g",
   ")",
   "[",
   "mask",
   "]",
   "/",
   "(",
   "maxc",
   "-",
   "minc",
   ")",
   "[",
   "mask",
   "]",
   "bc",
   "[",
   "mask",
   "]",
   "=",
   "(",
   "maxc",
   "-",
   "b",
   ")",
   "[",
   "mask",
   "]",
   "/",
   "(",
   "maxc",
   "-",
   "minc",
   ")",
   "[",
   "mask",
   "]",
   "hsv",
   "[",
   "...",
   ",",
   "0",
   "]",
   "=",
   "np",
   ".",
   "select",
   "(",
   "[",
   "r",
   "==",
   "maxc",
   ",",
   "g",
   "==",
   "maxc",
   "]",
   ",",
   "[",
   "bc",
   "-",
   "gc",
   ",",
   "2.0",
   "+",
   "rc",
   "-",
   "bc",
   "]",
   ",",
   "default",
   "=",
   "4.0",
   "+",
   "gc",
   "-",
   "rc",
   ")",
   "hsv",
   "[",
   "...",
   ",",
   "0",
   "]",
   "=",
   "(",
   "hsv",
   "[",
   "...",
   ",",
   "0",
   "]",
   "/",
   "6.0",
   ")",
   "%",
   "1.0",
   "return",
   "hsv"
  ]
 },
 {
  "idx": "maxmin-518",
  "nl_tokens": [
   "Implementation",
   "of",
   "the",
   "ARACNE",
   "algorithm",
   "."
  ],
  "pl_tokens": [
   "def",
   "aracne",
   "(",
   "m",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "I0",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'I0'",
   ",",
   "0.0",
   ")",
   "# No default thresholding",
   "W0",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'W0'",
   ",",
   "0.05",
   ")",
   "# thresholding",
   "m",
   "=",
   "np",
   ".",
   "where",
   "(",
   "m",
   ">",
   "I0",
   ",",
   "m",
   ",",
   "0",
   ")",
   "# Finding triplets and filtering them",
   "for",
   "i",
   "in",
   "range",
   "(",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "2",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "i",
   "+",
   "1",
   ",",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "1",
   ")",
   ":",
   "for",
   "k",
   "in",
   "range",
   "(",
   "j",
   "+",
   "1",
   ",",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "triplet",
   "=",
   "[",
   "m",
   "[",
   "i",
   ",",
   "j",
   "]",
   ",",
   "m",
   "[",
   "j",
   ",",
   "k",
   "]",
   ",",
   "m",
   "[",
   "i",
   ",",
   "k",
   "]",
   "]",
   "min_index",
   ",",
   "min_value",
   "=",
   "<mask>",
   "(",
   "enumerate",
   "(",
   "triplet",
   ")",
   ",",
   "key",
   "=",
   "operator",
   ".",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "if",
   "0",
   "<",
   "min_value",
   "<",
   "W0",
   ":",
   "if",
   "min_index",
   "==",
   "0",
   ":",
   "m",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "m",
   "[",
   "j",
   ",",
   "i",
   "]",
   "=",
   "0.",
   "elif",
   "min_index",
   "==",
   "1",
   ":",
   "m",
   "[",
   "j",
   ",",
   "k",
   "]",
   "=",
   "m",
   "[",
   "k",
   ",",
   "j",
   "]",
   "=",
   "0.",
   "else",
   ":",
   "m",
   "[",
   "i",
   ",",
   "k",
   "]",
   "=",
   "m",
   "[",
   "k",
   ",",
   "i",
   "]",
   "=",
   "0.",
   "return",
   "m"
  ]
 },
 {
  "idx": "maxmin-519",
  "nl_tokens": [
   "Called",
   "at",
   "the",
   "end",
   "of",
   "inference",
   "to",
   "print",
   "out",
   "various",
   "diagnostic",
   "information",
   "based",
   "on",
   "the",
   "current",
   "verbosity",
   "level",
   "."
  ],
  "pl_tokens": [
   "def",
   "printComputeEnd",
   "(",
   "self",
   ",",
   "output",
   ",",
   "learn",
   "=",
   "False",
   ")",
   ":",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "3",
   ":",
   "print",
   "\"----- computeEnd summary: \"",
   "print",
   "\"learn:\"",
   ",",
   "learn",
   "print",
   "\"numBurstingCols: %s, \"",
   "%",
   "(",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ".",
   "sum",
   "(",
   ")",
   ")",
   ",",
   "print",
   "\"curPredScore2: %s, \"",
   "%",
   "(",
   "self",
   ".",
   "_internalStats",
   "[",
   "'curPredictionScore2'",
   "]",
   ")",
   ",",
   "print",
   "\"curFalsePosScore: %s, \"",
   "%",
   "(",
   "self",
   ".",
   "_internalStats",
   "[",
   "'curFalsePositiveScore'",
   "]",
   ")",
   ",",
   "print",
   "\"1-curFalseNegScore: %s, \"",
   "%",
   "(",
   "1",
   "-",
   "self",
   ".",
   "_internalStats",
   "[",
   "'curFalseNegativeScore'",
   "]",
   ")",
   "print",
   "\"numSegments: \"",
   ",",
   "self",
   ".",
   "getNumSegments",
   "(",
   ")",
   ",",
   "print",
   "\"avgLearnedSeqLength: \"",
   ",",
   "self",
   ".",
   "avgLearnedSeqLength",
   "print",
   "\"----- infActiveState (%d on) ------\"",
   "%",
   "(",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "6",
   ":",
   "self",
   ".",
   "printState",
   "(",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ")",
   "print",
   "\"----- infPredictedState (%d on)-----\"",
   "%",
   "(",
   "self",
   ".",
   "infPredictedState",
   "[",
   "'t'",
   "]",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "self",
   ".",
   "infPredictedState",
   "[",
   "'t'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "6",
   ":",
   "self",
   ".",
   "printState",
   "(",
   "self",
   ".",
   "infPredictedState",
   "[",
   "'t'",
   "]",
   ")",
   "print",
   "\"----- lrnActiveState (%d on) ------\"",
   "%",
   "(",
   "self",
   ".",
   "lrnActiveState",
   "[",
   "'t'",
   "]",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "self",
   ".",
   "lrnActiveState",
   "[",
   "'t'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "6",
   ":",
   "self",
   ".",
   "printState",
   "(",
   "self",
   ".",
   "lrnActiveState",
   "[",
   "'t'",
   "]",
   ")",
   "print",
   "\"----- lrnPredictedState (%d on)-----\"",
   "%",
   "(",
   "self",
   ".",
   "lrnPredictedState",
   "[",
   "'t'",
   "]",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "self",
   ".",
   "lrnPredictedState",
   "[",
   "'t'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "6",
   ":",
   "self",
   ".",
   "printState",
   "(",
   "self",
   ".",
   "lrnPredictedState",
   "[",
   "'t'",
   "]",
   ")",
   "print",
   "\"----- cellConfidence -----\"",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "self",
   ".",
   "cellConfidence",
   "[",
   "'t'",
   "]",
   ",",
   "andValues",
   "=",
   "True",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "6",
   ":",
   "self",
   ".",
   "printConfidence",
   "(",
   "self",
   ".",
   "cellConfidence",
   "[",
   "'t'",
   "]",
   ")",
   "print",
   "\"----- colConfidence -----\"",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "self",
   ".",
   "colConfidence",
   "[",
   "'t'",
   "]",
   ",",
   "andValues",
   "=",
   "True",
   ")",
   "print",
   "\"----- cellConfidence[t-1] for currently active cells -----\"",
   "cc",
   "=",
   "self",
   ".",
   "cellConfidence",
   "[",
   "'t-1'",
   "]",
   "*",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "cc",
   ",",
   "andValues",
   "=",
   "True",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   "==",
   "4",
   ":",
   "print",
   "\"Cells, predicted segments only:\"",
   "self",
   ".",
   "printCells",
   "(",
   "predictedOnly",
   "=",
   "True",
   ")",
   "elif",
   "self",
   ".",
   "verbosity",
   ">=",
   "5",
   ":",
   "print",
   "\"Cells, all segments:\"",
   "self",
   ".",
   "printCells",
   "(",
   "predictedOnly",
   "=",
   "False",
   ")",
   "print",
   "elif",
   "self",
   ".",
   "verbosity",
   ">=",
   "1",
   ":",
   "print",
   "\"TM: learn:\"",
   ",",
   "learn",
   "print",
   "\"TM: active outputs(%d):\"",
   "%",
   "len",
   "(",
   "output",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ",",
   "self",
   ".",
   "printActiveIndices",
   "(",
   "output",
   ".",
   "reshape",
   "(",
   "self",
   ".",
   "numberOfCols",
   ",",
   "self",
   ".",
   "cellsPerColumn",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-520",
  "nl_tokens": [
   "Calls",
   "Fortran",
   "function",
   "that",
   "reads",
   "attribute",
   "data",
   ".",
   "data_offset",
   "translates",
   "unsigned",
   "into",
   "signed",
   ".",
   "If",
   "number",
   "read",
   "in",
   "is",
   "negative",
   "offset",
   "added",
   "."
  ],
  "pl_tokens": [
   "def",
   "_call_multi_fortran_z_attr",
   "(",
   "self",
   ",",
   "names",
   ",",
   "data_types",
   ",",
   "num_elems",
   ",",
   "entry_nums",
   ",",
   "attr_nums",
   ",",
   "var_names",
   ",",
   "input_type_code",
   ",",
   "func",
   ",",
   "data_offset",
   "=",
   "None",
   ")",
   ":",
   "# isolate input type code variables",
   "idx",
   ",",
   "=",
   "np",
   ".",
   "where",
   "(",
   "data_types",
   "==",
   "input_type_code",
   ")",
   "if",
   "len",
   "(",
   "idx",
   ")",
   ">",
   "0",
   ":",
   "# maximimum array dimension",
   "max_num",
   "=",
   "num_elems",
   "[",
   "idx",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "sub_num_elems",
   "=",
   "num_elems",
   "[",
   "idx",
   "]",
   "sub_names",
   "=",
   "np",
   ".",
   "array",
   "(",
   "names",
   ")",
   "[",
   "idx",
   "]",
   "sub_var_names",
   "=",
   "np",
   ".",
   "array",
   "(",
   "var_names",
   ")",
   "[",
   "idx",
   "]",
   "# zVariable numbers, 'entry' number",
   "sub_entry_nums",
   "=",
   "entry_nums",
   "[",
   "idx",
   "]",
   "# attribute number",
   "sub_attr_nums",
   "=",
   "attr_nums",
   "[",
   "idx",
   "]",
   "status",
   ",",
   "data",
   "=",
   "func",
   "(",
   "self",
   ".",
   "fname",
   ",",
   "sub_attr_nums",
   ",",
   "sub_entry_nums",
   ",",
   "len",
   "(",
   "sub_attr_nums",
   ")",
   ",",
   "max_num",
   ",",
   "len",
   "(",
   "self",
   ".",
   "fname",
   ")",
   ")",
   "if",
   "(",
   "status",
   "==",
   "0",
   ")",
   ".",
   "all",
   "(",
   ")",
   ":",
   "if",
   "data_offset",
   "is",
   "not",
   "None",
   ":",
   "data",
   "=",
   "data",
   ".",
   "astype",
   "(",
   "int",
   ")",
   "idx",
   ",",
   "idy",
   ",",
   "=",
   "np",
   ".",
   "where",
   "(",
   "data",
   "<",
   "0",
   ")",
   "data",
   "[",
   "idx",
   ",",
   "idy",
   "]",
   "+=",
   "data_offset",
   "self",
   ".",
   "_process_return_multi_z_attr",
   "(",
   "data",
   ",",
   "sub_names",
   ",",
   "sub_var_names",
   ",",
   "sub_num_elems",
   ")",
   "else",
   ":",
   "# raise ValueError('CDF Error code :', status)",
   "idx",
   ",",
   "=",
   "np",
   ".",
   "where",
   "(",
   "status",
   "!=",
   "0",
   ")",
   "# raise first error",
   "raise",
   "IOError",
   "(",
   "fortran_cdf",
   ".",
   "statusreporter",
   "(",
   "status",
   "[",
   "idx",
   "]",
   "[",
   "0",
   "]",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-521",
  "nl_tokens": [
   "Transforms",
   "a",
   "vector",
   "np",
   ".",
   "arange",
   "(",
   "-",
   "N",
   "M",
   "dx",
   ")",
   "to",
   "np",
   ".",
   "arange",
   "(",
   "min",
   "(",
   "|vec|",
   ")",
   "max",
   "(",
   "N",
   "M",
   ")",
   "dx",
   ")",
   "]"
  ],
  "pl_tokens": [
   "def",
   "vec_to_halfvec",
   "(",
   "vec",
   ")",
   ":",
   "d",
   "=",
   "vec",
   "[",
   "1",
   ":",
   "]",
   "-",
   "vec",
   "[",
   ":",
   "-",
   "1",
   "]",
   "if",
   "(",
   "(",
   "d",
   "/",
   "d",
   ".",
   "mean",
   "(",
   ")",
   ")",
   ".",
   "std",
   "(",
   ")",
   ">",
   "1e-14",
   ")",
   "or",
   "(",
   "d",
   ".",
   "mean",
   "(",
   ")",
   "<",
   "0",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'vec must be np.arange() in increasing order'",
   ")",
   "dx",
   "=",
   "d",
   ".",
   "mean",
   "(",
   ")",
   "lowest",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "vec",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "highest",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "vec",
   ")",
   ".",
   "max",
   "(",
   ")",
   "return",
   "np",
   ".",
   "arange",
   "(",
   "lowest",
   ",",
   "highest",
   "+",
   "0.1",
   "*",
   "dx",
   ",",
   "dx",
   ")",
   ".",
   "astype",
   "(",
   "vec",
   ".",
   "dtype",
   ")"
  ]
 },
 {
  "idx": "maxmin-522",
  "nl_tokens": [
   "Return",
   "the",
   "normalized",
   "typo",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "metric",
   "=",
   "'euclidean'",
   ",",
   "cost",
   "=",
   "(",
   "1",
   ",",
   "1",
   ",",
   "0.5",
   ",",
   "0.5",
   ")",
   ",",
   "layout",
   "=",
   "'QWERTY'",
   ",",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "ins_cost",
   ",",
   "del_cost",
   "=",
   "cost",
   "[",
   ":",
   "2",
   "]",
   "return",
   "self",
   ".",
   "dist_abs",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "metric",
   ",",
   "cost",
   ",",
   "layout",
   ")",
   "/",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   "*",
   "del_cost",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "*",
   "ins_cost",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-523",
  "nl_tokens": [
   "Return",
   "the",
   "Gotoh",
   "score",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "gap_open",
   "=",
   "1",
   ",",
   "gap_ext",
   "=",
   "0.4",
   ",",
   "sim_func",
   "=",
   "sim_ident",
   ")",
   ":",
   "d_mat",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "np_float32",
   ")",
   "p_mat",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "np_float32",
   ")",
   "q_mat",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "np_float32",
   ")",
   "d_mat",
   "[",
   "0",
   ",",
   "0",
   "]",
   "=",
   "0",
   "p_mat",
   "[",
   "0",
   ",",
   "0",
   "]",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "q_mat",
   "[",
   "0",
   ",",
   "0",
   "]",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ")",
   ":",
   "d_mat",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "p_mat",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "-",
   "gap_open",
   "-",
   "gap_ext",
   "*",
   "(",
   "i",
   "-",
   "1",
   ")",
   "q_mat",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "q_mat",
   "[",
   "i",
   ",",
   "1",
   "]",
   "=",
   "-",
   "gap_open",
   "for",
   "j",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ":",
   "d_mat",
   "[",
   "0",
   ",",
   "j",
   "]",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "p_mat",
   "[",
   "0",
   ",",
   "j",
   "]",
   "=",
   "float",
   "(",
   "'-inf'",
   ")",
   "p_mat",
   "[",
   "1",
   ",",
   "j",
   "]",
   "=",
   "-",
   "gap_open",
   "q_mat",
   "[",
   "0",
   ",",
   "j",
   "]",
   "=",
   "-",
   "gap_open",
   "-",
   "gap_ext",
   "*",
   "(",
   "j",
   "-",
   "1",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ":",
   "sim_val",
   "=",
   "sim_func",
   "(",
   "src",
   "[",
   "i",
   "-",
   "1",
   "]",
   ",",
   "tar",
   "[",
   "j",
   "-",
   "1",
   "]",
   ")",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "<mask>",
   "(",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "sim_val",
   ",",
   "p_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "sim_val",
   ",",
   "q_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "sim_val",
   ",",
   ")",
   "p_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "max",
   "(",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "]",
   "-",
   "gap_open",
   ",",
   "p_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "]",
   "-",
   "gap_ext",
   ")",
   "q_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "max",
   "(",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "-",
   "1",
   "]",
   "-",
   "gap_open",
   ",",
   "q_mat",
   "[",
   "i",
   ",",
   "j",
   "-",
   "1",
   "]",
   "-",
   "gap_ext",
   ")",
   "i",
   ",",
   "j",
   "=",
   "(",
   "n",
   "-",
   "1",
   "for",
   "n",
   "in",
   "d_mat",
   ".",
   "shape",
   ")",
   "return",
   "max",
   "(",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   ",",
   "p_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   ",",
   "q_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-524",
  "nl_tokens": [
   "Convert",
   "this",
   "polygon",
   "to",
   "a",
   "bounding",
   "box",
   "tightly",
   "containing",
   "the",
   "whole",
   "polygon",
   "."
  ],
  "pl_tokens": [
   "def",
   "to_bounding_box",
   "(",
   "self",
   ")",
   ":",
   "# TODO get rid of this deferred import",
   "from",
   "imgaug",
   ".",
   "augmentables",
   ".",
   "bbs",
   "import",
   "BoundingBox",
   "xx",
   "=",
   "self",
   ".",
   "xx",
   "yy",
   "=",
   "self",
   ".",
   "yy",
   "return",
   "BoundingBox",
   "(",
   "x1",
   "=",
   "<mask>",
   "(",
   "xx",
   ")",
   ",",
   "x2",
   "=",
   "max",
   "(",
   "xx",
   ")",
   ",",
   "y1",
   "=",
   "min",
   "(",
   "yy",
   ")",
   ",",
   "y2",
   "=",
   "max",
   "(",
   "yy",
   ")",
   ",",
   "label",
   "=",
   "self",
   ".",
   "label",
   ")"
  ]
 },
 {
  "idx": "maxmin-525",
  "nl_tokens": [
   "Compare",
   "the",
   "data",
   "model",
   "and",
   "residuals",
   "of",
   "a",
   "state",
   "."
  ],
  "pl_tokens": [
   "def",
   "compare_data_model_residuals",
   "(",
   "s",
   ",",
   "tile",
   ",",
   "data_vmin",
   "=",
   "'calc'",
   ",",
   "data_vmax",
   "=",
   "'calc'",
   ",",
   "res_vmin",
   "=",
   "-",
   "0.1",
   ",",
   "res_vmax",
   "=",
   "0.1",
   ",",
   "edgepts",
   "=",
   "'calc'",
   ",",
   "do_imshow",
   "=",
   "True",
   ",",
   "data_cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "bone",
   ",",
   "res_cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "RdBu",
   ")",
   ":",
   "# This could be modified to alpha the borderline... or to embiggen",
   "# the image and slice it more finely",
   "residuals",
   "=",
   "s",
   ".",
   "residuals",
   "[",
   "tile",
   ".",
   "slicer",
   "]",
   ".",
   "squeeze",
   "(",
   ")",
   "data",
   "=",
   "s",
   ".",
   "data",
   "[",
   "tile",
   ".",
   "slicer",
   "]",
   ".",
   "squeeze",
   "(",
   ")",
   "model",
   "=",
   "s",
   ".",
   "model",
   "[",
   "tile",
   ".",
   "slicer",
   "]",
   ".",
   "squeeze",
   "(",
   ")",
   "if",
   "data",
   ".",
   "ndim",
   "!=",
   "2",
   ":",
   "raise",
   "ValueError",
   "(",
   "'tile does not give a 2D slice'",
   ")",
   "im",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "[",
   "data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "4",
   "]",
   ")",
   "if",
   "data_vmin",
   "==",
   "'calc'",
   ":",
   "data_vmin",
   "=",
   "0.5",
   "*",
   "(",
   "data",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "model",
   ".",
   "min",
   "(",
   ")",
   ")",
   "if",
   "data_vmax",
   "==",
   "'calc'",
   ":",
   "data_vmax",
   "=",
   "0.5",
   "*",
   "(",
   "data",
   ".",
   "max",
   "(",
   ")",
   "+",
   "model",
   ".",
   "max",
   "(",
   ")",
   ")",
   "#1. Get masks:",
   "upper_mask",
   ",",
   "center_mask",
   ",",
   "lower_mask",
   "=",
   "trisect_image",
   "(",
   "im",
   ".",
   "shape",
   ",",
   "edgepts",
   ")",
   "#2. Get colorbar'd images",
   "gm",
   "=",
   "data_cmap",
   "(",
   "center_data",
   "(",
   "model",
   ",",
   "data_vmin",
   ",",
   "data_vmax",
   ")",
   ")",
   "dt",
   "=",
   "data_cmap",
   "(",
   "center_data",
   "(",
   "data",
   ",",
   "data_vmin",
   ",",
   "data_vmax",
   ")",
   ")",
   "rs",
   "=",
   "res_cmap",
   "(",
   "center_data",
   "(",
   "residuals",
   ",",
   "res_vmin",
   ",",
   "res_vmax",
   ")",
   ")",
   "for",
   "a",
   "in",
   "range",
   "(",
   "4",
   ")",
   ":",
   "im",
   "[",
   ":",
   ",",
   ":",
   ",",
   "a",
   "]",
   "[",
   "upper_mask",
   "]",
   "=",
   "rs",
   "[",
   ":",
   ",",
   ":",
   ",",
   "a",
   "]",
   "[",
   "upper_mask",
   "]",
   "im",
   "[",
   ":",
   ",",
   ":",
   ",",
   "a",
   "]",
   "[",
   "center_mask",
   "]",
   "=",
   "gm",
   "[",
   ":",
   ",",
   ":",
   ",",
   "a",
   "]",
   "[",
   "center_mask",
   "]",
   "im",
   "[",
   ":",
   ",",
   ":",
   ",",
   "a",
   "]",
   "[",
   "lower_mask",
   "]",
   "=",
   "dt",
   "[",
   ":",
   ",",
   ":",
   ",",
   "a",
   "]",
   "[",
   "lower_mask",
   "]",
   "if",
   "do_imshow",
   ":",
   "return",
   "plt",
   ".",
   "imshow",
   "(",
   "im",
   ")",
   "else",
   ":",
   "return",
   "im"
  ]
 },
 {
  "idx": "maxmin-526",
  "nl_tokens": [
   "Return",
   "Affine",
   "and",
   "shape",
   "of",
   "combined",
   "tiles",
   "."
  ],
  "pl_tokens": [
   "def",
   "tiles_to_affine_shape",
   "(",
   "tiles",
   ")",
   ":",
   "if",
   "not",
   "tiles",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"no tiles provided\"",
   ")",
   "pixel_size",
   "=",
   "tiles",
   "[",
   "0",
   "]",
   ".",
   "pixel_x_size",
   "left",
   ",",
   "bottom",
   ",",
   "right",
   ",",
   "top",
   "=",
   "(",
   "<mask>",
   "(",
   "[",
   "t",
   ".",
   "left",
   "for",
   "t",
   "in",
   "tiles",
   "]",
   ")",
   ",",
   "min",
   "(",
   "[",
   "t",
   ".",
   "bottom",
   "for",
   "t",
   "in",
   "tiles",
   "]",
   ")",
   ",",
   "max",
   "(",
   "[",
   "t",
   ".",
   "right",
   "for",
   "t",
   "in",
   "tiles",
   "]",
   ")",
   ",",
   "max",
   "(",
   "[",
   "t",
   ".",
   "top",
   "for",
   "t",
   "in",
   "tiles",
   "]",
   ")",
   ",",
   ")",
   "return",
   "(",
   "Affine",
   "(",
   "pixel_size",
   ",",
   "0",
   ",",
   "left",
   ",",
   "0",
   ",",
   "-",
   "pixel_size",
   ",",
   "top",
   ")",
   ",",
   "Shape",
   "(",
   "width",
   "=",
   "int",
   "(",
   "round",
   "(",
   "(",
   "right",
   "-",
   "left",
   ")",
   "/",
   "pixel_size",
   ",",
   "0",
   ")",
   ")",
   ",",
   "height",
   "=",
   "int",
   "(",
   "round",
   "(",
   "(",
   "top",
   "-",
   "bottom",
   ")",
   "/",
   "pixel_size",
   ",",
   "0",
   ")",
   ")",
   ",",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-527",
  "nl_tokens": [
   "Return",
   "reasonable",
   "min",
   "/",
   "max",
   "values",
   "to",
   "use",
   "given",
   "the",
   "data",
   "."
  ],
  "pl_tokens": [
   "def",
   "_rangeGen",
   "(",
   "data",
   ",",
   "std",
   "=",
   "1",
   ")",
   ":",
   "dataStd",
   "=",
   "np",
   ".",
   "std",
   "(",
   "data",
   ")",
   "if",
   "dataStd",
   "==",
   "0",
   ":",
   "dataStd",
   "=",
   "1",
   "minval",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "data",
   ")",
   "-",
   "std",
   "*",
   "dataStd",
   "maxval",
   "=",
   "np",
   ".",
   "max",
   "(",
   "data",
   ")",
   "+",
   "std",
   "*",
   "dataStd",
   "return",
   "minval",
   ",",
   "maxval"
  ]
 },
 {
  "idx": "maxmin-528",
  "nl_tokens": [
   "write",
   "the",
   "bisnp",
   "string"
  ],
  "pl_tokens": [
   "def",
   "write_usnps",
   "(",
   "data",
   ",",
   "sidx",
   ",",
   "pnames",
   ")",
   ":",
   "## grab bis data from tmparr",
   "tmparrs",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "data",
   ".",
   "dirs",
   ".",
   "outfiles",
   ",",
   "\"tmp-{}.h5\"",
   ".",
   "format",
   "(",
   "data",
   ".",
   "name",
   ")",
   ")",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "tmparrs",
   ",",
   "'r'",
   ")",
   "as",
   "io5",
   ":",
   "bisarr",
   "=",
   "io5",
   "[",
   "\"bisarr\"",
   "]",
   "## trim to size b/c it was made longer than actual",
   "end",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "all",
   "(",
   "bisarr",
   "[",
   ":",
   "]",
   "==",
   "\"\"",
   ",",
   "axis",
   "=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "np",
   ".",
   "any",
   "(",
   "end",
   ")",
   ":",
   "end",
   "=",
   "end",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "end",
   "=",
   "bisarr",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "## write to usnps file",
   "with",
   "open",
   "(",
   "data",
   ".",
   "outfiles",
   ".",
   "usnpsphy",
   ",",
   "'w'",
   ")",
   "as",
   "out",
   ":",
   "out",
   ".",
   "write",
   "(",
   "\"{} {}\\n\"",
   ".",
   "format",
   "(",
   "bisarr",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "end",
   ")",
   ")",
   "for",
   "idx",
   ",",
   "name",
   "in",
   "enumerate",
   "(",
   "pnames",
   ")",
   ":",
   "out",
   ".",
   "write",
   "(",
   "\"{}{}\\n\"",
   ".",
   "format",
   "(",
   "name",
   ",",
   "\"\"",
   ".",
   "join",
   "(",
   "bisarr",
   "[",
   "idx",
   ",",
   ":",
   "end",
   "]",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-529",
  "nl_tokens": [
   "http",
   ":",
   "//",
   "stackoverflow",
   ".",
   "com",
   "/",
   "questions",
   "/",
   "5098580",
   "/",
   "implementing",
   "-",
   "argmax",
   "-",
   "in",
   "-",
   "python"
  ],
  "pl_tokens": [
   "def",
   "argmax",
   "(",
   "l",
   ",",
   "f",
   "=",
   "None",
   ")",
   ":",
   "if",
   "f",
   ":",
   "l",
   "=",
   "[",
   "f",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "l",
   "]",
   "return",
   "<mask>",
   "(",
   "enumerate",
   "(",
   "l",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "1",
   "]",
   ")",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-530",
  "nl_tokens": [
   "t",
   "-",
   "SNE",
   "embedding",
   "of",
   "the",
   "parameters",
   "colored",
   "by",
   "score"
  ],
  "pl_tokens": [
   "def",
   "plot_3",
   "(",
   "data",
   ",",
   "ss",
   ",",
   "*",
   "args",
   ")",
   ":",
   "if",
   "len",
   "(",
   "data",
   ")",
   "<=",
   "1",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"Only one datapoint. Could not compute t-SNE embedding.\"",
   ")",
   "return",
   "None",
   "scores",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "d",
   "[",
   "'mean_test_score'",
   "]",
   "for",
   "d",
   "in",
   "data",
   "]",
   ")",
   "# maps each parameters to a vector of floats",
   "warped",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "ss",
   ".",
   "point_to_unit",
   "(",
   "d",
   "[",
   "'parameters'",
   "]",
   ")",
   "for",
   "d",
   "in",
   "data",
   "]",
   ")",
   "# Embed into 2 dimensions with t-SNE",
   "X",
   "=",
   "TSNE",
   "(",
   "n_components",
   "=",
   "2",
   ")",
   ".",
   "fit_transform",
   "(",
   "warped",
   ")",
   "e_scores",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "scores",
   ")",
   "mine",
   ",",
   "maxe",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "e_scores",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "e_scores",
   ")",
   "color",
   "=",
   "(",
   "e_scores",
   "-",
   "mine",
   ")",
   "/",
   "(",
   "maxe",
   "-",
   "mine",
   ")",
   "mapped_colors",
   "=",
   "list",
   "(",
   "map",
   "(",
   "rgb2hex",
   ",",
   "cm",
   ".",
   "get_cmap",
   "(",
   "'RdBu_r'",
   ")",
   "(",
   "color",
   ")",
   ")",
   ")",
   "p",
   "=",
   "bk",
   ".",
   "figure",
   "(",
   "title",
   "=",
   "'t-SNE (unsupervised)'",
   ",",
   "tools",
   "=",
   "TOOLS",
   ")",
   "df_params",
   "=",
   "nonconstant_parameters",
   "(",
   "data",
   ")",
   "df_params",
   "[",
   "'score'",
   "]",
   "=",
   "scores",
   "df_params",
   "[",
   "'x'",
   "]",
   "=",
   "X",
   "[",
   ":",
   ",",
   "0",
   "]",
   "df_params",
   "[",
   "'y'",
   "]",
   "=",
   "X",
   "[",
   ":",
   ",",
   "1",
   "]",
   "df_params",
   "[",
   "'color'",
   "]",
   "=",
   "mapped_colors",
   "df_params",
   "[",
   "'radius'",
   "]",
   "=",
   "1",
   "p",
   ".",
   "circle",
   "(",
   "x",
   "=",
   "'x'",
   ",",
   "y",
   "=",
   "'y'",
   ",",
   "color",
   "=",
   "'color'",
   ",",
   "radius",
   "=",
   "'radius'",
   ",",
   "source",
   "=",
   "ColumnDataSource",
   "(",
   "data",
   "=",
   "df_params",
   ")",
   ",",
   "fill_alpha",
   "=",
   "0.6",
   ",",
   "line_color",
   "=",
   "None",
   ")",
   "cp",
   "=",
   "p",
   "hover",
   "=",
   "cp",
   ".",
   "select",
   "(",
   "dict",
   "(",
   "type",
   "=",
   "HoverTool",
   ")",
   ")",
   "format_tt",
   "=",
   "[",
   "(",
   "s",
   ",",
   "'@%s'",
   "%",
   "s",
   ")",
   "for",
   "s",
   "in",
   "df_params",
   ".",
   "columns",
   "]",
   "hover",
   ".",
   "tooltips",
   "=",
   "OrderedDict",
   "(",
   "[",
   "(",
   "\"index\"",
   ",",
   "\"$index\"",
   ")",
   "]",
   "+",
   "format_tt",
   ")",
   "xax",
   ",",
   "yax",
   "=",
   "p",
   ".",
   "axis",
   "xax",
   ".",
   "axis_label",
   "=",
   "'t-SNE coord 1'",
   "yax",
   ".",
   "axis_label",
   "=",
   "'t-SNE coord 2'",
   "return",
   "p"
  ]
 },
 {
  "idx": "maxmin-531",
  "nl_tokens": [
   "Compute",
   "the",
   "maximum",
   "temporal",
   "distance",
   "."
  ],
  "pl_tokens": [
   "def",
   "largest_finite_distance",
   "(",
   "self",
   ")",
   ":",
   "block_start_distances",
   "=",
   "[",
   "block",
   ".",
   "distance_start",
   "for",
   "block",
   "in",
   "self",
   ".",
   "_profile_blocks",
   "if",
   "block",
   ".",
   "distance_start",
   "<",
   "float",
   "(",
   "'inf'",
   ")",
   "]",
   "block_end_distances",
   "=",
   "[",
   "block",
   ".",
   "distance_end",
   "for",
   "block",
   "in",
   "self",
   ".",
   "_profile_blocks",
   "if",
   "block",
   ".",
   "distance_end",
   "<",
   "float",
   "(",
   "'inf'",
   ")",
   "]",
   "distances",
   "=",
   "block_start_distances",
   "+",
   "block_end_distances",
   "if",
   "len",
   "(",
   "distances",
   ")",
   ">",
   "0",
   ":",
   "return",
   "<mask>",
   "(",
   "distances",
   ")",
   "else",
   ":",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-532",
  "nl_tokens": [
   "z",
   "as",
   "seeds",
   "scale\uc774",
   "\uc791\uc744",
   "\uc218\ub85d",
   "\ud328\ud134\uc774",
   "\ucee4\uc9c0\ub294",
   "\ud6a8\uacfc"
  ],
  "pl_tokens": [
   "def",
   "snoise2dz",
   "(",
   "size",
   ",",
   "z",
   ",",
   "scale",
   "=",
   "0.05",
   ",",
   "octaves",
   "=",
   "1",
   ",",
   "persistence",
   "=",
   "0.25",
   ",",
   "lacunarity",
   "=",
   "2.0",
   ")",
   ":",
   "import",
   "noise",
   "z_l",
   "=",
   "len",
   "(",
   "z",
   ")",
   "data",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "(",
   "z_l",
   ",",
   "size",
   "[",
   "0",
   "]",
   ",",
   "size",
   "[",
   "1",
   "]",
   ")",
   ",",
   "dtype",
   "=",
   "'float32'",
   ")",
   "for",
   "iz",
   "in",
   "range",
   "(",
   "z_l",
   ")",
   ":",
   "zvalue",
   "=",
   "z",
   "[",
   "iz",
   "]",
   "for",
   "y",
   "in",
   "range",
   "(",
   "size",
   "[",
   "0",
   "]",
   ")",
   ":",
   "for",
   "x",
   "in",
   "range",
   "(",
   "size",
   "[",
   "1",
   "]",
   ")",
   ":",
   "v",
   "=",
   "noise",
   ".",
   "snoise3",
   "(",
   "x",
   "*",
   "scale",
   ",",
   "y",
   "*",
   "scale",
   ",",
   "zvalue",
   ",",
   "octaves",
   "=",
   "octaves",
   ",",
   "persistence",
   "=",
   "persistence",
   ",",
   "lacunarity",
   "=",
   "lacunarity",
   ")",
   "data",
   "[",
   "iz",
   ",",
   "y",
   ",",
   "x",
   "]",
   "=",
   "v",
   "data",
   "=",
   "data",
   "*",
   "0.5",
   "+",
   "0.5",
   "if",
   "__debug__",
   ":",
   "assert",
   "data",
   ".",
   "<mask>",
   "(",
   ")",
   ">=",
   "0.",
   "and",
   "data",
   ".",
   "max",
   "(",
   ")",
   "<=",
   "1.0",
   "return",
   "data"
  ]
 },
 {
  "idx": "maxmin-533",
  "nl_tokens": [
   "Interacts",
   "with",
   "the",
   "graph",
   "by",
   "clicking",
   "or",
   "dragging",
   "nodes",
   ".",
   "Hovering",
   "a",
   "node",
   "fires",
   "the",
   "callback",
   "function",
   "events",
   ".",
   "hover",
   "()",
   ".",
   "Clicking",
   "a",
   "node",
   "fires",
   "the",
   "callback",
   "function",
   "events",
   ".",
   "click",
   "()",
   "."
  ],
  "pl_tokens": [
   "def",
   "update",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "mousedown",
   ":",
   "# When not pressing or dragging, check each node.",
   "if",
   "not",
   "self",
   ".",
   "pressed",
   "and",
   "not",
   "self",
   ".",
   "dragged",
   ":",
   "for",
   "n",
   "in",
   "self",
   ".",
   "graph",
   ".",
   "nodes",
   ":",
   "if",
   "self",
   ".",
   "mouse",
   "in",
   "n",
   ":",
   "self",
   ".",
   "pressed",
   "=",
   "n",
   "break",
   "# If a node is pressed, check if a drag is started.",
   "elif",
   "self",
   ".",
   "pressed",
   "and",
   "not",
   "self",
   ".",
   "mouse",
   "in",
   "self",
   ".",
   "pressed",
   ":",
   "self",
   ".",
   "dragged",
   "=",
   "self",
   ".",
   "pressed",
   "self",
   ".",
   "pressed",
   "=",
   "None",
   "# Drag the node (right now only for springgraphs).",
   "elif",
   "self",
   ".",
   "dragged",
   "and",
   "self",
   ".",
   "graph",
   ".",
   "layout",
   ".",
   "type",
   "==",
   "\"spring\"",
   ":",
   "self",
   ".",
   "drag",
   "(",
   "self",
   ".",
   "dragged",
   ")",
   "self",
   ".",
   "graph",
   ".",
   "layout",
   ".",
   "i",
   "=",
   "<mask>",
   "(",
   "100",
   ",",
   "max",
   "(",
   "2",
   ",",
   "self",
   ".",
   "graph",
   ".",
   "layout",
   ".",
   "n",
   "-",
   "100",
   ")",
   ")",
   "# Mouse is clicked on a node, fire callback.",
   "elif",
   "self",
   ".",
   "pressed",
   "and",
   "self",
   ".",
   "mouse",
   "in",
   "self",
   ".",
   "pressed",
   ":",
   "self",
   ".",
   "clicked",
   "=",
   "self",
   ".",
   "pressed",
   "self",
   ".",
   "pressed",
   "=",
   "None",
   "self",
   ".",
   "graph",
   ".",
   "layout",
   ".",
   "i",
   "=",
   "2",
   "self",
   ".",
   "click",
   "(",
   "self",
   ".",
   "clicked",
   ")",
   "# Mouse up.",
   "else",
   ":",
   "self",
   ".",
   "hovered",
   "=",
   "None",
   "self",
   ".",
   "pressed",
   "=",
   "None",
   "self",
   ".",
   "dragged",
   "=",
   "None",
   "# Hovering over a node?",
   "for",
   "n",
   "in",
   "self",
   ".",
   "graph",
   ".",
   "nodes",
   ":",
   "if",
   "self",
   ".",
   "mouse",
   "in",
   "n",
   ":",
   "self",
   ".",
   "hovered",
   "=",
   "n",
   "self",
   ".",
   "hover",
   "(",
   "n",
   ")",
   "break"
  ]
 },
 {
  "idx": "maxmin-534",
  "nl_tokens": [
   "Parses",
   "a",
   "block",
   "of",
   "text",
   "indiscriminately"
  ],
  "pl_tokens": [
   "def",
   "parse_data",
   "(",
   "self",
   ",",
   "text",
   ",",
   "maxwidth",
   ",",
   "maxheight",
   ",",
   "template_dir",
   ",",
   "context",
   ",",
   "urlize_all_links",
   ")",
   ":",
   "# create a dictionary of user urls -> rendered responses",
   "replacements",
   "=",
   "{",
   "}",
   "user_urls",
   "=",
   "set",
   "(",
   "re",
   ".",
   "findall",
   "(",
   "URL_RE",
   ",",
   "text",
   ")",
   ")",
   "for",
   "user_url",
   "in",
   "user_urls",
   ":",
   "try",
   ":",
   "resource",
   "=",
   "oembed",
   ".",
   "site",
   ".",
   "embed",
   "(",
   "user_url",
   ",",
   "maxwidth",
   "=",
   "maxwidth",
   ",",
   "maxheight",
   "=",
   "maxheight",
   ")",
   "except",
   "OEmbedException",
   ":",
   "if",
   "urlize_all_links",
   ":",
   "replacements",
   "[",
   "user_url",
   "]",
   "=",
   "'<a href=\"%(LINK)s\">%(LINK)s</a>'",
   "%",
   "{",
   "'LINK'",
   ":",
   "user_url",
   "}",
   "else",
   ":",
   "context",
   "[",
   "'minwidth'",
   "]",
   "=",
   "<mask>",
   "(",
   "maxwidth",
   ",",
   "resource",
   ".",
   "width",
   ")",
   "context",
   "[",
   "'minheight'",
   "]",
   "=",
   "min",
   "(",
   "maxheight",
   ",",
   "resource",
   ".",
   "height",
   ")",
   "replacement",
   "=",
   "self",
   ".",
   "render_oembed",
   "(",
   "resource",
   ",",
   "user_url",
   ",",
   "template_dir",
   "=",
   "template_dir",
   ",",
   "context",
   "=",
   "context",
   ")",
   "replacements",
   "[",
   "user_url",
   "]",
   "=",
   "replacement",
   ".",
   "strip",
   "(",
   ")",
   "# go through the text recording URLs that can be replaced",
   "# taking note of their start & end indexes",
   "user_urls",
   "=",
   "re",
   ".",
   "finditer",
   "(",
   "URL_RE",
   ",",
   "text",
   ")",
   "matches",
   "=",
   "[",
   "]",
   "for",
   "match",
   "in",
   "user_urls",
   ":",
   "if",
   "match",
   ".",
   "group",
   "(",
   ")",
   "in",
   "replacements",
   ":",
   "matches",
   ".",
   "append",
   "(",
   "[",
   "match",
   ".",
   "start",
   "(",
   ")",
   ",",
   "match",
   ".",
   "end",
   "(",
   ")",
   ",",
   "match",
   ".",
   "group",
   "(",
   ")",
   "]",
   ")",
   "# replace the URLs in order, offsetting the indices each go",
   "for",
   "indx",
   ",",
   "(",
   "start",
   ",",
   "end",
   ",",
   "user_url",
   ")",
   "in",
   "enumerate",
   "(",
   "matches",
   ")",
   ":",
   "replacement",
   "=",
   "replacements",
   "[",
   "user_url",
   "]",
   "difference",
   "=",
   "len",
   "(",
   "replacement",
   ")",
   "-",
   "len",
   "(",
   "user_url",
   ")",
   "# insert the replacement between two slices of text surrounding the",
   "# original url",
   "text",
   "=",
   "text",
   "[",
   ":",
   "start",
   "]",
   "+",
   "replacement",
   "+",
   "text",
   "[",
   "end",
   ":",
   "]",
   "# iterate through the rest of the matches offsetting their indices",
   "# based on the difference between replacement/original",
   "for",
   "j",
   "in",
   "xrange",
   "(",
   "indx",
   "+",
   "1",
   ",",
   "len",
   "(",
   "matches",
   ")",
   ")",
   ":",
   "matches",
   "[",
   "j",
   "]",
   "[",
   "0",
   "]",
   "+=",
   "difference",
   "matches",
   "[",
   "j",
   "]",
   "[",
   "1",
   "]",
   "+=",
   "difference",
   "return",
   "mark_safe",
   "(",
   "text",
   ")"
  ]
 },
 {
  "idx": "maxmin-535",
  "nl_tokens": [
   "Normalised",
   "data",
   "points",
   "using",
   "pure",
   "Python",
   "."
  ],
  "pl_tokens": [
   "def",
   "_normalised_python",
   "(",
   "self",
   ")",
   ":",
   "dx",
   "=",
   "(",
   "self",
   ".",
   "screen",
   ".",
   "width",
   "/",
   "float",
   "(",
   "len",
   "(",
   "self",
   ".",
   "points",
   ")",
   ")",
   ")",
   "oy",
   "=",
   "(",
   "self",
   ".",
   "screen",
   ".",
   "height",
   ")",
   "for",
   "x",
   ",",
   "point",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "points",
   ")",
   ":",
   "y",
   "=",
   "(",
   "point",
   "-",
   "self",
   ".",
   "minimum",
   ")",
   "*",
   "4.0",
   "/",
   "self",
   ".",
   "extents",
   "*",
   "self",
   ".",
   "size",
   ".",
   "y",
   "yield",
   "Point",
   "(",
   "(",
   "dx",
   "*",
   "x",
   ",",
   "<mask>",
   "(",
   "oy",
   ",",
   "oy",
   "-",
   "y",
   ")",
   ",",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-536",
  "nl_tokens": [
   "Inserts",
   "a",
   "new",
   "element",
   "as",
   "a",
   "child",
   "of",
   "this",
   "element",
   "before",
   "the",
   "specified",
   "index",
   "or",
   "sibling",
   "."
  ],
  "pl_tokens": [
   "def",
   "insert",
   "(",
   "self",
   ",",
   "before",
   ",",
   "name",
   ",",
   "attrs",
   "=",
   "None",
   ",",
   "data",
   "=",
   "None",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "before",
   ",",
   "self",
   ".",
   "__class__",
   ")",
   ":",
   "if",
   "before",
   ".",
   "parent",
   "!=",
   "self",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Cannot insert before an element with a different parent.'",
   ")",
   "before",
   "=",
   "before",
   ".",
   "index",
   "# Make sure 0 <= before <= len(_children).",
   "before",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "0",
   ",",
   "before",
   ")",
   ",",
   "len",
   "(",
   "self",
   ".",
   "_children",
   ")",
   ")",
   "elem",
   "=",
   "self",
   ".",
   "__class__",
   "(",
   "name",
   ",",
   "attrs",
   ",",
   "data",
   ",",
   "parent",
   "=",
   "self",
   ",",
   "index",
   "=",
   "before",
   ")",
   "self",
   ".",
   "_children",
   ".",
   "insert",
   "(",
   "before",
   ",",
   "elem",
   ")",
   "# Re-index all the children.",
   "for",
   "idx",
   ",",
   "c",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "_children",
   ")",
   ":",
   "c",
   ".",
   "index",
   "=",
   "idx",
   "return",
   "elem"
  ]
 },
 {
  "idx": "maxmin-537",
  "nl_tokens": [
   "Return",
   "Snowball",
   "Dutch",
   "stem",
   "."
  ],
  "pl_tokens": [
   "def",
   "stem",
   "(",
   "self",
   ",",
   "word",
   ")",
   ":",
   "# lowercase, normalize, decompose, filter umlauts & acutes out, and",
   "# compose",
   "word",
   "=",
   "normalize",
   "(",
   "'NFC'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "lower",
   "(",
   ")",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "translate",
   "(",
   "self",
   ".",
   "_accented",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "if",
   "i",
   "==",
   "0",
   "and",
   "word",
   "[",
   "0",
   "]",
   "==",
   "'y'",
   ":",
   "word",
   "=",
   "'Y'",
   "+",
   "word",
   "[",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'y'",
   "and",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_vowels",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'Y'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "(",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'i'",
   "and",
   "word",
   "[",
   "i",
   "-",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "i",
   "+",
   "1",
   "<",
   "len",
   "(",
   "word",
   ")",
   "and",
   "word",
   "[",
   "i",
   "+",
   "1",
   "]",
   "in",
   "self",
   ".",
   "_vowels",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'I'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "r1_start",
   "=",
   "<mask>",
   "(",
   "3",
   ",",
   "self",
   ".",
   "_sb_r1",
   "(",
   "word",
   ")",
   ")",
   "r2_start",
   "=",
   "self",
   ".",
   "_sb_r2",
   "(",
   "word",
   ")",
   "# Step 1",
   "if",
   "word",
   "[",
   "-",
   "5",
   ":",
   "]",
   "==",
   "'heden'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "5",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "+",
   "'id'",
   "elif",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "==",
   "'ene'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "3",
   "and",
   "(",
   "word",
   "[",
   "-",
   "4",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "word",
   "[",
   "-",
   "6",
   ":",
   "-",
   "3",
   "]",
   "!=",
   "'gem'",
   ")",
   ":",
   "word",
   "=",
   "self",
   ".",
   "_undouble",
   "(",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   ")",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'en'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "(",
   "word",
   "[",
   "-",
   "3",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "word",
   "[",
   "-",
   "5",
   ":",
   "-",
   "2",
   "]",
   "!=",
   "'gem'",
   ")",
   ":",
   "word",
   "=",
   "self",
   ".",
   "_undouble",
   "(",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   ")",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'se'",
   ":",
   "if",
   "(",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_not_s_endings",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'s'",
   ":",
   "if",
   "(",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "1",
   "and",
   "word",
   "[",
   "-",
   "2",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_not_s_endings",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# Step 2",
   "e_removed",
   "=",
   "False",
   "if",
   "word",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'e'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "1",
   "and",
   "word",
   "[",
   "-",
   "2",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   ":",
   "word",
   "=",
   "self",
   ".",
   "_undouble",
   "(",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   "e_removed",
   "=",
   "True",
   "# Step 3a",
   "if",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'heid'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   "and",
   "word",
   "[",
   "-",
   "5",
   "]",
   "!=",
   "'c'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "if",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'en'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "(",
   "word",
   "[",
   "-",
   "3",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "word",
   "[",
   "-",
   "5",
   ":",
   "-",
   "2",
   "]",
   "!=",
   "'gem'",
   ")",
   ":",
   "word",
   "=",
   "self",
   ".",
   "_undouble",
   "(",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   ")",
   "# Step 3b",
   "if",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'lijk'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "# Repeat step 2",
   "if",
   "word",
   "[",
   "-",
   "1",
   ":",
   "]",
   "==",
   "'e'",
   ":",
   "if",
   "(",
   "len",
   "(",
   "word",
   "[",
   "r1_start",
   ":",
   "]",
   ")",
   ">=",
   "1",
   "and",
   "word",
   "[",
   "-",
   "2",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   ")",
   ":",
   "word",
   "=",
   "self",
   ".",
   "_undouble",
   "(",
   "word",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   "elif",
   "word",
   "[",
   "-",
   "4",
   ":",
   "]",
   "==",
   "'baar'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "4",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "4",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "in",
   "(",
   "'end'",
   ",",
   "'ing'",
   ")",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "3",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "if",
   "(",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'ig'",
   "and",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "!=",
   "'e'",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "else",
   ":",
   "word",
   "=",
   "self",
   ".",
   "_undouble",
   "(",
   "word",
   ")",
   "elif",
   "word",
   "[",
   "-",
   "3",
   ":",
   "]",
   "==",
   "'bar'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "3",
   "and",
   "e_removed",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "3",
   "]",
   "elif",
   "word",
   "[",
   "-",
   "2",
   ":",
   "]",
   "==",
   "'ig'",
   ":",
   "if",
   "len",
   "(",
   "word",
   "[",
   "r2_start",
   ":",
   "]",
   ")",
   ">=",
   "2",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "!=",
   "'e'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "# Step 4",
   "if",
   "(",
   "len",
   "(",
   "word",
   ")",
   ">=",
   "4",
   "and",
   "word",
   "[",
   "-",
   "3",
   "]",
   "==",
   "word",
   "[",
   "-",
   "2",
   "]",
   "and",
   "word",
   "[",
   "-",
   "2",
   "]",
   "in",
   "{",
   "'a'",
   ",",
   "'e'",
   ",",
   "'o'",
   ",",
   "'u'",
   "}",
   "and",
   "word",
   "[",
   "-",
   "4",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "word",
   "[",
   "-",
   "1",
   "]",
   "not",
   "in",
   "self",
   ".",
   "_vowels",
   "and",
   "word",
   "[",
   "-",
   "1",
   "]",
   "!=",
   "'I'",
   ")",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "-",
   "2",
   "]",
   "+",
   "word",
   "[",
   "-",
   "1",
   "]",
   "# Change 'Y' and 'U' back to lowercase if survived stemming",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "if",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'Y'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'y'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "elif",
   "word",
   "[",
   "i",
   "]",
   "==",
   "'I'",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   "i",
   "]",
   "+",
   "'i'",
   "+",
   "word",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "return",
   "word"
  ]
 },
 {
  "idx": "maxmin-538",
  "nl_tokens": [
   "Get",
   "the",
   "earliest",
   "visit",
   "time",
   "of",
   "the",
   "stop",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_min_visit_time",
   "(",
   "self",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "visit_events",
   ":",
   "return",
   "float",
   "(",
   "'inf'",
   ")",
   "else",
   ":",
   "return",
   "<mask>",
   "(",
   "self",
   ".",
   "visit_events",
   ",",
   "key",
   "=",
   "lambda",
   "event",
   ":",
   "event",
   ".",
   "arr_time_ut",
   ")",
   ".",
   "arr_time_ut"
  ]
 },
 {
  "idx": "maxmin-539",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "initialize",
   "the",
   "object",
   "by",
   "precomputing",
   "any",
   "values",
   "which",
   "may",
   "be",
   "used",
   "repeatedly",
   "and",
   "by",
   "retrieving",
   "mixture",
   "-",
   "specific",
   "variables",
   ".",
   "All",
   "data",
   "are",
   "stored",
   "as",
   "attributes",
   ".",
   "This",
   "method",
   "also",
   "sets",
   ":",
   "obj",
   ":",
   "Tmin",
   ":",
   "obj",
   ":",
   "Tmax",
   "and",
   ":",
   "obj",
   ":",
   "all_methods",
   "as",
   "a",
   "set",
   "of",
   "methods",
   "which",
   "should",
   "work",
   "to",
   "calculate",
   "the",
   "property",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "SIMPLE",
   "]",
   "if",
   "none_and_length_check",
   "(",
   "(",
   "self",
   ".",
   "MWs",
   ",",
   "self",
   ".",
   "molecular_diameters",
   ",",
   "self",
   ".",
   "Stockmayers",
   ")",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "BROKAW",
   ")",
   "if",
   "none_and_length_check",
   "(",
   "[",
   "self",
   ".",
   "MWs",
   "]",
   ")",
   ":",
   "methods",
   ".",
   "extend",
   "(",
   "[",
   "WILKE",
   ",",
   "HERNING_ZIPPERER",
   "]",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "Tmins",
   "=",
   "[",
   "i",
   ".",
   "Tmin",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ViscosityGases",
   "if",
   "i",
   ".",
   "Tmin",
   "]",
   "Tmaxs",
   "=",
   "[",
   "i",
   ".",
   "Tmax",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ViscosityGases",
   "if",
   "i",
   ".",
   "Tmax",
   "]",
   "if",
   "Tmins",
   ":",
   "self",
   ".",
   "Tmin",
   "=",
   "<mask>",
   "(",
   "Tmins",
   ")",
   "if",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmax",
   "=",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-540",
  "nl_tokens": [
   "Choose",
   "n",
   "random",
   "cells",
   "to",
   "learn",
   "from",
   "."
  ],
  "pl_tokens": [
   "def",
   "_chooseCellsToLearnFrom",
   "(",
   "self",
   ",",
   "c",
   ",",
   "i",
   ",",
   "s",
   ",",
   "n",
   ",",
   "activeState",
   ")",
   ":",
   "if",
   "n",
   "<=",
   "0",
   ":",
   "return",
   "[",
   "]",
   "tmpCandidates",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "activeState",
   "==",
   "1",
   ")",
   "# Candidates can be empty at this point, in which case we return",
   "# an empty segment list. adaptSegments will do nothing when getting",
   "# that list.",
   "if",
   "len",
   "(",
   "tmpCandidates",
   "[",
   "0",
   "]",
   ")",
   "==",
   "0",
   ":",
   "return",
   "[",
   "]",
   "if",
   "s",
   "is",
   "None",
   ":",
   "# new segment",
   "cands",
   "=",
   "[",
   "syn",
   "for",
   "syn",
   "in",
   "zip",
   "(",
   "tmpCandidates",
   "[",
   "0",
   "]",
   ",",
   "tmpCandidates",
   "[",
   "1",
   "]",
   ")",
   "]",
   "else",
   ":",
   "# We exclude any synapse that is already in this segment.",
   "synapsesAlreadyInSegment",
   "=",
   "set",
   "(",
   "(",
   "syn",
   "[",
   "0",
   "]",
   ",",
   "syn",
   "[",
   "1",
   "]",
   ")",
   "for",
   "syn",
   "in",
   "s",
   ".",
   "syns",
   ")",
   "cands",
   "=",
   "[",
   "syn",
   "for",
   "syn",
   "in",
   "zip",
   "(",
   "tmpCandidates",
   "[",
   "0",
   "]",
   ",",
   "tmpCandidates",
   "[",
   "1",
   "]",
   ")",
   "if",
   "(",
   "syn",
   "[",
   "0",
   "]",
   ",",
   "syn",
   "[",
   "1",
   "]",
   ")",
   "not",
   "in",
   "synapsesAlreadyInSegment",
   "]",
   "# If we have no more candidates than requested, return all of them,",
   "# no shuffle necessary.",
   "if",
   "len",
   "(",
   "cands",
   ")",
   "<=",
   "n",
   ":",
   "return",
   "cands",
   "if",
   "n",
   "==",
   "1",
   ":",
   "# so that we don't shuffle if only one is needed",
   "idx",
   "=",
   "self",
   ".",
   "_random",
   ".",
   "getUInt32",
   "(",
   "len",
   "(",
   "cands",
   ")",
   ")",
   "return",
   "[",
   "cands",
   "[",
   "idx",
   "]",
   "]",
   "# col and cell idx in col",
   "# If we need more than one candidate",
   "indices",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "j",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "cands",
   ")",
   ")",
   "]",
   ",",
   "dtype",
   "=",
   "'uint32'",
   ")",
   "tmp",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "<mask>",
   "(",
   "n",
   ",",
   "len",
   "(",
   "indices",
   ")",
   ")",
   ",",
   "dtype",
   "=",
   "'uint32'",
   ")",
   "self",
   ".",
   "_random",
   ".",
   "sample",
   "(",
   "indices",
   ",",
   "tmp",
   ")",
   "return",
   "sorted",
   "(",
   "[",
   "cands",
   "[",
   "j",
   "]",
   "for",
   "j",
   "in",
   "tmp",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-541",
  "nl_tokens": [
   "See",
   "comments",
   "in",
   "base",
   "class",
   "."
  ],
  "pl_tokens": [
   "def",
   "pushAwayFrom",
   "(",
   "self",
   ",",
   "otherPositions",
   ",",
   "rng",
   ")",
   ":",
   "# If min and max are the same, nothing to do",
   "if",
   "self",
   ".",
   "<mask>",
   "==",
   "self",
   ".",
   "min",
   ":",
   "return",
   "# How many potential other positions to evaluate?",
   "numPositions",
   "=",
   "len",
   "(",
   "otherPositions",
   ")",
   "*",
   "4",
   "if",
   "numPositions",
   "==",
   "0",
   ":",
   "return",
   "# Assign a weight to each potential position based on how close it is",
   "# to other particles.",
   "stepSize",
   "=",
   "float",
   "(",
   "self",
   ".",
   "max",
   "-",
   "self",
   ".",
   "min",
   ")",
   "/",
   "numPositions",
   "positions",
   "=",
   "numpy",
   ".",
   "arange",
   "(",
   "self",
   ".",
   "min",
   ",",
   "self",
   ".",
   "max",
   "+",
   "stepSize",
   ",",
   "stepSize",
   ")",
   "# Get rid of duplicates.",
   "numPositions",
   "=",
   "len",
   "(",
   "positions",
   ")",
   "weights",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "numPositions",
   ")",
   "# Assign a weight to each potential position, based on a gaussian falloff",
   "# from each existing variable. The weight of a variable to each potential",
   "# position is given as:",
   "#    e ^ -(dist^2/stepSize^2)",
   "maxDistanceSq",
   "=",
   "-",
   "1",
   "*",
   "(",
   "stepSize",
   "**",
   "2",
   ")",
   "for",
   "pos",
   "in",
   "otherPositions",
   ":",
   "distances",
   "=",
   "pos",
   "-",
   "positions",
   "varWeights",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "numpy",
   ".",
   "power",
   "(",
   "distances",
   ",",
   "2",
   ")",
   "/",
   "maxDistanceSq",
   ")",
   "weights",
   "+=",
   "varWeights",
   "# Put this particle at the position with smallest weight.",
   "positionIdx",
   "=",
   "weights",
   ".",
   "argmin",
   "(",
   ")",
   "self",
   ".",
   "_position",
   "=",
   "positions",
   "[",
   "positionIdx",
   "]",
   "# Set its best position to this.",
   "self",
   ".",
   "_bestPosition",
   "=",
   "self",
   ".",
   "getPosition",
   "(",
   ")",
   "# Give it a random direction.",
   "self",
   ".",
   "_velocity",
   "*=",
   "rng",
   ".",
   "choice",
   "(",
   "[",
   "1",
   ",",
   "-",
   "1",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-542",
  "nl_tokens": [
   "Submits",
   "the",
   "command",
   "onto",
   "an",
   "Local",
   "Resource",
   "Manager",
   "job",
   "of",
   "blocksize",
   "parallel",
   "elements",
   "."
  ],
  "pl_tokens": [
   "def",
   "submit",
   "(",
   "self",
   ",",
   "command",
   ",",
   "blocksize",
   ",",
   "tasks_per_node",
   ",",
   "job_name",
   "=",
   "\"parsl.auto\"",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"Attempting to launch with blocksize: {}\"",
   ".",
   "format",
   "(",
   "blocksize",
   ")",
   ")",
   "if",
   "self",
   ".",
   "provisioned_blocks",
   ">=",
   "self",
   ".",
   "max_blocks",
   ":",
   "template",
   "=",
   "\"Provider {} is currently using {} blocks while max_blocks is {}; no blocks will be added\"",
   "logger",
   ".",
   "warn",
   "(",
   "template",
   ".",
   "format",
   "(",
   "self",
   ".",
   "label",
   ",",
   "self",
   ".",
   "provisioned_blocks",
   ",",
   "self",
   ".",
   "max_blocks",
   ")",
   ")",
   "return",
   "None",
   "# Note: Fix this later to avoid confusing behavior.",
   "# We should always allocate blocks in integer counts of node_granularity",
   "blocksize",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "nodes_per_block",
   ",",
   "blocksize",
   ")",
   "job_name",
   "=",
   "\"parsl.{0}.{1}\"",
   ".",
   "format",
   "(",
   "job_name",
   ",",
   "time",
   ".",
   "time",
   "(",
   ")",
   ")",
   "script_path",
   "=",
   "\"{0}/{1}.submit\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "script_dir",
   ",",
   "job_name",
   ")",
   "script_path",
   "=",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "script_path",
   ")",
   "userscript_path",
   "=",
   "\"{0}/{1}.script\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "script_dir",
   ",",
   "job_name",
   ")",
   "userscript_path",
   "=",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "userscript_path",
   ")",
   "self",
   ".",
   "environment",
   "[",
   "\"JOBNAME\"",
   "]",
   "=",
   "\"'{}'\"",
   ".",
   "format",
   "(",
   "job_name",
   ")",
   "job_config",
   "=",
   "{",
   "}",
   "job_config",
   "[",
   "\"job_name\"",
   "]",
   "=",
   "job_name",
   "job_config",
   "[",
   "\"submit_script_dir\"",
   "]",
   "=",
   "self",
   ".",
   "channel",
   ".",
   "script_dir",
   "job_config",
   "[",
   "\"project\"",
   "]",
   "=",
   "self",
   ".",
   "project",
   "job_config",
   "[",
   "\"nodes\"",
   "]",
   "=",
   "self",
   ".",
   "nodes_per_block",
   "job_config",
   "[",
   "\"scheduler_options\"",
   "]",
   "=",
   "self",
   ".",
   "scheduler_options",
   "job_config",
   "[",
   "\"worker_init\"",
   "]",
   "=",
   "self",
   ".",
   "worker_init",
   "job_config",
   "[",
   "\"user_script\"",
   "]",
   "=",
   "command",
   "job_config",
   "[",
   "\"tasks_per_node\"",
   "]",
   "=",
   "tasks_per_node",
   "job_config",
   "[",
   "\"requirements\"",
   "]",
   "=",
   "self",
   ".",
   "requirements",
   "job_config",
   "[",
   "\"environment\"",
   "]",
   "=",
   "' '",
   ".",
   "join",
   "(",
   "[",
   "'{}={}'",
   ".",
   "format",
   "(",
   "key",
   ",",
   "value",
   ")",
   "for",
   "key",
   ",",
   "value",
   "in",
   "self",
   ".",
   "environment",
   ".",
   "items",
   "(",
   ")",
   "]",
   ")",
   "# Move the user script",
   "# This is where the command should be wrapped by the launchers.",
   "wrapped_command",
   "=",
   "self",
   ".",
   "launcher",
   "(",
   "command",
   ",",
   "tasks_per_node",
   ",",
   "self",
   ".",
   "nodes_per_block",
   ")",
   "with",
   "open",
   "(",
   "userscript_path",
   ",",
   "'w'",
   ")",
   "as",
   "f",
   ":",
   "f",
   ".",
   "write",
   "(",
   "job_config",
   "[",
   "\"worker_init\"",
   "]",
   "+",
   "'\\n'",
   "+",
   "wrapped_command",
   ")",
   "user_script_path",
   "=",
   "self",
   ".",
   "channel",
   ".",
   "push_file",
   "(",
   "userscript_path",
   ",",
   "self",
   ".",
   "channel",
   ".",
   "script_dir",
   ")",
   "the_input_files",
   "=",
   "[",
   "user_script_path",
   "]",
   "+",
   "self",
   ".",
   "transfer_input_files",
   "job_config",
   "[",
   "\"input_files\"",
   "]",
   "=",
   "','",
   ".",
   "join",
   "(",
   "the_input_files",
   ")",
   "job_config",
   "[",
   "\"job_script\"",
   "]",
   "=",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "user_script_path",
   ")",
   "# Construct and move the submit script",
   "self",
   ".",
   "_write_submit_script",
   "(",
   "template_string",
   ",",
   "script_path",
   ",",
   "job_name",
   ",",
   "job_config",
   ")",
   "channel_script_path",
   "=",
   "self",
   ".",
   "channel",
   ".",
   "push_file",
   "(",
   "script_path",
   ",",
   "self",
   ".",
   "channel",
   ".",
   "script_dir",
   ")",
   "cmd",
   "=",
   "\"condor_submit {0}\"",
   ".",
   "format",
   "(",
   "channel_script_path",
   ")",
   "retcode",
   ",",
   "stdout",
   ",",
   "stderr",
   "=",
   "super",
   "(",
   ")",
   ".",
   "execute_wait",
   "(",
   "cmd",
   ",",
   "30",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Retcode:%s STDOUT:%s STDERR:%s\"",
   ",",
   "retcode",
   ",",
   "stdout",
   ".",
   "strip",
   "(",
   ")",
   ",",
   "stderr",
   ".",
   "strip",
   "(",
   ")",
   ")",
   "job_id",
   "=",
   "[",
   "]",
   "if",
   "retcode",
   "==",
   "0",
   ":",
   "for",
   "line",
   "in",
   "stdout",
   ".",
   "split",
   "(",
   "'\\n'",
   ")",
   ":",
   "if",
   "re",
   ".",
   "match",
   "(",
   "'^[0-9]'",
   ",",
   "line",
   ")",
   "is",
   "not",
   "None",
   ":",
   "cluster",
   "=",
   "line",
   ".",
   "split",
   "(",
   "\" \"",
   ")",
   "[",
   "5",
   "]",
   "# We know the first job id (\"process\" in condor terms) within a",
   "# cluster is 0 and we know the total number of jobs from",
   "# condor_submit, so we use some list comprehensions to expand",
   "# the condor_submit output into job IDs",
   "# e.g., ['118907.0', '118907.1', '118907.2', '118907.3', '118907.4', '118908.0']",
   "processes",
   "=",
   "[",
   "str",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "range",
   "(",
   "0",
   ",",
   "int",
   "(",
   "line",
   "[",
   "0",
   "]",
   ")",
   ")",
   "]",
   "job_id",
   "+=",
   "[",
   "cluster",
   "+",
   "process",
   "for",
   "process",
   "in",
   "processes",
   "]",
   "self",
   ".",
   "_add_resource",
   "(",
   "job_id",
   ")",
   "return",
   "job_id",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-543",
  "nl_tokens": [
   "set",
   "the",
   "sweep",
   "and",
   "channel",
   "of",
   "an",
   "ABF",
   ".",
   "Both",
   "start",
   "at",
   "0",
   "."
  ],
  "pl_tokens": [
   "def",
   "setsweep",
   "(",
   "self",
   ",",
   "sweep",
   "=",
   "0",
   ",",
   "channel",
   "=",
   "0",
   ")",
   ":",
   "try",
   ":",
   "sweep",
   "=",
   "int",
   "(",
   "sweep",
   ")",
   "except",
   ":",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"trying to set sweep to [%s]\"",
   ",",
   "sweep",
   ")",
   "return",
   "if",
   "sweep",
   "<",
   "0",
   ":",
   "sweep",
   "=",
   "self",
   ".",
   "sweeps",
   "-",
   "1",
   "-",
   "sweep",
   "# if negative, start from the end",
   "sweep",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "min",
   "(",
   "sweep",
   ",",
   "self",
   ".",
   "sweeps",
   "-",
   "1",
   ")",
   ")",
   "# correct for out of range sweeps",
   "if",
   "'sweep'",
   "in",
   "dir",
   "(",
   "self",
   ")",
   "and",
   "self",
   ".",
   "sweep",
   "==",
   "sweep",
   "and",
   "self",
   ".",
   "derivative",
   "is",
   "False",
   ":",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"sweep %d already set\"",
   ",",
   "sweep",
   ")",
   "return",
   "#self.log.debug(\"loading sweep %d (Ch%d)\",sweep,channel)",
   "self",
   ".",
   "channels",
   "=",
   "self",
   ".",
   "ABFblock",
   ".",
   "segments",
   "[",
   "sweep",
   "]",
   ".",
   "size",
   "[",
   "\"analogsignals\"",
   "]",
   "if",
   "self",
   ".",
   "channels",
   ">",
   "1",
   "and",
   "sweep",
   "==",
   "0",
   ":",
   "self",
   ".",
   "log",
   ".",
   "info",
   "(",
   "\"WARNING: multichannel not yet supported!\"",
   ")",
   "#TODO:",
   "self",
   ".",
   "trace",
   "=",
   "self",
   ".",
   "ABFblock",
   ".",
   "segments",
   "[",
   "sweep",
   "]",
   ".",
   "analogsignals",
   "[",
   "channel",
   "]",
   "self",
   ".",
   "sweep",
   "=",
   "sweep",
   "# currently selected sweep",
   "self",
   ".",
   "channel",
   "=",
   "channel",
   "# currently selected channel",
   "# sweep information",
   "self",
   ".",
   "rate",
   "=",
   "int",
   "(",
   "self",
   ".",
   "trace",
   ".",
   "sampling_rate",
   ")",
   "# Hz",
   "self",
   ".",
   "period",
   "=",
   "float",
   "(",
   "1",
   "/",
   "self",
   ".",
   "rate",
   ")",
   "# seconds (inverse of sample rate)",
   "self",
   ".",
   "pointsPerSec",
   "=",
   "int",
   "(",
   "self",
   ".",
   "rate",
   ")",
   "# for easy access",
   "self",
   ".",
   "pointsPerMs",
   "=",
   "int",
   "(",
   "self",
   ".",
   "rate",
   "/",
   "1000.0",
   ")",
   "# for easy access",
   "self",
   ".",
   "sweepSize",
   "=",
   "len",
   "(",
   "self",
   ".",
   "trace",
   ")",
   "# number of data points per sweep",
   "self",
   ".",
   "sweepInterval",
   "=",
   "self",
   ".",
   "trace",
   ".",
   "duration",
   ".",
   "magnitude",
   "# sweep interval (seconds)",
   "self",
   ".",
   "sweepLength",
   "=",
   "float",
   "(",
   "self",
   ".",
   "trace",
   ".",
   "t_stop",
   "-",
   "self",
   ".",
   "trace",
   ".",
   "t_start",
   ")",
   "# in seconds",
   "self",
   ".",
   "length",
   "=",
   "self",
   ".",
   "sweepLength",
   "*",
   "self",
   ".",
   "sweeps",
   "# length (sec) of total recording",
   "self",
   ".",
   "lengthMinutes",
   "=",
   "self",
   ".",
   "length",
   "/",
   "60.0",
   "# length (minutes) of total recording",
   "if",
   "str",
   "(",
   "self",
   ".",
   "trace",
   ".",
   "dimensionality",
   ")",
   "==",
   "'pA'",
   ":",
   "self",
   ".",
   "units",
   ",",
   "self",
   ".",
   "units2",
   "=",
   "\"pA\"",
   ",",
   "\"clamp current (pA)\"",
   "self",
   ".",
   "unitsD",
   ",",
   "self",
   ".",
   "unitsD2",
   "=",
   "\"pA/ms\"",
   ",",
   "\"current velocity (pA/ms)\"",
   "self",
   ".",
   "protoUnits",
   ",",
   "self",
   ".",
   "protoUnits2",
   "=",
   "\"mV\"",
   ",",
   "\"command voltage (mV)\"",
   "elif",
   "str",
   "(",
   "self",
   ".",
   "trace",
   ".",
   "dimensionality",
   ")",
   "==",
   "'mV'",
   ":",
   "self",
   ".",
   "units",
   ",",
   "self",
   ".",
   "units2",
   "=",
   "\"mV\"",
   ",",
   "\"membrane potential (mV)\"",
   "self",
   ".",
   "unitsD",
   ",",
   "self",
   ".",
   "unitsD2",
   "=",
   "\"V/s\"",
   ",",
   "\"potential velocity (V/s)\"",
   "self",
   ".",
   "protoUnits",
   ",",
   "self",
   ".",
   "protoUnits2",
   "=",
   "\"pA\"",
   ",",
   "\"command current (pA)\"",
   "else",
   ":",
   "self",
   ".",
   "units",
   ",",
   "self",
   ".",
   "units2",
   "=",
   "\"?\"",
   ",",
   "\"unknown units\"",
   "self",
   ".",
   "unitsD",
   ",",
   "self",
   ".",
   "unitsD2",
   "=",
   "\"?\"",
   ",",
   "\"unknown units\"",
   "# sweep data",
   "self",
   ".",
   "sweepY",
   "=",
   "self",
   ".",
   "trace",
   ".",
   "magnitude",
   "# sweep data (mV or pA)",
   "self",
   ".",
   "sweepT",
   "=",
   "self",
   ".",
   "trace",
   ".",
   "times",
   ".",
   "magnitude",
   "# actual sweep times (sec)",
   "self",
   ".",
   "sweepStart",
   "=",
   "float",
   "(",
   "self",
   ".",
   "trace",
   ".",
   "t_start",
   ")",
   "# time start of sweep (sec)",
   "self",
   ".",
   "sweepX2",
   "=",
   "self",
   ".",
   "sweepT",
   "-",
   "self",
   ".",
   "trace",
   ".",
   "t_start",
   ".",
   "magnitude",
   "# sweeps overlap",
   "self",
   ".",
   "sweepX",
   "=",
   "self",
   ".",
   "sweepX2",
   "+",
   "sweep",
   "*",
   "self",
   ".",
   "sweepInterval",
   "# assume no gaps",
   "if",
   "self",
   ".",
   "derivative",
   ":",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"taking derivative\"",
   ")",
   "#self.sweepD=np.diff(self.sweepY) # take derivative",
   "self",
   ".",
   "sweepD",
   "=",
   "self",
   ".",
   "sweepY",
   "[",
   "1",
   ":",
   "]",
   "-",
   "self",
   ".",
   "sweepY",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# better?",
   "self",
   ".",
   "sweepD",
   "=",
   "np",
   ".",
   "insert",
   "(",
   "self",
   ".",
   "sweepD",
   ",",
   "0",
   ",",
   "self",
   ".",
   "sweepD",
   "[",
   "0",
   "]",
   ")",
   "# add a point",
   "self",
   ".",
   "sweepD",
   "/=",
   "(",
   "self",
   ".",
   "period",
   "*",
   "1000",
   ")",
   "# correct for sample rate",
   "else",
   ":",
   "self",
   ".",
   "sweepD",
   "=",
   "[",
   "0",
   "]",
   "# derivative is forced to be empty",
   "# generate the protocol too",
   "self",
   ".",
   "generate_protocol",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-544",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "find_minimal_node",
   "(",
   "self",
   ",",
   "node_head",
   ",",
   "discriminator",
   ")",
   ":",
   "min_key",
   "=",
   "lambda",
   "cur_node",
   ":",
   "cur_node",
   ".",
   "data",
   "[",
   "discriminator",
   "]",
   "stack",
   "=",
   "[",
   "]",
   "candidates",
   "=",
   "[",
   "]",
   "isFinished",
   "=",
   "False",
   "while",
   "isFinished",
   "is",
   "False",
   ":",
   "if",
   "node_head",
   "is",
   "not",
   "None",
   ":",
   "stack",
   ".",
   "append",
   "(",
   "node_head",
   ")",
   "node_head",
   "=",
   "node_head",
   ".",
   "left",
   "else",
   ":",
   "if",
   "len",
   "(",
   "stack",
   ")",
   "!=",
   "0",
   ":",
   "node_head",
   "=",
   "stack",
   ".",
   "pop",
   "(",
   ")",
   "candidates",
   ".",
   "append",
   "(",
   "node_head",
   ")",
   "node_head",
   "=",
   "node_head",
   ".",
   "right",
   "else",
   ":",
   "isFinished",
   "=",
   "True",
   "return",
   "<mask>",
   "(",
   "candidates",
   ",",
   "key",
   "=",
   "min_key",
   ")"
  ]
 },
 {
  "idx": "maxmin-545",
  "nl_tokens": [
   "Reads",
   "data",
   "from",
   "the",
   "TLS",
   "-",
   "wrapped",
   "socket"
  ],
  "pl_tokens": [
   "def",
   "read",
   "(",
   "self",
   ",",
   "max_length",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "max_length",
   ",",
   "int_types",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "pretty_message",
   "(",
   "'''\n                max_length must be an integer, not %s\n                '''",
   ",",
   "type_name",
   "(",
   "max_length",
   ")",
   ")",
   ")",
   "buffered_length",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_decrypted_bytes",
   ")",
   "# If we already have enough buffered data, just use that",
   "if",
   "buffered_length",
   ">=",
   "max_length",
   ":",
   "output",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "[",
   "0",
   ":",
   "max_length",
   "]",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "[",
   "max_length",
   ":",
   "]",
   "return",
   "output",
   "if",
   "self",
   ".",
   "_ssl",
   "is",
   "None",
   ":",
   "self",
   ".",
   "_raise_closed",
   "(",
   ")",
   "# Don't block if we have buffered data available, since it is ok to",
   "# return less than the max_length",
   "if",
   "buffered_length",
   ">",
   "0",
   "and",
   "not",
   "self",
   ".",
   "select_read",
   "(",
   "0",
   ")",
   ":",
   "output",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "b''",
   "return",
   "output",
   "# Only read enough to get the requested amount when",
   "# combined with buffered data",
   "to_read",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_buffer_size",
   ",",
   "max_length",
   "-",
   "buffered_length",
   ")",
   "output",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "# The SSL_read() loop handles renegotiations, so we need to handle",
   "# requests for both reads and writes",
   "again",
   "=",
   "True",
   "while",
   "again",
   ":",
   "again",
   "=",
   "False",
   "result",
   "=",
   "libssl",
   ".",
   "SSL_read",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "self",
   ".",
   "_read_buffer",
   ",",
   "to_read",
   ")",
   "self",
   ".",
   "_raw_write",
   "(",
   ")",
   "if",
   "result",
   "<=",
   "0",
   ":",
   "error",
   "=",
   "libssl",
   ".",
   "SSL_get_error",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "result",
   ")",
   "if",
   "error",
   "==",
   "LibsslConst",
   ".",
   "SSL_ERROR_WANT_READ",
   ":",
   "if",
   "self",
   ".",
   "_raw_read",
   "(",
   ")",
   "!=",
   "b''",
   ":",
   "again",
   "=",
   "True",
   "continue",
   "raise_disconnection",
   "(",
   ")",
   "elif",
   "error",
   "==",
   "LibsslConst",
   ".",
   "SSL_ERROR_WANT_WRITE",
   ":",
   "self",
   ".",
   "_raw_write",
   "(",
   ")",
   "again",
   "=",
   "True",
   "continue",
   "elif",
   "error",
   "==",
   "LibsslConst",
   ".",
   "SSL_ERROR_ZERO_RETURN",
   ":",
   "self",
   ".",
   "_gracefully_closed",
   "=",
   "True",
   "self",
   ".",
   "_shutdown",
   "(",
   "False",
   ")",
   "break",
   "else",
   ":",
   "handle_openssl_error",
   "(",
   "0",
   ",",
   "TLSError",
   ")",
   "output",
   "+=",
   "bytes_from_buffer",
   "(",
   "self",
   ".",
   "_read_buffer",
   ",",
   "result",
   ")",
   "if",
   "self",
   ".",
   "_gracefully_closed",
   "and",
   "len",
   "(",
   "output",
   ")",
   "==",
   "0",
   ":",
   "self",
   ".",
   "_raise_closed",
   "(",
   ")",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "output",
   "[",
   "max_length",
   ":",
   "]",
   "return",
   "output",
   "[",
   "0",
   ":",
   "max_length",
   "]"
  ]
 },
 {
  "idx": "maxmin-546",
  "nl_tokens": [
   "Reads",
   "up",
   "to",
   "C",
   "{",
   "count",
   "}",
   "bytes",
   "from",
   "the",
   "file",
   ".",
   ":",
   "rtype",
   ":",
   "list",
   ":",
   "return",
   ":",
   "the",
   "list",
   "of",
   "symbolic",
   "bytes",
   "read"
  ],
  "pl_tokens": [
   "def",
   "read",
   "(",
   "self",
   ",",
   "count",
   ")",
   ":",
   "if",
   "self",
   ".",
   "pos",
   ">",
   "self",
   ".",
   "max_size",
   ":",
   "return",
   "[",
   "]",
   "else",
   ":",
   "size",
   "=",
   "<mask>",
   "(",
   "count",
   ",",
   "self",
   ".",
   "max_size",
   "-",
   "self",
   ".",
   "pos",
   ")",
   "ret",
   "=",
   "[",
   "self",
   ".",
   "array",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "pos",
   ",",
   "self",
   ".",
   "pos",
   "+",
   "size",
   ")",
   "]",
   "self",
   ".",
   "pos",
   "+=",
   "size",
   "return",
   "ret"
  ]
 },
 {
  "idx": "maxmin-547",
  "nl_tokens": [
   "Button",
   "action",
   "event"
  ],
  "pl_tokens": [
   "def",
   "__button_action",
   "(",
   "self",
   ",",
   "data",
   "=",
   "None",
   ")",
   ":",
   "if",
   "any",
   "(",
   "not",
   "x",
   "for",
   "x",
   "in",
   "(",
   "self",
   ".",
   "_ename",
   ".",
   "value",
   ",",
   "self",
   ".",
   "_p1",
   ".",
   "value",
   ",",
   "self",
   ".",
   "_p2",
   ".",
   "value",
   ",",
   "self",
   ".",
   "_file",
   ".",
   "value",
   ")",
   ")",
   ":",
   "print",
   "(",
   "\"Missing one of the required fields (event name, player names, file name)\"",
   ")",
   "return",
   "self",
   ".",
   "__p1chars",
   "=",
   "[",
   "]",
   "self",
   ".",
   "__p2chars",
   "=",
   "[",
   "]",
   "options",
   "=",
   "Namespace",
   "(",
   ")",
   "self",
   ".",
   "__history",
   ".",
   "append",
   "(",
   "self",
   ".",
   "__save_form",
   "(",
   ")",
   ")",
   "options",
   ".",
   "ename",
   "=",
   "self",
   ".",
   "_ename",
   ".",
   "value",
   "if",
   "self",
   ".",
   "_ename_min",
   ".",
   "value",
   ":",
   "options",
   ".",
   "ename_min",
   "=",
   "self",
   ".",
   "_ename_min",
   ".",
   "value",
   "else",
   ":",
   "options",
   ".",
   "ename_min",
   "=",
   "options",
   ".",
   "ename",
   "options",
   ".",
   "pID",
   "=",
   "self",
   ".",
   "_pID",
   ".",
   "value",
   "options",
   ".",
   "mtype",
   "=",
   "self",
   ".",
   "_mtype",
   ".",
   "value",
   "options",
   ".",
   "mmid",
   "=",
   "options",
   ".",
   "mtype",
   "options",
   ".",
   "p1",
   "=",
   "self",
   ".",
   "_p1",
   ".",
   "value",
   "options",
   ".",
   "p2",
   "=",
   "self",
   ".",
   "_p2",
   ".",
   "value",
   "options",
   ".",
   "p1char",
   "=",
   "self",
   ".",
   "_p1char",
   ".",
   "value",
   "options",
   ".",
   "p2char",
   "=",
   "self",
   ".",
   "_p2char",
   ".",
   "value",
   "options",
   ".",
   "bracket",
   "=",
   "self",
   ".",
   "_bracket",
   ".",
   "value",
   "isadir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "isdir",
   "(",
   "self",
   ".",
   "_file",
   ".",
   "value",
   ")",
   "if",
   "isadir",
   ":",
   "options",
   ".",
   "file",
   "=",
   "<mask>",
   "(",
   "[",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "self",
   ".",
   "_file",
   ".",
   "value",
   ",",
   "f",
   ")",
   "for",
   "f",
   "in",
   "os",
   ".",
   "listdir",
   "(",
   "self",
   ".",
   "_file",
   ".",
   "value",
   ")",
   "if",
   "os",
   ".",
   "path",
   ".",
   "isfile",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "self",
   ".",
   "_file",
   ".",
   "value",
   ",",
   "f",
   ")",
   ")",
   "]",
   ",",
   "key",
   "=",
   "os",
   ".",
   "path",
   ".",
   "getmtime",
   ")",
   "else",
   ":",
   "options",
   ".",
   "file",
   "=",
   "self",
   ".",
   "_file",
   ".",
   "value",
   "options",
   ".",
   "tags",
   "=",
   "self",
   ".",
   "_tags",
   ".",
   "value",
   "options",
   ".",
   "msuffix",
   "=",
   "self",
   ".",
   "_msuffix",
   ".",
   "value",
   "options",
   ".",
   "mprefix",
   "=",
   "self",
   ".",
   "_mprefix",
   ".",
   "value",
   "options",
   ".",
   "privacy",
   "=",
   "self",
   ".",
   "_privacy",
   ".",
   "value",
   "options",
   ".",
   "descrip",
   "=",
   "self",
   ".",
   "_description",
   ".",
   "value",
   "options",
   ".",
   "titleformat",
   "=",
   "self",
   ".",
   "_titleformat",
   ".",
   "value",
   "if",
   "self",
   ".",
   "_p1sponsor",
   ".",
   "value",
   ":",
   "options",
   ".",
   "p1",
   "=",
   "\" | \"",
   ".",
   "join",
   "(",
   "(",
   "self",
   ".",
   "_p1sponsor",
   ".",
   "value",
   ",",
   "options",
   ".",
   "p1",
   ")",
   ")",
   "if",
   "self",
   ".",
   "_p2sponsor",
   ".",
   "value",
   ":",
   "options",
   ".",
   "p2",
   "=",
   "\" | \"",
   ".",
   "join",
   "(",
   "(",
   "self",
   ".",
   "_p2sponsor",
   ".",
   "value",
   ",",
   "options",
   ".",
   "p2",
   ")",
   ")",
   "options",
   ".",
   "ignore",
   "=",
   "False",
   "self",
   ".",
   "__reset_match",
   "(",
   "False",
   ",",
   "isadir",
   ")",
   "self",
   ".",
   "__add_to_qview",
   "(",
   "options",
   ")",
   "self",
   ".",
   "_queueref",
   ".",
   "append",
   "(",
   "options",
   ")",
   "if",
   "consts",
   ".",
   "firstrun",
   ":",
   "thr",
   "=",
   "threading",
   ".",
   "Thread",
   "(",
   "target",
   "=",
   "self",
   ".",
   "__worker",
   ")",
   "thr",
   ".",
   "daemon",
   "=",
   "True",
   "thr",
   ".",
   "start",
   "(",
   ")",
   "consts",
   ".",
   "firstrun",
   "=",
   "False"
  ]
 },
 {
  "idx": "maxmin-548",
  "nl_tokens": [
   "Find",
   "a",
   "suitable",
   "weekly",
   "extract",
   "start",
   "date",
   "(",
   "monday",
   ")",
   ".",
   "The",
   "goal",
   "is",
   "to",
   "obtain",
   "as",
   "usual",
   "week",
   "as",
   "possible",
   ".",
   "The",
   "weekdays",
   "of",
   "the",
   "weekly",
   "extract",
   "week",
   "should",
   "contain",
   "at",
   "least",
   "0",
   ".",
   "9",
   "of",
   "the",
   "total",
   "maximum",
   "of",
   "trips",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_weekly_extract_start_date",
   "(",
   "self",
   ",",
   "ut",
   "=",
   "False",
   ",",
   "weekdays_at_least_of_max",
   "=",
   "0.9",
   ",",
   "verbose",
   "=",
   "False",
   ",",
   "download_date_override",
   "=",
   "None",
   ")",
   ":",
   "daily_trip_counts",
   "=",
   "self",
   ".",
   "get_trip_counts_per_day",
   "(",
   ")",
   "if",
   "isinstance",
   "(",
   "download_date_override",
   ",",
   "str",
   ")",
   ":",
   "search_start_date",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "strptime",
   "(",
   "download_date_override",
   ",",
   "\"%Y-%m-%d\"",
   ")",
   "elif",
   "isinstance",
   "(",
   "download_date_override",
   ",",
   "datetime",
   ".",
   "datetime",
   ")",
   ":",
   "search_start_date",
   "=",
   "download_date_override",
   "else",
   ":",
   "assert",
   "download_date_override",
   "is",
   "None",
   "download_date_str",
   "=",
   "self",
   ".",
   "meta",
   "[",
   "'download_date'",
   "]",
   "if",
   "download_date_str",
   "==",
   "\"\"",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"Download date is not speficied in the database. \"",
   "\"Download date used in GTFS.\"",
   "+",
   "self",
   ".",
   "get_weekly_extract_start_date",
   ".",
   "__name__",
   "+",
   "\"() defaults to the smallest date when any operations take place.\"",
   ")",
   "search_start_date",
   "=",
   "daily_trip_counts",
   "[",
   "'date'",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "else",
   ":",
   "search_start_date",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "strptime",
   "(",
   "download_date_str",
   ",",
   "\"%Y-%m-%d\"",
   ")",
   "feed_min_date",
   "=",
   "daily_trip_counts",
   "[",
   "'date'",
   "]",
   ".",
   "min",
   "(",
   ")",
   "feed_max_date",
   "=",
   "daily_trip_counts",
   "[",
   "'date'",
   "]",
   ".",
   "max",
   "(",
   ")",
   "assert",
   "(",
   "feed_max_date",
   "-",
   "feed_min_date",
   ">=",
   "datetime",
   ".",
   "timedelta",
   "(",
   "days",
   "=",
   "7",
   ")",
   ")",
   ",",
   "\"Dataset is not long enough for providing week long extracts\"",
   "# get first a valid monday where the search for the week can be started:",
   "next_monday_from_search_start_date",
   "=",
   "search_start_date",
   "+",
   "timedelta",
   "(",
   "days",
   "=",
   "(",
   "7",
   "-",
   "search_start_date",
   ".",
   "weekday",
   "(",
   ")",
   ")",
   ")",
   "if",
   "not",
   "(",
   "feed_min_date",
   "<=",
   "next_monday_from_search_start_date",
   "<=",
   "feed_max_date",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"The next monday after the (possibly user) specified download date is not present in the database.\"",
   "\"Resorting to first monday after the beginning of operations instead.\"",
   ")",
   "next_monday_from_search_start_date",
   "=",
   "feed_min_date",
   "+",
   "timedelta",
   "(",
   "days",
   "=",
   "(",
   "7",
   "-",
   "feed_min_date",
   ".",
   "weekday",
   "(",
   ")",
   ")",
   ")",
   "max_trip_count",
   "=",
   "daily_trip_counts",
   "[",
   "'trip_counts'",
   "]",
   ".",
   "quantile",
   "(",
   "0.95",
   ")",
   "# Take 95th percentile to omit special days, if any exist.",
   "threshold",
   "=",
   "weekdays_at_least_of_max",
   "*",
   "max_trip_count",
   "threshold_fulfilling_days",
   "=",
   "daily_trip_counts",
   "[",
   "'trip_counts'",
   "]",
   ">",
   "threshold",
   "# look forward first",
   "# get the index of the trip:",
   "search_start_monday_index",
   "=",
   "daily_trip_counts",
   "[",
   "daily_trip_counts",
   "[",
   "'date'",
   "]",
   "==",
   "next_monday_from_search_start_date",
   "]",
   ".",
   "index",
   "[",
   "0",
   "]",
   "# get starting point",
   "while_loop_monday_index",
   "=",
   "search_start_monday_index",
   "while",
   "len",
   "(",
   "daily_trip_counts",
   ".",
   "index",
   ")",
   ">=",
   "while_loop_monday_index",
   "+",
   "7",
   ":",
   "if",
   "all",
   "(",
   "threshold_fulfilling_days",
   "[",
   "while_loop_monday_index",
   ":",
   "while_loop_monday_index",
   "+",
   "5",
   "]",
   ")",
   ":",
   "row",
   "=",
   "daily_trip_counts",
   ".",
   "iloc",
   "[",
   "while_loop_monday_index",
   "]",
   "if",
   "ut",
   ":",
   "return",
   "self",
   ".",
   "get_day_start_ut",
   "(",
   "row",
   ".",
   "date_str",
   ")",
   "else",
   ":",
   "return",
   "row",
   "[",
   "'date'",
   "]",
   "while_loop_monday_index",
   "+=",
   "7",
   "while_loop_monday_index",
   "=",
   "search_start_monday_index",
   "-",
   "7",
   "# then backwards",
   "while",
   "while_loop_monday_index",
   ">=",
   "0",
   ":",
   "if",
   "all",
   "(",
   "threshold_fulfilling_days",
   "[",
   "while_loop_monday_index",
   ":",
   "while_loop_monday_index",
   "+",
   "5",
   "]",
   ")",
   ":",
   "row",
   "=",
   "daily_trip_counts",
   ".",
   "iloc",
   "[",
   "while_loop_monday_index",
   "]",
   "if",
   "ut",
   ":",
   "return",
   "self",
   ".",
   "get_day_start_ut",
   "(",
   "row",
   ".",
   "date_str",
   ")",
   "else",
   ":",
   "return",
   "row",
   "[",
   "'date'",
   "]",
   "while_loop_monday_index",
   "-=",
   "7",
   "raise",
   "RuntimeError",
   "(",
   "\"No suitable weekly extract start date could be determined!\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-549",
  "nl_tokens": [
   "Performs",
   "inhibition",
   ".",
   "This",
   "method",
   "calculates",
   "the",
   "necessary",
   "values",
   "needed",
   "to",
   "actually",
   "perform",
   "inhibition",
   "and",
   "then",
   "delegates",
   "the",
   "task",
   "of",
   "picking",
   "the",
   "active",
   "columns",
   "to",
   "helper",
   "functions",
   "."
  ],
  "pl_tokens": [
   "def",
   "_inhibitColumns",
   "(",
   "self",
   ",",
   "overlaps",
   ")",
   ":",
   "# determine how many columns should be selected in the inhibition phase.",
   "# This can be specified by either setting the 'numActiveColumnsPerInhArea'",
   "# parameter or the 'localAreaDensity' parameter when initializing the class",
   "if",
   "(",
   "self",
   ".",
   "_localAreaDensity",
   ">",
   "0",
   ")",
   ":",
   "density",
   "=",
   "self",
   ".",
   "_localAreaDensity",
   "else",
   ":",
   "inhibitionArea",
   "=",
   "(",
   "(",
   "2",
   "*",
   "self",
   ".",
   "_inhibitionRadius",
   "+",
   "1",
   ")",
   "**",
   "self",
   ".",
   "_columnDimensions",
   ".",
   "size",
   ")",
   "inhibitionArea",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_numColumns",
   ",",
   "inhibitionArea",
   ")",
   "density",
   "=",
   "float",
   "(",
   "self",
   ".",
   "_numActiveColumnsPerInhArea",
   ")",
   "/",
   "inhibitionArea",
   "density",
   "=",
   "min",
   "(",
   "density",
   ",",
   "0.5",
   ")",
   "if",
   "self",
   ".",
   "_globalInhibition",
   "or",
   "self",
   ".",
   "_inhibitionRadius",
   ">",
   "max",
   "(",
   "self",
   ".",
   "_columnDimensions",
   ")",
   ":",
   "return",
   "self",
   ".",
   "_inhibitColumnsGlobal",
   "(",
   "overlaps",
   ",",
   "density",
   ")",
   "else",
   ":",
   "return",
   "self",
   ".",
   "_inhibitColumnsLocal",
   "(",
   "overlaps",
   ",",
   "density",
   ")"
  ]
 },
 {
  "idx": "maxmin-550",
  "nl_tokens": [
   "Gets",
   "several",
   "neighbor",
   "GAIA",
   "and",
   "SIMBAD",
   "features",
   ":"
  ],
  "pl_tokens": [
   "def",
   "neighbor_gaia_features",
   "(",
   "objectinfo",
   ",",
   "lclist_kdtree",
   ",",
   "neighbor_radius_arcsec",
   ",",
   "gaia_matchdist_arcsec",
   "=",
   "3.0",
   ",",
   "verbose",
   "=",
   "True",
   ",",
   "gaia_submit_timeout",
   "=",
   "10.0",
   ",",
   "gaia_submit_tries",
   "=",
   "3",
   ",",
   "gaia_max_timeout",
   "=",
   "180.0",
   ",",
   "gaia_mirror",
   "=",
   "None",
   ",",
   "complete_query_later",
   "=",
   "True",
   ",",
   "search_simbad",
   "=",
   "False",
   ")",
   ":",
   "# kdtree search for neighbors in light curve catalog",
   "if",
   "(",
   "'ra'",
   "in",
   "objectinfo",
   "and",
   "'decl'",
   "in",
   "objectinfo",
   "and",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "(",
   "isinstance",
   "(",
   "lclist_kdtree",
   ",",
   "cKDTree",
   ")",
   "or",
   "isinstance",
   "(",
   "lclist_kdtree",
   ",",
   "KDTree",
   ")",
   ")",
   ")",
   ":",
   "ra",
   ",",
   "decl",
   "=",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   "cosdecl",
   "=",
   "np",
   ".",
   "cos",
   "(",
   "np",
   ".",
   "radians",
   "(",
   "decl",
   ")",
   ")",
   "sindecl",
   "=",
   "np",
   ".",
   "sin",
   "(",
   "np",
   ".",
   "radians",
   "(",
   "decl",
   ")",
   ")",
   "cosra",
   "=",
   "np",
   ".",
   "cos",
   "(",
   "np",
   ".",
   "radians",
   "(",
   "ra",
   ")",
   ")",
   "sinra",
   "=",
   "np",
   ".",
   "sin",
   "(",
   "np",
   ".",
   "radians",
   "(",
   "ra",
   ")",
   ")",
   "# this is the search distance in xyz unit vectors",
   "xyzdist",
   "=",
   "2.0",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "np",
   ".",
   "radians",
   "(",
   "neighbor_radius_arcsec",
   "/",
   "3600.0",
   ")",
   "/",
   "2.0",
   ")",
   "# look up the coordinates for the closest 100 objects in the kdtree",
   "# within 2 x neighbor_radius_arcsec",
   "kdt_dist",
   ",",
   "kdt_ind",
   "=",
   "lclist_kdtree",
   ".",
   "query",
   "(",
   "[",
   "cosra",
   "*",
   "cosdecl",
   ",",
   "sinra",
   "*",
   "cosdecl",
   ",",
   "sindecl",
   "]",
   ",",
   "k",
   "=",
   "100",
   ",",
   "distance_upper_bound",
   "=",
   "xyzdist",
   ")",
   "# the first match is the object itself",
   "finite_distind",
   "=",
   "(",
   "np",
   ".",
   "isfinite",
   "(",
   "kdt_dist",
   ")",
   ")",
   "&",
   "(",
   "kdt_dist",
   ">",
   "0",
   ")",
   "finite_dists",
   "=",
   "kdt_dist",
   "[",
   "finite_distind",
   "]",
   "nbrindices",
   "=",
   "kdt_ind",
   "[",
   "finite_distind",
   "]",
   "n_neighbors",
   "=",
   "finite_dists",
   ".",
   "size",
   "if",
   "n_neighbors",
   ">",
   "0",
   ":",
   "closest_dist",
   "=",
   "finite_dists",
   ".",
   "<mask>",
   "(",
   ")",
   "closest_dist_arcsec",
   "=",
   "(",
   "np",
   ".",
   "degrees",
   "(",
   "2.0",
   "*",
   "np",
   ".",
   "arcsin",
   "(",
   "closest_dist",
   "/",
   "2.0",
   ")",
   ")",
   "*",
   "3600.0",
   ")",
   "closest_dist_nbrind",
   "=",
   "nbrindices",
   "[",
   "finite_dists",
   "==",
   "finite_dists",
   ".",
   "min",
   "(",
   ")",
   "]",
   "resultdict",
   "=",
   "{",
   "'neighbors'",
   ":",
   "n_neighbors",
   ",",
   "'nbrindices'",
   ":",
   "nbrindices",
   ",",
   "'distarcsec'",
   ":",
   "np",
   ".",
   "degrees",
   "(",
   "2.0",
   "*",
   "np",
   ".",
   "arcsin",
   "(",
   "finite_dists",
   "/",
   "2.0",
   ")",
   ")",
   "*",
   "3600.0",
   ",",
   "'closestdistarcsec'",
   ":",
   "closest_dist_arcsec",
   ",",
   "'closestdistnbrind'",
   ":",
   "closest_dist_nbrind",
   ",",
   "'searchradarcsec'",
   ":",
   "neighbor_radius_arcsec",
   ",",
   "}",
   "else",
   ":",
   "resultdict",
   "=",
   "{",
   "'neighbors'",
   ":",
   "0",
   ",",
   "'nbrindices'",
   ":",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   ",",
   "'distarcsec'",
   ":",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   ",",
   "'closestdistarcsec'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'closestdistnbrind'",
   ":",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   ",",
   "'searchradarcsec'",
   ":",
   "neighbor_radius_arcsec",
   ",",
   "}",
   "else",
   ":",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "\"one of ra, decl, kdtree is missing in \"",
   "\"objectinfo dict or lclistpkl, \"",
   "\"can't get observed neighbors\"",
   ")",
   "resultdict",
   "=",
   "{",
   "'neighbors'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'nbrindices'",
   ":",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   ",",
   "'distarcsec'",
   ":",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   ",",
   "'closestdistarcsec'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'closestdistnbrind'",
   ":",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   ",",
   "'searchradarcsec'",
   ":",
   "neighbor_radius_arcsec",
   ",",
   "}",
   "# next, search for this object in GAIA",
   "if",
   "(",
   "'ra'",
   "in",
   "objectinfo",
   "and",
   "'decl'",
   "in",
   "objectinfo",
   "and",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   "is",
   "not",
   "None",
   ")",
   ":",
   "gaia_result",
   "=",
   "gaia",
   ".",
   "objectlist_conesearch",
   "(",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ",",
   "neighbor_radius_arcsec",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   "timeout",
   "=",
   "gaia_submit_timeout",
   ",",
   "maxtimeout",
   "=",
   "gaia_max_timeout",
   ",",
   "maxtries",
   "=",
   "gaia_submit_tries",
   ",",
   "gaia_mirror",
   "=",
   "gaia_mirror",
   ",",
   "complete_query_later",
   "=",
   "complete_query_later",
   ")",
   "if",
   "gaia_result",
   ":",
   "gaia_objlistf",
   "=",
   "gaia_result",
   "[",
   "'result'",
   "]",
   "with",
   "gzip",
   ".",
   "open",
   "(",
   "gaia_objlistf",
   ",",
   "'rb'",
   ")",
   "as",
   "infd",
   ":",
   "try",
   ":",
   "gaia_objlist",
   "=",
   "np",
   ".",
   "genfromtxt",
   "(",
   "infd",
   ",",
   "names",
   "=",
   "True",
   ",",
   "delimiter",
   "=",
   "','",
   ",",
   "dtype",
   "=",
   "'U20,f8,f8,f8,f8,f8,f8,f8,f8,f8,f8,f8,f8'",
   ",",
   "usecols",
   "=",
   "(",
   "0",
   ",",
   "1",
   ",",
   "2",
   ",",
   "3",
   ",",
   "4",
   ",",
   "5",
   ",",
   "6",
   ",",
   "7",
   ",",
   "8",
   ",",
   "9",
   ",",
   "10",
   ",",
   "11",
   ",",
   "12",
   ")",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "gaia_objlist",
   "=",
   "[",
   "]",
   "gaia_objlist",
   "=",
   "np",
   ".",
   "atleast_1d",
   "(",
   "gaia_objlist",
   ")",
   "if",
   "gaia_objlist",
   ".",
   "size",
   ">",
   "0",
   ":",
   "# if we have GAIA results, we can get xypositions of all of",
   "# these objects on the object skyview stamp",
   "stampres",
   "=",
   "skyview",
   ".",
   "get_stamp",
   "(",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ")",
   "if",
   "(",
   "stampres",
   "and",
   "'fitsfile'",
   "in",
   "stampres",
   "and",
   "stampres",
   "[",
   "'fitsfile'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "stampres",
   "[",
   "'fitsfile'",
   "]",
   ")",
   ")",
   ":",
   "stampwcs",
   "=",
   "WCS",
   "(",
   "stampres",
   "[",
   "'fitsfile'",
   "]",
   ")",
   "gaia_xypos",
   "=",
   "stampwcs",
   ".",
   "all_world2pix",
   "(",
   "np",
   ".",
   "column_stack",
   "(",
   "(",
   "gaia_objlist",
   "[",
   "'ra'",
   "]",
   ",",
   "gaia_objlist",
   "[",
   "'dec'",
   "]",
   ")",
   ")",
   ",",
   "1",
   ")",
   "else",
   ":",
   "gaia_xypos",
   "=",
   "None",
   "# the first object is likely the match to the object itself",
   "if",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "[",
   "0",
   "]",
   "<",
   "gaia_matchdist_arcsec",
   ":",
   "if",
   "gaia_objlist",
   ".",
   "size",
   ">",
   "1",
   ":",
   "gaia_nneighbors",
   "=",
   "gaia_objlist",
   "[",
   "1",
   ":",
   "]",
   ".",
   "size",
   "gaia_status",
   "=",
   "(",
   "'ok: object found with %s neighbors'",
   "%",
   "gaia_nneighbors",
   ")",
   "# the first in each array is the object",
   "gaia_ids",
   "=",
   "gaia_objlist",
   "[",
   "'source_id'",
   "]",
   "gaia_mags",
   "=",
   "gaia_objlist",
   "[",
   "'phot_g_mean_mag'",
   "]",
   "gaia_parallaxes",
   "=",
   "gaia_objlist",
   "[",
   "'parallax'",
   "]",
   "gaia_parallax_errs",
   "=",
   "gaia_objlist",
   "[",
   "'parallax_error'",
   "]",
   "gaia_pmra",
   "=",
   "gaia_objlist",
   "[",
   "'pmra'",
   "]",
   "gaia_pmra_err",
   "=",
   "gaia_objlist",
   "[",
   "'pmra_error'",
   "]",
   "gaia_pmdecl",
   "=",
   "gaia_objlist",
   "[",
   "'pmdec'",
   "]",
   "gaia_pmdecl_err",
   "=",
   "gaia_objlist",
   "[",
   "'pmdec_error'",
   "]",
   "gaia_absolute_mags",
   "=",
   "magnitudes",
   ".",
   "absolute_gaia_magnitude",
   "(",
   "gaia_mags",
   ",",
   "gaia_parallaxes",
   ")",
   "if",
   "(",
   "'kmag'",
   "in",
   "objectinfo",
   "and",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "np",
   ".",
   "isfinite",
   "(",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   ")",
   ")",
   ":",
   "gaiak_colors",
   "=",
   "gaia_mags",
   "-",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   "else",
   ":",
   "gaiak_colors",
   "=",
   "None",
   "gaia_dists",
   "=",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "gaia_closest_distarcsec",
   "=",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "[",
   "1",
   "]",
   "gaia_closest_gmagdiff",
   "=",
   "(",
   "gaia_objlist",
   "[",
   "'phot_g_mean_mag'",
   "]",
   "[",
   "0",
   "]",
   "-",
   "gaia_objlist",
   "[",
   "'phot_g_mean_mag'",
   "]",
   "[",
   "1",
   "]",
   ")",
   "else",
   ":",
   "LOGWARNING",
   "(",
   "'object found in GAIA at (%.3f,%.3f), '",
   "'but no neighbors'",
   "%",
   "(",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ")",
   ")",
   "gaia_nneighbors",
   "=",
   "0",
   "gaia_status",
   "=",
   "(",
   "'ok: object found but no neighbors'",
   ")",
   "# the first in each array is the object",
   "gaia_ids",
   "=",
   "gaia_objlist",
   "[",
   "'source_id'",
   "]",
   "gaia_mags",
   "=",
   "gaia_objlist",
   "[",
   "'phot_g_mean_mag'",
   "]",
   "gaia_parallaxes",
   "=",
   "gaia_objlist",
   "[",
   "'parallax'",
   "]",
   "gaia_parallax_errs",
   "=",
   "gaia_objlist",
   "[",
   "'parallax_error'",
   "]",
   "gaia_pmra",
   "=",
   "gaia_objlist",
   "[",
   "'pmra'",
   "]",
   "gaia_pmra_err",
   "=",
   "gaia_objlist",
   "[",
   "'pmra_error'",
   "]",
   "gaia_pmdecl",
   "=",
   "gaia_objlist",
   "[",
   "'pmdec'",
   "]",
   "gaia_pmdecl_err",
   "=",
   "gaia_objlist",
   "[",
   "'pmdec_error'",
   "]",
   "gaia_absolute_mags",
   "=",
   "magnitudes",
   ".",
   "absolute_gaia_magnitude",
   "(",
   "gaia_mags",
   ",",
   "gaia_parallaxes",
   ")",
   "if",
   "(",
   "'kmag'",
   "in",
   "objectinfo",
   "and",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "np",
   ".",
   "isfinite",
   "(",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   ")",
   ")",
   ":",
   "gaiak_colors",
   "=",
   "gaia_mags",
   "-",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   "else",
   ":",
   "gaiak_colors",
   "=",
   "None",
   "gaia_dists",
   "=",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "gaia_closest_distarcsec",
   "=",
   "np",
   ".",
   "nan",
   "gaia_closest_gmagdiff",
   "=",
   "np",
   ".",
   "nan",
   "# otherwise, the object wasn't found in GAIA for some reason",
   "else",
   ":",
   "LOGWARNING",
   "(",
   "'no GAIA objects found within '",
   "'%.3f arcsec of object position (%.3f, %.3f), '",
   "'closest object is at %.3f arcsec away'",
   "%",
   "(",
   "gaia_matchdist_arcsec",
   ",",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ",",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "[",
   "0",
   "]",
   ")",
   ")",
   "gaia_status",
   "=",
   "(",
   "'failed: no object within %.3f '",
   "'arcsec, closest = %.3f arcsec'",
   "%",
   "(",
   "gaia_matchdist_arcsec",
   ",",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "[",
   "0",
   "]",
   ")",
   ")",
   "gaia_nneighbors",
   "=",
   "np",
   ".",
   "nan",
   "gaia_ids",
   "=",
   "gaia_objlist",
   "[",
   "'source_id'",
   "]",
   "gaia_mags",
   "=",
   "gaia_objlist",
   "[",
   "'phot_g_mean_mag'",
   "]",
   "gaia_parallaxes",
   "=",
   "gaia_objlist",
   "[",
   "'parallax'",
   "]",
   "gaia_parallax_errs",
   "=",
   "gaia_objlist",
   "[",
   "'parallax_error'",
   "]",
   "gaia_pmra",
   "=",
   "gaia_objlist",
   "[",
   "'pmra'",
   "]",
   "gaia_pmra_err",
   "=",
   "gaia_objlist",
   "[",
   "'pmra_error'",
   "]",
   "gaia_pmdecl",
   "=",
   "gaia_objlist",
   "[",
   "'pmdec'",
   "]",
   "gaia_pmdecl_err",
   "=",
   "gaia_objlist",
   "[",
   "'pmdec_error'",
   "]",
   "gaia_absolute_mags",
   "=",
   "magnitudes",
   ".",
   "absolute_gaia_magnitude",
   "(",
   "gaia_mags",
   ",",
   "gaia_parallaxes",
   ")",
   "if",
   "(",
   "'kmag'",
   "in",
   "objectinfo",
   "and",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "np",
   ".",
   "isfinite",
   "(",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   ")",
   ")",
   ":",
   "gaiak_colors",
   "=",
   "gaia_mags",
   "-",
   "objectinfo",
   "[",
   "'kmag'",
   "]",
   "else",
   ":",
   "gaiak_colors",
   "=",
   "None",
   "gaia_dists",
   "=",
   "gaia_objlist",
   "[",
   "'dist_arcsec'",
   "]",
   "gaia_closest_distarcsec",
   "=",
   "np",
   ".",
   "nan",
   "gaia_closest_gmagdiff",
   "=",
   "np",
   ".",
   "nan",
   "# if there are no neighbors within neighbor_radius_arcsec",
   "# or this object is not covered by GAIA. return nothing",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no GAIA objects at this '",
   "'position or GAIA query failed'",
   ")",
   "gaia_status",
   "=",
   "(",
   "'failed: no GAIA objects at this '",
   "'position or GAIA query failed.'",
   ")",
   "gaia_nneighbors",
   "=",
   "np",
   ".",
   "nan",
   "gaia_ids",
   "=",
   "None",
   "gaia_mags",
   "=",
   "None",
   "gaia_xypos",
   "=",
   "None",
   "gaia_parallaxes",
   "=",
   "None",
   "gaia_parallax_errs",
   "=",
   "None",
   "gaia_pmra",
   "=",
   "None",
   "gaia_pmra_err",
   "=",
   "None",
   "gaia_pmdecl",
   "=",
   "None",
   "gaia_pmdecl_err",
   "=",
   "None",
   "gaia_absolute_mags",
   "=",
   "None",
   "gaiak_colors",
   "=",
   "None",
   "gaia_dists",
   "=",
   "None",
   "gaia_closest_distarcsec",
   "=",
   "np",
   ".",
   "nan",
   "gaia_closest_gmagdiff",
   "=",
   "np",
   ".",
   "nan",
   "# update the resultdict with gaia stuff",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'gaia_status'",
   ":",
   "gaia_status",
   ",",
   "'gaia_neighbors'",
   ":",
   "gaia_nneighbors",
   ",",
   "'gaia_ids'",
   ":",
   "gaia_ids",
   ",",
   "'gaia_xypos'",
   ":",
   "gaia_xypos",
   ",",
   "'gaia_mags'",
   ":",
   "gaia_mags",
   ",",
   "'gaia_parallaxes'",
   ":",
   "gaia_parallaxes",
   ",",
   "'gaia_parallax_errs'",
   ":",
   "gaia_parallax_errs",
   ",",
   "'gaia_pmras'",
   ":",
   "gaia_pmra",
   ",",
   "'gaia_pmra_errs'",
   ":",
   "gaia_pmra_err",
   ",",
   "'gaia_pmdecls'",
   ":",
   "gaia_pmdecl",
   ",",
   "'gaia_pmdecl_errs'",
   ":",
   "gaia_pmdecl_err",
   ",",
   "'gaia_absolute_mags'",
   ":",
   "gaia_absolute_mags",
   ",",
   "'gaiak_colors'",
   ":",
   "gaiak_colors",
   ",",
   "'gaia_dists'",
   ":",
   "gaia_dists",
   ",",
   "'gaia_closest_distarcsec'",
   ":",
   "gaia_closest_distarcsec",
   ",",
   "'gaia_closest_gmagdiff'",
   ":",
   "gaia_closest_gmagdiff",
   "}",
   ")",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'GAIA query did not return a '",
   "'result for object at (%.3f, %.3f)'",
   "%",
   "(",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ")",
   ")",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'gaia_status'",
   ":",
   "'failed: GAIA TAP query failed'",
   ",",
   "'gaia_neighbors'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'gaia_ids'",
   ":",
   "None",
   ",",
   "'gaia_xypos'",
   ":",
   "None",
   ",",
   "'gaia_mags'",
   ":",
   "None",
   ",",
   "'gaia_parallaxes'",
   ":",
   "None",
   ",",
   "'gaia_parallax_errs'",
   ":",
   "None",
   ",",
   "'gaia_pmras'",
   ":",
   "None",
   ",",
   "'gaia_pmra_errs'",
   ":",
   "None",
   ",",
   "'gaia_pmdecls'",
   ":",
   "None",
   ",",
   "'gaia_pmdecl_errs'",
   ":",
   "None",
   ",",
   "'gaia_absolute_mags'",
   ":",
   "None",
   ",",
   "'gaiak_colors'",
   ":",
   "None",
   ",",
   "'gaia_dists'",
   ":",
   "None",
   ",",
   "'gaia_closest_distarcsec'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'gaia_closest_gmagdiff'",
   ":",
   "np",
   ".",
   "nan",
   "}",
   ")",
   "else",
   ":",
   "LOGERROR",
   "(",
   "\"one or more of the 'ra', 'decl' keys \"",
   "\"are missing from the objectinfo dict, \"",
   "\"can't get GAIA or LC collection neighbor features\"",
   ")",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'gaia_status'",
   ":",
   "'failed: no ra/decl for object'",
   ",",
   "'gaia_neighbors'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'gaia_ids'",
   ":",
   "None",
   ",",
   "'gaia_xypos'",
   ":",
   "None",
   ",",
   "'gaia_mags'",
   ":",
   "None",
   ",",
   "'gaia_parallaxes'",
   ":",
   "None",
   ",",
   "'gaia_parallax_errs'",
   ":",
   "None",
   ",",
   "'gaia_pmras'",
   ":",
   "None",
   ",",
   "'gaia_pmra_errs'",
   ":",
   "None",
   ",",
   "'gaia_pmdecls'",
   ":",
   "None",
   ",",
   "'gaia_pmdecl_errs'",
   ":",
   "None",
   ",",
   "'gaia_absolute_mags'",
   ":",
   "None",
   ",",
   "'gaiak_colors'",
   ":",
   "None",
   ",",
   "'gaia_dists'",
   ":",
   "None",
   ",",
   "'gaia_closest_distarcsec'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'gaia_closest_gmagdiff'",
   ":",
   "np",
   ".",
   "nan",
   "}",
   ")",
   "# finally, search for this object in SIMBAD",
   "if",
   "(",
   "'ra'",
   "in",
   "objectinfo",
   "and",
   "'decl'",
   "in",
   "objectinfo",
   "and",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "search_simbad",
   ")",
   ":",
   "simbad_result",
   "=",
   "simbad",
   ".",
   "objectnames_conesearch",
   "(",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ",",
   "neighbor_radius_arcsec",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   "timeout",
   "=",
   "gaia_submit_timeout",
   ",",
   "maxtimeout",
   "=",
   "gaia_max_timeout",
   ",",
   "maxtries",
   "=",
   "gaia_submit_tries",
   ",",
   "complete_query_later",
   "=",
   "complete_query_later",
   ")",
   "else",
   ":",
   "simbad_result",
   "=",
   "None",
   "if",
   "(",
   "simbad_result",
   "and",
   "simbad_result",
   "[",
   "'result'",
   "]",
   "and",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "simbad_result",
   "[",
   "'result'",
   "]",
   ")",
   ")",
   ":",
   "with",
   "gzip",
   ".",
   "open",
   "(",
   "simbad_result",
   "[",
   "'result'",
   "]",
   ",",
   "'rb'",
   ")",
   "as",
   "infd",
   ":",
   "try",
   ":",
   "simbad_objectnames",
   "=",
   "np",
   ".",
   "genfromtxt",
   "(",
   "infd",
   ",",
   "names",
   "=",
   "True",
   ",",
   "delimiter",
   "=",
   "','",
   ",",
   "dtype",
   "=",
   "'U20,f8,f8,U20,U20,U20,i8,U600,f8'",
   ",",
   "usecols",
   "=",
   "(",
   "0",
   ",",
   "1",
   ",",
   "2",
   ",",
   "3",
   ",",
   "4",
   ",",
   "5",
   ",",
   "6",
   ",",
   "7",
   ",",
   "8",
   ")",
   ",",
   "comments",
   "=",
   "'?'",
   ",",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "simbad_objectnames",
   "=",
   "[",
   "]",
   "simbad_objectnames",
   "=",
   "np",
   ".",
   "atleast_1d",
   "(",
   "simbad_objectnames",
   ")",
   "if",
   "simbad_objectnames",
   ".",
   "size",
   ">",
   "0",
   ":",
   "simbad_mainid",
   "=",
   "simbad_objectnames",
   "[",
   "'main_id'",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "simbad_allids",
   "=",
   "simbad_objectnames",
   "[",
   "'all_ids'",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "simbad_objtype",
   "=",
   "simbad_objectnames",
   "[",
   "'otype_txt'",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "simbad_distarcsec",
   "=",
   "simbad_objectnames",
   "[",
   "'dist_arcsec'",
   "]",
   ".",
   "tolist",
   "(",
   ")",
   "simbad_nmatches",
   "=",
   "len",
   "(",
   "simbad_mainid",
   ")",
   "simbad_mainid",
   "=",
   "[",
   "x",
   ".",
   "replace",
   "(",
   "'\"'",
   ",",
   "''",
   ")",
   "for",
   "x",
   "in",
   "simbad_mainid",
   "]",
   "simbad_allids",
   "=",
   "[",
   "x",
   ".",
   "replace",
   "(",
   "'\"'",
   ",",
   "''",
   ")",
   "for",
   "x",
   "in",
   "simbad_allids",
   "]",
   "simbad_objtype",
   "=",
   "[",
   "x",
   ".",
   "replace",
   "(",
   "'\"'",
   ",",
   "''",
   ")",
   "for",
   "x",
   "in",
   "simbad_objtype",
   "]",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'simbad_nmatches'",
   ":",
   "simbad_nmatches",
   ",",
   "'simbad_mainid'",
   ":",
   "simbad_mainid",
   ",",
   "'simbad_objtype'",
   ":",
   "simbad_objtype",
   ",",
   "'simbad_allids'",
   ":",
   "simbad_allids",
   ",",
   "'simbad_distarcsec'",
   ":",
   "simbad_distarcsec",
   "}",
   ")",
   "if",
   "simbad_nmatches",
   ">",
   "1",
   ":",
   "resultdict",
   "[",
   "'simbad_status'",
   "]",
   "=",
   "(",
   "'ok: multiple SIMBAD matches found'",
   ")",
   "else",
   ":",
   "resultdict",
   "[",
   "'simbad_status'",
   "]",
   "=",
   "'ok: single SIMBAD match'",
   "# get the closest match",
   "if",
   "simbad_distarcsec",
   "[",
   "0",
   "]",
   "<",
   "gaia_matchdist_arcsec",
   ":",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'simbad_best_mainid'",
   ":",
   "simbad_mainid",
   "[",
   "0",
   "]",
   ",",
   "'simbad_best_objtype'",
   ":",
   "simbad_objtype",
   "[",
   "0",
   "]",
   ",",
   "'simbad_best_allids'",
   ":",
   "simbad_allids",
   "[",
   "0",
   "]",
   ",",
   "'simbad_best_distarcsec'",
   ":",
   "simbad_distarcsec",
   "[",
   "0",
   "]",
   ",",
   "'simbad_status'",
   ":",
   "'ok: object found within match radius'",
   "}",
   ")",
   "else",
   ":",
   "LOGWARNING",
   "(",
   "'no SIMBAD objects found within '",
   "'%.3f arcsec of object position (%.3f, %.3f), '",
   "'closest object: %s at %.3f arcsec away'",
   "%",
   "(",
   "gaia_matchdist_arcsec",
   ",",
   "objectinfo",
   "[",
   "'ra'",
   "]",
   ",",
   "objectinfo",
   "[",
   "'decl'",
   "]",
   ",",
   "simbad_mainid",
   "[",
   "0",
   "]",
   ",",
   "simbad_distarcsec",
   "[",
   "0",
   "]",
   ")",
   ")",
   "simbad_status",
   "=",
   "(",
   "'failed: no object within %.3f '",
   "'arcsec, closest = %.3f arcsec'",
   "%",
   "(",
   "gaia_matchdist_arcsec",
   ",",
   "simbad_distarcsec",
   "[",
   "0",
   "]",
   ")",
   ")",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'simbad_best_mainid'",
   ":",
   "None",
   ",",
   "'simbad_best_objtype'",
   ":",
   "None",
   ",",
   "'simbad_best_allids'",
   ":",
   "None",
   ",",
   "'simbad_best_distarcsec'",
   ":",
   "None",
   ",",
   "'simbad_status'",
   ":",
   "simbad_status",
   "}",
   ")",
   "else",
   ":",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'simbad_status'",
   ":",
   "'failed: no SIMBAD matches found'",
   ",",
   "'simbad_nmatches'",
   ":",
   "None",
   ",",
   "'simbad_mainid'",
   ":",
   "None",
   ",",
   "'simbad_objtype'",
   ":",
   "None",
   ",",
   "'simbad_allids'",
   ":",
   "None",
   ",",
   "'simbad_distarcsec'",
   ":",
   "None",
   ",",
   "'simbad_best_mainid'",
   ":",
   "None",
   ",",
   "'simbad_best_objtype'",
   ":",
   "None",
   ",",
   "'simbad_best_allids'",
   ":",
   "None",
   ",",
   "'simbad_best_distarcsec'",
   ":",
   "None",
   ",",
   "}",
   ")",
   "else",
   ":",
   "if",
   "search_simbad",
   ":",
   "simbad_status",
   "=",
   "'failed: SIMBAD query failed'",
   "else",
   ":",
   "simbad_status",
   "=",
   "'failed: SIMBAD query not tried'",
   "resultdict",
   ".",
   "update",
   "(",
   "{",
   "'simbad_status'",
   ":",
   "simbad_status",
   ",",
   "'simbad_nmatches'",
   ":",
   "None",
   ",",
   "'simbad_mainid'",
   ":",
   "None",
   ",",
   "'simbad_objtype'",
   ":",
   "None",
   ",",
   "'simbad_allids'",
   ":",
   "None",
   ",",
   "'simbad_distarcsec'",
   ":",
   "None",
   ",",
   "'simbad_best_mainid'",
   ":",
   "None",
   ",",
   "'simbad_best_objtype'",
   ":",
   "None",
   ",",
   "'simbad_best_allids'",
   ":",
   "None",
   ",",
   "'simbad_best_distarcsec'",
   ":",
   "None",
   ",",
   "}",
   ")",
   "return",
   "resultdict"
  ]
 },
 {
  "idx": "maxmin-551",
  "nl_tokens": [
   "Internal",
   ".",
   "This",
   "is",
   "the",
   "function",
   "that",
   "the",
   "thread",
   "will",
   "execute",
   ".",
   "waits",
   "on",
   "an",
   "event",
   "so",
   "that",
   "the",
   "thread",
   "can",
   "make",
   "a",
   "quick",
   "exit",
   "when",
   "close",
   "()",
   "is",
   "called"
  ],
  "pl_tokens": [
   "def",
   "_wake_up_timer",
   "(",
   "self",
   ",",
   "kill_event",
   ")",
   ":",
   "while",
   "True",
   ":",
   "prev",
   "=",
   "self",
   ".",
   "_wake_up_time",
   "# Waiting for the event returns True only when the event",
   "# is set, usually by the parent thread",
   "time_to_die",
   "=",
   "kill_event",
   ".",
   "wait",
   "(",
   "float",
   "(",
   "<mask>",
   "(",
   "prev",
   "-",
   "time",
   ".",
   "time",
   "(",
   ")",
   ",",
   "0",
   ")",
   ")",
   ")",
   "if",
   "time_to_die",
   ":",
   "return",
   "if",
   "prev",
   "==",
   "self",
   ".",
   "_wake_up_time",
   ":",
   "self",
   ".",
   "make_callback",
   "(",
   "kind",
   "=",
   "'timer'",
   ")",
   "else",
   ":",
   "print",
   "(",
   "\"Sleeping a bit more\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-552",
  "nl_tokens": [
   "Builds",
   "list",
   "of",
   "text",
   "lines",
   "by",
   "splitting",
   "text",
   "lines",
   "at",
   "wrap",
   "point"
  ],
  "pl_tokens": [
   "def",
   "_split_line",
   "(",
   "self",
   ",",
   "data_list",
   ",",
   "line_num",
   ",",
   "text",
   ")",
   ":",
   "# if blank line or context separator, just add it to the output list",
   "if",
   "not",
   "line_num",
   ":",
   "data_list",
   ".",
   "append",
   "(",
   "(",
   "line_num",
   ",",
   "text",
   ")",
   ")",
   "return",
   "# if line text doesn't need wrapping, just add it to the output list",
   "size",
   "=",
   "len",
   "(",
   "text",
   ")",
   "<mask>",
   "=",
   "self",
   ".",
   "_wrapcolumn",
   "if",
   "(",
   "size",
   "<=",
   "max",
   ")",
   "or",
   "(",
   "(",
   "size",
   "-",
   "(",
   "text",
   ".",
   "count",
   "(",
   "'\\0'",
   ")",
   "*",
   "3",
   ")",
   ")",
   "<=",
   "max",
   ")",
   ":",
   "data_list",
   ".",
   "append",
   "(",
   "(",
   "line_num",
   ",",
   "text",
   ")",
   ")",
   "return",
   "# scan text looking for the wrap point, keeping track if the wrap",
   "# point is inside markers",
   "i",
   "=",
   "0",
   "n",
   "=",
   "0",
   "mark",
   "=",
   "''",
   "while",
   "n",
   "<",
   "max",
   "and",
   "i",
   "<",
   "size",
   ":",
   "if",
   "text",
   "[",
   "i",
   "]",
   "==",
   "'\\0'",
   ":",
   "i",
   "+=",
   "1",
   "mark",
   "=",
   "text",
   "[",
   "i",
   "]",
   "i",
   "+=",
   "1",
   "elif",
   "text",
   "[",
   "i",
   "]",
   "==",
   "'\\1'",
   ":",
   "i",
   "+=",
   "1",
   "mark",
   "=",
   "''",
   "else",
   ":",
   "i",
   "+=",
   "1",
   "n",
   "+=",
   "1",
   "# wrap point is inside text, break it up into separate lines",
   "line1",
   "=",
   "text",
   "[",
   ":",
   "i",
   "]",
   "line2",
   "=",
   "text",
   "[",
   "i",
   ":",
   "]",
   "# if wrap point is inside markers, place end marker at end of first",
   "# line and start marker at beginning of second line because each",
   "# line will have its own table tag markup around it.",
   "if",
   "mark",
   ":",
   "line1",
   "=",
   "line1",
   "+",
   "'\\1'",
   "line2",
   "=",
   "'\\0'",
   "+",
   "mark",
   "+",
   "line2",
   "# tack on first line onto the output list",
   "data_list",
   ".",
   "append",
   "(",
   "(",
   "line_num",
   ",",
   "line1",
   ")",
   ")",
   "# use this routine again to wrap the remaining text",
   "self",
   ".",
   "_split_line",
   "(",
   "data_list",
   ",",
   "'>'",
   ",",
   "line2",
   ")"
  ]
 },
 {
  "idx": "maxmin-553",
  "nl_tokens": [
   "The",
   "delimiter",
   "/",
   "should",
   "/",
   "occur",
   "the",
   "same",
   "number",
   "of",
   "times",
   "on",
   "each",
   "row",
   ".",
   "However",
   "due",
   "to",
   "malformed",
   "data",
   "it",
   "may",
   "not",
   ".",
   "We",
   "don",
   "t",
   "want",
   "an",
   "all",
   "or",
   "nothing",
   "approach",
   "so",
   "we",
   "allow",
   "for",
   "small",
   "variations",
   "in",
   "this",
   "number",
   ".",
   "1",
   ")",
   "build",
   "a",
   "table",
   "of",
   "the",
   "frequency",
   "of",
   "each",
   "character",
   "on",
   "every",
   "line",
   ".",
   "2",
   ")",
   "build",
   "a",
   "table",
   "of",
   "frequencies",
   "of",
   "this",
   "frequency",
   "(",
   "meta",
   "-",
   "frequency?",
   ")",
   "e",
   ".",
   "g",
   ".",
   "x",
   "occurred",
   "5",
   "times",
   "in",
   "10",
   "rows",
   "6",
   "times",
   "in",
   "1000",
   "rows",
   "7",
   "times",
   "in",
   "2",
   "rows",
   "3",
   ")",
   "use",
   "the",
   "mode",
   "of",
   "the",
   "meta",
   "-",
   "frequency",
   "to",
   "determine",
   "the",
   "/",
   "expected",
   "/",
   "frequency",
   "for",
   "that",
   "character",
   "4",
   ")",
   "find",
   "out",
   "how",
   "often",
   "the",
   "character",
   "actually",
   "meets",
   "that",
   "goal",
   "5",
   ")",
   "the",
   "character",
   "that",
   "best",
   "meets",
   "its",
   "goal",
   "is",
   "the",
   "delimiter",
   "For",
   "performance",
   "reasons",
   "the",
   "data",
   "is",
   "evaluated",
   "in",
   "chunks",
   "so",
   "it",
   "can",
   "try",
   "and",
   "evaluate",
   "the",
   "smallest",
   "portion",
   "of",
   "the",
   "data",
   "possible",
   "evaluating",
   "additional",
   "chunks",
   "as",
   "necessary",
   "."
  ],
  "pl_tokens": [
   "def",
   "_guess_delimiter",
   "(",
   "self",
   ",",
   "data",
   ",",
   "delimiters",
   ")",
   ":",
   "data",
   "=",
   "filter",
   "(",
   "None",
   ",",
   "data",
   ".",
   "split",
   "(",
   "'\\n'",
   ")",
   ")",
   "ascii",
   "=",
   "[",
   "chr",
   "(",
   "c",
   ")",
   "for",
   "c",
   "in",
   "range",
   "(",
   "127",
   ")",
   "]",
   "# 7-bit ASCII",
   "# build frequency tables",
   "chunkLength",
   "=",
   "<mask>",
   "(",
   "10",
   ",",
   "len",
   "(",
   "data",
   ")",
   ")",
   "iteration",
   "=",
   "0",
   "charFrequency",
   "=",
   "{",
   "}",
   "modes",
   "=",
   "{",
   "}",
   "delims",
   "=",
   "{",
   "}",
   "start",
   ",",
   "end",
   "=",
   "0",
   ",",
   "min",
   "(",
   "chunkLength",
   ",",
   "len",
   "(",
   "data",
   ")",
   ")",
   "while",
   "start",
   "<",
   "len",
   "(",
   "data",
   ")",
   ":",
   "iteration",
   "+=",
   "1",
   "for",
   "line",
   "in",
   "data",
   "[",
   "start",
   ":",
   "end",
   "]",
   ":",
   "for",
   "char",
   "in",
   "ascii",
   ":",
   "metaFrequency",
   "=",
   "charFrequency",
   ".",
   "get",
   "(",
   "char",
   ",",
   "{",
   "}",
   ")",
   "# must count even if frequency is 0",
   "freq",
   "=",
   "line",
   ".",
   "count",
   "(",
   "char",
   ")",
   "# value is the mode",
   "metaFrequency",
   "[",
   "freq",
   "]",
   "=",
   "metaFrequency",
   ".",
   "get",
   "(",
   "freq",
   ",",
   "0",
   ")",
   "+",
   "1",
   "charFrequency",
   "[",
   "char",
   "]",
   "=",
   "metaFrequency",
   "for",
   "char",
   "in",
   "charFrequency",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "items",
   "=",
   "charFrequency",
   "[",
   "char",
   "]",
   ".",
   "items",
   "(",
   ")",
   "if",
   "len",
   "(",
   "items",
   ")",
   "==",
   "1",
   "and",
   "items",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "==",
   "0",
   ":",
   "continue",
   "# get the mode of the frequencies",
   "if",
   "len",
   "(",
   "items",
   ")",
   ">",
   "1",
   ":",
   "modes",
   "[",
   "char",
   "]",
   "=",
   "reduce",
   "(",
   "lambda",
   "a",
   ",",
   "b",
   ":",
   "a",
   "[",
   "1",
   "]",
   ">",
   "b",
   "[",
   "1",
   "]",
   "and",
   "a",
   "or",
   "b",
   ",",
   "items",
   ")",
   "# adjust the mode - subtract the sum of all",
   "# other frequencies",
   "items",
   ".",
   "remove",
   "(",
   "modes",
   "[",
   "char",
   "]",
   ")",
   "modes",
   "[",
   "char",
   "]",
   "=",
   "(",
   "modes",
   "[",
   "char",
   "]",
   "[",
   "0",
   "]",
   ",",
   "modes",
   "[",
   "char",
   "]",
   "[",
   "1",
   "]",
   "-",
   "reduce",
   "(",
   "lambda",
   "a",
   ",",
   "b",
   ":",
   "(",
   "0",
   ",",
   "a",
   "[",
   "1",
   "]",
   "+",
   "b",
   "[",
   "1",
   "]",
   ")",
   ",",
   "items",
   ")",
   "[",
   "1",
   "]",
   ")",
   "else",
   ":",
   "modes",
   "[",
   "char",
   "]",
   "=",
   "items",
   "[",
   "0",
   "]",
   "# build a list of possible delimiters",
   "modeList",
   "=",
   "modes",
   ".",
   "items",
   "(",
   ")",
   "total",
   "=",
   "float",
   "(",
   "chunkLength",
   "*",
   "iteration",
   ")",
   "# (rows of consistent data) / (number of rows) = 100%",
   "consistency",
   "=",
   "1.0",
   "# minimum consistency threshold",
   "threshold",
   "=",
   "0.9",
   "while",
   "len",
   "(",
   "delims",
   ")",
   "==",
   "0",
   "and",
   "consistency",
   ">=",
   "threshold",
   ":",
   "for",
   "k",
   ",",
   "v",
   "in",
   "modeList",
   ":",
   "if",
   "v",
   "[",
   "0",
   "]",
   ">",
   "0",
   "and",
   "v",
   "[",
   "1",
   "]",
   ">",
   "0",
   ":",
   "if",
   "(",
   "(",
   "v",
   "[",
   "1",
   "]",
   "/",
   "total",
   ")",
   ">=",
   "consistency",
   "and",
   "(",
   "delimiters",
   "is",
   "None",
   "or",
   "k",
   "in",
   "delimiters",
   ")",
   ")",
   ":",
   "delims",
   "[",
   "k",
   "]",
   "=",
   "v",
   "consistency",
   "-=",
   "0.01",
   "if",
   "len",
   "(",
   "delims",
   ")",
   "==",
   "1",
   ":",
   "delim",
   "=",
   "delims",
   ".",
   "keys",
   "(",
   ")",
   "[",
   "0",
   "]",
   "skipinitialspace",
   "=",
   "(",
   "data",
   "[",
   "0",
   "]",
   ".",
   "count",
   "(",
   "delim",
   ")",
   "==",
   "data",
   "[",
   "0",
   "]",
   ".",
   "count",
   "(",
   "\"%c \"",
   "%",
   "delim",
   ")",
   ")",
   "return",
   "(",
   "delim",
   ",",
   "skipinitialspace",
   ")",
   "# analyze another chunkLength lines",
   "start",
   "=",
   "end",
   "end",
   "+=",
   "chunkLength",
   "if",
   "not",
   "delims",
   ":",
   "return",
   "(",
   "''",
   ",",
   "0",
   ")",
   "# if there's more than one, fall back to a 'preferred' list",
   "if",
   "len",
   "(",
   "delims",
   ")",
   ">",
   "1",
   ":",
   "for",
   "d",
   "in",
   "self",
   ".",
   "preferred",
   ":",
   "if",
   "d",
   "in",
   "delims",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "skipinitialspace",
   "=",
   "(",
   "data",
   "[",
   "0",
   "]",
   ".",
   "count",
   "(",
   "d",
   ")",
   "==",
   "data",
   "[",
   "0",
   "]",
   ".",
   "count",
   "(",
   "\"%c \"",
   "%",
   "d",
   ")",
   ")",
   "return",
   "(",
   "d",
   ",",
   "skipinitialspace",
   ")",
   "# nothing else indicates a preference, pick the character that",
   "# dominates(?)",
   "items",
   "=",
   "[",
   "(",
   "v",
   ",",
   "k",
   ")",
   "for",
   "(",
   "k",
   ",",
   "v",
   ")",
   "in",
   "delims",
   ".",
   "items",
   "(",
   ")",
   "]",
   "items",
   ".",
   "sort",
   "(",
   ")",
   "delim",
   "=",
   "items",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   "skipinitialspace",
   "=",
   "(",
   "data",
   "[",
   "0",
   "]",
   ".",
   "count",
   "(",
   "delim",
   ")",
   "==",
   "data",
   "[",
   "0",
   "]",
   ".",
   "count",
   "(",
   "\"%c \"",
   "%",
   "delim",
   ")",
   ")",
   "return",
   "(",
   "delim",
   ",",
   "skipinitialspace",
   ")"
  ]
 },
 {
  "idx": "maxmin-554",
  "nl_tokens": [
   "Used",
   "to",
   "plot",
   "a",
   "set",
   "of",
   "coordinates",
   "."
  ],
  "pl_tokens": [
   "def",
   "NonUniformImage",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "fig",
   "=",
   "None",
   ",",
   "cmap",
   "=",
   "None",
   ",",
   "alpha",
   "=",
   "None",
   ",",
   "scalex",
   "=",
   "True",
   ",",
   "scaley",
   "=",
   "True",
   ",",
   "add_cbar",
   "=",
   "True",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "ax",
   "is",
   "None",
   "and",
   "fig",
   "is",
   "None",
   ":",
   "fig",
   ",",
   "ax",
   "=",
   "_setup_axes",
   "(",
   ")",
   "elif",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "fig",
   ".",
   "gca",
   "(",
   ")",
   "elif",
   "fig",
   "is",
   "None",
   ":",
   "fig",
   "=",
   "ax",
   ".",
   "get_figure",
   "(",
   ")",
   "norm",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'norm'",
   ",",
   "None",
   ")",
   "im",
   "=",
   "_mplim",
   ".",
   "NonUniformImage",
   "(",
   "ax",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "vmin",
   "=",
   "kwargs",
   ".",
   "pop",
   "(",
   "'vmin'",
   ",",
   "_np",
   ".",
   "<mask>",
   "(",
   "z",
   ")",
   ")",
   "vmax",
   "=",
   "kwargs",
   ".",
   "pop",
   "(",
   "'vmax'",
   ",",
   "_np",
   ".",
   "max",
   "(",
   "z",
   ")",
   ")",
   "# im.set_clim(vmin=vmin, vmax=vmax)",
   "if",
   "cmap",
   "is",
   "not",
   "None",
   ":",
   "im",
   ".",
   "set_cmap",
   "(",
   "cmap",
   ")",
   "m",
   "=",
   "_cm",
   ".",
   "ScalarMappable",
   "(",
   "cmap",
   "=",
   "im",
   ".",
   "get_cmap",
   "(",
   ")",
   ",",
   "norm",
   "=",
   "norm",
   ")",
   "m",
   ".",
   "set_array",
   "(",
   "z",
   ")",
   "if",
   "add_cbar",
   ":",
   "cax",
   ",",
   "cb",
   "=",
   "_cb",
   "(",
   "ax",
   "=",
   "ax",
   ",",
   "im",
   "=",
   "m",
   ",",
   "fig",
   "=",
   "fig",
   ")",
   "if",
   "alpha",
   "is",
   "not",
   "None",
   ":",
   "im",
   ".",
   "set_alpha",
   "(",
   "alpha",
   ")",
   "im",
   ".",
   "set_data",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ")",
   "ax",
   ".",
   "images",
   ".",
   "append",
   "(",
   "im",
   ")",
   "if",
   "scalex",
   ":",
   "xmin",
   "=",
   "min",
   "(",
   "x",
   ")",
   "xmax",
   "=",
   "max",
   "(",
   "x",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "xmin",
   ",",
   "xmax",
   ")",
   "if",
   "scaley",
   ":",
   "ymin",
   "=",
   "min",
   "(",
   "y",
   ")",
   "ymax",
   "=",
   "max",
   "(",
   "y",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "ymin",
   ",",
   "ymax",
   ")",
   "return",
   "_SI",
   "(",
   "im",
   "=",
   "im",
   ",",
   "cb",
   "=",
   "cb",
   ",",
   "cax",
   "=",
   "cax",
   ")"
  ]
 },
 {
  "idx": "maxmin-555",
  "nl_tokens": [
   "Combine",
   "structure",
   "replicates",
   "into",
   "a",
   "single",
   "indfile",
   "returns",
   "nreps",
   "ninds",
   ".",
   "Excludes",
   "reps",
   "with",
   "too",
   "high",
   "of",
   "variance",
   "(",
   "set",
   "with",
   "max_variance_multiplier",
   ")",
   "to",
   "exclude",
   "runs",
   "that",
   "did",
   "not",
   "converge",
   "."
  ],
  "pl_tokens": [
   "def",
   "_concat_reps",
   "(",
   "self",
   ",",
   "kpop",
   ",",
   "max_var_multiple",
   ",",
   "quiet",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "## make an output handle",
   "outf",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "self",
   ".",
   "workdir",
   ",",
   "\"{}-K-{}.indfile\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "name",
   ",",
   "kpop",
   ")",
   ")",
   "## combine replicates and write to indfile",
   "excluded",
   "=",
   "0",
   "reps",
   "=",
   "[",
   "]",
   "with",
   "open",
   "(",
   "outf",
   ",",
   "'w'",
   ")",
   "as",
   "outfile",
   ":",
   "repfiles",
   "=",
   "glob",
   ".",
   "glob",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "self",
   ".",
   "workdir",
   ",",
   "self",
   ".",
   "name",
   "+",
   "\"-K-{}-rep-*_f\"",
   ".",
   "format",
   "(",
   "kpop",
   ")",
   ")",
   ")",
   "## get result as a Rep object",
   "for",
   "rep",
   "in",
   "repfiles",
   ":",
   "result",
   "=",
   "Rep",
   "(",
   "rep",
   ",",
   "kpop",
   "=",
   "kpop",
   ")",
   "reps",
   ".",
   "append",
   "(",
   "result",
   ")",
   "## exclude results with variance NX above (min) ",
   "newreps",
   "=",
   "[",
   "]",
   "if",
   "len",
   "(",
   "reps",
   ")",
   ">",
   "1",
   ":",
   "min_var_across_reps",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "i",
   ".",
   "var_lnlik",
   "for",
   "i",
   "in",
   "reps",
   "]",
   ")",
   "else",
   ":",
   "min_var_across_reps",
   "=",
   "reps",
   "[",
   "0",
   "]",
   ".",
   "var_lnlik",
   "## iterate over reps",
   "for",
   "rep",
   "in",
   "reps",
   ":",
   "## store result w/o filtering",
   "if",
   "not",
   "max_var_multiple",
   ":",
   "newreps",
   ".",
   "append",
   "(",
   "rep",
   ")",
   "outfile",
   ".",
   "write",
   "(",
   "rep",
   ".",
   "stable",
   ")",
   "## use max-var-multiple as a filter for convergence                ",
   "else",
   ":",
   "#print(",
   "#    rep.var_lnlik, ",
   "#    min_var_across_reps, ",
   "#    rep.var_lnlik / min_var_across_reps, ",
   "#    max_var_multiple)",
   "## e.g., repvar is 1.05X minvar. We keep it if maxvar <= 1.05",
   "if",
   "(",
   "rep",
   ".",
   "var_lnlik",
   "/",
   "min_var_across_reps",
   ")",
   "<=",
   "max_var_multiple",
   ":",
   "newreps",
   ".",
   "append",
   "(",
   "rep",
   ")",
   "outfile",
   ".",
   "write",
   "(",
   "rep",
   ".",
   "stable",
   ")",
   "else",
   ":",
   "excluded",
   "+=",
   "1",
   "return",
   "newreps",
   ",",
   "excluded"
  ]
 },
 {
  "idx": "maxmin-556",
  "nl_tokens": [
   "Fit",
   "a",
   "Savitzky",
   "-",
   "Golay",
   "filter",
   "to",
   "the",
   "magnitude",
   "/",
   "flux",
   "time",
   "series",
   "."
  ],
  "pl_tokens": [
   "def",
   "savgol_fit_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "period",
   ",",
   "windowlength",
   "=",
   "None",
   ",",
   "polydeg",
   "=",
   "2",
   ",",
   "sigclip",
   "=",
   "30.0",
   ",",
   "plotfit",
   "=",
   "False",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "verbose",
   "=",
   "True",
   ")",
   ":",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ")",
   "# get rid of zero errs",
   "nzind",
   "=",
   "npnonzero",
   "(",
   "serrs",
   ")",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "stimes",
   "[",
   "nzind",
   "]",
   ",",
   "smags",
   "[",
   "nzind",
   "]",
   ",",
   "serrs",
   "[",
   "nzind",
   "]",
   "phase",
   ",",
   "pmags",
   ",",
   "perrs",
   ",",
   "ptimes",
   ",",
   "mintime",
   "=",
   "(",
   "get_phased_quantities",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "period",
   ")",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "windowlength",
   ",",
   "int",
   ")",
   ":",
   "windowlength",
   "=",
   "<mask>",
   "(",
   "polydeg",
   "+",
   "3",
   ",",
   "int",
   "(",
   "len",
   "(",
   "phase",
   ")",
   "/",
   "300",
   ")",
   ")",
   "if",
   "windowlength",
   "%",
   "2",
   "==",
   "0",
   ":",
   "windowlength",
   "+=",
   "1",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'applying Savitzky-Golay filter with '",
   "'window length %s and polynomial degree %s to '",
   "'mag series with %s observations, '",
   "'using period %.6f, folded at %.6f'",
   "%",
   "(",
   "windowlength",
   ",",
   "polydeg",
   ",",
   "len",
   "(",
   "pmags",
   ")",
   ",",
   "period",
   ",",
   "mintime",
   ")",
   ")",
   "# generate the function values obtained by applying the SG filter. The",
   "# \"wrap\" option is best for phase-folded LCs.",
   "sgf",
   "=",
   "savgol_filter",
   "(",
   "pmags",
   ",",
   "windowlength",
   ",",
   "polydeg",
   ",",
   "mode",
   "=",
   "'wrap'",
   ")",
   "# here the \"fit\" to the phases is the function produced by the",
   "# Savitzky-Golay filter. then compute the chisq and red-chisq.",
   "fitmags",
   "=",
   "sgf",
   "fitchisq",
   "=",
   "npsum",
   "(",
   "(",
   "(",
   "fitmags",
   "-",
   "pmags",
   ")",
   "*",
   "(",
   "fitmags",
   "-",
   "pmags",
   ")",
   ")",
   "/",
   "(",
   "perrs",
   "*",
   "perrs",
   ")",
   ")",
   "# TODO: quantify dof for SG filter.",
   "nparams",
   "=",
   "int",
   "(",
   "len",
   "(",
   "pmags",
   ")",
   "/",
   "windowlength",
   ")",
   "*",
   "polydeg",
   "fitredchisq",
   "=",
   "fitchisq",
   "/",
   "(",
   "len",
   "(",
   "pmags",
   ")",
   "-",
   "nparams",
   "-",
   "1",
   ")",
   "fitredchisq",
   "=",
   "-",
   "99.",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'SG filter applied. chisq = %.5f, reduced chisq = %.5f'",
   "%",
   "(",
   "fitchisq",
   ",",
   "fitredchisq",
   ")",
   ")",
   "# figure out the time of light curve minimum (i.e. the fit epoch)",
   "# this is when the fit mag is maximum (i.e. the faintest)",
   "# or if magsarefluxes = True, then this is when fit flux is minimum",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "fitmagminind",
   "=",
   "npwhere",
   "(",
   "fitmags",
   "==",
   "npmax",
   "(",
   "fitmags",
   ")",
   ")",
   "else",
   ":",
   "fitmagminind",
   "=",
   "npwhere",
   "(",
   "fitmags",
   "==",
   "npmin",
   "(",
   "fitmags",
   ")",
   ")",
   "if",
   "len",
   "(",
   "fitmagminind",
   "[",
   "0",
   "]",
   ")",
   ">",
   "1",
   ":",
   "fitmagminind",
   "=",
   "(",
   "fitmagminind",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ",",
   ")",
   "magseriesepoch",
   "=",
   "ptimes",
   "[",
   "fitmagminind",
   "]",
   "# assemble the returndict",
   "returndict",
   "=",
   "{",
   "'fittype'",
   ":",
   "'savgol'",
   ",",
   "'fitinfo'",
   ":",
   "{",
   "'windowlength'",
   ":",
   "windowlength",
   ",",
   "'polydeg'",
   ":",
   "polydeg",
   ",",
   "'fitmags'",
   ":",
   "fitmags",
   ",",
   "'fitepoch'",
   ":",
   "magseriesepoch",
   "}",
   ",",
   "'fitchisq'",
   ":",
   "fitchisq",
   ",",
   "'fitredchisq'",
   ":",
   "fitredchisq",
   ",",
   "'fitplotfile'",
   ":",
   "None",
   ",",
   "'magseries'",
   ":",
   "{",
   "'times'",
   ":",
   "ptimes",
   ",",
   "'phase'",
   ":",
   "phase",
   ",",
   "'mags'",
   ":",
   "pmags",
   ",",
   "'errs'",
   ":",
   "perrs",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "# make the fit plot if required",
   "if",
   "plotfit",
   "and",
   "isinstance",
   "(",
   "plotfit",
   ",",
   "str",
   ")",
   ":",
   "make_fit_plot",
   "(",
   "phase",
   ",",
   "pmags",
   ",",
   "perrs",
   ",",
   "fitmags",
   ",",
   "period",
   ",",
   "mintime",
   ",",
   "magseriesepoch",
   ",",
   "plotfit",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ")",
   "returndict",
   "[",
   "'fitplotfile'",
   "]",
   "=",
   "plotfit",
   "return",
   "returndict"
  ]
 },
 {
  "idx": "maxmin-557",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__merge_clusters",
   "(",
   "self",
   ",",
   "cluster1",
   ",",
   "cluster2",
   ")",
   ":",
   "merged_cluster",
   "=",
   "cure_cluster",
   "(",
   "None",
   ",",
   "None",
   ")",
   "merged_cluster",
   ".",
   "points",
   "=",
   "cluster1",
   ".",
   "points",
   "+",
   "cluster2",
   ".",
   "points",
   "merged_cluster",
   ".",
   "indexes",
   "=",
   "cluster1",
   ".",
   "indexes",
   "+",
   "cluster2",
   ".",
   "indexes",
   "# merged_cluster.mean = ( len(cluster1.points) * cluster1.mean + len(cluster2.points) * cluster2.mean ) / ( len(cluster1.points) + len(cluster2.points) );\r",
   "dimension",
   "=",
   "len",
   "(",
   "cluster1",
   ".",
   "mean",
   ")",
   "merged_cluster",
   ".",
   "mean",
   "=",
   "[",
   "0",
   "]",
   "*",
   "dimension",
   "if",
   "merged_cluster",
   ".",
   "points",
   "[",
   "1",
   ":",
   "]",
   "==",
   "merged_cluster",
   ".",
   "points",
   "[",
   ":",
   "-",
   "1",
   "]",
   ":",
   "merged_cluster",
   ".",
   "mean",
   "=",
   "merged_cluster",
   ".",
   "points",
   "[",
   "0",
   "]",
   "else",
   ":",
   "for",
   "index",
   "in",
   "range",
   "(",
   "dimension",
   ")",
   ":",
   "merged_cluster",
   ".",
   "mean",
   "[",
   "index",
   "]",
   "=",
   "(",
   "len",
   "(",
   "cluster1",
   ".",
   "points",
   ")",
   "*",
   "cluster1",
   ".",
   "mean",
   "[",
   "index",
   "]",
   "+",
   "len",
   "(",
   "cluster2",
   ".",
   "points",
   ")",
   "*",
   "cluster2",
   ".",
   "mean",
   "[",
   "index",
   "]",
   ")",
   "/",
   "(",
   "len",
   "(",
   "cluster1",
   ".",
   "points",
   ")",
   "+",
   "len",
   "(",
   "cluster2",
   ".",
   "points",
   ")",
   ")",
   "temporary",
   "=",
   "list",
   "(",
   ")",
   "for",
   "index",
   "in",
   "range",
   "(",
   "self",
   ".",
   "__number_represent_points",
   ")",
   ":",
   "maximal_distance",
   "=",
   "0",
   "maximal_point",
   "=",
   "None",
   "for",
   "point",
   "in",
   "merged_cluster",
   ".",
   "points",
   ":",
   "minimal_distance",
   "=",
   "0",
   "if",
   "index",
   "==",
   "0",
   ":",
   "minimal_distance",
   "=",
   "euclidean_distance_square",
   "(",
   "point",
   ",",
   "merged_cluster",
   ".",
   "mean",
   ")",
   "#minimal_distance = euclidean_distance_sqrt(point, merged_cluster.mean);\r",
   "else",
   ":",
   "minimal_distance",
   "=",
   "<mask>",
   "(",
   "[",
   "euclidean_distance_square",
   "(",
   "point",
   ",",
   "p",
   ")",
   "for",
   "p",
   "in",
   "temporary",
   "]",
   ")",
   "#minimal_distance = cluster_distance(cure_cluster(point), cure_cluster(temporary[0]));\r",
   "if",
   "minimal_distance",
   ">=",
   "maximal_distance",
   ":",
   "maximal_distance",
   "=",
   "minimal_distance",
   "maximal_point",
   "=",
   "point",
   "if",
   "maximal_point",
   "not",
   "in",
   "temporary",
   ":",
   "temporary",
   ".",
   "append",
   "(",
   "maximal_point",
   ")",
   "for",
   "point",
   "in",
   "temporary",
   ":",
   "representative_point",
   "=",
   "[",
   "0",
   "]",
   "*",
   "dimension",
   "for",
   "index",
   "in",
   "range",
   "(",
   "dimension",
   ")",
   ":",
   "representative_point",
   "[",
   "index",
   "]",
   "=",
   "point",
   "[",
   "index",
   "]",
   "+",
   "self",
   ".",
   "__compression",
   "*",
   "(",
   "merged_cluster",
   ".",
   "mean",
   "[",
   "index",
   "]",
   "-",
   "point",
   "[",
   "index",
   "]",
   ")",
   "merged_cluster",
   ".",
   "rep",
   ".",
   "append",
   "(",
   "representative_point",
   ")",
   "return",
   "merged_cluster"
  ]
 },
 {
  "idx": "maxmin-558",
  "nl_tokens": [
   "Return",
   "a",
   "list",
   "of",
   "swarm",
   "generations",
   "that",
   "have",
   "completed",
   "and",
   "the",
   "best",
   "(",
   "minimal",
   ")",
   "errScore",
   "seen",
   "for",
   "each",
   "of",
   "them",
   "."
  ],
  "pl_tokens": [
   "def",
   "getMaturedSwarmGenerations",
   "(",
   "self",
   ")",
   ":",
   "# Return results go in this list",
   "result",
   "=",
   "[",
   "]",
   "# For each of the swarm generations which have had model result updates",
   "# since the last time we were called, see which have completed.",
   "modifiedSwarmGens",
   "=",
   "sorted",
   "(",
   "self",
   ".",
   "_modifiedSwarmGens",
   ")",
   "# Walk through them in order from lowest to highest generation index",
   "for",
   "key",
   "in",
   "modifiedSwarmGens",
   ":",
   "(",
   "swarmId",
   ",",
   "genIdx",
   ")",
   "=",
   "key",
   "# Skip it if we've already reported on it. This should happen rarely, if",
   "#  ever. It means that some worker has started and completed a model in",
   "#  this generation after we've determined that the generation has ended.",
   "if",
   "key",
   "in",
   "self",
   ".",
   "_maturedSwarmGens",
   ":",
   "self",
   ".",
   "_modifiedSwarmGens",
   ".",
   "remove",
   "(",
   "key",
   ")",
   "continue",
   "# If the previous generation for this swarm is not complete yet, don't",
   "#  bother evaluating this one.",
   "if",
   "(",
   "genIdx",
   ">=",
   "1",
   ")",
   "and",
   "not",
   "(",
   "swarmId",
   ",",
   "genIdx",
   "-",
   "1",
   ")",
   "in",
   "self",
   ".",
   "_maturedSwarmGens",
   ":",
   "continue",
   "# We found a swarm generation that had some results reported since last",
   "# time, see if it's complete or not",
   "(",
   "_",
   ",",
   "_",
   ",",
   "errScores",
   ",",
   "completedFlags",
   ",",
   "maturedFlags",
   ")",
   "=",
   "self",
   ".",
   "getParticleInfos",
   "(",
   "swarmId",
   ",",
   "genIdx",
   ")",
   "maturedFlags",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "maturedFlags",
   ")",
   "numMatured",
   "=",
   "maturedFlags",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "numMatured",
   ">=",
   "self",
   ".",
   "_hsObj",
   ".",
   "_minParticlesPerSwarm",
   "and",
   "numMatured",
   "==",
   "len",
   "(",
   "maturedFlags",
   ")",
   ":",
   "errScores",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "errScores",
   ")",
   "bestScore",
   "=",
   "errScores",
   ".",
   "<mask>",
   "(",
   ")",
   "self",
   ".",
   "_maturedSwarmGens",
   ".",
   "add",
   "(",
   "key",
   ")",
   "self",
   ".",
   "_modifiedSwarmGens",
   ".",
   "remove",
   "(",
   "key",
   ")",
   "result",
   ".",
   "append",
   "(",
   "(",
   "swarmId",
   ",",
   "genIdx",
   ",",
   "bestScore",
   ")",
   ")",
   "# Return results",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-559",
  "nl_tokens": [
   "Plots",
   "total",
   "amount",
   "of",
   "stocks",
   "with",
   "an",
   "active",
   "position",
   "breaking",
   "out",
   "short",
   "and",
   "long",
   "into",
   "transparent",
   "filled",
   "regions",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_long_short_holdings",
   "(",
   "returns",
   ",",
   "positions",
   ",",
   "legend_loc",
   "=",
   "'upper left'",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   "positions",
   "=",
   "positions",
   ".",
   "drop",
   "(",
   "'cash'",
   ",",
   "axis",
   "=",
   "'columns'",
   ")",
   "positions",
   "=",
   "positions",
   ".",
   "replace",
   "(",
   "0",
   ",",
   "np",
   ".",
   "nan",
   ")",
   "df_longs",
   "=",
   "positions",
   "[",
   "positions",
   ">",
   "0",
   "]",
   ".",
   "count",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df_shorts",
   "=",
   "positions",
   "[",
   "positions",
   "<",
   "0",
   "]",
   ".",
   "count",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "lf",
   "=",
   "ax",
   ".",
   "fill_between",
   "(",
   "df_longs",
   ".",
   "index",
   ",",
   "0",
   ",",
   "df_longs",
   ".",
   "values",
   ",",
   "color",
   "=",
   "'g'",
   ",",
   "alpha",
   "=",
   "0.5",
   ",",
   "lw",
   "=",
   "2.0",
   ")",
   "sf",
   "=",
   "ax",
   ".",
   "fill_between",
   "(",
   "df_shorts",
   ".",
   "index",
   ",",
   "0",
   ",",
   "df_shorts",
   ".",
   "values",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "alpha",
   "=",
   "0.5",
   ",",
   "lw",
   "=",
   "2.0",
   ")",
   "bf",
   "=",
   "patches",
   ".",
   "Rectangle",
   "(",
   "[",
   "0",
   ",",
   "0",
   "]",
   ",",
   "1",
   ",",
   "1",
   ",",
   "color",
   "=",
   "'darkgoldenrod'",
   ")",
   "leg",
   "=",
   "ax",
   ".",
   "legend",
   "(",
   "[",
   "lf",
   ",",
   "sf",
   ",",
   "bf",
   "]",
   ",",
   "[",
   "'Long (max: %s, min: %s)'",
   "%",
   "(",
   "df_longs",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "df_longs",
   ".",
   "min",
   "(",
   ")",
   ")",
   ",",
   "'Short (max: %s, min: %s)'",
   "%",
   "(",
   "df_shorts",
   ".",
   "max",
   "(",
   ")",
   ",",
   "df_shorts",
   ".",
   "min",
   "(",
   ")",
   ")",
   ",",
   "'Overlap'",
   "]",
   ",",
   "loc",
   "=",
   "legend_loc",
   ",",
   "frameon",
   "=",
   "True",
   ",",
   "framealpha",
   "=",
   "0.5",
   ")",
   "leg",
   ".",
   "get_frame",
   "(",
   ")",
   ".",
   "set_edgecolor",
   "(",
   "'black'",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "returns",
   ".",
   "index",
   "[",
   "0",
   "]",
   ",",
   "returns",
   ".",
   "index",
   "[",
   "-",
   "1",
   "]",
   ")",
   ")",
   "ax",
   ".",
   "set_title",
   "(",
   "'Long and short holdings'",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "'Holdings'",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "''",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-560",
  "nl_tokens": [
   "Extract",
   "the",
   "data",
   "resolution",
   "of",
   "a",
   "query",
   "in",
   "seconds",
   "E",
   ".",
   "g",
   ".",
   "group",
   "by",
   "time",
   "(",
   "99s",
   ")",
   "=",
   ">",
   "99"
  ],
  "pl_tokens": [
   "def",
   "parse",
   "(",
   "self",
   ",",
   "group_by_stmt",
   ")",
   ":",
   "if",
   "not",
   "group_by_stmt",
   ":",
   "return",
   "Resolution",
   ".",
   "MAX_RESOLUTION",
   "m",
   "=",
   "self",
   ".",
   "GROUP_BY_TIME_PATTERN",
   ".",
   "match",
   "(",
   "group_by_stmt",
   ")",
   "if",
   "not",
   "m",
   ":",
   "return",
   "None",
   "value",
   "=",
   "int",
   "(",
   "m",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   "unit",
   "=",
   "m",
   ".",
   "group",
   "(",
   "2",
   ")",
   "resolution",
   "=",
   "self",
   ".",
   "convert_to_seconds",
   "(",
   "value",
   ",",
   "unit",
   ")",
   "# We can't have a higher resolution than the max resolution",
   "return",
   "<mask>",
   "(",
   "resolution",
   ",",
   "Resolution",
   ".",
   "MAX_RESOLUTION",
   ")"
  ]
 },
 {
  "idx": "maxmin-561",
  "nl_tokens": [
   "given",
   "a",
   "sweep",
   "and",
   "a",
   "time",
   "point",
   "return",
   "the",
   "AP",
   "array",
   "for",
   "that",
   "AP",
   ".",
   "APs",
   "will",
   "be",
   "centered",
   "in",
   "time",
   "by",
   "their",
   "maximum",
   "upslope",
   "."
  ],
  "pl_tokens": [
   "def",
   "analyzeAP",
   "(",
   "Y",
   ",",
   "dY",
   ",",
   "I",
   ",",
   "rate",
   ",",
   "verbose",
   "=",
   "False",
   ")",
   ":",
   "Ims",
   "=",
   "int",
   "(",
   "rate",
   "/",
   "1000",
   ")",
   "#Is per MS",
   "IsToLook",
   "=",
   "5",
   "*",
   "Ims",
   "#TODO: clarify this, ms until downslope is over",
   "upslope",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "dY",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   ")",
   "#maximum rise velocity",
   "upslopeI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "dY",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   "==",
   "upslope",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "I",
   "=",
   "upslopeI",
   "#center sweep at the upslope",
   "downslope",
   "=",
   "np",
   ".",
   "min",
   "(",
   "dY",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   ")",
   "#maximum fall velocity",
   "downslopeI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "dY",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   "==",
   "downslope",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "peak",
   "=",
   "np",
   ".",
   "max",
   "(",
   "Y",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   ")",
   "#find peak value (mV)",
   "peakI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "Y",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   "==",
   "peak",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "I",
   "#find peak I",
   "thresholdI",
   "=",
   "I",
   "-",
   "np",
   ".",
   "where",
   "(",
   "dY",
   "[",
   "I",
   ":",
   "I",
   "+",
   "IsToLook",
   ":",
   "-",
   "-",
   "1",
   "]",
   "<",
   "10",
   ")",
   "[",
   "0",
   "]",
   "#detect <10V/S",
   "if",
   "not",
   "len",
   "(",
   "thresholdI",
   ")",
   ":",
   "return",
   "False",
   "thresholdI",
   "=",
   "thresholdI",
   "[",
   "0",
   "]",
   "threshold",
   "=",
   "Y",
   "[",
   "thresholdI",
   "]",
   "# mV where >10mV/S",
   "height",
   "=",
   "peak",
   "-",
   "threshold",
   "# height (mV) from threshold to peak",
   "halfwidthPoint",
   "=",
   "np",
   ".",
   "average",
   "(",
   "(",
   "threshold",
   ",",
   "peak",
   ")",
   ")",
   "halfwidth",
   "=",
   "np",
   ".",
   "where",
   "(",
   "Y",
   "[",
   "I",
   "-",
   "IsToLook",
   ":",
   "I",
   "+",
   "IsToLook",
   "]",
   ">",
   "halfwidthPoint",
   ")",
   "[",
   "0",
   "]",
   "if",
   "not",
   "len",
   "(",
   "halfwidth",
   ")",
   ":",
   "return",
   "False",
   "#doesn't look like a real AP",
   "halfwidthI1",
   "=",
   "halfwidth",
   "[",
   "0",
   "]",
   "+",
   "I",
   "-",
   "IsToLook",
   "halfwidthI2",
   "=",
   "halfwidth",
   "[",
   "-",
   "1",
   "]",
   "+",
   "I",
   "-",
   "IsToLook",
   "if",
   "Y",
   "[",
   "halfwidthI1",
   "-",
   "1",
   "]",
   ">",
   "halfwidthPoint",
   "or",
   "Y",
   "[",
   "halfwidthI2",
   "+",
   "1",
   "]",
   ">",
   "halfwidthPoint",
   ":",
   "return",
   "False",
   "#doesn't look like a real AP",
   "halfwidth",
   "=",
   "len",
   "(",
   "halfwidth",
   ")",
   "/",
   "rate",
   "*",
   "1000",
   "#now in MS",
   "riseTime",
   "=",
   "(",
   "peakI",
   "-",
   "thresholdI",
   ")",
   "*",
   "1000",
   "/",
   "rate",
   "# time (ms) from threshold to peak",
   "IsToLook",
   "=",
   "100",
   "*",
   "Ims",
   "#TODO: max prediction until AHP reaches nadir",
   "AHPchunk",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "Y",
   "[",
   "downslopeI",
   ":",
   "downslopeI",
   "+",
   "IsToLook",
   "]",
   ")",
   "#first inflection",
   "AHPI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "AHPchunk",
   ">",
   "0",
   ")",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "AHPI",
   ")",
   "==",
   "0",
   ":",
   "AHPI",
   "=",
   "np",
   ".",
   "nan",
   "else",
   ":",
   "AHPI",
   "=",
   "AHPI",
   "[",
   "0",
   "]",
   "+",
   "downslopeI",
   "AHPchunk",
   "=",
   "Y",
   "[",
   "AHPI",
   ":",
   "AHPI",
   "+",
   "IsToLook",
   "]",
   "if",
   "max",
   "(",
   "AHPchunk",
   ")",
   ">",
   "threshold",
   ":",
   "#if another AP is coming, cut it out",
   "AHPchunk",
   "=",
   "AHPchunk",
   "[",
   ":",
   "np",
   ".",
   "where",
   "(",
   "AHPchunk",
   ">",
   "threshold",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "]",
   "if",
   "len",
   "(",
   "AHPchunk",
   ")",
   ":",
   "AHP",
   "=",
   "np",
   ".",
   "nanmin",
   "(",
   "AHPchunk",
   ")",
   "AHPI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "AHPchunk",
   "==",
   "AHP",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "+",
   "AHPI",
   "AHPheight",
   "=",
   "threshold",
   "-",
   "AHP",
   "# AHP magnitude from threshold (mV)",
   "IsToLook",
   "=",
   "500",
   "*",
   "Ims",
   "#TODO: max prediction until AHP reaches threshold",
   "AHPreturn",
   "=",
   "np",
   ".",
   "average",
   "(",
   "(",
   "AHP",
   ",",
   "threshold",
   ")",
   ")",
   "#half of threshold",
   "AHPreturnI",
   "=",
   "np",
   ".",
   "where",
   "(",
   "Y",
   "[",
   "AHPI",
   ":",
   "AHPI",
   "+",
   "IsToLook",
   "]",
   ">",
   "AHPreturn",
   ")",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "AHPreturnI",
   ")",
   ":",
   "#not having a clean decay won't cause AP to crash",
   "AHPreturnI",
   "=",
   "AHPreturnI",
   "[",
   "0",
   "]",
   "+",
   "AHPI",
   "AHPrisetime",
   "=",
   "(",
   "AHPreturnI",
   "-",
   "AHPI",
   ")",
   "*",
   "2",
   "/",
   "rate",
   "*",
   "1000",
   "#predicted return time (ms)",
   "AHPupslope",
   "=",
   "AHPheight",
   "/",
   "AHPrisetime",
   "#mV/ms = V/S",
   "AHPreturnFullI",
   "=",
   "(",
   "AHPreturnI",
   "-",
   "AHPI",
   ")",
   "*",
   "2",
   "+",
   "AHPI",
   "else",
   ":",
   "#make them nan so you can do averages later",
   "AHPreturnI",
   ",",
   "AHPrisetime",
   ",",
   "AHPupslope",
   "=",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "downslope",
   "=",
   "np",
   ".",
   "nan",
   "#fasttime (10V/S to 10V/S) #TODO:",
   "#dpp (deriv peak to peak) #TODO:",
   "sweepI",
   ",",
   "sweepT",
   "=",
   "I",
   ",",
   "I",
   "/",
   "rate",
   "# clean up variable names",
   "del",
   "IsToLook",
   ",",
   "I",
   ",",
   "Y",
   ",",
   "dY",
   ",",
   "Ims",
   ",",
   "AHPchunk",
   ",",
   "verbose",
   "#delete what we don't need",
   "return",
   "locals",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-562",
  "nl_tokens": [
   "This",
   "calculates",
   "a",
   "frequency",
   "grid",
   "for",
   "the",
   "period",
   "finding",
   "functions",
   "in",
   "this",
   "module",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_frequency_grid",
   "(",
   "times",
   ",",
   "samplesperpeak",
   "=",
   "5",
   ",",
   "nyquistfactor",
   "=",
   "5",
   ",",
   "minfreq",
   "=",
   "None",
   ",",
   "maxfreq",
   "=",
   "None",
   ",",
   "returnf0dfnf",
   "=",
   "False",
   ")",
   ":",
   "baseline",
   "=",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "times",
   ".",
   "min",
   "(",
   ")",
   "nsamples",
   "=",
   "times",
   ".",
   "size",
   "df",
   "=",
   "1.",
   "/",
   "baseline",
   "/",
   "samplesperpeak",
   "if",
   "minfreq",
   "is",
   "not",
   "None",
   ":",
   "f0",
   "=",
   "minfreq",
   "else",
   ":",
   "f0",
   "=",
   "0.5",
   "*",
   "df",
   "if",
   "maxfreq",
   "is",
   "not",
   "None",
   ":",
   "Nf",
   "=",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "f0",
   ")",
   "/",
   "df",
   ")",
   ")",
   "else",
   ":",
   "Nf",
   "=",
   "int",
   "(",
   "0.5",
   "*",
   "samplesperpeak",
   "*",
   "nyquistfactor",
   "*",
   "nsamples",
   ")",
   "if",
   "returnf0dfnf",
   ":",
   "return",
   "f0",
   ",",
   "df",
   ",",
   "Nf",
   ",",
   "f0",
   "+",
   "df",
   "*",
   "np",
   ".",
   "arange",
   "(",
   "Nf",
   ")",
   "else",
   ":",
   "return",
   "f0",
   "+",
   "df",
   "*",
   "np",
   ".",
   "arange",
   "(",
   "Nf",
   ")"
  ]
 },
 {
  "idx": "maxmin-563",
  "nl_tokens": [
   "Calculate",
   "statistics",
   "aggregations",
   "."
  ],
  "pl_tokens": [
   "def",
   "run",
   "(",
   "self",
   ",",
   "start_date",
   "=",
   "None",
   ",",
   "end_date",
   "=",
   "None",
   ",",
   "update_bookmark",
   "=",
   "True",
   ")",
   ":",
   "# If no events have been indexed there is nothing to aggregate",
   "if",
   "not",
   "Index",
   "(",
   "self",
   ".",
   "event_index",
   ",",
   "using",
   "=",
   "self",
   ".",
   "client",
   ")",
   ".",
   "exists",
   "(",
   ")",
   ":",
   "return",
   "lower_limit",
   "=",
   "start_date",
   "or",
   "self",
   ".",
   "get_bookmark",
   "(",
   ")",
   "# Stop here if no bookmark could be estimated.",
   "if",
   "lower_limit",
   "is",
   "None",
   ":",
   "return",
   "upper_limit",
   "=",
   "<mask>",
   "(",
   "end_date",
   "or",
   "datetime",
   ".",
   "datetime",
   ".",
   "max",
   ",",
   "# ignore if `None`",
   "datetime",
   ".",
   "datetime",
   ".",
   "utcnow",
   "(",
   ")",
   ".",
   "replace",
   "(",
   "microsecond",
   "=",
   "0",
   ")",
   ",",
   "datetime",
   ".",
   "datetime",
   ".",
   "combine",
   "(",
   "lower_limit",
   "+",
   "datetime",
   ".",
   "timedelta",
   "(",
   "self",
   ".",
   "batch_size",
   ")",
   ",",
   "datetime",
   ".",
   "datetime",
   ".",
   "min",
   ".",
   "time",
   "(",
   ")",
   ")",
   ")",
   "while",
   "upper_limit",
   "<=",
   "datetime",
   ".",
   "datetime",
   ".",
   "utcnow",
   "(",
   ")",
   ":",
   "self",
   ".",
   "indices",
   "=",
   "set",
   "(",
   ")",
   "self",
   ".",
   "new_bookmark",
   "=",
   "upper_limit",
   ".",
   "strftime",
   "(",
   "self",
   ".",
   "doc_id_suffix",
   ")",
   "bulk",
   "(",
   "self",
   ".",
   "client",
   ",",
   "self",
   ".",
   "agg_iter",
   "(",
   "lower_limit",
   ",",
   "upper_limit",
   ")",
   ",",
   "stats_only",
   "=",
   "True",
   ",",
   "chunk_size",
   "=",
   "50",
   ")",
   "# Flush all indices which have been modified",
   "current_search_client",
   ".",
   "indices",
   ".",
   "flush",
   "(",
   "index",
   "=",
   "','",
   ".",
   "join",
   "(",
   "self",
   ".",
   "indices",
   ")",
   ",",
   "wait_if_ongoing",
   "=",
   "True",
   ")",
   "if",
   "update_bookmark",
   ":",
   "self",
   ".",
   "set_bookmark",
   "(",
   ")",
   "self",
   ".",
   "indices",
   "=",
   "set",
   "(",
   ")",
   "lower_limit",
   "=",
   "lower_limit",
   "+",
   "datetime",
   ".",
   "timedelta",
   "(",
   "self",
   ".",
   "batch_size",
   ")",
   "upper_limit",
   "=",
   "min",
   "(",
   "end_date",
   "or",
   "datetime",
   ".",
   "datetime",
   ".",
   "max",
   ",",
   "# ignore if `None``",
   "datetime",
   ".",
   "datetime",
   ".",
   "utcnow",
   "(",
   ")",
   ".",
   "replace",
   "(",
   "microsecond",
   "=",
   "0",
   ")",
   ",",
   "lower_limit",
   "+",
   "datetime",
   ".",
   "timedelta",
   "(",
   "self",
   ".",
   "batch_size",
   ")",
   ")",
   "if",
   "lower_limit",
   ">",
   "upper_limit",
   ":",
   "break"
  ]
 },
 {
  "idx": "maxmin-564",
  "nl_tokens": [
   "Finds",
   "the",
   "biggest",
   "region",
   "size",
   "for",
   "LM",
   "particle",
   "optimization",
   "with",
   "a",
   "given",
   "memory",
   "constraint",
   "."
  ],
  "pl_tokens": [
   "def",
   "calc_particle_group_region_size",
   "(",
   "s",
   ",",
   "region_size",
   "=",
   "40",
   ",",
   "max_mem",
   "=",
   "1e9",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "region_size",
   "=",
   "np",
   ".",
   "array",
   "(",
   "region_size",
   ")",
   ".",
   "astype",
   "(",
   "'int'",
   ")",
   "def",
   "calc_mem_usage",
   "(",
   "region_size",
   ")",
   ":",
   "rs",
   "=",
   "np",
   ".",
   "array",
   "(",
   "region_size",
   ")",
   "particle_groups",
   "=",
   "separate_particles_into_groups",
   "(",
   "s",
   ",",
   "region_size",
   "=",
   "rs",
   ".",
   "tolist",
   "(",
   ")",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "# The actual mem usage is the max of the memory usage of all the",
   "# particle groups. However this is too slow. So instead we use the",
   "# max of the memory of the biggest 5 particle groups:",
   "numpart",
   "=",
   "[",
   "np",
   ".",
   "size",
   "(",
   "g",
   ")",
   "for",
   "g",
   "in",
   "particle_groups",
   "]",
   "biggroups",
   "=",
   "[",
   "particle_groups",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "np",
   ".",
   "argsort",
   "(",
   "numpart",
   ")",
   "[",
   "-",
   "5",
   ":",
   "]",
   "]",
   "def",
   "get_tile_jsize",
   "(",
   "group",
   ")",
   ":",
   "nms",
   "=",
   "s",
   ".",
   "param_particle",
   "(",
   "group",
   ")",
   "tile",
   "=",
   "s",
   ".",
   "get_update_io_tiles",
   "(",
   "nms",
   ",",
   "s",
   ".",
   "get_values",
   "(",
   "nms",
   ")",
   ")",
   "[",
   "2",
   "]",
   "return",
   "tile",
   ".",
   "shape",
   ".",
   "prod",
   "(",
   ")",
   "*",
   "len",
   "(",
   "nms",
   ")",
   "mems",
   "=",
   "[",
   "8",
   "*",
   "get_tile_jsize",
   "(",
   "g",
   ")",
   "for",
   "g",
   "in",
   "biggroups",
   "]",
   "# 8 for bytes/float64",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "mems",
   ")",
   "im_shape",
   "=",
   "s",
   ".",
   "oshape",
   ".",
   "shape",
   "if",
   "calc_mem_usage",
   "(",
   "region_size",
   ")",
   ">",
   "max_mem",
   ":",
   "while",
   "(",
   "(",
   "calc_mem_usage",
   "(",
   "region_size",
   ")",
   ">",
   "max_mem",
   ")",
   "and",
   "np",
   ".",
   "any",
   "(",
   "region_size",
   ">",
   "2",
   ")",
   ")",
   ":",
   "region_size",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "region_size",
   "-",
   "1",
   ",",
   "2",
   ",",
   "im_shape",
   ")",
   "else",
   ":",
   "while",
   "(",
   "(",
   "calc_mem_usage",
   "(",
   "region_size",
   ")",
   "<",
   "max_mem",
   ")",
   "and",
   "np",
   ".",
   "any",
   "(",
   "region_size",
   "<",
   "im_shape",
   ")",
   ")",
   ":",
   "region_size",
   "=",
   "np",
   ".",
   "clip",
   "(",
   "region_size",
   "+",
   "1",
   ",",
   "2",
   ",",
   "im_shape",
   ")",
   "region_size",
   "-=",
   "1",
   "#need to be < memory, so we undo 1 iteration",
   "return",
   "region_size"
  ]
 },
 {
  "idx": "maxmin-565",
  "nl_tokens": [
   "Highest",
   "value",
   "of",
   "input",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "imgmax",
   "(",
   "self",
   ")",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "self",
   ",",
   "'_imgmax'",
   ")",
   ":",
   "imgmax",
   "=",
   "_np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "images",
   "[",
   "0",
   "]",
   ")",
   "for",
   "img",
   "in",
   "self",
   ".",
   "images",
   ":",
   "imax",
   "=",
   "_np",
   ".",
   "max",
   "(",
   "img",
   ")",
   "if",
   "imax",
   ">",
   "imgmax",
   ":",
   "imgmax",
   "=",
   "imax",
   "self",
   ".",
   "_imgmax",
   "=",
   "imgmax",
   "return",
   "self",
   ".",
   "_imgmax"
  ]
 },
 {
  "idx": "maxmin-566",
  "nl_tokens": [
   "Args",
   ":",
   "input",
   "(",
   "str",
   ")",
   ":",
   "A",
   "partial",
   "string",
   "which",
   "is",
   "typically",
   "entered",
   "by",
   "a",
   "user",
   ".",
   "collection",
   "(",
   "iterable",
   ")",
   ":",
   "A",
   "collection",
   "of",
   "strings",
   "which",
   "will",
   "be",
   "filtered",
   "based",
   "on",
   "the",
   "input",
   ".",
   "accessor",
   "(",
   "function",
   ")",
   ":",
   "If",
   "the",
   "collection",
   "is",
   "not",
   "an",
   "iterable",
   "of",
   "strings",
   "then",
   "use",
   "the",
   "accessor",
   "to",
   "fetch",
   "the",
   "string",
   "that",
   "will",
   "be",
   "used",
   "for",
   "fuzzy",
   "matching",
   ".",
   "sort_results",
   "(",
   "bool",
   ")",
   ":",
   "The",
   "suggestions",
   "are",
   "sorted",
   "by",
   "considering",
   "the",
   "smallest",
   "contiguous",
   "match",
   "followed",
   "by",
   "where",
   "the",
   "match",
   "is",
   "found",
   "in",
   "the",
   "full",
   "string",
   ".",
   "If",
   "two",
   "suggestions",
   "have",
   "the",
   "same",
   "rank",
   "they",
   "are",
   "then",
   "sorted",
   "alpha",
   "-",
   "numerically",
   ".",
   "This",
   "parameter",
   "controls",
   "the",
   "*",
   "last",
   "tie",
   "-",
   "breaker",
   "-",
   "alpha",
   "-",
   "numeric",
   "sorting",
   "*",
   ".",
   "The",
   "sorting",
   "based",
   "on",
   "match",
   "length",
   "and",
   "position",
   "will",
   "be",
   "intact",
   "."
  ],
  "pl_tokens": [
   "def",
   "fuzzyfinder",
   "(",
   "input",
   ",",
   "collection",
   ",",
   "accessor",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   ",",
   "sort_results",
   "=",
   "True",
   ")",
   ":",
   "suggestions",
   "=",
   "[",
   "]",
   "input",
   "=",
   "str",
   "(",
   "input",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "input",
   ",",
   "str",
   ")",
   "else",
   "input",
   "pat",
   "=",
   "'.*?'",
   ".",
   "join",
   "(",
   "map",
   "(",
   "re",
   ".",
   "escape",
   ",",
   "input",
   ")",
   ")",
   "pat",
   "=",
   "'(?=({0}))'",
   ".",
   "format",
   "(",
   "pat",
   ")",
   "# lookahead regex to manage overlapping matches",
   "regex",
   "=",
   "re",
   ".",
   "compile",
   "(",
   "pat",
   ",",
   "re",
   ".",
   "IGNORECASE",
   ")",
   "for",
   "item",
   "in",
   "collection",
   ":",
   "r",
   "=",
   "list",
   "(",
   "regex",
   ".",
   "finditer",
   "(",
   "accessor",
   "(",
   "item",
   ")",
   ")",
   ")",
   "if",
   "r",
   ":",
   "best",
   "=",
   "<mask>",
   "(",
   "r",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   ")",
   "# find shortest match",
   "suggestions",
   ".",
   "append",
   "(",
   "(",
   "len",
   "(",
   "best",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   ",",
   "best",
   ".",
   "start",
   "(",
   ")",
   ",",
   "accessor",
   "(",
   "item",
   ")",
   ",",
   "item",
   ")",
   ")",
   "if",
   "sort_results",
   ":",
   "return",
   "(",
   "z",
   "[",
   "-",
   "1",
   "]",
   "for",
   "z",
   "in",
   "sorted",
   "(",
   "suggestions",
   ")",
   ")",
   "else",
   ":",
   "return",
   "(",
   "z",
   "[",
   "-",
   "1",
   "]",
   "for",
   "z",
   "in",
   "sorted",
   "(",
   "suggestions",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   ":",
   "2",
   "]",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-567",
  "nl_tokens": [
   "Find",
   "reactions",
   "that",
   "cannot",
   "carry",
   "any",
   "flux",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_blocked_reactions",
   "(",
   "model",
   ",",
   "reaction_list",
   "=",
   "None",
   ",",
   "zero_cutoff",
   "=",
   "None",
   ",",
   "open_exchanges",
   "=",
   "False",
   ",",
   "processes",
   "=",
   "None",
   ")",
   ":",
   "zero_cutoff",
   "=",
   "normalize_cutoff",
   "(",
   "model",
   ",",
   "zero_cutoff",
   ")",
   "with",
   "model",
   ":",
   "if",
   "open_exchanges",
   ":",
   "for",
   "reaction",
   "in",
   "model",
   ".",
   "exchanges",
   ":",
   "reaction",
   ".",
   "bounds",
   "=",
   "(",
   "<mask>",
   "(",
   "reaction",
   ".",
   "lower_bound",
   ",",
   "-",
   "1000",
   ")",
   ",",
   "max",
   "(",
   "reaction",
   ".",
   "upper_bound",
   ",",
   "1000",
   ")",
   ")",
   "if",
   "reaction_list",
   "is",
   "None",
   ":",
   "reaction_list",
   "=",
   "model",
   ".",
   "reactions",
   "# Limit the search space to reactions which have zero flux. If the",
   "# reactions already carry flux in this solution,",
   "# then they cannot be blocked.",
   "model",
   ".",
   "slim_optimize",
   "(",
   ")",
   "solution",
   "=",
   "get_solution",
   "(",
   "model",
   ",",
   "reactions",
   "=",
   "reaction_list",
   ")",
   "reaction_list",
   "=",
   "solution",
   ".",
   "fluxes",
   "[",
   "solution",
   ".",
   "fluxes",
   ".",
   "abs",
   "(",
   ")",
   "<",
   "zero_cutoff",
   "]",
   ".",
   "index",
   ".",
   "tolist",
   "(",
   ")",
   "# Run FVA to find reactions where both the minimal and maximal flux",
   "# are zero (below the cut off).",
   "flux_span",
   "=",
   "flux_variability_analysis",
   "(",
   "model",
   ",",
   "fraction_of_optimum",
   "=",
   "0.",
   ",",
   "reaction_list",
   "=",
   "reaction_list",
   ",",
   "processes",
   "=",
   "processes",
   ")",
   "return",
   "flux_span",
   "[",
   "flux_span",
   ".",
   "abs",
   "(",
   ")",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "<",
   "zero_cutoff",
   "]",
   ".",
   "index",
   ".",
   "tolist",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-568",
  "nl_tokens": [
   "Turns",
   "an",
   "array",
   "A",
   "of",
   "length",
   "N",
   "(",
   "the",
   "function",
   "values",
   "in",
   "N",
   "points",
   ")",
   "and",
   "an",
   "array",
   "dF",
   "of",
   "length",
   "N",
   "-",
   "1",
   "(",
   "the",
   "masses",
   "of",
   "the",
   "N",
   "-",
   "1",
   "intervals",
   ")",
   "into",
   "an",
   "array",
   "of",
   "length",
   "N",
   "(",
   "the",
   "integral",
   "\\",
   "int",
   "A",
   "dF",
   "at",
   "N",
   "points",
   "with",
   "first",
   "entry",
   "0",
   ")",
   ":",
   "param",
   "A",
   ":",
   "Integrand",
   "(",
   "optional",
   "default",
   "ones",
   "length",
   "N",
   ")",
   ":",
   "param",
   "dF",
   ":",
   "Integrator",
   "(",
   "optional",
   "default",
   "ones",
   "length",
   "N",
   "-",
   "1",
   ")",
   ":",
   "param",
   "F",
   ":",
   "Alternative",
   "to",
   "dF",
   "(",
   "optional",
   "length",
   "N",
   ")",
   ":",
   "param",
   "trapez",
   ":",
   "Use",
   "trapezoidal",
   "rule",
   "(",
   "else",
   "left",
   "point",
   ")"
  ],
  "pl_tokens": [
   "def",
   "integral",
   "(",
   "A",
   "=",
   "None",
   ",",
   "dF",
   "=",
   "None",
   ",",
   "F",
   "=",
   "None",
   ",",
   "axis",
   "=",
   "0",
   ",",
   "trapez",
   "=",
   "False",
   ",",
   "cumulative",
   "=",
   "False",
   ")",
   ":",
   "ndim",
   "=",
   "<mask>",
   "(",
   "v",
   ".",
   "ndim",
   "for",
   "v",
   "in",
   "(",
   "A",
   ",",
   "dF",
   ",",
   "F",
   ")",
   "if",
   "v",
   "is",
   "not",
   "None",
   ")",
   "def",
   "broadcast",
   "(",
   "x",
   ")",
   ":",
   "new_shape",
   "=",
   "[",
   "1",
   "]",
   "*",
   "ndim",
   "new_shape",
   "[",
   "axis",
   "]",
   "=",
   "-",
   "1",
   "return",
   "np",
   ".",
   "reshape",
   "(",
   "x",
   ",",
   "new_shape",
   ")",
   "if",
   "F",
   "is",
   "not",
   "None",
   ":",
   "assert",
   "(",
   "dF",
   "is",
   "None",
   ")",
   "if",
   "F",
   ".",
   "ndim",
   "<",
   "ndim",
   ":",
   "F",
   "=",
   "broadcast",
   "(",
   "F",
   ")",
   "N",
   "=",
   "F",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   "dF",
   "=",
   "F",
   ".",
   "take",
   "(",
   "indices",
   "=",
   "range",
   "(",
   "1",
   ",",
   "N",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   "-",
   "F",
   ".",
   "take",
   "(",
   "indices",
   "=",
   "range",
   "(",
   "N",
   "-",
   "1",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   "elif",
   "dF",
   "is",
   "not",
   "None",
   ":",
   "if",
   "dF",
   ".",
   "ndim",
   "<",
   "ndim",
   ":",
   "dF",
   "=",
   "broadcast",
   "(",
   "dF",
   ")",
   "N",
   "=",
   "dF",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   "+",
   "1",
   "else",
   ":",
   "if",
   "A",
   ".",
   "ndim",
   "<",
   "ndim",
   ":",
   "A",
   "=",
   "broadcast",
   "(",
   "A",
   ")",
   "N",
   "=",
   "A",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   "if",
   "A",
   "is",
   "not",
   "None",
   ":",
   "if",
   "trapez",
   ":",
   "midA",
   "=",
   "(",
   "A",
   ".",
   "take",
   "(",
   "indices",
   "=",
   "range",
   "(",
   "1",
   ",",
   "N",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   "+",
   "A",
   ".",
   "take",
   "(",
   "indices",
   "=",
   "range",
   "(",
   "N",
   "-",
   "1",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   ")",
   "/",
   "2",
   "else",
   ":",
   "midA",
   "=",
   "A",
   ".",
   "take",
   "(",
   "indices",
   "=",
   "range",
   "(",
   "N",
   "-",
   "1",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   "if",
   "dF",
   "is",
   "not",
   "None",
   ":",
   "dY",
   "=",
   "midA",
   "*",
   "dF",
   "else",
   ":",
   "dY",
   "=",
   "midA",
   "else",
   ":",
   "dY",
   "=",
   "dF",
   "pad_shape",
   "=",
   "list",
   "(",
   "dY",
   ".",
   "shape",
   ")",
   "pad_shape",
   "[",
   "axis",
   "]",
   "=",
   "1",
   "pad",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "pad_shape",
   ")",
   "if",
   "cumulative",
   ":",
   "return",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "pad",
   ",",
   "np",
   ".",
   "cumsum",
   "(",
   "dY",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   "else",
   ":",
   "return",
   "np",
   ".",
   "sum",
   "(",
   "dY",
   ",",
   "axis",
   "=",
   "axis",
   ")"
  ]
 },
 {
  "idx": "maxmin-569",
  "nl_tokens": [
   "Loads",
   "the",
   "process",
   "pyramid",
   "of",
   "a",
   "raw",
   "configuration",
   "."
  ],
  "pl_tokens": [
   "def",
   "bounds_from_opts",
   "(",
   "wkt_geometry",
   "=",
   "None",
   ",",
   "point",
   "=",
   "None",
   ",",
   "bounds",
   "=",
   "None",
   ",",
   "zoom",
   "=",
   "None",
   ",",
   "raw_conf",
   "=",
   "None",
   ")",
   ":",
   "if",
   "wkt_geometry",
   ":",
   "return",
   "wkt",
   ".",
   "loads",
   "(",
   "wkt_geometry",
   ")",
   ".",
   "bounds",
   "elif",
   "point",
   ":",
   "x",
   ",",
   "y",
   "=",
   "point",
   "zoom_levels",
   "=",
   "get_zoom_levels",
   "(",
   "process_zoom_levels",
   "=",
   "raw_conf",
   "[",
   "\"zoom_levels\"",
   "]",
   ",",
   "init_zoom_levels",
   "=",
   "zoom",
   ")",
   "tp",
   "=",
   "raw_conf_process_pyramid",
   "(",
   "raw_conf",
   ")",
   "return",
   "tp",
   ".",
   "tile_from_xy",
   "(",
   "x",
   ",",
   "y",
   ",",
   "<mask>",
   "(",
   "zoom_levels",
   ")",
   ")",
   ".",
   "bounds",
   "else",
   ":",
   "return",
   "bounds"
  ]
 },
 {
  "idx": "maxmin-570",
  "nl_tokens": [
   "Build",
   "per",
   "minute",
   "stats",
   "for",
   "each",
   "key"
  ],
  "pl_tokens": [
   "def",
   "stats",
   "(",
   "cls",
   ",",
   "traces",
   ")",
   ":",
   "data",
   "=",
   "{",
   "}",
   "stats",
   "=",
   "{",
   "}",
   "# Group traces by key and minute",
   "for",
   "trace",
   "in",
   "traces",
   ":",
   "key",
   "=",
   "trace",
   "[",
   "'key'",
   "]",
   "if",
   "key",
   "not",
   "in",
   "data",
   ":",
   "data",
   "[",
   "key",
   "]",
   "=",
   "[",
   "]",
   "stats",
   "[",
   "key",
   "]",
   "=",
   "{",
   "}",
   "data",
   "[",
   "key",
   "]",
   ".",
   "append",
   "(",
   "trace",
   "[",
   "'total_time'",
   "]",
   ")",
   "cls",
   ".",
   "_traces",
   ".",
   "pop",
   "(",
   "trace",
   "[",
   "'id'",
   "]",
   ")",
   "for",
   "key",
   "in",
   "data",
   ":",
   "times",
   "=",
   "data",
   "[",
   "key",
   "]",
   "stats",
   "[",
   "key",
   "]",
   "=",
   "dict",
   "(",
   "count",
   "=",
   "len",
   "(",
   "times",
   ")",
   ",",
   "<mask>",
   "=",
   "max",
   "(",
   "times",
   ")",
   ",",
   "min",
   "=",
   "min",
   "(",
   "times",
   ")",
   ",",
   "avg",
   "=",
   "sum",
   "(",
   "times",
   ")",
   "/",
   "len",
   "(",
   "times",
   ")",
   ")",
   "return",
   "stats"
  ]
 },
 {
  "idx": "maxmin-571",
  "nl_tokens": [
   "Clips",
   "bounds",
   "by",
   "clip",
   "."
  ],
  "pl_tokens": [
   "def",
   "clip_bounds",
   "(",
   "bounds",
   "=",
   "None",
   ",",
   "clip",
   "=",
   "None",
   ")",
   ":",
   "bounds",
   "=",
   "Bounds",
   "(",
   "*",
   "bounds",
   ")",
   "clip",
   "=",
   "Bounds",
   "(",
   "*",
   "clip",
   ")",
   "return",
   "Bounds",
   "(",
   "<mask>",
   "(",
   "bounds",
   ".",
   "left",
   ",",
   "clip",
   ".",
   "left",
   ")",
   ",",
   "max",
   "(",
   "bounds",
   ".",
   "bottom",
   ",",
   "clip",
   ".",
   "bottom",
   ")",
   ",",
   "min",
   "(",
   "bounds",
   ".",
   "right",
   ",",
   "clip",
   ".",
   "right",
   ")",
   ",",
   "min",
   "(",
   "bounds",
   ".",
   "top",
   ",",
   "clip",
   ".",
   "top",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-572",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__calculate_changes",
   "(",
   "self",
   ",",
   "updated_centers",
   ")",
   ":",
   "changes",
   "=",
   "numpy",
   ".",
   "sum",
   "(",
   "numpy",
   ".",
   "square",
   "(",
   "self",
   ".",
   "__centers",
   "-",
   "updated_centers",
   ")",
   ",",
   "axis",
   "=",
   "1",
   ")",
   ".",
   "T",
   "return",
   "numpy",
   ".",
   "<mask>",
   "(",
   "changes",
   ")"
  ]
 },
 {
  "idx": "maxmin-573",
  "nl_tokens": [
   "Return",
   "true",
   "if",
   "range",
   "is",
   "approximately",
   "in",
   "same",
   "order",
   "of",
   "magnitude"
  ],
  "pl_tokens": [
   "def",
   "same_log10_order_of_magnitude",
   "(",
   "x",
   ",",
   "delta",
   "=",
   "0.1",
   ")",
   ":",
   "dmin",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   "*",
   "(",
   "1",
   "-",
   "delta",
   ")",
   ")",
   "dmax",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "*",
   "(",
   "1",
   "+",
   "delta",
   ")",
   ")",
   "return",
   "np",
   ".",
   "floor",
   "(",
   "dmin",
   ")",
   "==",
   "np",
   ".",
   "floor",
   "(",
   "dmax",
   ")"
  ]
 },
 {
  "idx": "maxmin-574",
  "nl_tokens": [
   "This",
   "generates",
   "fake",
   "sinusoidal",
   "light",
   "curves",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_sinusoidal_lightcurve",
   "(",
   "times",
   ",",
   "mags",
   "=",
   "None",
   ",",
   "errs",
   "=",
   "None",
   ",",
   "paramdists",
   "=",
   "{",
   "'period'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.04",
   ",",
   "scale",
   "=",
   "500.0",
   ")",
   ",",
   "'fourierorder'",
   ":",
   "[",
   "2",
   ",",
   "10",
   "]",
   ",",
   "'amplitude'",
   ":",
   "sps",
   ".",
   "uniform",
   "(",
   "loc",
   "=",
   "0.1",
   ",",
   "scale",
   "=",
   "0.9",
   ")",
   ",",
   "'phioffset'",
   ":",
   "0.0",
   ",",
   "}",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ")",
   ":",
   "if",
   "mags",
   "is",
   "None",
   ":",
   "mags",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "if",
   "errs",
   "is",
   "None",
   ":",
   "errs",
   "=",
   "np",
   ".",
   "full_like",
   "(",
   "times",
   ",",
   "0.0",
   ")",
   "# choose the epoch",
   "epoch",
   "=",
   "npr",
   ".",
   "random",
   "(",
   ")",
   "*",
   "(",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "times",
   ".",
   "min",
   "(",
   ")",
   ")",
   "+",
   "times",
   ".",
   "min",
   "(",
   ")",
   "# choose the period, fourierorder, and amplitude",
   "period",
   "=",
   "paramdists",
   "[",
   "'period'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "fourierorder",
   "=",
   "npr",
   ".",
   "randint",
   "(",
   "paramdists",
   "[",
   "'fourierorder'",
   "]",
   "[",
   "0",
   "]",
   ",",
   "high",
   "=",
   "paramdists",
   "[",
   "'fourierorder'",
   "]",
   "[",
   "1",
   "]",
   ")",
   "amplitude",
   "=",
   "paramdists",
   "[",
   "'amplitude'",
   "]",
   ".",
   "rvs",
   "(",
   "size",
   "=",
   "1",
   ")",
   "# fix the amplitude if it needs to be flipped",
   "if",
   "magsarefluxes",
   "and",
   "amplitude",
   "<",
   "0.0",
   ":",
   "amplitude",
   "=",
   "-",
   "amplitude",
   "elif",
   "not",
   "magsarefluxes",
   "and",
   "amplitude",
   ">",
   "0.0",
   ":",
   "amplitude",
   "=",
   "-",
   "amplitude",
   "# generate the amplitudes and phases of the Fourier components",
   "ampcomps",
   "=",
   "[",
   "abs",
   "(",
   "amplitude",
   "/",
   "2.0",
   ")",
   "/",
   "float",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "range",
   "(",
   "1",
   ",",
   "fourierorder",
   "+",
   "1",
   ")",
   "]",
   "phacomps",
   "=",
   "[",
   "paramdists",
   "[",
   "'phioffset'",
   "]",
   "*",
   "float",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "range",
   "(",
   "1",
   ",",
   "fourierorder",
   "+",
   "1",
   ")",
   "]",
   "# now that we have our amp and pha components, generate the light curve",
   "modelmags",
   ",",
   "phase",
   ",",
   "ptimes",
   ",",
   "pmags",
   ",",
   "perrs",
   "=",
   "sinusoidal",
   ".",
   "sine_series_sum",
   "(",
   "[",
   "period",
   ",",
   "epoch",
   ",",
   "ampcomps",
   ",",
   "phacomps",
   "]",
   ",",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ")",
   "# resort in original time order",
   "timeind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "ptimes",
   ")",
   "mtimes",
   "=",
   "ptimes",
   "[",
   "timeind",
   "]",
   "mmags",
   "=",
   "modelmags",
   "[",
   "timeind",
   "]",
   "merrs",
   "=",
   "perrs",
   "[",
   "timeind",
   "]",
   "mphase",
   "=",
   "phase",
   "[",
   "timeind",
   "]",
   "# return a dict with everything",
   "modeldict",
   "=",
   "{",
   "'vartype'",
   ":",
   "'sinusoidal'",
   ",",
   "'params'",
   ":",
   "{",
   "x",
   ":",
   "y",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "[",
   "'period'",
   ",",
   "'epoch'",
   ",",
   "'amplitude'",
   ",",
   "'fourierorder'",
   ",",
   "'fourieramps'",
   ",",
   "'fourierphases'",
   "]",
   ",",
   "[",
   "period",
   ",",
   "epoch",
   ",",
   "amplitude",
   ",",
   "fourierorder",
   ",",
   "ampcomps",
   ",",
   "phacomps",
   "]",
   ")",
   "}",
   ",",
   "'times'",
   ":",
   "mtimes",
   ",",
   "'mags'",
   ":",
   "mmags",
   ",",
   "'errs'",
   ":",
   "merrs",
   ",",
   "'phase'",
   ":",
   "mphase",
   ",",
   "# these are standard keys that help with later characterization of",
   "# variability as a function period, variability amplitude, object mag,",
   "# ndet, etc.",
   "'varperiod'",
   ":",
   "period",
   ",",
   "'varamplitude'",
   ":",
   "amplitude",
   "}",
   "return",
   "modeldict"
  ]
 },
 {
  "idx": "maxmin-575",
  "nl_tokens": [
   "Runs",
   "the",
   "Box",
   "Least",
   "Squares",
   "Fitting",
   "Search",
   "for",
   "transit",
   "-",
   "shaped",
   "signals",
   "."
  ],
  "pl_tokens": [
   "def",
   "bls_parallel_pfind",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "startp",
   "=",
   "0.1",
   ",",
   "# by default, search from 0.1 d to...",
   "endp",
   "=",
   "100.0",
   ",",
   "# ... 100.0 d -- don't search full timebase",
   "stepsize",
   "=",
   "1.0e-4",
   ",",
   "mintransitduration",
   "=",
   "0.01",
   ",",
   "# minimum transit length in phase",
   "maxtransitduration",
   "=",
   "0.4",
   ",",
   "# maximum transit length in phase",
   "ndurations",
   "=",
   "100",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "# figure out f0, nf, and df automatically",
   "blsobjective",
   "=",
   "'likelihood'",
   ",",
   "blsmethod",
   "=",
   "'fast'",
   ",",
   "blsoversample",
   "=",
   "5",
   ",",
   "blsmintransits",
   "=",
   "3",
   ",",
   "blsfreqfactor",
   "=",
   "10.0",
   ",",
   "nbestpeaks",
   "=",
   "5",
   ",",
   "periodepsilon",
   "=",
   "0.1",
   ",",
   "# 0.1",
   "sigclip",
   "=",
   "10.0",
   ",",
   "verbose",
   "=",
   "True",
   ",",
   "nworkers",
   "=",
   "None",
   ",",
   ")",
   ":",
   "# get rid of nans first and sigclip",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# if we're setting up everything automatically",
   "if",
   "isinstance",
   "(",
   "autofreq",
   ",",
   "bool",
   ")",
   "and",
   "autofreq",
   ":",
   "# use heuristic to figure out best timestep",
   "stepsize",
   "=",
   "0.25",
   "*",
   "mintransitduration",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# now figure out the frequencies to use",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = True: using AUTOMATIC values for '",
   "'freq stepsize: %s, ndurations: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "ndurations",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "use_autoperiod",
   "=",
   "False",
   "elif",
   "isinstance",
   "(",
   "autofreq",
   ",",
   "bool",
   ")",
   "and",
   "not",
   "autofreq",
   ":",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = False: using PROVIDED values for '",
   "'freq stepsize: %s, ndurations: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "ndurations",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "use_autoperiod",
   "=",
   "False",
   "elif",
   "isinstance",
   "(",
   "autofreq",
   ",",
   "str",
   ")",
   "and",
   "autofreq",
   "==",
   "'astropy'",
   ":",
   "use_autoperiod",
   "=",
   "True",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "else",
   ":",
   "LOGERROR",
   "(",
   "\"unknown autofreq kwarg encountered. can't continue...\"",
   ")",
   "return",
   "None",
   "# check the minimum frequency",
   "if",
   "minfreq",
   "<",
   "(",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   ":",
   "minfreq",
   "=",
   "2.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'the requested max P = %.3f is larger than '",
   "'the time base of the observations = %.3f, '",
   "' will make minfreq = 2 x 1/timebase'",
   "%",
   "(",
   "endp",
   ",",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'new minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "#############################",
   "## NOW RUN BLS IN PARALLEL ##",
   "#############################",
   "# fix number of CPUs if needed",
   "if",
   "not",
   "nworkers",
   "or",
   "nworkers",
   ">",
   "NCPUS",
   ":",
   "nworkers",
   "=",
   "NCPUS",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'using %s workers...'",
   "%",
   "nworkers",
   ")",
   "# check if autoperiod is True and get the correct period-grid",
   "if",
   "use_autoperiod",
   ":",
   "# astropy's BLS requires durations in units of time",
   "durations",
   "=",
   "nplinspace",
   "(",
   "mintransitduration",
   "*",
   "startp",
   ",",
   "maxtransitduration",
   "*",
   "startp",
   ",",
   "ndurations",
   ")",
   "# set up the correct units for the BLS model",
   "if",
   "magsarefluxes",
   ":",
   "blsmodel",
   "=",
   "BoxLeastSquares",
   "(",
   "stimes",
   "*",
   "u",
   ".",
   "day",
   ",",
   "smags",
   "*",
   "u",
   ".",
   "dimensionless_unscaled",
   ",",
   "dy",
   "=",
   "serrs",
   "*",
   "u",
   ".",
   "dimensionless_unscaled",
   ")",
   "else",
   ":",
   "blsmodel",
   "=",
   "BoxLeastSquares",
   "(",
   "stimes",
   "*",
   "u",
   ".",
   "day",
   ",",
   "smags",
   "*",
   "u",
   ".",
   "mag",
   ",",
   "dy",
   "=",
   "serrs",
   "*",
   "u",
   ".",
   "mag",
   ")",
   "periods",
   "=",
   "nparray",
   "(",
   "blsmodel",
   ".",
   "autoperiod",
   "(",
   "durations",
   "*",
   "u",
   ".",
   "day",
   ",",
   "minimum_period",
   "=",
   "startp",
   ",",
   "maximum_period",
   "=",
   "endp",
   ",",
   "minimum_n_transit",
   "=",
   "blsmintransits",
   ",",
   "frequency_factor",
   "=",
   "blsfreqfactor",
   ")",
   ")",
   "frequencies",
   "=",
   "1.0",
   "/",
   "periods",
   "nfreq",
   "=",
   "frequencies",
   ".",
   "size",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "\"autofreq = 'astropy', used .autoperiod() with \"",
   "\"minimum_n_transit = %s, freq_factor = %s \"",
   "\"to generate the frequency grid\"",
   "%",
   "(",
   "blsmintransits",
   ",",
   "blsfreqfactor",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'stepsize = %s, nfreq = %s, minfreq = %.5f, '",
   "'maxfreq = %.5f, ndurations = %s'",
   "%",
   "(",
   "abs",
   "(",
   "frequencies",
   "[",
   "1",
   "]",
   "-",
   "frequencies",
   "[",
   "0",
   "]",
   ")",
   ",",
   "nfreq",
   ",",
   "1.0",
   "/",
   "periods",
   ".",
   "max",
   "(",
   ")",
   ",",
   "1.0",
   "/",
   "periods",
   ".",
   "min",
   "(",
   ")",
   ",",
   "durations",
   ".",
   "size",
   ")",
   ")",
   "del",
   "blsmodel",
   "del",
   "durations",
   "# otherwise, use kbls method",
   "else",
   ":",
   "frequencies",
   "=",
   "minfreq",
   "+",
   "nparange",
   "(",
   "nfreq",
   ")",
   "*",
   "stepsize",
   "# break up the tasks into chunks",
   "csrem",
   "=",
   "int",
   "(",
   "fmod",
   "(",
   "nfreq",
   ",",
   "nworkers",
   ")",
   ")",
   "csint",
   "=",
   "int",
   "(",
   "float",
   "(",
   "nfreq",
   "/",
   "nworkers",
   ")",
   ")",
   "chunk_minfreqs",
   ",",
   "chunk_nfreqs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "for",
   "x",
   "in",
   "range",
   "(",
   "nworkers",
   ")",
   ":",
   "this_minfreqs",
   "=",
   "frequencies",
   "[",
   "x",
   "*",
   "csint",
   "]",
   "# handle usual nfreqs",
   "if",
   "x",
   "<",
   "(",
   "nworkers",
   "-",
   "1",
   ")",
   ":",
   "this_nfreqs",
   "=",
   "frequencies",
   "[",
   "x",
   "*",
   "csint",
   ":",
   "x",
   "*",
   "csint",
   "+",
   "csint",
   "]",
   ".",
   "size",
   "else",
   ":",
   "this_nfreqs",
   "=",
   "frequencies",
   "[",
   "x",
   "*",
   "csint",
   ":",
   "x",
   "*",
   "csint",
   "+",
   "csint",
   "+",
   "csrem",
   "]",
   ".",
   "size",
   "chunk_minfreqs",
   ".",
   "append",
   "(",
   "this_minfreqs",
   ")",
   "chunk_nfreqs",
   ".",
   "append",
   "(",
   "this_nfreqs",
   ")",
   "# populate the tasks list",
   "#",
   "# task[0] = times",
   "# task[1] = mags",
   "# task[2] = errs",
   "# task[3] = magsarefluxes",
   "# task[4] = minfreq",
   "# task[5] = nfreq",
   "# task[6] = stepsize",
   "# task[7] = nphasebins",
   "# task[8] = mintransitduration",
   "# task[9] = maxtransitduration",
   "# task[10] = blsobjective",
   "# task[11] = blsmethod",
   "# task[12] = blsoversample",
   "# populate the tasks list",
   "tasks",
   "=",
   "[",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "magsarefluxes",
   ",",
   "chunk_minf",
   ",",
   "chunk_nf",
   ",",
   "stepsize",
   ",",
   "ndurations",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ",",
   "blsobjective",
   ",",
   "blsmethod",
   ",",
   "blsoversample",
   ")",
   "for",
   "(",
   "chunk_minf",
   ",",
   "chunk_nf",
   ")",
   "in",
   "zip",
   "(",
   "chunk_minfreqs",
   ",",
   "chunk_nfreqs",
   ")",
   "]",
   "if",
   "verbose",
   ":",
   "for",
   "ind",
   ",",
   "task",
   "in",
   "enumerate",
   "(",
   "tasks",
   ")",
   ":",
   "LOGINFO",
   "(",
   "'worker %s: minfreq = %.6f, nfreqs = %s'",
   "%",
   "(",
   "ind",
   "+",
   "1",
   ",",
   "task",
   "[",
   "4",
   "]",
   ",",
   "task",
   "[",
   "5",
   "]",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'running...'",
   ")",
   "# return tasks",
   "# start the pool",
   "pool",
   "=",
   "Pool",
   "(",
   "nworkers",
   ")",
   "results",
   "=",
   "pool",
   ".",
   "map",
   "(",
   "_parallel_bls_worker",
   ",",
   "tasks",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "del",
   "pool",
   "# now concatenate the output lsp arrays",
   "lsp",
   "=",
   "npconcatenate",
   "(",
   "[",
   "x",
   "[",
   "'power'",
   "]",
   "for",
   "x",
   "in",
   "results",
   "]",
   ")",
   "periods",
   "=",
   "1.0",
   "/",
   "frequencies",
   "# find the nbestpeaks for the periodogram: 1. sort the lsp array",
   "# by highest value first 2. go down the values until we find",
   "# five values that are separated by at least periodepsilon in",
   "# period",
   "# make sure to get only the finite peaks in the periodogram",
   "# this is needed because BLS may produce infs for some peaks",
   "finitepeakind",
   "=",
   "npisfinite",
   "(",
   "lsp",
   ")",
   "finlsp",
   "=",
   "lsp",
   "[",
   "finitepeakind",
   "]",
   "finperiods",
   "=",
   "periods",
   "[",
   "finitepeakind",
   "]",
   "# make sure that finlsp has finite values before we work on it",
   "try",
   ":",
   "bestperiodind",
   "=",
   "npargmax",
   "(",
   "finlsp",
   ")",
   "except",
   "ValueError",
   ":",
   "LOGERROR",
   "(",
   "'no finite periodogram values '",
   "'for this mag series, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestinds'",
   ":",
   "None",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'durations'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'blsmodel'",
   ":",
   "None",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "sortedlspind",
   "=",
   "npargsort",
   "(",
   "finlsp",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "sortedlspperiods",
   "=",
   "finperiods",
   "[",
   "sortedlspind",
   "]",
   "sortedlspvals",
   "=",
   "finlsp",
   "[",
   "sortedlspind",
   "]",
   "# now get the nbestpeaks",
   "nbestperiods",
   ",",
   "nbestlspvals",
   ",",
   "nbestinds",
   ",",
   "peakcount",
   "=",
   "(",
   "[",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "bestperiodind",
   "]",
   ",",
   "1",
   ")",
   "prevperiod",
   "=",
   "sortedlspperiods",
   "[",
   "0",
   "]",
   "# find the best nbestpeaks in the lsp and their periods",
   "for",
   "period",
   ",",
   "lspval",
   ",",
   "ind",
   "in",
   "zip",
   "(",
   "sortedlspperiods",
   ",",
   "sortedlspvals",
   ",",
   "sortedlspind",
   ")",
   ":",
   "if",
   "peakcount",
   "==",
   "nbestpeaks",
   ":",
   "break",
   "perioddiff",
   "=",
   "abs",
   "(",
   "period",
   "-",
   "prevperiod",
   ")",
   "bestperiodsdiff",
   "=",
   "[",
   "abs",
   "(",
   "period",
   "-",
   "x",
   ")",
   "for",
   "x",
   "in",
   "nbestperiods",
   "]",
   "# this ensures that this period is different from the last",
   "# period and from all the other existing best periods by",
   "# periodepsilon to make sure we jump to an entire different",
   "# peak in the periodogram",
   "if",
   "(",
   "perioddiff",
   ">",
   "(",
   "periodepsilon",
   "*",
   "prevperiod",
   ")",
   "and",
   "all",
   "(",
   "x",
   ">",
   "(",
   "periodepsilon",
   "*",
   "period",
   ")",
   "for",
   "x",
   "in",
   "bestperiodsdiff",
   ")",
   ")",
   ":",
   "nbestperiods",
   ".",
   "append",
   "(",
   "period",
   ")",
   "nbestlspvals",
   ".",
   "append",
   "(",
   "lspval",
   ")",
   "nbestinds",
   ".",
   "append",
   "(",
   "ind",
   ")",
   "peakcount",
   "=",
   "peakcount",
   "+",
   "1",
   "prevperiod",
   "=",
   "period",
   "# generate the return dict",
   "resultdict",
   "=",
   "{",
   "'bestperiod'",
   ":",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'bestlspval'",
   ":",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestinds'",
   ":",
   "nbestinds",
   ",",
   "'nbestlspvals'",
   ":",
   "nbestlspvals",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'lspvals'",
   ":",
   "lsp",
   ",",
   "'frequencies'",
   ":",
   "frequencies",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'durations'",
   ":",
   "[",
   "x",
   "[",
   "'durations'",
   "]",
   "for",
   "x",
   "in",
   "results",
   "]",
   ",",
   "'blsresult'",
   ":",
   "[",
   "x",
   "[",
   "'blsresult'",
   "]",
   "for",
   "x",
   "in",
   "results",
   "]",
   ",",
   "'blsmodel'",
   ":",
   "[",
   "x",
   "[",
   "'blsmodel'",
   "]",
   "for",
   "x",
   "in",
   "results",
   "]",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "nfreq",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "return",
   "resultdict",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestinds'",
   ":",
   "None",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'durations'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'blsmodel'",
   ":",
   "None",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "None",
   ",",
   "'nphasebins'",
   ":",
   "None",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'ndurations'",
   ":",
   "ndurations",
   ",",
   "'blsobjective'",
   ":",
   "blsobjective",
   ",",
   "'blsmethod'",
   ":",
   "blsmethod",
   ",",
   "'blsoversample'",
   ":",
   "blsoversample",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}"
  ]
 },
 {
  "idx": "maxmin-576",
  "nl_tokens": [
   "This",
   "is",
   "a",
   "very",
   "poor",
   "algorithm",
   "to",
   "draw",
   "Wikipedia",
   "tables",
   "in",
   "NodeBox",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw_table",
   "(",
   "table",
   ",",
   "x",
   ",",
   "y",
   ",",
   "w",
   ",",
   "padding",
   "=",
   "5",
   ")",
   ":",
   "try",
   ":",
   "from",
   "web",
   "import",
   "_ctx",
   "except",
   ":",
   "pass",
   "f",
   "=",
   "_ctx",
   ".",
   "fill",
   "(",
   ")",
   "_ctx",
   ".",
   "stroke",
   "(",
   "f",
   ")",
   "h",
   "=",
   "_ctx",
   ".",
   "textheight",
   "(",
   "\" \"",
   ")",
   "+",
   "padding",
   "*",
   "2",
   "row_y",
   "=",
   "y",
   "if",
   "table",
   ".",
   "title",
   "!=",
   "\"\"",
   ":",
   "_ctx",
   ".",
   "fill",
   "(",
   "f",
   ")",
   "_ctx",
   ".",
   "rect",
   "(",
   "x",
   ",",
   "row_y",
   ",",
   "w",
   ",",
   "h",
   ")",
   "_ctx",
   ".",
   "fill",
   "(",
   "1",
   ")",
   "_ctx",
   ".",
   "text",
   "(",
   "table",
   ".",
   "title",
   ",",
   "x",
   "+",
   "padding",
   ",",
   "row_y",
   "+",
   "_ctx",
   ".",
   "fontsize",
   "(",
   ")",
   "+",
   "padding",
   ")",
   "row_y",
   "+=",
   "h",
   "# A table of flags marking how long a cell ",
   "# from a previous row is still spanning in a column.",
   "rowspans",
   "=",
   "[",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "10",
   ")",
   "]",
   "previous_cell_w",
   "=",
   "0",
   "for",
   "row",
   "in",
   "table",
   ":",
   "cell_x",
   "=",
   "x",
   "# The width of a cell is the total table width ",
   "# evenly divided by the number of cells.",
   "# Previous rows' cells still spanning will push cells",
   "# to the right and decrease their width.",
   "cell_w",
   "=",
   "1.0",
   "*",
   "w",
   "cell_w",
   "-=",
   "previous_cell_w",
   "*",
   "len",
   "(",
   "[",
   "n",
   "for",
   "n",
   "in",
   "rowspans",
   "if",
   "n",
   ">",
   "1",
   "]",
   ")",
   "cell_w",
   "/=",
   "len",
   "(",
   "row",
   ")",
   "# The height of each cell is the highest cell in the row.",
   "# The height depends on the amount of text in the cell.",
   "cell_h",
   "=",
   "0",
   "for",
   "cell",
   "in",
   "row",
   ":",
   "this_h",
   "=",
   "_ctx",
   ".",
   "textheight",
   "(",
   "cell",
   ",",
   "width",
   "=",
   "cell_w",
   "-",
   "padding",
   "*",
   "2",
   ")",
   "+",
   "padding",
   "*",
   "2",
   "cell_h",
   "=",
   "<mask>",
   "(",
   "cell_h",
   ",",
   "this_h",
   ")",
   "# Traverse each cell in this row.",
   "i",
   "=",
   "0",
   "for",
   "cell",
   "in",
   "row",
   ":",
   "# If a previous row's cell is still spanning,",
   "# push this cell to the right.",
   "if",
   "rowspans",
   "[",
   "i",
   "]",
   ">",
   "1",
   ":",
   "rowspans",
   "[",
   "i",
   "]",
   "-=",
   "1",
   "cell_x",
   "+=",
   "previous_cell_w",
   "i",
   "+=",
   "1",
   "# Get the rowspan attribute for this cell.",
   "m",
   "=",
   "re",
   ".",
   "search",
   "(",
   "\"rowspan=\\\"(.*?)\\\"\"",
   ",",
   "cell",
   ".",
   "properties",
   ")",
   "if",
   "m",
   ":",
   "rowspan",
   "=",
   "int",
   "(",
   "m",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   "rowspans",
   "[",
   "i",
   "]",
   "=",
   "rowspan",
   "else",
   ":",
   "rowspan",
   "=",
   "1",
   "# Padded cell text.            ",
   "# Horizontal line above each cell.",
   "# Vertical line before each cell.",
   "_ctx",
   ".",
   "fill",
   "(",
   "f",
   ")",
   "_ctx",
   ".",
   "text",
   "(",
   "cell",
   ",",
   "cell_x",
   "+",
   "padding",
   ",",
   "row_y",
   "+",
   "_ctx",
   ".",
   "fontsize",
   "(",
   ")",
   "+",
   "padding",
   ",",
   "cell_w",
   "-",
   "padding",
   "*",
   "2",
   ")",
   "_ctx",
   ".",
   "line",
   "(",
   "cell_x",
   ",",
   "row_y",
   ",",
   "cell_x",
   "+",
   "cell_w",
   ",",
   "row_y",
   ")",
   "if",
   "cell_x",
   ">",
   "x",
   ":",
   "_ctx",
   ".",
   "nofill",
   "(",
   ")",
   "_ctx",
   ".",
   "line",
   "(",
   "cell_x",
   ",",
   "row_y",
   ",",
   "cell_x",
   ",",
   "row_y",
   "+",
   "cell_h",
   ")",
   "cell_x",
   "+=",
   "cell_w",
   "i",
   "+=",
   "1",
   "# Move to next row.",
   "row_y",
   "+=",
   "cell_h",
   "previous_cell_w",
   "=",
   "cell_w",
   "# Table's bounding rectangle.",
   "_ctx",
   ".",
   "nofill",
   "(",
   ")",
   "_ctx",
   ".",
   "rect",
   "(",
   "x",
   ",",
   "y",
   ",",
   "w",
   ",",
   "row_y",
   "-",
   "y",
   ")"
  ]
 },
 {
  "idx": "maxmin-577",
  "nl_tokens": [
   "Returns",
   "intersection",
   "of",
   "two",
   "lists",
   ".",
   "Assumes",
   "the",
   "lists",
   "are",
   "sorted",
   "by",
   "start",
   "positions"
  ],
  "pl_tokens": [
   "def",
   "intersection",
   "(",
   "l1",
   ",",
   "l2",
   ")",
   ":",
   "if",
   "len",
   "(",
   "l1",
   ")",
   "==",
   "0",
   "or",
   "len",
   "(",
   "l2",
   ")",
   "==",
   "0",
   ":",
   "return",
   "[",
   "]",
   "out",
   "=",
   "[",
   "]",
   "l2_pos",
   "=",
   "0",
   "for",
   "l",
   "in",
   "l1",
   ":",
   "while",
   "l2_pos",
   "<",
   "len",
   "(",
   "l2",
   ")",
   "and",
   "l2",
   "[",
   "l2_pos",
   "]",
   ".",
   "end",
   "<",
   "l",
   ".",
   "start",
   ":",
   "l2_pos",
   "+=",
   "1",
   "if",
   "l2_pos",
   "==",
   "len",
   "(",
   "l2",
   ")",
   ":",
   "break",
   "while",
   "l2_pos",
   "<",
   "len",
   "(",
   "l2",
   ")",
   "and",
   "l",
   ".",
   "intersects",
   "(",
   "l2",
   "[",
   "l2_pos",
   "]",
   ")",
   ":",
   "out",
   ".",
   "append",
   "(",
   "l",
   ".",
   "intersection",
   "(",
   "l2",
   "[",
   "l2_pos",
   "]",
   ")",
   ")",
   "l2_pos",
   "+=",
   "1",
   "l2_pos",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "l2_pos",
   "-",
   "1",
   ")",
   "return",
   "out"
  ]
 },
 {
  "idx": "maxmin-578",
  "nl_tokens": [
   "builds",
   "a",
   "seeds",
   "and",
   "hits",
   "(",
   "uarr",
   ")",
   "array",
   "of",
   "ints",
   "from",
   "the",
   "utemp",
   ".",
   "sort",
   "file",
   ".",
   "Saves",
   "outputs",
   "to",
   "files",
   "..."
  ],
  "pl_tokens": [
   "def",
   "get_seeds_and_hits",
   "(",
   "uhandle",
   ",",
   "bseeds",
   ",",
   "snames",
   ")",
   ":",
   "## Get max name length. Allow for trailing _ + up to 9 digits",
   "## of numbers of loci (an astronomical number of unique loci)",
   "maxlen_names",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "snames",
   ")",
   ")",
   "+",
   "10",
   "## read in the utemp.sort file",
   "updf",
   "=",
   "np",
   ".",
   "loadtxt",
   "(",
   "uhandle",
   ",",
   "dtype",
   "=",
   "\"S\"",
   ".",
   "format",
   "(",
   "maxlen_names",
   ")",
   ")",
   "## Get seeds for all matches from usort",
   "seeds",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "updf",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "seedsarr",
   "=",
   "np",
   ".",
   "column_stack",
   "(",
   "[",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "seeds",
   ")",
   ")",
   ",",
   "[",
   "i",
   ".",
   "rsplit",
   "(",
   "\"_\"",
   ",",
   "1",
   ")",
   "[",
   "0",
   "]",
   "for",
   "i",
   "in",
   "seeds",
   "]",
   ",",
   "[",
   "i",
   ".",
   "rsplit",
   "(",
   "\"_\"",
   ",",
   "1",
   ")",
   "[",
   "1",
   "]",
   "for",
   "i",
   "in",
   "seeds",
   "]",
   "]",
   ")",
   "seedsarr",
   "[",
   ":",
   ",",
   "1",
   "]",
   "=",
   "[",
   "snames",
   ".",
   "index",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "seedsarr",
   "[",
   ":",
   ",",
   "1",
   "]",
   "]",
   "seedsarr",
   "=",
   "seedsarr",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "int64",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"got a seedsarr %s\"",
   ",",
   "seedsarr",
   ".",
   "shape",
   ")",
   "## Get matches from usort and create an array for fast entry",
   "uarr",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "updf",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "3",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int64",
   ")",
   "idx",
   "=",
   "-",
   "1",
   "lastloc",
   "=",
   "None",
   "for",
   "ldx",
   "in",
   "xrange",
   "(",
   "updf",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "tloc",
   "=",
   "updf",
   "[",
   "ldx",
   ",",
   "1",
   "]",
   "if",
   "tloc",
   "!=",
   "lastloc",
   ":",
   "idx",
   "+=",
   "1",
   "uarr",
   "[",
   "ldx",
   ",",
   "0",
   "]",
   "=",
   "idx",
   "lastloc",
   "=",
   "tloc",
   "## create a column with sample index",
   "uarr",
   "[",
   ":",
   ",",
   "1",
   "]",
   "=",
   "[",
   "int",
   "(",
   "snames",
   ".",
   "index",
   "(",
   "i",
   ".",
   "rsplit",
   "(",
   "\"_\"",
   ",",
   "1",
   ")",
   "[",
   "0",
   "]",
   ")",
   ")",
   "for",
   "i",
   "in",
   "updf",
   "[",
   ":",
   ",",
   "0",
   "]",
   "]",
   "## create a column with only consens index for sample",
   "uarr",
   "[",
   ":",
   ",",
   "2",
   "]",
   "=",
   "[",
   "int",
   "(",
   "i",
   ".",
   "rsplit",
   "(",
   "\"_\"",
   ",",
   "1",
   ")",
   "[",
   "1",
   "]",
   ")",
   "for",
   "i",
   "in",
   "updf",
   "[",
   ":",
   ",",
   "0",
   "]",
   "]",
   "uarr",
   "=",
   "uarr",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "int64",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"got a uarr %s\"",
   ",",
   "uarr",
   ".",
   "shape",
   ")",
   "## save as h5 to we can grab by sample slices",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "bseeds",
   ",",
   "'w'",
   ")",
   "as",
   "io5",
   ":",
   "io5",
   ".",
   "create_dataset",
   "(",
   "\"seedsarr\"",
   ",",
   "data",
   "=",
   "seedsarr",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int64",
   ")",
   "io5",
   ".",
   "create_dataset",
   "(",
   "\"uarr\"",
   ",",
   "data",
   "=",
   "uarr",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int64",
   ")"
  ]
 },
 {
  "idx": "maxmin-579",
  "nl_tokens": [
   "Return",
   "the",
   "Baystat",
   "similarity",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "min_ss_len",
   "=",
   "None",
   ",",
   "left_ext",
   "=",
   "None",
   ",",
   "right_ext",
   "=",
   "None",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "1.0",
   "if",
   "not",
   "src",
   "or",
   "not",
   "tar",
   ":",
   "return",
   "0.0",
   "max_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   "if",
   "not",
   "(",
   "min_ss_len",
   "and",
   "left_ext",
   "and",
   "right_ext",
   ")",
   ":",
   "# These can be set via arguments to the function. Otherwise they",
   "# are set automatically based on values from the article.",
   "if",
   "max_len",
   ">=",
   "7",
   ":",
   "min_ss_len",
   "=",
   "2",
   "left_ext",
   "=",
   "2",
   "right_ext",
   "=",
   "2",
   "else",
   ":",
   "# The paper suggests that for short names, (exclusively) one or",
   "# the other of left_ext and right_ext can be 1, with good",
   "# results. I use 0 & 0 as the default in this case.",
   "min_ss_len",
   "=",
   "1",
   "left_ext",
   "=",
   "0",
   "right_ext",
   "=",
   "0",
   "pos",
   "=",
   "0",
   "match_len",
   "=",
   "0",
   "while",
   "True",
   ":",
   "if",
   "pos",
   "+",
   "min_ss_len",
   ">",
   "len",
   "(",
   "src",
   ")",
   ":",
   "return",
   "match_len",
   "/",
   "max_len",
   "hit_len",
   "=",
   "0",
   "ix",
   "=",
   "1",
   "substring",
   "=",
   "src",
   "[",
   "pos",
   ":",
   "pos",
   "+",
   "min_ss_len",
   "]",
   "search_begin",
   "=",
   "pos",
   "-",
   "left_ext",
   "if",
   "search_begin",
   "<",
   "0",
   ":",
   "search_begin",
   "=",
   "0",
   "left_ext_len",
   "=",
   "pos",
   "else",
   ":",
   "left_ext_len",
   "=",
   "left_ext",
   "if",
   "pos",
   "+",
   "min_ss_len",
   "+",
   "right_ext",
   ">=",
   "len",
   "(",
   "tar",
   ")",
   ":",
   "right_ext_len",
   "=",
   "len",
   "(",
   "tar",
   ")",
   "-",
   "pos",
   "-",
   "min_ss_len",
   "else",
   ":",
   "right_ext_len",
   "=",
   "right_ext",
   "if",
   "(",
   "search_begin",
   "+",
   "left_ext_len",
   "+",
   "min_ss_len",
   "+",
   "right_ext_len",
   ">",
   "search_begin",
   ")",
   ":",
   "search_val",
   "=",
   "tar",
   "[",
   "search_begin",
   ":",
   "(",
   "search_begin",
   "+",
   "left_ext_len",
   "+",
   "min_ss_len",
   "+",
   "right_ext_len",
   ")",
   "]",
   "else",
   ":",
   "search_val",
   "=",
   "''",
   "flagged_tar",
   "=",
   "''",
   "while",
   "substring",
   "in",
   "search_val",
   "and",
   "pos",
   "+",
   "ix",
   "<=",
   "len",
   "(",
   "src",
   ")",
   ":",
   "hit_len",
   "=",
   "len",
   "(",
   "substring",
   ")",
   "flagged_tar",
   "=",
   "tar",
   ".",
   "replace",
   "(",
   "substring",
   ",",
   "'#'",
   "*",
   "hit_len",
   ")",
   "if",
   "pos",
   "+",
   "min_ss_len",
   "+",
   "ix",
   "<=",
   "len",
   "(",
   "src",
   ")",
   ":",
   "substring",
   "=",
   "src",
   "[",
   "pos",
   ":",
   "pos",
   "+",
   "min_ss_len",
   "+",
   "ix",
   "]",
   "if",
   "pos",
   "+",
   "min_ss_len",
   "+",
   "right_ext_len",
   "+",
   "1",
   "<=",
   "len",
   "(",
   "tar",
   ")",
   ":",
   "right_ext_len",
   "+=",
   "1",
   "# The following is unnecessary, I think",
   "# if (search_begin + left_ext_len + min_ss_len + right_ext_len",
   "#     <= len(tar)):",
   "search_val",
   "=",
   "tar",
   "[",
   "search_begin",
   ":",
   "(",
   "search_begin",
   "+",
   "left_ext_len",
   "+",
   "min_ss_len",
   "+",
   "right_ext_len",
   ")",
   "]",
   "ix",
   "+=",
   "1",
   "if",
   "hit_len",
   ">",
   "0",
   ":",
   "tar",
   "=",
   "flagged_tar",
   "match_len",
   "+=",
   "hit_len",
   "pos",
   "+=",
   "ix"
  ]
 },
 {
  "idx": "maxmin-580",
  "nl_tokens": [
   "Return",
   "the",
   "Levenshtein",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "mode",
   "=",
   "'lev'",
   ",",
   "cost",
   "=",
   "(",
   "1",
   ",",
   "1",
   ",",
   "1",
   ",",
   "1",
   ")",
   ")",
   ":",
   "ins_cost",
   ",",
   "del_cost",
   ",",
   "sub_cost",
   ",",
   "trans_cost",
   "=",
   "cost",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0",
   "if",
   "not",
   "src",
   ":",
   "return",
   "len",
   "(",
   "tar",
   ")",
   "*",
   "ins_cost",
   "if",
   "not",
   "tar",
   ":",
   "return",
   "len",
   "(",
   "src",
   ")",
   "*",
   "del_cost",
   "d_mat",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "np_int",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ")",
   ":",
   "d_mat",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "i",
   "*",
   "del_cost",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ":",
   "d_mat",
   "[",
   "0",
   ",",
   "j",
   "]",
   "=",
   "j",
   "*",
   "ins_cost",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "src",
   ")",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "tar",
   ")",
   ")",
   ":",
   "d_mat",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "+",
   "1",
   "]",
   "=",
   "<mask>",
   "(",
   "d_mat",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "]",
   "+",
   "ins_cost",
   ",",
   "# ins",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "+",
   "1",
   "]",
   "+",
   "del_cost",
   ",",
   "# del",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "+",
   "(",
   "sub_cost",
   "if",
   "src",
   "[",
   "i",
   "]",
   "!=",
   "tar",
   "[",
   "j",
   "]",
   "else",
   "0",
   ")",
   ",",
   "# sub/==",
   ")",
   "if",
   "mode",
   "==",
   "'osa'",
   ":",
   "if",
   "(",
   "i",
   "+",
   "1",
   ">",
   "1",
   "and",
   "j",
   "+",
   "1",
   ">",
   "1",
   "and",
   "src",
   "[",
   "i",
   "]",
   "==",
   "tar",
   "[",
   "j",
   "-",
   "1",
   "]",
   "and",
   "src",
   "[",
   "i",
   "-",
   "1",
   "]",
   "==",
   "tar",
   "[",
   "j",
   "]",
   ")",
   ":",
   "# transposition",
   "d_mat",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "+",
   "1",
   "]",
   "=",
   "min",
   "(",
   "d_mat",
   "[",
   "i",
   "+",
   "1",
   ",",
   "j",
   "+",
   "1",
   "]",
   ",",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "trans_cost",
   ",",
   ")",
   "return",
   "d_mat",
   "[",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-581",
  "nl_tokens": [
   "receive",
   "-",
   "receive",
   "bytes",
   "from",
   "a",
   "file",
   "descriptor"
  ],
  "pl_tokens": [
   "def",
   "sys_receive",
   "(",
   "self",
   ",",
   "cpu",
   ",",
   "fd",
   ",",
   "buf",
   ",",
   "count",
   ",",
   "rx_bytes",
   ")",
   ":",
   "data",
   "=",
   "''",
   "if",
   "count",
   "!=",
   "0",
   ":",
   "if",
   "not",
   "self",
   ".",
   "_is_open",
   "(",
   "fd",
   ")",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"RECEIVE: Not valid file descriptor on receive. Returning EBADF\"",
   ")",
   "return",
   "Decree",
   ".",
   "CGC_EBADF",
   "# TODO check count bytes from buf",
   "if",
   "buf",
   "not",
   "in",
   "cpu",
   ".",
   "memory",
   ":",
   "# or not  buf+count in cpu.memory:",
   "logger",
   ".",
   "info",
   "(",
   "\"RECEIVE: buf points to invalid address. Returning EFAULT\"",
   ")",
   "return",
   "Decree",
   ".",
   "CGC_EFAULT",
   "#import random",
   "#count = random.randint(1,count)",
   "if",
   "fd",
   ">",
   "2",
   "and",
   "self",
   ".",
   "files",
   "[",
   "fd",
   "]",
   ".",
   "is_empty",
   "(",
   ")",
   ":",
   "cpu",
   ".",
   "PC",
   "-=",
   "cpu",
   ".",
   "instruction",
   ".",
   "size",
   "self",
   ".",
   "wait",
   "(",
   "[",
   "fd",
   "]",
   ",",
   "[",
   "]",
   ",",
   "None",
   ")",
   "raise",
   "RestartSyscall",
   "(",
   ")",
   "# get some potential delay",
   "# if random.randint(5) == 0 and count > 1:",
   "#    count = count/2",
   "# Read the data and put it in memory",
   "data",
   "=",
   "self",
   ".",
   "files",
   "[",
   "fd",
   "]",
   ".",
   "receive",
   "(",
   "count",
   ")",
   "self",
   ".",
   "syscall_trace",
   ".",
   "append",
   "(",
   "(",
   "\"_receive\"",
   ",",
   "fd",
   ",",
   "data",
   ")",
   ")",
   "cpu",
   ".",
   "write_bytes",
   "(",
   "buf",
   ",",
   "data",
   ")",
   "self",
   ".",
   "signal_receive",
   "(",
   "fd",
   ")",
   "# TODO check 4 bytes from rx_bytes",
   "if",
   "rx_bytes",
   ":",
   "if",
   "rx_bytes",
   "not",
   "in",
   "cpu",
   ".",
   "memory",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"RECEIVE: Not valid file descriptor on receive. Returning EFAULT\"",
   ")",
   "return",
   "Decree",
   ".",
   "CGC_EFAULT",
   "cpu",
   ".",
   "write_int",
   "(",
   "rx_bytes",
   ",",
   "len",
   "(",
   "data",
   ")",
   ",",
   "32",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"RECEIVE(%d, 0x%08x, %d, 0x%08x) -> <%s> (size:%d)\"",
   "%",
   "(",
   "fd",
   ",",
   "buf",
   ",",
   "count",
   ",",
   "rx_bytes",
   ",",
   "repr",
   "(",
   "data",
   ")",
   "[",
   ":",
   "<mask>",
   "(",
   "count",
   ",",
   "10",
   ")",
   "]",
   ",",
   "len",
   "(",
   "data",
   ")",
   ")",
   ")",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-582",
  "nl_tokens": [
   "Calculate",
   "the",
   "entropy",
   "of",
   "the",
   "compound",
   "phase",
   "at",
   "the",
   "specified",
   "temperature",
   "."
  ],
  "pl_tokens": [
   "def",
   "S",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "result",
   "=",
   "self",
   ".",
   "Sref",
   "for",
   "Tmax",
   "in",
   "sorted",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   ":",
   "result",
   "+=",
   "self",
   ".",
   "_Cp_records",
   "[",
   "str",
   "(",
   "Tmax",
   ")",
   "]",
   ".",
   "S",
   "(",
   "T",
   ")",
   "if",
   "T",
   "<=",
   "Tmax",
   ":",
   "return",
   "result",
   "+",
   "self",
   ".",
   "S_mag",
   "(",
   "T",
   ")",
   "# Extrapolate beyond the upper limit by using a constant heat capacity.",
   "Tmax",
   "=",
   "<mask>",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "result",
   "+=",
   "self",
   ".",
   "Cp",
   "(",
   "Tmax",
   ")",
   "*",
   "math",
   ".",
   "log",
   "(",
   "T",
   "/",
   "Tmax",
   ")",
   "return",
   "result",
   "+",
   "self",
   ".",
   "S_mag",
   "(",
   "T",
   ")"
  ]
 },
 {
  "idx": "maxmin-583",
  "nl_tokens": [
   "adds",
   "number",
   "of",
   "years",
   "to",
   "a",
   "date",
   ":",
   "param",
   "BaseDateFloat",
   "d",
   ":",
   "date",
   "to",
   "add",
   "years",
   "to",
   ":",
   "param",
   "int",
   "years_int",
   ":",
   "number",
   "of",
   "years",
   "to",
   "add",
   ":",
   "return",
   "BaseDate",
   ":",
   "resulting",
   "date"
  ],
  "pl_tokens": [
   "def",
   "add_years",
   "(",
   "d",
   ",",
   "years_int",
   ")",
   ":",
   "y",
   ",",
   "m",
   ",",
   "d",
   "=",
   "BaseDate",
   ".",
   "to_ymd",
   "(",
   "d",
   ")",
   "if",
   "not",
   "is_leap_year",
   "(",
   "years_int",
   ")",
   "and",
   "m",
   "==",
   "2",
   ":",
   "d",
   "=",
   "<mask>",
   "(",
   "28",
   ",",
   "d",
   ")",
   "return",
   "BaseDateFloat",
   ".",
   "from_ymd",
   "(",
   "y",
   "+",
   "years_int",
   ",",
   "m",
   ",",
   "d",
   ")"
  ]
 },
 {
  "idx": "maxmin-584",
  "nl_tokens": [
   "Determine",
   "the",
   "best",
   "zoom",
   "level",
   "in",
   "target",
   "TilePyramid",
   "from",
   "given",
   "Tile",
   "."
  ],
  "pl_tokens": [
   "def",
   "tile_to_zoom_level",
   "(",
   "tile",
   ",",
   "dst_pyramid",
   "=",
   "None",
   ",",
   "matching_method",
   "=",
   "\"gdal\"",
   ",",
   "precision",
   "=",
   "8",
   ")",
   ":",
   "def",
   "width_height",
   "(",
   "bounds",
   ")",
   ":",
   "try",
   ":",
   "l",
   ",",
   "b",
   ",",
   "r",
   ",",
   "t",
   "=",
   "reproject_geometry",
   "(",
   "box",
   "(",
   "*",
   "bounds",
   ")",
   ",",
   "src_crs",
   "=",
   "tile",
   ".",
   "crs",
   ",",
   "dst_crs",
   "=",
   "dst_pyramid",
   ".",
   "crs",
   ")",
   ".",
   "bounds",
   "except",
   "ValueError",
   ":",
   "raise",
   "TopologicalError",
   "(",
   "\"bounds cannot be translated into target CRS\"",
   ")",
   "return",
   "r",
   "-",
   "l",
   ",",
   "t",
   "-",
   "b",
   "if",
   "tile",
   ".",
   "tp",
   ".",
   "crs",
   "==",
   "dst_pyramid",
   ".",
   "crs",
   ":",
   "return",
   "tile",
   ".",
   "zoom",
   "else",
   ":",
   "if",
   "matching_method",
   "==",
   "\"gdal\"",
   ":",
   "# use rasterio/GDAL method to calculate default warp target properties",
   "transform",
   ",",
   "width",
   ",",
   "height",
   "=",
   "calculate_default_transform",
   "(",
   "tile",
   ".",
   "tp",
   ".",
   "crs",
   ",",
   "dst_pyramid",
   ".",
   "crs",
   ",",
   "tile",
   ".",
   "width",
   ",",
   "tile",
   ".",
   "height",
   ",",
   "*",
   "tile",
   ".",
   "bounds",
   ")",
   "# this is the resolution the tile would have in destination TilePyramid CRS",
   "tile_resolution",
   "=",
   "round",
   "(",
   "transform",
   "[",
   "0",
   "]",
   ",",
   "precision",
   ")",
   "elif",
   "matching_method",
   "==",
   "\"min\"",
   ":",
   "# calculate the minimum pixel size from the four tile corner pixels",
   "l",
   ",",
   "b",
   ",",
   "r",
   ",",
   "t",
   "=",
   "tile",
   ".",
   "bounds",
   "x",
   "=",
   "tile",
   ".",
   "pixel_x_size",
   "y",
   "=",
   "tile",
   ".",
   "pixel_y_size",
   "res",
   "=",
   "[",
   "]",
   "for",
   "bounds",
   "in",
   "[",
   "(",
   "l",
   ",",
   "t",
   "-",
   "y",
   ",",
   "l",
   "+",
   "x",
   ",",
   "t",
   ")",
   ",",
   "# left top",
   "(",
   "l",
   ",",
   "b",
   ",",
   "l",
   "+",
   "x",
   ",",
   "b",
   "+",
   "y",
   ")",
   ",",
   "# left bottom",
   "(",
   "r",
   "-",
   "x",
   ",",
   "b",
   ",",
   "r",
   ",",
   "b",
   "+",
   "y",
   ")",
   ",",
   "# right bottom",
   "(",
   "r",
   "-",
   "x",
   ",",
   "t",
   "-",
   "y",
   ",",
   "r",
   ",",
   "t",
   ")",
   "# right top",
   "]",
   ":",
   "try",
   ":",
   "w",
   ",",
   "h",
   "=",
   "width_height",
   "(",
   "bounds",
   ")",
   "res",
   ".",
   "extend",
   "(",
   "[",
   "w",
   ",",
   "h",
   "]",
   ")",
   "except",
   "TopologicalError",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"pixel outside of destination pyramid\"",
   ")",
   "if",
   "res",
   ":",
   "tile_resolution",
   "=",
   "round",
   "(",
   "<mask>",
   "(",
   "res",
   ")",
   ",",
   "precision",
   ")",
   "else",
   ":",
   "raise",
   "TopologicalError",
   "(",
   "\"tile outside of destination pyramid\"",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"invalid method given: %s\"",
   ",",
   "matching_method",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"we are looking for a zoom level interpolating to %s resolution\"",
   ",",
   "tile_resolution",
   ")",
   "zoom",
   "=",
   "0",
   "while",
   "True",
   ":",
   "td_resolution",
   "=",
   "round",
   "(",
   "dst_pyramid",
   ".",
   "pixel_x_size",
   "(",
   "zoom",
   ")",
   ",",
   "precision",
   ")",
   "if",
   "td_resolution",
   "<=",
   "tile_resolution",
   ":",
   "break",
   "zoom",
   "+=",
   "1",
   "logger",
   ".",
   "debug",
   "(",
   "\"target zoom for %s: %s (%s)\"",
   ",",
   "tile_resolution",
   ",",
   "zoom",
   ",",
   "td_resolution",
   ")",
   "return",
   "zoom"
  ]
 },
 {
  "idx": "maxmin-585",
  "nl_tokens": [
   "Sets",
   "the",
   "player",
   "s",
   "volume",
   "(",
   "150%",
   "or",
   "1000%",
   "limit",
   "imposed",
   "by",
   "lavalink",
   "depending",
   "on",
   "the",
   "version",
   ")",
   "."
  ],
  "pl_tokens": [
   "async",
   "def",
   "set_volume",
   "(",
   "self",
   ",",
   "vol",
   ":",
   "int",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_lavalink",
   ".",
   "_server_version",
   "<=",
   "2",
   ":",
   "self",
   ".",
   "volume",
   "=",
   "<mask>",
   "(",
   "min",
   "(",
   "vol",
   ",",
   "150",
   ")",
   ",",
   "0",
   ")",
   "else",
   ":",
   "self",
   ".",
   "volume",
   "=",
   "max",
   "(",
   "min",
   "(",
   "vol",
   ",",
   "1000",
   ")",
   ",",
   "0",
   ")",
   "await",
   "self",
   ".",
   "_lavalink",
   ".",
   "ws",
   ".",
   "send",
   "(",
   "op",
   "=",
   "'volume'",
   ",",
   "guildId",
   "=",
   "self",
   ".",
   "guild_id",
   ",",
   "volume",
   "=",
   "self",
   ".",
   "volume",
   ")"
  ]
 },
 {
  "idx": "maxmin-586",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "__calculate_changes",
   "(",
   "self",
   ",",
   "updated_centers",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "__centers",
   ")",
   "!=",
   "len",
   "(",
   "updated_centers",
   ")",
   ":",
   "maximum_change",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "else",
   ":",
   "changes",
   "=",
   "self",
   ".",
   "__metric",
   "(",
   "self",
   ".",
   "__centers",
   ",",
   "updated_centers",
   ")",
   "maximum_change",
   "=",
   "numpy",
   ".",
   "<mask>",
   "(",
   "changes",
   ")",
   "return",
   "maximum_change"
  ]
 },
 {
  "idx": "maxmin-587",
  "nl_tokens": [
   "Compute",
   "the",
   "saturation",
   "for",
   "a",
   "continuous",
   "level",
   ".",
   "This",
   "breaks",
   "the",
   "level",
   "into",
   "multiple",
   "regions",
   "and",
   "computes",
   "the",
   "saturation",
   "level",
   "for",
   "each",
   "region",
   "."
  ],
  "pl_tokens": [
   "def",
   "computeSaturationLevels",
   "(",
   "outputs",
   ",",
   "outputsShape",
   ",",
   "sparseForm",
   "=",
   "False",
   ")",
   ":",
   "# Get the outputs into a SparseBinaryMatrix",
   "if",
   "not",
   "sparseForm",
   ":",
   "outputs",
   "=",
   "outputs",
   ".",
   "reshape",
   "(",
   "outputsShape",
   ")",
   "spOut",
   "=",
   "SM32",
   "(",
   "outputs",
   ")",
   "else",
   ":",
   "if",
   "len",
   "(",
   "outputs",
   ")",
   ">",
   "0",
   ":",
   "assert",
   "(",
   "outputs",
   ".",
   "<mask>",
   "(",
   ")",
   "<",
   "outputsShape",
   "[",
   "0",
   "]",
   "*",
   "outputsShape",
   "[",
   "1",
   "]",
   ")",
   "spOut",
   "=",
   "SM32",
   "(",
   "1",
   ",",
   "outputsShape",
   "[",
   "0",
   "]",
   "*",
   "outputsShape",
   "[",
   "1",
   "]",
   ")",
   "spOut",
   ".",
   "setRowFromSparse",
   "(",
   "0",
   ",",
   "outputs",
   ",",
   "[",
   "1",
   "]",
   "*",
   "len",
   "(",
   "outputs",
   ")",
   ")",
   "spOut",
   ".",
   "reshape",
   "(",
   "outputsShape",
   "[",
   "0",
   "]",
   ",",
   "outputsShape",
   "[",
   "1",
   "]",
   ")",
   "# Get the activity in each local region using the nNonZerosPerBox method",
   "# This method takes a list of the end row indices and a list of the end",
   "#  column indices.",
   "# We will use regions that are 15x15, which give us about a 1/225 (.4%) resolution",
   "#  on saturation.",
   "regionSize",
   "=",
   "15",
   "rows",
   "=",
   "xrange",
   "(",
   "regionSize",
   "+",
   "1",
   ",",
   "outputsShape",
   "[",
   "0",
   "]",
   "+",
   "1",
   ",",
   "regionSize",
   ")",
   "cols",
   "=",
   "xrange",
   "(",
   "regionSize",
   "+",
   "1",
   ",",
   "outputsShape",
   "[",
   "1",
   "]",
   "+",
   "1",
   ",",
   "regionSize",
   ")",
   "regionSums",
   "=",
   "spOut",
   ".",
   "nNonZerosPerBox",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   "# Get all the nonzeros out - those are our saturation sums",
   "(",
   "locations",
   ",",
   "values",
   ")",
   "=",
   "regionSums",
   ".",
   "tolist",
   "(",
   ")",
   "values",
   "/=",
   "float",
   "(",
   "regionSize",
   "*",
   "regionSize",
   ")",
   "sat",
   "=",
   "list",
   "(",
   "values",
   ")",
   "# Now, to compute which are the inner regions, we will only take the ones that",
   "#  are surrounded by activity above, below, left and right",
   "innerSat",
   "=",
   "[",
   "]",
   "locationSet",
   "=",
   "set",
   "(",
   "locations",
   ")",
   "for",
   "(",
   "location",
   ",",
   "value",
   ")",
   "in",
   "itertools",
   ".",
   "izip",
   "(",
   "locations",
   ",",
   "values",
   ")",
   ":",
   "(",
   "row",
   ",",
   "col",
   ")",
   "=",
   "location",
   "if",
   "(",
   "row",
   "-",
   "1",
   ",",
   "col",
   ")",
   "in",
   "locationSet",
   "and",
   "(",
   "row",
   ",",
   "col",
   "-",
   "1",
   ")",
   "in",
   "locationSet",
   "and",
   "(",
   "row",
   "+",
   "1",
   ",",
   "col",
   ")",
   "in",
   "locationSet",
   "and",
   "(",
   "row",
   ",",
   "col",
   "+",
   "1",
   ")",
   "in",
   "locationSet",
   ":",
   "innerSat",
   ".",
   "append",
   "(",
   "value",
   ")",
   "return",
   "(",
   "sat",
   ",",
   "innerSat",
   ")"
  ]
 },
 {
  "idx": "maxmin-588",
  "nl_tokens": [
   "Awake",
   "process",
   "if",
   "timer",
   "has",
   "expired"
  ],
  "pl_tokens": [
   "def",
   "check_timers",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_current",
   "is",
   "None",
   ":",
   "# Advance the clocks. Go to future!!",
   "advance",
   "=",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "clocks",
   "]",
   "+",
   "[",
   "x",
   "for",
   "x",
   "in",
   "self",
   ".",
   "timers",
   "if",
   "x",
   "is",
   "not",
   "None",
   "]",
   ")",
   "+",
   "1",
   "logger",
   ".",
   "debug",
   "(",
   "f\"Advancing the clock from {self.clocks} to {advance}\"",
   ")",
   "self",
   ".",
   "clocks",
   "=",
   "advance",
   "for",
   "procid",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "timers",
   ")",
   ")",
   ":",
   "if",
   "self",
   ".",
   "timers",
   "[",
   "procid",
   "]",
   "is",
   "not",
   "None",
   ":",
   "if",
   "self",
   ".",
   "clocks",
   ">",
   "self",
   ".",
   "timers",
   "[",
   "procid",
   "]",
   ":",
   "self",
   ".",
   "procs",
   "[",
   "procid",
   "]",
   ".",
   "PC",
   "+=",
   "self",
   ".",
   "procs",
   "[",
   "procid",
   "]",
   ".",
   "instruction",
   ".",
   "size",
   "self",
   ".",
   "awake",
   "(",
   "procid",
   ")"
  ]
 },
 {
  "idx": "maxmin-589",
  "nl_tokens": [
   "decimate",
   "data",
   "using",
   "one",
   "of",
   "the",
   "following",
   "methods",
   ":",
   "avg",
   "max",
   "min",
   "fast",
   "They",
   "re",
   "self",
   "explainatory",
   ".",
   "fast",
   "just",
   "plucks",
   "the",
   "n",
   "th",
   "data",
   "point",
   "."
  ],
  "pl_tokens": [
   "def",
   "sweep_decimate",
   "(",
   "self",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "dataY",
   ")",
   "<",
   "self",
   ".",
   "decimateBy",
   ":",
   "return",
   "if",
   "self",
   ".",
   "decimateMethod",
   ":",
   "points",
   "=",
   "int",
   "(",
   "len",
   "(",
   "self",
   ".",
   "dataY",
   ")",
   "/",
   "self",
   ".",
   "decimateBy",
   ")",
   "self",
   ".",
   "dataY",
   "=",
   "self",
   ".",
   "dataY",
   "[",
   ":",
   "points",
   "*",
   "self",
   ".",
   "decimateBy",
   "]",
   "self",
   ".",
   "dataY",
   "=",
   "np",
   ".",
   "reshape",
   "(",
   "self",
   ".",
   "dataY",
   ",",
   "(",
   "points",
   ",",
   "self",
   ".",
   "decimateBy",
   ")",
   ")",
   "if",
   "self",
   ".",
   "decimateMethod",
   "==",
   "'avg'",
   ":",
   "self",
   ".",
   "dataY",
   "=",
   "np",
   ".",
   "average",
   "(",
   "self",
   ".",
   "dataY",
   ",",
   "1",
   ")",
   "elif",
   "self",
   ".",
   "decimateMethod",
   "==",
   "'max'",
   ":",
   "self",
   ".",
   "dataY",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "dataY",
   ",",
   "1",
   ")",
   "elif",
   "self",
   ".",
   "decimateMethod",
   "==",
   "'min'",
   ":",
   "self",
   ".",
   "dataY",
   "=",
   "np",
   ".",
   "min",
   "(",
   "self",
   ".",
   "dataY",
   ",",
   "1",
   ")",
   "elif",
   "self",
   ".",
   "decimateMethod",
   "==",
   "'fast'",
   ":",
   "self",
   ".",
   "dataY",
   "=",
   "self",
   ".",
   "dataY",
   "[",
   ":",
   ",",
   "0",
   "]",
   "else",
   ":",
   "print",
   "(",
   "\"!!! METHOD NOT IMPLIMENTED YET!!!\"",
   ",",
   "self",
   ".",
   "decimateMethod",
   ")",
   "self",
   ".",
   "dataX",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "self",
   ".",
   "dataY",
   ")",
   ")",
   "/",
   "self",
   ".",
   "rate",
   "*",
   "self",
   ".",
   "decimateBy"
  ]
 },
 {
  "idx": "maxmin-590",
  "nl_tokens": [
   "Utility",
   "function",
   "to",
   "display",
   "nice",
   "titles"
  ],
  "pl_tokens": [
   "def",
   "title",
   "(",
   "s",
   "=",
   "None",
   ",",
   "additional",
   "=",
   "''",
   ",",
   "stream",
   "=",
   "sys",
   ".",
   "stdout",
   ")",
   ":",
   "if",
   "s",
   "is",
   "None",
   ":",
   "callable_name",
   ",",
   "file_name",
   ",",
   "class_name",
   "=",
   "getCallerInfo",
   "(",
   "2",
   ")",
   "s",
   "=",
   "callable_name",
   "if",
   "class_name",
   "is",
   "not",
   "None",
   ":",
   "s",
   "=",
   "class_name",
   "+",
   "'.'",
   "+",
   "callable_name",
   "lines",
   "=",
   "(",
   "s",
   "+",
   "additional",
   ")",
   ".",
   "split",
   "(",
   "'\\n'",
   ")",
   "length",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "line",
   ")",
   "for",
   "line",
   "in",
   "lines",
   ")",
   "print",
   ">>",
   "stream",
   ",",
   "'-'",
   "*",
   "length",
   "print",
   ">>",
   "stream",
   ",",
   "s",
   "+",
   "additional",
   "print",
   ">>",
   "stream",
   ",",
   "'-'",
   "*",
   "length"
  ]
 },
 {
  "idx": "maxmin-591",
  "nl_tokens": [
   "Given",
   "a",
   "cluster",
   "create",
   "two",
   "Bokeh",
   "plot",
   "based",
   "H",
   "-",
   "R",
   "diagrams",
   ".",
   "The",
   "Selection",
   "in",
   "the",
   "left",
   "H",
   "-",
   "R",
   "diagram",
   "will",
   "show",
   "up",
   "on",
   "the",
   "right",
   "one",
   "."
  ],
  "pl_tokens": [
   "def",
   "hr_diagram_selection",
   "(",
   "cluster_name",
   ")",
   ":",
   "cluster",
   "=",
   "get_hr_data",
   "(",
   "cluster_name",
   ")",
   "temps",
   ",",
   "lums",
   "=",
   "round_teff_luminosity",
   "(",
   "cluster",
   ")",
   "x",
   ",",
   "y",
   "=",
   "temps",
   ",",
   "lums",
   "colors",
   ",",
   "color_mapper",
   "=",
   "hr_diagram_color_helper",
   "(",
   "temps",
   ")",
   "x_range",
   "=",
   "[",
   "<mask>",
   "(",
   "x",
   ")",
   "+",
   "max",
   "(",
   "x",
   ")",
   "*",
   "0.05",
   ",",
   "min",
   "(",
   "x",
   ")",
   "-",
   "min",
   "(",
   "x",
   ")",
   "*",
   "0.05",
   "]",
   "source",
   "=",
   "ColumnDataSource",
   "(",
   "data",
   "=",
   "dict",
   "(",
   "x",
   "=",
   "x",
   ",",
   "y",
   "=",
   "y",
   ",",
   "color",
   "=",
   "colors",
   ")",
   ",",
   "name",
   "=",
   "'hr'",
   ")",
   "source_selected",
   "=",
   "ColumnDataSource",
   "(",
   "data",
   "=",
   "dict",
   "(",
   "x",
   "=",
   "[",
   "]",
   ",",
   "y",
   "=",
   "[",
   "]",
   ",",
   "color",
   "=",
   "[",
   "]",
   ")",
   ",",
   "name",
   "=",
   "'hr'",
   ")",
   "pf",
   "=",
   "figure",
   "(",
   "y_axis_type",
   "=",
   "'log'",
   ",",
   "x_range",
   "=",
   "x_range",
   ",",
   "tools",
   "=",
   "'lasso_select,reset'",
   ",",
   "title",
   "=",
   "'H-R Diagram for {0}'",
   ".",
   "format",
   "(",
   "cluster",
   ".",
   "name",
   ")",
   ")",
   "_diagram",
   "(",
   "source",
   "=",
   "source",
   ",",
   "plot_figure",
   "=",
   "pf",
   ",",
   "name",
   "=",
   "'hr'",
   ",",
   "color",
   "=",
   "{",
   "'field'",
   ":",
   "'color'",
   ",",
   "'transform'",
   ":",
   "color_mapper",
   "}",
   ",",
   "xaxis_label",
   "=",
   "'Temperature (Kelvin)'",
   ",",
   "yaxis_label",
   "=",
   "'Luminosity (solar units)'",
   ")",
   "pf_selected",
   "=",
   "figure",
   "(",
   "y_axis_type",
   "=",
   "'log'",
   ",",
   "y_range",
   "=",
   "pf",
   ".",
   "y_range",
   ",",
   "x_range",
   "=",
   "x_range",
   ",",
   "tools",
   "=",
   "'reset'",
   ",",
   "title",
   "=",
   "'H-R Diagram for {0}'",
   ".",
   "format",
   "(",
   "cluster",
   ".",
   "name",
   ")",
   ")",
   "_diagram",
   "(",
   "source",
   "=",
   "source_selected",
   ",",
   "plot_figure",
   "=",
   "pf_selected",
   ",",
   "name",
   "=",
   "'hr'",
   ",",
   "color",
   "=",
   "{",
   "'field'",
   ":",
   "'color'",
   ",",
   "'transform'",
   ":",
   "color_mapper",
   "}",
   ",",
   "xaxis_label",
   "=",
   "'Temperature (Kelvin)'",
   ",",
   "yaxis_label",
   "=",
   "'Luminosity (solar units)'",
   ")",
   "source",
   ".",
   "callback",
   "=",
   "CustomJS",
   "(",
   "args",
   "=",
   "dict",
   "(",
   "source_selected",
   "=",
   "source_selected",
   ")",
   ",",
   "code",
   "=",
   "\"\"\"\n        var inds = cb_obj.selected['1d'].indices;\n        var d1 = cb_obj.data;\n        var d2 = source_selected.data;\n        console.log(inds);\n        d2['x'] = []\n        d2['y'] = []\n        d2['color'] = []\n        for (i = 0; i < inds.length; i++) {\n            d2['x'].push(d1['x'][inds[i]])\n            d2['y'].push(d1['y'][inds[i]])\n            d2['color'].push(d1['color'][inds[i]])\n        }\n        source_selected.change.emit();\n        \"\"\"",
   ")",
   "show_with_bokeh_server",
   "(",
   "row",
   "(",
   "pf",
   ",",
   "pf_selected",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-592",
  "nl_tokens": [
   "Check",
   "if",
   "current",
   "line",
   "contains",
   "an",
   "inherited",
   "function",
   "."
  ],
  "pl_tokens": [
   "def",
   "IsDerivedFunction",
   "(",
   "clean_lines",
   ",",
   "linenum",
   ")",
   ":",
   "# Scan back a few lines for start of current function",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "linenum",
   ",",
   "<mask>",
   "(",
   "-",
   "1",
   ",",
   "linenum",
   "-",
   "10",
   ")",
   ",",
   "-",
   "1",
   ")",
   ":",
   "match",
   "=",
   "Match",
   "(",
   "r'^([^()]*\\w+)\\('",
   ",",
   "clean_lines",
   ".",
   "elided",
   "[",
   "i",
   "]",
   ")",
   "if",
   "match",
   ":",
   "# Look for \"override\" after the matching closing parenthesis",
   "line",
   ",",
   "_",
   ",",
   "closing_paren",
   "=",
   "CloseExpression",
   "(",
   "clean_lines",
   ",",
   "i",
   ",",
   "len",
   "(",
   "match",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   ")",
   "return",
   "(",
   "closing_paren",
   ">=",
   "0",
   "and",
   "Search",
   "(",
   "r'\\boverride\\b'",
   ",",
   "line",
   "[",
   "closing_paren",
   ":",
   "]",
   ")",
   ")",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-593",
  "nl_tokens": [
   "Given",
   "a",
   "Variable",
   "and",
   "a",
   "value",
   "cleans",
   "it",
   "out"
  ],
  "pl_tokens": [
   "def",
   "sanitize",
   "(",
   "self",
   ",",
   "val",
   ")",
   ":",
   "if",
   "self",
   ".",
   "type",
   "==",
   "NUMBER",
   ":",
   "try",
   ":",
   "return",
   "clamp",
   "(",
   "self",
   ".",
   "<mask>",
   ",",
   "self",
   ".",
   "max",
   ",",
   "float",
   "(",
   "val",
   ")",
   ")",
   "except",
   "ValueError",
   ":",
   "return",
   "0.0",
   "elif",
   "self",
   ".",
   "type",
   "==",
   "TEXT",
   ":",
   "try",
   ":",
   "return",
   "unicode",
   "(",
   "str",
   "(",
   "val",
   ")",
   ",",
   "\"utf_8\"",
   ",",
   "\"replace\"",
   ")",
   "except",
   ":",
   "return",
   "\"\"",
   "elif",
   "self",
   ".",
   "type",
   "==",
   "BOOLEAN",
   ":",
   "if",
   "unicode",
   "(",
   "val",
   ")",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "(",
   "\"true\"",
   ",",
   "\"1\"",
   ",",
   "\"yes\"",
   ")",
   ":",
   "return",
   "True",
   "else",
   ":",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-594",
  "nl_tokens": [
   "Start",
   "the",
   "Manager",
   "process",
   "."
  ],
  "pl_tokens": [
   "def",
   "start",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "comm",
   ".",
   "Barrier",
   "(",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Manager synced with workers\"",
   ")",
   "self",
   ".",
   "_kill_event",
   "=",
   "threading",
   ".",
   "Event",
   "(",
   ")",
   "self",
   ".",
   "_task_puller_thread",
   "=",
   "threading",
   ".",
   "Thread",
   "(",
   "target",
   "=",
   "self",
   ".",
   "pull_tasks",
   ",",
   "args",
   "=",
   "(",
   "self",
   ".",
   "_kill_event",
   ",",
   ")",
   ")",
   "self",
   ".",
   "_result_pusher_thread",
   "=",
   "threading",
   ".",
   "Thread",
   "(",
   "target",
   "=",
   "self",
   ".",
   "push_results",
   ",",
   "args",
   "=",
   "(",
   "self",
   ".",
   "_kill_event",
   ",",
   ")",
   ")",
   "self",
   ".",
   "_task_puller_thread",
   ".",
   "start",
   "(",
   ")",
   "self",
   ".",
   "_result_pusher_thread",
   ".",
   "start",
   "(",
   ")",
   "start",
   "=",
   "None",
   "result_counter",
   "=",
   "0",
   "task_recv_counter",
   "=",
   "0",
   "task_sent_counter",
   "=",
   "0",
   "logger",
   ".",
   "info",
   "(",
   "\"Loop start\"",
   ")",
   "while",
   "not",
   "self",
   ".",
   "_kill_event",
   ".",
   "is_set",
   "(",
   ")",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "LOOP_SLOWDOWN",
   ")",
   "# In this block we attempt to probe MPI for a set amount of time,",
   "# and if we have exhausted all available MPI events, we move on",
   "# to the next block. The timer and counter trigger balance",
   "# fairness and responsiveness.",
   "timer",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "+",
   "0.05",
   "counter",
   "=",
   "<mask>",
   "(",
   "10",
   ",",
   "comm",
   ".",
   "size",
   ")",
   "while",
   "time",
   ".",
   "time",
   "(",
   ")",
   "<",
   "timer",
   ":",
   "info",
   "=",
   "MPI",
   ".",
   "Status",
   "(",
   ")",
   "if",
   "counter",
   ">",
   "10",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"Hit max mpi events per round\"",
   ")",
   "break",
   "if",
   "not",
   "self",
   ".",
   "comm",
   ".",
   "Iprobe",
   "(",
   "status",
   "=",
   "info",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"Timer expired, processed {} mpi events\"",
   ".",
   "format",
   "(",
   "counter",
   ")",
   ")",
   "break",
   "else",
   ":",
   "tag",
   "=",
   "info",
   ".",
   "Get_tag",
   "(",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"Message with tag {} received\"",
   ".",
   "format",
   "(",
   "tag",
   ")",
   ")",
   "counter",
   "+=",
   "1",
   "if",
   "tag",
   "==",
   "RESULT_TAG",
   ":",
   "result",
   "=",
   "self",
   ".",
   "recv_result_from_workers",
   "(",
   ")",
   "self",
   ".",
   "pending_result_queue",
   ".",
   "put",
   "(",
   "result",
   ")",
   "result_counter",
   "+=",
   "1",
   "elif",
   "tag",
   "==",
   "TASK_REQUEST_TAG",
   ":",
   "worker_rank",
   "=",
   "self",
   ".",
   "recv_task_request_from_workers",
   "(",
   ")",
   "self",
   ".",
   "ready_worker_queue",
   ".",
   "put",
   "(",
   "worker_rank",
   ")",
   "else",
   ":",
   "logger",
   ".",
   "error",
   "(",
   "\"Unknown tag {} - ignoring this message and continuing\"",
   ".",
   "format",
   "(",
   "tag",
   ")",
   ")",
   "available_worker_cnt",
   "=",
   "self",
   ".",
   "ready_worker_queue",
   ".",
   "qsize",
   "(",
   ")",
   "available_task_cnt",
   "=",
   "self",
   ".",
   "pending_task_queue",
   ".",
   "qsize",
   "(",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"[MAIN] Ready workers: {} Ready tasks: {}\"",
   ".",
   "format",
   "(",
   "available_worker_cnt",
   ",",
   "available_task_cnt",
   ")",
   ")",
   "this_round",
   "=",
   "min",
   "(",
   "available_worker_cnt",
   ",",
   "available_task_cnt",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "this_round",
   ")",
   ":",
   "worker_rank",
   "=",
   "self",
   ".",
   "ready_worker_queue",
   ".",
   "get",
   "(",
   ")",
   "task",
   "=",
   "self",
   ".",
   "pending_task_queue",
   ".",
   "get",
   "(",
   ")",
   "comm",
   ".",
   "send",
   "(",
   "task",
   ",",
   "dest",
   "=",
   "worker_rank",
   ",",
   "tag",
   "=",
   "worker_rank",
   ")",
   "task_sent_counter",
   "+=",
   "1",
   "logger",
   ".",
   "debug",
   "(",
   "\"Assigning worker:{} task:{}\"",
   ".",
   "format",
   "(",
   "worker_rank",
   ",",
   "task",
   "[",
   "'task_id'",
   "]",
   ")",
   ")",
   "if",
   "not",
   "start",
   ":",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Tasks recvd:{} Tasks dispatched:{} Results recvd:{}\"",
   ".",
   "format",
   "(",
   "task_recv_counter",
   ",",
   "task_sent_counter",
   ",",
   "result_counter",
   ")",
   ")",
   "# print(\"[{}] Received: {}\".format(self.identity, msg))",
   "# time.sleep(random.randint(4,10)/10)",
   "self",
   ".",
   "_task_puller_thread",
   ".",
   "join",
   "(",
   ")",
   "self",
   ".",
   "_result_pusher_thread",
   ".",
   "join",
   "(",
   ")",
   "self",
   ".",
   "task_incoming",
   ".",
   "close",
   "(",
   ")",
   "self",
   ".",
   "result_outgoing",
   ".",
   "close",
   "(",
   ")",
   "self",
   ".",
   "context",
   ".",
   "term",
   "(",
   ")",
   "delta",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   "logger",
   ".",
   "info",
   "(",
   "\"mpi_worker_pool ran for {} seconds\"",
   ".",
   "format",
   "(",
   "delta",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-595",
  "nl_tokens": [
   "Compute",
   "the",
   "xticks",
   "labels",
   "of",
   "this",
   "grid",
   "used",
   "for",
   "plotting",
   "the",
   "x",
   "-",
   "axis",
   "ticks",
   "when",
   "visualizing",
   "a",
   "regular"
  ],
  "pl_tokens": [
   "def",
   "xticks",
   "(",
   "self",
   ")",
   ":",
   "return",
   "np",
   ".",
   "linspace",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "self",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "self",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   ",",
   "4",
   ")"
  ]
 },
 {
  "idx": "maxmin-596",
  "nl_tokens": [
   "A",
   "function",
   "to",
   "merge",
   "fastq",
   "files",
   "produced",
   "by",
   "bam2fq",
   "."
  ],
  "pl_tokens": [
   "def",
   "merge_pairs_after_refmapping",
   "(",
   "data",
   ",",
   "two_files",
   ",",
   "merged_out",
   ")",
   ":",
   "## create temp files ",
   "nonmerged1",
   "=",
   "tempfile",
   ".",
   "NamedTemporaryFile",
   "(",
   "mode",
   "=",
   "'wb'",
   ",",
   "dir",
   "=",
   "data",
   ".",
   "dirs",
   ".",
   "edits",
   ",",
   "suffix",
   "=",
   "\"_nonmerged_R1_.fastq\"",
   ")",
   ".",
   "name",
   "nonmerged2",
   "=",
   "tempfile",
   ".",
   "NamedTemporaryFile",
   "(",
   "mode",
   "=",
   "'wb'",
   ",",
   "dir",
   "=",
   "data",
   ".",
   "dirs",
   ".",
   "edits",
   ",",
   "suffix",
   "=",
   "\"_nonmerged_R2_.fastq\"",
   ")",
   ".",
   "name",
   "## get the maxn and minlen values",
   "minlen",
   "=",
   "str",
   "(",
   "<mask>",
   "(",
   "32",
   ",",
   "data",
   ".",
   "paramsdict",
   "[",
   "\"filter_min_trim_len\"",
   "]",
   ")",
   ")",
   "try",
   ":",
   "maxn",
   "=",
   "sum",
   "(",
   "data",
   ".",
   "paramsdict",
   "[",
   "'max_low_qual_bases'",
   "]",
   ")",
   "except",
   "TypeError",
   ":",
   "maxn",
   "=",
   "data",
   ".",
   "paramsdict",
   "[",
   "'max_low_qual_bases'",
   "]",
   "## set the quality scores abritrarily high and orient R2 correctly",
   "tmp1",
   "=",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "tmp2",
   "=",
   "two_files",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "fastq_touchup_for_vsearch_merge",
   "(",
   "tmp1",
   ",",
   "tmp1",
   "+",
   "\".tu\"",
   ",",
   "False",
   ")",
   "fastq_touchup_for_vsearch_merge",
   "(",
   "tmp2",
   ",",
   "tmp2",
   "+",
   "\".tu\"",
   ",",
   "True",
   ")",
   "## command string to call vsearch",
   "cmd",
   "=",
   "[",
   "ipyrad",
   ".",
   "bins",
   ".",
   "vsearch",
   ",",
   "\"--fastq_mergepairs\"",
   ",",
   "tmp1",
   "+",
   "\".tu\"",
   ",",
   "\"--reverse\"",
   ",",
   "tmp2",
   "+",
   "\".tu\"",
   ",",
   "\"--fastqout\"",
   ",",
   "merged_out",
   ",",
   "\"--fastqout_notmerged_fwd\"",
   ",",
   "nonmerged1",
   ",",
   "\"--fastqout_notmerged_rev\"",
   ",",
   "nonmerged2",
   ",",
   "\"--fasta_width\"",
   ",",
   "\"0\"",
   ",",
   "\"--fastq_minmergelen\"",
   ",",
   "minlen",
   ",",
   "\"--fastq_maxns\"",
   ",",
   "str",
   "(",
   "maxn",
   ")",
   ",",
   "\"--fastq_minovlen\"",
   ",",
   "\"10\"",
   ",",
   "\"--fastq_maxdiffs\"",
   ",",
   "\"4\"",
   ",",
   "\"--label_suffix\"",
   ",",
   "\"_m1\"",
   ",",
   "\"--fastq_qmax\"",
   ",",
   "\"1000\"",
   ",",
   "\"--threads\"",
   ",",
   "\"2\"",
   ",",
   "\"--fastq_allowmergestagger\"",
   "]",
   "## run vsearch but allow kbd",
   "proc",
   "=",
   "sps",
   ".",
   "Popen",
   "(",
   "cmd",
   ",",
   "stderr",
   "=",
   "sps",
   ".",
   "STDOUT",
   ",",
   "stdout",
   "=",
   "sps",
   ".",
   "PIPE",
   ")",
   "try",
   ":",
   "res",
   "=",
   "proc",
   ".",
   "communicate",
   "(",
   ")",
   "[",
   "0",
   "]",
   "except",
   "KeyboardInterrupt",
   ":",
   "proc",
   ".",
   "kill",
   "(",
   ")",
   "## cleanup tmp files if job failed or stopped    ",
   "if",
   "proc",
   ".",
   "returncode",
   ":",
   "LOGGER",
   ".",
   "error",
   "(",
   "\"Error: %s %s\"",
   ",",
   "cmd",
   ",",
   "res",
   ")",
   "raise",
   "IPyradWarningExit",
   "(",
   "\"Error merge pairs:\\n %s\\n%s\"",
   ",",
   "cmd",
   ",",
   "res",
   ")",
   "## record how many read pairs were merged",
   "with",
   "open",
   "(",
   "merged_out",
   ",",
   "'r'",
   ")",
   "as",
   "tmpf",
   ":",
   "nmerged",
   "=",
   "sum",
   "(",
   "1",
   "for",
   "i",
   "in",
   "tmpf",
   ".",
   "readlines",
   "(",
   ")",
   ")",
   "//",
   "4",
   "## Concat unmerged pairs with a 'nnnn' separator",
   "with",
   "open",
   "(",
   "merged_out",
   ",",
   "'ab'",
   ")",
   "as",
   "combout",
   ":",
   "## read in paired end read files 4 lines at a time",
   "fr1",
   "=",
   "open",
   "(",
   "nonmerged1",
   ",",
   "'rb'",
   ")",
   "quart1",
   "=",
   "itertools",
   ".",
   "izip",
   "(",
   "*",
   "[",
   "iter",
   "(",
   "fr1",
   ")",
   "]",
   "*",
   "4",
   ")",
   "fr2",
   "=",
   "open",
   "(",
   "nonmerged2",
   ",",
   "'rb'",
   ")",
   "quart2",
   "=",
   "itertools",
   ".",
   "izip",
   "(",
   "*",
   "[",
   "iter",
   "(",
   "fr2",
   ")",
   "]",
   "*",
   "4",
   ")",
   "quarts",
   "=",
   "itertools",
   ".",
   "izip",
   "(",
   "quart1",
   ",",
   "quart2",
   ")",
   "## a list to store until writing",
   "writing",
   "=",
   "[",
   "]",
   "counts",
   "=",
   "0",
   "## iterate until done",
   "while",
   "1",
   ":",
   "try",
   ":",
   "read1s",
   ",",
   "read2s",
   "=",
   "quarts",
   ".",
   "next",
   "(",
   ")",
   "except",
   "StopIteration",
   ":",
   "break",
   "## store the read",
   "writing",
   ".",
   "append",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "[",
   "read1s",
   "[",
   "0",
   "]",
   ",",
   "read1s",
   "[",
   "1",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "+",
   "\"nnnn\"",
   "+",
   "read2s",
   "[",
   "1",
   "]",
   ",",
   "read1s",
   "[",
   "2",
   "]",
   ",",
   "read1s",
   "[",
   "3",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "+",
   "\"nnnn\"",
   "+",
   "read2s",
   "[",
   "3",
   "]",
   ",",
   "]",
   ")",
   ")",
   "## count up until time to write",
   "counts",
   "+=",
   "1",
   "if",
   "not",
   "counts",
   "%",
   "10",
   ":",
   "combout",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "writing",
   ")",
   ")",
   "writing",
   "=",
   "[",
   "]",
   "## write the remaining",
   "if",
   "writing",
   ":",
   "combout",
   ".",
   "write",
   "(",
   "\"\"",
   ".",
   "join",
   "(",
   "writing",
   ")",
   ")",
   "## close handles",
   "fr1",
   ".",
   "close",
   "(",
   ")",
   "fr2",
   ".",
   "close",
   "(",
   ")",
   "combout",
   ".",
   "close",
   "(",
   ")",
   "## remove temp files (or do this later)",
   "rmfiles",
   "=",
   "[",
   "nonmerged1",
   ",",
   "nonmerged2",
   ",",
   "tmp1",
   ",",
   "tmp2",
   ",",
   "tmp1",
   "+",
   "\".tu\"",
   ",",
   "tmp2",
   "+",
   "\".tu\"",
   "]",
   "for",
   "rmfile",
   "in",
   "rmfiles",
   ":",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "rmfile",
   ")",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "rmfile",
   ")",
   "return",
   "nmerged"
  ]
 },
 {
  "idx": "maxmin-597",
  "nl_tokens": [
   "Prepare",
   "the",
   "I",
   "/",
   "O",
   "handlers",
   "."
  ],
  "pl_tokens": [
   "def",
   "_prepare_handlers",
   "(",
   "self",
   ")",
   ":",
   "timeout",
   "=",
   "None",
   "readable",
   "=",
   "[",
   "]",
   "writable",
   "=",
   "[",
   "]",
   "for",
   "handler",
   "in",
   "self",
   ".",
   "_handlers",
   ":",
   "if",
   "handler",
   "not",
   "in",
   "self",
   ".",
   "_prepared",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\" preparing handler: {0!r}\"",
   ".",
   "format",
   "(",
   "handler",
   ")",
   ")",
   "ret",
   "=",
   "handler",
   ".",
   "prepare",
   "(",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"   prepare result: {0!r}\"",
   ".",
   "format",
   "(",
   "ret",
   ")",
   ")",
   "if",
   "isinstance",
   "(",
   "ret",
   ",",
   "HandlerReady",
   ")",
   ":",
   "self",
   ".",
   "_prepared",
   ".",
   "add",
   "(",
   "handler",
   ")",
   "elif",
   "isinstance",
   "(",
   "ret",
   ",",
   "PrepareAgain",
   ")",
   ":",
   "if",
   "ret",
   ".",
   "timeout",
   "is",
   "not",
   "None",
   ":",
   "if",
   "timeout",
   "is",
   "None",
   ":",
   "timeout",
   "=",
   "ret",
   ".",
   "timeout",
   "else",
   ":",
   "timeout",
   "=",
   "<mask>",
   "(",
   "timeout",
   ",",
   "ret",
   ".",
   "timeout",
   ")",
   "else",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Unexpected result type from prepare()\"",
   ")",
   "if",
   "not",
   "handler",
   ".",
   "fileno",
   "(",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\" {0!r}: no fileno\"",
   ".",
   "format",
   "(",
   "handler",
   ")",
   ")",
   "continue",
   "if",
   "handler",
   ".",
   "is_readable",
   "(",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\" {0!r} readable\"",
   ".",
   "format",
   "(",
   "handler",
   ")",
   ")",
   "readable",
   ".",
   "append",
   "(",
   "handler",
   ")",
   "if",
   "handler",
   ".",
   "is_writable",
   "(",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\" {0!r} writable\"",
   ".",
   "format",
   "(",
   "handler",
   ")",
   ")",
   "writable",
   ".",
   "append",
   "(",
   "handler",
   ")",
   "return",
   "readable",
   ",",
   "writable",
   ",",
   "timeout"
  ]
 },
 {
  "idx": "maxmin-598",
  "nl_tokens": [
   "Solving",
   "an",
   "MDP",
   "by",
   "value",
   "iteration",
   ".",
   "[",
   "Fig",
   ".",
   "17",
   ".",
   "4",
   "]"
  ],
  "pl_tokens": [
   "def",
   "value_iteration",
   "(",
   "mdp",
   ",",
   "epsilon",
   "=",
   "0.001",
   ")",
   ":",
   "U1",
   "=",
   "dict",
   "(",
   "[",
   "(",
   "s",
   ",",
   "0",
   ")",
   "for",
   "s",
   "in",
   "mdp",
   ".",
   "states",
   "]",
   ")",
   "R",
   ",",
   "T",
   ",",
   "gamma",
   "=",
   "mdp",
   ".",
   "R",
   ",",
   "mdp",
   ".",
   "T",
   ",",
   "mdp",
   ".",
   "gamma",
   "while",
   "True",
   ":",
   "U",
   "=",
   "U1",
   ".",
   "copy",
   "(",
   ")",
   "delta",
   "=",
   "0",
   "for",
   "s",
   "in",
   "mdp",
   ".",
   "states",
   ":",
   "U1",
   "[",
   "s",
   "]",
   "=",
   "R",
   "(",
   "s",
   ")",
   "+",
   "gamma",
   "*",
   "<mask>",
   "(",
   "[",
   "sum",
   "(",
   "[",
   "p",
   "*",
   "U",
   "[",
   "s1",
   "]",
   "for",
   "(",
   "p",
   ",",
   "s1",
   ")",
   "in",
   "T",
   "(",
   "s",
   ",",
   "a",
   ")",
   "]",
   ")",
   "for",
   "a",
   "in",
   "mdp",
   ".",
   "actions",
   "(",
   "s",
   ")",
   "]",
   ")",
   "delta",
   "=",
   "max",
   "(",
   "delta",
   ",",
   "abs",
   "(",
   "U1",
   "[",
   "s",
   "]",
   "-",
   "U",
   "[",
   "s",
   "]",
   ")",
   ")",
   "if",
   "delta",
   "<",
   "epsilon",
   "*",
   "(",
   "1",
   "-",
   "gamma",
   ")",
   "/",
   "gamma",
   ":",
   "return",
   "U"
  ]
 },
 {
  "idx": "maxmin-599",
  "nl_tokens": [
   "Returns",
   "a",
   "0",
   ".",
   "0",
   "-",
   "1",
   ".",
   "0",
   "brightness",
   "adjusted",
   "to",
   "a",
   "light",
   "source",
   "."
  ],
  "pl_tokens": [
   "def",
   "shader",
   "(",
   "x",
   ",",
   "y",
   ",",
   "dx",
   ",",
   "dy",
   ",",
   "radius",
   "=",
   "300",
   ",",
   "angle",
   "=",
   "0",
   ",",
   "spread",
   "=",
   "90",
   ")",
   ":",
   "if",
   "angle",
   "!=",
   "None",
   ":",
   "radius",
   "*=",
   "2",
   "# Get the distance and angle between point and light source.",
   "d",
   "=",
   "sqrt",
   "(",
   "(",
   "dx",
   "-",
   "x",
   ")",
   "**",
   "2",
   "+",
   "(",
   "dy",
   "-",
   "y",
   ")",
   "**",
   "2",
   ")",
   "a",
   "=",
   "degrees",
   "(",
   "atan2",
   "(",
   "dy",
   "-",
   "y",
   ",",
   "dx",
   "-",
   "x",
   ")",
   ")",
   "+",
   "180",
   "# If no angle is defined,",
   "# light is emitted evenly in all directions",
   "# and carries as far as the defined radius",
   "# (e.g. like a radial gradient).",
   "if",
   "d",
   "<=",
   "radius",
   ":",
   "d1",
   "=",
   "1.0",
   "*",
   "d",
   "/",
   "radius",
   "else",
   ":",
   "d1",
   "=",
   "1.0",
   "if",
   "angle",
   "is",
   "None",
   ":",
   "return",
   "1",
   "-",
   "d1",
   "# Normalize the light's direction and spread",
   "# between 0 and 360.",
   "angle",
   "=",
   "360",
   "-",
   "angle",
   "%",
   "360",
   "spread",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "min",
   "(",
   "spread",
   ",",
   "360",
   ")",
   ")",
   "if",
   "spread",
   "==",
   "0",
   ":",
   "return",
   "0.0",
   "# Objects that fall within the spreaded direction",
   "# of the light are illuminated.",
   "d",
   "=",
   "abs",
   "(",
   "a",
   "-",
   "angle",
   ")",
   "if",
   "d",
   "<=",
   "spread",
   "/",
   "2",
   ":",
   "d2",
   "=",
   "d",
   "/",
   "spread",
   "+",
   "d1",
   "else",
   ":",
   "d2",
   "=",
   "1.0",
   "# Wrapping from 0 to 360:",
   "# a light source with a direction of 10 degrees",
   "# and a spread of 45 degrees illuminates",
   "# objects between 0 and 35 degrees and 350 and 360 degrees.",
   "if",
   "360",
   "-",
   "angle",
   "<=",
   "spread",
   "/",
   "2",
   ":",
   "d",
   "=",
   "abs",
   "(",
   "360",
   "-",
   "angle",
   "+",
   "a",
   ")",
   "if",
   "d",
   "<=",
   "spread",
   "/",
   "2",
   ":",
   "d2",
   "=",
   "d",
   "/",
   "spread",
   "+",
   "d1",
   "# Wrapping from 360 to 0.",
   "if",
   "angle",
   "<",
   "spread",
   "/",
   "2",
   ":",
   "d",
   "=",
   "abs",
   "(",
   "360",
   "+",
   "angle",
   "-",
   "a",
   ")",
   "if",
   "d",
   "<=",
   "spread",
   "/",
   "2",
   ":",
   "d2",
   "=",
   "d",
   "/",
   "spread",
   "+",
   "d1",
   "return",
   "1",
   "-",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "d2",
   ",",
   "1",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-600",
  "nl_tokens": [
   "Computes",
   "the",
   "amount",
   "of",
   "time",
   "(",
   "if",
   "any",
   ")",
   "to",
   "delay",
   "the",
   "run",
   "of",
   "this",
   "model",
   ".",
   "This",
   "can",
   "be",
   "determined",
   "by",
   "two",
   "mutually",
   "exclusive",
   "parameters",
   ":",
   "delay",
   "and",
   "sleepModelRange",
   "."
  ],
  "pl_tokens": [
   "def",
   "_computModelDelay",
   "(",
   "self",
   ")",
   ":",
   "# 'delay' and 'sleepModelRange' are mutually exclusive",
   "if",
   "self",
   ".",
   "_params",
   "[",
   "'delay'",
   "]",
   "is",
   "not",
   "None",
   "and",
   "self",
   ".",
   "_params",
   "[",
   "'sleepModelRange'",
   "]",
   "is",
   "not",
   "None",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Only one of 'delay' or \"",
   "\"'sleepModelRange' may be specified\"",
   ")",
   "# Get the sleepModel range",
   "if",
   "self",
   ".",
   "_sleepModelRange",
   "is",
   "not",
   "None",
   ":",
   "range",
   ",",
   "delay",
   "=",
   "self",
   ".",
   "_sleepModelRange",
   ".",
   "split",
   "(",
   "':'",
   ")",
   "delay",
   "=",
   "float",
   "(",
   "delay",
   ")",
   "range",
   "=",
   "map",
   "(",
   "int",
   ",",
   "range",
   ".",
   "split",
   "(",
   "','",
   ")",
   ")",
   "modelIDs",
   "=",
   "self",
   ".",
   "_jobsDAO",
   ".",
   "jobGetModelIDs",
   "(",
   "self",
   ".",
   "_jobID",
   ")",
   "modelIDs",
   ".",
   "sort",
   "(",
   ")",
   "range",
   "[",
   "1",
   "]",
   "=",
   "<mask>",
   "(",
   "range",
   "[",
   "1",
   "]",
   ",",
   "len",
   "(",
   "modelIDs",
   ")",
   ")",
   "# If the model is in range, add the delay",
   "if",
   "self",
   ".",
   "_modelID",
   "in",
   "modelIDs",
   "[",
   "range",
   "[",
   "0",
   "]",
   ":",
   "range",
   "[",
   "1",
   "]",
   "]",
   ":",
   "self",
   ".",
   "_delay",
   "=",
   "delay",
   "else",
   ":",
   "self",
   ".",
   "_delay",
   "=",
   "self",
   ".",
   "_params",
   "[",
   "'delay'",
   "]"
  ]
 },
 {
  "idx": "maxmin-601",
  "nl_tokens": [
   "addition",
   "of",
   "a",
   "number",
   "of",
   "years"
  ],
  "pl_tokens": [
   "def",
   "add_years",
   "(",
   "d",
   ",",
   "years_int",
   ")",
   ":",
   "y",
   ",",
   "m",
   ",",
   "d",
   "=",
   "BaseDateDatetimeDate",
   ".",
   "to_ymd",
   "(",
   "d",
   ")",
   "y",
   "+=",
   "years_int",
   "if",
   "not",
   "is_leap_year",
   "(",
   "y",
   ")",
   "and",
   "m",
   "==",
   "2",
   ":",
   "d",
   "=",
   "<mask>",
   "(",
   "28",
   ",",
   "d",
   ")",
   "return",
   "BaseDateDatetimeDate",
   ".",
   "from_ymd",
   "(",
   "y",
   ",",
   "m",
   ",",
   "d",
   ")"
  ]
 },
 {
  "idx": "maxmin-602",
  "nl_tokens": [
   "Return",
   "the",
   "normalized",
   "Levenshtein",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "mode",
   "=",
   "'lev'",
   ",",
   "cost",
   "=",
   "(",
   "1",
   ",",
   "1",
   ",",
   "1",
   ",",
   "1",
   ")",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0",
   "ins_cost",
   ",",
   "del_cost",
   "=",
   "cost",
   "[",
   ":",
   "2",
   "]",
   "return",
   "levenshtein",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "mode",
   ",",
   "cost",
   ")",
   "/",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   "*",
   "del_cost",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "*",
   "ins_cost",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-603",
  "nl_tokens": [
   "Computes",
   "output",
   "for",
   "both",
   "learning",
   "and",
   "inference",
   ".",
   "In",
   "both",
   "cases",
   "the",
   "output",
   "is",
   "the",
   "boolean",
   "OR",
   "of",
   "activeState",
   "and",
   "predictedState",
   "at",
   "t",
   ".",
   "Stores",
   "currentOutput",
   "for",
   "checkPrediction",
   ".",
   ":",
   "returns",
   ":",
   "TODO",
   ":",
   "document"
  ],
  "pl_tokens": [
   "def",
   "_computeOutput",
   "(",
   "self",
   ")",
   ":",
   "# TODO: This operation can be sped up by:",
   "#  1.)  Pre-allocating space for the currentOutput",
   "#  2.)  Making predictedState and activeState of type 'float32' up front",
   "#  3.)  Using logical_or(self.predictedState['t'], self.activeState['t'],",
   "#          self.currentOutput)",
   "if",
   "self",
   ".",
   "outputType",
   "==",
   "'activeState1CellPerCol'",
   ":",
   "# Fire only the most confident cell in columns that have 2 or more",
   "#  active cells",
   "mostActiveCellPerCol",
   "=",
   "self",
   ".",
   "cellConfidence",
   "[",
   "'t'",
   "]",
   ".",
   "argmax",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "self",
   ".",
   "currentOutput",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ".",
   "shape",
   ",",
   "dtype",
   "=",
   "'float32'",
   ")",
   "# Turn on the most confident cell in each column. Note here that",
   "#  Columns refers to TM columns, even though each TM column is a row",
   "#  in the numpy array.",
   "numCols",
   "=",
   "self",
   ".",
   "currentOutput",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "self",
   ".",
   "currentOutput",
   "[",
   "(",
   "xrange",
   "(",
   "numCols",
   ")",
   ",",
   "mostActiveCellPerCol",
   ")",
   "]",
   "=",
   "1",
   "# Don't turn on anything in columns which are not active at all",
   "activeCols",
   "=",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "inactiveCols",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "activeCols",
   "==",
   "0",
   ")",
   "[",
   "0",
   "]",
   "self",
   ".",
   "currentOutput",
   "[",
   "inactiveCols",
   ",",
   ":",
   "]",
   "=",
   "0",
   "elif",
   "self",
   ".",
   "outputType",
   "==",
   "'activeState'",
   ":",
   "self",
   ".",
   "currentOutput",
   "=",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   "elif",
   "self",
   ".",
   "outputType",
   "==",
   "'normal'",
   ":",
   "self",
   ".",
   "currentOutput",
   "=",
   "numpy",
   ".",
   "logical_or",
   "(",
   "self",
   ".",
   "infPredictedState",
   "[",
   "'t'",
   "]",
   ",",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   ")",
   "else",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Unimplemented outputType\"",
   ")",
   "return",
   "self",
   ".",
   "currentOutput",
   ".",
   "reshape",
   "(",
   "-",
   "1",
   ")",
   ".",
   "astype",
   "(",
   "'float32'",
   ")"
  ]
 },
 {
  "idx": "maxmin-604",
  "nl_tokens": [
   "Calculate",
   "the",
   "heat",
   "capacity",
   "of",
   "the",
   "compound",
   "phase",
   "at",
   "the",
   "specified",
   "temperature",
   "."
  ],
  "pl_tokens": [
   "def",
   "Cp",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "# TODO: Fix str/float conversion",
   "for",
   "Tmax",
   "in",
   "sorted",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   ":",
   "if",
   "T",
   "<",
   "Tmax",
   ":",
   "return",
   "self",
   ".",
   "_Cp_records",
   "[",
   "str",
   "(",
   "Tmax",
   ")",
   "]",
   ".",
   "Cp",
   "(",
   "T",
   ")",
   "+",
   "self",
   ".",
   "Cp_mag",
   "(",
   "T",
   ")",
   "Tmax",
   "=",
   "<mask>",
   "(",
   "[",
   "float",
   "(",
   "TT",
   ")",
   "for",
   "TT",
   "in",
   "self",
   ".",
   "_Cp_records",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "return",
   "self",
   ".",
   "_Cp_records",
   "[",
   "str",
   "(",
   "Tmax",
   ")",
   "]",
   ".",
   "Cp",
   "(",
   "Tmax",
   ")",
   "+",
   "self",
   ".",
   "Cp_mag",
   "(",
   "T",
   ")"
  ]
 },
 {
  "idx": "maxmin-605",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "longest",
   "common",
   "substring",
   "similarity",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "1.0",
   "elif",
   "not",
   "src",
   "or",
   "not",
   "tar",
   ":",
   "return",
   "0.0",
   "return",
   "len",
   "(",
   "self",
   ".",
   "lcsstr",
   "(",
   "src",
   ",",
   "tar",
   ")",
   ")",
   "/",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-606",
  "nl_tokens": [
   "Draw",
   "people",
   "(",
   "s",
   ")",
   "into",
   "image",
   "using",
   "MPII",
   "dataset",
   "format",
   "as",
   "input",
   "return",
   "or",
   "save",
   "the",
   "result",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "draw_mpii_pose_to_image",
   "(",
   "image",
   ",",
   "poses",
   ",",
   "save_name",
   "=",
   "'image.png'",
   ")",
   ":",
   "# import skimage",
   "# don't change the original image, and avoid error https://stackoverflow.com/questions/30249053/python-opencv-drawing-errors-after-manipulating-array-with-numpy",
   "image",
   "=",
   "image",
   ".",
   "copy",
   "(",
   ")",
   "imh",
   ",",
   "imw",
   "=",
   "image",
   ".",
   "shape",
   "[",
   "0",
   ":",
   "2",
   "]",
   "thick",
   "=",
   "int",
   "(",
   "(",
   "imh",
   "+",
   "imw",
   ")",
   "//",
   "430",
   ")",
   "# radius = int(image.shape[1] / 500) + 1",
   "radius",
   "=",
   "int",
   "(",
   "thick",
   "*",
   "1.5",
   ")",
   "if",
   "image",
   ".",
   "<mask>",
   "(",
   ")",
   "<",
   "1",
   ":",
   "image",
   "=",
   "image",
   "*",
   "255",
   "for",
   "people",
   "in",
   "poses",
   ":",
   "# Pose Keyponts",
   "joint_pos",
   "=",
   "people",
   "[",
   "'joint_pos'",
   "]",
   "# draw sketch",
   "# joint id (0 - r ankle, 1 - r knee, 2 - r hip, 3 - l hip, 4 - l knee,",
   "#           5 - l ankle, 6 - pelvis, 7 - thorax, 8 - upper neck,",
   "#           9 - head top, 10 - r wrist, 11 - r elbow, 12 - r shoulder,",
   "#           13 - l shoulder, 14 - l elbow, 15 - l wrist)",
   "#",
   "#               9",
   "#               8",
   "#         12 ** 7 ** 13",
   "#        *      *      *",
   "#       11      *       14",
   "#      *        *         *",
   "#     10    2 * 6 * 3     15",
   "#           *       *",
   "#           1       4",
   "#           *       *",
   "#           0       5",
   "lines",
   "=",
   "[",
   "[",
   "(",
   "0",
   ",",
   "1",
   ")",
   ",",
   "[",
   "100",
   ",",
   "255",
   ",",
   "100",
   "]",
   "]",
   ",",
   "[",
   "(",
   "1",
   ",",
   "2",
   ")",
   ",",
   "[",
   "50",
   ",",
   "255",
   ",",
   "50",
   "]",
   "]",
   ",",
   "[",
   "(",
   "2",
   ",",
   "6",
   ")",
   ",",
   "[",
   "0",
   ",",
   "255",
   ",",
   "0",
   "]",
   "]",
   ",",
   "# right leg",
   "[",
   "(",
   "3",
   ",",
   "4",
   ")",
   ",",
   "[",
   "100",
   ",",
   "100",
   ",",
   "255",
   "]",
   "]",
   ",",
   "[",
   "(",
   "4",
   ",",
   "5",
   ")",
   ",",
   "[",
   "50",
   ",",
   "50",
   ",",
   "255",
   "]",
   "]",
   ",",
   "[",
   "(",
   "6",
   ",",
   "3",
   ")",
   ",",
   "[",
   "0",
   ",",
   "0",
   ",",
   "255",
   "]",
   "]",
   ",",
   "# left leg",
   "[",
   "(",
   "6",
   ",",
   "7",
   ")",
   ",",
   "[",
   "255",
   ",",
   "255",
   ",",
   "100",
   "]",
   "]",
   ",",
   "[",
   "(",
   "7",
   ",",
   "8",
   ")",
   ",",
   "[",
   "255",
   ",",
   "150",
   ",",
   "50",
   "]",
   "]",
   ",",
   "# body",
   "[",
   "(",
   "8",
   ",",
   "9",
   ")",
   ",",
   "[",
   "255",
   ",",
   "200",
   ",",
   "100",
   "]",
   "]",
   ",",
   "# head",
   "[",
   "(",
   "10",
   ",",
   "11",
   ")",
   ",",
   "[",
   "255",
   ",",
   "100",
   ",",
   "255",
   "]",
   "]",
   ",",
   "[",
   "(",
   "11",
   ",",
   "12",
   ")",
   ",",
   "[",
   "255",
   ",",
   "50",
   ",",
   "255",
   "]",
   "]",
   ",",
   "[",
   "(",
   "12",
   ",",
   "8",
   ")",
   ",",
   "[",
   "255",
   ",",
   "0",
   ",",
   "255",
   "]",
   "]",
   ",",
   "# right hand",
   "[",
   "(",
   "8",
   ",",
   "13",
   ")",
   ",",
   "[",
   "0",
   ",",
   "255",
   ",",
   "255",
   "]",
   "]",
   ",",
   "[",
   "(",
   "13",
   ",",
   "14",
   ")",
   ",",
   "[",
   "100",
   ",",
   "255",
   ",",
   "255",
   "]",
   "]",
   ",",
   "[",
   "(",
   "14",
   ",",
   "15",
   ")",
   ",",
   "[",
   "200",
   ",",
   "255",
   ",",
   "255",
   "]",
   "]",
   "# left hand",
   "]",
   "for",
   "line",
   "in",
   "lines",
   ":",
   "start",
   ",",
   "end",
   "=",
   "line",
   "[",
   "0",
   "]",
   "if",
   "(",
   "start",
   "in",
   "joint_pos",
   ")",
   "and",
   "(",
   "end",
   "in",
   "joint_pos",
   ")",
   ":",
   "cv2",
   ".",
   "line",
   "(",
   "image",
   ",",
   "(",
   "int",
   "(",
   "joint_pos",
   "[",
   "start",
   "]",
   "[",
   "0",
   "]",
   ")",
   ",",
   "int",
   "(",
   "joint_pos",
   "[",
   "start",
   "]",
   "[",
   "1",
   "]",
   ")",
   ")",
   ",",
   "(",
   "int",
   "(",
   "joint_pos",
   "[",
   "end",
   "]",
   "[",
   "0",
   "]",
   ")",
   ",",
   "int",
   "(",
   "joint_pos",
   "[",
   "end",
   "]",
   "[",
   "1",
   "]",
   ")",
   ")",
   ",",
   "# up-left and botton-right",
   "line",
   "[",
   "1",
   "]",
   ",",
   "thick",
   ")",
   "# rr, cc, val = skimage.draw.line_aa(int(joint_pos[start][1]), int(joint_pos[start][0]), int(joint_pos[end][1]), int(joint_pos[end][0]))",
   "# image[rr, cc] = line[1]",
   "# draw circles",
   "for",
   "pos",
   "in",
   "joint_pos",
   ".",
   "items",
   "(",
   ")",
   ":",
   "_",
   ",",
   "pos_loc",
   "=",
   "pos",
   "# pos_id, pos_loc",
   "pos_loc",
   "=",
   "(",
   "int",
   "(",
   "pos_loc",
   "[",
   "0",
   "]",
   ")",
   ",",
   "int",
   "(",
   "pos_loc",
   "[",
   "1",
   "]",
   ")",
   ")",
   "cv2",
   ".",
   "circle",
   "(",
   "image",
   ",",
   "center",
   "=",
   "pos_loc",
   ",",
   "radius",
   "=",
   "radius",
   ",",
   "color",
   "=",
   "(",
   "200",
   ",",
   "200",
   ",",
   "200",
   ")",
   ",",
   "thickness",
   "=",
   "-",
   "1",
   ")",
   "# rr, cc = skimage.draw.circle(int(pos_loc[1]), int(pos_loc[0]), radius)",
   "# image[rr, cc] = [0, 255, 0]",
   "# Head",
   "head_rect",
   "=",
   "people",
   "[",
   "'head_rect'",
   "]",
   "if",
   "head_rect",
   ":",
   "# if head exists",
   "cv2",
   ".",
   "rectangle",
   "(",
   "image",
   ",",
   "(",
   "int",
   "(",
   "head_rect",
   "[",
   "0",
   "]",
   ")",
   ",",
   "int",
   "(",
   "head_rect",
   "[",
   "1",
   "]",
   ")",
   ")",
   ",",
   "(",
   "int",
   "(",
   "head_rect",
   "[",
   "2",
   "]",
   ")",
   ",",
   "int",
   "(",
   "head_rect",
   "[",
   "3",
   "]",
   ")",
   ")",
   ",",
   "# up-left and botton-right",
   "[",
   "0",
   ",",
   "180",
   ",",
   "0",
   "]",
   ",",
   "thick",
   ")",
   "if",
   "save_name",
   "is",
   "not",
   "None",
   ":",
   "# cv2.imwrite(save_name, image)",
   "save_image",
   "(",
   "image",
   ",",
   "save_name",
   ")",
   "return",
   "image"
  ]
 },
 {
  "idx": "maxmin-607",
  "nl_tokens": [
   "Returns",
   "the",
   "index",
   "of",
   "the",
   "pattern",
   "that",
   "is",
   "closest",
   "to",
   "inputPattern",
   "the",
   "distances",
   "of",
   "all",
   "patterns",
   "to",
   "inputPattern",
   "and",
   "the",
   "indices",
   "of",
   "the",
   "k",
   "closest",
   "categories",
   "."
  ],
  "pl_tokens": [
   "def",
   "getClosest",
   "(",
   "self",
   ",",
   "inputPattern",
   ",",
   "topKCategories",
   "=",
   "3",
   ")",
   ":",
   "inferenceResult",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   "+",
   "1",
   ")",
   "dist",
   "=",
   "self",
   ".",
   "_getDistances",
   "(",
   "inputPattern",
   ")",
   "sorted",
   "=",
   "dist",
   ".",
   "argsort",
   "(",
   ")",
   "validVectorCount",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   "-",
   "self",
   ".",
   "_categoryList",
   ".",
   "count",
   "(",
   "-",
   "1",
   ")",
   "for",
   "j",
   "in",
   "sorted",
   "[",
   ":",
   "min",
   "(",
   "self",
   ".",
   "k",
   ",",
   "validVectorCount",
   ")",
   "]",
   ":",
   "inferenceResult",
   "[",
   "self",
   ".",
   "_categoryList",
   "[",
   "j",
   "]",
   "]",
   "+=",
   "1.0",
   "winner",
   "=",
   "inferenceResult",
   ".",
   "argmax",
   "(",
   ")",
   "topNCats",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "topKCategories",
   ")",
   ":",
   "topNCats",
   ".",
   "append",
   "(",
   "(",
   "self",
   ".",
   "_categoryList",
   "[",
   "sorted",
   "[",
   "i",
   "]",
   "]",
   ",",
   "dist",
   "[",
   "sorted",
   "[",
   "i",
   "]",
   "]",
   ")",
   ")",
   "return",
   "winner",
   ",",
   "dist",
   ",",
   "topNCats"
  ]
 },
 {
  "idx": "maxmin-608",
  "nl_tokens": [
   "Create",
   "a",
   "segment",
   "on",
   "the",
   "connections",
   "enforcing",
   "the",
   "maxSegmentsPerCell",
   "parameter",
   "."
  ],
  "pl_tokens": [
   "def",
   "_createSegment",
   "(",
   "cls",
   ",",
   "connections",
   ",",
   "lastUsedIterationForSegment",
   ",",
   "cell",
   ",",
   "iteration",
   ",",
   "maxSegmentsPerCell",
   ")",
   ":",
   "# Enforce maxSegmentsPerCell.",
   "while",
   "connections",
   ".",
   "numSegments",
   "(",
   "cell",
   ")",
   ">=",
   "maxSegmentsPerCell",
   ":",
   "leastRecentlyUsedSegment",
   "=",
   "<mask>",
   "(",
   "connections",
   ".",
   "segmentsForCell",
   "(",
   "cell",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "segment",
   ":",
   "lastUsedIterationForSegment",
   "[",
   "segment",
   ".",
   "flatIdx",
   "]",
   ")",
   "connections",
   ".",
   "destroySegment",
   "(",
   "leastRecentlyUsedSegment",
   ")",
   "# Create the segment.",
   "segment",
   "=",
   "connections",
   ".",
   "createSegment",
   "(",
   "cell",
   ")",
   "# Do TM-specific bookkeeping for the segment.",
   "if",
   "segment",
   ".",
   "flatIdx",
   "==",
   "len",
   "(",
   "lastUsedIterationForSegment",
   ")",
   ":",
   "lastUsedIterationForSegment",
   ".",
   "append",
   "(",
   "iteration",
   ")",
   "elif",
   "segment",
   ".",
   "flatIdx",
   "<",
   "len",
   "(",
   "lastUsedIterationForSegment",
   ")",
   ":",
   "# A flatIdx was recycled.",
   "lastUsedIterationForSegment",
   "[",
   "segment",
   ".",
   "flatIdx",
   "]",
   "=",
   "iteration",
   "else",
   ":",
   "raise",
   "AssertionError",
   "(",
   "\"All segments should be created with the TM createSegment method.\"",
   ")",
   "return",
   "segment"
  ]
 },
 {
  "idx": "maxmin-609",
  "nl_tokens": [
   "Variance",
   "ratio",
   "between",
   "K",
   "and",
   "I",
   "."
  ],
  "pl_tokens": [
   "def",
   "delta",
   "(",
   "self",
   ")",
   ":",
   "v",
   "=",
   "float",
   "(",
   "self",
   ".",
   "_logistic",
   ".",
   "value",
   ")",
   "if",
   "v",
   ">",
   "0.0",
   ":",
   "v",
   "=",
   "1",
   "/",
   "(",
   "1",
   "+",
   "exp",
   "(",
   "-",
   "v",
   ")",
   ")",
   "else",
   ":",
   "v",
   "=",
   "exp",
   "(",
   "v",
   ")",
   "v",
   "=",
   "v",
   "/",
   "(",
   "v",
   "+",
   "1.0",
   ")",
   "return",
   "<mask>",
   "(",
   "max",
   "(",
   "v",
   ",",
   "epsilon",
   ".",
   "tiny",
   ")",
   ",",
   "1",
   "-",
   "epsilon",
   ".",
   "tiny",
   ")"
  ]
 },
 {
  "idx": "maxmin-610",
  "nl_tokens": [
   "Create",
   "a",
   "transaction",
   "in",
   "the",
   "general",
   "ledger",
   "."
  ],
  "pl_tokens": [
   "def",
   "create_transaction",
   "(",
   "self",
   ",",
   "name",
   ",",
   "description",
   "=",
   "None",
   ",",
   "tx_date",
   "=",
   "datetime",
   ".",
   "<mask>",
   ".",
   "date",
   "(",
   ")",
   ",",
   "dt_account",
   "=",
   "None",
   ",",
   "cr_account",
   "=",
   "None",
   ",",
   "source",
   "=",
   "None",
   ",",
   "amount",
   "=",
   "0.00",
   ")",
   ":",
   "new_tx",
   "=",
   "Transaction",
   "(",
   "name",
   ",",
   "description",
   ",",
   "tx_date",
   ",",
   "dt_account",
   ",",
   "cr_account",
   ",",
   "source",
   ",",
   "amount",
   ")",
   "self",
   ".",
   "transactions",
   ".",
   "append",
   "(",
   "new_tx",
   ")",
   "return",
   "new_tx"
  ]
 },
 {
  "idx": "maxmin-611",
  "nl_tokens": [
   "For",
   "each",
   "traded",
   "name",
   "find",
   "the",
   "daily",
   "transaction",
   "total",
   "that",
   "consumed",
   "the",
   "greatest",
   "proportion",
   "of",
   "available",
   "daily",
   "bar",
   "volume",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_low_liquidity_transactions",
   "(",
   "transactions",
   ",",
   "market_data",
   ",",
   "last_n_days",
   "=",
   "None",
   ")",
   ":",
   "txn_daily_w_bar",
   "=",
   "daily_txns_with_bar_data",
   "(",
   "transactions",
   ",",
   "market_data",
   ")",
   "txn_daily_w_bar",
   ".",
   "index",
   ".",
   "name",
   "=",
   "'date'",
   "txn_daily_w_bar",
   "=",
   "txn_daily_w_bar",
   ".",
   "reset_index",
   "(",
   ")",
   "if",
   "last_n_days",
   "is",
   "not",
   "None",
   ":",
   "md",
   "=",
   "txn_daily_w_bar",
   ".",
   "date",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "pd",
   ".",
   "Timedelta",
   "(",
   "days",
   "=",
   "last_n_days",
   ")",
   "txn_daily_w_bar",
   "=",
   "txn_daily_w_bar",
   "[",
   "txn_daily_w_bar",
   ".",
   "date",
   ">",
   "md",
   "]",
   "bar_consumption",
   "=",
   "txn_daily_w_bar",
   ".",
   "assign",
   "(",
   "max_pct_bar_consumed",
   "=",
   "(",
   "txn_daily_w_bar",
   ".",
   "amount",
   "/",
   "txn_daily_w_bar",
   ".",
   "volume",
   ")",
   "*",
   "100",
   ")",
   ".",
   "sort_values",
   "(",
   "'max_pct_bar_consumed'",
   ",",
   "ascending",
   "=",
   "False",
   ")",
   "max_bar_consumption",
   "=",
   "bar_consumption",
   ".",
   "groupby",
   "(",
   "'symbol'",
   ")",
   ".",
   "first",
   "(",
   ")",
   "return",
   "max_bar_consumption",
   "[",
   "[",
   "'date'",
   ",",
   "'max_pct_bar_consumed'",
   "]",
   "]"
  ]
 },
 {
  "idx": "maxmin-612",
  "nl_tokens": [
   "Remove",
   "labels",
   "from",
   "each",
   "record",
   "with",
   "record",
   "ROWID",
   "in",
   "range",
   "from",
   "start",
   "to",
   "end",
   "noninclusive",
   "of",
   "end",
   ".",
   "Removes",
   "all",
   "records",
   "if",
   "labelFilter",
   "is",
   "None",
   "otherwise",
   "only",
   "removes",
   "the",
   "labels",
   "equal",
   "to",
   "labelFilter",
   "."
  ],
  "pl_tokens": [
   "def",
   "removeLabels",
   "(",
   "self",
   ",",
   "start",
   "=",
   "None",
   ",",
   "end",
   "=",
   "None",
   ",",
   "labelFilter",
   "=",
   "None",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for \"",
   "\"'removeLabels'. Model has no saved records.\"",
   ")",
   "try",
   ":",
   "start",
   "=",
   "int",
   "(",
   "start",
   ")",
   "except",
   "Exception",
   ":",
   "start",
   "=",
   "0",
   "try",
   ":",
   "end",
   "=",
   "int",
   "(",
   "end",
   ")",
   "except",
   "Exception",
   ":",
   "end",
   "=",
   "self",
   ".",
   "_recordsCache",
   "[",
   "-",
   "1",
   "]",
   ".",
   "ROWID",
   "startID",
   "=",
   "self",
   ".",
   "_recordsCache",
   "[",
   "0",
   "]",
   ".",
   "ROWID",
   "clippedStart",
   "=",
   "0",
   "if",
   "start",
   "is",
   "None",
   "else",
   "<mask>",
   "(",
   "0",
   ",",
   "start",
   "-",
   "startID",
   ")",
   "clippedEnd",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "if",
   "end",
   "is",
   "None",
   "else",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   ",",
   "end",
   "-",
   "startID",
   ")",
   ")",
   "if",
   "clippedEnd",
   "<=",
   "clippedStart",
   ":",
   "raise",
   "HTMPredictionModelInvalidRangeError",
   "(",
   "\"Invalid supplied range for \"",
   "\"'removeLabels'.\"",
   ",",
   "debugInfo",
   "=",
   "{",
   "'requestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "start",
   ",",
   "'endRecordID'",
   ":",
   "end",
   "}",
   ",",
   "'clippedRequestRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "clippedStart",
   ",",
   "'endRecordID'",
   ":",
   "clippedEnd",
   "}",
   ",",
   "'validRange'",
   ":",
   "{",
   "'startRecordID'",
   ":",
   "startID",
   ",",
   "'endRecordID'",
   ":",
   "self",
   ".",
   "_recordsCache",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "-",
   "1",
   "]",
   ".",
   "ROWID",
   "}",
   ",",
   "'numRecordsStored'",
   ":",
   "len",
   "(",
   "self",
   ".",
   "_recordsCache",
   ")",
   "}",
   ")",
   "# Remove records within the cache",
   "recordsToDelete",
   "=",
   "[",
   "]",
   "for",
   "state",
   "in",
   "self",
   ".",
   "_recordsCache",
   "[",
   "clippedStart",
   ":",
   "clippedEnd",
   "]",
   ":",
   "if",
   "labelFilter",
   "is",
   "not",
   "None",
   ":",
   "if",
   "labelFilter",
   "in",
   "state",
   ".",
   "anomalyLabel",
   ":",
   "state",
   ".",
   "anomalyLabel",
   ".",
   "remove",
   "(",
   "labelFilter",
   ")",
   "else",
   ":",
   "state",
   ".",
   "anomalyLabel",
   "=",
   "[",
   "]",
   "state",
   ".",
   "setByUser",
   "=",
   "False",
   "recordsToDelete",
   ".",
   "append",
   "(",
   "state",
   ")",
   "self",
   ".",
   "_deleteRecordsFromKNN",
   "(",
   "recordsToDelete",
   ")",
   "# Remove records not in cache",
   "self",
   ".",
   "_deleteRangeFromKNN",
   "(",
   "start",
   ",",
   "end",
   ")",
   "# Recompute [clippedEnd, ...)",
   "for",
   "state",
   "in",
   "self",
   ".",
   "_recordsCache",
   "[",
   "clippedEnd",
   ":",
   "]",
   ":",
   "self",
   ".",
   "_classifyState",
   "(",
   "state",
   ")"
  ]
 },
 {
  "idx": "maxmin-613",
  "nl_tokens": [
   "Count",
   "bit",
   "errors",
   "between",
   "a",
   "transmitted",
   "and",
   "received",
   "QPSK",
   "signal",
   ".",
   "Time",
   "delay",
   "between",
   "streams",
   "is",
   "detected",
   "as",
   "well",
   "as",
   "ambiquity",
   "resolution",
   "due",
   "to",
   "carrier",
   "phase",
   "lock",
   "offsets",
   "of",
   ":",
   "math",
   ":",
   "k",
   "*",
   "\\\\",
   "frac",
   "{",
   "\\\\",
   "pi",
   "}",
   "{",
   "4",
   "}",
   "k",
   "=",
   "0",
   "1",
   "2",
   "3",
   ".",
   "The",
   "ndarray",
   "sdata",
   "is",
   "Tx",
   "+",
   "/",
   "-",
   "1",
   "symbols",
   "as",
   "complex",
   "numbers",
   "I",
   "+",
   "j",
   "*",
   "Q",
   ".",
   "The",
   "ndarray",
   "data",
   "is",
   "Rx",
   "+",
   "/",
   "-",
   "1",
   "symbols",
   "as",
   "complex",
   "numbers",
   "I",
   "+",
   "j",
   "*",
   "Q",
   ".",
   "Note",
   ":",
   "Ncorr",
   "needs",
   "to",
   "be",
   "even"
  ],
  "pl_tokens": [
   "def",
   "QPSK_BEP",
   "(",
   "tx_data",
   ",",
   "rx_data",
   ",",
   "Ncorr",
   "=",
   "1024",
   ",",
   "Ntransient",
   "=",
   "0",
   ")",
   ":",
   "#Remove Ntransient symbols",
   "tx_data",
   "=",
   "tx_data",
   "[",
   "Ntransient",
   ":",
   "]",
   "rx_data",
   "=",
   "rx_data",
   "[",
   "Ntransient",
   ":",
   "]",
   "#Correlate the first Ncorr symbols at four possible phase rotations",
   "R0",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "ifft",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "rx_data",
   ",",
   "Ncorr",
   ")",
   "*",
   "np",
   ".",
   "conj",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   ")",
   ")",
   "R1",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "ifft",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "1j",
   "*",
   "rx_data",
   ",",
   "Ncorr",
   ")",
   "*",
   "np",
   ".",
   "conj",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   ")",
   ")",
   "R2",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "ifft",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "-",
   "1",
   "*",
   "rx_data",
   ",",
   "Ncorr",
   ")",
   "*",
   "np",
   ".",
   "conj",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   ")",
   ")",
   "R3",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "ifft",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "-",
   "1j",
   "*",
   "rx_data",
   ",",
   "Ncorr",
   ")",
   "*",
   "np",
   ".",
   "conj",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   ")",
   ")",
   "#Place the zero lag value in the center of the array",
   "R0",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fftshift",
   "(",
   "R0",
   ")",
   "R1",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fftshift",
   "(",
   "R1",
   ")",
   "R2",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fftshift",
   "(",
   "R2",
   ")",
   "R3",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fftshift",
   "(",
   "R3",
   ")",
   "R0max",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "R0",
   ".",
   "real",
   ")",
   "R1max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R1",
   ".",
   "real",
   ")",
   "R2max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R2",
   ".",
   "real",
   ")",
   "R3max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R3",
   ".",
   "real",
   ")",
   "R",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "R0max",
   ",",
   "R1max",
   ",",
   "R2max",
   ",",
   "R3max",
   "]",
   ")",
   "Rmax",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R",
   ")",
   "kphase_max",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "kmax",
   "=",
   "kphase_max",
   "[",
   "0",
   "]",
   "#Correlation lag value is zero at the center of the array",
   "if",
   "kmax",
   "==",
   "0",
   ":",
   "lagmax",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R0",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "-",
   "Ncorr",
   "/",
   "2",
   "elif",
   "kmax",
   "==",
   "1",
   ":",
   "lagmax",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R1",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "-",
   "Ncorr",
   "/",
   "2",
   "elif",
   "kmax",
   "==",
   "2",
   ":",
   "lagmax",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R2",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "-",
   "Ncorr",
   "/",
   "2",
   "elif",
   "kmax",
   "==",
   "3",
   ":",
   "lagmax",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R3",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "-",
   "Ncorr",
   "/",
   "2",
   "taumax",
   "=",
   "lagmax",
   "[",
   "0",
   "]",
   "print",
   "(",
   "'kmax =  %d, taumax = %d'",
   "%",
   "(",
   "kmax",
   ",",
   "taumax",
   ")",
   ")",
   "# Count bit and symbol errors over the entire input ndarrays",
   "# Begin by making tx and rx length equal and apply phase rotation to rx",
   "if",
   "taumax",
   "<",
   "0",
   ":",
   "tx_data",
   "=",
   "tx_data",
   "[",
   "-",
   "taumax",
   ":",
   "]",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "min",
   "(",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   ")",
   "]",
   "rx_data",
   "=",
   "1j",
   "**",
   "kmax",
   "*",
   "rx_data",
   "[",
   ":",
   "len",
   "(",
   "tx_data",
   ")",
   "]",
   "else",
   ":",
   "rx_data",
   "=",
   "1j",
   "**",
   "kmax",
   "*",
   "rx_data",
   "[",
   "taumax",
   ":",
   "]",
   "rx_data",
   "=",
   "rx_data",
   "[",
   ":",
   "min",
   "(",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   ")",
   "]",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "len",
   "(",
   "rx_data",
   ")",
   "]",
   "#Convert to 0's and 1's",
   "S_count",
   "=",
   "len",
   "(",
   "tx_data",
   ")",
   "tx_I",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "(",
   "tx_data",
   ".",
   "real",
   "+",
   "1",
   ")",
   "/",
   "2",
   ")",
   "tx_Q",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "(",
   "tx_data",
   ".",
   "imag",
   "+",
   "1",
   ")",
   "/",
   "2",
   ")",
   "rx_I",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "(",
   "rx_data",
   ".",
   "real",
   "+",
   "1",
   ")",
   "/",
   "2",
   ")",
   "rx_Q",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "(",
   "rx_data",
   ".",
   "imag",
   "+",
   "1",
   ")",
   "/",
   "2",
   ")",
   "I_errors",
   "=",
   "tx_I",
   "^",
   "rx_I",
   "Q_errors",
   "=",
   "tx_Q",
   "^",
   "rx_Q",
   "#A symbol errors occurs when I or Q or both are in error",
   "S_errors",
   "=",
   "I_errors",
   "|",
   "Q_errors",
   "#return 0",
   "return",
   "S_count",
   ",",
   "np",
   ".",
   "sum",
   "(",
   "I_errors",
   ")",
   ",",
   "np",
   ".",
   "sum",
   "(",
   "Q_errors",
   ")",
   ",",
   "np",
   ".",
   "sum",
   "(",
   "S_errors",
   ")"
  ]
 },
 {
  "idx": "maxmin-614",
  "nl_tokens": [
   "This",
   "plots",
   "the",
   "training",
   "results",
   "from",
   "the",
   "classifier",
   "run",
   "on",
   "the",
   "training",
   "set",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_training_results",
   "(",
   "classifier",
   ",",
   "classlabels",
   ",",
   "outfile",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "classifier",
   ",",
   "str",
   ")",
   "and",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "classifier",
   ")",
   ":",
   "with",
   "open",
   "(",
   "classifier",
   ",",
   "'rb'",
   ")",
   "as",
   "infd",
   ":",
   "clfdict",
   "=",
   "pickle",
   ".",
   "load",
   "(",
   "infd",
   ")",
   "elif",
   "isinstance",
   "(",
   "classifier",
   ",",
   "dict",
   ")",
   ":",
   "clfdict",
   "=",
   "classifier",
   "else",
   ":",
   "LOGERROR",
   "(",
   "\"can't figure out the input classifier arg\"",
   ")",
   "return",
   "None",
   "confmatrix",
   "=",
   "clfdict",
   "[",
   "'best_confmatrix'",
   "]",
   "overall_feature_importances",
   "=",
   "clfdict",
   "[",
   "'best_classifier'",
   "]",
   ".",
   "feature_importances_",
   "feature_importances_per_tree",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "tree",
   ".",
   "feature_importances_",
   "for",
   "tree",
   "in",
   "clfdict",
   "[",
   "'best_classifier'",
   "]",
   ".",
   "estimators_",
   "]",
   ")",
   "stdev_feature_importances",
   "=",
   "np",
   ".",
   "std",
   "(",
   "feature_importances_per_tree",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "feature_names",
   "=",
   "np",
   ".",
   "array",
   "(",
   "clfdict",
   "[",
   "'feature_names'",
   "]",
   ")",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "6.4",
   "*",
   "3.0",
   ",",
   "4.8",
   ")",
   ")",
   "# confusion matrix",
   "plt",
   ".",
   "subplot",
   "(",
   "121",
   ")",
   "classes",
   "=",
   "np",
   ".",
   "array",
   "(",
   "classlabels",
   ")",
   "plt",
   ".",
   "imshow",
   "(",
   "confmatrix",
   ",",
   "interpolation",
   "=",
   "'nearest'",
   ",",
   "cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "Blues",
   ")",
   "tick_marks",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "classes",
   ")",
   ")",
   "plt",
   ".",
   "xticks",
   "(",
   "tick_marks",
   ",",
   "classes",
   ")",
   "plt",
   ".",
   "yticks",
   "(",
   "tick_marks",
   ",",
   "classes",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'evaluation set confusion matrix'",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'predicted class'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'actual class'",
   ")",
   "thresh",
   "=",
   "confmatrix",
   ".",
   "<mask>",
   "(",
   ")",
   "/",
   "2.",
   "for",
   "i",
   ",",
   "j",
   "in",
   "itertools",
   ".",
   "product",
   "(",
   "range",
   "(",
   "confmatrix",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ",",
   "range",
   "(",
   "confmatrix",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   ":",
   "plt",
   ".",
   "text",
   "(",
   "j",
   ",",
   "i",
   ",",
   "confmatrix",
   "[",
   "i",
   ",",
   "j",
   "]",
   ",",
   "horizontalalignment",
   "=",
   "\"center\"",
   ",",
   "color",
   "=",
   "\"white\"",
   "if",
   "confmatrix",
   "[",
   "i",
   ",",
   "j",
   "]",
   ">",
   "thresh",
   "else",
   "\"black\"",
   ")",
   "# feature importances",
   "plt",
   ".",
   "subplot",
   "(",
   "122",
   ")",
   "features",
   "=",
   "np",
   ".",
   "array",
   "(",
   "feature_names",
   ")",
   "sorted_ind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "overall_feature_importances",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "features",
   "=",
   "features",
   "[",
   "sorted_ind",
   "]",
   "feature_names",
   "=",
   "feature_names",
   "[",
   "sorted_ind",
   "]",
   "overall_feature_importances",
   "=",
   "overall_feature_importances",
   "[",
   "sorted_ind",
   "]",
   "stdev_feature_importances",
   "=",
   "stdev_feature_importances",
   "[",
   "sorted_ind",
   "]",
   "plt",
   ".",
   "bar",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "features",
   ".",
   "size",
   ")",
   ",",
   "overall_feature_importances",
   ",",
   "yerr",
   "=",
   "stdev_feature_importances",
   ",",
   "width",
   "=",
   "0.8",
   ",",
   "color",
   "=",
   "'grey'",
   ")",
   "plt",
   ".",
   "xticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "features",
   ".",
   "size",
   ")",
   ",",
   "features",
   ",",
   "rotation",
   "=",
   "90",
   ")",
   "plt",
   ".",
   "yticks",
   "(",
   "[",
   "0.0",
   ",",
   "0.1",
   ",",
   "0.2",
   ",",
   "0.3",
   ",",
   "0.4",
   ",",
   "0.5",
   ",",
   "0.6",
   ",",
   "0.7",
   ",",
   "0.8",
   ",",
   "0.9",
   ",",
   "1.0",
   "]",
   ")",
   "plt",
   ".",
   "xlim",
   "(",
   "-",
   "0.75",
   ",",
   "features",
   ".",
   "size",
   "-",
   "1.0",
   "+",
   "0.75",
   ")",
   "plt",
   ".",
   "ylim",
   "(",
   "0.0",
   ",",
   "0.9",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'relative importance'",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'relative importance of features'",
   ")",
   "plt",
   ".",
   "subplots_adjust",
   "(",
   "wspace",
   "=",
   "0.1",
   ")",
   "plt",
   ".",
   "savefig",
   "(",
   "outfile",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "100",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "'all'",
   ")",
   "return",
   "outfile"
  ]
 },
 {
  "idx": "maxmin-615",
  "nl_tokens": [
   "Play",
   "the",
   "queue",
   "from",
   "a",
   "specific",
   "point",
   ".",
   "Disregards",
   "tracks",
   "before",
   "the",
   "index",
   "."
  ],
  "pl_tokens": [
   "async",
   "def",
   "play_at",
   "(",
   "self",
   ",",
   "index",
   ":",
   "int",
   ")",
   ":",
   "self",
   ".",
   "queue",
   "=",
   "self",
   ".",
   "queue",
   "[",
   "<mask>",
   "(",
   "index",
   ",",
   "len",
   "(",
   "self",
   ".",
   "queue",
   ")",
   "-",
   "1",
   ")",
   ":",
   "len",
   "(",
   "self",
   ".",
   "queue",
   ")",
   "]",
   "await",
   "self",
   ".",
   "play",
   "(",
   "ignore_shuffle",
   "=",
   "True",
   ")"
  ]
 },
 {
  "idx": "maxmin-616",
  "nl_tokens": [
   "Plugin",
   "to",
   "get",
   "a",
   "loopless",
   "FVA",
   "solution",
   "from",
   "single",
   "FVA",
   "iteration",
   "."
  ],
  "pl_tokens": [
   "def",
   "loopless_fva_iter",
   "(",
   "model",
   ",",
   "reaction",
   ",",
   "solution",
   "=",
   "False",
   ",",
   "zero_cutoff",
   "=",
   "None",
   ")",
   ":",
   "zero_cutoff",
   "=",
   "normalize_cutoff",
   "(",
   "model",
   ",",
   "zero_cutoff",
   ")",
   "current",
   "=",
   "model",
   ".",
   "objective",
   ".",
   "value",
   "sol",
   "=",
   "get_solution",
   "(",
   "model",
   ")",
   "objective_dir",
   "=",
   "model",
   ".",
   "objective",
   ".",
   "direction",
   "# boundary reactions can not be part of cycles",
   "if",
   "reaction",
   ".",
   "boundary",
   ":",
   "if",
   "solution",
   ":",
   "return",
   "sol",
   "else",
   ":",
   "return",
   "current",
   "with",
   "model",
   ":",
   "_add_cycle_free",
   "(",
   "model",
   ",",
   "sol",
   ".",
   "fluxes",
   ")",
   "model",
   ".",
   "slim_optimize",
   "(",
   ")",
   "# If the previous optimum is maintained in the loopless solution it was",
   "# loopless and we are done",
   "if",
   "abs",
   "(",
   "reaction",
   ".",
   "flux",
   "-",
   "current",
   ")",
   "<",
   "zero_cutoff",
   ":",
   "if",
   "solution",
   ":",
   "return",
   "sol",
   "return",
   "current",
   "# If previous optimum was not in the loopless solution create a new",
   "# almost loopless solution containing only loops including the current",
   "# reaction. Than remove all of those loops.",
   "ll_sol",
   "=",
   "get_solution",
   "(",
   "model",
   ")",
   ".",
   "fluxes",
   "reaction",
   ".",
   "bounds",
   "=",
   "(",
   "current",
   ",",
   "current",
   ")",
   "model",
   ".",
   "slim_optimize",
   "(",
   ")",
   "almost_ll_sol",
   "=",
   "get_solution",
   "(",
   "model",
   ")",
   ".",
   "fluxes",
   "with",
   "model",
   ":",
   "# find the reactions with loops using the current reaction and remove",
   "# the loops",
   "for",
   "rxn",
   "in",
   "model",
   ".",
   "reactions",
   ":",
   "rid",
   "=",
   "rxn",
   ".",
   "id",
   "if",
   "(",
   "(",
   "abs",
   "(",
   "ll_sol",
   "[",
   "rid",
   "]",
   ")",
   "<",
   "zero_cutoff",
   ")",
   "and",
   "(",
   "abs",
   "(",
   "almost_ll_sol",
   "[",
   "rid",
   "]",
   ")",
   ">",
   "zero_cutoff",
   ")",
   ")",
   ":",
   "rxn",
   ".",
   "bounds",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "rxn",
   ".",
   "lower_bound",
   ")",
   ",",
   "min",
   "(",
   "0",
   ",",
   "rxn",
   ".",
   "upper_bound",
   ")",
   "if",
   "solution",
   ":",
   "best",
   "=",
   "model",
   ".",
   "optimize",
   "(",
   ")",
   "else",
   ":",
   "model",
   ".",
   "slim_optimize",
   "(",
   ")",
   "best",
   "=",
   "reaction",
   ".",
   "flux",
   "model",
   ".",
   "objective",
   ".",
   "direction",
   "=",
   "objective_dir",
   "return",
   "best"
  ]
 },
 {
  "idx": "maxmin-617",
  "nl_tokens": [
   "Returns",
   "radius",
   "for",
   "given",
   "speed",
   "."
  ],
  "pl_tokens": [
   "def",
   "radiusForSpeed",
   "(",
   "self",
   ",",
   "speed",
   ")",
   ":",
   "overlap",
   "=",
   "1.5",
   "coordinatesPerTimestep",
   "=",
   "speed",
   "*",
   "self",
   ".",
   "timestep",
   "/",
   "self",
   ".",
   "scale",
   "radius",
   "=",
   "int",
   "(",
   "round",
   "(",
   "float",
   "(",
   "coordinatesPerTimestep",
   ")",
   "/",
   "2",
   "*",
   "overlap",
   ")",
   ")",
   "minRadius",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "(",
   "math",
   ".",
   "sqrt",
   "(",
   "self",
   ".",
   "w",
   ")",
   "-",
   "1",
   ")",
   "/",
   "2",
   ")",
   ")",
   "return",
   "<mask>",
   "(",
   "radius",
   ",",
   "minRadius",
   ")"
  ]
 },
 {
  "idx": "maxmin-618",
  "nl_tokens": [
   "Takes",
   "a",
   "decimal",
   "and",
   "returns",
   "base91",
   "char",
   "string",
   ".",
   "With",
   "optional",
   "parameter",
   "for",
   "fix",
   "with",
   "output"
  ],
  "pl_tokens": [
   "def",
   "from_decimal",
   "(",
   "number",
   ",",
   "width",
   "=",
   "1",
   ")",
   ":",
   "text",
   "=",
   "[",
   "]",
   "if",
   "not",
   "isinstance",
   "(",
   "number",
   ",",
   "int_type",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Expected number to be int, got %s\"",
   ",",
   "type",
   "(",
   "number",
   ")",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "width",
   ",",
   "int_type",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Expected width to be int, got %s\"",
   ",",
   "type",
   "(",
   "number",
   ")",
   ")",
   "elif",
   "number",
   "<",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Expected number to be positive integer\"",
   ")",
   "elif",
   "number",
   ">",
   "0",
   ":",
   "max_n",
   "=",
   "ceil",
   "(",
   "log",
   "(",
   "number",
   ")",
   "/",
   "log",
   "(",
   "91",
   ")",
   ")",
   "for",
   "n",
   "in",
   "_range",
   "(",
   "int",
   "(",
   "max_n",
   ")",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   ":",
   "quotient",
   ",",
   "number",
   "=",
   "divmod",
   "(",
   "number",
   ",",
   "91",
   "**",
   "n",
   ")",
   "text",
   ".",
   "append",
   "(",
   "chr",
   "(",
   "33",
   "+",
   "quotient",
   ")",
   ")",
   "return",
   "\"\"",
   ".",
   "join",
   "(",
   "text",
   ")",
   ".",
   "lstrip",
   "(",
   "'!'",
   ")",
   ".",
   "rjust",
   "(",
   "<mask>",
   "(",
   "1",
   ",",
   "width",
   ")",
   ",",
   "'!'",
   ")"
  ]
 },
 {
  "idx": "maxmin-619",
  "nl_tokens": [
   "Return",
   "an",
   "integer",
   "index",
   "or",
   "None"
  ],
  "pl_tokens": [
   "def",
   "index",
   "(",
   "self",
   ",",
   "i",
   ",",
   "length",
   "=",
   "None",
   ")",
   ":",
   "if",
   "self",
   ".",
   "begin",
   "<=",
   "i",
   "<=",
   "self",
   ".",
   "end",
   ":",
   "index",
   "=",
   "i",
   "-",
   "self",
   ".",
   "BEGIN",
   "-",
   "self",
   ".",
   "offset",
   "if",
   "length",
   "is",
   "None",
   ":",
   "length",
   "=",
   "self",
   ".",
   "full_range",
   "(",
   ")",
   "else",
   ":",
   "length",
   "=",
   "<mask>",
   "(",
   "length",
   ",",
   "self",
   ".",
   "full_range",
   "(",
   ")",
   ")",
   "if",
   "0",
   "<=",
   "index",
   "<",
   "length",
   ":",
   "return",
   "index"
  ]
 },
 {
  "idx": "maxmin-620",
  "nl_tokens": [
   "submits",
   "a",
   "job",
   "to",
   "run",
   "on",
   "the",
   "cluster",
   "and",
   "returns",
   "an",
   "asynchronous",
   "result",
   "object",
   ".",
   "K",
   "is",
   "the",
   "number",
   "of",
   "populations",
   "randomseed",
   "if",
   "not",
   "set",
   "will",
   "be",
   "randomly",
   "drawn",
   "ipyclient",
   "if",
   "not",
   "entered",
   "will",
   "raise",
   "an",
   "error",
   ".",
   "If",
   "nreps",
   "is",
   "set",
   "then",
   "multiple",
   "jobs",
   "will",
   "be",
   "started",
   "from",
   "new",
   "seeds",
   "each",
   "labeled",
   "by",
   "its",
   "replicate",
   "number",
   ".",
   "If",
   "force",
   "=",
   "True",
   "then",
   "replicates",
   "will",
   "be",
   "overwritten",
   "otherwise",
   "new",
   "replicates",
   "will",
   "be",
   "created",
   "starting",
   "with",
   "the",
   "last",
   "file",
   "N",
   "found",
   "in",
   "the",
   "workdir",
   "."
  ],
  "pl_tokens": [
   "def",
   "run",
   "(",
   "self",
   ",",
   "kpop",
   ",",
   "nreps",
   ",",
   "ipyclient",
   "=",
   "None",
   ",",
   "seed",
   "=",
   "12345",
   ",",
   "force",
   "=",
   "False",
   ",",
   "quiet",
   "=",
   "False",
   ",",
   ")",
   ":",
   "## initiate starting seed",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "seed",
   ")",
   "## check for stuructre here",
   "proc",
   "=",
   "subprocess",
   ".",
   "Popen",
   "(",
   "[",
   "\"which\"",
   ",",
   "\"structure\"",
   "]",
   ",",
   "stdout",
   "=",
   "subprocess",
   ".",
   "PIPE",
   ",",
   "stderr",
   "=",
   "subprocess",
   ".",
   "STDOUT",
   ")",
   ".",
   "communicate",
   "(",
   ")",
   "if",
   "not",
   "proc",
   ":",
   "raise",
   "Exception",
   "(",
   "\"structure is not installed: run `conda install structure -c ipyrad`\"",
   ")",
   "## start load balancer",
   "if",
   "ipyclient",
   ":",
   "lbview",
   "=",
   "ipyclient",
   ".",
   "load_balanced_view",
   "(",
   ")",
   "## remove old jobs with this same name",
   "handle",
   "=",
   "OPJ",
   "(",
   "self",
   ".",
   "workdir",
   ",",
   "self",
   ".",
   "name",
   "+",
   "\"-K-{}-*\"",
   ".",
   "format",
   "(",
   "kpop",
   ")",
   ")",
   "oldjobs",
   "=",
   "glob",
   ".",
   "glob",
   "(",
   "handle",
   ")",
   "if",
   "force",
   "or",
   "(",
   "not",
   "oldjobs",
   ")",
   ":",
   "for",
   "job",
   "in",
   "oldjobs",
   ":",
   "os",
   ".",
   "remove",
   "(",
   "job",
   ")",
   "repstart",
   "=",
   "0",
   "repend",
   "=",
   "nreps",
   "else",
   ":",
   "repstart",
   "=",
   "<mask>",
   "(",
   "[",
   "int",
   "(",
   "i",
   ".",
   "split",
   "(",
   "\"-\"",
   ")",
   "[",
   "-",
   "1",
   "]",
   "[",
   ":",
   "-",
   "2",
   "]",
   ")",
   "for",
   "i",
   "in",
   "oldjobs",
   "]",
   ")",
   "repend",
   "=",
   "repstart",
   "+",
   "nreps",
   "## check that there is a ipcluster instance running",
   "for",
   "rep",
   "in",
   "xrange",
   "(",
   "repstart",
   ",",
   "repend",
   ")",
   ":",
   "## sample random seed for this rep",
   "self",
   ".",
   "extraparams",
   ".",
   "seed",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "1e9",
   ",",
   "1",
   ")",
   "[",
   "0",
   "]",
   "## prepare files (randomly subsamples snps if mapfile)",
   "mname",
   ",",
   "ename",
   ",",
   "sname",
   "=",
   "self",
   ".",
   "write_structure_files",
   "(",
   "kpop",
   ",",
   "rep",
   ")",
   "args",
   "=",
   "[",
   "mname",
   ",",
   "ename",
   ",",
   "sname",
   ",",
   "self",
   ".",
   "name",
   ",",
   "self",
   ".",
   "workdir",
   ",",
   "self",
   ".",
   "extraparams",
   ".",
   "seed",
   ",",
   "self",
   ".",
   "ntaxa",
   ",",
   "self",
   ".",
   "nsites",
   ",",
   "kpop",
   ",",
   "rep",
   "]",
   "if",
   "ipyclient",
   ":",
   "## call structure",
   "async",
   "=",
   "lbview",
   ".",
   "apply",
   "(",
   "_call_structure",
   ",",
   "*",
   "(",
   "args",
   ")",
   ")",
   "self",
   ".",
   "asyncs",
   ".",
   "append",
   "(",
   "async",
   ")",
   "else",
   ":",
   "if",
   "not",
   "quiet",
   ":",
   "sys",
   ".",
   "stderr",
   ".",
   "write",
   "(",
   "\"submitted 1 structure job [{}-K-{}]\\n\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "name",
   ",",
   "kpop",
   ")",
   ")",
   "comm",
   "=",
   "_call_structure",
   "(",
   "*",
   "args",
   ")",
   "return",
   "comm",
   "if",
   "ipyclient",
   ":",
   "if",
   "not",
   "quiet",
   ":",
   "sys",
   ".",
   "stderr",
   ".",
   "write",
   "(",
   "\"submitted {} structure jobs [{}-K-{}]\\n\"",
   ".",
   "format",
   "(",
   "nreps",
   ",",
   "self",
   ".",
   "name",
   ",",
   "kpop",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-621",
  "nl_tokens": [
   "Transforms",
   "this",
   "?",
   ":",
   "crap",
   "into",
   "if",
   "else",
   "python",
   "syntax"
  ],
  "pl_tokens": [
   "def",
   "transform_crap",
   "(",
   "code",
   ")",
   ":",
   "#needs some more tests",
   "ind",
   "=",
   "code",
   ".",
   "rfind",
   "(",
   "'?'",
   ")",
   "if",
   "ind",
   "==",
   "-",
   "1",
   ":",
   "return",
   "code",
   "sep",
   "=",
   "code",
   ".",
   "find",
   "(",
   "':'",
   ",",
   "ind",
   ")",
   "if",
   "sep",
   "==",
   "-",
   "1",
   ":",
   "raise",
   "SyntaxError",
   "(",
   "'Invalid ?: syntax (probably missing \":\" )'",
   ")",
   "beg",
   "=",
   "<mask>",
   "(",
   "code",
   ".",
   "rfind",
   "(",
   "':'",
   ",",
   "0",
   ",",
   "ind",
   ")",
   ",",
   "code",
   ".",
   "find",
   "(",
   "'?'",
   ",",
   "0",
   ",",
   "ind",
   ")",
   ")",
   "+",
   "1",
   "end",
   "=",
   "code",
   ".",
   "find",
   "(",
   "':'",
   ",",
   "sep",
   "+",
   "1",
   ")",
   "end",
   "=",
   "len",
   "(",
   "code",
   ")",
   "if",
   "end",
   "==",
   "-",
   "1",
   "else",
   "end",
   "formula",
   "=",
   "'('",
   "+",
   "code",
   "[",
   "ind",
   "+",
   "1",
   ":",
   "sep",
   "]",
   "+",
   "' if '",
   "+",
   "code",
   "[",
   "beg",
   ":",
   "ind",
   "]",
   "+",
   "' else '",
   "+",
   "code",
   "[",
   "sep",
   "+",
   "1",
   ":",
   "end",
   "]",
   "+",
   "')'",
   "return",
   "transform_crap",
   "(",
   "code",
   "[",
   ":",
   "beg",
   "]",
   "+",
   "formula",
   "+",
   "code",
   "[",
   "end",
   ":",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-622",
  "nl_tokens": [
   "Return",
   "the",
   "Soundex",
   "code",
   "for",
   "a",
   "word",
   "."
  ],
  "pl_tokens": [
   "def",
   "encode",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_length",
   "=",
   "4",
   ",",
   "var",
   "=",
   "'American'",
   ",",
   "reverse",
   "=",
   "False",
   ",",
   "zero_pad",
   "=",
   "True",
   ")",
   ":",
   "# Require a max_length of at least 4 and not more than 64",
   "if",
   "max_length",
   "!=",
   "-",
   "1",
   ":",
   "max_length",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "4",
   ",",
   "max_length",
   ")",
   ",",
   "64",
   ")",
   "else",
   ":",
   "max_length",
   "=",
   "64",
   "# uppercase, normalize, decompose, and filter non-A-Z out",
   "word",
   "=",
   "unicode_normalize",
   "(",
   "'NFKD'",
   ",",
   "text_type",
   "(",
   "word",
   ".",
   "upper",
   "(",
   ")",
   ")",
   ")",
   "word",
   "=",
   "word",
   ".",
   "replace",
   "(",
   "'\u00df',",
   " ",
   "SS')",
   "",
   "if",
   "var",
   "==",
   "'Census'",
   ":",
   "if",
   "word",
   "[",
   ":",
   "3",
   "]",
   "in",
   "{",
   "'VAN'",
   ",",
   "'CON'",
   "}",
   "and",
   "len",
   "(",
   "word",
   ")",
   ">",
   "4",
   ":",
   "return",
   "(",
   "soundex",
   "(",
   "word",
   ",",
   "max_length",
   ",",
   "'American'",
   ",",
   "reverse",
   ",",
   "zero_pad",
   ")",
   ",",
   "soundex",
   "(",
   "word",
   "[",
   "3",
   ":",
   "]",
   ",",
   "max_length",
   ",",
   "'American'",
   ",",
   "reverse",
   ",",
   "zero_pad",
   ")",
   ",",
   ")",
   "if",
   "word",
   "[",
   ":",
   "2",
   "]",
   "in",
   "{",
   "'DE'",
   ",",
   "'DI'",
   ",",
   "'LA'",
   ",",
   "'LE'",
   "}",
   "and",
   "len",
   "(",
   "word",
   ")",
   ">",
   "3",
   ":",
   "return",
   "(",
   "soundex",
   "(",
   "word",
   ",",
   "max_length",
   ",",
   "'American'",
   ",",
   "reverse",
   ",",
   "zero_pad",
   ")",
   ",",
   "soundex",
   "(",
   "word",
   "[",
   "2",
   ":",
   "]",
   ",",
   "max_length",
   ",",
   "'American'",
   ",",
   "reverse",
   ",",
   "zero_pad",
   ")",
   ",",
   ")",
   "# Otherwise, proceed as usual (var='American' mode, ostensibly)",
   "word",
   "=",
   "''",
   ".",
   "join",
   "(",
   "c",
   "for",
   "c",
   "in",
   "word",
   "if",
   "c",
   "in",
   "self",
   ".",
   "_uc_set",
   ")",
   "# Nothing to convert, return base case",
   "if",
   "not",
   "word",
   ":",
   "if",
   "zero_pad",
   ":",
   "return",
   "'0'",
   "*",
   "max_length",
   "return",
   "'0'",
   "# Reverse word if computing Reverse Soundex",
   "if",
   "reverse",
   ":",
   "word",
   "=",
   "word",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "# apply the Soundex algorithm",
   "sdx",
   "=",
   "word",
   ".",
   "translate",
   "(",
   "self",
   ".",
   "_trans",
   ")",
   "if",
   "var",
   "==",
   "'special'",
   ":",
   "sdx",
   "=",
   "sdx",
   ".",
   "replace",
   "(",
   "'9'",
   ",",
   "'0'",
   ")",
   "# special rule for 1880-1910 census",
   "else",
   ":",
   "sdx",
   "=",
   "sdx",
   ".",
   "replace",
   "(",
   "'9'",
   ",",
   "''",
   ")",
   "# rule 1",
   "sdx",
   "=",
   "self",
   ".",
   "_delete_consecutive_repeats",
   "(",
   "sdx",
   ")",
   "# rule 3",
   "if",
   "word",
   "[",
   "0",
   "]",
   "in",
   "'HW'",
   ":",
   "sdx",
   "=",
   "word",
   "[",
   "0",
   "]",
   "+",
   "sdx",
   "else",
   ":",
   "sdx",
   "=",
   "word",
   "[",
   "0",
   "]",
   "+",
   "sdx",
   "[",
   "1",
   ":",
   "]",
   "sdx",
   "=",
   "sdx",
   ".",
   "replace",
   "(",
   "'0'",
   ",",
   "''",
   ")",
   "# rule 1",
   "if",
   "zero_pad",
   ":",
   "sdx",
   "+=",
   "'0'",
   "*",
   "max_length",
   "# rule 4",
   "return",
   "sdx",
   "[",
   ":",
   "max_length",
   "]"
  ]
 },
 {
  "idx": "maxmin-623",
  "nl_tokens": [
   "Calculates",
   "the",
   "cross",
   "-",
   "entropy",
   "for",
   "a",
   "batch",
   "of",
   "logits",
   "."
  ],
  "pl_tokens": [
   "def",
   "batch_crossentropy",
   "(",
   "label",
   ",",
   "logits",
   ")",
   ":",
   "assert",
   "logits",
   ".",
   "ndim",
   "==",
   "2",
   "# for numerical reasons we subtract the max logit",
   "# (mathematically it doesn't matter!)",
   "# otherwise exp(logits) might become too large or too small",
   "logits",
   "=",
   "logits",
   "-",
   "np",
   ".",
   "<mask>",
   "(",
   "logits",
   ",",
   "axis",
   "=",
   "1",
   ",",
   "keepdims",
   "=",
   "True",
   ")",
   "e",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "logits",
   ")",
   "s",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "e",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "ces",
   "=",
   "np",
   ".",
   "log",
   "(",
   "s",
   ")",
   "-",
   "logits",
   "[",
   ":",
   ",",
   "label",
   "]",
   "return",
   "ces"
  ]
 },
 {
  "idx": "maxmin-624",
  "nl_tokens": [
   "Called",
   "at",
   "the",
   "end",
   "of",
   "learning",
   "and",
   "inference",
   "this",
   "routine",
   "will",
   "update",
   "a",
   "number",
   "of",
   "stats",
   "in",
   "our",
   "_internalStats",
   "dictionary",
   "including",
   "our",
   "computed",
   "prediction",
   "score",
   "."
  ],
  "pl_tokens": [
   "def",
   "_updateStatsInferEnd",
   "(",
   "self",
   ",",
   "stats",
   ",",
   "bottomUpNZ",
   ",",
   "predictedState",
   ",",
   "colConfidence",
   ")",
   ":",
   "# Return if not collecting stats",
   "if",
   "not",
   "self",
   ".",
   "collectStats",
   ":",
   "return",
   "stats",
   "[",
   "'nInfersSinceReset'",
   "]",
   "+=",
   "1",
   "# Compute the prediction score, how well the prediction from the last",
   "# time step predicted the current bottom-up input",
   "(",
   "numExtra2",
   ",",
   "numMissing2",
   ",",
   "confidences2",
   ")",
   "=",
   "self",
   ".",
   "_checkPrediction",
   "(",
   "patternNZs",
   "=",
   "[",
   "bottomUpNZ",
   "]",
   ",",
   "output",
   "=",
   "predictedState",
   ",",
   "colConfidence",
   "=",
   "colConfidence",
   ")",
   "predictionScore",
   ",",
   "positivePredictionScore",
   ",",
   "negativePredictionScore",
   "=",
   "(",
   "confidences2",
   "[",
   "0",
   "]",
   ")",
   "# Store the stats that don't depend on burn-in",
   "stats",
   "[",
   "'curPredictionScore2'",
   "]",
   "=",
   "float",
   "(",
   "predictionScore",
   ")",
   "stats",
   "[",
   "'curFalseNegativeScore'",
   "]",
   "=",
   "1.0",
   "-",
   "float",
   "(",
   "positivePredictionScore",
   ")",
   "stats",
   "[",
   "'curFalsePositiveScore'",
   "]",
   "=",
   "float",
   "(",
   "negativePredictionScore",
   ")",
   "stats",
   "[",
   "'curMissing'",
   "]",
   "=",
   "numMissing2",
   "stats",
   "[",
   "'curExtra'",
   "]",
   "=",
   "numExtra2",
   "# If we are passed the burn-in period, update the accumulated stats",
   "# Here's what various burn-in values mean:",
   "#   0: try to predict the first element of each sequence and all subsequent",
   "#   1: try to predict the second element of each sequence and all subsequent",
   "#   etc.",
   "if",
   "stats",
   "[",
   "'nInfersSinceReset'",
   "]",
   "<=",
   "self",
   ".",
   "burnIn",
   ":",
   "return",
   "# Burn-in related stats",
   "stats",
   "[",
   "'nPredictions'",
   "]",
   "+=",
   "1",
   "numExpected",
   "=",
   "<mask>",
   "(",
   "1.0",
   ",",
   "float",
   "(",
   "len",
   "(",
   "bottomUpNZ",
   ")",
   ")",
   ")",
   "stats",
   "[",
   "'totalMissing'",
   "]",
   "+=",
   "numMissing2",
   "stats",
   "[",
   "'totalExtra'",
   "]",
   "+=",
   "numExtra2",
   "stats",
   "[",
   "'pctExtraTotal'",
   "]",
   "+=",
   "100.0",
   "*",
   "numExtra2",
   "/",
   "numExpected",
   "stats",
   "[",
   "'pctMissingTotal'",
   "]",
   "+=",
   "100.0",
   "*",
   "numMissing2",
   "/",
   "numExpected",
   "stats",
   "[",
   "'predictionScoreTotal2'",
   "]",
   "+=",
   "float",
   "(",
   "predictionScore",
   ")",
   "stats",
   "[",
   "'falseNegativeScoreTotal'",
   "]",
   "+=",
   "1.0",
   "-",
   "float",
   "(",
   "positivePredictionScore",
   ")",
   "stats",
   "[",
   "'falsePositiveScoreTotal'",
   "]",
   "+=",
   "float",
   "(",
   "negativePredictionScore",
   ")",
   "if",
   "self",
   ".",
   "collectSequenceStats",
   ":",
   "# Collect cell confidences for every cell that correctly predicted current",
   "# bottom up input. Normalize confidence across each column",
   "cc",
   "=",
   "self",
   ".",
   "cellConfidence",
   "[",
   "'t-1'",
   "]",
   "*",
   "self",
   ".",
   "infActiveState",
   "[",
   "'t'",
   "]",
   "sconf",
   "=",
   "cc",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "for",
   "c",
   "in",
   "range",
   "(",
   "self",
   ".",
   "numberOfCols",
   ")",
   ":",
   "if",
   "sconf",
   "[",
   "c",
   "]",
   ">",
   "0",
   ":",
   "cc",
   "[",
   "c",
   ",",
   ":",
   "]",
   "/=",
   "sconf",
   "[",
   "c",
   "]",
   "# Update cell confidence histogram: add column-normalized confidence",
   "# scores to the histogram",
   "self",
   ".",
   "_internalStats",
   "[",
   "'confHistogram'",
   "]",
   "+=",
   "cc"
  ]
 },
 {
  "idx": "maxmin-625",
  "nl_tokens": [
   "Search",
   "the",
   "nodes",
   "with",
   "the",
   "lowest",
   "f",
   "scores",
   "first",
   ".",
   "You",
   "specify",
   "the",
   "function",
   "f",
   "(",
   "node",
   ")",
   "that",
   "you",
   "want",
   "to",
   "minimize",
   ";",
   "for",
   "example",
   "if",
   "f",
   "is",
   "a",
   "heuristic",
   "estimate",
   "to",
   "the",
   "goal",
   "then",
   "we",
   "have",
   "greedy",
   "best",
   "first",
   "search",
   ";",
   "if",
   "f",
   "is",
   "node",
   ".",
   "depth",
   "then",
   "we",
   "have",
   "breadth",
   "-",
   "first",
   "search",
   ".",
   "There",
   "is",
   "a",
   "subtlety",
   ":",
   "the",
   "line",
   "f",
   "=",
   "memoize",
   "(",
   "f",
   "f",
   ")",
   "means",
   "that",
   "the",
   "f",
   "values",
   "will",
   "be",
   "cached",
   "on",
   "the",
   "nodes",
   "as",
   "they",
   "are",
   "computed",
   ".",
   "So",
   "after",
   "doing",
   "a",
   "best",
   "first",
   "search",
   "you",
   "can",
   "examine",
   "the",
   "f",
   "values",
   "of",
   "the",
   "path",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "best_first_graph_search",
   "(",
   "problem",
   ",",
   "f",
   ")",
   ":",
   "f",
   "=",
   "memoize",
   "(",
   "f",
   ",",
   "'f'",
   ")",
   "node",
   "=",
   "Node",
   "(",
   "problem",
   ".",
   "initial",
   ")",
   "if",
   "problem",
   ".",
   "goal_test",
   "(",
   "node",
   ".",
   "state",
   ")",
   ":",
   "return",
   "node",
   "frontier",
   "=",
   "PriorityQueue",
   "(",
   "<mask>",
   ",",
   "f",
   ")",
   "frontier",
   ".",
   "append",
   "(",
   "node",
   ")",
   "explored",
   "=",
   "set",
   "(",
   ")",
   "while",
   "frontier",
   ":",
   "node",
   "=",
   "frontier",
   ".",
   "pop",
   "(",
   ")",
   "if",
   "problem",
   ".",
   "goal_test",
   "(",
   "node",
   ".",
   "state",
   ")",
   ":",
   "return",
   "node",
   "explored",
   ".",
   "add",
   "(",
   "node",
   ".",
   "state",
   ")",
   "for",
   "child",
   "in",
   "node",
   ".",
   "expand",
   "(",
   "problem",
   ")",
   ":",
   "if",
   "child",
   ".",
   "state",
   "not",
   "in",
   "explored",
   "and",
   "child",
   "not",
   "in",
   "frontier",
   ":",
   "frontier",
   ".",
   "append",
   "(",
   "child",
   ")",
   "elif",
   "child",
   "in",
   "frontier",
   ":",
   "incumbent",
   "=",
   "frontier",
   "[",
   "child",
   "]",
   "if",
   "f",
   "(",
   "child",
   ")",
   "<",
   "f",
   "(",
   "incumbent",
   ")",
   ":",
   "del",
   "frontier",
   "[",
   "incumbent",
   "]",
   "frontier",
   ".",
   "append",
   "(",
   "child",
   ")",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-626",
  "nl_tokens": [
   "Return",
   "the",
   "NCD",
   "between",
   "two",
   "strings",
   "using",
   "bzip2",
   "compression",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "src",
   "=",
   "src",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   "tar",
   "=",
   "tar",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   "src_comp",
   "=",
   "bz2",
   ".",
   "compress",
   "(",
   "src",
   ",",
   "self",
   ".",
   "_level",
   ")",
   "[",
   "10",
   ":",
   "]",
   "tar_comp",
   "=",
   "bz2",
   ".",
   "compress",
   "(",
   "tar",
   ",",
   "self",
   ".",
   "_level",
   ")",
   "[",
   "10",
   ":",
   "]",
   "concat_comp",
   "=",
   "bz2",
   ".",
   "compress",
   "(",
   "src",
   "+",
   "tar",
   ",",
   "self",
   ".",
   "_level",
   ")",
   "[",
   "10",
   ":",
   "]",
   "concat_comp2",
   "=",
   "bz2",
   ".",
   "compress",
   "(",
   "tar",
   "+",
   "src",
   ",",
   "self",
   ".",
   "_level",
   ")",
   "[",
   "10",
   ":",
   "]",
   "return",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "concat_comp",
   ")",
   ",",
   "len",
   "(",
   "concat_comp2",
   ")",
   ")",
   "-",
   "min",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")",
   ")",
   "/",
   "max",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-627",
  "nl_tokens": [
   "Sonify",
   "beats",
   "and",
   "downbeats",
   "together",
   "."
  ],
  "pl_tokens": [
   "def",
   "downbeat",
   "(",
   "annotation",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "length",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "beat_click",
   "=",
   "mkclick",
   "(",
   "440",
   "*",
   "2",
   ",",
   "sr",
   "=",
   "sr",
   ")",
   "downbeat_click",
   "=",
   "mkclick",
   "(",
   "440",
   "*",
   "3",
   ",",
   "sr",
   "=",
   "sr",
   ")",
   "intervals",
   ",",
   "values",
   "=",
   "annotation",
   ".",
   "to_interval_values",
   "(",
   ")",
   "beats",
   ",",
   "downbeats",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "for",
   "time",
   ",",
   "value",
   "in",
   "zip",
   "(",
   "intervals",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "values",
   ")",
   ":",
   "if",
   "value",
   "[",
   "'position'",
   "]",
   "==",
   "1",
   ":",
   "downbeats",
   ".",
   "append",
   "(",
   "time",
   ")",
   "else",
   ":",
   "beats",
   ".",
   "append",
   "(",
   "time",
   ")",
   "if",
   "length",
   "is",
   "None",
   ":",
   "length",
   "=",
   "int",
   "(",
   "sr",
   "*",
   "np",
   ".",
   "<mask>",
   "(",
   "intervals",
   ")",
   ")",
   "+",
   "len",
   "(",
   "beat_click",
   ")",
   "+",
   "1",
   "y",
   "=",
   "filter_kwargs",
   "(",
   "mir_eval",
   ".",
   "sonify",
   ".",
   "clicks",
   ",",
   "np",
   ".",
   "asarray",
   "(",
   "beats",
   ")",
   ",",
   "fs",
   "=",
   "sr",
   ",",
   "length",
   "=",
   "length",
   ",",
   "click",
   "=",
   "beat_click",
   ")",
   "y",
   "+=",
   "filter_kwargs",
   "(",
   "mir_eval",
   ".",
   "sonify",
   ".",
   "clicks",
   ",",
   "np",
   ".",
   "asarray",
   "(",
   "downbeats",
   ")",
   ",",
   "fs",
   "=",
   "sr",
   ",",
   "length",
   "=",
   "length",
   ",",
   "click",
   "=",
   "downbeat_click",
   ")",
   "return",
   "y"
  ]
 },
 {
  "idx": "maxmin-628",
  "nl_tokens": [
   "Finds",
   "the",
   "top",
   "long",
   "short",
   "and",
   "absolute",
   "positions",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_top_long_short_abs",
   "(",
   "positions",
   ",",
   "top",
   "=",
   "10",
   ")",
   ":",
   "positions",
   "=",
   "positions",
   ".",
   "drop",
   "(",
   "'cash'",
   ",",
   "axis",
   "=",
   "'columns'",
   ")",
   "df_max",
   "=",
   "positions",
   ".",
   "<mask>",
   "(",
   ")",
   "df_min",
   "=",
   "positions",
   ".",
   "min",
   "(",
   ")",
   "df_abs_max",
   "=",
   "positions",
   ".",
   "abs",
   "(",
   ")",
   ".",
   "max",
   "(",
   ")",
   "df_top_long",
   "=",
   "df_max",
   "[",
   "df_max",
   ">",
   "0",
   "]",
   ".",
   "nlargest",
   "(",
   "top",
   ")",
   "df_top_short",
   "=",
   "df_min",
   "[",
   "df_min",
   "<",
   "0",
   "]",
   ".",
   "nsmallest",
   "(",
   "top",
   ")",
   "df_top_abs",
   "=",
   "df_abs_max",
   ".",
   "nlargest",
   "(",
   "top",
   ")",
   "return",
   "df_top_long",
   ",",
   "df_top_short",
   ",",
   "df_top_abs"
  ]
 },
 {
  "idx": "maxmin-629",
  "nl_tokens": [
   "Get",
   "the",
   "desired",
   "block",
   "from",
   "the",
   "chain",
   "if",
   "the",
   "current",
   "head",
   "block",
   "is",
   "smaller",
   "(",
   "for",
   "both",
   "head",
   "and",
   "irreversible",
   ")",
   "then",
   "we",
   "wait",
   "but",
   "a",
   "maxmimum",
   "of",
   "blocks_waiting_for",
   "*",
   "max_block_wait_repetition",
   "time",
   "before",
   "failure",
   "."
  ],
  "pl_tokens": [
   "def",
   "wait_for_and_get_block",
   "(",
   "self",
   ",",
   "block_number",
   ",",
   "blocks_waiting_for",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "blocks_waiting_for",
   ":",
   "blocks_waiting_for",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "block_number",
   "-",
   "self",
   ".",
   "get_current_block_num",
   "(",
   ")",
   ")",
   "repetition",
   "=",
   "0",
   "# can't return the block before the chain has reached it (support",
   "# future block_num)",
   "while",
   "self",
   ".",
   "get_current_block_num",
   "(",
   ")",
   "<",
   "block_number",
   ":",
   "repetition",
   "+=",
   "1",
   "time",
   ".",
   "sleep",
   "(",
   "self",
   ".",
   "block_interval",
   ")",
   "if",
   "repetition",
   ">",
   "blocks_waiting_for",
   "*",
   "self",
   ".",
   "max_block_wait_repetition",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Wait time for new block exceeded, aborting\"",
   ")",
   "# block has to be returned properly",
   "block",
   "=",
   "self",
   ".",
   "blockchain",
   ".",
   "rpc",
   ".",
   "get_block",
   "(",
   "block_number",
   ")",
   "repetition",
   "=",
   "0",
   "while",
   "not",
   "block",
   ":",
   "repetition",
   "+=",
   "1",
   "time",
   ".",
   "sleep",
   "(",
   "self",
   ".",
   "block_interval",
   ")",
   "if",
   "repetition",
   ">",
   "self",
   ".",
   "max_block_wait_repetition",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Wait time for new block exceeded, aborting\"",
   ")",
   "block",
   "=",
   "self",
   ".",
   "blockchain",
   ".",
   "rpc",
   ".",
   "get_block",
   "(",
   "block_number",
   ")",
   "return",
   "block"
  ]
 },
 {
  "idx": "maxmin-630",
  "nl_tokens": [
   "Typically",
   "called",
   "from",
   ":",
   "py",
   ":",
   "func",
   ":",
   "_compute_packet",
   "this",
   "applies",
   "brightness",
   "and",
   "gamma",
   "correction",
   "to",
   "the",
   "pixels",
   "controlled",
   "by",
   "this",
   "driver",
   "."
  ],
  "pl_tokens": [
   "def",
   "_render",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "set_device_brightness",
   ":",
   "level",
   "=",
   "1.0",
   "else",
   ":",
   "level",
   "=",
   "self",
   ".",
   "_brightness",
   "/",
   "255.0",
   "gam",
   ",",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   "=",
   "self",
   ".",
   "gamma",
   ".",
   "get",
   ",",
   "self",
   ".",
   "c_order",
   "for",
   "i",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "numLEDs",
   ",",
   "len",
   "(",
   "self",
   ".",
   "_buf",
   ")",
   "/",
   "3",
   ")",
   ")",
   ":",
   "c",
   "=",
   "[",
   "int",
   "(",
   "level",
   "*",
   "x",
   ")",
   "for",
   "x",
   "in",
   "self",
   ".",
   "_colors",
   "[",
   "i",
   "+",
   "self",
   ".",
   "_pos",
   "]",
   "]",
   "self",
   ".",
   "_buf",
   "[",
   "i",
   "*",
   "3",
   ":",
   "(",
   "i",
   "+",
   "1",
   ")",
   "*",
   "3",
   "]",
   "=",
   "gam",
   "(",
   "c",
   "[",
   "r",
   "]",
   ")",
   ",",
   "gam",
   "(",
   "c",
   "[",
   "g",
   "]",
   ")",
   ",",
   "gam",
   "(",
   "c",
   "[",
   "b",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-631",
  "nl_tokens": [
   "Some",
   "common",
   "methods",
   "for",
   "processing",
   "a",
   "database",
   "of",
   "flux",
   "information",
   "into",
   "print",
   "-",
   "ready",
   "formats",
   ".",
   "Used",
   "in",
   "both",
   "model_summary",
   "and",
   "metabolite_summary",
   "."
  ],
  "pl_tokens": [
   "def",
   "_process_flux_dataframe",
   "(",
   "flux_dataframe",
   ",",
   "fva",
   ",",
   "threshold",
   ",",
   "floatfmt",
   ")",
   ":",
   "abs_flux",
   "=",
   "flux_dataframe",
   "[",
   "'flux'",
   "]",
   ".",
   "abs",
   "(",
   ")",
   "flux_threshold",
   "=",
   "threshold",
   "*",
   "abs_flux",
   ".",
   "<mask>",
   "(",
   ")",
   "# Drop unused boundary fluxes",
   "if",
   "fva",
   "is",
   "None",
   ":",
   "flux_dataframe",
   "=",
   "flux_dataframe",
   ".",
   "loc",
   "[",
   "abs_flux",
   ">=",
   "flux_threshold",
   ",",
   ":",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "else",
   ":",
   "flux_dataframe",
   "=",
   "flux_dataframe",
   ".",
   "loc",
   "[",
   "(",
   "abs_flux",
   ">=",
   "flux_threshold",
   ")",
   "|",
   "(",
   "flux_dataframe",
   "[",
   "'fmin'",
   "]",
   ".",
   "abs",
   "(",
   ")",
   ">=",
   "flux_threshold",
   ")",
   "|",
   "(",
   "flux_dataframe",
   "[",
   "'fmax'",
   "]",
   ".",
   "abs",
   "(",
   ")",
   ">=",
   "flux_threshold",
   ")",
   ",",
   ":",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "# Why set to zero? If included show true value?",
   "# flux_dataframe.loc[",
   "#     flux_dataframe['flux'].abs() < flux_threshold, 'flux'] = 0",
   "# Make all fluxes positive",
   "if",
   "fva",
   "is",
   "None",
   ":",
   "flux_dataframe",
   "[",
   "'is_input'",
   "]",
   "=",
   "(",
   "flux_dataframe",
   "[",
   "'flux'",
   "]",
   ">=",
   "0",
   ")",
   "flux_dataframe",
   "[",
   "'flux'",
   "]",
   "=",
   "flux_dataframe",
   "[",
   "'flux'",
   "]",
   ".",
   "abs",
   "(",
   ")",
   "else",
   ":",
   "def",
   "get_direction",
   "(",
   "flux",
   ",",
   "fmin",
   ",",
   "fmax",
   ")",
   ":",
   "\"\"\" decide whether or not to reverse a flux to make it positive \"\"\"",
   "if",
   "flux",
   "<",
   "0",
   ":",
   "return",
   "-",
   "1",
   "elif",
   "flux",
   ">",
   "0",
   ":",
   "return",
   "1",
   "elif",
   "(",
   "fmax",
   ">",
   "0",
   ")",
   "&",
   "(",
   "fmin",
   "<=",
   "0",
   ")",
   ":",
   "return",
   "1",
   "elif",
   "(",
   "fmax",
   "<",
   "0",
   ")",
   "&",
   "(",
   "fmin",
   ">=",
   "0",
   ")",
   ":",
   "return",
   "-",
   "1",
   "elif",
   "(",
   "(",
   "fmax",
   "+",
   "fmin",
   ")",
   "/",
   "2",
   ")",
   "<",
   "0",
   ":",
   "return",
   "-",
   "1",
   "else",
   ":",
   "return",
   "1",
   "sign",
   "=",
   "flux_dataframe",
   ".",
   "apply",
   "(",
   "lambda",
   "x",
   ":",
   "get_direction",
   "(",
   "x",
   ".",
   "flux",
   ",",
   "x",
   ".",
   "fmin",
   ",",
   "x",
   ".",
   "fmax",
   ")",
   ",",
   "1",
   ")",
   "flux_dataframe",
   "[",
   "'is_input'",
   "]",
   "=",
   "sign",
   "==",
   "1",
   "flux_dataframe",
   ".",
   "loc",
   "[",
   ":",
   ",",
   "[",
   "'flux'",
   ",",
   "'fmin'",
   ",",
   "'fmax'",
   "]",
   "]",
   "=",
   "flux_dataframe",
   ".",
   "loc",
   "[",
   ":",
   ",",
   "[",
   "'flux'",
   ",",
   "'fmin'",
   ",",
   "'fmax'",
   "]",
   "]",
   ".",
   "multiply",
   "(",
   "sign",
   ",",
   "0",
   ")",
   ".",
   "astype",
   "(",
   "'float'",
   ")",
   ".",
   "round",
   "(",
   "6",
   ")",
   "flux_dataframe",
   ".",
   "loc",
   "[",
   ":",
   ",",
   "[",
   "'flux'",
   ",",
   "'fmin'",
   ",",
   "'fmax'",
   "]",
   "]",
   "=",
   "flux_dataframe",
   ".",
   "loc",
   "[",
   ":",
   ",",
   "[",
   "'flux'",
   ",",
   "'fmin'",
   ",",
   "'fmax'",
   "]",
   "]",
   ".",
   "applymap",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "if",
   "abs",
   "(",
   "x",
   ")",
   ">",
   "1E-6",
   "else",
   "0",
   ")",
   "if",
   "fva",
   "is",
   "not",
   "None",
   ":",
   "flux_dataframe",
   "[",
   "'fva_fmt'",
   "]",
   "=",
   "flux_dataframe",
   ".",
   "apply",
   "(",
   "lambda",
   "x",
   ":",
   "(",
   "\"[{0.fmin:\"",
   "+",
   "floatfmt",
   "+",
   "\"}, {0.fmax:\"",
   "+",
   "floatfmt",
   "+",
   "\"}]\"",
   ")",
   ".",
   "format",
   "(",
   "x",
   ")",
   ",",
   "1",
   ")",
   "flux_dataframe",
   "=",
   "flux_dataframe",
   ".",
   "sort_values",
   "(",
   "by",
   "=",
   "[",
   "'flux'",
   ",",
   "'fmax'",
   ",",
   "'fmin'",
   ",",
   "'id'",
   "]",
   ",",
   "ascending",
   "=",
   "[",
   "False",
   ",",
   "False",
   ",",
   "False",
   ",",
   "True",
   "]",
   ")",
   "else",
   ":",
   "flux_dataframe",
   "=",
   "flux_dataframe",
   ".",
   "sort_values",
   "(",
   "by",
   "=",
   "[",
   "'flux'",
   ",",
   "'id'",
   "]",
   ",",
   "ascending",
   "=",
   "[",
   "False",
   ",",
   "True",
   "]",
   ")",
   "return",
   "flux_dataframe"
  ]
 },
 {
  "idx": "maxmin-632",
  "nl_tokens": [
   "Format",
   "intraday",
   "data"
  ],
  "pl_tokens": [
   "def",
   "format_intraday",
   "(",
   "data",
   ":",
   "pd",
   ".",
   "DataFrame",
   ",",
   "ticker",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "->",
   "pd",
   ".",
   "DataFrame",
   ":",
   "if",
   "data",
   ".",
   "empty",
   ":",
   "return",
   "pd",
   ".",
   "DataFrame",
   "(",
   ")",
   "data",
   ".",
   "columns",
   "=",
   "pd",
   ".",
   "MultiIndex",
   ".",
   "from_product",
   "(",
   "[",
   "[",
   "ticker",
   "]",
   ",",
   "data",
   ".",
   "rename",
   "(",
   "columns",
   "=",
   "dict",
   "(",
   "numEvents",
   "=",
   "'num_trds'",
   ")",
   ")",
   ".",
   "columns",
   "]",
   ",",
   "names",
   "=",
   "[",
   "'ticker'",
   ",",
   "'field'",
   "]",
   ")",
   "data",
   ".",
   "index",
   ".",
   "name",
   "=",
   "None",
   "if",
   "kwargs",
   ".",
   "get",
   "(",
   "'price_only'",
   ",",
   "False",
   ")",
   ":",
   "kw_xs",
   "=",
   "dict",
   "(",
   "axis",
   "=",
   "1",
   ",",
   "level",
   "=",
   "1",
   ")",
   "close",
   "=",
   "data",
   ".",
   "xs",
   "(",
   "'close'",
   ",",
   "*",
   "*",
   "kw_xs",
   ")",
   "volume",
   "=",
   "data",
   ".",
   "xs",
   "(",
   "'volume'",
   ",",
   "*",
   "*",
   "kw_xs",
   ")",
   ".",
   "iloc",
   "[",
   ":",
   ",",
   "0",
   "]",
   "return",
   "close",
   ".",
   "loc",
   "[",
   "volume",
   ">",
   "0",
   "]",
   "if",
   "volume",
   ".",
   "<mask>",
   "(",
   ")",
   ">",
   "0",
   "else",
   "close",
   "else",
   ":",
   "return",
   "data"
  ]
 },
 {
  "idx": "maxmin-633",
  "nl_tokens": [
   "dual",
   "I",
   "/",
   "V",
   "steps",
   "in",
   "VC",
   "mode",
   "one",
   "from",
   "-",
   "70",
   "and",
   "one",
   "-",
   "50",
   "."
  ],
  "pl_tokens": [
   "def",
   "proto_02_02_IVdual",
   "(",
   "abf",
   "=",
   "exampleABF",
   ")",
   ":",
   "av1",
   ",",
   "sd1",
   "=",
   "swhlab",
   ".",
   "plot",
   ".",
   "IV",
   "(",
   "abf",
   ",",
   ".7",
   ",",
   "1",
   ",",
   "True",
   ",",
   "'b'",
   ")",
   "swhlab",
   ".",
   "plot",
   ".",
   "save",
   "(",
   "abf",
   ",",
   "tag",
   "=",
   "'iv1'",
   ")",
   "a2v",
   ",",
   "sd2",
   "=",
   "swhlab",
   ".",
   "plot",
   ".",
   "IV",
   "(",
   "abf",
   ",",
   "2.2",
   ",",
   "2.5",
   ",",
   "True",
   ",",
   "'r'",
   ")",
   "swhlab",
   ".",
   "plot",
   ".",
   "save",
   "(",
   "abf",
   ",",
   "tag",
   "=",
   "'iv2'",
   ")",
   "swhlab",
   ".",
   "plot",
   ".",
   "sweep",
   "(",
   "abf",
   ",",
   "'all'",
   ")",
   "pylab",
   ".",
   "axis",
   "(",
   "[",
   "None",
   ",",
   "None",
   ",",
   "<mask>",
   "(",
   "av1",
   ")",
   "-",
   "50",
   ",",
   "max",
   "(",
   "av1",
   ")",
   "+",
   "50",
   "]",
   ")",
   "swhlab",
   ".",
   "plot",
   ".",
   "save",
   "(",
   "abf",
   ",",
   "tag",
   "=",
   "'overlay'",
   ")"
  ]
 },
 {
  "idx": "maxmin-634",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "initialize",
   "the",
   "object",
   "by",
   "precomputing",
   "any",
   "values",
   "which",
   "may",
   "be",
   "used",
   "repeatedly",
   "and",
   "by",
   "retrieving",
   "mixture",
   "-",
   "specific",
   "variables",
   ".",
   "All",
   "data",
   "are",
   "stored",
   "as",
   "attributes",
   ".",
   "This",
   "method",
   "also",
   "sets",
   ":",
   "obj",
   ":",
   "Tmin",
   ":",
   "obj",
   ":",
   "Tmax",
   "and",
   ":",
   "obj",
   ":",
   "all_methods",
   "as",
   "a",
   "set",
   "of",
   "methods",
   "which",
   "should",
   "work",
   "to",
   "calculate",
   "the",
   "property",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "]",
   "methods",
   ".",
   "append",
   "(",
   "SIMPLE",
   ")",
   "if",
   "none_and_length_check",
   "(",
   "(",
   "self",
   ".",
   "Tbs",
   ",",
   "self",
   ".",
   "MWs",
   ")",
   ")",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "LINDSAY_BROMLEY",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "Tmins",
   "=",
   "[",
   "i",
   ".",
   "Tmin",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ThermalConductivityGases",
   "if",
   "i",
   ".",
   "Tmin",
   "]",
   "Tmaxs",
   "=",
   "[",
   "i",
   ".",
   "Tmax",
   "for",
   "i",
   "in",
   "self",
   ".",
   "ThermalConductivityGases",
   "if",
   "i",
   ".",
   "Tmax",
   "]",
   "if",
   "Tmins",
   ":",
   "self",
   ".",
   "Tmin",
   "=",
   "<mask>",
   "(",
   "Tmins",
   ")",
   "if",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmax",
   "=",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-635",
  "nl_tokens": [
   "Accepts",
   "log",
   "-",
   "values",
   "as",
   "input",
   "exponentiates",
   "them",
   "computes",
   "the",
   "sum",
   "then",
   "converts",
   "the",
   "sum",
   "back",
   "to",
   "log",
   "-",
   "space",
   "and",
   "returns",
   "the",
   "result",
   ".",
   "Handles",
   "underflow",
   "by",
   "rescaling",
   "so",
   "that",
   "the",
   "largest",
   "values",
   "is",
   "exactly",
   "1",
   ".",
   "0",
   "."
  ],
  "pl_tokens": [
   "def",
   "lscsum",
   "(",
   "lx",
   ",",
   "epsilon",
   "=",
   "None",
   ")",
   ":",
   "lx",
   "=",
   "numpy",
   ".",
   "asarray",
   "(",
   "lx",
   ")",
   "base",
   "=",
   "lx",
   ".",
   "<mask>",
   "(",
   ")",
   "# If the input is the log of 0's, catch this condition before we generate",
   "#  an exception, and return the log(0)",
   "if",
   "numpy",
   ".",
   "isinf",
   "(",
   "base",
   ")",
   ":",
   "return",
   "base",
   "# If the user specified an epsilon and we are below it, return epsilon",
   "if",
   "(",
   "epsilon",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "base",
   "<",
   "epsilon",
   ")",
   ":",
   "return",
   "epsilon",
   "x",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   "-",
   "base",
   ")",
   "ssum",
   "=",
   "x",
   ".",
   "sum",
   "(",
   ")",
   "result",
   "=",
   "numpy",
   ".",
   "log",
   "(",
   "ssum",
   ")",
   "+",
   "base",
   "# try:",
   "#   conventional = numpy.log(numpy.exp(lx).sum())",
   "#   if not similar(result, conventional):",
   "#     if numpy.isinf(conventional).any() and not numpy.isinf(result).any():",
   "#       # print \"Scaled log sum avoided underflow or overflow.\"",
   "#       pass",
   "#     else:",
   "#       import sys",
   "#       print >>sys.stderr, \"Warning: scaled log sum did not match.\"",
   "#       print >>sys.stderr, \"Scaled log result:\"",
   "#       print >>sys.stderr, result",
   "#       print >>sys.stderr, \"Conventional result:\"",
   "#       print >>sys.stderr, conventional",
   "# except FloatingPointError, e:",
   "#   # print \"Scaled log sum avoided underflow or overflow.\"",
   "#   pass",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-636",
  "nl_tokens": [
   "Return",
   "the",
   "strcmp95",
   "similarity",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "long_strings",
   "=",
   "False",
   ")",
   ":",
   "def",
   "_in_range",
   "(",
   "char",
   ")",
   ":",
   "\"\"\"Return True if char is in the range (0, 91).\n\n            Parameters\n            ----------\n            char : str\n                The character to check\n\n            Returns\n            -------\n            bool\n                True if char is in the range (0, 91)\n\n            \"\"\"",
   "return",
   "91",
   ">",
   "ord",
   "(",
   "char",
   ")",
   ">",
   "0",
   "ying",
   "=",
   "src",
   ".",
   "strip",
   "(",
   ")",
   ".",
   "upper",
   "(",
   ")",
   "yang",
   "=",
   "tar",
   ".",
   "strip",
   "(",
   ")",
   ".",
   "upper",
   "(",
   ")",
   "if",
   "ying",
   "==",
   "yang",
   ":",
   "return",
   "1.0",
   "# If either string is blank - return - added in Version 2",
   "if",
   "not",
   "ying",
   "or",
   "not",
   "yang",
   ":",
   "return",
   "0.0",
   "adjwt",
   "=",
   "defaultdict",
   "(",
   "int",
   ")",
   "# Initialize the adjwt array on the first call to the function only.",
   "# The adjwt array is used to give partial credit for characters that",
   "# may be errors due to known phonetic or character recognition errors.",
   "# A typical example is to match the letter \"O\" with the number \"0\"",
   "for",
   "i",
   "in",
   "self",
   ".",
   "_sp_mx",
   ":",
   "adjwt",
   "[",
   "(",
   "i",
   "[",
   "0",
   "]",
   ",",
   "i",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "3",
   "adjwt",
   "[",
   "(",
   "i",
   "[",
   "1",
   "]",
   ",",
   "i",
   "[",
   "0",
   "]",
   ")",
   "]",
   "=",
   "3",
   "if",
   "len",
   "(",
   "ying",
   ")",
   ">",
   "len",
   "(",
   "yang",
   ")",
   ":",
   "search_range",
   "=",
   "len",
   "(",
   "ying",
   ")",
   "minv",
   "=",
   "len",
   "(",
   "yang",
   ")",
   "else",
   ":",
   "search_range",
   "=",
   "len",
   "(",
   "yang",
   ")",
   "minv",
   "=",
   "len",
   "(",
   "ying",
   ")",
   "# Blank out the flags",
   "ying_flag",
   "=",
   "[",
   "0",
   "]",
   "*",
   "search_range",
   "yang_flag",
   "=",
   "[",
   "0",
   "]",
   "*",
   "search_range",
   "search_range",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "search_range",
   "//",
   "2",
   "-",
   "1",
   ")",
   "# Looking only within the search range,",
   "# count and flag the matched pairs.",
   "num_com",
   "=",
   "0",
   "yl1",
   "=",
   "len",
   "(",
   "yang",
   ")",
   "-",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "ying",
   ")",
   ")",
   ":",
   "low_lim",
   "=",
   "(",
   "i",
   "-",
   "search_range",
   ")",
   "if",
   "(",
   "i",
   ">=",
   "search_range",
   ")",
   "else",
   "0",
   "hi_lim",
   "=",
   "(",
   "i",
   "+",
   "search_range",
   ")",
   "if",
   "(",
   "(",
   "i",
   "+",
   "search_range",
   ")",
   "<=",
   "yl1",
   ")",
   "else",
   "yl1",
   "for",
   "j",
   "in",
   "range",
   "(",
   "low_lim",
   ",",
   "hi_lim",
   "+",
   "1",
   ")",
   ":",
   "if",
   "(",
   "yang_flag",
   "[",
   "j",
   "]",
   "==",
   "0",
   ")",
   "and",
   "(",
   "yang",
   "[",
   "j",
   "]",
   "==",
   "ying",
   "[",
   "i",
   "]",
   ")",
   ":",
   "yang_flag",
   "[",
   "j",
   "]",
   "=",
   "1",
   "ying_flag",
   "[",
   "i",
   "]",
   "=",
   "1",
   "num_com",
   "+=",
   "1",
   "break",
   "# If no characters in common - return",
   "if",
   "num_com",
   "==",
   "0",
   ":",
   "return",
   "0.0",
   "# Count the number of transpositions",
   "k",
   "=",
   "n_trans",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "ying",
   ")",
   ")",
   ":",
   "if",
   "ying_flag",
   "[",
   "i",
   "]",
   "!=",
   "0",
   ":",
   "j",
   "=",
   "0",
   "for",
   "j",
   "in",
   "range",
   "(",
   "k",
   ",",
   "len",
   "(",
   "yang",
   ")",
   ")",
   ":",
   "# pragma: no branch",
   "if",
   "yang_flag",
   "[",
   "j",
   "]",
   "!=",
   "0",
   ":",
   "k",
   "=",
   "j",
   "+",
   "1",
   "break",
   "if",
   "ying",
   "[",
   "i",
   "]",
   "!=",
   "yang",
   "[",
   "j",
   "]",
   ":",
   "n_trans",
   "+=",
   "1",
   "n_trans",
   "//=",
   "2",
   "# Adjust for similarities in unmatched characters",
   "n_simi",
   "=",
   "0",
   "if",
   "minv",
   ">",
   "num_com",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "ying",
   ")",
   ")",
   ":",
   "if",
   "ying_flag",
   "[",
   "i",
   "]",
   "==",
   "0",
   "and",
   "_in_range",
   "(",
   "ying",
   "[",
   "i",
   "]",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "yang",
   ")",
   ")",
   ":",
   "if",
   "yang_flag",
   "[",
   "j",
   "]",
   "==",
   "0",
   "and",
   "_in_range",
   "(",
   "yang",
   "[",
   "j",
   "]",
   ")",
   ":",
   "if",
   "(",
   "ying",
   "[",
   "i",
   "]",
   ",",
   "yang",
   "[",
   "j",
   "]",
   ")",
   "in",
   "adjwt",
   ":",
   "n_simi",
   "+=",
   "adjwt",
   "[",
   "(",
   "ying",
   "[",
   "i",
   "]",
   ",",
   "yang",
   "[",
   "j",
   "]",
   ")",
   "]",
   "yang_flag",
   "[",
   "j",
   "]",
   "=",
   "2",
   "break",
   "num_sim",
   "=",
   "n_simi",
   "/",
   "10.0",
   "+",
   "num_com",
   "# Main weight computation",
   "weight",
   "=",
   "(",
   "num_sim",
   "/",
   "len",
   "(",
   "ying",
   ")",
   "+",
   "num_sim",
   "/",
   "len",
   "(",
   "yang",
   ")",
   "+",
   "(",
   "num_com",
   "-",
   "n_trans",
   ")",
   "/",
   "num_com",
   ")",
   "weight",
   "/=",
   "3.0",
   "# Continue to boost the weight if the strings are similar",
   "if",
   "weight",
   ">",
   "0.7",
   ":",
   "# Adjust for having up to the first 4 characters in common",
   "j",
   "=",
   "4",
   "if",
   "(",
   "minv",
   ">=",
   "4",
   ")",
   "else",
   "minv",
   "i",
   "=",
   "0",
   "while",
   "(",
   "i",
   "<",
   "j",
   ")",
   "and",
   "(",
   "ying",
   "[",
   "i",
   "]",
   "==",
   "yang",
   "[",
   "i",
   "]",
   ")",
   "and",
   "(",
   "not",
   "ying",
   "[",
   "i",
   "]",
   ".",
   "isdigit",
   "(",
   ")",
   ")",
   ":",
   "i",
   "+=",
   "1",
   "if",
   "i",
   ":",
   "weight",
   "+=",
   "i",
   "*",
   "0.1",
   "*",
   "(",
   "1.0",
   "-",
   "weight",
   ")",
   "# Optionally adjust for long strings.",
   "# After agreeing beginning chars, at least two more must agree and",
   "# the agreeing characters must be > .5 of remaining characters.",
   "if",
   "(",
   "long_strings",
   "and",
   "(",
   "minv",
   ">",
   "4",
   ")",
   "and",
   "(",
   "num_com",
   ">",
   "i",
   "+",
   "1",
   ")",
   "and",
   "(",
   "2",
   "*",
   "num_com",
   ">=",
   "minv",
   "+",
   "i",
   ")",
   ")",
   ":",
   "if",
   "not",
   "ying",
   "[",
   "0",
   "]",
   ".",
   "isdigit",
   "(",
   ")",
   ":",
   "weight",
   "+=",
   "(",
   "1.0",
   "-",
   "weight",
   ")",
   "*",
   "(",
   "(",
   "num_com",
   "-",
   "i",
   "-",
   "1",
   ")",
   "/",
   "(",
   "len",
   "(",
   "ying",
   ")",
   "+",
   "len",
   "(",
   "yang",
   ")",
   "-",
   "i",
   "*",
   "2",
   "+",
   "2",
   ")",
   ")",
   "return",
   "weight"
  ]
 },
 {
  "idx": "maxmin-637",
  "nl_tokens": [
   "Get",
   "the",
   "giant",
   "component",
   "of",
   "a",
   "graph",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_largest_component",
   "(",
   "graph",
   ":",
   "BELGraph",
   ")",
   "->",
   "BELGraph",
   ":",
   "biggest_component_nodes",
   "=",
   "<mask>",
   "(",
   "nx",
   ".",
   "weakly_connected_components",
   "(",
   "graph",
   ")",
   ",",
   "key",
   "=",
   "len",
   ")",
   "return",
   "subgraph",
   "(",
   "graph",
   ",",
   "biggest_component_nodes",
   ")"
  ]
 },
 {
  "idx": "maxmin-638",
  "nl_tokens": [
   "Args"
  ],
  "pl_tokens": [
   "def",
   "tuplize_key",
   "(",
   "obj",
   ",",
   "key",
   ",",
   "remove_extra",
   "=",
   "False",
   ")",
   ":",
   "paramlen",
   "=",
   "len",
   "(",
   "obj",
   ".",
   "formula",
   ".",
   "parameters",
   ")",
   "if",
   "isinstance",
   "(",
   "key",
   ",",
   "str",
   ")",
   ":",
   "key",
   "=",
   "(",
   "key",
   ",",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "key",
   ",",
   "Sequence",
   ")",
   ":",
   "key",
   "=",
   "(",
   "key",
   ",",
   ")",
   "if",
   "not",
   "remove_extra",
   ":",
   "return",
   "key",
   "else",
   ":",
   "arglen",
   "=",
   "len",
   "(",
   "key",
   ")",
   "if",
   "arglen",
   ":",
   "return",
   "key",
   "[",
   ":",
   "<mask>",
   "(",
   "arglen",
   ",",
   "paramlen",
   ")",
   "]",
   "else",
   ":",
   "return",
   "key"
  ]
 },
 {
  "idx": "maxmin-639",
  "nl_tokens": [
   "Determine",
   "the",
   "geometry",
   "of",
   "the",
   "Voronoi",
   "pixelization",
   "by",
   "alligning",
   "it",
   "with",
   "the",
   "outer",
   "-",
   "most",
   "coordinates",
   "on",
   "a",
   "\\",
   "grid",
   "plus",
   "a",
   "small",
   "buffer",
   "."
  ],
  "pl_tokens": [
   "def",
   "geometry_from_grid",
   "(",
   "self",
   ",",
   "grid",
   ",",
   "pixel_centres",
   ",",
   "pixel_neighbors",
   ",",
   "pixel_neighbors_size",
   ",",
   "buffer",
   "=",
   "1e-8",
   ")",
   ":",
   "y_min",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "-",
   "buffer",
   "y_max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "+",
   "buffer",
   "x_min",
   "=",
   "np",
   ".",
   "min",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "-",
   "buffer",
   "x_max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "grid",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "+",
   "buffer",
   "shape_arcsec",
   "=",
   "(",
   "y_max",
   "-",
   "y_min",
   ",",
   "x_max",
   "-",
   "x_min",
   ")",
   "origin",
   "=",
   "(",
   "(",
   "y_max",
   "+",
   "y_min",
   ")",
   "/",
   "2.0",
   ",",
   "(",
   "x_max",
   "+",
   "x_min",
   ")",
   "/",
   "2.0",
   ")",
   "return",
   "self",
   ".",
   "Geometry",
   "(",
   "shape_arcsec",
   "=",
   "shape_arcsec",
   ",",
   "pixel_centres",
   "=",
   "pixel_centres",
   ",",
   "origin",
   "=",
   "origin",
   ",",
   "pixel_neighbors",
   "=",
   "pixel_neighbors",
   ",",
   "pixel_neighbors_size",
   "=",
   "pixel_neighbors_size",
   ")"
  ]
 },
 {
  "idx": "maxmin-640",
  "nl_tokens": [
   "Given",
   "a",
   "list",
   "of",
   "pathnames",
   "returns",
   "the",
   "longest",
   "common",
   "leading",
   "component"
  ],
  "pl_tokens": [
   "def",
   "commonprefix",
   "(",
   "m",
   ")",
   ":",
   "if",
   "not",
   "m",
   ":",
   "return",
   "''",
   "s1",
   "=",
   "<mask>",
   "(",
   "m",
   ")",
   "s2",
   "=",
   "max",
   "(",
   "m",
   ")",
   "for",
   "i",
   ",",
   "c",
   "in",
   "enumerate",
   "(",
   "s1",
   ")",
   ":",
   "if",
   "c",
   "!=",
   "s2",
   "[",
   "i",
   "]",
   ":",
   "return",
   "s1",
   "[",
   ":",
   "i",
   "]",
   "return",
   "s1"
  ]
 },
 {
  "idx": "maxmin-641",
  "nl_tokens": [
   "Pads",
   "each",
   "sequence",
   "to",
   "the",
   "same",
   "length",
   ":",
   "the",
   "length",
   "of",
   "the",
   "longest",
   "sequence",
   ".",
   "If",
   "maxlen",
   "is",
   "provided",
   "any",
   "sequence",
   "longer",
   "than",
   "maxlen",
   "is",
   "truncated",
   "to",
   "maxlen",
   ".",
   "Truncation",
   "happens",
   "off",
   "either",
   "the",
   "beginning",
   "(",
   "default",
   ")",
   "or",
   "the",
   "end",
   "of",
   "the",
   "sequence",
   ".",
   "Supports",
   "post",
   "-",
   "padding",
   "and",
   "pre",
   "-",
   "padding",
   "(",
   "default",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "pad_sequences",
   "(",
   "sequences",
   ",",
   "maxlen",
   "=",
   "None",
   ",",
   "dtype",
   "=",
   "'int32'",
   ",",
   "padding",
   "=",
   "'post'",
   ",",
   "truncating",
   "=",
   "'pre'",
   ",",
   "value",
   "=",
   "0.",
   ")",
   ":",
   "lengths",
   "=",
   "[",
   "len",
   "(",
   "s",
   ")",
   "for",
   "s",
   "in",
   "sequences",
   "]",
   "nb_samples",
   "=",
   "len",
   "(",
   "sequences",
   ")",
   "if",
   "maxlen",
   "is",
   "None",
   ":",
   "maxlen",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "lengths",
   ")",
   "# take the sample shape from the first non empty sequence",
   "# checking for consistency in the main loop below.",
   "sample_shape",
   "=",
   "tuple",
   "(",
   ")",
   "for",
   "s",
   "in",
   "sequences",
   ":",
   "if",
   "len",
   "(",
   "s",
   ")",
   ">",
   "0",
   ":",
   "sample_shape",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "s",
   ")",
   ".",
   "shape",
   "[",
   "1",
   ":",
   "]",
   "break",
   "x",
   "=",
   "(",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "nb_samples",
   ",",
   "maxlen",
   ")",
   "+",
   "sample_shape",
   ")",
   "*",
   "value",
   ")",
   ".",
   "astype",
   "(",
   "dtype",
   ")",
   "for",
   "idx",
   ",",
   "s",
   "in",
   "enumerate",
   "(",
   "sequences",
   ")",
   ":",
   "if",
   "len",
   "(",
   "s",
   ")",
   "==",
   "0",
   ":",
   "continue",
   "# empty list was found",
   "if",
   "truncating",
   "==",
   "'pre'",
   ":",
   "trunc",
   "=",
   "s",
   "[",
   "-",
   "maxlen",
   ":",
   "]",
   "elif",
   "truncating",
   "==",
   "'post'",
   ":",
   "trunc",
   "=",
   "s",
   "[",
   ":",
   "maxlen",
   "]",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Truncating type \"%s\" not understood'",
   "%",
   "truncating",
   ")",
   "# check `trunc` has expected shape",
   "trunc",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "trunc",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "if",
   "trunc",
   ".",
   "shape",
   "[",
   "1",
   ":",
   "]",
   "!=",
   "sample_shape",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Shape of sample %s of sequence at position %s is different from expected shape %s'",
   "%",
   "(",
   "trunc",
   ".",
   "shape",
   "[",
   "1",
   ":",
   "]",
   ",",
   "idx",
   ",",
   "sample_shape",
   ")",
   ")",
   "if",
   "padding",
   "==",
   "'post'",
   ":",
   "x",
   "[",
   "idx",
   ",",
   ":",
   "len",
   "(",
   "trunc",
   ")",
   "]",
   "=",
   "trunc",
   "elif",
   "padding",
   "==",
   "'pre'",
   ":",
   "x",
   "[",
   "idx",
   ",",
   "-",
   "len",
   "(",
   "trunc",
   ")",
   ":",
   "]",
   "=",
   "trunc",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Padding type \"%s\" not understood'",
   "%",
   "padding",
   ")",
   "return",
   "x",
   ".",
   "tolist",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-642",
  "nl_tokens": [
   "Return",
   "the",
   "Jaro",
   "or",
   "Jaro",
   "-",
   "Winkler",
   "similarity",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "sim",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "qval",
   "=",
   "1",
   ",",
   "mode",
   "=",
   "'winkler'",
   ",",
   "long_strings",
   "=",
   "False",
   ",",
   "boost_threshold",
   "=",
   "0.7",
   ",",
   "scaling_factor",
   "=",
   "0.1",
   ",",
   ")",
   ":",
   "if",
   "mode",
   "==",
   "'winkler'",
   ":",
   "if",
   "boost_threshold",
   ">",
   "1",
   "or",
   "boost_threshold",
   "<",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Unsupported boost_threshold assignment; '",
   "+",
   "'boost_threshold must be between 0 and 1.'",
   ")",
   "if",
   "scaling_factor",
   ">",
   "0.25",
   "or",
   "scaling_factor",
   "<",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Unsupported scaling_factor assignment; '",
   "+",
   "'scaling_factor must be between 0 and 0.25.'",
   ")",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "1.0",
   "src",
   "=",
   "QGrams",
   "(",
   "src",
   ".",
   "strip",
   "(",
   ")",
   ",",
   "qval",
   ")",
   ".",
   "_ordered_list",
   "tar",
   "=",
   "QGrams",
   "(",
   "tar",
   ".",
   "strip",
   "(",
   ")",
   ",",
   "qval",
   ")",
   ".",
   "_ordered_list",
   "lens",
   "=",
   "len",
   "(",
   "src",
   ")",
   "lent",
   "=",
   "len",
   "(",
   "tar",
   ")",
   "# If either string is blank - return - added in Version 2",
   "if",
   "lens",
   "==",
   "0",
   "or",
   "lent",
   "==",
   "0",
   ":",
   "return",
   "0.0",
   "if",
   "lens",
   ">",
   "lent",
   ":",
   "search_range",
   "=",
   "lens",
   "minv",
   "=",
   "lent",
   "else",
   ":",
   "search_range",
   "=",
   "lent",
   "minv",
   "=",
   "lens",
   "# Zero out the flags",
   "src_flag",
   "=",
   "[",
   "0",
   "]",
   "*",
   "search_range",
   "tar_flag",
   "=",
   "[",
   "0",
   "]",
   "*",
   "search_range",
   "search_range",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "search_range",
   "//",
   "2",
   "-",
   "1",
   ")",
   "# Looking only within the search range,",
   "# count and flag the matched pairs.",
   "num_com",
   "=",
   "0",
   "yl1",
   "=",
   "lent",
   "-",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "lens",
   ")",
   ":",
   "low_lim",
   "=",
   "(",
   "i",
   "-",
   "search_range",
   ")",
   "if",
   "(",
   "i",
   ">=",
   "search_range",
   ")",
   "else",
   "0",
   "hi_lim",
   "=",
   "(",
   "i",
   "+",
   "search_range",
   ")",
   "if",
   "(",
   "(",
   "i",
   "+",
   "search_range",
   ")",
   "<=",
   "yl1",
   ")",
   "else",
   "yl1",
   "for",
   "j",
   "in",
   "range",
   "(",
   "low_lim",
   ",",
   "hi_lim",
   "+",
   "1",
   ")",
   ":",
   "if",
   "(",
   "tar_flag",
   "[",
   "j",
   "]",
   "==",
   "0",
   ")",
   "and",
   "(",
   "tar",
   "[",
   "j",
   "]",
   "==",
   "src",
   "[",
   "i",
   "]",
   ")",
   ":",
   "tar_flag",
   "[",
   "j",
   "]",
   "=",
   "1",
   "src_flag",
   "[",
   "i",
   "]",
   "=",
   "1",
   "num_com",
   "+=",
   "1",
   "break",
   "# If no characters in common - return",
   "if",
   "num_com",
   "==",
   "0",
   ":",
   "return",
   "0.0",
   "# Count the number of transpositions",
   "k",
   "=",
   "n_trans",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "lens",
   ")",
   ":",
   "if",
   "src_flag",
   "[",
   "i",
   "]",
   "!=",
   "0",
   ":",
   "j",
   "=",
   "0",
   "for",
   "j",
   "in",
   "range",
   "(",
   "k",
   ",",
   "lent",
   ")",
   ":",
   "# pragma: no branch",
   "if",
   "tar_flag",
   "[",
   "j",
   "]",
   "!=",
   "0",
   ":",
   "k",
   "=",
   "j",
   "+",
   "1",
   "break",
   "if",
   "src",
   "[",
   "i",
   "]",
   "!=",
   "tar",
   "[",
   "j",
   "]",
   ":",
   "n_trans",
   "+=",
   "1",
   "n_trans",
   "//=",
   "2",
   "# Main weight computation for Jaro distance",
   "weight",
   "=",
   "(",
   "num_com",
   "/",
   "lens",
   "+",
   "num_com",
   "/",
   "lent",
   "+",
   "(",
   "num_com",
   "-",
   "n_trans",
   ")",
   "/",
   "num_com",
   ")",
   "weight",
   "/=",
   "3.0",
   "# Continue to boost the weight if the strings are similar",
   "# This is the Winkler portion of Jaro-Winkler distance",
   "if",
   "mode",
   "==",
   "'winkler'",
   "and",
   "weight",
   ">",
   "boost_threshold",
   ":",
   "# Adjust for having up to the first 4 characters in common",
   "j",
   "=",
   "4",
   "if",
   "(",
   "minv",
   ">=",
   "4",
   ")",
   "else",
   "minv",
   "i",
   "=",
   "0",
   "while",
   "(",
   "i",
   "<",
   "j",
   ")",
   "and",
   "(",
   "src",
   "[",
   "i",
   "]",
   "==",
   "tar",
   "[",
   "i",
   "]",
   ")",
   ":",
   "i",
   "+=",
   "1",
   "weight",
   "+=",
   "i",
   "*",
   "scaling_factor",
   "*",
   "(",
   "1.0",
   "-",
   "weight",
   ")",
   "# Optionally adjust for long strings.",
   "# After agreeing beginning chars, at least two more must agree and",
   "# the agreeing characters must be > .5 of remaining characters.",
   "if",
   "(",
   "long_strings",
   "and",
   "(",
   "minv",
   ">",
   "4",
   ")",
   "and",
   "(",
   "num_com",
   ">",
   "i",
   "+",
   "1",
   ")",
   "and",
   "(",
   "2",
   "*",
   "num_com",
   ">=",
   "minv",
   "+",
   "i",
   ")",
   ")",
   ":",
   "weight",
   "+=",
   "(",
   "1.0",
   "-",
   "weight",
   ")",
   "*",
   "(",
   "(",
   "num_com",
   "-",
   "i",
   "-",
   "1",
   ")",
   "/",
   "(",
   "lens",
   "+",
   "lent",
   "-",
   "i",
   "*",
   "2",
   "+",
   "2",
   ")",
   ")",
   "return",
   "weight"
  ]
 },
 {
  "idx": "maxmin-643",
  "nl_tokens": [
   "Reads",
   "data",
   "from",
   "the",
   "TLS",
   "-",
   "wrapped",
   "socket"
  ],
  "pl_tokens": [
   "def",
   "read",
   "(",
   "self",
   ",",
   "max_length",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "max_length",
   ",",
   "int_types",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "pretty_message",
   "(",
   "'''\n                max_length must be an integer, not %s\n                '''",
   ",",
   "type_name",
   "(",
   "max_length",
   ")",
   ")",
   ")",
   "if",
   "self",
   ".",
   "_context_handle_pointer",
   "is",
   "None",
   ":",
   "# Allow the user to read any remaining decrypted data",
   "if",
   "self",
   ".",
   "_decrypted_bytes",
   "!=",
   "b''",
   ":",
   "output",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "[",
   "0",
   ":",
   "max_length",
   "]",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "[",
   "max_length",
   ":",
   "]",
   "return",
   "output",
   "self",
   ".",
   "_raise_closed",
   "(",
   ")",
   "# The first time read is called, set up a single contiguous buffer that",
   "# it used by DecryptMessage() to populate the three output buffers.",
   "# Since we are creating the buffer, we do not need to free it other",
   "# than allowing Python to GC it once this object is GCed.",
   "if",
   "not",
   "self",
   ".",
   "_decrypt_data_buffer",
   ":",
   "self",
   ".",
   "_decrypt_data_buffer",
   "=",
   "buffer_from_bytes",
   "(",
   "self",
   ".",
   "_buffer_size",
   ")",
   "self",
   ".",
   "_decrypt_desc",
   ",",
   "self",
   ".",
   "_decrypt_buffers",
   "=",
   "self",
   ".",
   "_create_buffers",
   "(",
   "4",
   ")",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_DATA",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "pvBuffer",
   "=",
   "cast",
   "(",
   "secur32",
   ",",
   "'BYTE *'",
   ",",
   "self",
   ".",
   "_decrypt_data_buffer",
   ")",
   "to_recv",
   "=",
   "<mask>",
   "(",
   "max_length",
   ",",
   "self",
   ".",
   "_buffer_size",
   ")",
   "# These variables are set to reduce dict access and function calls",
   "# in the read loop. Also makes the code easier to read.",
   "null_value",
   "=",
   "null",
   "(",
   ")",
   "buf0",
   "=",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "0",
   "]",
   "buf1",
   "=",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "1",
   "]",
   "buf2",
   "=",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "2",
   "]",
   "buf3",
   "=",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "3",
   "]",
   "def",
   "_reset_buffers",
   "(",
   ")",
   ":",
   "buf0",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_DATA",
   "buf0",
   ".",
   "pvBuffer",
   "=",
   "cast",
   "(",
   "secur32",
   ",",
   "'BYTE *'",
   ",",
   "self",
   ".",
   "_decrypt_data_buffer",
   ")",
   "buf0",
   ".",
   "cbBuffer",
   "=",
   "0",
   "buf1",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_EMPTY",
   "buf1",
   ".",
   "pvBuffer",
   "=",
   "null_value",
   "buf1",
   ".",
   "cbBuffer",
   "=",
   "0",
   "buf2",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_EMPTY",
   "buf2",
   ".",
   "pvBuffer",
   "=",
   "null_value",
   "buf2",
   ".",
   "cbBuffer",
   "=",
   "0",
   "buf3",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_EMPTY",
   "buf3",
   ".",
   "pvBuffer",
   "=",
   "null_value",
   "buf3",
   ".",
   "cbBuffer",
   "=",
   "0",
   "output",
   "=",
   "self",
   ".",
   "_decrypted_bytes",
   "output_len",
   "=",
   "len",
   "(",
   "output",
   ")",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "b''",
   "# Don't block if we have buffered data available",
   "if",
   "output_len",
   ">",
   "0",
   "and",
   "not",
   "self",
   ".",
   "select_read",
   "(",
   "0",
   ")",
   ":",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "b''",
   "return",
   "output",
   "# This read loop will only be run if there wasn't enough",
   "# buffered data to fulfill the requested max_length",
   "do_read",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_received_bytes",
   ")",
   "==",
   "0",
   "while",
   "output_len",
   "<",
   "max_length",
   ":",
   "if",
   "do_read",
   ":",
   "self",
   ".",
   "_received_bytes",
   "+=",
   "self",
   ".",
   "_socket",
   ".",
   "recv",
   "(",
   "to_recv",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_received_bytes",
   ")",
   "==",
   "0",
   ":",
   "raise_disconnection",
   "(",
   ")",
   "data_len",
   "=",
   "min",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_received_bytes",
   ")",
   ",",
   "self",
   ".",
   "_buffer_size",
   ")",
   "if",
   "data_len",
   "==",
   "0",
   ":",
   "break",
   "self",
   ".",
   "_decrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "cbBuffer",
   "=",
   "data_len",
   "write_to_buffer",
   "(",
   "self",
   ".",
   "_decrypt_data_buffer",
   ",",
   "self",
   ".",
   "_received_bytes",
   "[",
   "0",
   ":",
   "data_len",
   "]",
   ")",
   "result",
   "=",
   "secur32",
   ".",
   "DecryptMessage",
   "(",
   "self",
   ".",
   "_context_handle_pointer",
   ",",
   "self",
   ".",
   "_decrypt_desc",
   ",",
   "0",
   ",",
   "null",
   "(",
   ")",
   ")",
   "do_read",
   "=",
   "False",
   "if",
   "result",
   "==",
   "Secur32Const",
   ".",
   "SEC_E_INCOMPLETE_MESSAGE",
   ":",
   "_reset_buffers",
   "(",
   ")",
   "do_read",
   "=",
   "True",
   "continue",
   "elif",
   "result",
   "==",
   "Secur32Const",
   ".",
   "SEC_I_CONTEXT_EXPIRED",
   ":",
   "self",
   ".",
   "_remote_closed",
   "=",
   "True",
   "self",
   ".",
   "shutdown",
   "(",
   ")",
   "break",
   "elif",
   "result",
   "==",
   "Secur32Const",
   ".",
   "SEC_I_RENEGOTIATE",
   ":",
   "self",
   ".",
   "_handshake",
   "(",
   "renegotiate",
   "=",
   "True",
   ")",
   "return",
   "self",
   ".",
   "read",
   "(",
   "max_length",
   ")",
   "elif",
   "result",
   "!=",
   "Secur32Const",
   ".",
   "SEC_E_OK",
   ":",
   "handle_error",
   "(",
   "result",
   ",",
   "TLSError",
   ")",
   "valid_buffer_types",
   "=",
   "set",
   "(",
   "[",
   "Secur32Const",
   ".",
   "SECBUFFER_EMPTY",
   ",",
   "Secur32Const",
   ".",
   "SECBUFFER_STREAM_HEADER",
   ",",
   "Secur32Const",
   ".",
   "SECBUFFER_STREAM_TRAILER",
   "]",
   ")",
   "extra_amount",
   "=",
   "None",
   "for",
   "buf",
   "in",
   "(",
   "buf0",
   ",",
   "buf1",
   ",",
   "buf2",
   ",",
   "buf3",
   ")",
   ":",
   "buffer_type",
   "=",
   "buf",
   ".",
   "BufferType",
   "if",
   "buffer_type",
   "==",
   "Secur32Const",
   ".",
   "SECBUFFER_DATA",
   ":",
   "output",
   "+=",
   "bytes_from_buffer",
   "(",
   "buf",
   ".",
   "pvBuffer",
   ",",
   "buf",
   ".",
   "cbBuffer",
   ")",
   "output_len",
   "=",
   "len",
   "(",
   "output",
   ")",
   "elif",
   "buffer_type",
   "==",
   "Secur32Const",
   ".",
   "SECBUFFER_EXTRA",
   ":",
   "extra_amount",
   "=",
   "native",
   "(",
   "int",
   ",",
   "buf",
   ".",
   "cbBuffer",
   ")",
   "elif",
   "buffer_type",
   "not",
   "in",
   "valid_buffer_types",
   ":",
   "raise",
   "OSError",
   "(",
   "pretty_message",
   "(",
   "'''\n                        Unexpected decrypt output buffer of type %s\n                        '''",
   ",",
   "buffer_type",
   ")",
   ")",
   "if",
   "extra_amount",
   ":",
   "self",
   ".",
   "_received_bytes",
   "=",
   "self",
   ".",
   "_received_bytes",
   "[",
   "data_len",
   "-",
   "extra_amount",
   ":",
   "]",
   "else",
   ":",
   "self",
   ".",
   "_received_bytes",
   "=",
   "self",
   ".",
   "_received_bytes",
   "[",
   "data_len",
   ":",
   "]",
   "# Here we reset the structs for the next call to DecryptMessage()",
   "_reset_buffers",
   "(",
   ")",
   "# If we have read something, but there is nothing left to read, we",
   "# break so that we don't block for longer than necessary",
   "if",
   "self",
   ".",
   "select_read",
   "(",
   "0",
   ")",
   ":",
   "do_read",
   "=",
   "True",
   "if",
   "not",
   "do_read",
   "and",
   "len",
   "(",
   "self",
   ".",
   "_received_bytes",
   ")",
   "==",
   "0",
   ":",
   "break",
   "# If the output is more than we requested (because data is decrypted in",
   "# blocks), we save the extra in a buffer",
   "if",
   "len",
   "(",
   "output",
   ")",
   ">",
   "max_length",
   ":",
   "self",
   ".",
   "_decrypted_bytes",
   "=",
   "output",
   "[",
   "max_length",
   ":",
   "]",
   "output",
   "=",
   "output",
   "[",
   "0",
   ":",
   "max_length",
   "]",
   "return",
   "output"
  ]
 },
 {
  "idx": "maxmin-644",
  "nl_tokens": [
   "Return",
   "whether",
   "I",
   "am",
   "compatible",
   "with",
   "the",
   "given",
   "var",
   ":",
   "-",
   "Type",
   "should",
   "be",
   "the",
   "same",
   "-",
   "My",
   "value",
   "should",
   "be",
   "inside",
   "the",
   "given",
   "vars",
   "min",
   "/",
   "max",
   "range",
   "."
  ],
  "pl_tokens": [
   "def",
   "compliesTo",
   "(",
   "self",
   ",",
   "v",
   ")",
   ":",
   "if",
   "self",
   ".",
   "type",
   "==",
   "v",
   ".",
   "type",
   ":",
   "if",
   "self",
   ".",
   "type",
   "==",
   "NUMBER",
   ":",
   "if",
   "self",
   ".",
   "value",
   "<",
   "self",
   ".",
   "<mask>",
   "or",
   "self",
   ".",
   "value",
   ">",
   "self",
   ".",
   "max",
   ":",
   "return",
   "False",
   "return",
   "True",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-645",
  "nl_tokens": [
   "Compute",
   "the",
   "min",
   "along",
   "a",
   "1D",
   "array",
   "like",
   "ma",
   ".",
   "mean",
   "but",
   "with",
   "a",
   "representativity",
   "coefficient",
   ":",
   "if",
   "ma",
   ".",
   "count",
   "(",
   "a",
   ")",
   "/",
   "ma",
   ".",
   "size",
   "(",
   "a",
   ")",
   ">",
   "=",
   "rep",
   "then",
   "the",
   "result",
   "is",
   "a",
   "masked",
   "value"
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "a",
   ",",
   "rep",
   "=",
   "0.75",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "return",
   "rfunc",
   "(",
   "a",
   ",",
   "ma",
   ".",
   "min",
   ",",
   "rep",
   ",",
   "*",
   "*",
   "kwargs",
   ")"
  ]
 },
 {
  "idx": "maxmin-646",
  "nl_tokens": [
   "Iteratively",
   "finds",
   "the",
   "minimum",
   "value",
   "for",
   "a",
   "symbol",
   "within",
   "given",
   "constraints",
   "."
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "constraints",
   ",",
   "X",
   ":",
   "BitVec",
   ",",
   "M",
   "=",
   "10000",
   ")",
   ":",
   "assert",
   "isinstance",
   "(",
   "X",
   ",",
   "BitVec",
   ")",
   "return",
   "self",
   ".",
   "optimize",
   "(",
   "constraints",
   ",",
   "X",
   ",",
   "'minimize'",
   ",",
   "M",
   ")"
  ]
 },
 {
  "idx": "maxmin-647",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "load",
   "all",
   "data",
   "and",
   "set",
   "all_methods",
   "based",
   "on",
   "the",
   "available",
   "data",
   "and",
   "properties",
   ".",
   "Demo",
   "function",
   "for",
   "testing",
   "only",
   ";",
   "must",
   "be",
   "implemented",
   "according",
   "to",
   "the",
   "methods",
   "available",
   "for",
   "each",
   "individual",
   "method",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_all_methods",
   "(",
   "self",
   ")",
   ":",
   "methods",
   "=",
   "[",
   "]",
   "Tmins",
   ",",
   "Tmaxs",
   "=",
   "[",
   "]",
   ",",
   "[",
   "]",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "[",
   "'7732-18-5'",
   ",",
   "'67-56-1'",
   ",",
   "'64-17-5'",
   "]",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "TEST_METHOD_1",
   ")",
   "self",
   ".",
   "TEST_METHOD_1_Tmin",
   "=",
   "200.",
   "self",
   ".",
   "TEST_METHOD_1_Tmax",
   "=",
   "350",
   "self",
   ".",
   "TEST_METHOD_1_coeffs",
   "=",
   "[",
   "1",
   ",",
   ".002",
   "]",
   "Tmins",
   ".",
   "append",
   "(",
   "self",
   ".",
   "TEST_METHOD_1_Tmin",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "TEST_METHOD_1_Tmax",
   ")",
   "if",
   "self",
   ".",
   "CASRN",
   "in",
   "[",
   "'67-56-1'",
   "]",
   ":",
   "methods",
   ".",
   "append",
   "(",
   "TEST_METHOD_2",
   ")",
   "self",
   ".",
   "TEST_METHOD_2_Tmin",
   "=",
   "300.",
   "self",
   ".",
   "TEST_METHOD_2_Tmax",
   "=",
   "400",
   "self",
   ".",
   "TEST_METHOD_2_coeffs",
   "=",
   "[",
   "1",
   ",",
   ".003",
   "]",
   "Tmins",
   ".",
   "append",
   "(",
   "self",
   ".",
   "TEST_METHOD_2_Tmin",
   ")",
   "Tmaxs",
   ".",
   "append",
   "(",
   "self",
   ".",
   "TEST_METHOD_2_Tmax",
   ")",
   "self",
   ".",
   "all_methods",
   "=",
   "set",
   "(",
   "methods",
   ")",
   "if",
   "Tmins",
   "and",
   "Tmaxs",
   ":",
   "self",
   ".",
   "Tmin",
   "=",
   "<mask>",
   "(",
   "Tmins",
   ")",
   "self",
   ".",
   "Tmax",
   "=",
   "max",
   "(",
   "Tmaxs",
   ")"
  ]
 },
 {
  "idx": "maxmin-648",
  "nl_tokens": [
   "Nsymb",
   "Nerr",
   "SEP_hat",
   "=",
   "QAM_symb_errors",
   "(",
   "tx_data",
   "rx_data",
   "mod_type",
   "Ncorr",
   "=",
   "1024",
   "Ntransient",
   "=",
   "0",
   ")",
   "Count",
   "symbol",
   "errors",
   "between",
   "a",
   "transmitted",
   "and",
   "received",
   "QAM",
   "signal",
   ".",
   "The",
   "received",
   "symbols",
   "are",
   "assumed",
   "to",
   "be",
   "soft",
   "values",
   "on",
   "a",
   "unit",
   "square",
   ".",
   "Time",
   "delay",
   "between",
   "streams",
   "is",
   "detected",
   ".",
   "The",
   "ndarray",
   "tx_data",
   "is",
   "Tx",
   "complex",
   "symbols",
   ".",
   "The",
   "ndarray",
   "rx_data",
   "is",
   "Rx",
   "complex",
   "symbols",
   ".",
   "Note",
   ":",
   "Ncorr",
   "needs",
   "to",
   "be",
   "even"
  ],
  "pl_tokens": [
   "def",
   "QAM_SEP",
   "(",
   "tx_data",
   ",",
   "rx_data",
   ",",
   "mod_type",
   ",",
   "Ncorr",
   "=",
   "1024",
   ",",
   "Ntransient",
   "=",
   "0",
   ",",
   "SEP_disp",
   "=",
   "True",
   ")",
   ":",
   "#Remove Ntransient symbols and makes lengths equal",
   "tx_data",
   "=",
   "tx_data",
   "[",
   "Ntransient",
   ":",
   "]",
   "rx_data",
   "=",
   "rx_data",
   "[",
   "Ntransient",
   ":",
   "]",
   "Nmin",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   "]",
   ")",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "Nmin",
   "]",
   "rx_data",
   "=",
   "rx_data",
   "[",
   ":",
   "Nmin",
   "]",
   "# Perform level translation and quantize the soft symbol values",
   "if",
   "mod_type",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'qpsk'",
   ":",
   "M",
   "=",
   "2",
   "# bits per symbol",
   "elif",
   "mod_type",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'16qam'",
   ":",
   "M",
   "=",
   "4",
   "elif",
   "mod_type",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'64qam'",
   ":",
   "M",
   "=",
   "8",
   "elif",
   "mod_type",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'256qam'",
   ":",
   "M",
   "=",
   "16",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Unknown mod_type'",
   ")",
   "rx_data",
   "=",
   "np",
   ".",
   "rint",
   "(",
   "(",
   "M",
   "-",
   "1",
   ")",
   "*",
   "(",
   "rx_data",
   "+",
   "(",
   "1",
   "+",
   "1j",
   ")",
   ")",
   "/",
   "2.",
   ")",
   "# Fix-up edge points real part",
   "s1r",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "rx_data",
   ".",
   "real",
   ">",
   "M",
   "-",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "s2r",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "rx_data",
   ".",
   "real",
   "<",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "rx_data",
   ".",
   "real",
   "[",
   "s1r",
   "]",
   "=",
   "(",
   "M",
   "-",
   "1",
   ")",
   "*",
   "np",
   ".",
   "ones",
   "(",
   "len",
   "(",
   "s1r",
   ")",
   ")",
   "rx_data",
   ".",
   "real",
   "[",
   "s2r",
   "]",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "s2r",
   ")",
   ")",
   "# Fix-up edge points imag part",
   "s1i",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "rx_data",
   ".",
   "imag",
   ">",
   "M",
   "-",
   "1",
   ")",
   ")",
   "[",
   "0",
   "]",
   "s2i",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "rx_data",
   ".",
   "imag",
   "<",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "rx_data",
   ".",
   "imag",
   "[",
   "s1i",
   "]",
   "=",
   "(",
   "M",
   "-",
   "1",
   ")",
   "*",
   "np",
   ".",
   "ones",
   "(",
   "len",
   "(",
   "s1i",
   ")",
   ")",
   "rx_data",
   ".",
   "imag",
   "[",
   "s2i",
   "]",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "len",
   "(",
   "s2i",
   ")",
   ")",
   "rx_data",
   "=",
   "2",
   "*",
   "rx_data",
   "-",
   "(",
   "M",
   "-",
   "1",
   ")",
   "*",
   "(",
   "1",
   "+",
   "1j",
   ")",
   "#Correlate the first Ncorr symbols at four possible phase rotations",
   "R0",
   ",",
   "lags",
   "=",
   "xcorr",
   "(",
   "rx_data",
   ",",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   "R1",
   ",",
   "lags",
   "=",
   "xcorr",
   "(",
   "rx_data",
   "*",
   "(",
   "1j",
   ")",
   "**",
   "1",
   ",",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   "R2",
   ",",
   "lags",
   "=",
   "xcorr",
   "(",
   "rx_data",
   "*",
   "(",
   "1j",
   ")",
   "**",
   "2",
   ",",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   "R3",
   ",",
   "lags",
   "=",
   "xcorr",
   "(",
   "rx_data",
   "*",
   "(",
   "1j",
   ")",
   "**",
   "3",
   ",",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   "#Place the zero lag value in the center of the array",
   "R0max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R0",
   ".",
   "real",
   ")",
   "R1max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R1",
   ".",
   "real",
   ")",
   "R2max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R2",
   ".",
   "real",
   ")",
   "R3max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R3",
   ".",
   "real",
   ")",
   "R",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "R0max",
   ",",
   "R1max",
   ",",
   "R2max",
   ",",
   "R3max",
   "]",
   ")",
   "Rmax",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R",
   ")",
   "kphase_max",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "kmax",
   "=",
   "kphase_max",
   "[",
   "0",
   "]",
   "#Find correlation lag value is zero at the center of the array",
   "if",
   "kmax",
   "==",
   "0",
   ":",
   "lagmax",
   "=",
   "lags",
   "[",
   "np",
   ".",
   "where",
   "(",
   "R0",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "]",
   "elif",
   "kmax",
   "==",
   "1",
   ":",
   "lagmax",
   "=",
   "lags",
   "[",
   "np",
   ".",
   "where",
   "(",
   "R1",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "]",
   "elif",
   "kmax",
   "==",
   "2",
   ":",
   "lagmax",
   "=",
   "lags",
   "[",
   "np",
   ".",
   "where",
   "(",
   "R2",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "]",
   "elif",
   "kmax",
   "==",
   "3",
   ":",
   "lagmax",
   "=",
   "lags",
   "[",
   "np",
   ".",
   "where",
   "(",
   "R3",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "]",
   "taumax",
   "=",
   "lagmax",
   "[",
   "0",
   "]",
   "if",
   "SEP_disp",
   ":",
   "print",
   "(",
   "'Phase ambiquity = (1j)**%d, taumax = %d'",
   "%",
   "(",
   "kmax",
   ",",
   "taumax",
   ")",
   ")",
   "#Count symbol errors over the entire input ndarrays",
   "#Begin by making tx and rx length equal and apply ",
   "#phase rotation to rx_data",
   "if",
   "taumax",
   "<",
   "0",
   ":",
   "tx_data",
   "=",
   "tx_data",
   "[",
   "-",
   "taumax",
   ":",
   "]",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "min",
   "(",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   ")",
   "]",
   "rx_data",
   "=",
   "(",
   "1j",
   ")",
   "**",
   "kmax",
   "*",
   "rx_data",
   "[",
   ":",
   "len",
   "(",
   "tx_data",
   ")",
   "]",
   "else",
   ":",
   "rx_data",
   "=",
   "(",
   "1j",
   ")",
   "**",
   "kmax",
   "*",
   "rx_data",
   "[",
   "taumax",
   ":",
   "]",
   "rx_data",
   "=",
   "rx_data",
   "[",
   ":",
   "min",
   "(",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   ")",
   "]",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "len",
   "(",
   "rx_data",
   ")",
   "]",
   "#Convert QAM symbol difference to symbol errors",
   "errors",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "abs",
   "(",
   "rx_data",
   "-",
   "tx_data",
   ")",
   ")",
   "# Detect symbols errors",
   "# Could decode bit errors from symbol index difference",
   "idx",
   "=",
   "np",
   ".",
   "nonzero",
   "(",
   "np",
   ".",
   "ravel",
   "(",
   "errors",
   "!=",
   "0",
   ")",
   ")",
   "[",
   "0",
   "]",
   "if",
   "SEP_disp",
   ":",
   "print",
   "(",
   "'Symbols = %d, Errors %d, SEP = %1.2e'",
   "%",
   "(",
   "len",
   "(",
   "errors",
   ")",
   ",",
   "len",
   "(",
   "idx",
   ")",
   ",",
   "len",
   "(",
   "idx",
   ")",
   "/",
   "float",
   "(",
   "len",
   "(",
   "errors",
   ")",
   ")",
   ")",
   ")",
   "return",
   "len",
   "(",
   "errors",
   ")",
   ",",
   "len",
   "(",
   "idx",
   ")",
   ",",
   "len",
   "(",
   "idx",
   ")",
   "/",
   "float",
   "(",
   "len",
   "(",
   "errors",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-649",
  "nl_tokens": [
   "Return",
   "the",
   "NCD",
   "between",
   "two",
   "strings",
   "using",
   "BWT",
   "plus",
   "RLE",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "src_comp",
   "=",
   "self",
   ".",
   "_rle",
   ".",
   "encode",
   "(",
   "self",
   ".",
   "_bwt",
   ".",
   "encode",
   "(",
   "src",
   ")",
   ")",
   "tar_comp",
   "=",
   "self",
   ".",
   "_rle",
   ".",
   "encode",
   "(",
   "self",
   ".",
   "_bwt",
   ".",
   "encode",
   "(",
   "tar",
   ")",
   ")",
   "concat_comp",
   "=",
   "self",
   ".",
   "_rle",
   ".",
   "encode",
   "(",
   "self",
   ".",
   "_bwt",
   ".",
   "encode",
   "(",
   "src",
   "+",
   "tar",
   ")",
   ")",
   "concat_comp2",
   "=",
   "self",
   ".",
   "_rle",
   ".",
   "encode",
   "(",
   "self",
   ".",
   "_bwt",
   ".",
   "encode",
   "(",
   "tar",
   "+",
   "src",
   ")",
   ")",
   "return",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "concat_comp",
   ")",
   ",",
   "len",
   "(",
   "concat_comp2",
   ")",
   ")",
   "-",
   "min",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")",
   ")",
   "/",
   "max",
   "(",
   "len",
   "(",
   "src_comp",
   ")",
   ",",
   "len",
   "(",
   "tar_comp",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-650",
  "nl_tokens": [
   "This",
   "method",
   "will",
   "remove",
   "any",
   "stored",
   "records",
   "within",
   "the",
   "range",
   "from",
   "start",
   "to",
   "end",
   ".",
   "Noninclusive",
   "of",
   "end",
   "."
  ],
  "pl_tokens": [
   "def",
   "_deleteRangeFromKNN",
   "(",
   "self",
   ",",
   "start",
   "=",
   "0",
   ",",
   "end",
   "=",
   "None",
   ")",
   ":",
   "classifier",
   "=",
   "self",
   ".",
   "htm_prediction_model",
   ".",
   "_getAnomalyClassifier",
   "(",
   ")",
   "knn",
   "=",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "_knn",
   "prototype_idx",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "classifier",
   ".",
   "getSelf",
   "(",
   ")",
   ".",
   "getParameter",
   "(",
   "'categoryRecencyList'",
   ")",
   ")",
   "if",
   "end",
   "is",
   "None",
   ":",
   "end",
   "=",
   "prototype_idx",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "1",
   "idsIdxToDelete",
   "=",
   "numpy",
   ".",
   "logical_and",
   "(",
   "prototype_idx",
   ">=",
   "start",
   ",",
   "prototype_idx",
   "<",
   "end",
   ")",
   "idsToDelete",
   "=",
   "prototype_idx",
   "[",
   "idsIdxToDelete",
   "]",
   "nProtos",
   "=",
   "knn",
   ".",
   "_numPatterns",
   "knn",
   ".",
   "removeIds",
   "(",
   "idsToDelete",
   ".",
   "tolist",
   "(",
   ")",
   ")",
   "assert",
   "knn",
   ".",
   "_numPatterns",
   "==",
   "nProtos",
   "-",
   "len",
   "(",
   "idsToDelete",
   ")"
  ]
 },
 {
  "idx": "maxmin-651",
  "nl_tokens": [
   "Writes",
   "data",
   "to",
   "the",
   "TLS",
   "-",
   "wrapped",
   "socket"
  ],
  "pl_tokens": [
   "def",
   "write",
   "(",
   "self",
   ",",
   "data",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_context_handle_pointer",
   "is",
   "None",
   ":",
   "self",
   ".",
   "_raise_closed",
   "(",
   ")",
   "if",
   "not",
   "self",
   ".",
   "_encrypt_data_buffer",
   ":",
   "self",
   ".",
   "_encrypt_data_buffer",
   "=",
   "buffer_from_bytes",
   "(",
   "self",
   ".",
   "_header_size",
   "+",
   "self",
   ".",
   "_message_size",
   "+",
   "self",
   ".",
   "_trailer_size",
   ")",
   "self",
   ".",
   "_encrypt_desc",
   ",",
   "self",
   ".",
   "_encrypt_buffers",
   "=",
   "self",
   ".",
   "_create_buffers",
   "(",
   "4",
   ")",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_STREAM_HEADER",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "cbBuffer",
   "=",
   "self",
   ".",
   "_header_size",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "pvBuffer",
   "=",
   "cast",
   "(",
   "secur32",
   ",",
   "'BYTE *'",
   ",",
   "self",
   ".",
   "_encrypt_data_buffer",
   ")",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "1",
   "]",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_DATA",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "1",
   "]",
   ".",
   "pvBuffer",
   "=",
   "ref",
   "(",
   "self",
   ".",
   "_encrypt_data_buffer",
   ",",
   "self",
   ".",
   "_header_size",
   ")",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "2",
   "]",
   ".",
   "BufferType",
   "=",
   "Secur32Const",
   ".",
   "SECBUFFER_STREAM_TRAILER",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "2",
   "]",
   ".",
   "cbBuffer",
   "=",
   "self",
   ".",
   "_trailer_size",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "2",
   "]",
   ".",
   "pvBuffer",
   "=",
   "ref",
   "(",
   "self",
   ".",
   "_encrypt_data_buffer",
   ",",
   "self",
   ".",
   "_header_size",
   "+",
   "self",
   ".",
   "_message_size",
   ")",
   "while",
   "len",
   "(",
   "data",
   ")",
   ">",
   "0",
   ":",
   "to_write",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "data",
   ")",
   ",",
   "self",
   ".",
   "_message_size",
   ")",
   "write_to_buffer",
   "(",
   "self",
   ".",
   "_encrypt_data_buffer",
   ",",
   "data",
   "[",
   "0",
   ":",
   "to_write",
   "]",
   ",",
   "self",
   ".",
   "_header_size",
   ")",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "1",
   "]",
   ".",
   "cbBuffer",
   "=",
   "to_write",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "2",
   "]",
   ".",
   "pvBuffer",
   "=",
   "ref",
   "(",
   "self",
   ".",
   "_encrypt_data_buffer",
   ",",
   "self",
   ".",
   "_header_size",
   "+",
   "to_write",
   ")",
   "result",
   "=",
   "secur32",
   ".",
   "EncryptMessage",
   "(",
   "self",
   ".",
   "_context_handle_pointer",
   ",",
   "0",
   ",",
   "self",
   ".",
   "_encrypt_desc",
   ",",
   "0",
   ")",
   "if",
   "result",
   "!=",
   "Secur32Const",
   ".",
   "SEC_E_OK",
   ":",
   "handle_error",
   "(",
   "result",
   ",",
   "TLSError",
   ")",
   "to_send",
   "=",
   "native",
   "(",
   "int",
   ",",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "0",
   "]",
   ".",
   "cbBuffer",
   ")",
   "to_send",
   "+=",
   "native",
   "(",
   "int",
   ",",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "1",
   "]",
   ".",
   "cbBuffer",
   ")",
   "to_send",
   "+=",
   "native",
   "(",
   "int",
   ",",
   "self",
   ".",
   "_encrypt_buffers",
   "[",
   "2",
   "]",
   ".",
   "cbBuffer",
   ")",
   "try",
   ":",
   "self",
   ".",
   "_socket",
   ".",
   "send",
   "(",
   "bytes_from_buffer",
   "(",
   "self",
   ".",
   "_encrypt_data_buffer",
   ",",
   "to_send",
   ")",
   ")",
   "except",
   "(",
   "socket_",
   ".",
   "error",
   ")",
   "as",
   "e",
   ":",
   "if",
   "e",
   ".",
   "errno",
   "==",
   "10053",
   ":",
   "raise_disconnection",
   "(",
   ")",
   "raise",
   "data",
   "=",
   "data",
   "[",
   "to_send",
   ":",
   "]"
  ]
 },
 {
  "idx": "maxmin-652",
  "nl_tokens": [
   "This",
   "function",
   "should",
   "be",
   "run",
   "when",
   "there",
   "are",
   "no",
   "leaves",
   "but",
   "there",
   "are",
   "still",
   "unscored",
   "nodes",
   ".",
   "It",
   "will",
   "introduce",
   "a",
   "probabilistic",
   "element",
   "to",
   "the",
   "algorithm",
   "where",
   "some",
   "edges",
   "are",
   "disregarded",
   "randomly",
   "to",
   "eventually",
   "get",
   "a",
   "score",
   "for",
   "the",
   "network",
   ".",
   "This",
   "means",
   "that",
   "the",
   "score",
   "can",
   "be",
   "averaged",
   "over",
   "many",
   "runs",
   "for",
   "a",
   "given",
   "graph",
   "and",
   "a",
   "better",
   "data",
   "structure",
   "will",
   "have",
   "to",
   "be",
   "later",
   "developed",
   "that",
   "doesn",
   "t",
   "destroy",
   "the",
   "graph",
   "(",
   "instead",
   "annotates",
   "which",
   "edges",
   "have",
   "been",
   "disregarded",
   "later",
   ")"
  ],
  "pl_tokens": [
   "def",
   "get_random_edge",
   "(",
   "self",
   ")",
   ":",
   "nodes",
   "=",
   "[",
   "(",
   "n",
   ",",
   "self",
   ".",
   "in_out_ratio",
   "(",
   "n",
   ")",
   ")",
   "for",
   "n",
   "in",
   "self",
   ".",
   "unscored_nodes_iter",
   "(",
   ")",
   "if",
   "n",
   "!=",
   "self",
   ".",
   "target_node",
   "]",
   "node",
   ",",
   "deg",
   "=",
   "<mask>",
   "(",
   "nodes",
   ",",
   "key",
   "=",
   "itemgetter",
   "(",
   "1",
   ")",
   ")",
   "log",
   ".",
   "log",
   "(",
   "5",
   ",",
   "'checking %s (in/out ratio: %.3f)'",
   ",",
   "node",
   ",",
   "deg",
   ")",
   "possible_edges",
   "=",
   "self",
   ".",
   "graph",
   ".",
   "in_edges",
   "(",
   "node",
   ",",
   "keys",
   "=",
   "True",
   ")",
   "log",
   ".",
   "log",
   "(",
   "5",
   ",",
   "'possible edges: %s'",
   ",",
   "possible_edges",
   ")",
   "edge_to_remove",
   "=",
   "random",
   ".",
   "choice",
   "(",
   "possible_edges",
   ")",
   "log",
   ".",
   "log",
   "(",
   "5",
   ",",
   "'chose: %s'",
   ",",
   "edge_to_remove",
   ")",
   "return",
   "edge_to_remove"
  ]
 },
 {
  "idx": "maxmin-653",
  "nl_tokens": [
   "Context",
   "manager",
   "to",
   "only",
   "update",
   "listeners",
   "at",
   "the",
   "end",
   "in",
   "the",
   "meantime",
   "it",
   "doesn",
   "t",
   "matter",
   "what",
   "intermediate",
   "state",
   "the",
   "vars",
   "are",
   "in",
   "(",
   "they",
   "can",
   "be",
   "added",
   "and",
   "removed",
   ")"
  ],
  "pl_tokens": [
   "def",
   "batch",
   "(",
   "vars",
   ",",
   "oldvars",
   ",",
   "ns",
   ")",
   ":",
   "snapshot_vars",
   "=",
   "dict",
   "(",
   "vars",
   ")",
   "with",
   "VarListener",
   ".",
   "disabled",
   "(",
   ")",
   ":",
   "yield",
   "added_vars",
   "=",
   "set",
   "(",
   "oldvars",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "-",
   "set",
   "(",
   "snapshot_vars",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "deleted_vars",
   "=",
   "set",
   "(",
   "snapshot_vars",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "-",
   "set",
   "(",
   "oldvars",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "existing_vars",
   "=",
   "set",
   "(",
   "vars",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "-",
   "added_vars",
   "-",
   "deleted_vars",
   "for",
   "name",
   "in",
   "existing_vars",
   ":",
   "old_var",
   "=",
   "snapshot_vars",
   "[",
   "name",
   "]",
   "new_var",
   "=",
   "vars",
   "[",
   "name",
   "]",
   "if",
   "old_var",
   ".",
   "type",
   "!=",
   "new_var",
   ".",
   "type",
   "or",
   "old_var",
   ".",
   "<mask>",
   "!=",
   "new_var",
   ".",
   "min",
   "or",
   "old_var",
   ".",
   "max",
   "!=",
   "new_var",
   ".",
   "max",
   ":",
   "deleted_vars",
   ".",
   "add",
   "(",
   "name",
   ")",
   "added_vars",
   ".",
   "add",
   "(",
   "name",
   ")",
   "if",
   "old_var",
   ".",
   "type",
   "==",
   "new_var",
   ".",
   "type",
   ":",
   "new_var",
   ".",
   "value",
   "=",
   "old_var",
   ".",
   "value",
   "for",
   "listener",
   "in",
   "VarListener",
   ".",
   "listeners",
   ":",
   "for",
   "name",
   "in",
   "deleted_vars",
   ":",
   "listener",
   ".",
   "var_deleted",
   "(",
   "snapshot_vars",
   "[",
   "name",
   "]",
   ")",
   "if",
   "ns",
   ".",
   "get",
   "(",
   "name",
   ")",
   "is",
   "snapshot_vars",
   "[",
   "name",
   "]",
   ".",
   "value",
   ":",
   "del",
   "ns",
   "[",
   "name",
   "]",
   "for",
   "name",
   "in",
   "added_vars",
   ":",
   "listener",
   ".",
   "var_added",
   "(",
   "vars",
   "[",
   "name",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-654",
  "nl_tokens": [
   "Rescale",
   "numeric",
   "vector",
   "to",
   "have",
   "specified",
   "maximum",
   "."
  ],
  "pl_tokens": [
   "def",
   "rescale_max",
   "(",
   "x",
   ",",
   "to",
   "=",
   "(",
   "0",
   ",",
   "1",
   ")",
   ",",
   "_from",
   "=",
   "None",
   ")",
   ":",
   "array_like",
   "=",
   "True",
   "try",
   ":",
   "len",
   "(",
   "x",
   ")",
   "except",
   "TypeError",
   ":",
   "array_like",
   "=",
   "False",
   "x",
   "=",
   "[",
   "x",
   "]",
   "if",
   "not",
   "hasattr",
   "(",
   "x",
   ",",
   "'dtype'",
   ")",
   ":",
   "x",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "x",
   ")",
   "if",
   "_from",
   "is",
   "None",
   ":",
   "_from",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "]",
   ")",
   "out",
   "=",
   "x",
   "/",
   "_from",
   "[",
   "1",
   "]",
   "*",
   "to",
   "[",
   "1",
   "]",
   "if",
   "not",
   "array_like",
   ":",
   "out",
   "=",
   "out",
   "[",
   "0",
   "]",
   "return",
   "out"
  ]
 },
 {
  "idx": "maxmin-655",
  "nl_tokens": [
   "Identifies",
   "regions",
   "of",
   "missing",
   "/",
   "misfeatured",
   "particles",
   "based",
   "on",
   "the",
   "residuals",
   "local",
   "deviation",
   "from",
   "uniform",
   "Gaussian",
   "noise",
   "."
  ],
  "pl_tokens": [
   "def",
   "identify_misfeatured_regions",
   "(",
   "st",
   ",",
   "filter_size",
   "=",
   "5",
   ",",
   "sigma_cutoff",
   "=",
   "8.",
   ")",
   ":",
   "# 1. Field of local std",
   "r",
   "=",
   "st",
   ".",
   "residuals",
   "weights",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "[",
   "filter_size",
   "]",
   "*",
   "len",
   "(",
   "r",
   ".",
   "shape",
   ")",
   ",",
   "dtype",
   "=",
   "'float'",
   ")",
   "weights",
   "/=",
   "weights",
   ".",
   "sum",
   "(",
   ")",
   "f",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "nd",
   ".",
   "filters",
   ".",
   "convolve",
   "(",
   "r",
   "*",
   "r",
   ",",
   "weights",
   ",",
   "mode",
   "=",
   "'reflect'",
   ")",
   ")",
   "# 2. Maximal reasonable value of the field.",
   "if",
   "sigma_cutoff",
   "==",
   "'otsu'",
   ":",
   "max_ok",
   "=",
   "initializers",
   ".",
   "otsu_threshold",
   "(",
   "f",
   ")",
   "else",
   ":",
   "# max_ok = f.mean() * (1 + sigma_cutoff / np.sqrt(weights.size))",
   "max_ok",
   "=",
   "f",
   ".",
   "mean",
   "(",
   ")",
   "+",
   "sigma_cutoff",
   "*",
   "f",
   ".",
   "std",
   "(",
   ")",
   "# 3. Label & Identify",
   "bad",
   "=",
   "f",
   ">",
   "max_ok",
   "labels",
   ",",
   "n",
   "=",
   "nd",
   ".",
   "measurements",
   ".",
   "label",
   "(",
   "bad",
   ")",
   "inds",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "n",
   "+",
   "1",
   ")",
   ":",
   "inds",
   ".",
   "append",
   "(",
   "np",
   ".",
   "nonzero",
   "(",
   "labels",
   "==",
   "i",
   ")",
   ")",
   "# 4. Parse into tiles",
   "tiles",
   "=",
   "[",
   "Tile",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "ind",
   ",",
   "axis",
   "=",
   "1",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "ind",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "+",
   "1",
   ")",
   "for",
   "ind",
   "in",
   "inds",
   "]",
   "# 5. Sort and return",
   "volumes",
   "=",
   "[",
   "t",
   ".",
   "volume",
   "for",
   "t",
   "in",
   "tiles",
   "]",
   "return",
   "[",
   "tiles",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "np",
   ".",
   "argsort",
   "(",
   "volumes",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "]"
  ]
 },
 {
  "idx": "maxmin-656",
  "nl_tokens": [
   "Populate",
   "array",
   "with",
   "random",
   "quartets",
   "sampled",
   "from",
   "a",
   "generator",
   ".",
   "Holding",
   "all",
   "sets",
   "in",
   "memory",
   "might",
   "take",
   "a",
   "lot",
   "but",
   "holding",
   "a",
   "very",
   "large",
   "list",
   "of",
   "random",
   "numbers",
   "for",
   "which",
   "ones",
   "to",
   "sample",
   "will",
   "fit",
   "into",
   "memory",
   "for",
   "most",
   "reasonable",
   "sized",
   "sets",
   ".",
   "So",
   "we",
   "ll",
   "load",
   "a",
   "list",
   "of",
   "random",
   "numbers",
   "in",
   "the",
   "range",
   "of",
   "the",
   "length",
   "of",
   "total",
   "sets",
   "that",
   "can",
   "be",
   "generated",
   "then",
   "only",
   "keep",
   "sets",
   "from",
   "the",
   "set",
   "generator",
   "if",
   "they",
   "are",
   "in",
   "the",
   "int",
   "list",
   ".",
   "I",
   "did",
   "several",
   "tests",
   "to",
   "check",
   "that",
   "random",
   "pairs",
   "are",
   "as",
   "likely",
   "as",
   "0",
   "&",
   "1",
   "to",
   "come",
   "up",
   "together",
   "in",
   "a",
   "random",
   "quartet",
   "set",
   "."
  ],
  "pl_tokens": [
   "def",
   "store_random",
   "(",
   "self",
   ")",
   ":",
   "with",
   "h5py",
   ".",
   "File",
   "(",
   "self",
   ".",
   "database",
   ".",
   "input",
   ",",
   "'a'",
   ")",
   "as",
   "io5",
   ":",
   "fillsets",
   "=",
   "io5",
   "[",
   "\"quartets\"",
   "]",
   "## set generators",
   "qiter",
   "=",
   "itertools",
   ".",
   "combinations",
   "(",
   "xrange",
   "(",
   "len",
   "(",
   "self",
   ".",
   "samples",
   ")",
   ")",
   ",",
   "4",
   ")",
   "rand",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "n_choose_k",
   "(",
   "len",
   "(",
   "self",
   ".",
   "samples",
   ")",
   ",",
   "4",
   ")",
   ")",
   "np",
   ".",
   "random",
   ".",
   "shuffle",
   "(",
   "rand",
   ")",
   "rslice",
   "=",
   "rand",
   "[",
   ":",
   "self",
   ".",
   "params",
   ".",
   "nquartets",
   "]",
   "rss",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "rslice",
   ")",
   "riter",
   "=",
   "iter",
   "(",
   "rss",
   ")",
   "del",
   "rand",
   ",",
   "rslice",
   "## print progress update 1 to the engine stdout",
   "print",
   "(",
   "self",
   ".",
   "_chunksize",
   ")",
   "## set to store",
   "rando",
   "=",
   "riter",
   ".",
   "next",
   "(",
   ")",
   "tmpr",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "self",
   ".",
   "params",
   ".",
   "nquartets",
   ",",
   "4",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "uint16",
   ")",
   "tidx",
   "=",
   "0",
   "while",
   "1",
   ":",
   "try",
   ":",
   "for",
   "i",
   ",",
   "j",
   "in",
   "enumerate",
   "(",
   "qiter",
   ")",
   ":",
   "if",
   "i",
   "==",
   "rando",
   ":",
   "tmpr",
   "[",
   "tidx",
   "]",
   "=",
   "j",
   "tidx",
   "+=",
   "1",
   "rando",
   "=",
   "riter",
   ".",
   "next",
   "(",
   ")",
   "## print progress bar update to engine stdout",
   "if",
   "not",
   "i",
   "%",
   "self",
   ".",
   "_chunksize",
   ":",
   "print",
   "(",
   "<mask>",
   "(",
   "i",
   ",",
   "self",
   ".",
   "params",
   ".",
   "nquartets",
   ")",
   ")",
   "except",
   "StopIteration",
   ":",
   "break",
   "## store into database",
   "fillsets",
   "[",
   ":",
   "]",
   "=",
   "tmpr",
   "del",
   "tmpr"
  ]
 },
 {
  "idx": "maxmin-657",
  "nl_tokens": [
   "Find",
   "the",
   "external",
   "compartment",
   "in",
   "the",
   "model",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_external_compartment",
   "(",
   "model",
   ")",
   ":",
   "if",
   "model",
   ".",
   "boundary",
   ":",
   "counts",
   "=",
   "pd",
   ".",
   "Series",
   "(",
   "tuple",
   "(",
   "r",
   ".",
   "compartments",
   ")",
   "[",
   "0",
   "]",
   "for",
   "r",
   "in",
   "model",
   ".",
   "boundary",
   ")",
   "most",
   "=",
   "counts",
   ".",
   "value_counts",
   "(",
   ")",
   "most",
   "=",
   "most",
   ".",
   "index",
   "[",
   "most",
   "==",
   "most",
   ".",
   "<mask>",
   "(",
   ")",
   "]",
   ".",
   "to_series",
   "(",
   ")",
   "else",
   ":",
   "most",
   "=",
   "None",
   "like_external",
   "=",
   "compartment_shortlist",
   "[",
   "\"e\"",
   "]",
   "+",
   "[",
   "\"e\"",
   "]",
   "matches",
   "=",
   "pd",
   ".",
   "Series",
   "(",
   "[",
   "co",
   "in",
   "like_external",
   "for",
   "co",
   "in",
   "model",
   ".",
   "compartments",
   "]",
   ",",
   "index",
   "=",
   "model",
   ".",
   "compartments",
   ")",
   "if",
   "matches",
   ".",
   "sum",
   "(",
   ")",
   "==",
   "1",
   ":",
   "compartment",
   "=",
   "matches",
   ".",
   "index",
   "[",
   "matches",
   "]",
   "[",
   "0",
   "]",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"Compartment `%s` sounds like an external compartment. \"",
   "\"Using this one without counting boundary reactions\"",
   "%",
   "compartment",
   ")",
   "return",
   "compartment",
   "elif",
   "most",
   "is",
   "not",
   "None",
   "and",
   "matches",
   ".",
   "sum",
   "(",
   ")",
   ">",
   "1",
   "and",
   "matches",
   "[",
   "most",
   "]",
   ".",
   "sum",
   "(",
   ")",
   "==",
   "1",
   ":",
   "compartment",
   "=",
   "most",
   "[",
   "matches",
   "[",
   "most",
   "]",
   "]",
   "[",
   "0",
   "]",
   "LOGGER",
   ".",
   "warning",
   "(",
   "\"There are several compartments that look like an \"",
   "\"external compartment but `%s` has the most boundary \"",
   "\"reactions, so using that as the external \"",
   "\"compartment.\"",
   "%",
   "compartment",
   ")",
   "return",
   "compartment",
   "elif",
   "matches",
   ".",
   "sum",
   "(",
   ")",
   ">",
   "1",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"There are several compartments (%s) that look \"",
   "\"like external compartments but we can't tell \"",
   "\"which one to use. Consider renaming your \"",
   "\"compartments please.\"",
   ")",
   "if",
   "most",
   "is",
   "not",
   "None",
   ":",
   "return",
   "most",
   "[",
   "0",
   "]",
   "LOGGER",
   ".",
   "warning",
   "(",
   "\"Could not identify an external compartment by name and\"",
   "\" choosing one with the most boundary reactions. That \"",
   "\"might be complete nonsense or change suddenly. \"",
   "\"Consider renaming your compartments using \"",
   "\"`Model.compartments` to fix this.\"",
   ")",
   "# No info in the model, so give up",
   "raise",
   "RuntimeError",
   "(",
   "\"The heuristic for discovering an external compartment \"",
   "\"relies on names and boundary reactions. Yet, there \"",
   "\"are neither compartments with recognized names nor \"",
   "\"boundary reactions in the model.\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-658",
  "nl_tokens": [
   "Given",
   "a",
   "cluster",
   "create",
   "a",
   "Bokeh",
   "plot",
   "figure",
   "creating",
   "an",
   "H",
   "-",
   "R",
   "diagram",
   "."
  ],
  "pl_tokens": [
   "def",
   "hr_diagram_figure",
   "(",
   "cluster",
   ")",
   ":",
   "temps",
   ",",
   "lums",
   "=",
   "round_teff_luminosity",
   "(",
   "cluster",
   ")",
   "x",
   ",",
   "y",
   "=",
   "temps",
   ",",
   "lums",
   "colors",
   ",",
   "color_mapper",
   "=",
   "hr_diagram_color_helper",
   "(",
   "temps",
   ")",
   "x_range",
   "=",
   "[",
   "<mask>",
   "(",
   "x",
   ")",
   "+",
   "max",
   "(",
   "x",
   ")",
   "*",
   "0.05",
   ",",
   "min",
   "(",
   "x",
   ")",
   "-",
   "min",
   "(",
   "x",
   ")",
   "*",
   "0.05",
   "]",
   "source",
   "=",
   "ColumnDataSource",
   "(",
   "data",
   "=",
   "dict",
   "(",
   "x",
   "=",
   "x",
   ",",
   "y",
   "=",
   "y",
   ",",
   "color",
   "=",
   "colors",
   ")",
   ")",
   "pf",
   "=",
   "figure",
   "(",
   "y_axis_type",
   "=",
   "'log'",
   ",",
   "x_range",
   "=",
   "x_range",
   ",",
   "name",
   "=",
   "'hr'",
   ",",
   "tools",
   "=",
   "'box_select,lasso_select,reset,hover'",
   ",",
   "title",
   "=",
   "'H-R Diagram for {0}'",
   ".",
   "format",
   "(",
   "cluster",
   ".",
   "name",
   ")",
   ")",
   "pf",
   ".",
   "select",
   "(",
   "BoxSelectTool",
   ")",
   ".",
   "select_every_mousemove",
   "=",
   "False",
   "pf",
   ".",
   "select",
   "(",
   "LassoSelectTool",
   ")",
   ".",
   "select_every_mousemove",
   "=",
   "False",
   "hover",
   "=",
   "pf",
   ".",
   "select",
   "(",
   "HoverTool",
   ")",
   "[",
   "0",
   "]",
   "hover",
   ".",
   "tooltips",
   "=",
   "[",
   "(",
   "\"Temperature (Kelvin)\"",
   ",",
   "\"@x{0}\"",
   ")",
   ",",
   "(",
   "\"Luminosity (solar units)\"",
   ",",
   "\"@y{0.00}\"",
   ")",
   "]",
   "_diagram",
   "(",
   "source",
   "=",
   "source",
   ",",
   "plot_figure",
   "=",
   "pf",
   ",",
   "name",
   "=",
   "'hr'",
   ",",
   "color",
   "=",
   "{",
   "'field'",
   ":",
   "'color'",
   ",",
   "'transform'",
   ":",
   "color_mapper",
   "}",
   ",",
   "xaxis_label",
   "=",
   "'Temperature (Kelvin)'",
   ",",
   "yaxis_label",
   "=",
   "'Luminosity (solar units)'",
   ")",
   "return",
   "pf"
  ]
 },
 {
  "idx": "maxmin-659",
  "nl_tokens": [
   "num_datapoints",
   "=",
   "min",
   "(",
   "duration",
   "/",
   "resolution",
   "limit",
   ")"
  ],
  "pl_tokens": [
   "def",
   "parse",
   "(",
   "duration_seconds",
   ",",
   "resolution_seconds",
   "=",
   "Resolution",
   ".",
   "MAX_RESOLUTION",
   ",",
   "limit",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "duration_seconds",
   "or",
   "duration_seconds",
   "<",
   "0",
   ":",
   "return",
   "0",
   "if",
   "not",
   "resolution_seconds",
   "or",
   "resolution_seconds",
   "<=",
   "0",
   ":",
   "return",
   "None",
   "num_datapoints",
   "=",
   "duration_seconds",
   "/",
   "resolution_seconds",
   "if",
   "limit",
   ":",
   "num_datapoints",
   "=",
   "<mask>",
   "(",
   "int",
   "(",
   "limit",
   ")",
   ",",
   "num_datapoints",
   ")",
   "return",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "num_datapoints",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-660",
  "nl_tokens": [
   "pads",
   "names",
   "for",
   "loci",
   "output"
  ],
  "pl_tokens": [
   "def",
   "padnames",
   "(",
   "names",
   ")",
   ":",
   "## get longest name",
   "longname_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "names",
   ")",
   "## Padding distance between name and seq.",
   "padding",
   "=",
   "5",
   "## add pad to names",
   "pnames",
   "=",
   "[",
   "name",
   "+",
   "\" \"",
   "*",
   "(",
   "longname_len",
   "-",
   "len",
   "(",
   "name",
   ")",
   "+",
   "padding",
   ")",
   "for",
   "name",
   "in",
   "names",
   "]",
   "snppad",
   "=",
   "\"//\"",
   "+",
   "\" \"",
   "*",
   "(",
   "longname_len",
   "-",
   "2",
   "+",
   "padding",
   ")",
   "return",
   "np",
   ".",
   "array",
   "(",
   "pnames",
   ")",
   ",",
   "snppad"
  ]
 },
 {
  "idx": "maxmin-661",
  "nl_tokens": [
   "Get",
   "get",
   "a",
   "canonical",
   "representation",
   "of",
   "the",
   "ordered",
   "collection",
   "by",
   "finding",
   "its",
   "minimum",
   "circulation",
   "with",
   "the",
   "given",
   "sort",
   "key"
  ],
  "pl_tokens": [
   "def",
   "canonical_circulation",
   "(",
   "elements",
   ":",
   "T",
   ",",
   "key",
   ":",
   "Optional",
   "[",
   "Callable",
   "[",
   "[",
   "T",
   "]",
   ",",
   "bool",
   "]",
   "]",
   "=",
   "None",
   ")",
   "->",
   "T",
   ":",
   "return",
   "<mask>",
   "(",
   "get_circulations",
   "(",
   "elements",
   ")",
   ",",
   "key",
   "=",
   "key",
   ")"
  ]
 },
 {
  "idx": "maxmin-662",
  "nl_tokens": [
   "This",
   "plots",
   "a",
   "magnitude",
   "/",
   "flux",
   "time",
   "-",
   "series",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "errs",
   "=",
   "None",
   ",",
   "out",
   "=",
   "None",
   ",",
   "sigclip",
   "=",
   "30.0",
   ",",
   "normto",
   "=",
   "'globalmedian'",
   ",",
   "normmingap",
   "=",
   "4.0",
   ",",
   "timebin",
   "=",
   "None",
   ",",
   "yrange",
   "=",
   "None",
   ",",
   "segmentmingap",
   "=",
   "100.0",
   ",",
   "plotdpi",
   "=",
   "100",
   ")",
   ":",
   "# sigclip the magnitude timeseries",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# now we proceed to binning",
   "if",
   "timebin",
   "and",
   "errs",
   "is",
   "not",
   "None",
   ":",
   "binned",
   "=",
   "time_bin_magseries_with_errs",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "binsize",
   "=",
   "timebin",
   ")",
   "btimes",
   ",",
   "bmags",
   ",",
   "berrs",
   "=",
   "(",
   "binned",
   "[",
   "'binnedtimes'",
   "]",
   ",",
   "binned",
   "[",
   "'binnedmags'",
   "]",
   ",",
   "binned",
   "[",
   "'binnederrs'",
   "]",
   ")",
   "elif",
   "timebin",
   "and",
   "errs",
   "is",
   "None",
   ":",
   "binned",
   "=",
   "time_bin_magseries",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "binsize",
   "=",
   "timebin",
   ")",
   "btimes",
   ",",
   "bmags",
   ",",
   "berrs",
   "=",
   "binned",
   "[",
   "'binnedtimes'",
   "]",
   ",",
   "binned",
   "[",
   "'binnedmags'",
   "]",
   ",",
   "None",
   "else",
   ":",
   "btimes",
   ",",
   "bmags",
   ",",
   "berrs",
   "=",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "# check if we need to normalize",
   "if",
   "normto",
   "is",
   "not",
   "False",
   ":",
   "btimes",
   ",",
   "bmags",
   "=",
   "normalize_magseries",
   "(",
   "btimes",
   ",",
   "bmags",
   ",",
   "normto",
   "=",
   "normto",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "mingap",
   "=",
   "normmingap",
   ")",
   "btimeorigin",
   "=",
   "btimes",
   ".",
   "<mask>",
   "(",
   ")",
   "btimes",
   "=",
   "btimes",
   "-",
   "btimeorigin",
   "##################################",
   "## FINALLY PLOT THE LIGHT CURVE ##",
   "##################################",
   "# if we're going to plot with segment gaps highlighted, then find the gaps",
   "if",
   "segmentmingap",
   "is",
   "not",
   "None",
   ":",
   "ntimegroups",
   ",",
   "timegroups",
   "=",
   "find_lc_timegroups",
   "(",
   "btimes",
   ",",
   "mingap",
   "=",
   "segmentmingap",
   ")",
   "# get the yrange for all the plots if it's given",
   "if",
   "yrange",
   "and",
   "isinstance",
   "(",
   "yrange",
   ",",
   "(",
   "list",
   ",",
   "tuple",
   ")",
   ")",
   "and",
   "len",
   "(",
   "yrange",
   ")",
   "==",
   "2",
   ":",
   "ymin",
   ",",
   "ymax",
   "=",
   "yrange",
   "# if it's not given, figure it out",
   "else",
   ":",
   "# the plot y limits are just 0.05 mags on each side if mags are used",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "ymin",
   ",",
   "ymax",
   "=",
   "(",
   "bmags",
   ".",
   "min",
   "(",
   ")",
   "-",
   "0.05",
   ",",
   "bmags",
   ".",
   "max",
   "(",
   ")",
   "+",
   "0.05",
   ")",
   "# if we're dealing with fluxes, limits are 2% of the flux range per side",
   "else",
   ":",
   "ycov",
   "=",
   "bmags",
   ".",
   "max",
   "(",
   ")",
   "-",
   "bmags",
   ".",
   "min",
   "(",
   ")",
   "ymin",
   "=",
   "bmags",
   ".",
   "min",
   "(",
   ")",
   "-",
   "0.02",
   "*",
   "ycov",
   "ymax",
   "=",
   "bmags",
   ".",
   "max",
   "(",
   ")",
   "+",
   "0.02",
   "*",
   "ycov",
   "# if we're supposed to make the plot segment-aware (i.e. gaps longer than",
   "# segmentmingap will be cut out)",
   "if",
   "segmentmingap",
   "and",
   "ntimegroups",
   ">",
   "1",
   ":",
   "LOGINFO",
   "(",
   "'%s time groups found'",
   "%",
   "ntimegroups",
   ")",
   "# our figure is now a multiple axis plot",
   "# the aspect ratio is a bit wider",
   "fig",
   ",",
   "axes",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "1",
   ",",
   "ntimegroups",
   ",",
   "sharey",
   "=",
   "True",
   ")",
   "fig",
   ".",
   "set_size_inches",
   "(",
   "10",
   ",",
   "4.8",
   ")",
   "axes",
   "=",
   "np",
   ".",
   "ravel",
   "(",
   "axes",
   ")",
   "# now go through each axis and make the plots for each timegroup",
   "for",
   "timegroup",
   ",",
   "ax",
   ",",
   "axind",
   "in",
   "zip",
   "(",
   "timegroups",
   ",",
   "axes",
   ",",
   "range",
   "(",
   "len",
   "(",
   "axes",
   ")",
   ")",
   ")",
   ":",
   "tgtimes",
   "=",
   "btimes",
   "[",
   "timegroup",
   "]",
   "tgmags",
   "=",
   "bmags",
   "[",
   "timegroup",
   "]",
   "if",
   "berrs",
   ":",
   "tgerrs",
   "=",
   "berrs",
   "[",
   "timegroup",
   "]",
   "else",
   ":",
   "tgerrs",
   "=",
   "None",
   "LOGINFO",
   "(",
   "'axes: %s, timegroup %s: JD %.3f to %.3f'",
   "%",
   "(",
   "axind",
   ",",
   "axind",
   "+",
   "1",
   ",",
   "btimeorigin",
   "+",
   "tgtimes",
   ".",
   "min",
   "(",
   ")",
   ",",
   "btimeorigin",
   "+",
   "tgtimes",
   ".",
   "max",
   "(",
   ")",
   ")",
   ")",
   "ax",
   ".",
   "errorbar",
   "(",
   "tgtimes",
   ",",
   "tgmags",
   ",",
   "fmt",
   "=",
   "'go'",
   ",",
   "yerr",
   "=",
   "tgerrs",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0.0",
   ",",
   "ecolor",
   "=",
   "'grey'",
   ",",
   "capsize",
   "=",
   "0",
   ")",
   "# don't use offsets on any xaxis",
   "ax",
   ".",
   "get_xaxis",
   "(",
   ")",
   ".",
   "get_major_formatter",
   "(",
   ")",
   ".",
   "set_useOffset",
   "(",
   "False",
   ")",
   "# fix the ticks to use no yoffsets and remove right spines for first",
   "# axes instance",
   "if",
   "axind",
   "==",
   "0",
   ":",
   "ax",
   ".",
   "get_yaxis",
   "(",
   ")",
   ".",
   "get_major_formatter",
   "(",
   ")",
   ".",
   "set_useOffset",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "'right'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "tick_left",
   "(",
   ")",
   "# remove the right and left spines for the other axes instances",
   "elif",
   "0",
   "<",
   "axind",
   "<",
   "(",
   "len",
   "(",
   "axes",
   ")",
   "-",
   "1",
   ")",
   ":",
   "ax",
   ".",
   "spines",
   "[",
   "'right'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "'left'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "tick_params",
   "(",
   "right",
   "=",
   "'off'",
   ",",
   "labelright",
   "=",
   "'off'",
   ",",
   "left",
   "=",
   "'off'",
   ",",
   "labelleft",
   "=",
   "'off'",
   ")",
   "# make the left spines invisible for the last axes instance",
   "elif",
   "axind",
   "==",
   "(",
   "len",
   "(",
   "axes",
   ")",
   "-",
   "1",
   ")",
   ":",
   "ax",
   ".",
   "spines",
   "[",
   "'left'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "'right'",
   "]",
   ".",
   "set_visible",
   "(",
   "True",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "tick_right",
   "(",
   ")",
   "# set the yaxis limits",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "ax",
   ".",
   "set_ylim",
   "(",
   "ymax",
   ",",
   "ymin",
   ")",
   "else",
   ":",
   "ax",
   ".",
   "set_ylim",
   "(",
   "ymin",
   ",",
   "ymax",
   ")",
   "# now figure out the xaxis ticklabels and ranges",
   "tgrange",
   "=",
   "tgtimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "tgtimes",
   ".",
   "min",
   "(",
   ")",
   "if",
   "tgrange",
   "<",
   "10.0",
   ":",
   "ticklocations",
   "=",
   "[",
   "tgrange",
   "/",
   "2.0",
   "]",
   "ax",
   ".",
   "set_xlim",
   "(",
   "npmin",
   "(",
   "tgtimes",
   ")",
   "-",
   "0.5",
   ",",
   "npmax",
   "(",
   "tgtimes",
   ")",
   "+",
   "0.5",
   ")",
   "elif",
   "10.0",
   "<",
   "tgrange",
   "<",
   "30.0",
   ":",
   "ticklocations",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "tgtimes",
   ".",
   "min",
   "(",
   ")",
   "+",
   "5.0",
   ",",
   "tgtimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "5.0",
   ",",
   "num",
   "=",
   "2",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "npmin",
   "(",
   "tgtimes",
   ")",
   "-",
   "2.0",
   ",",
   "npmax",
   "(",
   "tgtimes",
   ")",
   "+",
   "2.0",
   ")",
   "elif",
   "30.0",
   "<",
   "tgrange",
   "<",
   "100.0",
   ":",
   "ticklocations",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "tgtimes",
   ".",
   "min",
   "(",
   ")",
   "+",
   "10.0",
   ",",
   "tgtimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "10.0",
   ",",
   "num",
   "=",
   "3",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "npmin",
   "(",
   "tgtimes",
   ")",
   "-",
   "2.5",
   ",",
   "npmax",
   "(",
   "tgtimes",
   ")",
   "+",
   "2.5",
   ")",
   "else",
   ":",
   "ticklocations",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "tgtimes",
   ".",
   "min",
   "(",
   ")",
   "+",
   "20.0",
   ",",
   "tgtimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "20.0",
   ",",
   "num",
   "=",
   "3",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "npmin",
   "(",
   "tgtimes",
   ")",
   "-",
   "3.0",
   ",",
   "npmax",
   "(",
   "tgtimes",
   ")",
   "+",
   "3.0",
   ")",
   "ax",
   ".",
   "xaxis",
   ".",
   "set_ticks",
   "(",
   "[",
   "int",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "ticklocations",
   "]",
   ")",
   "# done with plotting all the sub axes",
   "# make the distance between sub plots smaller",
   "plt",
   ".",
   "subplots_adjust",
   "(",
   "wspace",
   "=",
   "0.07",
   ")",
   "# make the overall x and y labels",
   "fig",
   ".",
   "text",
   "(",
   "0.5",
   ",",
   "0.00",
   ",",
   "'JD - %.3f (not showing gaps > %.2f d)'",
   "%",
   "(",
   "btimeorigin",
   ",",
   "segmentmingap",
   ")",
   ",",
   "ha",
   "=",
   "'center'",
   ")",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "fig",
   ".",
   "text",
   "(",
   "0.02",
   ",",
   "0.5",
   ",",
   "'magnitude'",
   ",",
   "va",
   "=",
   "'center'",
   ",",
   "rotation",
   "=",
   "'vertical'",
   ")",
   "else",
   ":",
   "fig",
   ".",
   "text",
   "(",
   "0.02",
   ",",
   "0.5",
   ",",
   "'flux'",
   ",",
   "va",
   "=",
   "'center'",
   ",",
   "rotation",
   "=",
   "'vertical'",
   ")",
   "# make normal figure otherwise",
   "else",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "fig",
   ".",
   "set_size_inches",
   "(",
   "7.5",
   ",",
   "4.8",
   ")",
   "plt",
   ".",
   "errorbar",
   "(",
   "btimes",
   ",",
   "bmags",
   ",",
   "fmt",
   "=",
   "'go'",
   ",",
   "yerr",
   "=",
   "berrs",
   ",",
   "markersize",
   "=",
   "2.0",
   ",",
   "markeredgewidth",
   "=",
   "0.0",
   ",",
   "ecolor",
   "=",
   "'grey'",
   ",",
   "capsize",
   "=",
   "0",
   ")",
   "# make a grid",
   "plt",
   ".",
   "grid",
   "(",
   "color",
   "=",
   "'#a9a9a9'",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "zorder",
   "=",
   "0",
   ",",
   "linewidth",
   "=",
   "1.0",
   ",",
   "linestyle",
   "=",
   "':'",
   ")",
   "# fix the ticks to use no offsets",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "get_yaxis",
   "(",
   ")",
   ".",
   "get_major_formatter",
   "(",
   ")",
   ".",
   "set_useOffset",
   "(",
   "False",
   ")",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "get_xaxis",
   "(",
   ")",
   ".",
   "get_major_formatter",
   "(",
   ")",
   ".",
   "set_useOffset",
   "(",
   "False",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'JD - %.3f'",
   "%",
   "btimeorigin",
   ")",
   "# set the yaxis limits and labels",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "plt",
   ".",
   "ylim",
   "(",
   "ymax",
   ",",
   "ymin",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'magnitude'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "ylim",
   "(",
   "ymin",
   ",",
   "ymax",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'flux'",
   ")",
   "# check if the output filename is actually an instance of StringIO",
   "if",
   "sys",
   ".",
   "version_info",
   "[",
   ":",
   "2",
   "]",
   "<",
   "(",
   "3",
   ",",
   "0",
   ")",
   ":",
   "is_Strio",
   "=",
   "isinstance",
   "(",
   "out",
   ",",
   "cStringIO",
   ".",
   "InputType",
   ")",
   "else",
   ":",
   "is_Strio",
   "=",
   "isinstance",
   "(",
   "out",
   ",",
   "Strio",
   ")",
   "# write the plot out to a file if requested",
   "if",
   "out",
   "and",
   "not",
   "is_Strio",
   ":",
   "if",
   "out",
   ".",
   "endswith",
   "(",
   "'.png'",
   ")",
   ":",
   "plt",
   ".",
   "savefig",
   "(",
   "out",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "plotdpi",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "savefig",
   "(",
   "out",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "return",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "out",
   ")",
   "elif",
   "out",
   "and",
   "is_Strio",
   ":",
   "plt",
   ".",
   "savefig",
   "(",
   "out",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "plotdpi",
   ",",
   "format",
   "=",
   "'png'",
   ")",
   "return",
   "out",
   "elif",
   "not",
   "out",
   "and",
   "dispok",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "return",
   "else",
   ":",
   "LOGWARNING",
   "(",
   "'no output file specified and no $DISPLAY set, '",
   "'saving to magseries-plot.png in current directory'",
   ")",
   "outfile",
   "=",
   "'magseries-plot.png'",
   "plt",
   ".",
   "savefig",
   "(",
   "outfile",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "plotdpi",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "return",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "outfile",
   ")"
  ]
 },
 {
  "idx": "maxmin-663",
  "nl_tokens": [
   "Generate",
   "a",
   "set",
   "of",
   "simple",
   "sequences",
   ".",
   "The",
   "elements",
   "of",
   "the",
   "sequences",
   "will",
   "be",
   "integers",
   "from",
   "0",
   "to",
   "nCoinc",
   "-",
   "1",
   ".",
   "The",
   "length",
   "of",
   "each",
   "sequence",
   "will",
   "be",
   "randomly",
   "chosen",
   "from",
   "the",
   "seqLength",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "generateSimpleSequences",
   "(",
   "nCoinc",
   "=",
   "10",
   ",",
   "seqLength",
   "=",
   "[",
   "5",
   ",",
   "6",
   ",",
   "7",
   "]",
   ",",
   "nSeq",
   "=",
   "100",
   ")",
   ":",
   "coincList",
   "=",
   "range",
   "(",
   "nCoinc",
   ")",
   "seqList",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "nSeq",
   ")",
   ":",
   "if",
   "<mask>",
   "(",
   "seqLength",
   ")",
   "<=",
   "nCoinc",
   ":",
   "seqList",
   ".",
   "append",
   "(",
   "random",
   ".",
   "sample",
   "(",
   "coincList",
   ",",
   "random",
   ".",
   "choice",
   "(",
   "seqLength",
   ")",
   ")",
   ")",
   "else",
   ":",
   "len",
   "=",
   "random",
   ".",
   "choice",
   "(",
   "seqLength",
   ")",
   "seq",
   "=",
   "[",
   "]",
   "for",
   "x",
   "in",
   "xrange",
   "(",
   "len",
   ")",
   ":",
   "seq",
   ".",
   "append",
   "(",
   "random",
   ".",
   "choice",
   "(",
   "coincList",
   ")",
   ")",
   "seqList",
   ".",
   "append",
   "(",
   "seq",
   ")",
   "return",
   "seqList"
  ]
 },
 {
  "idx": "maxmin-664",
  "nl_tokens": [
   "Python",
   "implementation",
   "/",
   "translation",
   "of",
   "network",
   "deconvolution",
   "by",
   "MIT",
   "-",
   "KELLIS",
   "LAB",
   "."
  ],
  "pl_tokens": [
   "def",
   "network_deconvolution",
   "(",
   "mat",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "alpha",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'alpha'",
   ",",
   "1",
   ")",
   "beta",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'beta'",
   ",",
   "0.99",
   ")",
   "control",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'control'",
   ",",
   "0",
   ")",
   "# ToDO : ASSERTS",
   "try",
   ":",
   "assert",
   "beta",
   "<",
   "1",
   "or",
   "beta",
   ">",
   "0",
   "assert",
   "alpha",
   "<=",
   "1",
   "or",
   "alpha",
   ">",
   "0",
   "except",
   "AssertionError",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"alpha must be in ]0, 1] and beta in [0, 1]\"",
   ")",
   "#  Processing the input matrix, diagonal values are filtered",
   "np",
   ".",
   "fill_diagonal",
   "(",
   "mat",
   ",",
   "0",
   ")",
   "# Thresholding the input matrix",
   "y",
   "=",
   "stat",
   ".",
   "mquantiles",
   "(",
   "mat",
   "[",
   ":",
   "]",
   ",",
   "prob",
   "=",
   "[",
   "1",
   "-",
   "alpha",
   "]",
   ")",
   "th",
   "=",
   "mat",
   ">=",
   "y",
   "mat_th",
   "=",
   "mat",
   "*",
   "th",
   "# Making the matrix symetric if already not",
   "mat_th",
   "=",
   "(",
   "mat_th",
   "+",
   "mat_th",
   ".",
   "T",
   ")",
   "/",
   "2",
   "# Eigen decomposition",
   "Dv",
   ",",
   "U",
   "=",
   "LA",
   ".",
   "eigh",
   "(",
   "mat_th",
   ")",
   "D",
   "=",
   "np",
   ".",
   "diag",
   "(",
   "(",
   "Dv",
   ")",
   ")",
   "lam_n",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "diag",
   "(",
   "D",
   ")",
   ")",
   ",",
   "0",
   ")",
   ")",
   "lam_p",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "diag",
   "(",
   "D",
   ")",
   ")",
   ",",
   "0",
   ")",
   ")",
   "m1",
   "=",
   "lam_p",
   "*",
   "(",
   "1",
   "-",
   "beta",
   ")",
   "/",
   "beta",
   "m2",
   "=",
   "lam_n",
   "*",
   "(",
   "1",
   "+",
   "beta",
   ")",
   "/",
   "beta",
   "m",
   "=",
   "max",
   "(",
   "m1",
   ",",
   "m2",
   ")",
   "# network deconvolution",
   "for",
   "i",
   "in",
   "range",
   "(",
   "D",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "D",
   "[",
   "i",
   ",",
   "i",
   "]",
   "=",
   "(",
   "D",
   "[",
   "i",
   ",",
   "i",
   "]",
   ")",
   "/",
   "(",
   "m",
   "+",
   "D",
   "[",
   "i",
   ",",
   "i",
   "]",
   ")",
   "mat_new1",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "U",
   ",",
   "np",
   ".",
   "dot",
   "(",
   "D",
   ",",
   "LA",
   ".",
   "inv",
   "(",
   "U",
   ")",
   ")",
   ")",
   "# Displying direct weights",
   "if",
   "control",
   "==",
   "0",
   ":",
   "ind_edges",
   "=",
   "(",
   "mat_th",
   ">",
   "0",
   ")",
   "*",
   "1.0",
   "ind_nonedges",
   "=",
   "(",
   "mat_th",
   "==",
   "0",
   ")",
   "*",
   "1.0",
   "m1",
   "=",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "max",
   "(",
   "mat",
   "*",
   "ind_nonedges",
   ")",
   ")",
   "m2",
   "=",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "min",
   "(",
   "mat_new1",
   ")",
   ")",
   "mat_new2",
   "=",
   "(",
   "mat_new1",
   "+",
   "np",
   ".",
   "max",
   "(",
   "m1",
   "-",
   "m2",
   ",",
   "0",
   ")",
   ")",
   "*",
   "ind_edges",
   "+",
   "(",
   "mat",
   "*",
   "ind_nonedges",
   ")",
   "else",
   ":",
   "m2",
   "=",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "min",
   "(",
   "mat_new1",
   ")",
   ")",
   "mat_new2",
   "=",
   "(",
   "mat_new1",
   "+",
   "np",
   ".",
   "max",
   "(",
   "-",
   "m2",
   ",",
   "0",
   ")",
   ")",
   "# linearly mapping the deconvolved matrix to be between 0 and 1",
   "m1",
   "=",
   "np",
   ".",
   "min",
   "(",
   "np",
   ".",
   "min",
   "(",
   "mat_new2",
   ")",
   ")",
   "m2",
   "=",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "max",
   "(",
   "mat_new2",
   ")",
   ")",
   "mat_nd",
   "=",
   "(",
   "mat_new2",
   "-",
   "m1",
   ")",
   "/",
   "(",
   "m2",
   "-",
   "m1",
   ")",
   "return",
   "mat_nd"
  ]
 },
 {
  "idx": "maxmin-665",
  "nl_tokens": [
   "Plot",
   "the",
   "temporal",
   "distance",
   "probability",
   "density",
   "function",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_temporal_distance_pdf",
   "(",
   "self",
   ",",
   "use_minutes",
   "=",
   "True",
   ",",
   "color",
   "=",
   "\"green\"",
   ",",
   "ax",
   "=",
   "None",
   ")",
   ":",
   "from",
   "matplotlib",
   "import",
   "pyplot",
   "as",
   "plt",
   "plt",
   ".",
   "rc",
   "(",
   "'text'",
   ",",
   "usetex",
   "=",
   "True",
   ")",
   "temporal_distance_split_points_ordered",
   ",",
   "densities",
   ",",
   "delta_peaks",
   "=",
   "self",
   ".",
   "_temporal_distance_pdf",
   "(",
   ")",
   "xs",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "x",
   "in",
   "enumerate",
   "(",
   "temporal_distance_split_points_ordered",
   ")",
   ":",
   "xs",
   ".",
   "append",
   "(",
   "x",
   ")",
   "xs",
   ".",
   "append",
   "(",
   "x",
   ")",
   "xs",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "xs",
   ")",
   "ys",
   "=",
   "[",
   "0",
   "]",
   "for",
   "y",
   "in",
   "densities",
   ":",
   "ys",
   ".",
   "append",
   "(",
   "y",
   ")",
   "ys",
   ".",
   "append",
   "(",
   "y",
   ")",
   "ys",
   ".",
   "append",
   "(",
   "0",
   ")",
   "ys",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "ys",
   ")",
   "# convert data to minutes:",
   "xlabel",
   "=",
   "\"Temporal distance (s)\"",
   "ylabel",
   "=",
   "\"Probability density (t)\"",
   "if",
   "use_minutes",
   ":",
   "xs",
   "/=",
   "60.0",
   "ys",
   "*=",
   "60.0",
   "xlabel",
   "=",
   "\"Temporal distance (min)\"",
   "delta_peaks",
   "=",
   "{",
   "peak",
   "/",
   "60.0",
   ":",
   "mass",
   "for",
   "peak",
   ",",
   "mass",
   "in",
   "delta_peaks",
   ".",
   "items",
   "(",
   ")",
   "}",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "111",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "xs",
   ",",
   "ys",
   ",",
   "\"k-\"",
   ")",
   "ax",
   ".",
   "fill_between",
   "(",
   "xs",
   ",",
   "ys",
   ",",
   "color",
   "=",
   "\"green\"",
   ",",
   "alpha",
   "=",
   "0.2",
   ")",
   "if",
   "delta_peaks",
   ":",
   "peak_height",
   "=",
   "<mask>",
   "(",
   "ys",
   ")",
   "*",
   "1.4",
   "max_x",
   "=",
   "max",
   "(",
   "xs",
   ")",
   "min_x",
   "=",
   "min",
   "(",
   "xs",
   ")",
   "now_max_x",
   "=",
   "max",
   "(",
   "xs",
   ")",
   "+",
   "0.3",
   "*",
   "(",
   "max_x",
   "-",
   "min_x",
   ")",
   "now_min_x",
   "=",
   "min_x",
   "-",
   "0.1",
   "*",
   "(",
   "max_x",
   "-",
   "min_x",
   ")",
   "text_x_offset",
   "=",
   "0.1",
   "*",
   "(",
   "now_max_x",
   "-",
   "max_x",
   ")",
   "for",
   "loc",
   ",",
   "mass",
   "in",
   "delta_peaks",
   ".",
   "items",
   "(",
   ")",
   ":",
   "ax",
   ".",
   "plot",
   "(",
   "[",
   "loc",
   ",",
   "loc",
   "]",
   ",",
   "[",
   "0",
   ",",
   "peak_height",
   "]",
   ",",
   "color",
   "=",
   "\"green\"",
   ",",
   "lw",
   "=",
   "5",
   ")",
   "ax",
   ".",
   "text",
   "(",
   "loc",
   "+",
   "text_x_offset",
   ",",
   "peak_height",
   "*",
   "0.99",
   ",",
   "\"$P(\\\\mathrm{walk}) = %.2f$\"",
   "%",
   "(",
   "mass",
   ")",
   ",",
   "color",
   "=",
   "\"green\"",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "now_min_x",
   ",",
   "now_max_x",
   ")",
   "tot_delta_peak_mass",
   "=",
   "sum",
   "(",
   "delta_peaks",
   ".",
   "values",
   "(",
   ")",
   ")",
   "transit_text_x",
   "=",
   "(",
   "min_x",
   "+",
   "max_x",
   ")",
   "/",
   "2",
   "transit_text_y",
   "=",
   "min",
   "(",
   "ys",
   "[",
   "ys",
   ">",
   "0",
   "]",
   ")",
   "/",
   "2.",
   "ax",
   ".",
   "text",
   "(",
   "transit_text_x",
   ",",
   "transit_text_y",
   ",",
   "\"$P(mathrm{PT}) = %.2f$\"",
   "%",
   "(",
   "1",
   "-",
   "tot_delta_peak_mass",
   ")",
   ",",
   "color",
   "=",
   "\"green\"",
   ",",
   "va",
   "=",
   "\"center\"",
   ",",
   "ha",
   "=",
   "\"center\"",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "xlabel",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "ylabel",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "bottom",
   "=",
   "0",
   ")",
   "return",
   "ax",
   ".",
   "figure"
  ]
 },
 {
  "idx": "maxmin-666",
  "nl_tokens": [
   "Increment",
   "version",
   "number",
   "string",
   "version",
   ".",
   "Type",
   "can",
   "be",
   "one",
   "of",
   ":",
   "major",
   "minor",
   "or",
   "bug"
  ],
  "pl_tokens": [
   "def",
   "version_bump",
   "(",
   "self",
   ",",
   "version",
   ",",
   "type",
   "=",
   "\"bug\"",
   ")",
   ":",
   "parsed_version",
   "=",
   "LooseVersion",
   "(",
   "version",
   ")",
   ".",
   "version",
   "total_components",
   "=",
   "<mask>",
   "(",
   "3",
   ",",
   "len",
   "(",
   "parsed_version",
   ")",
   ")",
   "bits",
   "=",
   "[",
   "]",
   "for",
   "bit",
   "in",
   "parsed_version",
   ":",
   "try",
   ":",
   "bit",
   "=",
   "int",
   "(",
   "bit",
   ")",
   "except",
   "ValueError",
   ":",
   "continue",
   "bits",
   ".",
   "append",
   "(",
   "bit",
   ")",
   "indexes",
   "=",
   "{",
   "\"major\"",
   ":",
   "0",
   ",",
   "\"minor\"",
   ":",
   "1",
   ",",
   "\"bug\"",
   ":",
   "2",
   ",",
   "}",
   "bits",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "(",
   "3",
   "-",
   "len",
   "(",
   "bits",
   ")",
   ")",
   "# pad to 3 digits",
   "# Increment the version",
   "bits",
   "[",
   "indexes",
   "[",
   "type",
   "]",
   "]",
   "+=",
   "1",
   "# Set the subsequent digits to 0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "indexes",
   "[",
   "type",
   "]",
   "+",
   "1",
   ",",
   "3",
   ")",
   ":",
   "bits",
   "[",
   "i",
   "]",
   "=",
   "0",
   "return",
   "\".\"",
   ".",
   "join",
   "(",
   "map",
   "(",
   "str",
   ",",
   "bits",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-667",
  "nl_tokens": [
   "Generate",
   "a",
   "transaction",
   "list",
   "report",
   "."
  ],
  "pl_tokens": [
   "def",
   "balance_sheet",
   "(",
   "self",
   ",",
   "end",
   "=",
   "datetime",
   ".",
   "<mask>",
   ",",
   "format",
   "=",
   "ReportFormat",
   ".",
   "printout",
   ",",
   "output_path",
   "=",
   "None",
   ")",
   ":",
   "rpt",
   "=",
   "BalanceSheet",
   "(",
   "self",
   ",",
   "end",
   ",",
   "output_path",
   ")",
   "return",
   "rpt",
   ".",
   "render",
   "(",
   "format",
   ")"
  ]
 },
 {
  "idx": "maxmin-668",
  "nl_tokens": [
   "For",
   "each",
   "package",
   "check",
   "if",
   "the",
   "version",
   "in",
   "one",
   "repo",
   "is",
   "equal",
   "for",
   "all",
   "targets",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_homogeneous",
   "(",
   "package_descriptors",
   ",",
   "targets",
   ",",
   "repos_data",
   ")",
   ":",
   "homogeneous",
   "=",
   "{",
   "}",
   "for",
   "package_descriptor",
   "in",
   "package_descriptors",
   ".",
   "values",
   "(",
   ")",
   ":",
   "pkg_name",
   "=",
   "package_descriptor",
   ".",
   "pkg_name",
   "debian_pkg_name",
   "=",
   "package_descriptor",
   ".",
   "debian_pkg_name",
   "versions",
   "=",
   "[",
   "]",
   "for",
   "repo_data",
   "in",
   "repos_data",
   ":",
   "versions",
   ".",
   "append",
   "(",
   "set",
   "(",
   "[",
   "]",
   ")",
   ")",
   "for",
   "target",
   "in",
   "targets",
   ":",
   "version",
   "=",
   "_strip_version_suffix",
   "(",
   "repo_data",
   ".",
   "get",
   "(",
   "target",
   ",",
   "{",
   "}",
   ")",
   ".",
   "get",
   "(",
   "debian_pkg_name",
   ",",
   "None",
   ")",
   ")",
   "versions",
   "[",
   "-",
   "1",
   "]",
   ".",
   "add",
   "(",
   "version",
   ")",
   "homogeneous",
   "[",
   "pkg_name",
   "]",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "v",
   ")",
   "for",
   "v",
   "in",
   "versions",
   "]",
   ")",
   "==",
   "1",
   "return",
   "homogeneous"
  ]
 },
 {
  "idx": "maxmin-669",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "calculate_connvectivity_radius",
   "(",
   "self",
   ",",
   "amount_clusters",
   ",",
   "maximum_iterations",
   "=",
   "100",
   ")",
   ":",
   "maximum_distance",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "__ordering",
   ")",
   "upper_distance",
   "=",
   "maximum_distance",
   "lower_distance",
   "=",
   "0.0",
   "result",
   "=",
   "None",
   "amount",
   ",",
   "borders",
   "=",
   "self",
   ".",
   "extract_cluster_amount",
   "(",
   "maximum_distance",
   ")",
   "if",
   "amount",
   "<=",
   "amount_clusters",
   ":",
   "for",
   "_",
   "in",
   "range",
   "(",
   "maximum_iterations",
   ")",
   ":",
   "radius",
   "=",
   "(",
   "lower_distance",
   "+",
   "upper_distance",
   ")",
   "/",
   "2.0",
   "amount",
   ",",
   "borders",
   "=",
   "self",
   ".",
   "extract_cluster_amount",
   "(",
   "radius",
   ")",
   "if",
   "amount",
   "==",
   "amount_clusters",
   ":",
   "result",
   "=",
   "radius",
   "break",
   "elif",
   "amount",
   "==",
   "0",
   ":",
   "break",
   "elif",
   "amount",
   ">",
   "amount_clusters",
   ":",
   "lower_distance",
   "=",
   "radius",
   "elif",
   "amount",
   "<",
   "amount_clusters",
   ":",
   "upper_distance",
   "=",
   "radius",
   "return",
   "result",
   ",",
   "borders"
  ]
 },
 {
  "idx": "maxmin-670",
  "nl_tokens": [
   "make",
   "toyplot",
   "matrix",
   "fig"
  ],
  "pl_tokens": [
   "def",
   "_plotshare",
   "(",
   "share",
   ",",
   "names",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "## set the colormap",
   "colormap",
   "=",
   "toyplot",
   ".",
   "color",
   ".",
   "LinearMap",
   "(",
   "toyplot",
   ".",
   "color",
   ".",
   "brewer",
   ".",
   "palette",
   "(",
   "\"Spectral\"",
   ")",
   ",",
   "domain_min",
   "=",
   "share",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "domain_max",
   "=",
   "share",
   ".",
   "max",
   "(",
   ")",
   ")",
   "## set up canvas",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "'width'",
   ")",
   ":",
   "width",
   "=",
   "900",
   "else",
   ":",
   "width",
   "=",
   "kwargs",
   "[",
   "'width'",
   "]",
   "canvas",
   "=",
   "toyplot",
   ".",
   "Canvas",
   "(",
   "width",
   "=",
   "width",
   ",",
   "height",
   "=",
   "width",
   "*",
   "0.77778",
   ")",
   "## order the dta",
   "table",
   "=",
   "canvas",
   ".",
   "matrix",
   "(",
   "(",
   "share",
   ",",
   "colormap",
   ")",
   ",",
   "bounds",
   "=",
   "(",
   "50",
   ",",
   "canvas",
   ".",
   "height",
   "-",
   "100",
   ",",
   "50",
   ",",
   "canvas",
   ".",
   "height",
   "-",
   "100",
   ")",
   ",",
   "step",
   "=",
   "5",
   ",",
   "tshow",
   "=",
   "False",
   ",",
   "lshow",
   "=",
   "False",
   ")",
   "## put a box around the table",
   "table",
   ".",
   "body",
   ".",
   "grid",
   ".",
   "vlines",
   "[",
   "...",
   ",",
   "[",
   "0",
   ",",
   "-",
   "1",
   "]",
   "]",
   "=",
   "'single'",
   "table",
   ".",
   "body",
   ".",
   "grid",
   ".",
   "hlines",
   "[",
   "[",
   "0",
   ",",
   "-",
   "1",
   "]",
   ",",
   "...",
   "]",
   "=",
   "'single'",
   "## make hover info on grid",
   "for",
   "i",
   ",",
   "j",
   "in",
   "itertools",
   ".",
   "product",
   "(",
   "range",
   "(",
   "len",
   "(",
   "share",
   ")",
   ")",
   ",",
   "repeat",
   "=",
   "2",
   ")",
   ":",
   "table",
   ".",
   "body",
   ".",
   "cell",
   "(",
   "i",
   ",",
   "j",
   ")",
   ".",
   "title",
   "=",
   "\"%s, %s : %s\"",
   "%",
   "(",
   "names",
   "[",
   "i",
   "]",
   ",",
   "names",
   "[",
   "j",
   "]",
   ",",
   "int",
   "(",
   "share",
   "[",
   "i",
   ",",
   "j",
   "]",
   ")",
   ")",
   "## create barplot",
   "axes",
   "=",
   "canvas",
   ".",
   "cartesian",
   "(",
   "bounds",
   "=",
   "(",
   "665",
   ",",
   "800",
   ",",
   "90",
   ",",
   "560",
   ")",
   ")",
   "## make a hover for barplot",
   "zf",
   "=",
   "zip",
   "(",
   "names",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "share",
   ".",
   "diagonal",
   "(",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   "barfloater",
   "=",
   "[",
   "\"%s: %s\"",
   "%",
   "(",
   "i",
   ",",
   "int",
   "(",
   "j",
   ")",
   ")",
   "for",
   "i",
   ",",
   "j",
   "in",
   "zf",
   "]",
   "## plot bars",
   "axes",
   ".",
   "bars",
   "(",
   "share",
   ".",
   "diagonal",
   "(",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "along",
   "=",
   "'y'",
   ",",
   "title",
   "=",
   "barfloater",
   ")",
   "## hide spine, move labels to the left, ",
   "## use taxon names, rotate angle, align",
   "axes",
   ".",
   "y",
   ".",
   "spine",
   ".",
   "show",
   "=",
   "False",
   "axes",
   ".",
   "y",
   ".",
   "ticks",
   ".",
   "labels",
   ".",
   "offset",
   "=",
   "0",
   "axes",
   ".",
   "y",
   ".",
   "ticks",
   ".",
   "locator",
   "=",
   "toyplot",
   ".",
   "locator",
   ".",
   "Explicit",
   "(",
   "range",
   "(",
   "len",
   "(",
   "names",
   ")",
   ")",
   ",",
   "labels",
   "=",
   "names",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   "axes",
   ".",
   "y",
   ".",
   "ticks",
   ".",
   "labels",
   ".",
   "angle",
   "=",
   "-",
   "90",
   "axes",
   ".",
   "y",
   ".",
   "ticks",
   ".",
   "labels",
   ".",
   "style",
   "=",
   "{",
   "\"baseline-shift\"",
   ":",
   "0",
   ",",
   "\"text-anchor\"",
   ":",
   "\"end\"",
   ",",
   "\"font-size\"",
   ":",
   "\"8px\"",
   "}",
   "## rotate xlabels, align with ticks, change to thousands, move up on canvas",
   "## show ticks, and hide popup coordinates",
   "axes",
   ".",
   "x",
   ".",
   "ticks",
   ".",
   "labels",
   ".",
   "angle",
   "=",
   "90",
   "axes",
   ".",
   "x",
   ".",
   "ticks",
   ".",
   "labels",
   ".",
   "offset",
   "=",
   "20",
   "axes",
   ".",
   "x",
   ".",
   "ticks",
   ".",
   "locator",
   "=",
   "toyplot",
   ".",
   "locator",
   ".",
   "Explicit",
   "(",
   "range",
   "(",
   "0",
   ",",
   "int",
   "(",
   "share",
   ".",
   "max",
   "(",
   ")",
   ")",
   ",",
   "int",
   "(",
   "share",
   ".",
   "max",
   "(",
   ")",
   "/",
   "10",
   ")",
   ")",
   ",",
   "[",
   "\"{}\"",
   ".",
   "format",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "int",
   "(",
   "share",
   ".",
   "max",
   "(",
   ")",
   ")",
   ",",
   "int",
   "(",
   "share",
   ".",
   "max",
   "(",
   ")",
   "/",
   "10",
   ")",
   ")",
   "]",
   ")",
   "axes",
   ".",
   "x",
   ".",
   "ticks",
   ".",
   "labels",
   ".",
   "style",
   "=",
   "{",
   "\"baseline-shift\"",
   ":",
   "0",
   ",",
   "\"text-anchor\"",
   ":",
   "\"end\"",
   ",",
   "\"-toyplot-anchor-shift\"",
   ":",
   "\"15px\"",
   "}",
   "axes",
   ".",
   "x",
   ".",
   "ticks",
   ".",
   "show",
   "=",
   "True",
   "## add labels",
   "label_style",
   "=",
   "{",
   "\"font-size\"",
   ":",
   "\"16px\"",
   ",",
   "\"font-weight\"",
   ":",
   "\"bold\"",
   "}",
   "canvas",
   ".",
   "text",
   "(",
   "300",
   ",",
   "60",
   ",",
   "\"Matrix of shared RAD loci\"",
   ",",
   "style",
   "=",
   "label_style",
   ")",
   "canvas",
   ".",
   "text",
   "(",
   "700",
   ",",
   "60",
   ",",
   "\"N RAD loci per sample\"",
   ",",
   "style",
   "=",
   "label_style",
   ")",
   "return",
   "canvas",
   ",",
   "axes"
  ]
 },
 {
  "idx": "maxmin-671",
  "nl_tokens": [
   "Yield",
   "CPU",
   ".",
   "This",
   "will",
   "choose",
   "another",
   "process",
   "from",
   "the",
   "RUNNNIG",
   "list",
   "and",
   "change",
   "current",
   "running",
   "process",
   ".",
   "May",
   "give",
   "the",
   "same",
   "cpu",
   "if",
   "only",
   "one",
   "running",
   "process",
   "."
  ],
  "pl_tokens": [
   "def",
   "sched",
   "(",
   "self",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "procs",
   ")",
   ">",
   "1",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"SCHED:\"",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tProcess: %r\"",
   ",",
   "self",
   ".",
   "procs",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tRunning: %r\"",
   ",",
   "self",
   ".",
   "running",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tRWait: %r\"",
   ",",
   "self",
   ".",
   "rwait",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tTWait: %r\"",
   ",",
   "self",
   ".",
   "twait",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tTimers: %r\"",
   ",",
   "self",
   ".",
   "timers",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tCurrent clock: %d\"",
   ",",
   "self",
   ".",
   "clocks",
   ")",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tCurrent cpu: %d\"",
   ",",
   "self",
   ".",
   "_current",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "running",
   ")",
   "==",
   "0",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"None running checking if there is some process waiting for a timeout\"",
   ")",
   "if",
   "all",
   "(",
   "[",
   "x",
   "is",
   "None",
   "for",
   "x",
   "in",
   "self",
   ".",
   "timers",
   "]",
   ")",
   ":",
   "raise",
   "Deadlock",
   "(",
   ")",
   "self",
   ".",
   "clocks",
   "=",
   "<mask>",
   "(",
   "[",
   "x",
   "for",
   "x",
   "in",
   "self",
   ".",
   "timers",
   "if",
   "x",
   "is",
   "not",
   "None",
   "]",
   ")",
   "+",
   "1",
   "self",
   ".",
   "check_timers",
   "(",
   ")",
   "assert",
   "len",
   "(",
   "self",
   ".",
   "running",
   ")",
   "!=",
   "0",
   ",",
   "\"DEADLOCK!\"",
   "self",
   ".",
   "_current",
   "=",
   "self",
   ".",
   "running",
   "[",
   "0",
   "]",
   "return",
   "next_index",
   "=",
   "(",
   "self",
   ".",
   "running",
   ".",
   "index",
   "(",
   "self",
   ".",
   "_current",
   ")",
   "+",
   "1",
   ")",
   "%",
   "len",
   "(",
   "self",
   ".",
   "running",
   ")",
   "next",
   "=",
   "self",
   ".",
   "running",
   "[",
   "next_index",
   "]",
   "if",
   "len",
   "(",
   "self",
   ".",
   "procs",
   ")",
   ">",
   "1",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"\\tTransfer control from process %d to %d\"",
   ",",
   "self",
   ".",
   "_current",
   ",",
   "next",
   ")",
   "self",
   ".",
   "_current",
   "=",
   "next"
  ]
 },
 {
  "idx": "maxmin-672",
  "nl_tokens": [
   "Creates",
   "an",
   "essay",
   "set",
   "from",
   "given",
   "data",
   ".",
   "Text",
   "should",
   "be",
   "a",
   "list",
   "of",
   "strings",
   "corresponding",
   "to",
   "essay",
   "text",
   ".",
   "Score",
   "should",
   "be",
   "a",
   "list",
   "of",
   "scores",
   "where",
   "score",
   "[",
   "n",
   "]",
   "corresponds",
   "to",
   "text",
   "[",
   "n",
   "]",
   "Prompt",
   "string",
   "is",
   "just",
   "a",
   "string",
   "containing",
   "the",
   "essay",
   "prompt",
   ".",
   "Generate_additional",
   "indicates",
   "whether",
   "to",
   "generate",
   "additional",
   "essays",
   "at",
   "the",
   "minimum",
   "score",
   "point",
   "or",
   "not",
   "."
  ],
  "pl_tokens": [
   "def",
   "create_essay_set",
   "(",
   "text",
   ",",
   "score",
   ",",
   "prompt_string",
   ",",
   "generate_additional",
   "=",
   "True",
   ")",
   ":",
   "x",
   "=",
   "EssaySet",
   "(",
   ")",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "text",
   ")",
   ")",
   ":",
   "x",
   ".",
   "add_essay",
   "(",
   "text",
   "[",
   "i",
   "]",
   ",",
   "score",
   "[",
   "i",
   "]",
   ")",
   "if",
   "score",
   "[",
   "i",
   "]",
   "==",
   "<mask>",
   "(",
   "score",
   ")",
   "and",
   "generate_additional",
   "==",
   "True",
   ":",
   "x",
   ".",
   "generate_additional_essays",
   "(",
   "x",
   ".",
   "_clean_text",
   "[",
   "len",
   "(",
   "x",
   ".",
   "_clean_text",
   ")",
   "-",
   "1",
   "]",
   ",",
   "score",
   "[",
   "i",
   "]",
   ")",
   "x",
   ".",
   "update_prompt",
   "(",
   "prompt_string",
   ")",
   "return",
   "x"
  ]
 },
 {
  "idx": "maxmin-673",
  "nl_tokens": [
   "Load",
   "IMDB",
   "dataset",
   "."
  ],
  "pl_tokens": [
   "def",
   "load_imdb_dataset",
   "(",
   "path",
   "=",
   "'data'",
   ",",
   "nb_words",
   "=",
   "None",
   ",",
   "skip_top",
   "=",
   "0",
   ",",
   "maxlen",
   "=",
   "None",
   ",",
   "test_split",
   "=",
   "0.2",
   ",",
   "seed",
   "=",
   "113",
   ",",
   "start_char",
   "=",
   "1",
   ",",
   "oov_char",
   "=",
   "2",
   ",",
   "index_from",
   "=",
   "3",
   ")",
   ":",
   "path",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "path",
   ",",
   "'imdb'",
   ")",
   "filename",
   "=",
   "\"imdb.pkl\"",
   "url",
   "=",
   "'https://s3.amazonaws.com/text-datasets/'",
   "maybe_download_and_extract",
   "(",
   "filename",
   ",",
   "path",
   ",",
   "url",
   ")",
   "if",
   "filename",
   ".",
   "endswith",
   "(",
   "\".gz\"",
   ")",
   ":",
   "f",
   "=",
   "gzip",
   ".",
   "open",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "path",
   ",",
   "filename",
   ")",
   ",",
   "'rb'",
   ")",
   "else",
   ":",
   "f",
   "=",
   "open",
   "(",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "path",
   ",",
   "filename",
   ")",
   ",",
   "'rb'",
   ")",
   "X",
   ",",
   "labels",
   "=",
   "cPickle",
   ".",
   "load",
   "(",
   "f",
   ")",
   "f",
   ".",
   "close",
   "(",
   ")",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "seed",
   ")",
   "np",
   ".",
   "random",
   ".",
   "shuffle",
   "(",
   "X",
   ")",
   "np",
   ".",
   "random",
   ".",
   "seed",
   "(",
   "seed",
   ")",
   "np",
   ".",
   "random",
   ".",
   "shuffle",
   "(",
   "labels",
   ")",
   "if",
   "start_char",
   "is",
   "not",
   "None",
   ":",
   "X",
   "=",
   "[",
   "[",
   "start_char",
   "]",
   "+",
   "[",
   "w",
   "+",
   "index_from",
   "for",
   "w",
   "in",
   "x",
   "]",
   "for",
   "x",
   "in",
   "X",
   "]",
   "elif",
   "index_from",
   ":",
   "X",
   "=",
   "[",
   "[",
   "w",
   "+",
   "index_from",
   "for",
   "w",
   "in",
   "x",
   "]",
   "for",
   "x",
   "in",
   "X",
   "]",
   "if",
   "maxlen",
   ":",
   "new_X",
   "=",
   "[",
   "]",
   "new_labels",
   "=",
   "[",
   "]",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "X",
   ",",
   "labels",
   ")",
   ":",
   "if",
   "len",
   "(",
   "x",
   ")",
   "<",
   "maxlen",
   ":",
   "new_X",
   ".",
   "append",
   "(",
   "x",
   ")",
   "new_labels",
   ".",
   "append",
   "(",
   "y",
   ")",
   "X",
   "=",
   "new_X",
   "labels",
   "=",
   "new_labels",
   "if",
   "not",
   "X",
   ":",
   "raise",
   "Exception",
   "(",
   "'After filtering for sequences shorter than maxlen='",
   "+",
   "str",
   "(",
   "maxlen",
   ")",
   "+",
   "', no sequence was kept. '",
   "'Increase maxlen.'",
   ")",
   "if",
   "not",
   "nb_words",
   ":",
   "nb_words",
   "=",
   "<mask>",
   "(",
   "[",
   "max",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "X",
   "]",
   ")",
   "# by convention, use 2 as OOV word",
   "# reserve 'index_from' (=3 by default) characters: 0 (padding), 1 (start), 2 (OOV)",
   "if",
   "oov_char",
   "is",
   "not",
   "None",
   ":",
   "X",
   "=",
   "[",
   "[",
   "oov_char",
   "if",
   "(",
   "w",
   ">=",
   "nb_words",
   "or",
   "w",
   "<",
   "skip_top",
   ")",
   "else",
   "w",
   "for",
   "w",
   "in",
   "x",
   "]",
   "for",
   "x",
   "in",
   "X",
   "]",
   "else",
   ":",
   "nX",
   "=",
   "[",
   "]",
   "for",
   "x",
   "in",
   "X",
   ":",
   "nx",
   "=",
   "[",
   "]",
   "for",
   "w",
   "in",
   "x",
   ":",
   "if",
   "(",
   "w",
   ">=",
   "nb_words",
   "or",
   "w",
   "<",
   "skip_top",
   ")",
   ":",
   "nx",
   ".",
   "append",
   "(",
   "w",
   ")",
   "nX",
   ".",
   "append",
   "(",
   "nx",
   ")",
   "X",
   "=",
   "nX",
   "X_train",
   "=",
   "np",
   ".",
   "array",
   "(",
   "X",
   "[",
   ":",
   "int",
   "(",
   "len",
   "(",
   "X",
   ")",
   "*",
   "(",
   "1",
   "-",
   "test_split",
   ")",
   ")",
   "]",
   ")",
   "y_train",
   "=",
   "np",
   ".",
   "array",
   "(",
   "labels",
   "[",
   ":",
   "int",
   "(",
   "len",
   "(",
   "X",
   ")",
   "*",
   "(",
   "1",
   "-",
   "test_split",
   ")",
   ")",
   "]",
   ")",
   "X_test",
   "=",
   "np",
   ".",
   "array",
   "(",
   "X",
   "[",
   "int",
   "(",
   "len",
   "(",
   "X",
   ")",
   "*",
   "(",
   "1",
   "-",
   "test_split",
   ")",
   ")",
   ":",
   "]",
   ")",
   "y_test",
   "=",
   "np",
   ".",
   "array",
   "(",
   "labels",
   "[",
   "int",
   "(",
   "len",
   "(",
   "X",
   ")",
   "*",
   "(",
   "1",
   "-",
   "test_split",
   ")",
   ")",
   ":",
   "]",
   ")",
   "return",
   "X_train",
   ",",
   "y_train",
   ",",
   "X_test",
   ",",
   "y_test"
  ]
 },
 {
  "idx": "maxmin-674",
  "nl_tokens": [
   "check",
   "the",
   "status",
   "of",
   "the",
   "network",
   "and",
   "the",
   "peers"
  ],
  "pl_tokens": [
   "def",
   "status",
   "(",
   "self",
   ")",
   ":",
   "peer",
   "=",
   "random",
   ".",
   "choice",
   "(",
   "self",
   ".",
   "PEERS",
   ")",
   "formatted_peer",
   "=",
   "'http://{}:4001'",
   ".",
   "format",
   "(",
   "peer",
   ")",
   "peerdata",
   "=",
   "requests",
   ".",
   "get",
   "(",
   "url",
   "=",
   "formatted_peer",
   "+",
   "'/api/peers/'",
   ")",
   ".",
   "json",
   "(",
   ")",
   "[",
   "'peers'",
   "]",
   "peers_status",
   "=",
   "{",
   "}",
   "networkheight",
   "=",
   "<mask>",
   "(",
   "[",
   "x",
   "[",
   "'height'",
   "]",
   "for",
   "x",
   "in",
   "peerdata",
   "]",
   ")",
   "for",
   "i",
   "in",
   "peerdata",
   ":",
   "if",
   "'http://{}:4001'",
   ".",
   "format",
   "(",
   "i",
   "[",
   "'ip'",
   "]",
   ")",
   "in",
   "self",
   ".",
   "PEERS",
   ":",
   "peers_status",
   ".",
   "update",
   "(",
   "{",
   "i",
   "[",
   "'ip'",
   "]",
   ":",
   "{",
   "'height'",
   ":",
   "i",
   "[",
   "'height'",
   "]",
   ",",
   "'status'",
   ":",
   "i",
   "[",
   "'status'",
   "]",
   ",",
   "'version'",
   ":",
   "i",
   "[",
   "'version'",
   "]",
   ",",
   "'delay'",
   ":",
   "i",
   "[",
   "'delay'",
   "]",
   ",",
   "}",
   "}",
   ")",
   "return",
   "{",
   "'network_height'",
   ":",
   "networkheight",
   ",",
   "'peer_status'",
   ":",
   "peers_status",
   "}"
  ]
 },
 {
  "idx": "maxmin-675",
  "nl_tokens": [
   "np",
   ".",
   "dot",
   "(",
   "m",
   "m",
   ".",
   "T",
   ")",
   "with",
   "low",
   "mem",
   "usage",
   "by",
   "doing",
   "it",
   "in",
   "small",
   "steps"
  ],
  "pl_tokens": [
   "def",
   "low_mem_sq",
   "(",
   "m",
   ",",
   "step",
   "=",
   "100000",
   ")",
   ":",
   "if",
   "not",
   "m",
   ".",
   "flags",
   ".",
   "c_contiguous",
   ":",
   "raise",
   "ValueError",
   "(",
   "'m must be C ordered for this to work with less mem.'",
   ")",
   "# -- can make this even faster with pre-allocating arrays, but not worth it",
   "# right now",
   "# mmt = np.zeros([m.shape[0], m.shape[0]])  #6us",
   "# mt_tmp = np.zeros([step, m.shape[0]])",
   "# for a in range(0, m.shape[1], step):",
   "# mx = min(a+step, m.shape[1])",
   "# mt_tmp[:mx-a,:] = m.T[a:mx]",
   "# # np.dot(m_tmp, m.T, out=mmt[a:mx])",
   "# # np.dot(m, m[a:mx].T, out=mmt[:, a:mx])",
   "# np.dot(m[:,a:mx], mt_tmp[:mx], out=mmt)",
   "# return mmt",
   "mmt",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "[",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "]",
   ")",
   "#6us",
   "# m_tmp = np.zeros([step, m.shape[1]])",
   "for",
   "a",
   "in",
   "range",
   "(",
   "0",
   ",",
   "m",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "step",
   ")",
   ":",
   "mx",
   "=",
   "<mask>",
   "(",
   "a",
   "+",
   "step",
   ",",
   "m",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "# m_tmp[:] = m[a:mx]",
   "# np.dot(m_tmp, m.T, out=mmt[a:mx])",
   "mmt",
   "[",
   ":",
   ",",
   "a",
   ":",
   "mx",
   "]",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "m",
   ",",
   "m",
   "[",
   "a",
   ":",
   "mx",
   "]",
   ".",
   "T",
   ")",
   "return",
   "mmt"
  ]
 },
 {
  "idx": "maxmin-676",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "process",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "__ccore",
   "is",
   "True",
   ":",
   "ccore_metric",
   "=",
   "metric_wrapper",
   ".",
   "create_instance",
   "(",
   "self",
   ".",
   "__metric",
   ")",
   "self",
   ".",
   "__clusters",
   ",",
   "self",
   ".",
   "__medoid_indexes",
   "=",
   "wrapper",
   ".",
   "kmedoids",
   "(",
   "self",
   ".",
   "__pointer_data",
   ",",
   "self",
   ".",
   "__medoid_indexes",
   ",",
   "self",
   ".",
   "__tolerance",
   ",",
   "self",
   ".",
   "__itermax",
   ",",
   "ccore_metric",
   ".",
   "get_pointer",
   "(",
   ")",
   ",",
   "self",
   ".",
   "__data_type",
   ")",
   "else",
   ":",
   "changes",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "iterations",
   "=",
   "0",
   "while",
   "changes",
   ">",
   "self",
   ".",
   "__tolerance",
   "and",
   "iterations",
   "<",
   "self",
   ".",
   "__itermax",
   ":",
   "self",
   ".",
   "__clusters",
   "=",
   "self",
   ".",
   "__update_clusters",
   "(",
   ")",
   "update_medoid_indexes",
   "=",
   "self",
   ".",
   "__update_medoids",
   "(",
   ")",
   "changes",
   "=",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "__distance_calculator",
   "(",
   "self",
   ".",
   "__medoid_indexes",
   "[",
   "index",
   "]",
   ",",
   "update_medoid_indexes",
   "[",
   "index",
   "]",
   ")",
   "for",
   "index",
   "in",
   "range",
   "(",
   "len",
   "(",
   "update_medoid_indexes",
   ")",
   ")",
   "]",
   ")",
   "self",
   ".",
   "__medoid_indexes",
   "=",
   "update_medoid_indexes",
   "iterations",
   "+=",
   "1",
   "return",
   "self"
  ]
 },
 {
  "idx": "maxmin-677",
  "nl_tokens": [
   "Generate",
   "the",
   "correct",
   "function",
   "for",
   "a",
   "struct",
   "signature",
   "."
  ],
  "pl_tokens": [
   "def",
   "_handle_struct",
   "(",
   "toks",
   ")",
   ":",
   "subtrees",
   "=",
   "toks",
   "[",
   "1",
   ":",
   "-",
   "1",
   "]",
   "signature",
   "=",
   "''",
   ".",
   "join",
   "(",
   "s",
   "for",
   "(",
   "_",
   ",",
   "s",
   ")",
   "in",
   "subtrees",
   ")",
   "funcs",
   "=",
   "[",
   "f",
   "for",
   "(",
   "f",
   ",",
   "_",
   ")",
   "in",
   "subtrees",
   "]",
   "def",
   "the_func",
   "(",
   "a_list",
   ",",
   "variant",
   "=",
   "0",
   ")",
   ":",
   "\"\"\"\n            Function for generating a Struct from a list.\n\n            :param a_list: the list to transform\n            :type a_list: list or tuple\n            :param int variant: variant index\n            :returns: a dbus Struct of transformed values and variant level\n            :rtype: Struct * int\n            :raises IntoDPValueError:\n            \"\"\"",
   "if",
   "isinstance",
   "(",
   "a_list",
   ",",
   "dict",
   ")",
   ":",
   "raise",
   "IntoDPValueError",
   "(",
   "a_list",
   ",",
   "\"a_list\"",
   ",",
   "\"must be a simple sequence, is a dict\"",
   ")",
   "if",
   "len",
   "(",
   "a_list",
   ")",
   "!=",
   "len",
   "(",
   "funcs",
   ")",
   ":",
   "raise",
   "IntoDPValueError",
   "(",
   "a_list",
   ",",
   "\"a_list\"",
   ",",
   "\"must have exactly %u items, has %u\"",
   "%",
   "(",
   "len",
   "(",
   "funcs",
   ")",
   ",",
   "len",
   "(",
   "a_list",
   ")",
   ")",
   ")",
   "elements",
   "=",
   "[",
   "f",
   "(",
   "x",
   ")",
   "for",
   "(",
   "f",
   ",",
   "x",
   ")",
   "in",
   "zip",
   "(",
   "funcs",
   ",",
   "a_list",
   ")",
   "]",
   "level",
   "=",
   "0",
   "if",
   "elements",
   "==",
   "[",
   "]",
   "else",
   "<mask>",
   "(",
   "x",
   "for",
   "(",
   "_",
   ",",
   "x",
   ")",
   "in",
   "elements",
   ")",
   "(",
   "obj_level",
   ",",
   "func_level",
   ")",
   "=",
   "_ToDbusXformer",
   ".",
   "_variant_levels",
   "(",
   "level",
   ",",
   "variant",
   ")",
   "return",
   "(",
   "dbus",
   ".",
   "types",
   ".",
   "Struct",
   "(",
   "(",
   "x",
   "for",
   "(",
   "x",
   ",",
   "_",
   ")",
   "in",
   "elements",
   ")",
   ",",
   "signature",
   "=",
   "signature",
   ",",
   "variant_level",
   "=",
   "obj_level",
   ")",
   ",",
   "func_level",
   ")",
   "return",
   "(",
   "the_func",
   ",",
   "'('",
   "+",
   "signature",
   "+",
   "')'",
   ")"
  ]
 },
 {
  "idx": "maxmin-678",
  "nl_tokens": [
   "Convert",
   "an",
   "RGB",
   "color",
   "representation",
   "to",
   "an",
   "HSV",
   "color",
   "representation",
   "."
  ],
  "pl_tokens": [
   "def",
   "rgb_to_hsv",
   "(",
   "rgb",
   ")",
   ":",
   "r",
   ",",
   "g",
   ",",
   "b",
   "=",
   "rgb",
   "[",
   "0",
   "]",
   "/",
   "255",
   ",",
   "rgb",
   "[",
   "1",
   "]",
   "/",
   "255",
   ",",
   "rgb",
   "[",
   "2",
   "]",
   "/",
   "255",
   "_min",
   "=",
   "<mask>",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   "_max",
   "=",
   "max",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   "v",
   "=",
   "_max",
   "delta",
   "=",
   "_max",
   "-",
   "_min",
   "if",
   "_max",
   "==",
   "0",
   ":",
   "return",
   "0",
   ",",
   "0",
   ",",
   "v",
   "s",
   "=",
   "delta",
   "/",
   "_max",
   "if",
   "delta",
   "==",
   "0",
   ":",
   "delta",
   "=",
   "1",
   "if",
   "r",
   "==",
   "_max",
   ":",
   "h",
   "=",
   "60",
   "*",
   "(",
   "(",
   "(",
   "g",
   "-",
   "b",
   ")",
   "/",
   "delta",
   ")",
   "%",
   "6",
   ")",
   "elif",
   "g",
   "==",
   "_max",
   ":",
   "h",
   "=",
   "60",
   "*",
   "(",
   "(",
   "(",
   "b",
   "-",
   "r",
   ")",
   "/",
   "delta",
   ")",
   "+",
   "2",
   ")",
   "else",
   ":",
   "h",
   "=",
   "60",
   "*",
   "(",
   "(",
   "(",
   "r",
   "-",
   "g",
   ")",
   "/",
   "delta",
   ")",
   "+",
   "4",
   ")",
   "return",
   "round",
   "(",
   "h",
   ",",
   "3",
   ")",
   ",",
   "round",
   "(",
   "s",
   ",",
   "3",
   ")",
   ",",
   "round",
   "(",
   "v",
   ",",
   "3",
   ")"
  ]
 },
 {
  "idx": "maxmin-679",
  "nl_tokens": [
   "Indent",
   "representation",
   "of",
   "a",
   "dict"
  ],
  "pl_tokens": [
   "def",
   "ppdict",
   "(",
   "dict_to_print",
   ",",
   "br",
   "=",
   "'\\n'",
   ",",
   "html",
   "=",
   "False",
   ",",
   "key_align",
   "=",
   "'l'",
   ",",
   "sort_keys",
   "=",
   "True",
   ",",
   "key_preffix",
   "=",
   "''",
   ",",
   "key_suffix",
   "=",
   "''",
   ",",
   "value_prefix",
   "=",
   "''",
   ",",
   "value_suffix",
   "=",
   "''",
   ",",
   "left_margin",
   "=",
   "3",
   ",",
   "indent",
   "=",
   "2",
   ")",
   ":",
   "if",
   "dict_to_print",
   ":",
   "if",
   "sort_keys",
   ":",
   "dic",
   "=",
   "dict_to_print",
   ".",
   "copy",
   "(",
   ")",
   "keys",
   "=",
   "list",
   "(",
   "dic",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "keys",
   ".",
   "sort",
   "(",
   ")",
   "dict_to_print",
   "=",
   "OrderedDict",
   "(",
   ")",
   "for",
   "k",
   "in",
   "keys",
   ":",
   "dict_to_print",
   "[",
   "k",
   "]",
   "=",
   "dic",
   "[",
   "k",
   "]",
   "tmp",
   "=",
   "[",
   "'{'",
   "]",
   "ks",
   "=",
   "[",
   "type",
   "(",
   "x",
   ")",
   "==",
   "str",
   "and",
   "\"'%s'\"",
   "%",
   "x",
   "or",
   "x",
   "for",
   "x",
   "in",
   "dict_to_print",
   ".",
   "keys",
   "(",
   ")",
   "]",
   "vs",
   "=",
   "[",
   "type",
   "(",
   "x",
   ")",
   "==",
   "str",
   "and",
   "\"'%s'\"",
   "%",
   "x",
   "or",
   "x",
   "for",
   "x",
   "in",
   "dict_to_print",
   ".",
   "values",
   "(",
   ")",
   "]",
   "max_key_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "str",
   "(",
   "x",
   ")",
   ")",
   "for",
   "x",
   "in",
   "ks",
   "]",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "ks",
   ")",
   ")",
   ":",
   "k",
   "=",
   "{",
   "1",
   ":",
   "str",
   "(",
   "ks",
   "[",
   "i",
   "]",
   ")",
   ".",
   "ljust",
   "(",
   "max_key_len",
   ")",
   ",",
   "key_align",
   "==",
   "'r'",
   ":",
   "str",
   "(",
   "ks",
   "[",
   "i",
   "]",
   ")",
   ".",
   "rjust",
   "(",
   "max_key_len",
   ")",
   "}",
   "[",
   "1",
   "]",
   "v",
   "=",
   "vs",
   "[",
   "i",
   "]",
   "tmp",
   ".",
   "append",
   "(",
   "' '",
   "*",
   "indent",
   "+",
   "'{}{}{}:{}{}{},'",
   ".",
   "format",
   "(",
   "key_preffix",
   ",",
   "k",
   ",",
   "key_suffix",
   ",",
   "value_prefix",
   ",",
   "v",
   ",",
   "value_suffix",
   ")",
   ")",
   "tmp",
   "[",
   "-",
   "1",
   "]",
   "=",
   "tmp",
   "[",
   "-",
   "1",
   "]",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# remove the ',' in the last item",
   "tmp",
   ".",
   "append",
   "(",
   "'}'",
   ")",
   "if",
   "left_margin",
   ":",
   "tmp",
   "=",
   "[",
   "' '",
   "*",
   "left_margin",
   "+",
   "x",
   "for",
   "x",
   "in",
   "tmp",
   "]",
   "if",
   "html",
   ":",
   "return",
   "'<code>{}</code>'",
   ".",
   "format",
   "(",
   "br",
   ".",
   "join",
   "(",
   "tmp",
   ")",
   ".",
   "replace",
   "(",
   "' '",
   ",",
   "'&nbsp;'",
   ")",
   ")",
   "else",
   ":",
   "return",
   "br",
   ".",
   "join",
   "(",
   "tmp",
   ")",
   "else",
   ":",
   "return",
   "'{}'"
  ]
 },
 {
  "idx": "maxmin-680",
  "nl_tokens": [
   "Orders",
   "images",
   "from",
   "GBDX",
   "."
  ],
  "pl_tokens": [
   "def",
   "order",
   "(",
   "self",
   ",",
   "image_catalog_ids",
   ",",
   "batch_size",
   "=",
   "100",
   ",",
   "callback",
   "=",
   "None",
   ")",
   ":",
   "def",
   "_order_single_batch",
   "(",
   "url_",
   ",",
   "ids",
   ",",
   "results_list",
   ")",
   ":",
   "data",
   "=",
   "json",
   ".",
   "dumps",
   "(",
   "ids",
   ")",
   "if",
   "callback",
   "is",
   "None",
   "else",
   "json",
   ".",
   "dumps",
   "(",
   "{",
   "\"acquisitionIds\"",
   ":",
   "ids",
   ",",
   "\"callback\"",
   ":",
   "callback",
   "}",
   ")",
   "r",
   "=",
   "self",
   ".",
   "gbdx_connection",
   ".",
   "post",
   "(",
   "url_",
   ",",
   "data",
   "=",
   "data",
   ")",
   "r",
   ".",
   "raise_for_status",
   "(",
   ")",
   "order_id",
   "=",
   "r",
   ".",
   "json",
   "(",
   ")",
   ".",
   "get",
   "(",
   "\"order_id\"",
   ")",
   "if",
   "order_id",
   ":",
   "results_list",
   ".",
   "append",
   "(",
   "order_id",
   ")",
   "self",
   ".",
   "logger",
   ".",
   "debug",
   "(",
   "'Place order'",
   ")",
   "url",
   "=",
   "(",
   "'%s/order'",
   "if",
   "callback",
   "is",
   "None",
   "else",
   "'%s/ordercb'",
   ")",
   "%",
   "self",
   ".",
   "base_url",
   "batch_size",
   "=",
   "<mask>",
   "(",
   "100",
   ",",
   "batch_size",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "image_catalog_ids",
   ",",
   "list",
   ")",
   ":",
   "image_catalog_ids",
   "=",
   "[",
   "image_catalog_ids",
   "]",
   "sanitized_ids",
   "=",
   "list",
   "(",
   "set",
   "(",
   "(",
   "id",
   "for",
   "id",
   "in",
   "(",
   "_id",
   ".",
   "strip",
   "(",
   ")",
   "for",
   "_id",
   "in",
   "image_catalog_ids",
   ")",
   "if",
   "id",
   ")",
   ")",
   ")",
   "res",
   "=",
   "[",
   "]",
   "# Use itertool batch recipe",
   "acq_ids_by_batch",
   "=",
   "zip",
   "(",
   "*",
   "(",
   "[",
   "iter",
   "(",
   "sanitized_ids",
   ")",
   "]",
   "*",
   "batch_size",
   ")",
   ")",
   "for",
   "ids_batch",
   "in",
   "acq_ids_by_batch",
   ":",
   "_order_single_batch",
   "(",
   "url",
   ",",
   "ids_batch",
   ",",
   "res",
   ")",
   "# Order reminder",
   "remain_count",
   "=",
   "len",
   "(",
   "sanitized_ids",
   ")",
   "%",
   "batch_size",
   "if",
   "remain_count",
   ">",
   "0",
   ":",
   "_order_single_batch",
   "(",
   "url",
   ",",
   "sanitized_ids",
   "[",
   "-",
   "remain_count",
   ":",
   "]",
   ",",
   "res",
   ")",
   "if",
   "len",
   "(",
   "res",
   ")",
   "==",
   "1",
   ":",
   "return",
   "res",
   "[",
   "0",
   "]",
   "elif",
   "len",
   "(",
   "res",
   ")",
   ">",
   "1",
   ":",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-681",
  "nl_tokens": [
   "Save",
   "multiple",
   "images",
   "into",
   "one",
   "single",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "save_images",
   "(",
   "images",
   ",",
   "size",
   ",",
   "image_path",
   "=",
   "'_temp.png'",
   ")",
   ":",
   "if",
   "len",
   "(",
   "images",
   ".",
   "shape",
   ")",
   "==",
   "3",
   ":",
   "# Greyscale [batch, h, w] --> [batch, h, w, 1]",
   "images",
   "=",
   "images",
   "[",
   ":",
   ",",
   ":",
   ",",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "def",
   "merge",
   "(",
   "images",
   ",",
   "size",
   ")",
   ":",
   "h",
   ",",
   "w",
   "=",
   "images",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "images",
   ".",
   "shape",
   "[",
   "2",
   "]",
   "img",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "h",
   "*",
   "size",
   "[",
   "0",
   "]",
   ",",
   "w",
   "*",
   "size",
   "[",
   "1",
   "]",
   ",",
   "3",
   ")",
   ",",
   "dtype",
   "=",
   "images",
   ".",
   "dtype",
   ")",
   "for",
   "idx",
   ",",
   "image",
   "in",
   "enumerate",
   "(",
   "images",
   ")",
   ":",
   "i",
   "=",
   "idx",
   "%",
   "size",
   "[",
   "1",
   "]",
   "j",
   "=",
   "idx",
   "//",
   "size",
   "[",
   "1",
   "]",
   "img",
   "[",
   "j",
   "*",
   "h",
   ":",
   "j",
   "*",
   "h",
   "+",
   "h",
   ",",
   "i",
   "*",
   "w",
   ":",
   "i",
   "*",
   "w",
   "+",
   "w",
   ",",
   ":",
   "]",
   "=",
   "image",
   "return",
   "img",
   "def",
   "imsave",
   "(",
   "images",
   ",",
   "size",
   ",",
   "path",
   ")",
   ":",
   "if",
   "np",
   ".",
   "<mask>",
   "(",
   "images",
   ")",
   "<=",
   "1",
   "and",
   "(",
   "-",
   "1",
   "<=",
   "np",
   ".",
   "min",
   "(",
   "images",
   ")",
   "<",
   "0",
   ")",
   ":",
   "images",
   "=",
   "(",
   "(",
   "images",
   "+",
   "1",
   ")",
   "*",
   "127.5",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "elif",
   "np",
   ".",
   "max",
   "(",
   "images",
   ")",
   "<=",
   "1",
   "and",
   "np",
   ".",
   "min",
   "(",
   "images",
   ")",
   ">=",
   "0",
   ":",
   "images",
   "=",
   "(",
   "images",
   "*",
   "255",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "return",
   "imageio",
   ".",
   "imwrite",
   "(",
   "path",
   ",",
   "merge",
   "(",
   "images",
   ",",
   "size",
   ")",
   ")",
   "if",
   "len",
   "(",
   "images",
   ")",
   ">",
   "size",
   "[",
   "0",
   "]",
   "*",
   "size",
   "[",
   "1",
   "]",
   ":",
   "raise",
   "AssertionError",
   "(",
   "\"number of images should be equal or less than size[0] * size[1] {}\"",
   ".",
   "format",
   "(",
   "len",
   "(",
   "images",
   ")",
   ")",
   ")",
   "return",
   "imsave",
   "(",
   "images",
   ",",
   "size",
   ",",
   "image_path",
   ")"
  ]
 },
 {
  "idx": "maxmin-682",
  "nl_tokens": [
   "Override",
   "of",
   "getStats",
   "()",
   "in",
   "BaseStatsCollector"
  ],
  "pl_tokens": [
   "def",
   "getStats",
   "(",
   "self",
   ",",
   "stats",
   ")",
   ":",
   "BaseStatsCollector",
   ".",
   "getStats",
   "(",
   "self",
   ",",
   "stats",
   ")",
   "sortedNumberList",
   "=",
   "sorted",
   "(",
   "self",
   ".",
   "valueList",
   ")",
   "listLength",
   "=",
   "len",
   "(",
   "sortedNumberList",
   ")",
   "<mask>",
   "=",
   "sortedNumberList",
   "[",
   "0",
   "]",
   "max",
   "=",
   "sortedNumberList",
   "[",
   "-",
   "1",
   "]",
   "mean",
   "=",
   "numpy",
   ".",
   "mean",
   "(",
   "self",
   ".",
   "valueList",
   ")",
   "median",
   "=",
   "sortedNumberList",
   "[",
   "int",
   "(",
   "0.5",
   "*",
   "listLength",
   ")",
   "]",
   "percentile1st",
   "=",
   "sortedNumberList",
   "[",
   "int",
   "(",
   "0.01",
   "*",
   "listLength",
   ")",
   "]",
   "percentile99th",
   "=",
   "sortedNumberList",
   "[",
   "int",
   "(",
   "0.99",
   "*",
   "listLength",
   ")",
   "]",
   "differenceList",
   "=",
   "[",
   "(",
   "cur",
   "-",
   "prev",
   ")",
   "for",
   "prev",
   ",",
   "cur",
   "in",
   "itertools",
   ".",
   "izip",
   "(",
   "list",
   "(",
   "self",
   ".",
   "valueSet",
   ")",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "list",
   "(",
   "self",
   ".",
   "valueSet",
   ")",
   "[",
   "1",
   ":",
   "]",
   ")",
   "]",
   "if",
   "min",
   ">",
   "max",
   ":",
   "print",
   "self",
   ".",
   "fieldname",
   ",",
   "min",
   ",",
   "max",
   ",",
   "'-----'",
   "meanResolution",
   "=",
   "numpy",
   ".",
   "mean",
   "(",
   "differenceList",
   ")",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'min'",
   "]",
   "=",
   "min",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'max'",
   "]",
   "=",
   "max",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'mean'",
   "]",
   "=",
   "mean",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'median'",
   "]",
   "=",
   "median",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'percentile1st'",
   "]",
   "=",
   "percentile1st",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'percentile99th'",
   "]",
   "=",
   "percentile99th",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'meanResolution'",
   "]",
   "=",
   "meanResolution",
   "# TODO: Right now, always pass the data along.",
   "# This is used for data-dependent encoders.",
   "passData",
   "=",
   "True",
   "if",
   "passData",
   ":",
   "stats",
   "[",
   "self",
   ".",
   "fieldname",
   "]",
   "[",
   "'data'",
   "]",
   "=",
   "self",
   ".",
   "valueList",
   "if",
   "VERBOSITY",
   ">",
   "2",
   ":",
   "print",
   "'--'",
   "print",
   "\"Statistics:\"",
   "print",
   "\"min:\"",
   ",",
   "min",
   "print",
   "\"max:\"",
   ",",
   "max",
   "print",
   "\"mean:\"",
   ",",
   "mean",
   "print",
   "\"median:\"",
   ",",
   "median",
   "print",
   "\"1st percentile :\"",
   ",",
   "percentile1st",
   "print",
   "\"99th percentile:\"",
   ",",
   "percentile99th",
   "print",
   "'--'",
   "print",
   "\"Resolution:\"",
   "print",
   "\"Mean Resolution:\"",
   ",",
   "meanResolution",
   "if",
   "VERBOSITY",
   ">",
   "3",
   ":",
   "print",
   "'--'",
   "print",
   "\"Histogram:\"",
   "counts",
   ",",
   "bins",
   "=",
   "numpy",
   ".",
   "histogram",
   "(",
   "self",
   ".",
   "valueList",
   ",",
   "new",
   "=",
   "True",
   ")",
   "print",
   "\"Counts:\"",
   ",",
   "counts",
   ".",
   "tolist",
   "(",
   ")",
   "print",
   "\"Bins:\"",
   ",",
   "bins",
   ".",
   "tolist",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-683",
  "nl_tokens": [
   "Return",
   "the",
   "normalized",
   "Hamming",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "diff_lens",
   "=",
   "True",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "return",
   "self",
   ".",
   "dist_abs",
   "(",
   "src",
   ",",
   "tar",
   ",",
   "diff_lens",
   ")",
   "/",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-684",
  "nl_tokens": [
   "Create",
   "a",
   "mosaic",
   "from",
   "tiles",
   ".",
   "Tiles",
   "must",
   "be",
   "connected",
   "(",
   "also",
   "possible",
   "over",
   "Antimeridian",
   ")",
   "otherwise",
   "strange",
   "things",
   "can",
   "happen!"
  ],
  "pl_tokens": [
   "def",
   "create_mosaic",
   "(",
   "tiles",
   ",",
   "nodata",
   "=",
   "0",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "tiles",
   ",",
   "GeneratorType",
   ")",
   ":",
   "tiles",
   "=",
   "list",
   "(",
   "tiles",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "tiles",
   ",",
   "list",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"tiles must be either a list or generator\"",
   ")",
   "if",
   "not",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "pair",
   ",",
   "tuple",
   ")",
   "for",
   "pair",
   "in",
   "tiles",
   "]",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"tiles items must be tuples\"",
   ")",
   "if",
   "not",
   "all",
   "(",
   "[",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "tile",
   ",",
   "BufferedTile",
   ")",
   ",",
   "isinstance",
   "(",
   "data",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "]",
   ")",
   "for",
   "tile",
   ",",
   "data",
   "in",
   "tiles",
   "]",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"tuples must be pairs of BufferedTile and array\"",
   ")",
   "if",
   "len",
   "(",
   "tiles",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"tiles list is empty\"",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"create mosaic from %s tile(s)\"",
   ",",
   "len",
   "(",
   "tiles",
   ")",
   ")",
   "# quick return if there is just one tile",
   "if",
   "len",
   "(",
   "tiles",
   ")",
   "==",
   "1",
   ":",
   "tile",
   ",",
   "data",
   "=",
   "tiles",
   "[",
   "0",
   "]",
   "return",
   "ReferencedRaster",
   "(",
   "data",
   "=",
   "data",
   ",",
   "affine",
   "=",
   "tile",
   ".",
   "affine",
   ",",
   "bounds",
   "=",
   "tile",
   ".",
   "bounds",
   ",",
   "crs",
   "=",
   "tile",
   ".",
   "crs",
   ")",
   "# assert all tiles have same properties",
   "pyramid",
   ",",
   "resolution",
   ",",
   "dtype",
   "=",
   "_get_tiles_properties",
   "(",
   "tiles",
   ")",
   "# just handle antimeridian on global pyramid types",
   "shift",
   "=",
   "_shift_required",
   "(",
   "tiles",
   ")",
   "# determine mosaic shape and reference",
   "m_left",
   ",",
   "m_bottom",
   ",",
   "m_right",
   ",",
   "m_top",
   "=",
   "None",
   ",",
   "None",
   ",",
   "None",
   ",",
   "None",
   "for",
   "tile",
   ",",
   "data",
   "in",
   "tiles",
   ":",
   "num_bands",
   "=",
   "data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "if",
   "data",
   ".",
   "ndim",
   ">",
   "2",
   "else",
   "1",
   "left",
   ",",
   "bottom",
   ",",
   "right",
   ",",
   "top",
   "=",
   "tile",
   ".",
   "bounds",
   "if",
   "shift",
   ":",
   "# shift by half of the grid width",
   "left",
   "+=",
   "pyramid",
   ".",
   "x_size",
   "/",
   "2",
   "right",
   "+=",
   "pyramid",
   ".",
   "x_size",
   "/",
   "2",
   "# if tile is now shifted outside pyramid bounds, move within",
   "if",
   "right",
   ">",
   "pyramid",
   ".",
   "right",
   ":",
   "right",
   "-=",
   "pyramid",
   ".",
   "x_size",
   "left",
   "-=",
   "pyramid",
   ".",
   "x_size",
   "m_left",
   "=",
   "<mask>",
   "(",
   "[",
   "left",
   ",",
   "m_left",
   "]",
   ")",
   "if",
   "m_left",
   "is",
   "not",
   "None",
   "else",
   "left",
   "m_bottom",
   "=",
   "min",
   "(",
   "[",
   "bottom",
   ",",
   "m_bottom",
   "]",
   ")",
   "if",
   "m_bottom",
   "is",
   "not",
   "None",
   "else",
   "bottom",
   "m_right",
   "=",
   "max",
   "(",
   "[",
   "right",
   ",",
   "m_right",
   "]",
   ")",
   "if",
   "m_right",
   "is",
   "not",
   "None",
   "else",
   "right",
   "m_top",
   "=",
   "max",
   "(",
   "[",
   "top",
   ",",
   "m_top",
   "]",
   ")",
   "if",
   "m_top",
   "is",
   "not",
   "None",
   "else",
   "top",
   "height",
   "=",
   "int",
   "(",
   "round",
   "(",
   "(",
   "m_top",
   "-",
   "m_bottom",
   ")",
   "/",
   "resolution",
   ")",
   ")",
   "width",
   "=",
   "int",
   "(",
   "round",
   "(",
   "(",
   "m_right",
   "-",
   "m_left",
   ")",
   "/",
   "resolution",
   ")",
   ")",
   "# initialize empty mosaic",
   "mosaic",
   "=",
   "ma",
   ".",
   "MaskedArray",
   "(",
   "data",
   "=",
   "np",
   ".",
   "full",
   "(",
   "(",
   "num_bands",
   ",",
   "height",
   ",",
   "width",
   ")",
   ",",
   "dtype",
   "=",
   "dtype",
   ",",
   "fill_value",
   "=",
   "nodata",
   ")",
   ",",
   "mask",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "(",
   "num_bands",
   ",",
   "height",
   ",",
   "width",
   ")",
   ")",
   ")",
   "# create Affine",
   "affine",
   "=",
   "Affine",
   "(",
   "resolution",
   ",",
   "0",
   ",",
   "m_left",
   ",",
   "0",
   ",",
   "-",
   "resolution",
   ",",
   "m_top",
   ")",
   "# fill mosaic array with tile data",
   "for",
   "tile",
   ",",
   "data",
   "in",
   "tiles",
   ":",
   "data",
   "=",
   "prepare_array",
   "(",
   "data",
   ",",
   "nodata",
   "=",
   "nodata",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "t_left",
   ",",
   "t_bottom",
   ",",
   "t_right",
   ",",
   "t_top",
   "=",
   "tile",
   ".",
   "bounds",
   "if",
   "shift",
   ":",
   "t_left",
   "+=",
   "pyramid",
   ".",
   "x_size",
   "/",
   "2",
   "t_right",
   "+=",
   "pyramid",
   ".",
   "x_size",
   "/",
   "2",
   "# if tile is now shifted outside pyramid bounds, move within",
   "if",
   "t_right",
   ">",
   "pyramid",
   ".",
   "right",
   ":",
   "t_right",
   "-=",
   "pyramid",
   ".",
   "x_size",
   "t_left",
   "-=",
   "pyramid",
   ".",
   "x_size",
   "minrow",
   ",",
   "maxrow",
   ",",
   "mincol",
   ",",
   "maxcol",
   "=",
   "bounds_to_ranges",
   "(",
   "out_bounds",
   "=",
   "(",
   "t_left",
   ",",
   "t_bottom",
   ",",
   "t_right",
   ",",
   "t_top",
   ")",
   ",",
   "in_affine",
   "=",
   "affine",
   ",",
   "in_shape",
   "=",
   "(",
   "height",
   ",",
   "width",
   ")",
   ")",
   "mosaic",
   "[",
   ":",
   ",",
   "minrow",
   ":",
   "maxrow",
   ",",
   "mincol",
   ":",
   "maxcol",
   "]",
   "=",
   "data",
   "mosaic",
   ".",
   "mask",
   "[",
   ":",
   ",",
   "minrow",
   ":",
   "maxrow",
   ",",
   "mincol",
   ":",
   "maxcol",
   "]",
   "=",
   "data",
   ".",
   "mask",
   "if",
   "shift",
   ":",
   "# shift back output mosaic",
   "affine",
   "=",
   "Affine",
   "(",
   "resolution",
   ",",
   "0",
   ",",
   "m_left",
   "-",
   "pyramid",
   ".",
   "x_size",
   "/",
   "2",
   ",",
   "0",
   ",",
   "-",
   "resolution",
   ",",
   "m_top",
   ")",
   "return",
   "ReferencedRaster",
   "(",
   "data",
   "=",
   "mosaic",
   ",",
   "affine",
   "=",
   "affine",
   ",",
   "bounds",
   "=",
   "Bounds",
   "(",
   "m_left",
   ",",
   "m_bottom",
   ",",
   "m_right",
   ",",
   "m_top",
   ")",
   ",",
   "crs",
   "=",
   "tile",
   ".",
   "crs",
   ")"
  ]
 },
 {
  "idx": "maxmin-685",
  "nl_tokens": [
   "Recurse",
   "through",
   "the",
   "system",
   ".",
   "When",
   "a",
   "segment",
   "is",
   "drawn",
   "the",
   "LSsytem",
   ".",
   "segment",
   "()",
   "method",
   "will",
   "be",
   "called",
   ".",
   "You",
   "can",
   "customize",
   "this",
   "method",
   "to",
   "create",
   "your",
   "own",
   "visualizations",
   ".",
   "It",
   "takes",
   "an",
   "optional",
   "time",
   "parameter",
   ".",
   "If",
   "you",
   "divide",
   "this",
   "parameter",
   "by",
   "LSsytem",
   ".",
   "duration",
   "()",
   "you",
   "get",
   "a",
   "number",
   "between",
   "0",
   ".",
   "0",
   "and",
   "1",
   ".",
   "0",
   "you",
   "can",
   "use",
   "as",
   "an",
   "alpha",
   "value",
   "for",
   "example",
   ".",
   "The",
   "method",
   "also",
   "has",
   "an",
   "id",
   "parameter",
   "which",
   "is",
   "a",
   "unique",
   "number",
   "between",
   "0",
   "and",
   "LSystem",
   ".",
   "segments",
   "."
  ],
  "pl_tokens": [
   "def",
   "_grow",
   "(",
   "self",
   ",",
   "generation",
   ",",
   "rule",
   ",",
   "angle",
   ",",
   "length",
   ",",
   "time",
   "=",
   "maxint",
   ",",
   "draw",
   "=",
   "True",
   ")",
   ":",
   "if",
   "generation",
   "==",
   "0",
   ":",
   "# We are at the bottom of the system so now we now the total time needed.",
   "self",
   ".",
   "_duration",
   "=",
   "1",
   "+",
   "maxint",
   "-",
   "time",
   "if",
   "length",
   "<=",
   "self",
   ".",
   "threshold",
   ":",
   "# Segment length has fallen below the threshold, stop recursing.",
   "self",
   ".",
   "_duration",
   "=",
   "1",
   "+",
   "maxint",
   "-",
   "time",
   "return",
   "if",
   "rule",
   "in",
   "self",
   ".",
   "commands",
   ":",
   "# Custom command symbols:",
   "# If the rule is a key in the LSsytem.commands dictionary,",
   "# execute its value which is a function taking 6 parameters:",
   "# lsystem, generation, rule, angle, length and time.",
   "self",
   ".",
   "commands",
   "[",
   "rule",
   "]",
   "(",
   "self",
   ",",
   "generation",
   ",",
   "rule",
   ",",
   "angle",
   ",",
   "length",
   ",",
   "time",
   ")",
   "if",
   "draw",
   ":",
   "# Standard command symbols:",
   "# f signifies a move,",
   "# + and - rotate either left or right, | rotates 180 degrees,",
   "# [ and ] are for push() and pop(), e.g. offshoot branches,",
   "# < and > decrease or increases the segment length,",
   "# ( and ) decrease or increases the rotation angle.",
   "if",
   "rule",
   "==",
   "\"f\"",
   ":",
   "_ctx",
   ".",
   "translate",
   "(",
   "0",
   ",",
   "-",
   "<mask>",
   "(",
   "length",
   ",",
   "length",
   "*",
   "time",
   ")",
   ")",
   "elif",
   "rule",
   "==",
   "\"-\"",
   ":",
   "_ctx",
   ".",
   "rotate",
   "(",
   "max",
   "(",
   "-",
   "angle",
   ",",
   "-",
   "angle",
   "*",
   "time",
   ")",
   ")",
   "elif",
   "rule",
   "==",
   "\"+\"",
   ":",
   "_ctx",
   ".",
   "rotate",
   "(",
   "min",
   "(",
   "+",
   "angle",
   ",",
   "+",
   "angle",
   "*",
   "time",
   ")",
   ")",
   "elif",
   "rule",
   "==",
   "\"|\"",
   ":",
   "_ctx",
   ".",
   "rotate",
   "(",
   "180",
   ")",
   "elif",
   "rule",
   "==",
   "\"[\"",
   ":",
   "_ctx",
   ".",
   "push",
   "(",
   ")",
   "elif",
   "rule",
   "==",
   "\"]\"",
   ":",
   "_ctx",
   ".",
   "pop",
   "(",
   ")",
   "if",
   "rule",
   "in",
   "self",
   ".",
   "rules",
   "and",
   "generation",
   ">",
   "0",
   "and",
   "time",
   ">",
   "0",
   ":",
   "# Recursion:",
   "# Occurs when there is enough \"life\" (i.e. generation or time).",
   "# Generation is decreased and segment length scaled down.",
   "# Also, F symbols in the rule have a cost that depletes time.",
   "for",
   "cmd",
   "in",
   "self",
   ".",
   "rules",
   "[",
   "rule",
   "]",
   ":",
   "# Modification command symbols:",
   "if",
   "cmd",
   "==",
   "\"F\"",
   ":",
   "time",
   "-=",
   "self",
   ".",
   "cost",
   "elif",
   "cmd",
   "==",
   "\"!\"",
   ":",
   "angle",
   "=",
   "-",
   "angle",
   "elif",
   "cmd",
   "==",
   "\"(\"",
   ":",
   "angle",
   "*=",
   "1.1",
   "elif",
   "cmd",
   "==",
   "\")\"",
   ":",
   "angle",
   "*=",
   "0.9",
   "elif",
   "cmd",
   "==",
   "\"<\"",
   ":",
   "length",
   "*=",
   "0.9",
   "elif",
   "cmd",
   "==",
   "\">\"",
   ":",
   "length",
   "*=",
   "1.1",
   "self",
   ".",
   "_grow",
   "(",
   "generation",
   "-",
   "1",
   ",",
   "cmd",
   ",",
   "angle",
   ",",
   "length",
   "*",
   "self",
   ".",
   "decrease",
   ",",
   "time",
   ",",
   "draw",
   ")",
   "elif",
   "rule",
   "==",
   "\"F\"",
   "or",
   "(",
   "rule",
   "in",
   "self",
   ".",
   "rules",
   "and",
   "self",
   ".",
   "rules",
   "[",
   "rule",
   "]",
   "==",
   "\"\"",
   ")",
   ":",
   "# Draw segment:",
   "# If the rule is an F symbol or empty (e.g. in Penrose tiles).",
   "# Segment length grows to its full size as time progresses.",
   "self",
   ".",
   "_segments",
   "+=",
   "1",
   "if",
   "draw",
   "and",
   "time",
   ">",
   "0",
   ":",
   "length",
   "=",
   "min",
   "(",
   "length",
   ",",
   "length",
   "*",
   "time",
   ")",
   "if",
   "self",
   ".",
   "_timed",
   ":",
   "self",
   ".",
   "segment",
   "(",
   "length",
   ",",
   "generation",
   ",",
   "time",
   ",",
   "id",
   "=",
   "self",
   ".",
   "_segments",
   ")",
   "else",
   ":",
   "self",
   ".",
   "segment",
   "(",
   "length",
   ",",
   "generation",
   ",",
   "None",
   ",",
   "id",
   "=",
   "self",
   ".",
   "_segments",
   ")",
   "_ctx",
   ".",
   "translate",
   "(",
   "0",
   ",",
   "-",
   "length",
   ")"
  ]
 },
 {
  "idx": "maxmin-686",
  "nl_tokens": [
   "return",
   "a",
   "frequency",
   "array",
   "from",
   "a",
   "loci",
   "file",
   "for",
   "all",
   "loci",
   "with",
   "taxa",
   "from",
   "taxdict",
   "and",
   "min",
   "coverage",
   "from",
   "mindict",
   "."
  ],
  "pl_tokens": [
   "def",
   "_loci_to_arr",
   "(",
   "loci",
   ",",
   "taxdict",
   ",",
   "mindict",
   ")",
   ":",
   "## make the array (4 or 5) and a mask array to remove loci without cov",
   "nloci",
   "=",
   "len",
   "(",
   "loci",
   ")",
   "maxlen",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "np",
   ".",
   "array",
   "(",
   "[",
   "len",
   "(",
   "locus",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   "[",
   "0",
   "]",
   ")",
   "for",
   "locus",
   "in",
   "loci",
   "]",
   ")",
   ")",
   "keep",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "nloci",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "bool_",
   ")",
   "arr",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "nloci",
   ",",
   "4",
   ",",
   "maxlen",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   "## six rows b/c one for each p3, and for the fused p3 ancestor",
   "if",
   "len",
   "(",
   "taxdict",
   ")",
   "==",
   "5",
   ":",
   "arr",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "nloci",
   ",",
   "6",
   ",",
   "maxlen",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ")",
   "## if not mindict, make one that requires 1 in each taxon",
   "if",
   "isinstance",
   "(",
   "mindict",
   ",",
   "int",
   ")",
   ":",
   "mindict",
   "=",
   "{",
   "i",
   ":",
   "mindict",
   "for",
   "i",
   "in",
   "taxdict",
   "}",
   "elif",
   "isinstance",
   "(",
   "mindict",
   ",",
   "dict",
   ")",
   ":",
   "mindict",
   "=",
   "{",
   "i",
   ":",
   "mindict",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "taxdict",
   "}",
   "else",
   ":",
   "mindict",
   "=",
   "{",
   "i",
   ":",
   "1",
   "for",
   "i",
   "in",
   "taxdict",
   "}",
   "## raise error if names are not 'p[int]' ",
   "allowed_names",
   "=",
   "[",
   "'p1'",
   ",",
   "'p2'",
   ",",
   "'p3'",
   ",",
   "'p4'",
   ",",
   "'p5'",
   "]",
   "if",
   "any",
   "(",
   "[",
   "i",
   "not",
   "in",
   "allowed_names",
   "for",
   "i",
   "in",
   "taxdict",
   "]",
   ")",
   ":",
   "raise",
   "IPyradError",
   "(",
   "\"keys in taxdict must be named 'p1' through 'p4' or 'p5'\"",
   ")",
   "## parse key names",
   "keys",
   "=",
   "sorted",
   "(",
   "[",
   "i",
   "for",
   "i",
   "in",
   "taxdict",
   ".",
   "keys",
   "(",
   ")",
   "if",
   "i",
   "[",
   "0",
   "]",
   "==",
   "'p'",
   "]",
   ")",
   "outg",
   "=",
   "keys",
   "[",
   "-",
   "1",
   "]",
   "## grab seqs just for the good guys",
   "for",
   "loc",
   "in",
   "xrange",
   "(",
   "nloci",
   ")",
   ":",
   "## parse the locus",
   "lines",
   "=",
   "loci",
   "[",
   "loc",
   "]",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   "[",
   ":",
   "-",
   "1",
   "]",
   "names",
   "=",
   "[",
   "i",
   ".",
   "split",
   "(",
   ")",
   "[",
   "0",
   "]",
   "for",
   "i",
   "in",
   "lines",
   "]",
   "seqs",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "list",
   "(",
   "i",
   ".",
   "split",
   "(",
   ")",
   "[",
   "1",
   "]",
   ")",
   "for",
   "i",
   "in",
   "lines",
   "]",
   ")",
   "## check that names cover the taxdict (still need to check by site)",
   "covs",
   "=",
   "[",
   "sum",
   "(",
   "[",
   "j",
   "in",
   "names",
   "for",
   "j",
   "in",
   "taxdict",
   "[",
   "tax",
   "]",
   "]",
   ")",
   ">=",
   "mindict",
   "[",
   "tax",
   "]",
   "for",
   "tax",
   "in",
   "taxdict",
   "]",
   "## keep locus",
   "if",
   "all",
   "(",
   "covs",
   ")",
   ":",
   "keep",
   "[",
   "loc",
   "]",
   "=",
   "True",
   "## get the refseq",
   "refidx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "i",
   "in",
   "taxdict",
   "[",
   "outg",
   "]",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "[",
   "0",
   "]",
   "refseq",
   "=",
   "seqs",
   "[",
   "refidx",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "ancestral",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "reftrick",
   "(",
   "refseq",
   ",",
   "GETCONS2",
   ")",
   "[",
   ":",
   ",",
   "0",
   "]",
   "]",
   ")",
   "## freq of ref in outgroup",
   "iseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "refseq",
   ",",
   "GETCONS2",
   ")",
   "arr",
   "[",
   "loc",
   ",",
   "-",
   "1",
   ",",
   ":",
   "iseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "iseq",
   "## enter 4-taxon freqs",
   "if",
   "len",
   "(",
   "taxdict",
   ")",
   "==",
   "4",
   ":",
   "for",
   "tidx",
   ",",
   "key",
   "in",
   "enumerate",
   "(",
   "keys",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   ":",
   "## get idx of names in test tax",
   "nidx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "i",
   "in",
   "taxdict",
   "[",
   "key",
   "]",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "[",
   "0",
   "]",
   "sidx",
   "=",
   "seqs",
   "[",
   "nidx",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "## get freq of sidx",
   "iseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "sidx",
   ",",
   "GETCONS2",
   ")",
   "## fill it in ",
   "arr",
   "[",
   "loc",
   ",",
   "tidx",
   ",",
   ":",
   "iseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "iseq",
   "else",
   ":",
   "## entere p5; and fill it in",
   "iseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "refseq",
   ",",
   "GETCONS2",
   ")",
   "arr",
   "[",
   "loc",
   ",",
   "-",
   "1",
   ",",
   ":",
   "iseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "iseq",
   "## enter p1",
   "nidx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "i",
   "in",
   "taxdict",
   "[",
   "'p1'",
   "]",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "[",
   "0",
   "]",
   "sidx",
   "=",
   "seqs",
   "[",
   "nidx",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "iseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "sidx",
   ",",
   "GETCONS2",
   ")",
   "arr",
   "[",
   "loc",
   ",",
   "0",
   ",",
   ":",
   "iseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "iseq",
   "## enter p2",
   "nidx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "i",
   "in",
   "taxdict",
   "[",
   "'p2'",
   "]",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "[",
   "0",
   "]",
   "sidx",
   "=",
   "seqs",
   "[",
   "nidx",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "iseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "sidx",
   ",",
   "GETCONS2",
   ")",
   "arr",
   "[",
   "loc",
   ",",
   "1",
   ",",
   ":",
   "iseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "iseq",
   "## enter p3 with p4 masked, and p4 with p3 masked",
   "nidx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "i",
   "in",
   "taxdict",
   "[",
   "'p3'",
   "]",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "[",
   "0",
   "]",
   "nidy",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "i",
   "in",
   "taxdict",
   "[",
   "'p4'",
   "]",
   "for",
   "i",
   "in",
   "names",
   "]",
   ")",
   "[",
   "0",
   "]",
   "sidx",
   "=",
   "seqs",
   "[",
   "nidx",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "sidy",
   "=",
   "seqs",
   "[",
   "nidy",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "xseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "sidx",
   ",",
   "GETCONS2",
   ")",
   "yseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "sidy",
   ",",
   "GETCONS2",
   ")",
   "mask3",
   "=",
   "xseq",
   "!=",
   "0",
   "mask4",
   "=",
   "yseq",
   "!=",
   "0",
   "xseq",
   "[",
   "mask4",
   "]",
   "=",
   "0",
   "yseq",
   "[",
   "mask3",
   "]",
   "=",
   "0",
   "arr",
   "[",
   "loc",
   ",",
   "2",
   ",",
   ":",
   "xseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "xseq",
   "arr",
   "[",
   "loc",
   ",",
   "3",
   ",",
   ":",
   "yseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "yseq",
   "## enter p34 ",
   "nidx",
   "=",
   "nidx",
   ".",
   "tolist",
   "(",
   ")",
   "+",
   "nidy",
   ".",
   "tolist",
   "(",
   ")",
   "sidx",
   "=",
   "seqs",
   "[",
   "nidx",
   "]",
   ".",
   "view",
   "(",
   "np",
   ".",
   "uint8",
   ")",
   "iseq",
   "=",
   "_reffreq2",
   "(",
   "ancestral",
   ",",
   "sidx",
   ",",
   "GETCONS2",
   ")",
   "arr",
   "[",
   "loc",
   ",",
   "4",
   ",",
   ":",
   "iseq",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "]",
   "=",
   "iseq",
   "## size-down array to the number of loci that have taxa for the test",
   "arr",
   "=",
   "arr",
   "[",
   "keep",
   ",",
   ":",
   ",",
   ":",
   "]",
   "## size-down sites to ",
   "arr",
   "=",
   "masknulls",
   "(",
   "arr",
   ")",
   "return",
   "arr",
   ",",
   "keep"
  ]
 },
 {
  "idx": "maxmin-687",
  "nl_tokens": [
   "r",
   "Method",
   "to",
   "calculate",
   "molar",
   "volume",
   "of",
   "the",
   "vapor",
   "phase",
   "along",
   "the",
   "saturation",
   "line",
   ".",
   "Parameters",
   "----------",
   "T",
   ":",
   "float",
   "Temperature",
   "[",
   "K",
   "]"
  ],
  "pl_tokens": [
   "def",
   "V_g_sat",
   "(",
   "self",
   ",",
   "T",
   ")",
   ":",
   "Psat",
   "=",
   "self",
   ".",
   "Psat",
   "(",
   "T",
   ")",
   "a_alpha",
   "=",
   "self",
   ".",
   "a_alpha_and_derivatives",
   "(",
   "T",
   ",",
   "full",
   "=",
   "False",
   ")",
   "Vs",
   "=",
   "self",
   ".",
   "volume_solutions",
   "(",
   "T",
   ",",
   "Psat",
   ",",
   "self",
   ".",
   "b",
   ",",
   "self",
   ".",
   "delta",
   ",",
   "self",
   ".",
   "epsilon",
   ",",
   "a_alpha",
   ")",
   "# Assume we can safely take the Vmax as gas, Vmin as l on the saturation line",
   "return",
   "<mask>",
   "(",
   "[",
   "i",
   ".",
   "real",
   "for",
   "i",
   "in",
   "Vs",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-688",
  "nl_tokens": [
   "Compute",
   "the",
   "contribution",
   "map",
   "of",
   "a",
   "galaxy",
   "which",
   "represents",
   "the",
   "fraction",
   "of",
   "flux",
   "in",
   "each",
   "pixel",
   "that",
   "the",
   "\\",
   "galaxy",
   "is",
   "attributed",
   "to",
   "contain",
   "scaled",
   "to",
   "the",
   "*",
   "contribution_factor",
   "*",
   "hyper",
   "-",
   "parameter",
   "."
  ],
  "pl_tokens": [
   "def",
   "contributions_from_model_image_and_galaxy_image",
   "(",
   "self",
   ",",
   "model_image",
   ",",
   "galaxy_image",
   ",",
   "minimum_value",
   "=",
   "0.0",
   ")",
   ":",
   "contributions",
   "=",
   "np",
   ".",
   "divide",
   "(",
   "galaxy_image",
   ",",
   "np",
   ".",
   "add",
   "(",
   "model_image",
   ",",
   "self",
   ".",
   "contribution_factor",
   ")",
   ")",
   "contributions",
   "=",
   "np",
   ".",
   "divide",
   "(",
   "contributions",
   ",",
   "np",
   ".",
   "<mask>",
   "(",
   "contributions",
   ")",
   ")",
   "contributions",
   "[",
   "contributions",
   "<",
   "minimum_value",
   "]",
   "=",
   "0.0",
   "return",
   "contributions"
  ]
 },
 {
  "idx": "maxmin-689",
  "nl_tokens": [
   "Add",
   "a",
   "new",
   "field",
   "into",
   "the",
   "record",
   "."
  ],
  "pl_tokens": [
   "def",
   "record_add_field",
   "(",
   "rec",
   ",",
   "tag",
   ",",
   "ind1",
   "=",
   "' '",
   ",",
   "ind2",
   "=",
   "' '",
   ",",
   "controlfield_value",
   "=",
   "''",
   ",",
   "subfields",
   "=",
   "None",
   ",",
   "field_position_global",
   "=",
   "None",
   ",",
   "field_position_local",
   "=",
   "None",
   ")",
   ":",
   "error",
   "=",
   "_validate_record_field_positions_global",
   "(",
   "rec",
   ")",
   "if",
   "error",
   ":",
   "# FIXME one should write a message here",
   "pass",
   "# Clean the parameters.",
   "if",
   "subfields",
   "is",
   "None",
   ":",
   "subfields",
   "=",
   "[",
   "]",
   "ind1",
   ",",
   "ind2",
   "=",
   "_wash_indicators",
   "(",
   "ind1",
   ",",
   "ind2",
   ")",
   "if",
   "controlfield_value",
   "and",
   "(",
   "ind1",
   "!=",
   "' '",
   "or",
   "ind2",
   "!=",
   "' '",
   "or",
   "subfields",
   ")",
   ":",
   "return",
   "-",
   "1",
   "# Detect field number to be used for insertion:",
   "# Dictionaries for uniqueness.",
   "tag_field_positions_global",
   "=",
   "{",
   "}",
   ".",
   "fromkeys",
   "(",
   "[",
   "field",
   "[",
   "4",
   "]",
   "for",
   "field",
   "in",
   "rec",
   ".",
   "get",
   "(",
   "tag",
   ",",
   "[",
   "]",
   ")",
   "]",
   ")",
   "all_field_positions_global",
   "=",
   "{",
   "}",
   ".",
   "fromkeys",
   "(",
   "[",
   "field",
   "[",
   "4",
   "]",
   "for",
   "fields",
   "in",
   "rec",
   ".",
   "values",
   "(",
   ")",
   "for",
   "field",
   "in",
   "fields",
   "]",
   ")",
   "if",
   "field_position_global",
   "is",
   "None",
   "and",
   "field_position_local",
   "is",
   "None",
   ":",
   "# Let's determine the global field position of the new field.",
   "if",
   "tag",
   "in",
   "rec",
   ":",
   "try",
   ":",
   "field_position_global",
   "=",
   "<mask>",
   "(",
   "[",
   "field",
   "[",
   "4",
   "]",
   "for",
   "field",
   "in",
   "rec",
   "[",
   "tag",
   "]",
   "]",
   ")",
   "+",
   "1",
   "except",
   "IndexError",
   ":",
   "if",
   "tag_field_positions_global",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "tag_field_positions_global",
   ")",
   "+",
   "1",
   "elif",
   "all_field_positions_global",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "all_field_positions_global",
   ")",
   "+",
   "1",
   "else",
   ":",
   "field_position_global",
   "=",
   "1",
   "else",
   ":",
   "if",
   "tag",
   "in",
   "(",
   "'FMT'",
   ",",
   "'FFT'",
   ",",
   "'BDR'",
   ",",
   "'BDM'",
   ")",
   ":",
   "# Add the new tag to the end of the record.",
   "if",
   "tag_field_positions_global",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "tag_field_positions_global",
   ")",
   "+",
   "1",
   "elif",
   "all_field_positions_global",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "all_field_positions_global",
   ")",
   "+",
   "1",
   "else",
   ":",
   "field_position_global",
   "=",
   "1",
   "else",
   ":",
   "# Insert the tag in an ordered way by selecting the",
   "# right global field position.",
   "immediate_lower_tag",
   "=",
   "'000'",
   "for",
   "rec_tag",
   "in",
   "rec",
   ":",
   "if",
   "(",
   "tag",
   "not",
   "in",
   "(",
   "'FMT'",
   ",",
   "'FFT'",
   ",",
   "'BDR'",
   ",",
   "'BDM'",
   ")",
   "and",
   "rec",
   "[",
   "rec_tag",
   "]",
   "and",
   "immediate_lower_tag",
   "<",
   "rec_tag",
   "<",
   "tag",
   ")",
   ":",
   "immediate_lower_tag",
   "=",
   "rec_tag",
   "if",
   "immediate_lower_tag",
   "==",
   "'000'",
   ":",
   "field_position_global",
   "=",
   "1",
   "else",
   ":",
   "field_position_global",
   "=",
   "rec",
   "[",
   "immediate_lower_tag",
   "]",
   "[",
   "-",
   "1",
   "]",
   "[",
   "4",
   "]",
   "+",
   "1",
   "field_position_local",
   "=",
   "len",
   "(",
   "rec",
   ".",
   "get",
   "(",
   "tag",
   ",",
   "[",
   "]",
   ")",
   ")",
   "_shift_field_positions_global",
   "(",
   "rec",
   ",",
   "field_position_global",
   ",",
   "1",
   ")",
   "elif",
   "field_position_local",
   "is",
   "not",
   "None",
   ":",
   "if",
   "tag",
   "in",
   "rec",
   ":",
   "if",
   "field_position_local",
   ">=",
   "len",
   "(",
   "rec",
   "[",
   "tag",
   "]",
   ")",
   ":",
   "field_position_global",
   "=",
   "rec",
   "[",
   "tag",
   "]",
   "[",
   "-",
   "1",
   "]",
   "[",
   "4",
   "]",
   "+",
   "1",
   "else",
   ":",
   "field_position_global",
   "=",
   "rec",
   "[",
   "tag",
   "]",
   "[",
   "field_position_local",
   "]",
   "[",
   "4",
   "]",
   "_shift_field_positions_global",
   "(",
   "rec",
   ",",
   "field_position_global",
   ",",
   "1",
   ")",
   "else",
   ":",
   "if",
   "all_field_positions_global",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "all_field_positions_global",
   ")",
   "+",
   "1",
   "else",
   ":",
   "# Empty record.",
   "field_position_global",
   "=",
   "1",
   "elif",
   "field_position_global",
   "is",
   "not",
   "None",
   ":",
   "# If the user chose an existing global field position, shift all the",
   "# global field positions greater than the input global field position.",
   "if",
   "tag",
   "not",
   "in",
   "rec",
   ":",
   "if",
   "all_field_positions_global",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "all_field_positions_global",
   ")",
   "+",
   "1",
   "else",
   ":",
   "field_position_global",
   "=",
   "1",
   "field_position_local",
   "=",
   "0",
   "elif",
   "field_position_global",
   "<",
   "min",
   "(",
   "tag_field_positions_global",
   ")",
   ":",
   "field_position_global",
   "=",
   "min",
   "(",
   "tag_field_positions_global",
   ")",
   "_shift_field_positions_global",
   "(",
   "rec",
   ",",
   "min",
   "(",
   "tag_field_positions_global",
   ")",
   ",",
   "1",
   ")",
   "field_position_local",
   "=",
   "0",
   "elif",
   "field_position_global",
   ">",
   "max",
   "(",
   "tag_field_positions_global",
   ")",
   ":",
   "field_position_global",
   "=",
   "max",
   "(",
   "tag_field_positions_global",
   ")",
   "+",
   "1",
   "_shift_field_positions_global",
   "(",
   "rec",
   ",",
   "max",
   "(",
   "tag_field_positions_global",
   ")",
   "+",
   "1",
   ",",
   "1",
   ")",
   "field_position_local",
   "=",
   "len",
   "(",
   "rec",
   ".",
   "get",
   "(",
   "tag",
   ",",
   "[",
   "]",
   ")",
   ")",
   "else",
   ":",
   "if",
   "field_position_global",
   "in",
   "tag_field_positions_global",
   ":",
   "_shift_field_positions_global",
   "(",
   "rec",
   ",",
   "field_position_global",
   ",",
   "1",
   ")",
   "field_position_local",
   "=",
   "0",
   "for",
   "position",
   ",",
   "field",
   "in",
   "enumerate",
   "(",
   "rec",
   "[",
   "tag",
   "]",
   ")",
   ":",
   "if",
   "field",
   "[",
   "4",
   "]",
   "==",
   "field_position_global",
   "+",
   "1",
   ":",
   "field_position_local",
   "=",
   "position",
   "# Create the new field.",
   "newfield",
   "=",
   "(",
   "subfields",
   ",",
   "ind1",
   ",",
   "ind2",
   ",",
   "str",
   "(",
   "controlfield_value",
   ")",
   ",",
   "field_position_global",
   ")",
   "rec",
   ".",
   "setdefault",
   "(",
   "tag",
   ",",
   "[",
   "]",
   ")",
   ".",
   "insert",
   "(",
   "field_position_local",
   ",",
   "newfield",
   ")",
   "# Return new field number:",
   "return",
   "field_position_global"
  ]
 },
 {
  "idx": "maxmin-690",
  "nl_tokens": [
   "Updates",
   "synapses",
   "on",
   "segment",
   ".",
   "Strengthens",
   "active",
   "synapses",
   ";",
   "weakens",
   "inactive",
   "synapses",
   "."
  ],
  "pl_tokens": [
   "def",
   "_adaptSegment",
   "(",
   "cls",
   ",",
   "connections",
   ",",
   "segment",
   ",",
   "prevActiveCells",
   ",",
   "permanenceIncrement",
   ",",
   "permanenceDecrement",
   ")",
   ":",
   "# Destroying a synapse modifies the set that we're iterating through.",
   "synapsesToDestroy",
   "=",
   "[",
   "]",
   "for",
   "synapse",
   "in",
   "connections",
   ".",
   "synapsesForSegment",
   "(",
   "segment",
   ")",
   ":",
   "permanence",
   "=",
   "synapse",
   ".",
   "permanence",
   "if",
   "binSearch",
   "(",
   "prevActiveCells",
   ",",
   "synapse",
   ".",
   "presynapticCell",
   ")",
   "!=",
   "-",
   "1",
   ":",
   "permanence",
   "+=",
   "permanenceIncrement",
   "else",
   ":",
   "permanence",
   "-=",
   "permanenceDecrement",
   "# Keep permanence within min/max bounds",
   "permanence",
   "=",
   "<mask>",
   "(",
   "0.0",
   ",",
   "min",
   "(",
   "1.0",
   ",",
   "permanence",
   ")",
   ")",
   "if",
   "permanence",
   "<",
   "EPSILON",
   ":",
   "synapsesToDestroy",
   ".",
   "append",
   "(",
   "synapse",
   ")",
   "else",
   ":",
   "connections",
   ".",
   "updateSynapsePermanence",
   "(",
   "synapse",
   ",",
   "permanence",
   ")",
   "for",
   "synapse",
   "in",
   "synapsesToDestroy",
   ":",
   "connections",
   ".",
   "destroySynapse",
   "(",
   "synapse",
   ")",
   "if",
   "connections",
   ".",
   "numSynapses",
   "(",
   "segment",
   ")",
   "==",
   "0",
   ":",
   "connections",
   ".",
   "destroySegment",
   "(",
   "segment",
   ")"
  ]
 },
 {
  "idx": "maxmin-691",
  "nl_tokens": [
   "Standardizing",
   "the",
   "plot",
   "format",
   "of",
   "the",
   "does_matter",
   "section",
   ".",
   "See",
   "any",
   "of",
   "the",
   "accompaning",
   "files",
   "to",
   "see",
   "how",
   "to",
   "use",
   "this",
   "generalized",
   "plot",
   "."
  ],
  "pl_tokens": [
   "def",
   "doplot",
   "(",
   "image0",
   ",",
   "image1",
   ",",
   "xs",
   ",",
   "crbs",
   ",",
   "errors",
   ",",
   "labels",
   ",",
   "diff_image_scale",
   "=",
   "0.1",
   ",",
   "dolabels",
   "=",
   "True",
   ",",
   "multiple_crbs",
   "=",
   "True",
   ",",
   "xlim",
   "=",
   "None",
   ",",
   "ylim",
   "=",
   "None",
   ",",
   "highlight",
   "=",
   "None",
   ",",
   "detailed_labels",
   "=",
   "False",
   ",",
   "xlabel",
   "=",
   "\"\"",
   ",",
   "title",
   "=",
   "\"\"",
   ")",
   ":",
   "if",
   "len",
   "(",
   "crbs",
   ")",
   "!=",
   "len",
   "(",
   "errors",
   ")",
   "or",
   "len",
   "(",
   "crbs",
   ")",
   "!=",
   "len",
   "(",
   "labels",
   ")",
   ":",
   "raise",
   "IndexError",
   ",",
   "\"lengths are not consistent\"",
   "fig",
   "=",
   "pl",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "14",
   ",",
   "7",
   ")",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.43",
   ",",
   "0.15",
   ",",
   "0.52",
   ",",
   "0.75",
   "]",
   ")",
   "gs",
   "=",
   "ImageGrid",
   "(",
   "fig",
   ",",
   "rect",
   "=",
   "[",
   "0.05",
   ",",
   "0.05",
   ",",
   "0.25",
   ",",
   "0.90",
   "]",
   ",",
   "nrows_ncols",
   "=",
   "(",
   "2",
   ",",
   "1",
   ")",
   ",",
   "axes_pad",
   "=",
   "0.25",
   ",",
   "cbar_location",
   "=",
   "'right'",
   ",",
   "cbar_mode",
   "=",
   "'each'",
   ",",
   "cbar_size",
   "=",
   "'10%'",
   ",",
   "cbar_pad",
   "=",
   "0.04",
   ")",
   "diffm",
   "=",
   "diff_image_scale",
   "*",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "image1",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "/",
   "diff_image_scale",
   ")",
   "im0",
   "=",
   "gs",
   "[",
   "0",
   "]",
   ".",
   "imshow",
   "(",
   "image0",
   ",",
   "vmin",
   "=",
   "0",
   ",",
   "vmax",
   "=",
   "1",
   ",",
   "cmap",
   "=",
   "'bone_r'",
   ")",
   "im1",
   "=",
   "gs",
   "[",
   "1",
   "]",
   ".",
   "imshow",
   "(",
   "image1",
   ",",
   "vmin",
   "=",
   "-",
   "diffm",
   ",",
   "vmax",
   "=",
   "diffm",
   ",",
   "cmap",
   "=",
   "'RdBu'",
   ")",
   "cb0",
   "=",
   "pl",
   ".",
   "colorbar",
   "(",
   "im0",
   ",",
   "cax",
   "=",
   "gs",
   "[",
   "0",
   "]",
   ".",
   "cax",
   ",",
   "ticks",
   "=",
   "[",
   "0",
   ",",
   "1",
   "]",
   ")",
   "cb1",
   "=",
   "pl",
   ".",
   "colorbar",
   "(",
   "im1",
   ",",
   "cax",
   "=",
   "gs",
   "[",
   "1",
   "]",
   ".",
   "cax",
   ",",
   "ticks",
   "=",
   "[",
   "-",
   "diffm",
   ",",
   "diffm",
   "]",
   ")",
   "cb0",
   ".",
   "ax",
   ".",
   "set_yticklabels",
   "(",
   "[",
   "'0'",
   ",",
   "'1'",
   "]",
   ")",
   "cb1",
   ".",
   "ax",
   ".",
   "set_yticklabels",
   "(",
   "[",
   "'-%0.1f'",
   "%",
   "diffm",
   ",",
   "'%0.1f'",
   "%",
   "diffm",
   "]",
   ")",
   "image_names",
   "=",
   "[",
   "\"Reference\"",
   ",",
   "\"Difference\"",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "2",
   ")",
   ":",
   "gs",
   "[",
   "i",
   "]",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "gs",
   "[",
   "i",
   "]",
   ".",
   "set_yticks",
   "(",
   "[",
   "]",
   ")",
   "gs",
   "[",
   "i",
   "]",
   ".",
   "set_ylabel",
   "(",
   "image_names",
   "[",
   "i",
   "]",
   ")",
   "if",
   "dolabels",
   ":",
   "lbl",
   "(",
   "gs",
   "[",
   "i",
   "]",
   ",",
   "figlbl",
   "[",
   "i",
   "]",
   ")",
   "symbols",
   "=",
   "[",
   "'o'",
   ",",
   "'^'",
   ",",
   "'D'",
   ",",
   "'>'",
   "]",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "labels",
   ")",
   ")",
   ":",
   "c",
   "=",
   "COLORS",
   "[",
   "i",
   "]",
   "if",
   "multiple_crbs",
   "or",
   "i",
   "==",
   "0",
   ":",
   "if",
   "multiple_crbs",
   ":",
   "label",
   "=",
   "labels",
   "[",
   "i",
   "]",
   "if",
   "(",
   "i",
   "!=",
   "0",
   "and",
   "not",
   "detailed_labels",
   ")",
   "else",
   "'%s CRB'",
   "%",
   "labels",
   "[",
   "i",
   "]",
   "else",
   ":",
   "label",
   "=",
   "'CRB'",
   "ax",
   ".",
   "plot",
   "(",
   "xs",
   "[",
   "i",
   "]",
   ",",
   "crbs",
   "[",
   "i",
   "]",
   ",",
   "'-'",
   ",",
   "c",
   "=",
   "c",
   ",",
   "lw",
   "=",
   "3",
   ",",
   "label",
   "=",
   "label",
   ")",
   "label",
   "=",
   "labels",
   "[",
   "i",
   "]",
   "if",
   "(",
   "i",
   "!=",
   "0",
   "and",
   "not",
   "detailed_labels",
   ")",
   "else",
   "'%s Error'",
   "%",
   "labels",
   "[",
   "i",
   "]",
   "ax",
   ".",
   "plot",
   "(",
   "xs",
   "[",
   "i",
   "]",
   ",",
   "errors",
   "[",
   "i",
   "]",
   ",",
   "symbols",
   "[",
   "i",
   "]",
   ",",
   "ls",
   "=",
   "'--'",
   ",",
   "lw",
   "=",
   "2",
   ",",
   "c",
   "=",
   "c",
   ",",
   "label",
   "=",
   "label",
   ",",
   "ms",
   "=",
   "12",
   ")",
   "if",
   "dolabels",
   ":",
   "lbl",
   "(",
   "ax",
   ",",
   "'D'",
   ")",
   "ax",
   ".",
   "loglog",
   "(",
   ")",
   "if",
   "xlim",
   ":",
   "ax",
   ".",
   "set_xlim",
   "(",
   "xlim",
   ")",
   "if",
   "ylim",
   ":",
   "ax",
   ".",
   "set_ylim",
   "(",
   "ylim",
   ")",
   "ax",
   ".",
   "legend",
   "(",
   "loc",
   "=",
   "'upper left'",
   ",",
   "ncol",
   "=",
   "2",
   ",",
   "prop",
   "=",
   "{",
   "'size'",
   ":",
   "18",
   "}",
   ",",
   "numpoints",
   "=",
   "1",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "xlabel",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "r\"Position CRB, Error\"",
   ")",
   "ax",
   ".",
   "grid",
   "(",
   "False",
   ",",
   "which",
   "=",
   "'both'",
   ",",
   "axis",
   "=",
   "'both'",
   ")",
   "ax",
   ".",
   "set_title",
   "(",
   "title",
   ")",
   "return",
   "gs",
   ",",
   "ax"
  ]
 },
 {
  "idx": "maxmin-692",
  "nl_tokens": [
   "Complete",
   "the",
   "Counter",
   "timeline",
   "."
  ],
  "pl_tokens": [
   "def",
   "create_timeline",
   "(",
   "year_counter",
   ":",
   "typing",
   ".",
   "Counter",
   "[",
   "int",
   "]",
   ")",
   "->",
   "List",
   "[",
   "Tuple",
   "[",
   "int",
   ",",
   "int",
   "]",
   "]",
   ":",
   "if",
   "not",
   "year_counter",
   ":",
   "return",
   "[",
   "]",
   "from_year",
   "=",
   "<mask>",
   "(",
   "year_counter",
   ")",
   "-",
   "1",
   "until_year",
   "=",
   "datetime",
   ".",
   "now",
   "(",
   ")",
   ".",
   "year",
   "+",
   "1",
   "return",
   "[",
   "(",
   "year",
   ",",
   "year_counter",
   ".",
   "get",
   "(",
   "year",
   ",",
   "0",
   ")",
   ")",
   "for",
   "year",
   "in",
   "range",
   "(",
   "from_year",
   ",",
   "until_year",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-693",
  "nl_tokens": [
   "Wait",
   "for",
   "x",
   "seconds",
   "each",
   "wait",
   "command",
   "is",
   "100ms"
  ],
  "pl_tokens": [
   "def",
   "wait",
   "(",
   "self",
   ",",
   "sec",
   "=",
   "0.1",
   ")",
   ":",
   "sec",
   "=",
   "<mask>",
   "(",
   "sec",
   ",",
   "0",
   ")",
   "reps",
   "=",
   "int",
   "(",
   "floor",
   "(",
   "sec",
   "/",
   "0.1",
   ")",
   ")",
   "commands",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "reps",
   ")",
   ":",
   "commands",
   ".",
   "append",
   "(",
   "Command",
   "(",
   "0x00",
   ",",
   "wait",
   "=",
   "True",
   ")",
   ")",
   "return",
   "tuple",
   "(",
   "commands",
   ")"
  ]
 },
 {
  "idx": "maxmin-694",
  "nl_tokens": [
   "Returns",
   "a",
   "color",
   "with",
   "random",
   "values",
   "in",
   "the",
   "defined",
   "h",
   "s",
   "b",
   "a",
   "ranges",
   "."
  ],
  "pl_tokens": [
   "def",
   "color",
   "(",
   "self",
   ",",
   "clr",
   "=",
   "None",
   ",",
   "d",
   "=",
   "0.035",
   ")",
   ":",
   "# Revert to grayscale for black, white and grey hues.",
   "if",
   "clr",
   "!=",
   "None",
   "and",
   "not",
   "isinstance",
   "(",
   "clr",
   ",",
   "Color",
   ")",
   ":",
   "clr",
   "=",
   "color",
   "(",
   "clr",
   ")",
   "if",
   "clr",
   "!=",
   "None",
   "and",
   "not",
   "self",
   ".",
   "grayscale",
   ":",
   "if",
   "clr",
   ".",
   "is_black",
   ":",
   "return",
   "self",
   ".",
   "black",
   ".",
   "color",
   "(",
   "clr",
   ",",
   "d",
   ")",
   "if",
   "clr",
   ".",
   "is_white",
   ":",
   "return",
   "self",
   ".",
   "white",
   ".",
   "color",
   "(",
   "clr",
   ",",
   "d",
   ")",
   "if",
   "clr",
   ".",
   "is_grey",
   ":",
   "return",
   "choice",
   "(",
   "(",
   "self",
   ".",
   "black",
   ".",
   "color",
   "(",
   "clr",
   ",",
   "d",
   ")",
   ",",
   "self",
   ".",
   "white",
   ".",
   "color",
   "(",
   "clr",
   ",",
   "d",
   ")",
   ")",
   ")",
   "h",
   ",",
   "s",
   ",",
   "b",
   ",",
   "a",
   "=",
   "self",
   ".",
   "h",
   ",",
   "self",
   ".",
   "s",
   ",",
   "self",
   ".",
   "b",
   ",",
   "self",
   ".",
   "a",
   "if",
   "clr",
   "!=",
   "None",
   ":",
   "h",
   ",",
   "a",
   "=",
   "clr",
   ".",
   "h",
   "+",
   "d",
   "*",
   "(",
   "random",
   "(",
   ")",
   "*",
   "2",
   "-",
   "1",
   ")",
   ",",
   "clr",
   ".",
   "a",
   "hsba",
   "=",
   "[",
   "]",
   "for",
   "v",
   "in",
   "[",
   "h",
   ",",
   "s",
   ",",
   "b",
   ",",
   "a",
   "]",
   ":",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "_list",
   ")",
   ":",
   "<mask>",
   ",",
   "max",
   "=",
   "choice",
   "(",
   "v",
   ")",
   "elif",
   "isinstance",
   "(",
   "v",
   ",",
   "tuple",
   ")",
   ":",
   "min",
   ",",
   "max",
   "=",
   "v",
   "else",
   ":",
   "min",
   ",",
   "max",
   "=",
   "v",
   ",",
   "v",
   "hsba",
   ".",
   "append",
   "(",
   "min",
   "+",
   "(",
   "max",
   "-",
   "min",
   ")",
   "*",
   "random",
   "(",
   ")",
   ")",
   "h",
   ",",
   "s",
   ",",
   "b",
   ",",
   "a",
   "=",
   "hsba",
   "return",
   "color",
   "(",
   "h",
   ",",
   "s",
   ",",
   "b",
   ",",
   "a",
   ",",
   "mode",
   "=",
   "\"hsb\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-695",
  "nl_tokens": [
   "Does",
   "phase",
   "-",
   "folding",
   "for",
   "the",
   "mag",
   "/",
   "flux",
   "time",
   "-",
   "series",
   "given",
   "a",
   "period",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_phased_quantities",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "period",
   ")",
   ":",
   "# phase the mag series using the given period and faintest mag time",
   "# mintime = stimes[npwhere(smags == npmax(smags))]",
   "# phase the mag series using the given period and epoch = min(stimes)",
   "mintime",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "stimes",
   ")",
   "# calculate the unsorted phase, then sort it",
   "iphase",
   "=",
   "(",
   "stimes",
   "-",
   "mintime",
   ")",
   "/",
   "period",
   "-",
   "np",
   ".",
   "floor",
   "(",
   "(",
   "stimes",
   "-",
   "mintime",
   ")",
   "/",
   "period",
   ")",
   "phasesortind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "iphase",
   ")",
   "# these are the final quantities to use for the Fourier fits",
   "phase",
   "=",
   "iphase",
   "[",
   "phasesortind",
   "]",
   "pmags",
   "=",
   "smags",
   "[",
   "phasesortind",
   "]",
   "perrs",
   "=",
   "serrs",
   "[",
   "phasesortind",
   "]",
   "# get the times sorted in phase order (useful to get the fit mag minimum",
   "# with respect to phase -- the light curve minimum)",
   "ptimes",
   "=",
   "stimes",
   "[",
   "phasesortind",
   "]",
   "return",
   "phase",
   ",",
   "pmags",
   ",",
   "perrs",
   ",",
   "ptimes",
   ",",
   "mintime"
  ]
 },
 {
  "idx": "maxmin-696",
  "nl_tokens": [
   "Get",
   "the",
   "lower",
   "and",
   "upper",
   "bound",
   "distances",
   ".",
   "Negative",
   "is",
   "bad",
   "."
  ],
  "pl_tokens": [
   "def",
   "_bounds_dist",
   "(",
   "self",
   ",",
   "p",
   ")",
   ":",
   "prob",
   "=",
   "self",
   ".",
   "problem",
   "lb_dist",
   "=",
   "(",
   "p",
   "-",
   "prob",
   ".",
   "variable_bounds",
   "[",
   "0",
   ",",
   "]",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "ub_dist",
   "=",
   "(",
   "prob",
   ".",
   "variable_bounds",
   "[",
   "1",
   ",",
   "]",
   "-",
   "p",
   ")",
   ".",
   "min",
   "(",
   ")",
   "if",
   "prob",
   ".",
   "bounds",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ">",
   "0",
   ":",
   "const",
   "=",
   "prob",
   ".",
   "inequalities",
   ".",
   "dot",
   "(",
   "p",
   ")",
   "const_lb_dist",
   "=",
   "(",
   "const",
   "-",
   "prob",
   ".",
   "bounds",
   "[",
   "0",
   ",",
   "]",
   ")",
   ".",
   "min",
   "(",
   ")",
   "const_ub_dist",
   "=",
   "(",
   "prob",
   ".",
   "bounds",
   "[",
   "1",
   ",",
   "]",
   "-",
   "const",
   ")",
   ".",
   "min",
   "(",
   ")",
   "lb_dist",
   "=",
   "min",
   "(",
   "lb_dist",
   ",",
   "const_lb_dist",
   ")",
   "ub_dist",
   "=",
   "min",
   "(",
   "ub_dist",
   ",",
   "const_ub_dist",
   ")",
   "return",
   "np",
   ".",
   "array",
   "(",
   "[",
   "lb_dist",
   ",",
   "ub_dist",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-697",
  "nl_tokens": [
   "Tests",
   "all",
   "the",
   "intents",
   "against",
   "the",
   "query",
   "and",
   "returns",
   "match",
   "data",
   "of",
   "the",
   "best",
   "intent"
  ],
  "pl_tokens": [
   "def",
   "calc_intent",
   "(",
   "self",
   ",",
   "query",
   ")",
   ":",
   "matches",
   "=",
   "self",
   ".",
   "calc_intents",
   "(",
   "query",
   ")",
   "if",
   "len",
   "(",
   "matches",
   ")",
   "==",
   "0",
   ":",
   "return",
   "MatchData",
   "(",
   "''",
   ",",
   "''",
   ")",
   "best_match",
   "=",
   "<mask>",
   "(",
   "matches",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   ".",
   "conf",
   ")",
   "best_matches",
   "=",
   "(",
   "match",
   "for",
   "match",
   "in",
   "matches",
   "if",
   "match",
   ".",
   "conf",
   "==",
   "best_match",
   ".",
   "conf",
   ")",
   "return",
   "min",
   "(",
   "best_matches",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "sum",
   "(",
   "map",
   "(",
   "len",
   ",",
   "x",
   ".",
   "matches",
   ".",
   "values",
   "(",
   ")",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-698",
  "nl_tokens": [
   "Add",
   "weighted",
   "(",
   "0",
   ".",
   "0",
   "-",
   "1",
   ".",
   "0",
   ")",
   "edge",
   "between",
   "nodes",
   "creating",
   "them",
   "if",
   "necessary",
   ".",
   "The",
   "weight",
   "represents",
   "the",
   "importance",
   "of",
   "the",
   "connection",
   "(",
   "not",
   "the",
   "cost",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_edge",
   "(",
   "self",
   ",",
   "id1",
   ",",
   "id2",
   ",",
   "weight",
   "=",
   "0.0",
   ",",
   "length",
   "=",
   "1.0",
   ",",
   "label",
   "=",
   "\"\"",
   ",",
   "properties",
   "=",
   "{",
   "}",
   ")",
   ":",
   "if",
   "id1",
   "==",
   "id2",
   ":",
   "return",
   "None",
   "if",
   "not",
   "self",
   ".",
   "has_key",
   "(",
   "id1",
   ")",
   ":",
   "self",
   ".",
   "add_node",
   "(",
   "id1",
   ")",
   "if",
   "not",
   "self",
   ".",
   "has_key",
   "(",
   "id2",
   ")",
   ":",
   "self",
   ".",
   "add_node",
   "(",
   "id2",
   ")",
   "n1",
   "=",
   "self",
   "[",
   "id1",
   "]",
   "n2",
   "=",
   "self",
   "[",
   "id2",
   "]",
   "# If a->b already exists, don't re-create it.",
   "# However, b->a may still pass.",
   "if",
   "n1",
   "in",
   "n2",
   ".",
   "links",
   ":",
   "if",
   "n2",
   ".",
   "links",
   ".",
   "edge",
   "(",
   "n1",
   ")",
   ".",
   "node1",
   "==",
   "n1",
   ":",
   "return",
   "self",
   ".",
   "edge",
   "(",
   "id1",
   ",",
   "id2",
   ")",
   "weight",
   "=",
   "<mask>",
   "(",
   "0.0",
   ",",
   "min",
   "(",
   "weight",
   ",",
   "1.0",
   ")",
   ")",
   "e",
   "=",
   "edge",
   "(",
   "n1",
   ",",
   "n2",
   ",",
   "weight",
   ",",
   "length",
   ",",
   "label",
   ",",
   "properties",
   ")",
   "self",
   ".",
   "edges",
   ".",
   "append",
   "(",
   "e",
   ")",
   "n1",
   ".",
   "links",
   ".",
   "append",
   "(",
   "n2",
   ",",
   "e",
   ")",
   "n2",
   ".",
   "links",
   ".",
   "append",
   "(",
   "n1",
   ",",
   "e",
   ")",
   "return",
   "e"
  ]
 },
 {
  "idx": "maxmin-699",
  "nl_tokens": [
   "Accepts",
   "log",
   "-",
   "values",
   "as",
   "input",
   "exponentiates",
   "them",
   "sums",
   "down",
   "the",
   "rows",
   "(",
   "first",
   "dimension",
   ")",
   "then",
   "converts",
   "the",
   "sum",
   "back",
   "to",
   "log",
   "-",
   "space",
   "and",
   "returns",
   "the",
   "result",
   ".",
   "Handles",
   "underflow",
   "by",
   "rescaling",
   "so",
   "that",
   "the",
   "largest",
   "values",
   "is",
   "exactly",
   "1",
   ".",
   "0",
   "."
  ],
  "pl_tokens": [
   "def",
   "lscsum0",
   "(",
   "lx",
   ")",
   ":",
   "# rows = lx.shape[0]",
   "# columns = numpy.prod(lx.shape[1:])",
   "# lx = lx.reshape(rows, columns)",
   "# bases = lx.max(1).reshape(rows, 1)",
   "# bases = lx.max(0).reshape((1,) + lx.shape[1:])",
   "lx",
   "=",
   "numpy",
   ".",
   "asarray",
   "(",
   "lx",
   ")",
   "bases",
   "=",
   "lx",
   ".",
   "<mask>",
   "(",
   "0",
   ")",
   "# Don't need to reshape in the case of 0.",
   "x",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   "-",
   "bases",
   ")",
   "ssum",
   "=",
   "x",
   ".",
   "sum",
   "(",
   "0",
   ")",
   "result",
   "=",
   "numpy",
   ".",
   "log",
   "(",
   "ssum",
   ")",
   "+",
   "bases",
   "try",
   ":",
   "conventional",
   "=",
   "numpy",
   ".",
   "log",
   "(",
   "numpy",
   ".",
   "exp",
   "(",
   "lx",
   ")",
   ".",
   "sum",
   "(",
   "0",
   ")",
   ")",
   "if",
   "not",
   "similar",
   "(",
   "result",
   ",",
   "conventional",
   ")",
   ":",
   "if",
   "numpy",
   ".",
   "isinf",
   "(",
   "conventional",
   ")",
   ".",
   "any",
   "(",
   ")",
   "and",
   "not",
   "numpy",
   ".",
   "isinf",
   "(",
   "result",
   ")",
   ".",
   "any",
   "(",
   ")",
   ":",
   "# print \"Scaled log sum down axis 0 avoided underflow or overflow.\"",
   "pass",
   "else",
   ":",
   "import",
   "sys",
   "print",
   ">>",
   "sys",
   ".",
   "stderr",
   ",",
   "\"Warning: scaled log sum down axis 0 did not match.\"",
   "print",
   ">>",
   "sys",
   ".",
   "stderr",
   ",",
   "\"Scaled log result:\"",
   "print",
   ">>",
   "sys",
   ".",
   "stderr",
   ",",
   "result",
   "print",
   ">>",
   "sys",
   ".",
   "stderr",
   ",",
   "\"Conventional result:\"",
   "print",
   ">>",
   "sys",
   ".",
   "stderr",
   ",",
   "conventional",
   "except",
   "FloatingPointError",
   ",",
   "e",
   ":",
   "# print \"Scaled log sum down axis 0 avoided underflow or overflow.\"",
   "pass",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-700",
  "nl_tokens": [
   "Return",
   "the",
   "Smith",
   "-",
   "Waterman",
   "score",
   "of",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "gap_cost",
   "=",
   "1",
   ",",
   "sim_func",
   "=",
   "sim_ident",
   ")",
   ":",
   "d_mat",
   "=",
   "np_zeros",
   "(",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "np_float32",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ")",
   ":",
   "d_mat",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "0",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ":",
   "d_mat",
   "[",
   "0",
   ",",
   "j",
   "]",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "src",
   ")",
   "+",
   "1",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "tar",
   ")",
   "+",
   "1",
   ")",
   ":",
   "match",
   "=",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "-",
   "1",
   "]",
   "+",
   "sim_func",
   "(",
   "src",
   "[",
   "i",
   "-",
   "1",
   "]",
   ",",
   "tar",
   "[",
   "j",
   "-",
   "1",
   "]",
   ")",
   "delete",
   "=",
   "d_mat",
   "[",
   "i",
   "-",
   "1",
   ",",
   "j",
   "]",
   "-",
   "gap_cost",
   "insert",
   "=",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "-",
   "1",
   "]",
   "-",
   "gap_cost",
   "d_mat",
   "[",
   "i",
   ",",
   "j",
   "]",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "match",
   ",",
   "delete",
   ",",
   "insert",
   ")",
   "return",
   "d_mat",
   "[",
   "d_mat",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "1",
   ",",
   "d_mat",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "-",
   "1",
   "]"
  ]
 },
 {
  "idx": "maxmin-701",
  "nl_tokens": [
   "Runs",
   "the",
   "Box",
   "Least",
   "Squares",
   "Fitting",
   "Search",
   "for",
   "transit",
   "-",
   "shaped",
   "signals",
   "."
  ],
  "pl_tokens": [
   "def",
   "bls_serial_pfind",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "startp",
   "=",
   "0.1",
   ",",
   "# search from 0.1 d to...",
   "endp",
   "=",
   "100.0",
   ",",
   "# ... 100.0 d -- don't search full timebase",
   "stepsize",
   "=",
   "5.0e-4",
   ",",
   "mintransitduration",
   "=",
   "0.01",
   ",",
   "# minimum transit length in phase",
   "maxtransitduration",
   "=",
   "0.4",
   ",",
   "# maximum transit length in phase",
   "nphasebins",
   "=",
   "200",
   ",",
   "autofreq",
   "=",
   "True",
   ",",
   "# figure out f0, nf, and df automatically",
   "periodepsilon",
   "=",
   "0.1",
   ",",
   "nbestpeaks",
   "=",
   "5",
   ",",
   "sigclip",
   "=",
   "10.0",
   ",",
   "verbose",
   "=",
   "True",
   ",",
   "get_stats",
   "=",
   "True",
   ",",
   ")",
   ":",
   "# get rid of nans first and sigclip",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# make sure there are enough points to calculate a spectrum",
   "if",
   "len",
   "(",
   "stimes",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "smags",
   ")",
   ">",
   "9",
   "and",
   "len",
   "(",
   "serrs",
   ")",
   ">",
   "9",
   ":",
   "# if we're setting up everything automatically",
   "if",
   "autofreq",
   ":",
   "# figure out the best number of phasebins to use",
   "nphasebins",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "2.0",
   "/",
   "mintransitduration",
   ")",
   ")",
   "if",
   "nphasebins",
   ">",
   "3000",
   ":",
   "nphasebins",
   "=",
   "3000",
   "# use heuristic to figure out best timestep",
   "stepsize",
   "=",
   "0.25",
   "*",
   "mintransitduration",
   "/",
   "(",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "# now figure out the frequencies to use",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = True: using AUTOMATIC values for '",
   "'freq stepsize: %s, nphasebins: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "nphasebins",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "else",
   ":",
   "minfreq",
   "=",
   "1.0",
   "/",
   "endp",
   "maxfreq",
   "=",
   "1.0",
   "/",
   "startp",
   "nfreq",
   "=",
   "int",
   "(",
   "npceil",
   "(",
   "(",
   "maxfreq",
   "-",
   "minfreq",
   ")",
   "/",
   "stepsize",
   ")",
   ")",
   "# say what we're using",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'min P: %s, max P: %s, nfreq: %s, '",
   "'minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "startp",
   ",",
   "endp",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'autofreq = False: using PROVIDED values for '",
   "'freq stepsize: %s, nphasebins: %s, '",
   "'min transit duration: %s, max transit duration: %s'",
   "%",
   "(",
   "stepsize",
   ",",
   "nphasebins",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   ")",
   "if",
   "nfreq",
   ">",
   "5.0e5",
   ":",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'more than 5.0e5 frequencies to go through; '",
   "'this will take a while. '",
   "'you might want to use the '",
   "'periodbase.bls_parallel_pfind function instead'",
   ")",
   "if",
   "minfreq",
   "<",
   "(",
   "1.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   ":",
   "if",
   "verbose",
   ":",
   "LOGWARNING",
   "(",
   "'the requested max P = %.3f is larger than '",
   "'the time base of the observations = %.3f, '",
   "' will make minfreq = 2 x 1/timebase'",
   "%",
   "(",
   "endp",
   ",",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   ")",
   "minfreq",
   "=",
   "2.0",
   "/",
   "(",
   "stimes",
   ".",
   "max",
   "(",
   ")",
   "-",
   "stimes",
   ".",
   "min",
   "(",
   ")",
   ")",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "'new minfreq: %s, maxfreq: %s'",
   "%",
   "(",
   "minfreq",
   ",",
   "maxfreq",
   ")",
   ")",
   "# run BLS",
   "try",
   ":",
   "blsresult",
   "=",
   "_bls_runner",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "nfreq",
   ",",
   "minfreq",
   ",",
   "stepsize",
   ",",
   "nphasebins",
   ",",
   "mintransitduration",
   ",",
   "maxtransitduration",
   ")",
   "# find the peaks in the BLS. this uses wavelet transforms to",
   "# smooth the spectrum and find peaks. a similar thing would be",
   "# to do a convolution with a gaussian kernel or a tophat",
   "# function, calculate d/dx(result), then get indices where this",
   "# is zero",
   "# blspeakinds = find_peaks_cwt(blsresults['power'],",
   "#                              nparray([2.0,3.0,4.0,5.0]))",
   "frequencies",
   "=",
   "minfreq",
   "+",
   "nparange",
   "(",
   "nfreq",
   ")",
   "*",
   "stepsize",
   "periods",
   "=",
   "1.0",
   "/",
   "frequencies",
   "lsp",
   "=",
   "blsresult",
   "[",
   "'power'",
   "]",
   "# find the nbestpeaks for the periodogram: 1. sort the lsp array",
   "# by highest value first 2. go down the values until we find",
   "# five values that are separated by at least periodepsilon in",
   "# period",
   "# make sure to get only the finite peaks in the periodogram",
   "# this is needed because BLS may produce infs for some peaks",
   "finitepeakind",
   "=",
   "npisfinite",
   "(",
   "lsp",
   ")",
   "finlsp",
   "=",
   "lsp",
   "[",
   "finitepeakind",
   "]",
   "finperiods",
   "=",
   "periods",
   "[",
   "finitepeakind",
   "]",
   "# make sure that finlsp has finite values before we work on it",
   "try",
   ":",
   "bestperiodind",
   "=",
   "npargmax",
   "(",
   "finlsp",
   ")",
   "except",
   "ValueError",
   ":",
   "LOGERROR",
   "(",
   "'no finite periodogram values '",
   "'for this mag series, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "sortedlspind",
   "=",
   "npargsort",
   "(",
   "finlsp",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "sortedlspperiods",
   "=",
   "finperiods",
   "[",
   "sortedlspind",
   "]",
   "sortedlspvals",
   "=",
   "finlsp",
   "[",
   "sortedlspind",
   "]",
   "# now get the nbestpeaks",
   "nbestperiods",
   ",",
   "nbestlspvals",
   ",",
   "peakcount",
   "=",
   "(",
   "[",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "[",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   "]",
   ",",
   "1",
   ")",
   "prevperiod",
   "=",
   "sortedlspperiods",
   "[",
   "0",
   "]",
   "# find the best nbestpeaks in the lsp and their periods",
   "for",
   "period",
   ",",
   "lspval",
   "in",
   "zip",
   "(",
   "sortedlspperiods",
   ",",
   "sortedlspvals",
   ")",
   ":",
   "if",
   "peakcount",
   "==",
   "nbestpeaks",
   ":",
   "break",
   "perioddiff",
   "=",
   "abs",
   "(",
   "period",
   "-",
   "prevperiod",
   ")",
   "bestperiodsdiff",
   "=",
   "[",
   "abs",
   "(",
   "period",
   "-",
   "x",
   ")",
   "for",
   "x",
   "in",
   "nbestperiods",
   "]",
   "# print('prevperiod = %s, thisperiod = %s, '",
   "#       'perioddiff = %s, peakcount = %s' %",
   "#       (prevperiod, period, perioddiff, peakcount))",
   "# this ensures that this period is different from the last",
   "# period and from all the other existing best periods by",
   "# periodepsilon to make sure we jump to an entire different",
   "# peak in the periodogram",
   "if",
   "(",
   "perioddiff",
   ">",
   "(",
   "periodepsilon",
   "*",
   "prevperiod",
   ")",
   "and",
   "all",
   "(",
   "x",
   ">",
   "(",
   "periodepsilon",
   "*",
   "period",
   ")",
   "for",
   "x",
   "in",
   "bestperiodsdiff",
   ")",
   ")",
   ":",
   "nbestperiods",
   ".",
   "append",
   "(",
   "period",
   ")",
   "nbestlspvals",
   ".",
   "append",
   "(",
   "lspval",
   ")",
   "peakcount",
   "=",
   "peakcount",
   "+",
   "1",
   "prevperiod",
   "=",
   "period",
   "# generate the return dict",
   "resultdict",
   "=",
   "{",
   "'bestperiod'",
   ":",
   "finperiods",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'bestlspval'",
   ":",
   "finlsp",
   "[",
   "bestperiodind",
   "]",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "nbestlspvals",
   ",",
   "'nbestperiods'",
   ":",
   "nbestperiods",
   ",",
   "'lspvals'",
   ":",
   "lsp",
   ",",
   "'frequencies'",
   ":",
   "frequencies",
   ",",
   "'periods'",
   ":",
   "periods",
   ",",
   "'blsresult'",
   ":",
   "blsresult",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "nfreq",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "# get stats if requested",
   "if",
   "get_stats",
   ":",
   "resultdict",
   "[",
   "'stats'",
   "]",
   "=",
   "[",
   "]",
   "for",
   "bp",
   "in",
   "nbestperiods",
   ":",
   "if",
   "verbose",
   ":",
   "LOGINFO",
   "(",
   "\"Getting stats for best period: %.6f\"",
   "%",
   "bp",
   ")",
   "this_pstats",
   "=",
   "bls_stats_singleperiod",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "bp",
   ",",
   "magsarefluxes",
   "=",
   "resultdict",
   "[",
   "'kwargs'",
   "]",
   "[",
   "'magsarefluxes'",
   "]",
   ",",
   "sigclip",
   "=",
   "resultdict",
   "[",
   "'kwargs'",
   "]",
   "[",
   "'sigclip'",
   "]",
   ",",
   "nphasebins",
   "=",
   "resultdict",
   "[",
   "'nphasebins'",
   "]",
   ",",
   "mintransitduration",
   "=",
   "resultdict",
   "[",
   "'mintransitduration'",
   "]",
   ",",
   "maxtransitduration",
   "=",
   "resultdict",
   "[",
   "'maxtransitduration'",
   "]",
   ",",
   "verbose",
   "=",
   "verbose",
   ",",
   ")",
   "resultdict",
   "[",
   "'stats'",
   "]",
   ".",
   "append",
   "(",
   "this_pstats",
   ")",
   "return",
   "resultdict",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "LOGEXCEPTION",
   "(",
   "'BLS failed!'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "nfreq",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}",
   "else",
   ":",
   "LOGERROR",
   "(",
   "'no good detections for these times and mags, skipping...'",
   ")",
   "return",
   "{",
   "'bestperiod'",
   ":",
   "npnan",
   ",",
   "'bestlspval'",
   ":",
   "npnan",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'nbestlspvals'",
   ":",
   "None",
   ",",
   "'nbestperiods'",
   ":",
   "None",
   ",",
   "'lspvals'",
   ":",
   "None",
   ",",
   "'periods'",
   ":",
   "None",
   ",",
   "'blsresult'",
   ":",
   "None",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'nfreq'",
   ":",
   "None",
   ",",
   "'nphasebins'",
   ":",
   "None",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'method'",
   ":",
   "'bls'",
   ",",
   "'kwargs'",
   ":",
   "{",
   "'startp'",
   ":",
   "startp",
   ",",
   "'endp'",
   ":",
   "endp",
   ",",
   "'stepsize'",
   ":",
   "stepsize",
   ",",
   "'mintransitduration'",
   ":",
   "mintransitduration",
   ",",
   "'maxtransitduration'",
   ":",
   "maxtransitduration",
   ",",
   "'nphasebins'",
   ":",
   "nphasebins",
   ",",
   "'autofreq'",
   ":",
   "autofreq",
   ",",
   "'periodepsilon'",
   ":",
   "periodepsilon",
   ",",
   "'nbestpeaks'",
   ":",
   "nbestpeaks",
   ",",
   "'sigclip'",
   ":",
   "sigclip",
   ",",
   "'magsarefluxes'",
   ":",
   "magsarefluxes",
   "}",
   "}"
  ]
 },
 {
  "idx": "maxmin-702",
  "nl_tokens": [
   "Applies",
   "the",
   "overlay",
   "blend",
   "mode",
   ".",
   "Overlays",
   "image",
   "img2",
   "on",
   "image",
   "img1",
   ".",
   "The",
   "overlay",
   "pixel",
   "combines",
   "multiply",
   "and",
   "screen",
   ":",
   "it",
   "multiplies",
   "dark",
   "pixels",
   "values",
   "and",
   "screen",
   "light",
   "values",
   ".",
   "Returns",
   "a",
   "composite",
   "image",
   "with",
   "the",
   "alpha",
   "channel",
   "retained",
   "."
  ],
  "pl_tokens": [
   "def",
   "overlay",
   "(",
   "self",
   ",",
   "img1",
   ",",
   "img2",
   ")",
   ":",
   "p1",
   "=",
   "list",
   "(",
   "img1",
   ".",
   "getdata",
   "(",
   ")",
   ")",
   "p2",
   "=",
   "list",
   "(",
   "img2",
   ".",
   "getdata",
   "(",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "p1",
   ")",
   ")",
   ":",
   "p3",
   "=",
   "(",
   ")",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "p1",
   "[",
   "i",
   "]",
   ")",
   ")",
   ":",
   "a",
   "=",
   "p1",
   "[",
   "i",
   "]",
   "[",
   "j",
   "]",
   "/",
   "255.0",
   "b",
   "=",
   "p2",
   "[",
   "i",
   "]",
   "[",
   "j",
   "]",
   "/",
   "255.0",
   "#When overlaying the alpha channels,",
   "#take the alpha of the most transparent layer.",
   "if",
   "j",
   "==",
   "3",
   ":",
   "#d = (a+b)*0.5",
   "#d = a",
   "d",
   "=",
   "<mask>",
   "(",
   "a",
   ",",
   "b",
   ")",
   "elif",
   "a",
   ">",
   "0.5",
   ":",
   "d",
   "=",
   "2",
   "*",
   "(",
   "a",
   "+",
   "b",
   "-",
   "a",
   "*",
   "b",
   ")",
   "-",
   "1",
   "else",
   ":",
   "d",
   "=",
   "2",
   "*",
   "a",
   "*",
   "b",
   "p3",
   "+=",
   "(",
   "int",
   "(",
   "d",
   "*",
   "255",
   ")",
   ",",
   ")",
   "p1",
   "[",
   "i",
   "]",
   "=",
   "p3",
   "img",
   "=",
   "Image",
   ".",
   "new",
   "(",
   "\"RGBA\"",
   ",",
   "img1",
   ".",
   "size",
   ",",
   "255",
   ")",
   "img",
   ".",
   "putdata",
   "(",
   "p1",
   ")",
   "return",
   "img"
  ]
 },
 {
  "idx": "maxmin-703",
  "nl_tokens": [
   "Resize",
   "an",
   "array",
   "using",
   "max",
   "-",
   "pooling",
   "."
  ],
  "pl_tokens": [
   "def",
   "max_pool",
   "(",
   "arr",
   ",",
   "block_size",
   ",",
   "cval",
   "=",
   "0",
   ",",
   "preserve_dtype",
   "=",
   "True",
   ")",
   ":",
   "return",
   "pool",
   "(",
   "arr",
   ",",
   "block_size",
   ",",
   "np",
   ".",
   "<mask>",
   ",",
   "cval",
   "=",
   "cval",
   ",",
   "preserve_dtype",
   "=",
   "preserve_dtype",
   ")"
  ]
 },
 {
  "idx": "maxmin-704",
  "nl_tokens": [
   "Sample",
   "a",
   "new",
   "feasible",
   "point",
   "from",
   "the",
   "point",
   "x",
   "in",
   "direction",
   "delta",
   "."
  ],
  "pl_tokens": [
   "def",
   "step",
   "(",
   "sampler",
   ",",
   "x",
   ",",
   "delta",
   ",",
   "fraction",
   "=",
   "None",
   ",",
   "tries",
   "=",
   "0",
   ")",
   ":",
   "prob",
   "=",
   "sampler",
   ".",
   "problem",
   "valid",
   "=",
   "(",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "delta",
   ")",
   ">",
   "sampler",
   ".",
   "feasibility_tol",
   ")",
   "&",
   "np",
   ".",
   "logical_not",
   "(",
   "prob",
   ".",
   "variable_fixed",
   ")",
   ")",
   "# permissible alphas for staying in variable bounds",
   "valphas",
   "=",
   "(",
   "(",
   "1.0",
   "-",
   "sampler",
   ".",
   "bounds_tol",
   ")",
   "*",
   "prob",
   ".",
   "variable_bounds",
   "-",
   "x",
   ")",
   "[",
   ":",
   ",",
   "valid",
   "]",
   "valphas",
   "=",
   "(",
   "valphas",
   "/",
   "delta",
   "[",
   "valid",
   "]",
   ")",
   ".",
   "flatten",
   "(",
   ")",
   "if",
   "prob",
   ".",
   "bounds",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ">",
   "0",
   ":",
   "# permissible alphas for staying in constraint bounds",
   "ineqs",
   "=",
   "prob",
   ".",
   "inequalities",
   ".",
   "dot",
   "(",
   "delta",
   ")",
   "valid",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "ineqs",
   ")",
   ">",
   "sampler",
   ".",
   "feasibility_tol",
   "balphas",
   "=",
   "(",
   "(",
   "1.0",
   "-",
   "sampler",
   ".",
   "bounds_tol",
   ")",
   "*",
   "prob",
   ".",
   "bounds",
   "-",
   "prob",
   ".",
   "inequalities",
   ".",
   "dot",
   "(",
   "x",
   ")",
   ")",
   "[",
   ":",
   ",",
   "valid",
   "]",
   "balphas",
   "=",
   "(",
   "balphas",
   "/",
   "ineqs",
   "[",
   "valid",
   "]",
   ")",
   ".",
   "flatten",
   "(",
   ")",
   "# combined alphas",
   "alphas",
   "=",
   "np",
   ".",
   "hstack",
   "(",
   "[",
   "valphas",
   ",",
   "balphas",
   "]",
   ")",
   "else",
   ":",
   "alphas",
   "=",
   "valphas",
   "pos_alphas",
   "=",
   "alphas",
   "[",
   "alphas",
   ">",
   "0.0",
   "]",
   "neg_alphas",
   "=",
   "alphas",
   "[",
   "alphas",
   "<=",
   "0.0",
   "]",
   "alpha_range",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "neg_alphas",
   ".",
   "<mask>",
   "(",
   ")",
   "if",
   "len",
   "(",
   "neg_alphas",
   ")",
   ">",
   "0",
   "else",
   "0",
   ",",
   "pos_alphas",
   ".",
   "min",
   "(",
   ")",
   "if",
   "len",
   "(",
   "pos_alphas",
   ")",
   ">",
   "0",
   "else",
   "0",
   "]",
   ")",
   "if",
   "fraction",
   ":",
   "alpha",
   "=",
   "alpha_range",
   "[",
   "0",
   "]",
   "+",
   "fraction",
   "*",
   "(",
   "alpha_range",
   "[",
   "1",
   "]",
   "-",
   "alpha_range",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "alpha",
   "=",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "alpha_range",
   "[",
   "0",
   "]",
   ",",
   "alpha_range",
   "[",
   "1",
   "]",
   ")",
   "p",
   "=",
   "x",
   "+",
   "alpha",
   "*",
   "delta",
   "# Numerical instabilities may cause bounds invalidation",
   "# reset sampler and sample from one of the original warmup directions",
   "# if that occurs. Also reset if we got stuck.",
   "if",
   "(",
   "np",
   ".",
   "any",
   "(",
   "sampler",
   ".",
   "_bounds_dist",
   "(",
   "p",
   ")",
   "<",
   "-",
   "sampler",
   ".",
   "bounds_tol",
   ")",
   "or",
   "np",
   ".",
   "abs",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "alpha_range",
   ")",
   ".",
   "max",
   "(",
   ")",
   "*",
   "delta",
   ")",
   ".",
   "max",
   "(",
   ")",
   "<",
   "sampler",
   ".",
   "bounds_tol",
   ")",
   ":",
   "if",
   "tries",
   ">",
   "MAX_TRIES",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Can not escape sampling region, model seems\"",
   "\" numerically unstable :( Reporting the \"",
   "\"model to \"",
   "\"https://github.com/opencobra/cobrapy/issues \"",
   "\"will help us to fix this :)\"",
   ")",
   "LOGGER",
   ".",
   "info",
   "(",
   "\"found bounds infeasibility in sample, \"",
   "\"resetting to center\"",
   ")",
   "newdir",
   "=",
   "sampler",
   ".",
   "warmup",
   "[",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "sampler",
   ".",
   "n_warmup",
   ")",
   "]",
   "sampler",
   ".",
   "retries",
   "+=",
   "1",
   "return",
   "step",
   "(",
   "sampler",
   ",",
   "sampler",
   ".",
   "center",
   ",",
   "newdir",
   "-",
   "sampler",
   ".",
   "center",
   ",",
   "None",
   ",",
   "tries",
   "+",
   "1",
   ")",
   "return",
   "p"
  ]
 },
 {
  "idx": "maxmin-705",
  "nl_tokens": [
   "Get",
   "the",
   "bounding",
   "box",
   "for",
   "the",
   "mesh"
  ],
  "pl_tokens": [
   "def",
   "get_bbox",
   "(",
   "self",
   ",",
   "primitive",
   ")",
   ":",
   "accessor",
   "=",
   "primitive",
   ".",
   "attributes",
   ".",
   "get",
   "(",
   "'POSITION'",
   ")",
   "return",
   "accessor",
   ".",
   "<mask>",
   ",",
   "accessor",
   ".",
   "max"
  ]
 },
 {
  "idx": "maxmin-706",
  "nl_tokens": [
   "Checks",
   "for",
   "a",
   "C",
   "-",
   "style",
   "cast",
   "by",
   "looking",
   "for",
   "the",
   "pattern",
   "."
  ],
  "pl_tokens": [
   "def",
   "CheckCStyleCast",
   "(",
   "filename",
   ",",
   "clean_lines",
   ",",
   "linenum",
   ",",
   "cast_type",
   ",",
   "pattern",
   ",",
   "error",
   ")",
   ":",
   "line",
   "=",
   "clean_lines",
   ".",
   "elided",
   "[",
   "linenum",
   "]",
   "match",
   "=",
   "Search",
   "(",
   "pattern",
   ",",
   "line",
   ")",
   "if",
   "not",
   "match",
   ":",
   "return",
   "False",
   "# Exclude lines with keywords that tend to look like casts",
   "context",
   "=",
   "line",
   "[",
   "0",
   ":",
   "match",
   ".",
   "start",
   "(",
   "1",
   ")",
   "-",
   "1",
   "]",
   "if",
   "Match",
   "(",
   "r'.*\\b(?:sizeof|alignof|alignas|[_A-Z][_A-Z0-9]*)\\s*$'",
   ",",
   "context",
   ")",
   ":",
   "return",
   "False",
   "# Try expanding current context to see if we one level of",
   "# parentheses inside a macro.",
   "if",
   "linenum",
   ">",
   "0",
   ":",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "linenum",
   "-",
   "1",
   ",",
   "<mask>",
   "(",
   "0",
   ",",
   "linenum",
   "-",
   "5",
   ")",
   ",",
   "-",
   "1",
   ")",
   ":",
   "context",
   "=",
   "clean_lines",
   ".",
   "elided",
   "[",
   "i",
   "]",
   "+",
   "context",
   "if",
   "Match",
   "(",
   "r'.*\\b[_A-Z][_A-Z0-9]*\\s*\\((?:\\([^()]*\\)|[^()])*$'",
   ",",
   "context",
   ")",
   ":",
   "return",
   "False",
   "# operator++(int) and operator--(int)",
   "if",
   "context",
   ".",
   "endswith",
   "(",
   "' operator++'",
   ")",
   "or",
   "context",
   ".",
   "endswith",
   "(",
   "' operator--'",
   ")",
   ":",
   "return",
   "False",
   "# A single unnamed argument for a function tends to look like old style cast.",
   "# If we see those, don't issue warnings for deprecated casts.",
   "remainder",
   "=",
   "line",
   "[",
   "match",
   ".",
   "end",
   "(",
   "0",
   ")",
   ":",
   "]",
   "if",
   "Match",
   "(",
   "r'^\\s*(?:;|const\\b|throw\\b|final\\b|override\\b|[=>{),]|->)'",
   ",",
   "remainder",
   ")",
   ":",
   "return",
   "False",
   "# At this point, all that should be left is actual casts.",
   "error",
   "(",
   "filename",
   ",",
   "linenum",
   ",",
   "'readability/casting'",
   ",",
   "4",
   ",",
   "'Using C-style cast.  Use %s<%s>(...) instead'",
   "%",
   "(",
   "cast_type",
   ",",
   "match",
   ".",
   "group",
   "(",
   "1",
   ")",
   ")",
   ")",
   "return",
   "True"
  ]
 },
 {
  "idx": "maxmin-707",
  "nl_tokens": [
   "Given",
   "model",
   "params",
   "figure",
   "out",
   "the",
   "correct",
   "parameters",
   "for",
   "the",
   "RandomDistributed",
   "encoder",
   ".",
   "Modifies",
   "params",
   "in",
   "place",
   "."
  ],
  "pl_tokens": [
   "def",
   "_fixupRandomEncoderParams",
   "(",
   "params",
   ",",
   "minVal",
   ",",
   "maxVal",
   ",",
   "minResolution",
   ")",
   ":",
   "encodersDict",
   "=",
   "(",
   "params",
   "[",
   "\"modelConfig\"",
   "]",
   "[",
   "\"modelParams\"",
   "]",
   "[",
   "\"sensorParams\"",
   "]",
   "[",
   "\"encoders\"",
   "]",
   ")",
   "for",
   "encoder",
   "in",
   "encodersDict",
   ".",
   "itervalues",
   "(",
   ")",
   ":",
   "if",
   "encoder",
   "is",
   "not",
   "None",
   ":",
   "if",
   "encoder",
   "[",
   "\"type\"",
   "]",
   "==",
   "\"RandomDistributedScalarEncoder\"",
   ":",
   "resolution",
   "=",
   "<mask>",
   "(",
   "minResolution",
   ",",
   "(",
   "maxVal",
   "-",
   "minVal",
   ")",
   "/",
   "encoder",
   ".",
   "pop",
   "(",
   "\"numBuckets\"",
   ")",
   ")",
   "encodersDict",
   "[",
   "\"c1\"",
   "]",
   "[",
   "\"resolution\"",
   "]",
   "=",
   "resolution"
  ]
 },
 {
  "idx": "maxmin-708",
  "nl_tokens": [
   "Compute",
   "closeness",
   "scores",
   "between",
   "the",
   "expected",
   "scalar",
   "value",
   "(",
   "s",
   ")",
   "and",
   "actual",
   "scalar",
   "value",
   "(",
   "s",
   ")",
   ".",
   "The",
   "expected",
   "scalar",
   "values",
   "are",
   "typically",
   "those",
   "obtained",
   "from",
   "the",
   ":",
   "meth",
   ":",
   ".",
   "getScalars",
   "method",
   ".",
   "The",
   "actual",
   "scalar",
   "values",
   "are",
   "typically",
   "those",
   "returned",
   "from",
   ":",
   "meth",
   ":",
   ".",
   "topDownCompute",
   "."
  ],
  "pl_tokens": [
   "def",
   "closenessScores",
   "(",
   "self",
   ",",
   "expValues",
   ",",
   "actValues",
   ",",
   "fractional",
   "=",
   "True",
   ")",
   ":",
   "# Fallback closenss is a percentage match",
   "if",
   "self",
   ".",
   "encoders",
   "is",
   "None",
   ":",
   "err",
   "=",
   "abs",
   "(",
   "expValues",
   "[",
   "0",
   "]",
   "-",
   "actValues",
   "[",
   "0",
   "]",
   ")",
   "if",
   "fractional",
   ":",
   "denom",
   "=",
   "<mask>",
   "(",
   "expValues",
   "[",
   "0",
   "]",
   ",",
   "actValues",
   "[",
   "0",
   "]",
   ")",
   "if",
   "denom",
   "==",
   "0",
   ":",
   "denom",
   "=",
   "1.0",
   "closeness",
   "=",
   "1.0",
   "-",
   "float",
   "(",
   "err",
   ")",
   "/",
   "denom",
   "if",
   "closeness",
   "<",
   "0",
   ":",
   "closeness",
   "=",
   "0",
   "else",
   ":",
   "closeness",
   "=",
   "err",
   "return",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "closeness",
   "]",
   ")",
   "# Concatenate the results from closeness scores on each child encoder",
   "scalarIdx",
   "=",
   "0",
   "retVals",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "for",
   "(",
   "name",
   ",",
   "encoder",
   ",",
   "offset",
   ")",
   "in",
   "self",
   ".",
   "encoders",
   ":",
   "values",
   "=",
   "encoder",
   ".",
   "closenessScores",
   "(",
   "expValues",
   "[",
   "scalarIdx",
   ":",
   "]",
   ",",
   "actValues",
   "[",
   "scalarIdx",
   ":",
   "]",
   ",",
   "fractional",
   "=",
   "fractional",
   ")",
   "scalarIdx",
   "+=",
   "len",
   "(",
   "values",
   ")",
   "retVals",
   "=",
   "numpy",
   ".",
   "hstack",
   "(",
   "(",
   "retVals",
   ",",
   "values",
   ")",
   ")",
   "return",
   "retVals"
  ]
 },
 {
  "idx": "maxmin-709",
  "nl_tokens": [
   "Finds",
   "the",
   "closest",
   "objects",
   "in",
   "(",
   "ra2",
   "dec2",
   ")",
   "to",
   "scalar",
   "coordinate",
   "pair",
   "(",
   "ra1",
   "dec1",
   ")",
   "and",
   "returns",
   "the",
   "indices",
   "of",
   "the",
   "objects",
   "that",
   "match",
   "."
  ],
  "pl_tokens": [
   "def",
   "xmatch_neighbors",
   "(",
   "ra1",
   ",",
   "dec1",
   ",",
   "ra2",
   ",",
   "dec2",
   ",",
   "match_radius",
   "=",
   "60.0",
   ",",
   "includeself",
   "=",
   "False",
   ",",
   "sortresults",
   "=",
   "True",
   ")",
   ":",
   "dist",
   "=",
   "great_circle_dist",
   "(",
   "ra1",
   ",",
   "dec1",
   ",",
   "ra2",
   ",",
   "dec2",
   ")",
   "if",
   "includeself",
   ":",
   "match_dist_ind",
   "=",
   "np",
   ".",
   "where",
   "(",
   "dist",
   "<",
   "match_radius",
   ")",
   "else",
   ":",
   "# make sure we match only objects that are not the same as this object",
   "match_dist_ind",
   "=",
   "np",
   ".",
   "where",
   "(",
   "(",
   "dist",
   "<",
   "match_radius",
   ")",
   "&",
   "(",
   "dist",
   ">",
   "0.1",
   ")",
   ")",
   "if",
   "len",
   "(",
   "match_dist_ind",
   ")",
   ">",
   "0",
   ":",
   "match_dists",
   "=",
   "dist",
   "[",
   "match_dist_ind",
   "]",
   "dist_sort_ind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "match_dists",
   ")",
   "if",
   "sortresults",
   ":",
   "match_dist_ind",
   "=",
   "(",
   "match_dist_ind",
   "[",
   "0",
   "]",
   ")",
   "[",
   "dist_sort_ind",
   "]",
   "min_dist",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "match_dists",
   ")",
   "return",
   "(",
   "True",
   ",",
   "min_dist",
   ",",
   "match_dist_ind",
   ",",
   "match_dists",
   "[",
   "dist_sort_ind",
   "]",
   ")",
   "else",
   ":",
   "return",
   "(",
   "False",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-710",
  "nl_tokens": [
   "Compute",
   "the",
   "minimal",
   "distance",
   "between",
   "the",
   "line",
   "string",
   "and",
   "other",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_distance",
   "(",
   "self",
   ",",
   "other",
   ",",
   "default",
   "=",
   "None",
   ")",
   ":",
   "# FIXME this computes distance pointwise, does not have to be identical",
   "#       with the actual min distance (e.g. edge center to other's point)",
   "distances",
   "=",
   "self",
   ".",
   "compute_pointwise_distances",
   "(",
   "other",
   ",",
   "default",
   "=",
   "[",
   "]",
   ")",
   "if",
   "len",
   "(",
   "distances",
   ")",
   "==",
   "0",
   ":",
   "return",
   "default",
   "return",
   "<mask>",
   "(",
   "distances",
   ")"
  ]
 },
 {
  "idx": "maxmin-711",
  "nl_tokens": [
   "Count",
   "bit",
   "errors",
   "between",
   "a",
   "transmitted",
   "and",
   "received",
   "BPSK",
   "signal",
   ".",
   "Time",
   "delay",
   "between",
   "streams",
   "is",
   "detected",
   "as",
   "well",
   "as",
   "ambiquity",
   "resolution",
   "due",
   "to",
   "carrier",
   "phase",
   "lock",
   "offsets",
   "of",
   ":",
   "math",
   ":",
   "k",
   "*",
   "\\\\",
   "pi",
   "k",
   "=",
   "0",
   "1",
   ".",
   "The",
   "ndarray",
   "tx_data",
   "is",
   "Tx",
   "0",
   "/",
   "1",
   "bits",
   "as",
   "real",
   "numbers",
   "I",
   ".",
   "The",
   "ndarray",
   "rx_data",
   "is",
   "Rx",
   "0",
   "/",
   "1",
   "bits",
   "as",
   "real",
   "numbers",
   "I",
   ".",
   "Note",
   ":",
   "Ncorr",
   "needs",
   "to",
   "be",
   "even"
  ],
  "pl_tokens": [
   "def",
   "bit_errors",
   "(",
   "tx_data",
   ",",
   "rx_data",
   ",",
   "Ncorr",
   "=",
   "1024",
   ",",
   "Ntransient",
   "=",
   "0",
   ")",
   ":",
   "# Remove Ntransient symbols and level shift to {-1,+1}",
   "tx_data",
   "=",
   "2",
   "*",
   "tx_data",
   "[",
   "Ntransient",
   ":",
   "]",
   "-",
   "1",
   "rx_data",
   "=",
   "2",
   "*",
   "rx_data",
   "[",
   "Ntransient",
   ":",
   "]",
   "-",
   "1",
   "# Correlate the first Ncorr symbols at four possible phase rotations",
   "R0",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "ifft",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "rx_data",
   ",",
   "Ncorr",
   ")",
   "*",
   "np",
   ".",
   "conj",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   ")",
   ")",
   "R1",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "ifft",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "-",
   "1",
   "*",
   "rx_data",
   ",",
   "Ncorr",
   ")",
   "*",
   "np",
   ".",
   "conj",
   "(",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "tx_data",
   ",",
   "Ncorr",
   ")",
   ")",
   ")",
   "#Place the zero lag value in the center of the array",
   "R0",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fftshift",
   "(",
   "R0",
   ")",
   "R1",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fftshift",
   "(",
   "R1",
   ")",
   "R0max",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "R0",
   ".",
   "real",
   ")",
   "R1max",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R1",
   ".",
   "real",
   ")",
   "R",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "R0max",
   ",",
   "R1max",
   "]",
   ")",
   "Rmax",
   "=",
   "np",
   ".",
   "max",
   "(",
   "R",
   ")",
   "kphase_max",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "kmax",
   "=",
   "kphase_max",
   "[",
   "0",
   "]",
   "# Correlation lag value is zero at the center of the array",
   "if",
   "kmax",
   "==",
   "0",
   ":",
   "lagmax",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R0",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "-",
   "Ncorr",
   "/",
   "2",
   "elif",
   "kmax",
   "==",
   "1",
   ":",
   "lagmax",
   "=",
   "np",
   ".",
   "where",
   "(",
   "R1",
   ".",
   "real",
   "==",
   "Rmax",
   ")",
   "[",
   "0",
   "]",
   "-",
   "Ncorr",
   "/",
   "2",
   "taumax",
   "=",
   "lagmax",
   "[",
   "0",
   "]",
   "print",
   "(",
   "'kmax =  %d, taumax = %d'",
   "%",
   "(",
   "kmax",
   ",",
   "taumax",
   ")",
   ")",
   "# Count bit and symbol errors over the entire input ndarrays",
   "# Begin by making tx and rx length equal and apply phase rotation to rx",
   "if",
   "taumax",
   "<",
   "0",
   ":",
   "tx_data",
   "=",
   "tx_data",
   "[",
   "int",
   "(",
   "-",
   "taumax",
   ")",
   ":",
   "]",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "min",
   "(",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   ")",
   "]",
   "rx_data",
   "=",
   "(",
   "-",
   "1",
   ")",
   "**",
   "kmax",
   "*",
   "rx_data",
   "[",
   ":",
   "len",
   "(",
   "tx_data",
   ")",
   "]",
   "else",
   ":",
   "rx_data",
   "=",
   "(",
   "-",
   "1",
   ")",
   "**",
   "kmax",
   "*",
   "rx_data",
   "[",
   "int",
   "(",
   "taumax",
   ")",
   ":",
   "]",
   "rx_data",
   "=",
   "rx_data",
   "[",
   ":",
   "min",
   "(",
   "len",
   "(",
   "tx_data",
   ")",
   ",",
   "len",
   "(",
   "rx_data",
   ")",
   ")",
   "]",
   "tx_data",
   "=",
   "tx_data",
   "[",
   ":",
   "len",
   "(",
   "rx_data",
   ")",
   "]",
   "# Convert to 0's and 1's",
   "Bit_count",
   "=",
   "len",
   "(",
   "tx_data",
   ")",
   "tx_I",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "(",
   "tx_data",
   ".",
   "real",
   "+",
   "1",
   ")",
   "/",
   "2",
   ")",
   "rx_I",
   "=",
   "np",
   ".",
   "int16",
   "(",
   "(",
   "rx_data",
   ".",
   "real",
   "+",
   "1",
   ")",
   "/",
   "2",
   ")",
   "Bit_errors",
   "=",
   "tx_I",
   "^",
   "rx_I",
   "return",
   "Bit_count",
   ",",
   "np",
   ".",
   "sum",
   "(",
   "Bit_errors",
   ")"
  ]
 },
 {
  "idx": "maxmin-712",
  "nl_tokens": [
   "Convert",
   "a",
   "YIQ",
   "color",
   "representation",
   "to",
   "an",
   "RGB",
   "color",
   "representation",
   "."
  ],
  "pl_tokens": [
   "def",
   "yiq_to_rgb",
   "(",
   "yiq",
   ")",
   ":",
   "y",
   ",",
   "i",
   ",",
   "q",
   "=",
   "yiq",
   "r",
   "=",
   "y",
   "+",
   "(",
   "0.956",
   "*",
   "i",
   ")",
   "+",
   "(",
   "0.621",
   "*",
   "q",
   ")",
   "g",
   "=",
   "y",
   "-",
   "(",
   "0.272",
   "*",
   "i",
   ")",
   "-",
   "(",
   "0.647",
   "*",
   "q",
   ")",
   "b",
   "=",
   "y",
   "-",
   "(",
   "1.108",
   "*",
   "i",
   ")",
   "+",
   "(",
   "1.705",
   "*",
   "q",
   ")",
   "r",
   "=",
   "1",
   "if",
   "r",
   ">",
   "1",
   "else",
   "<mask>",
   "(",
   "0",
   ",",
   "r",
   ")",
   "g",
   "=",
   "1",
   "if",
   "g",
   ">",
   "1",
   "else",
   "max",
   "(",
   "0",
   ",",
   "g",
   ")",
   "b",
   "=",
   "1",
   "if",
   "b",
   ">",
   "1",
   "else",
   "max",
   "(",
   "0",
   ",",
   "b",
   ")",
   "return",
   "round",
   "(",
   "r",
   "*",
   "255",
   ",",
   "3",
   ")",
   ",",
   "round",
   "(",
   "g",
   "*",
   "255",
   ",",
   "3",
   ")",
   ",",
   "round",
   "(",
   "b",
   "*",
   "255",
   ",",
   "3",
   ")"
  ]
 },
 {
  "idx": "maxmin-713",
  "nl_tokens": [
   "Return",
   "the",
   "position",
   "fingerprint",
   "."
  ],
  "pl_tokens": [
   "def",
   "fingerprint",
   "(",
   "self",
   ",",
   "word",
   ",",
   "n_bits",
   "=",
   "16",
   ",",
   "most_common",
   "=",
   "MOST_COMMON_LETTERS_CG",
   ",",
   "bits_per_letter",
   "=",
   "3",
   ",",
   ")",
   ":",
   "position",
   "=",
   "{",
   "}",
   "for",
   "pos",
   ",",
   "letter",
   "in",
   "enumerate",
   "(",
   "word",
   ")",
   ":",
   "if",
   "letter",
   "not",
   "in",
   "position",
   "and",
   "letter",
   "in",
   "most_common",
   ":",
   "position",
   "[",
   "letter",
   "]",
   "=",
   "<mask>",
   "(",
   "pos",
   ",",
   "2",
   "**",
   "bits_per_letter",
   "-",
   "1",
   ")",
   "fingerprint",
   "=",
   "0",
   "for",
   "letter",
   "in",
   "most_common",
   ":",
   "if",
   "n_bits",
   ":",
   "fingerprint",
   "<<=",
   "min",
   "(",
   "bits_per_letter",
   ",",
   "n_bits",
   ")",
   "if",
   "letter",
   "in",
   "position",
   ":",
   "fingerprint",
   "+=",
   "min",
   "(",
   "position",
   "[",
   "letter",
   "]",
   ",",
   "2",
   "**",
   "n_bits",
   "-",
   "1",
   ")",
   "else",
   ":",
   "fingerprint",
   "+=",
   "min",
   "(",
   "2",
   "**",
   "bits_per_letter",
   "-",
   "1",
   ",",
   "2",
   "**",
   "n_bits",
   "-",
   "1",
   ")",
   "n_bits",
   "-=",
   "min",
   "(",
   "bits_per_letter",
   ",",
   "n_bits",
   ")",
   "else",
   ":",
   "break",
   "for",
   "_",
   "in",
   "range",
   "(",
   "n_bits",
   ")",
   ":",
   "fingerprint",
   "<<=",
   "1",
   "fingerprint",
   "+=",
   "1",
   "return",
   "fingerprint"
  ]
 },
 {
  "idx": "maxmin-714",
  "nl_tokens": [
   "Generates",
   "a",
   "confusion",
   "matrix",
   "between",
   "rater_a",
   "and",
   "rater_b",
   "A",
   "confusion",
   "matrix",
   "shows",
   "how",
   "often",
   "2",
   "values",
   "agree",
   "and",
   "disagree",
   "See",
   "quadratic_weighted_kappa",
   "for",
   "argument",
   "descriptions"
  ],
  "pl_tokens": [
   "def",
   "confusion_matrix",
   "(",
   "rater_a",
   ",",
   "rater_b",
   ",",
   "min_rating",
   "=",
   "None",
   ",",
   "max_rating",
   "=",
   "None",
   ")",
   ":",
   "assert",
   "(",
   "len",
   "(",
   "rater_a",
   ")",
   "==",
   "len",
   "(",
   "rater_b",
   ")",
   ")",
   "rater_a",
   "=",
   "[",
   "int",
   "(",
   "a",
   ")",
   "for",
   "a",
   "in",
   "rater_a",
   "]",
   "rater_b",
   "=",
   "[",
   "int",
   "(",
   "b",
   ")",
   "for",
   "b",
   "in",
   "rater_b",
   "]",
   "min_rating",
   "=",
   "int",
   "(",
   "min_rating",
   ")",
   "max_rating",
   "=",
   "int",
   "(",
   "max_rating",
   ")",
   "if",
   "min_rating",
   "is",
   "None",
   ":",
   "min_rating",
   "=",
   "<mask>",
   "(",
   "rater_a",
   ")",
   "if",
   "max_rating",
   "is",
   "None",
   ":",
   "max_rating",
   "=",
   "max",
   "(",
   "rater_a",
   ")",
   "num_ratings",
   "=",
   "int",
   "(",
   "max_rating",
   "-",
   "min_rating",
   "+",
   "1",
   ")",
   "conf_mat",
   "=",
   "[",
   "[",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "num_ratings",
   ")",
   "]",
   "for",
   "j",
   "in",
   "range",
   "(",
   "num_ratings",
   ")",
   "]",
   "for",
   "a",
   ",",
   "b",
   "in",
   "zip",
   "(",
   "rater_a",
   ",",
   "rater_b",
   ")",
   ":",
   "conf_mat",
   "[",
   "int",
   "(",
   "a",
   "-",
   "min_rating",
   ")",
   "]",
   "[",
   "int",
   "(",
   "b",
   "-",
   "min_rating",
   ")",
   "]",
   "+=",
   "1",
   "return",
   "conf_mat"
  ]
 },
 {
  "idx": "maxmin-715",
  "nl_tokens": [
   "Creates",
   "nDesiredNewSynapes",
   "synapses",
   "on",
   "the",
   "segment",
   "passed",
   "in",
   "if",
   "possible",
   "choosing",
   "random",
   "cells",
   "from",
   "the",
   "previous",
   "winner",
   "cells",
   "that",
   "are",
   "not",
   "already",
   "on",
   "the",
   "segment",
   "."
  ],
  "pl_tokens": [
   "def",
   "_growSynapses",
   "(",
   "cls",
   ",",
   "connections",
   ",",
   "random",
   ",",
   "segment",
   ",",
   "nDesiredNewSynapes",
   ",",
   "prevWinnerCells",
   ",",
   "initialPermanence",
   ",",
   "maxSynapsesPerSegment",
   ")",
   ":",
   "candidates",
   "=",
   "list",
   "(",
   "prevWinnerCells",
   ")",
   "for",
   "synapse",
   "in",
   "connections",
   ".",
   "synapsesForSegment",
   "(",
   "segment",
   ")",
   ":",
   "i",
   "=",
   "binSearch",
   "(",
   "candidates",
   ",",
   "synapse",
   ".",
   "presynapticCell",
   ")",
   "if",
   "i",
   "!=",
   "-",
   "1",
   ":",
   "del",
   "candidates",
   "[",
   "i",
   "]",
   "nActual",
   "=",
   "<mask>",
   "(",
   "nDesiredNewSynapes",
   ",",
   "len",
   "(",
   "candidates",
   ")",
   ")",
   "# Check if we're going to surpass the maximum number of synapses.",
   "overrun",
   "=",
   "connections",
   ".",
   "numSynapses",
   "(",
   "segment",
   ")",
   "+",
   "nActual",
   "-",
   "maxSynapsesPerSegment",
   "if",
   "overrun",
   ">",
   "0",
   ":",
   "cls",
   ".",
   "_destroyMinPermanenceSynapses",
   "(",
   "connections",
   ",",
   "random",
   ",",
   "segment",
   ",",
   "overrun",
   ",",
   "prevWinnerCells",
   ")",
   "# Recalculate in case we weren't able to destroy as many synapses as needed.",
   "nActual",
   "=",
   "min",
   "(",
   "nActual",
   ",",
   "maxSynapsesPerSegment",
   "-",
   "connections",
   ".",
   "numSynapses",
   "(",
   "segment",
   ")",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "nActual",
   ")",
   ":",
   "i",
   "=",
   "random",
   ".",
   "getUInt32",
   "(",
   "len",
   "(",
   "candidates",
   ")",
   ")",
   "connections",
   ".",
   "createSynapse",
   "(",
   "segment",
   ",",
   "candidates",
   "[",
   "i",
   "]",
   ",",
   "initialPermanence",
   ")",
   "del",
   "candidates",
   "[",
   "i",
   "]"
  ]
 },
 {
  "idx": "maxmin-716",
  "nl_tokens": [
   "Crops",
   "img",
   "as",
   "much",
   "as",
   "possible"
  ],
  "pl_tokens": [
   "def",
   "crop_img",
   "(",
   "image",
   ",",
   "rtol",
   "=",
   "1e-8",
   ",",
   "copy",
   "=",
   "True",
   ")",
   ":",
   "img",
   "=",
   "check_img",
   "(",
   "image",
   ")",
   "data",
   "=",
   "img",
   ".",
   "get_data",
   "(",
   ")",
   "infinity_norm",
   "=",
   "<mask>",
   "(",
   "-",
   "data",
   ".",
   "min",
   "(",
   ")",
   ",",
   "data",
   ".",
   "max",
   "(",
   ")",
   ")",
   "passes_threshold",
   "=",
   "np",
   ".",
   "logical_or",
   "(",
   "data",
   "<",
   "-",
   "rtol",
   "*",
   "infinity_norm",
   ",",
   "data",
   ">",
   "rtol",
   "*",
   "infinity_norm",
   ")",
   "if",
   "data",
   ".",
   "ndim",
   "==",
   "4",
   ":",
   "passes_threshold",
   "=",
   "np",
   ".",
   "any",
   "(",
   "passes_threshold",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "coords",
   "=",
   "np",
   ".",
   "array",
   "(",
   "np",
   ".",
   "where",
   "(",
   "passes_threshold",
   ")",
   ")",
   "start",
   "=",
   "coords",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "end",
   "=",
   "coords",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "+",
   "1",
   "# pad with one voxel to avoid resampling problems",
   "start",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "start",
   "-",
   "1",
   ",",
   "0",
   ")",
   "end",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "end",
   "+",
   "1",
   ",",
   "data",
   ".",
   "shape",
   "[",
   ":",
   "3",
   "]",
   ")",
   "slices",
   "=",
   "[",
   "slice",
   "(",
   "s",
   ",",
   "e",
   ")",
   "for",
   "s",
   ",",
   "e",
   "in",
   "zip",
   "(",
   "start",
   ",",
   "end",
   ")",
   "]",
   "return",
   "_crop_img_to",
   "(",
   "img",
   ",",
   "slices",
   ",",
   "copy",
   "=",
   "copy",
   ")"
  ]
 },
 {
  "idx": "maxmin-717",
  "nl_tokens": [
   "Decode",
   "geohash",
   "returning",
   "two",
   "strings",
   "with",
   "latitude",
   "and",
   "longitude",
   "containing",
   "only",
   "relevant",
   "digits",
   "and",
   "with",
   "trailing",
   "zeroes",
   "removed",
   "."
  ],
  "pl_tokens": [
   "def",
   "decode",
   "(",
   "geohash",
   ")",
   ":",
   "lat",
   ",",
   "lon",
   ",",
   "lat_err",
   ",",
   "lon_err",
   "=",
   "decode_exactly",
   "(",
   "geohash",
   ")",
   "# Format to the number of decimals that are known",
   "lats",
   "=",
   "\"%.*f\"",
   "%",
   "(",
   "<mask>",
   "(",
   "1",
   ",",
   "int",
   "(",
   "round",
   "(",
   "-",
   "log10",
   "(",
   "lat_err",
   ")",
   ")",
   ")",
   ")",
   "-",
   "1",
   ",",
   "lat",
   ")",
   "lons",
   "=",
   "\"%.*f\"",
   "%",
   "(",
   "max",
   "(",
   "1",
   ",",
   "int",
   "(",
   "round",
   "(",
   "-",
   "log10",
   "(",
   "lon_err",
   ")",
   ")",
   ")",
   ")",
   "-",
   "1",
   ",",
   "lon",
   ")",
   "if",
   "'.'",
   "in",
   "lats",
   ":",
   "lats",
   "=",
   "lats",
   ".",
   "rstrip",
   "(",
   "'0'",
   ")",
   "if",
   "'.'",
   "in",
   "lons",
   ":",
   "lons",
   "=",
   "lons",
   ".",
   "rstrip",
   "(",
   "'0'",
   ")",
   "return",
   "lats",
   ",",
   "lons"
  ]
 },
 {
  "idx": "maxmin-718",
  "nl_tokens": [
   "r",
   "Solves",
   "the",
   "objective",
   "function",
   "of",
   "the",
   "Li",
   "-",
   "Johns",
   "-",
   "Ahmadi",
   "flash",
   "equation",
   ".",
   "Uses",
   "the",
   "method",
   "proposed",
   "in",
   "[",
   "1",
   "]",
   "_",
   "to",
   "obtain",
   "an",
   "initial",
   "guess",
   "."
  ],
  "pl_tokens": [
   "def",
   "Li_Johns_Ahmadi_solution",
   "(",
   "zs",
   ",",
   "Ks",
   ")",
   ":",
   "# Re-order both Ks and Zs by K value, higher coming first",
   "p",
   "=",
   "sorted",
   "(",
   "zip",
   "(",
   "Ks",
   ",",
   "zs",
   ")",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "Ks_sorted",
   ",",
   "zs_sorted",
   "=",
   "[",
   "K",
   "for",
   "(",
   "K",
   ",",
   "z",
   ")",
   "in",
   "p",
   "]",
   ",",
   "[",
   "z",
   "for",
   "(",
   "K",
   ",",
   "z",
   ")",
   "in",
   "p",
   "]",
   "# Largest K value and corresponding overall mole fraction",
   "k1",
   "=",
   "Ks_sorted",
   "[",
   "0",
   "]",
   "z1",
   "=",
   "zs_sorted",
   "[",
   "0",
   "]",
   "# Smallest K value",
   "kn",
   "=",
   "Ks_sorted",
   "[",
   "-",
   "1",
   "]",
   "x_min",
   "=",
   "(",
   "1.",
   "-",
   "kn",
   ")",
   "/",
   "(",
   "k1",
   "-",
   "kn",
   ")",
   "*",
   "z1",
   "x_max",
   "=",
   "(",
   "1.",
   "-",
   "kn",
   ")",
   "/",
   "(",
   "k1",
   "-",
   "kn",
   ")",
   "x_min2",
   "=",
   "<mask>",
   "(",
   "0.",
   ",",
   "x_min",
   ")",
   "x_max2",
   "=",
   "min",
   "(",
   "1.",
   ",",
   "x_max",
   ")",
   "x_guess",
   "=",
   "(",
   "x_min2",
   "+",
   "x_max2",
   ")",
   "*",
   "0.5",
   "length",
   "=",
   "len",
   "(",
   "zs",
   ")",
   "-",
   "1",
   "kn_m_1",
   "=",
   "kn",
   "-",
   "1.",
   "k1_m_1",
   "=",
   "(",
   "k1",
   "-",
   "1.",
   ")",
   "t1",
   "=",
   "(",
   "k1",
   "-",
   "kn",
   ")",
   "/",
   "(",
   "kn",
   "-",
   "1.",
   ")",
   "objective",
   "=",
   "lambda",
   "x1",
   ":",
   "1.",
   "+",
   "t1",
   "*",
   "x1",
   "+",
   "sum",
   "(",
   "[",
   "(",
   "ki",
   "-",
   "kn",
   ")",
   "/",
   "(",
   "kn_m_1",
   ")",
   "*",
   "zi",
   "*",
   "k1_m_1",
   "*",
   "x1",
   "/",
   "(",
   "(",
   "ki",
   "-",
   "1.",
   ")",
   "*",
   "z1",
   "+",
   "(",
   "k1",
   "-",
   "ki",
   ")",
   "*",
   "x1",
   ")",
   "for",
   "ki",
   ",",
   "zi",
   "in",
   "zip",
   "(",
   "Ks_sorted",
   "[",
   "1",
   ":",
   "length",
   "]",
   ",",
   "zs_sorted",
   "[",
   "1",
   ":",
   "length",
   "]",
   ")",
   "]",
   ")",
   "try",
   ":",
   "x1",
   "=",
   "newton",
   "(",
   "objective",
   ",",
   "x_guess",
   ")",
   "# newton skips out of its specified range in some cases, finding another solution",
   "# Check for that with asserts, and use brenth if it did",
   "# Must also check that V_over_F is right.",
   "assert",
   "x1",
   ">=",
   "x_min2",
   "assert",
   "x1",
   "<=",
   "x_max2",
   "V_over_F",
   "=",
   "(",
   "-",
   "x1",
   "+",
   "z1",
   ")",
   "/",
   "(",
   "x1",
   "*",
   "(",
   "k1",
   "-",
   "1.",
   ")",
   ")",
   "assert",
   "0",
   "<=",
   "V_over_F",
   "<=",
   "1",
   "except",
   ":",
   "x1",
   "=",
   "brenth",
   "(",
   "objective",
   ",",
   "x_min",
   ",",
   "x_max",
   ")",
   "V_over_F",
   "=",
   "(",
   "-",
   "x1",
   "+",
   "z1",
   ")",
   "/",
   "(",
   "x1",
   "*",
   "(",
   "k1",
   "-",
   "1.",
   ")",
   ")",
   "xs",
   "=",
   "[",
   "zi",
   "/",
   "(",
   "1.",
   "+",
   "V_over_F",
   "*",
   "(",
   "Ki",
   "-",
   "1.",
   ")",
   ")",
   "for",
   "zi",
   ",",
   "Ki",
   "in",
   "zip",
   "(",
   "zs",
   ",",
   "Ks",
   ")",
   "]",
   "ys",
   "=",
   "[",
   "Ki",
   "*",
   "xi",
   "for",
   "xi",
   ",",
   "Ki",
   "in",
   "zip",
   "(",
   "xs",
   ",",
   "Ks",
   ")",
   "]",
   "return",
   "V_over_F",
   ",",
   "xs",
   ",",
   "ys"
  ]
 },
 {
  "idx": "maxmin-719",
  "nl_tokens": [
   "Returns",
   "the",
   "maximum",
   "delay",
   "for",
   "the",
   "InferenceElements",
   "in",
   "the",
   "inference",
   "dictionary"
  ],
  "pl_tokens": [
   "def",
   "getMaxDelay",
   "(",
   "inferences",
   ")",
   ":",
   "maxDelay",
   "=",
   "0",
   "for",
   "inferenceElement",
   ",",
   "inference",
   "in",
   "inferences",
   ".",
   "iteritems",
   "(",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "inference",
   ",",
   "dict",
   ")",
   ":",
   "for",
   "key",
   "in",
   "inference",
   ".",
   "iterkeys",
   "(",
   ")",
   ":",
   "maxDelay",
   "=",
   "<mask>",
   "(",
   "InferenceElement",
   ".",
   "getTemporalDelay",
   "(",
   "inferenceElement",
   ",",
   "key",
   ")",
   ",",
   "maxDelay",
   ")",
   "else",
   ":",
   "maxDelay",
   "=",
   "max",
   "(",
   "InferenceElement",
   ".",
   "getTemporalDelay",
   "(",
   "inferenceElement",
   ")",
   ",",
   "maxDelay",
   ")",
   "return",
   "maxDelay"
  ]
 },
 {
  "idx": "maxmin-720",
  "nl_tokens": [
   "Validate",
   "a",
   "set",
   "of",
   "samples",
   "for",
   "equality",
   "and",
   "inequality",
   "feasibility",
   "."
  ],
  "pl_tokens": [
   "def",
   "validate",
   "(",
   "self",
   ",",
   "samples",
   ")",
   ":",
   "samples",
   "=",
   "np",
   ".",
   "atleast_2d",
   "(",
   "samples",
   ")",
   "prob",
   "=",
   "self",
   ".",
   "problem",
   "if",
   "samples",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "==",
   "len",
   "(",
   "self",
   ".",
   "model",
   ".",
   "reactions",
   ")",
   ":",
   "S",
   "=",
   "create_stoichiometric_matrix",
   "(",
   "self",
   ".",
   "model",
   ")",
   "b",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "self",
   ".",
   "model",
   ".",
   "constraints",
   "[",
   "m",
   ".",
   "id",
   "]",
   ".",
   "lb",
   "for",
   "m",
   "in",
   "self",
   ".",
   "model",
   ".",
   "metabolites",
   "]",
   ")",
   "bounds",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "r",
   ".",
   "bounds",
   "for",
   "r",
   "in",
   "self",
   ".",
   "model",
   ".",
   "reactions",
   "]",
   ")",
   ".",
   "T",
   "elif",
   "samples",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "==",
   "len",
   "(",
   "self",
   ".",
   "model",
   ".",
   "variables",
   ")",
   ":",
   "S",
   "=",
   "prob",
   ".",
   "equalities",
   "b",
   "=",
   "prob",
   ".",
   "b",
   "bounds",
   "=",
   "prob",
   ".",
   "variable_bounds",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Wrong number of columns. samples must have a \"",
   "\"column for each flux or variable defined in the \"",
   "\"model!\"",
   ")",
   "feasibility",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "S",
   ".",
   "dot",
   "(",
   "samples",
   ".",
   "T",
   ")",
   ".",
   "T",
   "-",
   "b",
   ")",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "lb_error",
   "=",
   "(",
   "samples",
   "-",
   "bounds",
   "[",
   "0",
   ",",
   "]",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "ub_error",
   "=",
   "(",
   "bounds",
   "[",
   "1",
   ",",
   "]",
   "-",
   "samples",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "if",
   "(",
   "samples",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "==",
   "len",
   "(",
   "self",
   ".",
   "model",
   ".",
   "variables",
   ")",
   "and",
   "prob",
   ".",
   "inequalities",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ":",
   "consts",
   "=",
   "prob",
   ".",
   "inequalities",
   ".",
   "dot",
   "(",
   "samples",
   ".",
   "T",
   ")",
   "lb_error",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "lb_error",
   ",",
   "(",
   "consts",
   "-",
   "prob",
   ".",
   "bounds",
   "[",
   "0",
   ",",
   "]",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ")",
   "ub_error",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "ub_error",
   ",",
   "(",
   "prob",
   ".",
   "bounds",
   "[",
   "1",
   ",",
   "]",
   "-",
   "consts",
   ")",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ")",
   "valid",
   "=",
   "(",
   "(",
   "feasibility",
   "<",
   "self",
   ".",
   "feasibility_tol",
   ")",
   "&",
   "(",
   "lb_error",
   ">",
   "-",
   "self",
   ".",
   "bounds_tol",
   ")",
   "&",
   "(",
   "ub_error",
   ">",
   "-",
   "self",
   ".",
   "bounds_tol",
   ")",
   ")",
   "codes",
   "=",
   "np",
   ".",
   "repeat",
   "(",
   "\"\"",
   ",",
   "valid",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "dtype",
   "(",
   "(",
   "str",
   ",",
   "3",
   ")",
   ")",
   ")",
   "codes",
   "[",
   "valid",
   "]",
   "=",
   "\"v\"",
   "codes",
   "[",
   "lb_error",
   "<=",
   "-",
   "self",
   ".",
   "bounds_tol",
   "]",
   "=",
   "np",
   ".",
   "char",
   ".",
   "add",
   "(",
   "codes",
   "[",
   "lb_error",
   "<=",
   "-",
   "self",
   ".",
   "bounds_tol",
   "]",
   ",",
   "\"l\"",
   ")",
   "codes",
   "[",
   "ub_error",
   "<=",
   "-",
   "self",
   ".",
   "bounds_tol",
   "]",
   "=",
   "np",
   ".",
   "char",
   ".",
   "add",
   "(",
   "codes",
   "[",
   "ub_error",
   "<=",
   "-",
   "self",
   ".",
   "bounds_tol",
   "]",
   ",",
   "\"u\"",
   ")",
   "codes",
   "[",
   "feasibility",
   ">",
   "self",
   ".",
   "feasibility_tol",
   "]",
   "=",
   "np",
   ".",
   "char",
   ".",
   "add",
   "(",
   "codes",
   "[",
   "feasibility",
   ">",
   "self",
   ".",
   "feasibility_tol",
   "]",
   ",",
   "\"e\"",
   ")",
   "return",
   "codes"
  ]
 },
 {
  "idx": "maxmin-721",
  "nl_tokens": [
   "1",
   ".",
   "Collect",
   "all",
   "<severity",
   ">",
   "and",
   "<impact",
   "-",
   "level",
   ">",
   "values",
   ".",
   "2",
   ".",
   "Convert",
   "impact",
   "-",
   "level",
   "of",
   "1",
   "-",
   "3",
   "to",
   "MINOR",
   "4",
   "-",
   "7",
   "to",
   "MODERATE",
   "8",
   "-",
   "10",
   "to",
   "MAJOR",
   "3",
   ".",
   "Map",
   "severity",
   "-",
   ">",
   "none",
   "to",
   "MINOR",
   "natural",
   "-",
   "disaster",
   "to",
   "MAJOR",
   "other",
   "to",
   "UNKNOWN",
   "4",
   ".",
   "Pick",
   "the",
   "highest",
   "severity",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_severity",
   "(",
   "c",
   ")",
   ":",
   "severities",
   "=",
   "c",
   ".",
   "feu",
   ".",
   "xpath",
   "(",
   "'event-indicators/event-indicator/event-severity/text()|event-indicators/event-indicator/severity/text()'",
   ")",
   "impacts",
   "=",
   "c",
   ".",
   "feu",
   ".",
   "xpath",
   "(",
   "'event-indicators/event-indicator/event-impact/text()|event-indicators/event-indicator/impact/text()'",
   ")",
   "severities",
   "=",
   "[",
   "convert_severity",
   "[",
   "s",
   "]",
   "for",
   "s",
   "in",
   "severities",
   "]",
   "impacts",
   "=",
   "[",
   "convert_impact",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "impacts",
   "]",
   "return",
   "[",
   "'UNKNOWN'",
   ",",
   "'MINOR'",
   ",",
   "'MODERATE'",
   ",",
   "'MAJOR'",
   "]",
   "[",
   "<mask>",
   "(",
   "itertools",
   ".",
   "chain",
   "(",
   "severities",
   ",",
   "impacts",
   ")",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-722",
  "nl_tokens": [
   "Get",
   "the",
   "earliest",
   "date",
   "that",
   "one",
   "of",
   "the",
   "courses",
   "in",
   "the",
   "program",
   "was",
   "available",
   ".",
   "For",
   "the",
   "sake",
   "of",
   "emails",
   "to",
   "new",
   "learners",
   "we",
   "treat",
   "this",
   "as",
   "the",
   "program",
   "start",
   "date",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_earliest_start_date_from_program",
   "(",
   "program",
   ")",
   ":",
   "start_dates",
   "=",
   "[",
   "]",
   "for",
   "course",
   "in",
   "program",
   ".",
   "get",
   "(",
   "'courses'",
   ",",
   "[",
   "]",
   ")",
   ":",
   "for",
   "run",
   "in",
   "course",
   ".",
   "get",
   "(",
   "'course_runs'",
   ",",
   "[",
   "]",
   ")",
   ":",
   "if",
   "run",
   ".",
   "get",
   "(",
   "'start'",
   ")",
   ":",
   "start_dates",
   ".",
   "append",
   "(",
   "parse_lms_api_datetime",
   "(",
   "run",
   "[",
   "'start'",
   "]",
   ")",
   ")",
   "if",
   "not",
   "start_dates",
   ":",
   "return",
   "None",
   "return",
   "<mask>",
   "(",
   "start_dates",
   ")"
  ]
 },
 {
  "idx": "maxmin-723",
  "nl_tokens": [
   "Draws",
   "a",
   "weighted",
   "swatch",
   "with",
   "approximately",
   "n",
   "columns",
   "and",
   "rows",
   "."
  ],
  "pl_tokens": [
   "def",
   "swatch",
   "(",
   "self",
   ",",
   "x",
   ",",
   "y",
   ",",
   "w",
   "=",
   "35",
   ",",
   "h",
   "=",
   "35",
   ",",
   "padding",
   "=",
   "4",
   ",",
   "roundness",
   "=",
   "0",
   ",",
   "n",
   "=",
   "12",
   ",",
   "d",
   "=",
   "0.035",
   ",",
   "grouped",
   "=",
   "None",
   ")",
   ":",
   "if",
   "grouped",
   "is",
   "None",
   ":",
   "# should be True or False",
   "grouped",
   "=",
   "self",
   ".",
   "group_swatches",
   "# If we dont't need to make groups,",
   "# just display an individual column for each weight",
   "# in the (color, range, weight) tuples.",
   "if",
   "not",
   "grouped",
   ":",
   "s",
   "=",
   "sum",
   "(",
   "[",
   "wgt",
   "for",
   "clr",
   ",",
   "rng",
   ",",
   "wgt",
   "in",
   "self",
   ".",
   "ranges",
   "]",
   ")",
   "for",
   "clr",
   ",",
   "rng",
   ",",
   "wgt",
   "in",
   "self",
   ".",
   "ranges",
   ":",
   "cols",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "int",
   "(",
   "wgt",
   "/",
   "s",
   "*",
   "n",
   ")",
   ")",
   "for",
   "i",
   "in",
   "_range",
   "(",
   "cols",
   ")",
   ":",
   "rng",
   ".",
   "colors",
   "(",
   "clr",
   ",",
   "n",
   "=",
   "n",
   ",",
   "d",
   "=",
   "d",
   ")",
   ".",
   "swatch",
   "(",
   "x",
   ",",
   "y",
   ",",
   "w",
   ",",
   "h",
   ",",
   "padding",
   "=",
   "padding",
   ",",
   "roundness",
   "=",
   "roundness",
   ")",
   "x",
   "+=",
   "w",
   "+",
   "padding",
   "return",
   "x",
   ",",
   "y",
   "+",
   "n",
   "*",
   "(",
   "h",
   "+",
   "padding",
   ")",
   "# When grouped, combine hues and display them",
   "# in batches of rows, then moving on to the next hue.",
   "grouped",
   "=",
   "self",
   ".",
   "_weight_by_hue",
   "(",
   ")",
   "for",
   "total_weight",
   ",",
   "normalized_weight",
   ",",
   "hue",
   ",",
   "ranges",
   "in",
   "grouped",
   ":",
   "dy",
   "=",
   "y",
   "rc",
   "=",
   "0",
   "for",
   "clr",
   ",",
   "rng",
   ",",
   "weight",
   "in",
   "ranges",
   ":",
   "dx",
   "=",
   "x",
   "cols",
   "=",
   "int",
   "(",
   "normalized_weight",
   "*",
   "n",
   ")",
   "cols",
   "=",
   "max",
   "(",
   "1",
   ",",
   "min",
   "(",
   "cols",
   ",",
   "n",
   "-",
   "len",
   "(",
   "grouped",
   ")",
   ")",
   ")",
   "if",
   "clr",
   ".",
   "name",
   "==",
   "\"black\"",
   ":",
   "rng",
   "=",
   "rng",
   ".",
   "black",
   "if",
   "clr",
   ".",
   "name",
   "==",
   "\"white\"",
   ":",
   "rng",
   "=",
   "rng",
   ".",
   "white",
   "for",
   "i",
   "in",
   "_range",
   "(",
   "cols",
   ")",
   ":",
   "rows",
   "=",
   "int",
   "(",
   "weight",
   "/",
   "total_weight",
   "*",
   "n",
   ")",
   "rows",
   "=",
   "max",
   "(",
   "1",
   ",",
   "rows",
   ")",
   "# Each column should add up to n rows,",
   "# if not due to rounding errors, add a row at the bottom.",
   "if",
   "(",
   "clr",
   ",",
   "rng",
   ",",
   "weight",
   ")",
   "==",
   "ranges",
   "[",
   "-",
   "1",
   "]",
   "and",
   "rc",
   "+",
   "rows",
   "<",
   "n",
   ":",
   "rows",
   "+=",
   "1",
   "rng",
   ".",
   "colors",
   "(",
   "clr",
   ",",
   "n",
   "=",
   "rows",
   ",",
   "d",
   "=",
   "d",
   ")",
   ".",
   "swatch",
   "(",
   "dx",
   ",",
   "dy",
   ",",
   "w",
   ",",
   "h",
   ",",
   "padding",
   "=",
   "padding",
   ",",
   "roundness",
   "=",
   "roundness",
   ")",
   "dx",
   "+=",
   "w",
   "+",
   "padding",
   "dy",
   "+=",
   "(",
   "w",
   "+",
   "padding",
   ")",
   "*",
   "rows",
   "# + padding",
   "rc",
   "=",
   "rows",
   "x",
   "+=",
   "(",
   "w",
   "+",
   "padding",
   ")",
   "*",
   "cols",
   "+",
   "padding",
   "return",
   "x",
   ",",
   "dy"
  ]
 },
 {
  "idx": "maxmin-724",
  "nl_tokens": [
   "Return",
   "the",
   "NCD",
   "between",
   "two",
   "strings",
   "using",
   "arithmetic",
   "coding",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "probs",
   "=",
   "None",
   ")",
   ":",
   "if",
   "src",
   "==",
   "tar",
   ":",
   "return",
   "0.0",
   "if",
   "probs",
   "is",
   "None",
   ":",
   "# lacking a reasonable dictionary, train on the strings themselves",
   "self",
   ".",
   "_coder",
   ".",
   "train",
   "(",
   "src",
   "+",
   "tar",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_coder",
   ".",
   "set_probs",
   "(",
   "probs",
   ")",
   "src_comp",
   "=",
   "self",
   ".",
   "_coder",
   ".",
   "encode",
   "(",
   "src",
   ")",
   "[",
   "1",
   "]",
   "tar_comp",
   "=",
   "self",
   ".",
   "_coder",
   ".",
   "encode",
   "(",
   "tar",
   ")",
   "[",
   "1",
   "]",
   "concat_comp",
   "=",
   "self",
   ".",
   "_coder",
   ".",
   "encode",
   "(",
   "src",
   "+",
   "tar",
   ")",
   "[",
   "1",
   "]",
   "concat_comp2",
   "=",
   "self",
   ".",
   "_coder",
   ".",
   "encode",
   "(",
   "tar",
   "+",
   "src",
   ")",
   "[",
   "1",
   "]",
   "return",
   "(",
   "<mask>",
   "(",
   "concat_comp",
   ",",
   "concat_comp2",
   ")",
   "-",
   "min",
   "(",
   "src_comp",
   ",",
   "tar_comp",
   ")",
   ")",
   "/",
   "max",
   "(",
   "src_comp",
   ",",
   "tar_comp",
   ")"
  ]
 },
 {
  "idx": "maxmin-725",
  "nl_tokens": [
   "Convert",
   "reflection",
   "coefficients",
   "to",
   "inverse",
   "sine",
   "parameters",
   "."
  ],
  "pl_tokens": [
   "def",
   "rc2is",
   "(",
   "k",
   ")",
   ":",
   "assert",
   "numpy",
   ".",
   "isrealobj",
   "(",
   "k",
   ")",
   ",",
   "'Inverse sine parameters not defined for complex reflection coefficients.'",
   "if",
   "<mask>",
   "(",
   "numpy",
   ".",
   "abs",
   "(",
   "k",
   ")",
   ")",
   ">=",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "'All reflection coefficients should have magnitude less than unity.'",
   ")",
   "return",
   "(",
   "2",
   "/",
   "numpy",
   ".",
   "pi",
   ")",
   "*",
   "numpy",
   ".",
   "arcsin",
   "(",
   "k",
   ")"
  ]
 },
 {
  "idx": "maxmin-726",
  "nl_tokens": [
   "function",
   "that",
   "takes",
   "a",
   "dictionary",
   "mapping",
   "names",
   "to",
   "sequences",
   "and",
   "a",
   "locus",
   "number",
   "and",
   "writes",
   "it",
   "as",
   "a",
   "NEXUS",
   "file",
   "with",
   "a",
   "mrbayes",
   "analysis",
   "block",
   "."
  ],
  "pl_tokens": [
   "def",
   "nexmake",
   "(",
   "mdict",
   ",",
   "nlocus",
   ",",
   "dirs",
   ",",
   "mcmc_burnin",
   ",",
   "mcmc_ngen",
   ",",
   "mcmc_sample_freq",
   ")",
   ":",
   "## create matrix as a string",
   "max_name_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "mdict",
   "]",
   ")",
   "namestring",
   "=",
   "\"{:<\"",
   "+",
   "str",
   "(",
   "max_name_len",
   "+",
   "1",
   ")",
   "+",
   "\"} {}\\n\"",
   "matrix",
   "=",
   "\"\"",
   "for",
   "i",
   "in",
   "mdict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "matrix",
   "+=",
   "namestring",
   ".",
   "format",
   "(",
   "i",
   "[",
   "0",
   "]",
   ",",
   "i",
   "[",
   "1",
   "]",
   ")",
   "## write nexus block",
   "handle",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "dirs",
   ",",
   "\"{}.nex\"",
   ".",
   "format",
   "(",
   "nlocus",
   ")",
   ")",
   "with",
   "open",
   "(",
   "handle",
   ",",
   "'w'",
   ")",
   "as",
   "outnex",
   ":",
   "outnex",
   ".",
   "write",
   "(",
   "NEXBLOCK",
   ".",
   "format",
   "(",
   "*",
   "*",
   "{",
   "\"ntax\"",
   ":",
   "len",
   "(",
   "mdict",
   ")",
   ",",
   "\"nchar\"",
   ":",
   "len",
   "(",
   "mdict",
   ".",
   "values",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ",",
   "\"matrix\"",
   ":",
   "matrix",
   ",",
   "\"ngen\"",
   ":",
   "mcmc_ngen",
   ",",
   "\"sfreq\"",
   ":",
   "mcmc_sample_freq",
   ",",
   "\"burnin\"",
   ":",
   "mcmc_burnin",
   ",",
   "}",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-727",
  "nl_tokens": [
   "Gets",
   "the",
   "list",
   "of",
   "operations",
   "for",
   "the",
   "specified",
   "filter",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "cls",
   ",",
   "service",
   ",",
   "ops_filter",
   ",",
   "page_size",
   "=",
   "0",
   ")",
   ":",
   "page_token",
   "=",
   "None",
   "more_operations",
   "=",
   "True",
   "documented_default_page_size",
   "=",
   "256",
   "documented_max_page_size",
   "=",
   "2048",
   "if",
   "not",
   "page_size",
   ":",
   "page_size",
   "=",
   "documented_default_page_size",
   "page_size",
   "=",
   "<mask>",
   "(",
   "page_size",
   ",",
   "documented_max_page_size",
   ")",
   "while",
   "more_operations",
   ":",
   "api",
   "=",
   "service",
   ".",
   "operations",
   "(",
   ")",
   ".",
   "list",
   "(",
   "name",
   "=",
   "'operations'",
   ",",
   "filter",
   "=",
   "ops_filter",
   ",",
   "pageToken",
   "=",
   "page_token",
   ",",
   "pageSize",
   "=",
   "page_size",
   ")",
   "response",
   "=",
   "google_base",
   ".",
   "Api",
   ".",
   "execute",
   "(",
   "api",
   ")",
   "ops",
   "=",
   "response",
   ".",
   "get",
   "(",
   "'operations'",
   ",",
   "[",
   "]",
   ")",
   "for",
   "op",
   "in",
   "ops",
   ":",
   "if",
   "cls",
   ".",
   "is_dsub_operation",
   "(",
   "op",
   ")",
   ":",
   "yield",
   "GoogleOperation",
   "(",
   "op",
   ")",
   "page_token",
   "=",
   "response",
   ".",
   "get",
   "(",
   "'nextPageToken'",
   ")",
   "more_operations",
   "=",
   "bool",
   "(",
   "page_token",
   ")"
  ]
 },
 {
  "idx": "maxmin-728",
  "nl_tokens": [
   "Paginate",
   "an",
   "iterable",
   "during",
   "a",
   "request",
   "."
  ],
  "pl_tokens": [
   "def",
   "paginate",
   "(",
   "request",
   ",",
   "response",
   ",",
   "items",
   ")",
   ":",
   "# TODO: support dynamic rangewords and page lengths",
   "# TODO: support multi-part range requests",
   "# Get the header",
   "header",
   "=",
   "request",
   ".",
   "headers",
   ".",
   "get",
   "(",
   "'Range'",
   ")",
   "if",
   "not",
   "header",
   ":",
   "# No range header; move along.",
   "return",
   "items",
   "# do some validation",
   "prefix",
   "=",
   "RANGE_SPECIFIER",
   "+",
   "'='",
   "if",
   "not",
   "header",
   ".",
   "find",
   "(",
   "prefix",
   ")",
   "==",
   "0",
   ":",
   "# This is not using a range specifier that we understand",
   "raise",
   "exceptions",
   ".",
   "RequestedRangeNotSatisfiable",
   "(",
   ")",
   "else",
   ":",
   "# Chop the prefix off the header and parse it",
   "ranges",
   "=",
   "parse",
   "(",
   "header",
   "[",
   "len",
   "(",
   "prefix",
   ")",
   ":",
   "]",
   ")",
   "ranges",
   "=",
   "list",
   "(",
   "ranges",
   ")",
   "if",
   "len",
   "(",
   "ranges",
   ")",
   ">",
   "1",
   ":",
   "raise",
   "exceptions",
   ".",
   "RequestedRangeNotSatisfiable",
   "(",
   "'Multiple ranges in a single request is not yet supported.'",
   ")",
   "start",
   ",",
   "end",
   "=",
   "ranges",
   "[",
   "0",
   "]",
   "# Make sure the length is not higher than the total number allowed.",
   "max_length",
   "=",
   "request",
   ".",
   "resource",
   ".",
   "count",
   "(",
   "items",
   ")",
   "end",
   "=",
   "<mask>",
   "(",
   "end",
   ",",
   "max_length",
   ")",
   "response",
   ".",
   "status",
   "=",
   "client",
   ".",
   "PARTIAL_CONTENT",
   "response",
   ".",
   "headers",
   "[",
   "'Content-Range'",
   "]",
   "=",
   "'%d-%d/%d'",
   "%",
   "(",
   "start",
   ",",
   "end",
   ",",
   "max_length",
   ")",
   "response",
   ".",
   "headers",
   "[",
   "'Accept-Ranges'",
   "]",
   "=",
   "RANGE_SPECIFIER",
   "# Splice and return the items.",
   "items",
   "=",
   "items",
   "[",
   "start",
   ":",
   "end",
   "+",
   "1",
   "]",
   "return",
   "items"
  ]
 },
 {
  "idx": "maxmin-729",
  "nl_tokens": [
   "Print",
   "up",
   "to",
   "maxCols",
   "number",
   "from",
   "a",
   "flat",
   "floating",
   "point",
   "array",
   "."
  ],
  "pl_tokens": [
   "def",
   "printColConfidence",
   "(",
   "self",
   ",",
   "aState",
   ",",
   "maxCols",
   "=",
   "20",
   ")",
   ":",
   "def",
   "formatFPRow",
   "(",
   "var",
   ")",
   ":",
   "s",
   "=",
   "''",
   "for",
   "c",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "maxCols",
   ",",
   "self",
   ".",
   "numberOfCols",
   ")",
   ")",
   ":",
   "if",
   "c",
   ">",
   "0",
   "and",
   "c",
   "%",
   "10",
   "==",
   "0",
   ":",
   "s",
   "+=",
   "'   '",
   "s",
   "+=",
   "' %5.3f'",
   "%",
   "var",
   "[",
   "c",
   "]",
   "s",
   "+=",
   "' '",
   "return",
   "s",
   "print",
   "formatFPRow",
   "(",
   "aState",
   ")"
  ]
 },
 {
  "idx": "maxmin-730",
  "nl_tokens": [
   "Checks",
   "to",
   "see",
   "if",
   "the",
   "model",
   "should",
   "exit",
   "based",
   "on",
   "the",
   "exitAfter",
   "dummy",
   "parameter"
  ],
  "pl_tokens": [
   "def",
   "__shouldSysExit",
   "(",
   "self",
   ",",
   "iteration",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_exitAfter",
   "is",
   "None",
   "or",
   "iteration",
   "<",
   "self",
   ".",
   "_exitAfter",
   ":",
   "return",
   "False",
   "results",
   "=",
   "self",
   ".",
   "_jobsDAO",
   ".",
   "modelsGetFieldsForJob",
   "(",
   "self",
   ".",
   "_jobID",
   ",",
   "[",
   "'params'",
   "]",
   ")",
   "modelIDs",
   "=",
   "[",
   "e",
   "[",
   "0",
   "]",
   "for",
   "e",
   "in",
   "results",
   "]",
   "modelNums",
   "=",
   "[",
   "json",
   ".",
   "loads",
   "(",
   "e",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ")",
   "[",
   "'structuredParams'",
   "]",
   "[",
   "'__model_num'",
   "]",
   "for",
   "e",
   "in",
   "results",
   "]",
   "sameModelNumbers",
   "=",
   "filter",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "1",
   "]",
   "==",
   "self",
   ".",
   "modelIndex",
   ",",
   "zip",
   "(",
   "modelIDs",
   ",",
   "modelNums",
   ")",
   ")",
   "firstModelID",
   "=",
   "<mask>",
   "(",
   "zip",
   "(",
   "*",
   "sameModelNumbers",
   ")",
   "[",
   "0",
   "]",
   ")",
   "return",
   "firstModelID",
   "==",
   "self",
   ".",
   "_modelID"
  ]
 },
 {
  "idx": "maxmin-731",
  "nl_tokens": [
   "See",
   "comments",
   "in",
   "base",
   "class",
   "."
  ],
  "pl_tokens": [
   "def",
   "getPosition",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "stepSize",
   "is",
   "None",
   ":",
   "return",
   "self",
   ".",
   "_position",
   "# Find nearest step",
   "numSteps",
   "=",
   "(",
   "self",
   ".",
   "_position",
   "-",
   "self",
   ".",
   "<mask>",
   ")",
   "/",
   "self",
   ".",
   "stepSize",
   "numSteps",
   "=",
   "int",
   "(",
   "round",
   "(",
   "numSteps",
   ")",
   ")",
   "position",
   "=",
   "self",
   ".",
   "min",
   "+",
   "(",
   "numSteps",
   "*",
   "self",
   ".",
   "stepSize",
   ")",
   "position",
   "=",
   "max",
   "(",
   "self",
   ".",
   "min",
   ",",
   "position",
   ")",
   "position",
   "=",
   "min",
   "(",
   "self",
   ".",
   "max",
   ",",
   "position",
   ")",
   "return",
   "position"
  ]
 },
 {
  "idx": "maxmin-732",
  "nl_tokens": [
   "Return",
   "a",
   "value",
   "check",
   "function",
   "which",
   "raises",
   "a",
   "ValueError",
   "if",
   "the",
   "supplied",
   "value",
   "when",
   "cast",
   "as",
   "type",
   "is",
   "less",
   "than",
   "min",
   "or",
   "greater",
   "than",
   "max",
   "."
  ],
  "pl_tokens": [
   "def",
   "number_range_inclusive",
   "(",
   "<mask>",
   ",",
   "max",
   ",",
   "type",
   "=",
   "float",
   ")",
   ":",
   "def",
   "checker",
   "(",
   "v",
   ")",
   ":",
   "if",
   "type",
   "(",
   "v",
   ")",
   "<",
   "min",
   "or",
   "type",
   "(",
   "v",
   ")",
   ">",
   "max",
   ":",
   "raise",
   "ValueError",
   "(",
   "v",
   ")",
   "return",
   "checker"
  ]
 },
 {
  "idx": "maxmin-733",
  "nl_tokens": [
   "Makes",
   "a",
   "naive",
   "datetime",
   ".",
   "datetime",
   "in",
   "a",
   "given",
   "time",
   "zone",
   "aware",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_aware",
   "(",
   "value",
   ",",
   "timezone",
   ")",
   ":",
   "if",
   "hasattr",
   "(",
   "timezone",
   ",",
   "'localize'",
   ")",
   "and",
   "value",
   "not",
   "in",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "<mask>",
   ",",
   "datetime",
   ".",
   "datetime",
   ".",
   "max",
   ")",
   ":",
   "# available for pytz time zones",
   "return",
   "timezone",
   ".",
   "localize",
   "(",
   "value",
   ",",
   "is_dst",
   "=",
   "None",
   ")",
   "else",
   ":",
   "# may be wrong around DST changes",
   "return",
   "value",
   ".",
   "replace",
   "(",
   "tzinfo",
   "=",
   "timezone",
   ")"
  ]
 },
 {
  "idx": "maxmin-734",
  "nl_tokens": [
   "Pickle",
   "and",
   "compress",
   "."
  ],
  "pl_tokens": [
   "def",
   "pickle",
   "(",
   "obj",
   ",",
   "filepath",
   ")",
   ":",
   "arr",
   "=",
   "pkl",
   ".",
   "dumps",
   "(",
   "obj",
   ",",
   "-",
   "1",
   ")",
   "with",
   "open",
   "(",
   "filepath",
   ",",
   "'wb'",
   ")",
   "as",
   "f",
   ":",
   "s",
   "=",
   "0",
   "while",
   "s",
   "<",
   "len",
   "(",
   "arr",
   ")",
   ":",
   "e",
   "=",
   "<mask>",
   "(",
   "s",
   "+",
   "blosc",
   ".",
   "MAX_BUFFERSIZE",
   ",",
   "len",
   "(",
   "arr",
   ")",
   ")",
   "carr",
   "=",
   "blosc",
   ".",
   "compress",
   "(",
   "arr",
   "[",
   "s",
   ":",
   "e",
   "]",
   ",",
   "typesize",
   "=",
   "8",
   ")",
   "f",
   ".",
   "write",
   "(",
   "carr",
   ")",
   "s",
   "=",
   "e"
  ]
 },
 {
  "idx": "maxmin-735",
  "nl_tokens": [
   "given",
   "a",
   "TIF",
   "taken",
   "by",
   "our",
   "cameras",
   "make",
   "it",
   "a",
   "pretty",
   "labeled",
   "JPG",
   "."
  ],
  "pl_tokens": [
   "def",
   "TIF_to_jpg",
   "(",
   "fnameTiff",
   ",",
   "overwrite",
   "=",
   "False",
   ",",
   "saveAs",
   "=",
   "\"\"",
   ")",
   ":",
   "if",
   "saveAs",
   "==",
   "\"\"",
   ":",
   "saveAs",
   "=",
   "fnameTiff",
   "+",
   "\".jpg\"",
   "if",
   "overwrite",
   "is",
   "False",
   "and",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "saveAs",
   ")",
   ":",
   "print",
   "(",
   "\"file exists, not overwriting...\"",
   ")",
   "return",
   "# load the image",
   "img",
   "=",
   "pylab",
   ".",
   "imread",
   "(",
   "fnameTiff",
   ")",
   "img",
   "=",
   "img",
   "/",
   "np",
   ".",
   "<mask>",
   "(",
   "img",
   ")",
   "# now the data is from 0 to 1",
   "# determine the old histogram",
   "hist1",
   ",",
   "bins1",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "img",
   ".",
   "ravel",
   "(",
   ")",
   ",",
   "bins",
   "=",
   "256",
   ",",
   "range",
   "=",
   "(",
   "0",
   ",",
   "1",
   ")",
   ")",
   "#pylab.plot(bins[:-1],hist)",
   "# detect darkfield by average:",
   "if",
   "np",
   ".",
   "average",
   "(",
   "img",
   ")",
   "<",
   ".2",
   ":",
   "vmin",
   "=",
   "None",
   "vmax",
   "=",
   "None",
   "msg",
   "=",
   "\" | FLU\"",
   "while",
   "np",
   ".",
   "average",
   "(",
   "img",
   ")",
   "<",
   ".5",
   ":",
   "img",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "img",
   ")",
   "msg",
   "+=",
   "\"^(.5)\"",
   "else",
   ":",
   "msg",
   "=",
   "\" | DIC\"",
   "percentile",
   "=",
   ".005",
   "vmin",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "img",
   ".",
   "ravel",
   "(",
   ")",
   ",",
   "percentile",
   ")",
   "vmax",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "img",
   ".",
   "ravel",
   "(",
   ")",
   ",",
   "100",
   "-",
   "percentile",
   ")",
   "# determine the new histogram",
   "hist2",
   ",",
   "bins2",
   "=",
   "np",
   ".",
   "histogram",
   "(",
   "img",
   ".",
   "ravel",
   "(",
   ")",
   ",",
   "bins",
   "=",
   "256",
   ",",
   "range",
   "=",
   "(",
   "0",
   ",",
   "1",
   ")",
   ")",
   "# plot it with resizing magic",
   "fig",
   "=",
   "pylab",
   ".",
   "figure",
   "(",
   "facecolor",
   "=",
   "'r'",
   ")",
   "fig",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "imshow",
   "(",
   "img",
   ",",
   "cmap",
   "=",
   "pylab",
   ".",
   "gray",
   "(",
   ")",
   ",",
   "vmin",
   "=",
   "vmin",
   ",",
   "vmax",
   "=",
   "vmax",
   ")",
   "pylab",
   ".",
   "subplots_adjust",
   "(",
   "top",
   "=",
   "1",
   ",",
   "bottom",
   "=",
   "0",
   ",",
   "right",
   "=",
   "1",
   ",",
   "left",
   "=",
   "0",
   ",",
   "hspace",
   "=",
   "0",
   ",",
   "wspace",
   "=",
   "0",
   ")",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "xaxis",
   ".",
   "set_major_locator",
   "(",
   "pylab",
   ".",
   "NullLocator",
   "(",
   ")",
   ")",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "yaxis",
   ".",
   "set_major_locator",
   "(",
   "pylab",
   ".",
   "NullLocator",
   "(",
   ")",
   ")",
   "pylab",
   ".",
   "axis",
   "(",
   "'off'",
   ")",
   "# resize it to the original size",
   "fig",
   ".",
   "set_size_inches",
   "(",
   "img",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "/",
   "100",
   ",",
   "img",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "/",
   "100",
   ")",
   "# add text",
   "msg",
   "=",
   "\"%s | %s\"",
   "%",
   "(",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "fnameTiff",
   ")",
   ",",
   "datetime",
   ".",
   "datetime",
   ".",
   "fromtimestamp",
   "(",
   "os",
   ".",
   "path",
   ".",
   "getmtime",
   "(",
   "fnameTiff",
   ")",
   ")",
   ")",
   "+",
   "msg",
   "center",
   "=",
   "10",
   "pylab",
   ".",
   "text",
   "(",
   "center",
   ",",
   "center",
   ",",
   "\"%s\"",
   "%",
   "(",
   "msg",
   ")",
   ",",
   "va",
   "=",
   "\"top\"",
   ",",
   "color",
   "=",
   "'w'",
   ",",
   "size",
   "=",
   "'small'",
   ",",
   "family",
   "=",
   "'monospace'",
   ",",
   "weight",
   "=",
   "'bold'",
   ",",
   "bbox",
   "=",
   "dict",
   "(",
   "facecolor",
   "=",
   "'k'",
   ",",
   "alpha",
   "=",
   ".5",
   ")",
   ")",
   "# add scale bar",
   "scaleWidthPx",
   "=",
   "False",
   "if",
   "\"f10\"",
   "in",
   "fnameTiff",
   ":",
   "scaleWidthPx",
   ",",
   "scaleBarText",
   "=",
   "39",
   ",",
   "\"25 um\"",
   "if",
   "\"f20\"",
   "in",
   "fnameTiff",
   ":",
   "scaleWidthPx",
   ",",
   "scaleBarText",
   "=",
   "31",
   ",",
   "\"10 um\"",
   "if",
   "scaleWidthPx",
   ":",
   "scaleBarPadding",
   "=",
   "10",
   "x2",
   ",",
   "y2",
   "=",
   "img",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "-",
   "scaleBarPadding",
   ",",
   "img",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "scaleBarPadding",
   "x1",
   ",",
   "y1",
   "=",
   "x2",
   "-",
   "scaleWidthPx",
   ",",
   "y2",
   "for",
   "offset",
   ",",
   "color",
   ",",
   "alpha",
   "in",
   "[",
   "[",
   "2",
   ",",
   "'k'",
   ",",
   ".5",
   "]",
   ",",
   "[",
   "0",
   ",",
   "'w'",
   ",",
   "1",
   "]",
   "]",
   ":",
   "pylab",
   ".",
   "plot",
   "(",
   "[",
   "x1",
   "+",
   "offset",
   ",",
   "x2",
   "+",
   "offset",
   "]",
   ",",
   "[",
   "y1",
   "+",
   "offset",
   ",",
   "y2",
   "+",
   "offset",
   "]",
   ",",
   "'-'",
   ",",
   "color",
   "=",
   "color",
   ",",
   "lw",
   "=",
   "4",
   ",",
   "alpha",
   "=",
   "alpha",
   ")",
   "pylab",
   ".",
   "text",
   "(",
   "(",
   "x1",
   "+",
   "x2",
   ")",
   "/",
   "2",
   "+",
   "offset",
   ",",
   "y1",
   "-",
   "5",
   "+",
   "offset",
   ",",
   "scaleBarText",
   ",",
   "color",
   "=",
   "color",
   ",",
   "ha",
   "=",
   "\"center\"",
   ",",
   "weight",
   "=",
   "\"bold\"",
   ",",
   "alpha",
   "=",
   "alpha",
   ",",
   "size",
   "=",
   "\"small\"",
   ",",
   "va",
   "=",
   "\"bottom\"",
   ",",
   "family",
   "=",
   "\"monospace\"",
   ")",
   "# add histogram",
   "#pylab.plot(img.shape[1]-bins1[:-1][::-1]*200,-hist1/max(hist1)*100+110,color='g')",
   "#pylab.plot(img.shape[1]-bins2[:-1][::-1]*200,-hist2/max(hist2)*100+110,color='b')",
   "#pylab.show()",
   "# save it",
   "pylab",
   ".",
   "savefig",
   "(",
   "saveAs",
   ",",
   "dpi",
   "=",
   "100",
   ")",
   "# clean up",
   "pylab",
   ".",
   "close",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-736",
  "nl_tokens": [
   "Finds",
   "the",
   "category",
   "that",
   "best",
   "matches",
   "the",
   "input",
   "pattern",
   ".",
   "Returns",
   "the",
   "winning",
   "category",
   "index",
   "as",
   "well",
   "as",
   "a",
   "distribution",
   "over",
   "all",
   "categories",
   "."
  ],
  "pl_tokens": [
   "def",
   "infer",
   "(",
   "self",
   ",",
   "inputPattern",
   ",",
   "computeScores",
   "=",
   "True",
   ",",
   "overCategories",
   "=",
   "True",
   ",",
   "partitionId",
   "=",
   "None",
   ")",
   ":",
   "# Calculate sparsity. If sparsity is too low, we do not want to run",
   "# inference with this vector",
   "sparsity",
   "=",
   "0.0",
   "if",
   "self",
   ".",
   "minSparsity",
   ">",
   "0.0",
   ":",
   "sparsity",
   "=",
   "(",
   "float",
   "(",
   "len",
   "(",
   "inputPattern",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   ")",
   ")",
   "/",
   "len",
   "(",
   "inputPattern",
   ")",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   "==",
   "0",
   "or",
   "sparsity",
   "<",
   "self",
   ".",
   "minSparsity",
   ":",
   "# No categories learned yet; i.e. first inference w/ online learning or",
   "# insufficient sparsity",
   "winner",
   "=",
   "None",
   "inferenceResult",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "1",
   ")",
   "dist",
   "=",
   "numpy",
   ".",
   "ones",
   "(",
   "1",
   ")",
   "categoryDist",
   "=",
   "numpy",
   ".",
   "ones",
   "(",
   "1",
   ")",
   "else",
   ":",
   "maxCategoryIdx",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   "inferenceResult",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "maxCategoryIdx",
   "+",
   "1",
   ")",
   "dist",
   "=",
   "self",
   ".",
   "_getDistances",
   "(",
   "inputPattern",
   ",",
   "partitionId",
   "=",
   "partitionId",
   ")",
   "validVectorCount",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_categoryList",
   ")",
   "-",
   "self",
   ".",
   "_categoryList",
   ".",
   "count",
   "(",
   "-",
   "1",
   ")",
   "# Loop through the indices of the nearest neighbors.",
   "if",
   "self",
   ".",
   "exact",
   ":",
   "# Is there an exact match in the distances?",
   "exactMatches",
   "=",
   "numpy",
   ".",
   "where",
   "(",
   "dist",
   "<",
   "0.00001",
   ")",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "exactMatches",
   ")",
   ">",
   "0",
   ":",
   "for",
   "i",
   "in",
   "exactMatches",
   "[",
   ":",
   "min",
   "(",
   "self",
   ".",
   "k",
   ",",
   "validVectorCount",
   ")",
   "]",
   ":",
   "inferenceResult",
   "[",
   "self",
   ".",
   "_categoryList",
   "[",
   "i",
   "]",
   "]",
   "+=",
   "1.0",
   "else",
   ":",
   "sorted",
   "=",
   "dist",
   ".",
   "argsort",
   "(",
   ")",
   "for",
   "j",
   "in",
   "sorted",
   "[",
   ":",
   "min",
   "(",
   "self",
   ".",
   "k",
   ",",
   "validVectorCount",
   ")",
   "]",
   ":",
   "inferenceResult",
   "[",
   "self",
   ".",
   "_categoryList",
   "[",
   "j",
   "]",
   "]",
   "+=",
   "1.0",
   "# Prepare inference results.",
   "if",
   "inferenceResult",
   ".",
   "any",
   "(",
   ")",
   ":",
   "winner",
   "=",
   "inferenceResult",
   ".",
   "argmax",
   "(",
   ")",
   "inferenceResult",
   "/=",
   "inferenceResult",
   ".",
   "sum",
   "(",
   ")",
   "else",
   ":",
   "winner",
   "=",
   "None",
   "categoryDist",
   "=",
   "min_score_per_category",
   "(",
   "maxCategoryIdx",
   ",",
   "self",
   ".",
   "_categoryList",
   ",",
   "dist",
   ")",
   "categoryDist",
   ".",
   "clip",
   "(",
   "0",
   ",",
   "1.0",
   ",",
   "categoryDist",
   ")",
   "if",
   "self",
   ".",
   "verbosity",
   ">=",
   "1",
   ":",
   "print",
   "\"%s infer:\"",
   "%",
   "(",
   "g_debugPrefix",
   ")",
   "print",
   "\"  active inputs:\"",
   ",",
   "_labeledInput",
   "(",
   "inputPattern",
   ",",
   "cellsPerCol",
   "=",
   "self",
   ".",
   "cellsPerCol",
   ")",
   "print",
   "\"  winner category:\"",
   ",",
   "winner",
   "print",
   "\"  pct neighbors of each category:\"",
   ",",
   "inferenceResult",
   "print",
   "\"  dist of each prototype:\"",
   ",",
   "dist",
   "print",
   "\"  dist of each category:\"",
   ",",
   "categoryDist",
   "result",
   "=",
   "(",
   "winner",
   ",",
   "inferenceResult",
   ",",
   "dist",
   ",",
   "categoryDist",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-737",
  "nl_tokens": [
   "Shift",
   "the",
   "channels",
   "of",
   "images",
   "with",
   "the",
   "same",
   "arguments",
   "randomly",
   "or",
   "non",
   "-",
   "randomly",
   "see",
   "numpy",
   ".",
   "rollaxis",
   "<https",
   ":",
   "//",
   "docs",
   ".",
   "scipy",
   ".",
   "org",
   "/",
   "doc",
   "/",
   "numpy",
   "/",
   "reference",
   "/",
   "generated",
   "/",
   "numpy",
   ".",
   "rollaxis",
   ".",
   "html",
   ">",
   "__",
   ".",
   "Usually",
   "be",
   "used",
   "for",
   "image",
   "segmentation",
   "which",
   "x",
   "=",
   "[",
   "X",
   "Y",
   "]",
   "X",
   "and",
   "Y",
   "should",
   "be",
   "matched",
   "."
  ],
  "pl_tokens": [
   "def",
   "channel_shift_multi",
   "(",
   "x",
   ",",
   "intensity",
   ",",
   "is_random",
   "=",
   "False",
   ",",
   "channel_index",
   "=",
   "2",
   ")",
   ":",
   "if",
   "is_random",
   ":",
   "factor",
   "=",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "-",
   "intensity",
   ",",
   "intensity",
   ")",
   "else",
   ":",
   "factor",
   "=",
   "intensity",
   "results",
   "=",
   "[",
   "]",
   "for",
   "data",
   "in",
   "x",
   ":",
   "data",
   "=",
   "np",
   ".",
   "rollaxis",
   "(",
   "data",
   ",",
   "channel_index",
   ",",
   "0",
   ")",
   "min_x",
   ",",
   "max_x",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "data",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "data",
   ")",
   "channel_images",
   "=",
   "[",
   "np",
   ".",
   "clip",
   "(",
   "x_channel",
   "+",
   "factor",
   ",",
   "min_x",
   ",",
   "max_x",
   ")",
   "for",
   "x_channel",
   "in",
   "x",
   "]",
   "data",
   "=",
   "np",
   ".",
   "stack",
   "(",
   "channel_images",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "data",
   "=",
   "np",
   ".",
   "rollaxis",
   "(",
   "x",
   ",",
   "0",
   ",",
   "channel_index",
   "+",
   "1",
   ")",
   "results",
   ".",
   "append",
   "(",
   "data",
   ")",
   "return",
   "np",
   ".",
   "asarray",
   "(",
   "results",
   ")"
  ]
 },
 {
  "idx": "maxmin-738",
  "nl_tokens": [
   "implements",
   "30",
   "/",
   "360",
   "Day",
   "Count",
   "Convention",
   "(",
   "4",
   ".",
   "16",
   "(",
   "f",
   ")",
   "2006",
   "ISDA",
   "Definitions",
   ")"
  ],
  "pl_tokens": [
   "def",
   "get_30_360",
   "(",
   "self",
   ",",
   "end",
   ")",
   ":",
   "start_day",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "day",
   ",",
   "30",
   ")",
   "end_day",
   "=",
   "30",
   "if",
   "(",
   "start_day",
   "==",
   "30",
   "and",
   "end",
   ".",
   "day",
   "==",
   "31",
   ")",
   "else",
   "end",
   ".",
   "day",
   "return",
   "(",
   "360",
   "*",
   "(",
   "end",
   ".",
   "year",
   "-",
   "self",
   ".",
   "year",
   ")",
   "+",
   "30",
   "*",
   "(",
   "end",
   ".",
   "month",
   "-",
   "self",
   ".",
   "month",
   ")",
   "+",
   "(",
   "end_day",
   "-",
   "start_day",
   ")",
   ")",
   "/",
   "360.0"
  ]
 },
 {
  "idx": "maxmin-739",
  "nl_tokens": [
   "signature",
   "..."
  ],
  "pl_tokens": [
   "def",
   "tree_panel_plot",
   "(",
   "ttree",
   ",",
   "print_args",
   "=",
   "False",
   ",",
   "*",
   "args",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "## create Panel plot object and set height & width",
   "panel",
   "=",
   "Panel",
   "(",
   "ttree",
   ")",
   "#tree, edges, verts, names)",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"width\"",
   ")",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"width\"",
   "]",
   "=",
   "<mask>",
   "(",
   "1000",
   ",",
   "25",
   "*",
   "len",
   "(",
   "panel",
   ".",
   "tree",
   ")",
   ")",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"height\"",
   ")",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"height\"",
   "]",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"width\"",
   "]",
   "## update defaults with kwargs & update size based on ntips & ntests",
   "panel",
   ".",
   "kwargs",
   ".",
   "update",
   "(",
   "kwargs",
   ")",
   "## magic node label arguments overrides others",
   "if",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"show_node_support\"",
   "]",
   ":",
   "nnodes",
   "=",
   "sum",
   "(",
   "1",
   "for",
   "i",
   "in",
   "panel",
   ".",
   "tree",
   ".",
   "traverse",
   "(",
   ")",
   ")",
   "-",
   "len",
   "(",
   "panel",
   ".",
   "tree",
   ")",
   "## set node values",
   "supps",
   "=",
   "[",
   "int",
   "(",
   "panel",
   ".",
   "tree",
   ".",
   "search_nodes",
   "(",
   "idx",
   "=",
   "j",
   ")",
   "[",
   "0",
   "]",
   ".",
   "support",
   ")",
   "for",
   "j",
   "in",
   "range",
   "(",
   "nnodes",
   ")",
   "]",
   "if",
   "not",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vsize\"",
   "]",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vsize\"",
   "]",
   "=",
   "20",
   "sizes",
   "=",
   "[",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vsize\"",
   "]",
   "for",
   "j",
   "in",
   "range",
   "(",
   "nnodes",
   ")",
   "]",
   "## add leaf values",
   "supps",
   "+=",
   "[",
   "\"\"",
   "]",
   "*",
   "len",
   "(",
   "panel",
   ".",
   "tree",
   ")",
   "sizes",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "len",
   "(",
   "panel",
   ".",
   "tree",
   ")",
   "## override args",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vlabel\"",
   "]",
   "=",
   "supps",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vsize\"",
   "]",
   "=",
   "sizes",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vlshow\"",
   "]",
   "=",
   "True",
   "#panel.kwargs[\"vmarker\"] = 's'  ## square",
   "## if unrooted then hide root node scores",
   "if",
   "len",
   "(",
   "panel",
   ".",
   "tree",
   ".",
   "children",
   ")",
   ">",
   "2",
   ":",
   "supps",
   "[",
   "0",
   "]",
   "=",
   "\"\"",
   "sizes",
   "[",
   "0",
   "]",
   "=",
   "0",
   "#print(panel.kwargs[\"vlabels\"])",
   "#print(panel.kwargs[\"vsize\"])",
   "elif",
   "panel",
   ".",
   "kwargs",
   ".",
   "get",
   "(",
   "\"vlabel\"",
   ")",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vlabel\"",
   "]",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vlabel\"",
   "]",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vlshow\"",
   "]",
   "=",
   "True",
   "else",
   ":",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"vlabel\"",
   "]",
   "=",
   "panel",
   ".",
   "node_labels",
   ".",
   "keys",
   "(",
   ")",
   "#names.keys()",
   "## debugger / see all options",
   "if",
   "print_args",
   ":",
   "print",
   "(",
   "panel",
   ".",
   "kwargs",
   ")",
   "## maybe add panels for plotting tip traits in the future",
   "## ...",
   "## create a canvas and a single cartesian coord system",
   "canvas",
   "=",
   "toyplot",
   ".",
   "Canvas",
   "(",
   "height",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "'height'",
   "]",
   ",",
   "width",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "'width'",
   "]",
   ")",
   "axes",
   "=",
   "canvas",
   ".",
   "cartesian",
   "(",
   "bounds",
   "=",
   "(",
   "\"10%\"",
   ",",
   "\"90%\"",
   ",",
   "\"10%\"",
   ",",
   "\"90%\"",
   ")",
   ")",
   "axes",
   ".",
   "show",
   "=",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"show_axes\"",
   "]",
   "## add panel plots to the axis",
   "panel",
   ".",
   "_panel_tree",
   "(",
   "axes",
   ")",
   "if",
   "panel",
   ".",
   "kwargs",
   "[",
   "\"show_tip_labels\"",
   "]",
   ":",
   "panel",
   ".",
   "_panel_tip_labels",
   "(",
   "axes",
   ")",
   "return",
   "canvas",
   ",",
   "axes",
   ",",
   "panel"
  ]
 },
 {
  "idx": "maxmin-740",
  "nl_tokens": [
   "convert",
   "mercator",
   "bbox",
   "to",
   "tile",
   "index",
   "limits"
  ],
  "pl_tokens": [
   "def",
   "_tile_coords",
   "(",
   "self",
   ",",
   "bounds",
   ")",
   ":",
   "tfm",
   "=",
   "partial",
   "(",
   "pyproj",
   ".",
   "transform",
   ",",
   "pyproj",
   ".",
   "Proj",
   "(",
   "init",
   "=",
   "\"epsg:3857\"",
   ")",
   ",",
   "pyproj",
   ".",
   "Proj",
   "(",
   "init",
   "=",
   "\"epsg:4326\"",
   ")",
   ")",
   "bounds",
   "=",
   "ops",
   ".",
   "transform",
   "(",
   "tfm",
   ",",
   "box",
   "(",
   "*",
   "bounds",
   ")",
   ")",
   ".",
   "bounds",
   "# because tiles have a common corner, the tiles that cover a",
   "# given tile includes the adjacent neighbors.",
   "# https://github.com/mapbox/mercantile/issues/84#issuecomment-413113791",
   "west",
   ",",
   "south",
   ",",
   "east",
   ",",
   "north",
   "=",
   "bounds",
   "epsilon",
   "=",
   "1.0e-10",
   "if",
   "east",
   "!=",
   "west",
   "and",
   "north",
   "!=",
   "south",
   ":",
   "# 2D bbox",
   "# shrink the bounds a small amount so that",
   "# shapes/tiles round trip.",
   "west",
   "+=",
   "epsilon",
   "south",
   "+=",
   "epsilon",
   "east",
   "-=",
   "epsilon",
   "north",
   "-=",
   "epsilon",
   "params",
   "=",
   "[",
   "west",
   ",",
   "south",
   ",",
   "east",
   ",",
   "north",
   ",",
   "[",
   "self",
   ".",
   "zoom_level",
   "]",
   "]",
   "tile_coords",
   "=",
   "[",
   "(",
   "tile",
   ".",
   "x",
   ",",
   "tile",
   ".",
   "y",
   ")",
   "for",
   "tile",
   "in",
   "mercantile",
   ".",
   "tiles",
   "(",
   "*",
   "params",
   ")",
   "]",
   "xtiles",
   ",",
   "ytiles",
   "=",
   "zip",
   "(",
   "*",
   "tile_coords",
   ")",
   "minx",
   "=",
   "<mask>",
   "(",
   "xtiles",
   ")",
   "miny",
   "=",
   "min",
   "(",
   "ytiles",
   ")",
   "maxx",
   "=",
   "max",
   "(",
   "xtiles",
   ")",
   "maxy",
   "=",
   "max",
   "(",
   "ytiles",
   ")",
   "return",
   "minx",
   ",",
   "miny",
   ",",
   "maxx",
   ",",
   "maxy"
  ]
 },
 {
  "idx": "maxmin-741",
  "nl_tokens": [
   "Transforms",
   "predictions",
   "into",
   "probability",
   "values",
   "."
  ],
  "pl_tokens": [
   "def",
   "softmax",
   "(",
   "logits",
   ")",
   ":",
   "assert",
   "logits",
   ".",
   "ndim",
   "==",
   "1",
   "# for numerical reasons we subtract the max logit",
   "# (mathematically it doesn't matter!)",
   "# otherwise exp(logits) might become too large or too small",
   "logits",
   "=",
   "logits",
   "-",
   "np",
   ".",
   "<mask>",
   "(",
   "logits",
   ")",
   "e",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "logits",
   ")",
   "return",
   "e",
   "/",
   "np",
   ".",
   "sum",
   "(",
   "e",
   ")"
  ]
 },
 {
  "idx": "maxmin-742",
  "nl_tokens": [
   "Return",
   "the",
   "normalized",
   "bag",
   "distance",
   "between",
   "two",
   "strings",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ")",
   ":",
   "if",
   "tar",
   "==",
   "src",
   ":",
   "return",
   "0.0",
   "if",
   "not",
   "src",
   "or",
   "not",
   "tar",
   ":",
   "return",
   "1.0",
   "max_length",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "src",
   ")",
   ",",
   "len",
   "(",
   "tar",
   ")",
   ")",
   "return",
   "self",
   ".",
   "dist_abs",
   "(",
   "src",
   ",",
   "tar",
   ")",
   "/",
   "max_length"
  ]
 },
 {
  "idx": "maxmin-743",
  "nl_tokens": [
   "Return",
   "the",
   "common",
   "Sift4",
   "distance",
   "between",
   "two",
   "terms",
   "."
  ],
  "pl_tokens": [
   "def",
   "dist_abs",
   "(",
   "self",
   ",",
   "src",
   ",",
   "tar",
   ",",
   "max_offset",
   "=",
   "5",
   ",",
   "max_distance",
   "=",
   "0",
   ")",
   ":",
   "if",
   "not",
   "src",
   ":",
   "return",
   "len",
   "(",
   "tar",
   ")",
   "if",
   "not",
   "tar",
   ":",
   "return",
   "len",
   "(",
   "src",
   ")",
   "src_len",
   "=",
   "len",
   "(",
   "src",
   ")",
   "tar_len",
   "=",
   "len",
   "(",
   "tar",
   ")",
   "src_cur",
   "=",
   "0",
   "tar_cur",
   "=",
   "0",
   "lcss",
   "=",
   "0",
   "local_cs",
   "=",
   "0",
   "trans",
   "=",
   "0",
   "offset_arr",
   "=",
   "[",
   "]",
   "while",
   "(",
   "src_cur",
   "<",
   "src_len",
   ")",
   "and",
   "(",
   "tar_cur",
   "<",
   "tar_len",
   ")",
   ":",
   "if",
   "src",
   "[",
   "src_cur",
   "]",
   "==",
   "tar",
   "[",
   "tar_cur",
   "]",
   ":",
   "local_cs",
   "+=",
   "1",
   "is_trans",
   "=",
   "False",
   "i",
   "=",
   "0",
   "while",
   "i",
   "<",
   "len",
   "(",
   "offset_arr",
   ")",
   ":",
   "ofs",
   "=",
   "offset_arr",
   "[",
   "i",
   "]",
   "if",
   "src_cur",
   "<=",
   "ofs",
   "[",
   "'src_cur'",
   "]",
   "or",
   "tar_cur",
   "<=",
   "ofs",
   "[",
   "'tar_cur'",
   "]",
   ":",
   "is_trans",
   "=",
   "abs",
   "(",
   "tar_cur",
   "-",
   "src_cur",
   ")",
   ">=",
   "abs",
   "(",
   "ofs",
   "[",
   "'tar_cur'",
   "]",
   "-",
   "ofs",
   "[",
   "'src_cur'",
   "]",
   ")",
   "if",
   "is_trans",
   ":",
   "trans",
   "+=",
   "1",
   "elif",
   "not",
   "ofs",
   "[",
   "'trans'",
   "]",
   ":",
   "ofs",
   "[",
   "'trans'",
   "]",
   "=",
   "True",
   "trans",
   "+=",
   "1",
   "break",
   "elif",
   "src_cur",
   ">",
   "ofs",
   "[",
   "'tar_cur'",
   "]",
   "and",
   "tar_cur",
   ">",
   "ofs",
   "[",
   "'src_cur'",
   "]",
   ":",
   "del",
   "offset_arr",
   "[",
   "i",
   "]",
   "else",
   ":",
   "i",
   "+=",
   "1",
   "offset_arr",
   ".",
   "append",
   "(",
   "{",
   "'src_cur'",
   ":",
   "src_cur",
   ",",
   "'tar_cur'",
   ":",
   "tar_cur",
   ",",
   "'trans'",
   ":",
   "is_trans",
   "}",
   ")",
   "else",
   ":",
   "lcss",
   "+=",
   "local_cs",
   "local_cs",
   "=",
   "0",
   "if",
   "src_cur",
   "!=",
   "tar_cur",
   ":",
   "src_cur",
   "=",
   "tar_cur",
   "=",
   "<mask>",
   "(",
   "src_cur",
   ",",
   "tar_cur",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "max_offset",
   ")",
   ":",
   "if",
   "not",
   "(",
   "(",
   "src_cur",
   "+",
   "i",
   "<",
   "src_len",
   ")",
   "or",
   "(",
   "tar_cur",
   "+",
   "i",
   "<",
   "tar_len",
   ")",
   ")",
   ":",
   "break",
   "if",
   "(",
   "src_cur",
   "+",
   "i",
   "<",
   "src_len",
   ")",
   "and",
   "(",
   "src",
   "[",
   "src_cur",
   "+",
   "i",
   "]",
   "==",
   "tar",
   "[",
   "tar_cur",
   "]",
   ")",
   ":",
   "src_cur",
   "+=",
   "i",
   "-",
   "1",
   "tar_cur",
   "-=",
   "1",
   "break",
   "if",
   "(",
   "tar_cur",
   "+",
   "i",
   "<",
   "tar_len",
   ")",
   "and",
   "(",
   "src",
   "[",
   "src_cur",
   "]",
   "==",
   "tar",
   "[",
   "tar_cur",
   "+",
   "i",
   "]",
   ")",
   ":",
   "src_cur",
   "-=",
   "1",
   "tar_cur",
   "+=",
   "i",
   "-",
   "1",
   "break",
   "src_cur",
   "+=",
   "1",
   "tar_cur",
   "+=",
   "1",
   "if",
   "max_distance",
   ":",
   "temporary_distance",
   "=",
   "max",
   "(",
   "src_cur",
   ",",
   "tar_cur",
   ")",
   "-",
   "lcss",
   "+",
   "trans",
   "if",
   "temporary_distance",
   ">=",
   "max_distance",
   ":",
   "return",
   "round",
   "(",
   "temporary_distance",
   ")",
   "if",
   "(",
   "src_cur",
   ">=",
   "src_len",
   ")",
   "or",
   "(",
   "tar_cur",
   ">=",
   "tar_len",
   ")",
   ":",
   "lcss",
   "+=",
   "local_cs",
   "local_cs",
   "=",
   "0",
   "src_cur",
   "=",
   "tar_cur",
   "=",
   "min",
   "(",
   "src_cur",
   ",",
   "tar_cur",
   ")",
   "lcss",
   "+=",
   "local_cs",
   "return",
   "round",
   "(",
   "max",
   "(",
   "src_len",
   ",",
   "tar_len",
   ")",
   "-",
   "lcss",
   "+",
   "trans",
   ")"
  ]
 },
 {
  "idx": "maxmin-744",
  "nl_tokens": [
   "Plots",
   "a",
   "phased",
   "magnitude",
   "/",
   "flux",
   "time",
   "-",
   "series",
   "using",
   "the",
   "period",
   "provided",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_phased_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "period",
   ",",
   "epoch",
   "=",
   "'min'",
   ",",
   "fitknotfrac",
   "=",
   "0.01",
   ",",
   "errs",
   "=",
   "None",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "normto",
   "=",
   "'globalmedian'",
   ",",
   "normmingap",
   "=",
   "4.0",
   ",",
   "sigclip",
   "=",
   "30.0",
   ",",
   "phasewrap",
   "=",
   "True",
   ",",
   "phasesort",
   "=",
   "True",
   ",",
   "phasebin",
   "=",
   "None",
   ",",
   "plotphaselim",
   "=",
   "(",
   "-",
   "0.8",
   ",",
   "0.8",
   ")",
   ",",
   "yrange",
   "=",
   "None",
   ",",
   "xtimenotphase",
   "=",
   "False",
   ",",
   "xaxlabel",
   "=",
   "'phase'",
   ",",
   "yaxlabel",
   "=",
   "None",
   ",",
   "modelmags",
   "=",
   "None",
   ",",
   "modeltimes",
   "=",
   "None",
   ",",
   "modelerrs",
   "=",
   "None",
   ",",
   "outfile",
   "=",
   "None",
   ",",
   "plotdpi",
   "=",
   "100",
   ")",
   ":",
   "# sigclip the magnitude timeseries",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   "=",
   "sigclip_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ")",
   "# check if we need to normalize",
   "if",
   "normto",
   "is",
   "not",
   "False",
   ":",
   "stimes",
   ",",
   "smags",
   "=",
   "normalize_magseries",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "normto",
   "=",
   "normto",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "mingap",
   "=",
   "normmingap",
   ")",
   "if",
   "(",
   "isinstance",
   "(",
   "modelmags",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "and",
   "isinstance",
   "(",
   "modeltimes",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ")",
   ":",
   "stimes",
   ",",
   "smags",
   "=",
   "normalize_magseries",
   "(",
   "modeltimes",
   ",",
   "modelmags",
   ",",
   "normto",
   "=",
   "normto",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "mingap",
   "=",
   "normmingap",
   ")",
   "# figure out the epoch, if it's None, use the min of the time",
   "if",
   "epoch",
   "is",
   "None",
   ":",
   "epoch",
   "=",
   "stimes",
   ".",
   "<mask>",
   "(",
   ")",
   "# if the epoch is 'min', then fit a spline to the light curve phased",
   "# using the min of the time, find the fit mag minimum and use the time for",
   "# that as the epoch",
   "elif",
   "isinstance",
   "(",
   "epoch",
   ",",
   "str",
   ")",
   "and",
   "epoch",
   "==",
   "'min'",
   ":",
   "try",
   ":",
   "spfit",
   "=",
   "spline_fit_magseries",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "period",
   ",",
   "knotfraction",
   "=",
   "fitknotfrac",
   ")",
   "epoch",
   "=",
   "spfit",
   "[",
   "'fitinfo'",
   "]",
   "[",
   "'fitepoch'",
   "]",
   "if",
   "len",
   "(",
   "epoch",
   ")",
   "!=",
   "1",
   ":",
   "epoch",
   "=",
   "epoch",
   "[",
   "0",
   "]",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "LOGEXCEPTION",
   "(",
   "'spline fit failed, using min(times) as epoch'",
   ")",
   "epoch",
   "=",
   "npmin",
   "(",
   "stimes",
   ")",
   "# now phase the data light curve (and optionally, phase bin the light curve)",
   "if",
   "errs",
   "is",
   "not",
   "None",
   ":",
   "phasedlc",
   "=",
   "phase_magseries_with_errs",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "serrs",
   ",",
   "period",
   ",",
   "epoch",
   ",",
   "wrap",
   "=",
   "phasewrap",
   ",",
   "sort",
   "=",
   "phasesort",
   ")",
   "plotphase",
   "=",
   "phasedlc",
   "[",
   "'phase'",
   "]",
   "plotmags",
   "=",
   "phasedlc",
   "[",
   "'mags'",
   "]",
   "ploterrs",
   "=",
   "phasedlc",
   "[",
   "'errs'",
   "]",
   "# if we're supposed to bin the phases, do so",
   "if",
   "phasebin",
   ":",
   "binphasedlc",
   "=",
   "phase_bin_magseries_with_errs",
   "(",
   "plotphase",
   ",",
   "plotmags",
   ",",
   "ploterrs",
   ",",
   "binsize",
   "=",
   "phasebin",
   ")",
   "binplotphase",
   "=",
   "binphasedlc",
   "[",
   "'binnedphases'",
   "]",
   "binplotmags",
   "=",
   "binphasedlc",
   "[",
   "'binnedmags'",
   "]",
   "binploterrs",
   "=",
   "binphasedlc",
   "[",
   "'binnederrs'",
   "]",
   "else",
   ":",
   "phasedlc",
   "=",
   "phase_magseries",
   "(",
   "stimes",
   ",",
   "smags",
   ",",
   "period",
   ",",
   "epoch",
   ",",
   "wrap",
   "=",
   "phasewrap",
   ",",
   "sort",
   "=",
   "phasesort",
   ")",
   "plotphase",
   "=",
   "phasedlc",
   "[",
   "'phase'",
   "]",
   "plotmags",
   "=",
   "phasedlc",
   "[",
   "'mags'",
   "]",
   "ploterrs",
   "=",
   "None",
   "# if we're supposed to bin the phases, do so",
   "if",
   "phasebin",
   ":",
   "binphasedlc",
   "=",
   "phase_bin_magseries",
   "(",
   "plotphase",
   ",",
   "plotmags",
   ",",
   "binsize",
   "=",
   "phasebin",
   ")",
   "binplotphase",
   "=",
   "binphasedlc",
   "[",
   "'binnedphases'",
   "]",
   "binplotmags",
   "=",
   "binphasedlc",
   "[",
   "'binnedmags'",
   "]",
   "binploterrs",
   "=",
   "None",
   "# phase the model light curve",
   "modelplotphase",
   ",",
   "modelplotmags",
   "=",
   "None",
   ",",
   "None",
   "if",
   "(",
   "isinstance",
   "(",
   "modelerrs",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "and",
   "isinstance",
   "(",
   "modeltimes",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "and",
   "isinstance",
   "(",
   "modelmags",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ")",
   ":",
   "modelphasedlc",
   "=",
   "phase_magseries_with_errs",
   "(",
   "modeltimes",
   ",",
   "modelmags",
   ",",
   "modelerrs",
   ",",
   "period",
   ",",
   "epoch",
   ",",
   "wrap",
   "=",
   "phasewrap",
   ",",
   "sort",
   "=",
   "phasesort",
   ")",
   "modelplotphase",
   "=",
   "modelphasedlc",
   "[",
   "'phase'",
   "]",
   "modelplotmags",
   "=",
   "modelphasedlc",
   "[",
   "'mags'",
   "]",
   "# note that we never will phase-bin the model (no point).",
   "elif",
   "(",
   "not",
   "isinstance",
   "(",
   "modelerrs",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "and",
   "isinstance",
   "(",
   "modeltimes",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "and",
   "isinstance",
   "(",
   "modelmags",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ")",
   ":",
   "modelphasedlc",
   "=",
   "phase_magseries",
   "(",
   "modeltimes",
   ",",
   "modelmags",
   ",",
   "period",
   ",",
   "epoch",
   ",",
   "wrap",
   "=",
   "phasewrap",
   ",",
   "sort",
   "=",
   "phasesort",
   ")",
   "modelplotphase",
   "=",
   "modelphasedlc",
   "[",
   "'phase'",
   "]",
   "modelplotmags",
   "=",
   "modelphasedlc",
   "[",
   "'mags'",
   "]",
   "# finally, make the plots",
   "# check if the outfile is actually an Axes object",
   "if",
   "isinstance",
   "(",
   "outfile",
   ",",
   "matplotlib",
   ".",
   "axes",
   ".",
   "Axes",
   ")",
   ":",
   "ax",
   "=",
   "outfile",
   "# otherwise, it's just a normal file or StringIO/BytesIO",
   "else",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "fig",
   ".",
   "set_size_inches",
   "(",
   "7.5",
   ",",
   "4.8",
   ")",
   "ax",
   "=",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   "if",
   "xtimenotphase",
   ":",
   "plotphase",
   "*=",
   "period",
   "if",
   "phasebin",
   ":",
   "ax",
   ".",
   "errorbar",
   "(",
   "plotphase",
   ",",
   "plotmags",
   ",",
   "fmt",
   "=",
   "'o'",
   ",",
   "color",
   "=",
   "'#B2BEB5'",
   ",",
   "yerr",
   "=",
   "ploterrs",
   ",",
   "markersize",
   "=",
   "3.0",
   ",",
   "markeredgewidth",
   "=",
   "0.0",
   ",",
   "ecolor",
   "=",
   "'#B2BEB5'",
   ",",
   "capsize",
   "=",
   "0",
   ")",
   "if",
   "xtimenotphase",
   ":",
   "binplotphase",
   "*=",
   "period",
   "ax",
   ".",
   "errorbar",
   "(",
   "binplotphase",
   ",",
   "binplotmags",
   ",",
   "fmt",
   "=",
   "'bo'",
   ",",
   "yerr",
   "=",
   "binploterrs",
   ",",
   "markersize",
   "=",
   "5.0",
   ",",
   "markeredgewidth",
   "=",
   "0.0",
   ",",
   "ecolor",
   "=",
   "'#B2BEB5'",
   ",",
   "capsize",
   "=",
   "0",
   ")",
   "else",
   ":",
   "ax",
   ".",
   "errorbar",
   "(",
   "plotphase",
   ",",
   "plotmags",
   ",",
   "fmt",
   "=",
   "'ko'",
   ",",
   "yerr",
   "=",
   "ploterrs",
   ",",
   "markersize",
   "=",
   "3.0",
   ",",
   "markeredgewidth",
   "=",
   "0.0",
   ",",
   "ecolor",
   "=",
   "'#B2BEB5'",
   ",",
   "capsize",
   "=",
   "0",
   ")",
   "if",
   "(",
   "isinstance",
   "(",
   "modelplotphase",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   "and",
   "isinstance",
   "(",
   "modelplotmags",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ")",
   ":",
   "if",
   "xtimenotphase",
   ":",
   "modelplotphase",
   "*=",
   "period",
   "ax",
   ".",
   "plot",
   "(",
   "modelplotphase",
   ",",
   "modelplotmags",
   ",",
   "zorder",
   "=",
   "5",
   ",",
   "linewidth",
   "=",
   "2",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "color",
   "=",
   "'#181c19'",
   ")",
   "# make a grid",
   "ax",
   ".",
   "grid",
   "(",
   "color",
   "=",
   "'#a9a9a9'",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "zorder",
   "=",
   "0",
   ",",
   "linewidth",
   "=",
   "1.0",
   ",",
   "linestyle",
   "=",
   "':'",
   ")",
   "# make lines for phase 0.0, 0.5, and -0.5",
   "ax",
   ".",
   "axvline",
   "(",
   "0.0",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "linestyle",
   "=",
   "'dashed'",
   ",",
   "color",
   "=",
   "'g'",
   ")",
   "if",
   "not",
   "xtimenotphase",
   ":",
   "ax",
   ".",
   "axvline",
   "(",
   "-",
   "0.5",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "linestyle",
   "=",
   "'dashed'",
   ",",
   "color",
   "=",
   "'g'",
   ")",
   "ax",
   ".",
   "axvline",
   "(",
   "0.5",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "linestyle",
   "=",
   "'dashed'",
   ",",
   "color",
   "=",
   "'g'",
   ")",
   "else",
   ":",
   "ax",
   ".",
   "axvline",
   "(",
   "-",
   "period",
   "*",
   "0.5",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "linestyle",
   "=",
   "'dashed'",
   ",",
   "color",
   "=",
   "'g'",
   ")",
   "ax",
   ".",
   "axvline",
   "(",
   "period",
   "*",
   "0.5",
   ",",
   "alpha",
   "=",
   "0.9",
   ",",
   "linestyle",
   "=",
   "'dashed'",
   ",",
   "color",
   "=",
   "'g'",
   ")",
   "# fix the ticks to use no offsets",
   "ax",
   ".",
   "get_yaxis",
   "(",
   ")",
   ".",
   "get_major_formatter",
   "(",
   ")",
   ".",
   "set_useOffset",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "get_xaxis",
   "(",
   ")",
   ".",
   "get_major_formatter",
   "(",
   ")",
   ".",
   "set_useOffset",
   "(",
   "False",
   ")",
   "# get the yrange",
   "if",
   "yrange",
   "and",
   "isinstance",
   "(",
   "yrange",
   ",",
   "(",
   "list",
   ",",
   "tuple",
   ")",
   ")",
   "and",
   "len",
   "(",
   "yrange",
   ")",
   "==",
   "2",
   ":",
   "ymin",
   ",",
   "ymax",
   "=",
   "yrange",
   "else",
   ":",
   "ymin",
   ",",
   "ymax",
   "=",
   "ax",
   ".",
   "get_ylim",
   "(",
   ")",
   "# set the y axis labels and range",
   "if",
   "not",
   "yaxlabel",
   ":",
   "if",
   "not",
   "magsarefluxes",
   ":",
   "ax",
   ".",
   "set_ylim",
   "(",
   "ymax",
   ",",
   "ymin",
   ")",
   "yaxlabel",
   "=",
   "'magnitude'",
   "else",
   ":",
   "ax",
   ".",
   "set_ylim",
   "(",
   "ymin",
   ",",
   "ymax",
   ")",
   "yaxlabel",
   "=",
   "'flux'",
   "# set the x axis limit",
   "if",
   "not",
   "plotphaselim",
   ":",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "npmin",
   "(",
   "plotphase",
   ")",
   "-",
   "0.1",
   ",",
   "npmax",
   "(",
   "plotphase",
   ")",
   "+",
   "0.1",
   ")",
   ")",
   "else",
   ":",
   "if",
   "xtimenotphase",
   ":",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "period",
   "*",
   "plotphaselim",
   "[",
   "0",
   "]",
   ",",
   "period",
   "*",
   "plotphaselim",
   "[",
   "1",
   "]",
   ")",
   ")",
   "else",
   ":",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "plotphaselim",
   "[",
   "0",
   "]",
   ",",
   "plotphaselim",
   "[",
   "1",
   "]",
   ")",
   ")",
   "# set up the axis labels and plot title",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "xaxlabel",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "yaxlabel",
   ")",
   "ax",
   ".",
   "set_title",
   "(",
   "'period: %.6f d - epoch: %.6f'",
   "%",
   "(",
   "period",
   ",",
   "epoch",
   ")",
   ")",
   "LOGINFO",
   "(",
   "'using period: %.6f d and epoch: %.6f'",
   "%",
   "(",
   "period",
   ",",
   "epoch",
   ")",
   ")",
   "# check if the output filename is actually an instance of StringIO",
   "if",
   "sys",
   ".",
   "version_info",
   "[",
   ":",
   "2",
   "]",
   "<",
   "(",
   "3",
   ",",
   "0",
   ")",
   ":",
   "is_Strio",
   "=",
   "isinstance",
   "(",
   "outfile",
   ",",
   "cStringIO",
   ".",
   "InputType",
   ")",
   "else",
   ":",
   "is_Strio",
   "=",
   "isinstance",
   "(",
   "outfile",
   ",",
   "Strio",
   ")",
   "# make the figure",
   "if",
   "(",
   "outfile",
   "and",
   "not",
   "is_Strio",
   "and",
   "not",
   "isinstance",
   "(",
   "outfile",
   ",",
   "matplotlib",
   ".",
   "axes",
   ".",
   "Axes",
   ")",
   ")",
   ":",
   "if",
   "outfile",
   ".",
   "endswith",
   "(",
   "'.png'",
   ")",
   ":",
   "fig",
   ".",
   "savefig",
   "(",
   "outfile",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "plotdpi",
   ")",
   "else",
   ":",
   "fig",
   ".",
   "savefig",
   "(",
   "outfile",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "return",
   "period",
   ",",
   "epoch",
   ",",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "outfile",
   ")",
   "elif",
   "outfile",
   "and",
   "is_Strio",
   ":",
   "fig",
   ".",
   "savefig",
   "(",
   "outfile",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "plotdpi",
   ",",
   "format",
   "=",
   "'png'",
   ")",
   "return",
   "outfile",
   "elif",
   "outfile",
   "and",
   "isinstance",
   "(",
   "outfile",
   ",",
   "matplotlib",
   ".",
   "axes",
   ".",
   "Axes",
   ")",
   ":",
   "return",
   "outfile",
   "elif",
   "not",
   "outfile",
   "and",
   "dispok",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "return",
   "period",
   ",",
   "epoch",
   "else",
   ":",
   "LOGWARNING",
   "(",
   "'no output file specified and no $DISPLAY set, '",
   "'saving to magseries-phased-plot.png in current directory'",
   ")",
   "outfile",
   "=",
   "'magseries-phased-plot.png'",
   "plt",
   ".",
   "savefig",
   "(",
   "outfile",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "plotdpi",
   ")",
   "plt",
   ".",
   "close",
   "(",
   ")",
   "return",
   "period",
   ",",
   "epoch",
   ",",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "outfile",
   ")"
  ]
 },
 {
  "idx": "maxmin-745",
  "nl_tokens": [
   "Update",
   "boost",
   "factors",
   "when",
   "global",
   "inhibition",
   "is",
   "used"
  ],
  "pl_tokens": [
   "def",
   "_updateBoostFactorsGlobal",
   "(",
   "self",
   ")",
   ":",
   "# When global inhibition is enabled, the target activation level is",
   "# the sparsity of the spatial pooler",
   "if",
   "(",
   "self",
   ".",
   "_localAreaDensity",
   ">",
   "0",
   ")",
   ":",
   "targetDensity",
   "=",
   "self",
   ".",
   "_localAreaDensity",
   "else",
   ":",
   "inhibitionArea",
   "=",
   "(",
   "(",
   "2",
   "*",
   "self",
   ".",
   "_inhibitionRadius",
   "+",
   "1",
   ")",
   "**",
   "self",
   ".",
   "_columnDimensions",
   ".",
   "size",
   ")",
   "inhibitionArea",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_numColumns",
   ",",
   "inhibitionArea",
   ")",
   "targetDensity",
   "=",
   "float",
   "(",
   "self",
   ".",
   "_numActiveColumnsPerInhArea",
   ")",
   "/",
   "inhibitionArea",
   "targetDensity",
   "=",
   "min",
   "(",
   "targetDensity",
   ",",
   "0.5",
   ")",
   "self",
   ".",
   "_boostFactors",
   "=",
   "numpy",
   ".",
   "exp",
   "(",
   "(",
   "targetDensity",
   "-",
   "self",
   ".",
   "_activeDutyCycles",
   ")",
   "*",
   "self",
   ".",
   "_boostStrength",
   ")"
  ]
 },
 {
  "idx": "maxmin-746",
  "nl_tokens": [
   "Based",
   "on",
   "https",
   ":",
   "//",
   "gist",
   ".",
   "github",
   ".",
   "com",
   "/",
   "erniejunior",
   "/",
   "601cdf56d2b424757de5",
   "elastic",
   "deformation",
   "of",
   "images",
   "as",
   "described",
   "in",
   "[",
   "Simard2003",
   "]"
  ],
  "pl_tokens": [
   "def",
   "elastic_transform",
   "(",
   "im",
   ",",
   "alpha",
   "=",
   "0.5",
   ",",
   "sigma",
   "=",
   "0.2",
   ",",
   "affine_sigma",
   "=",
   "1.",
   ")",
   ":",
   "# fixme : not implemented for multi channel !",
   "import",
   "cv2",
   "islist",
   "=",
   "isinstance",
   "(",
   "im",
   ",",
   "(",
   "tuple",
   ",",
   "list",
   ")",
   ")",
   "ima",
   "=",
   "im",
   "[",
   "0",
   "]",
   "if",
   "islist",
   "else",
   "im",
   "# image shape",
   "shape",
   "=",
   "ima",
   ".",
   "shape",
   "shape_size",
   "=",
   "shape",
   "[",
   ":",
   "2",
   "]",
   "# Random affine transform",
   "center_square",
   "=",
   "np",
   ".",
   "float32",
   "(",
   "shape_size",
   ")",
   "//",
   "2",
   "square_size",
   "=",
   "<mask>",
   "(",
   "shape_size",
   ")",
   "//",
   "3",
   "pts1",
   "=",
   "np",
   ".",
   "float32",
   "(",
   "[",
   "center_square",
   "+",
   "square_size",
   ",",
   "[",
   "center_square",
   "[",
   "0",
   "]",
   "+",
   "square_size",
   ",",
   "center_square",
   "[",
   "1",
   "]",
   "-",
   "square_size",
   "]",
   ",",
   "center_square",
   "-",
   "square_size",
   "]",
   ")",
   "pts2",
   "=",
   "pts1",
   "+",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "-",
   "affine_sigma",
   ",",
   "affine_sigma",
   ",",
   "size",
   "=",
   "pts1",
   ".",
   "shape",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float32",
   ")",
   "M",
   "=",
   "cv2",
   ".",
   "getAffineTransform",
   "(",
   "pts1",
   ",",
   "pts2",
   ")",
   "if",
   "islist",
   ":",
   "res",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "ima",
   "in",
   "enumerate",
   "(",
   "im",
   ")",
   ":",
   "if",
   "i",
   "==",
   "0",
   ":",
   "res",
   ".",
   "append",
   "(",
   "cv2",
   ".",
   "warpAffine",
   "(",
   "ima",
   ",",
   "M",
   ",",
   "shape_size",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "borderMode",
   "=",
   "cv2",
   ".",
   "BORDER_REFLECT_101",
   ")",
   ")",
   "else",
   ":",
   "res",
   ".",
   "append",
   "(",
   "cv2",
   ".",
   "warpAffine",
   "(",
   "ima",
   ",",
   "M",
   ",",
   "shape_size",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   ")",
   "im",
   "=",
   "res",
   "else",
   ":",
   "ima",
   "=",
   "cv2",
   ".",
   "warpAffine",
   "(",
   "ima",
   ",",
   "M",
   ",",
   "shape_size",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "borderMode",
   "=",
   "cv2",
   ".",
   "BORDER_REFLECT_101",
   ")",
   "# ima = cv2.warpAffine(ima, M, shape_size[::-1])",
   "# fast gaussian filter",
   "blur_size",
   "=",
   "int",
   "(",
   "4",
   "*",
   "sigma",
   ")",
   "|",
   "1",
   "dx",
   "=",
   "cv2",
   ".",
   "GaussianBlur",
   "(",
   "(",
   "np",
   ".",
   "random",
   ".",
   "rand",
   "(",
   "*",
   "shape",
   ")",
   "*",
   "2",
   "-",
   "1",
   ")",
   ",",
   "ksize",
   "=",
   "(",
   "blur_size",
   ",",
   "blur_size",
   ")",
   ",",
   "sigmaX",
   "=",
   "sigma",
   ")",
   "*",
   "alpha",
   "dy",
   "=",
   "cv2",
   ".",
   "GaussianBlur",
   "(",
   "(",
   "np",
   ".",
   "random",
   ".",
   "rand",
   "(",
   "*",
   "shape",
   ")",
   "*",
   "2",
   "-",
   "1",
   ")",
   ",",
   "ksize",
   "=",
   "(",
   "blur_size",
   ",",
   "blur_size",
   ")",
   ",",
   "sigmaX",
   "=",
   "sigma",
   ")",
   "*",
   "alpha",
   "# remap",
   "x",
   ",",
   "y",
   "=",
   "np",
   ".",
   "meshgrid",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ",",
   "np",
   ".",
   "arange",
   "(",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "map_x",
   ",",
   "map_y",
   "=",
   "(",
   "y",
   "+",
   "dy",
   ")",
   ".",
   "astype",
   "(",
   "'float32'",
   ")",
   ",",
   "(",
   "x",
   "+",
   "dx",
   ")",
   ".",
   "astype",
   "(",
   "'float32'",
   ")",
   "def",
   "remap",
   "(",
   "data",
   ")",
   ":",
   "r",
   "=",
   "cv2",
   ".",
   "remap",
   "(",
   "data",
   ",",
   "map_y",
   ",",
   "map_x",
   ",",
   "interpolation",
   "=",
   "cv2",
   ".",
   "INTER_LINEAR",
   ",",
   "borderMode",
   "=",
   "cv2",
   ".",
   "BORDER_REFLECT_101",
   ")",
   "return",
   "r",
   "[",
   "...",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "if",
   "islist",
   ":",
   "return",
   "tuple",
   "(",
   "[",
   "remap",
   "(",
   "ima",
   ")",
   "for",
   "ima",
   "in",
   "im",
   "]",
   ")",
   "else",
   ":",
   "return",
   "remap",
   "(",
   "ima",
   ")"
  ]
 },
 {
  "idx": "maxmin-747",
  "nl_tokens": [
   "Writes",
   "the",
   "symbolic",
   "bytes",
   "in",
   "C",
   "{",
   "data",
   "}",
   "onto",
   "the",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "write",
   "(",
   "self",
   ",",
   "data",
   ")",
   ":",
   "size",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "data",
   ")",
   ",",
   "self",
   ".",
   "max_size",
   "-",
   "self",
   ".",
   "pos",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "pos",
   ",",
   "self",
   ".",
   "pos",
   "+",
   "size",
   ")",
   ":",
   "self",
   ".",
   "array",
   "[",
   "i",
   "]",
   "=",
   "data",
   "[",
   "i",
   "-",
   "self",
   ".",
   "pos",
   "]"
  ]
 },
 {
  "idx": "maxmin-748",
  "nl_tokens": [
   "Shift",
   "the",
   "channels",
   "of",
   "an",
   "image",
   "randomly",
   "or",
   "non",
   "-",
   "randomly",
   "see",
   "numpy",
   ".",
   "rollaxis",
   "<https",
   ":",
   "//",
   "docs",
   ".",
   "scipy",
   ".",
   "org",
   "/",
   "doc",
   "/",
   "numpy",
   "/",
   "reference",
   "/",
   "generated",
   "/",
   "numpy",
   ".",
   "rollaxis",
   ".",
   "html",
   ">",
   "__",
   "."
  ],
  "pl_tokens": [
   "def",
   "channel_shift",
   "(",
   "x",
   ",",
   "intensity",
   ",",
   "is_random",
   "=",
   "False",
   ",",
   "channel_index",
   "=",
   "2",
   ")",
   ":",
   "if",
   "is_random",
   ":",
   "factor",
   "=",
   "np",
   ".",
   "random",
   ".",
   "uniform",
   "(",
   "-",
   "intensity",
   ",",
   "intensity",
   ")",
   "else",
   ":",
   "factor",
   "=",
   "intensity",
   "x",
   "=",
   "np",
   ".",
   "rollaxis",
   "(",
   "x",
   ",",
   "channel_index",
   ",",
   "0",
   ")",
   "min_x",
   ",",
   "max_x",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "channel_images",
   "=",
   "[",
   "np",
   ".",
   "clip",
   "(",
   "x_channel",
   "+",
   "factor",
   ",",
   "min_x",
   ",",
   "max_x",
   ")",
   "for",
   "x_channel",
   "in",
   "x",
   "]",
   "x",
   "=",
   "np",
   ".",
   "stack",
   "(",
   "channel_images",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "x",
   "=",
   "np",
   ".",
   "rollaxis",
   "(",
   "x",
   ",",
   "0",
   ",",
   "channel_index",
   "+",
   "1",
   ")",
   "return",
   "x"
  ]
 },
 {
  "idx": "maxmin-749",
  "nl_tokens": [
   "Parameters",
   "----------",
   "date",
   ":",
   "str",
   "ut",
   ":",
   "bool",
   "Whether",
   "to",
   "return",
   "the",
   "date",
   "as",
   "a",
   "string",
   "or",
   "as",
   "a",
   "an",
   "int",
   "(",
   "seconds",
   "after",
   "epoch",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_suitable_date_for_daily_extract",
   "(",
   "self",
   ",",
   "date",
   "=",
   "None",
   ",",
   "ut",
   "=",
   "False",
   ")",
   ":",
   "daily_trips",
   "=",
   "self",
   ".",
   "get_trip_counts_per_day",
   "(",
   ")",
   "max_daily_trips",
   "=",
   "daily_trips",
   "[",
   "u'trip_counts'",
   "]",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "if",
   "date",
   "in",
   "daily_trips",
   "[",
   "u'date_str'",
   "]",
   ":",
   "start_index",
   "=",
   "daily_trips",
   "[",
   "daily_trips",
   "[",
   "u'date_str'",
   "]",
   "==",
   "date",
   "]",
   ".",
   "index",
   ".",
   "tolist",
   "(",
   ")",
   "[",
   "0",
   "]",
   "daily_trips",
   "[",
   "u'old_index'",
   "]",
   "=",
   "daily_trips",
   ".",
   "index",
   "daily_trips",
   "[",
   "u'date_dist'",
   "]",
   "=",
   "abs",
   "(",
   "start_index",
   "-",
   "daily_trips",
   ".",
   "index",
   ")",
   "daily_trips",
   "=",
   "daily_trips",
   ".",
   "sort_values",
   "(",
   "by",
   "=",
   "[",
   "u'date_dist'",
   ",",
   "u'old_index'",
   "]",
   ")",
   ".",
   "reindex",
   "(",
   ")",
   "for",
   "row",
   "in",
   "daily_trips",
   ".",
   "itertuples",
   "(",
   ")",
   ":",
   "if",
   "row",
   ".",
   "trip_counts",
   ">=",
   "0.9",
   "*",
   "max_daily_trips",
   ":",
   "if",
   "ut",
   ":",
   "return",
   "self",
   ".",
   "get_day_start_ut",
   "(",
   "row",
   ".",
   "date_str",
   ")",
   "else",
   ":",
   "return",
   "row",
   ".",
   "date_str"
  ]
 },
 {
  "idx": "maxmin-750",
  "nl_tokens": [
   "A",
   "floating",
   "point",
   "-",
   "valued",
   "dimension",
   "bounded",
   "min",
   "<",
   "=",
   "x",
   "<",
   "max"
  ],
  "pl_tokens": [
   "def",
   "add_float",
   "(",
   "self",
   ",",
   "name",
   ",",
   "<mask>",
   ",",
   "max",
   ",",
   "warp",
   "=",
   "None",
   ")",
   ":",
   "min",
   ",",
   "max",
   "=",
   "map",
   "(",
   "float",
   ",",
   "(",
   "min",
   ",",
   "max",
   ")",
   ")",
   "if",
   "not",
   "min",
   "<",
   "max",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: min >= max error'",
   "%",
   "name",
   ")",
   "if",
   "warp",
   "not",
   "in",
   "(",
   "None",
   ",",
   "'log'",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: warp=%s is not supported. use '",
   "'None or \"log\",'",
   "%",
   "(",
   "name",
   ",",
   "warp",
   ")",
   ")",
   "if",
   "min",
   "<=",
   "0",
   "and",
   "warp",
   "==",
   "'log'",
   ":",
   "raise",
   "ValueError",
   "(",
   "'variable %s: log-warping requires min > 0'",
   ")",
   "self",
   ".",
   "variables",
   "[",
   "name",
   "]",
   "=",
   "FloatVariable",
   "(",
   "name",
   ",",
   "min",
   ",",
   "max",
   ",",
   "warp",
   ")"
  ]
 },
 {
  "idx": "maxmin-751",
  "nl_tokens": [
   "Takes",
   "ciphertext",
   "from",
   "the",
   "memory",
   "bio",
   "and",
   "writes",
   "it",
   "to",
   "the",
   "socket",
   "."
  ],
  "pl_tokens": [
   "def",
   "_raw_write",
   "(",
   "self",
   ")",
   ":",
   "data_available",
   "=",
   "libssl",
   ".",
   "BIO_ctrl_pending",
   "(",
   "self",
   ".",
   "_wbio",
   ")",
   "if",
   "data_available",
   "==",
   "0",
   ":",
   "return",
   "b''",
   "to_read",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_buffer_size",
   ",",
   "data_available",
   ")",
   "read",
   "=",
   "libssl",
   ".",
   "BIO_read",
   "(",
   "self",
   ".",
   "_wbio",
   ",",
   "self",
   ".",
   "_bio_write_buffer",
   ",",
   "to_read",
   ")",
   "to_write",
   "=",
   "bytes_from_buffer",
   "(",
   "self",
   ".",
   "_bio_write_buffer",
   ",",
   "read",
   ")",
   "output",
   "=",
   "to_write",
   "while",
   "len",
   "(",
   "to_write",
   ")",
   ":",
   "raise_disconnect",
   "=",
   "False",
   "try",
   ":",
   "sent",
   "=",
   "self",
   ".",
   "_socket",
   ".",
   "send",
   "(",
   "to_write",
   ")",
   "except",
   "(",
   "socket_",
   ".",
   "error",
   ")",
   "as",
   "e",
   ":",
   "# Handle ECONNRESET and EPIPE",
   "if",
   "e",
   ".",
   "errno",
   "==",
   "104",
   "or",
   "e",
   ".",
   "errno",
   "==",
   "32",
   ":",
   "raise_disconnect",
   "=",
   "True",
   "else",
   ":",
   "raise",
   "if",
   "raise_disconnect",
   ":",
   "raise_disconnection",
   "(",
   ")",
   "to_write",
   "=",
   "to_write",
   "[",
   "sent",
   ":",
   "]",
   "if",
   "len",
   "(",
   "to_write",
   ")",
   ":",
   "self",
   ".",
   "select_write",
   "(",
   ")",
   "return",
   "output"
  ]
 },
 {
  "idx": "maxmin-752",
  "nl_tokens": [
   "Print",
   "a",
   "floating",
   "point",
   "array",
   "that",
   "is",
   "the",
   "same",
   "shape",
   "as",
   "activeState",
   "."
  ],
  "pl_tokens": [
   "def",
   "printConfidence",
   "(",
   "self",
   ",",
   "aState",
   ",",
   "maxCols",
   "=",
   "20",
   ")",
   ":",
   "def",
   "formatFPRow",
   "(",
   "var",
   ",",
   "i",
   ")",
   ":",
   "s",
   "=",
   "''",
   "for",
   "c",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "maxCols",
   ",",
   "self",
   ".",
   "numberOfCols",
   ")",
   ")",
   ":",
   "if",
   "c",
   ">",
   "0",
   "and",
   "c",
   "%",
   "10",
   "==",
   "0",
   ":",
   "s",
   "+=",
   "'   '",
   "s",
   "+=",
   "' %5.3f'",
   "%",
   "var",
   "[",
   "c",
   ",",
   "i",
   "]",
   "s",
   "+=",
   "' '",
   "return",
   "s",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "self",
   ".",
   "cellsPerColumn",
   ")",
   ":",
   "print",
   "formatFPRow",
   "(",
   "aState",
   ",",
   "i",
   ")"
  ]
 },
 {
  "idx": "maxmin-753",
  "nl_tokens": [
   "Optimize",
   "an",
   "image",
   "Resize",
   "the",
   "picture",
   "to",
   "the",
   "max_size",
   "defaulting",
   "to",
   "the",
   "large",
   "photo",
   "size",
   "of",
   "Twitter",
   "in",
   ":",
   "meth",
   ":",
   "PeonyClient",
   ".",
   "upload_media",
   "when",
   "used",
   "with",
   "the",
   "optimize_media",
   "argument",
   ".",
   "Parameters",
   "----------",
   "file_",
   ":",
   "file",
   "object",
   "the",
   "file",
   "object",
   "of",
   "an",
   "image",
   "max_size",
   ":",
   ":",
   "obj",
   ":",
   "tuple",
   "or",
   ":",
   "obj",
   ":",
   "list",
   "of",
   ":",
   "obj",
   ":",
   "int",
   "a",
   "tuple",
   "in",
   "the",
   "format",
   "(",
   "width",
   "height",
   ")",
   "which",
   "is",
   "maximum",
   "size",
   "of",
   "the",
   "picture",
   "returned",
   "by",
   "this",
   "function",
   "formats",
   ":",
   ":",
   "obj",
   "list",
   "or",
   ":",
   "obj",
   ":",
   "tuple",
   "of",
   ":",
   "obj",
   ":",
   "dict",
   "a",
   "list",
   "of",
   "all",
   "the",
   "formats",
   "to",
   "convert",
   "the",
   "picture",
   "to",
   "Returns",
   "-------",
   "file",
   "The",
   "smallest",
   "file",
   "created",
   "in",
   "this",
   "function"
  ],
  "pl_tokens": [
   "def",
   "optimize_media",
   "(",
   "file_",
   ",",
   "max_size",
   ",",
   "formats",
   ")",
   ":",
   "if",
   "not",
   "PIL",
   ":",
   "msg",
   "=",
   "(",
   "\"Pillow must be installed to optimize a media\\n\"",
   "\"$ pip3 install Pillow\"",
   ")",
   "raise",
   "RuntimeError",
   "(",
   "msg",
   ")",
   "img",
   "=",
   "PIL",
   ".",
   "Image",
   ".",
   "open",
   "(",
   "file_",
   ")",
   "# resize the picture (defaults to the 'large' photo size of Twitter",
   "# in peony.PeonyClient.upload_media)",
   "ratio",
   "=",
   "<mask>",
   "(",
   "hw",
   "/",
   "max_hw",
   "for",
   "hw",
   ",",
   "max_hw",
   "in",
   "zip",
   "(",
   "img",
   ".",
   "size",
   ",",
   "max_size",
   ")",
   ")",
   "if",
   "ratio",
   ">",
   "1",
   ":",
   "size",
   "=",
   "tuple",
   "(",
   "int",
   "(",
   "hw",
   "//",
   "ratio",
   ")",
   "for",
   "hw",
   "in",
   "img",
   ".",
   "size",
   ")",
   "img",
   "=",
   "img",
   ".",
   "resize",
   "(",
   "size",
   ",",
   "PIL",
   ".",
   "Image",
   ".",
   "ANTIALIAS",
   ")",
   "media",
   "=",
   "convert",
   "(",
   "img",
   ",",
   "formats",
   ")",
   "# do not close a file opened by the user",
   "# only close if a filename was given",
   "if",
   "not",
   "hasattr",
   "(",
   "file_",
   ",",
   "'read'",
   ")",
   ":",
   "img",
   ".",
   "close",
   "(",
   ")",
   "return",
   "media"
  ]
 },
 {
  "idx": "maxmin-754",
  "nl_tokens": [
   "Copy",
   "code",
   "running",
   "in",
   "current",
   "environment",
   "to",
   "memory"
  ],
  "pl_tokens": [
   "def",
   "CODECOPY",
   "(",
   "self",
   ",",
   "mem_offset",
   ",",
   "code_offset",
   ",",
   "size",
   ")",
   ":",
   "self",
   ".",
   "_allocate",
   "(",
   "mem_offset",
   ",",
   "size",
   ")",
   "GCOPY",
   "=",
   "3",
   "# cost to copy one 32 byte word",
   "copyfee",
   "=",
   "self",
   ".",
   "safe_mul",
   "(",
   "GCOPY",
   ",",
   "Operators",
   ".",
   "UDIV",
   "(",
   "self",
   ".",
   "safe_add",
   "(",
   "size",
   ",",
   "31",
   ")",
   ",",
   "32",
   ")",
   ")",
   "self",
   ".",
   "_consume",
   "(",
   "copyfee",
   ")",
   "if",
   "issymbolic",
   "(",
   "size",
   ")",
   ":",
   "max_size",
   "=",
   "solver",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "constraints",
   ",",
   "size",
   ")",
   "else",
   ":",
   "max_size",
   "=",
   "size",
   "for",
   "i",
   "in",
   "range",
   "(",
   "max_size",
   ")",
   ":",
   "if",
   "issymbolic",
   "(",
   "i",
   "<",
   "size",
   ")",
   ":",
   "default",
   "=",
   "Operators",
   ".",
   "ITEBV",
   "(",
   "8",
   ",",
   "i",
   "<",
   "size",
   ",",
   "0",
   ",",
   "self",
   ".",
   "_load",
   "(",
   "mem_offset",
   "+",
   "i",
   ",",
   "1",
   ")",
   ")",
   "# Fixme. unnecessary memory read",
   "else",
   ":",
   "if",
   "i",
   "<",
   "size",
   ":",
   "default",
   "=",
   "0",
   "else",
   ":",
   "default",
   "=",
   "self",
   ".",
   "_load",
   "(",
   "mem_offset",
   "+",
   "i",
   ",",
   "1",
   ")",
   "if",
   "issymbolic",
   "(",
   "code_offset",
   ")",
   ":",
   "value",
   "=",
   "Operators",
   ".",
   "ITEBV",
   "(",
   "8",
   ",",
   "code_offset",
   "+",
   "i",
   ">=",
   "len",
   "(",
   "self",
   ".",
   "bytecode",
   ")",
   ",",
   "default",
   ",",
   "self",
   ".",
   "bytecode",
   "[",
   "code_offset",
   "+",
   "i",
   "]",
   ")",
   "else",
   ":",
   "if",
   "code_offset",
   "+",
   "i",
   ">=",
   "len",
   "(",
   "self",
   ".",
   "bytecode",
   ")",
   ":",
   "value",
   "=",
   "default",
   "else",
   ":",
   "value",
   "=",
   "self",
   ".",
   "bytecode",
   "[",
   "code_offset",
   "+",
   "i",
   "]",
   "self",
   ".",
   "_store",
   "(",
   "mem_offset",
   "+",
   "i",
   ",",
   "value",
   ")",
   "self",
   ".",
   "_publish",
   "(",
   "'did_evm_read_code'",
   ",",
   "code_offset",
   ",",
   "size",
   ")"
  ]
 },
 {
  "idx": "maxmin-755",
  "nl_tokens": [
   "This",
   "calculates",
   "the",
   "ACF",
   "of",
   "a",
   "light",
   "curve",
   "."
  ],
  "pl_tokens": [
   "def",
   "autocorr_magseries",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "maxlags",
   "=",
   "1000",
   ",",
   "func",
   "=",
   "_autocorr_func3",
   ",",
   "fillgaps",
   "=",
   "0.0",
   ",",
   "filterwindow",
   "=",
   "11",
   ",",
   "forcetimebin",
   "=",
   "None",
   ",",
   "sigclip",
   "=",
   "3.0",
   ",",
   "magsarefluxes",
   "=",
   "False",
   ",",
   "verbose",
   "=",
   "True",
   ")",
   ":",
   "# get the gap-filled timeseries",
   "interpolated",
   "=",
   "fill_magseries_gaps",
   "(",
   "times",
   ",",
   "mags",
   ",",
   "errs",
   ",",
   "fillgaps",
   "=",
   "fillgaps",
   ",",
   "forcetimebin",
   "=",
   "forcetimebin",
   ",",
   "sigclip",
   "=",
   "sigclip",
   ",",
   "magsarefluxes",
   "=",
   "magsarefluxes",
   ",",
   "filterwindow",
   "=",
   "filterwindow",
   ",",
   "verbose",
   "=",
   "verbose",
   ")",
   "if",
   "not",
   "interpolated",
   ":",
   "print",
   "(",
   "'failed to interpolate light curve to minimum cadence!'",
   ")",
   "return",
   "None",
   "itimes",
   ",",
   "imags",
   "=",
   "interpolated",
   "[",
   "'itimes'",
   "]",
   ",",
   "interpolated",
   "[",
   "'imags'",
   "]",
   ",",
   "# calculate the lags up to maxlags",
   "if",
   "maxlags",
   ":",
   "lags",
   "=",
   "nparange",
   "(",
   "0",
   ",",
   "maxlags",
   ")",
   "else",
   ":",
   "lags",
   "=",
   "nparange",
   "(",
   "itimes",
   ".",
   "size",
   ")",
   "series_stdev",
   "=",
   "1.483",
   "*",
   "npmedian",
   "(",
   "npabs",
   "(",
   "imags",
   ")",
   ")",
   "if",
   "func",
   "!=",
   "_autocorr_func3",
   ":",
   "# get the autocorrelation as a function of the lag of the mag series",
   "autocorr",
   "=",
   "nparray",
   "(",
   "[",
   "func",
   "(",
   "imags",
   ",",
   "x",
   ",",
   "imags",
   ".",
   "size",
   ",",
   "0.0",
   ",",
   "series_stdev",
   ")",
   "for",
   "x",
   "in",
   "lags",
   "]",
   ")",
   "# this doesn't need a lags array",
   "else",
   ":",
   "autocorr",
   "=",
   "_autocorr_func3",
   "(",
   "imags",
   ",",
   "lags",
   "[",
   "0",
   "]",
   ",",
   "imags",
   ".",
   "size",
   ",",
   "0.0",
   ",",
   "series_stdev",
   ")",
   "# return only the maximum number of lags",
   "if",
   "maxlags",
   "is",
   "not",
   "None",
   ":",
   "autocorr",
   "=",
   "autocorr",
   "[",
   ":",
   "maxlags",
   "]",
   "interpolated",
   ".",
   "update",
   "(",
   "{",
   "'minitime'",
   ":",
   "itimes",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "'lags'",
   ":",
   "lags",
   ",",
   "'acf'",
   ":",
   "autocorr",
   "}",
   ")",
   "return",
   "interpolated"
  ]
 },
 {
  "idx": "maxmin-756",
  "nl_tokens": [
   "Return",
   "the",
   "minimum",
   "and",
   "maximum",
   "of",
   "x"
  ],
  "pl_tokens": [
   "def",
   "min_max",
   "(",
   "x",
   ",",
   "na_rm",
   "=",
   "False",
   ",",
   "finite",
   "=",
   "True",
   ")",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "x",
   ",",
   "'dtype'",
   ")",
   ":",
   "x",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "x",
   ")",
   "if",
   "na_rm",
   "and",
   "finite",
   ":",
   "x",
   "=",
   "x",
   "[",
   "np",
   ".",
   "isfinite",
   "(",
   "x",
   ")",
   "]",
   "elif",
   "not",
   "na_rm",
   "and",
   "np",
   ".",
   "any",
   "(",
   "np",
   ".",
   "isnan",
   "(",
   "x",
   ")",
   ")",
   ":",
   "return",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "elif",
   "na_rm",
   ":",
   "x",
   "=",
   "x",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "x",
   ")",
   "]",
   "elif",
   "finite",
   ":",
   "x",
   "=",
   "x",
   "[",
   "~",
   "np",
   ".",
   "isinf",
   "(",
   "x",
   ")",
   "]",
   "if",
   "(",
   "len",
   "(",
   "x",
   ")",
   ")",
   ":",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "x",
   ")",
   "else",
   ":",
   "return",
   "float",
   "(",
   "'-inf'",
   ")",
   ",",
   "float",
   "(",
   "'inf'",
   ")"
  ]
 },
 {
  "idx": "maxmin-757",
  "nl_tokens": [
   "!"
  ],
  "pl_tokens": [
   "def",
   "chebyshev_distance",
   "(",
   "point1",
   ",",
   "point2",
   ")",
   ":",
   "distance",
   "=",
   "0.0",
   "dimension",
   "=",
   "len",
   "(",
   "point1",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "dimension",
   ")",
   ":",
   "distance",
   "=",
   "<mask>",
   "(",
   "distance",
   ",",
   "abs",
   "(",
   "point1",
   "[",
   "i",
   "]",
   "-",
   "point2",
   "[",
   "i",
   "]",
   ")",
   ")",
   "return",
   "distance"
  ]
 },
 {
  "idx": "maxmin-758",
  "nl_tokens": [
   "Return",
   "the",
   "value",
   "of",
   "skipRecords",
   "for",
   "passing",
   "to",
   "estimateAnomalyLikelihoods"
  ],
  "pl_tokens": [
   "def",
   "_calcSkipRecords",
   "(",
   "numIngested",
   ",",
   "windowSize",
   ",",
   "learningPeriod",
   ")",
   ":",
   "numShiftedOut",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "numIngested",
   "-",
   "windowSize",
   ")",
   "return",
   "min",
   "(",
   "numIngested",
   ",",
   "max",
   "(",
   "0",
   ",",
   "learningPeriod",
   "-",
   "numShiftedOut",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-759",
  "nl_tokens": [
   "Finds",
   "the",
   "max",
   "and",
   "median",
   "long",
   "and",
   "short",
   "position",
   "concentrations",
   "in",
   "each",
   "time",
   "period",
   "specified",
   "by",
   "the",
   "index",
   "of",
   "positions",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_max_median_position_concentration",
   "(",
   "positions",
   ")",
   ":",
   "expos",
   "=",
   "get_percent_alloc",
   "(",
   "positions",
   ")",
   "expos",
   "=",
   "expos",
   ".",
   "drop",
   "(",
   "'cash'",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "longs",
   "=",
   "expos",
   ".",
   "where",
   "(",
   "expos",
   ".",
   "applymap",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   ">",
   "0",
   ")",
   ")",
   "shorts",
   "=",
   "expos",
   ".",
   "where",
   "(",
   "expos",
   ".",
   "applymap",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "<",
   "0",
   ")",
   ")",
   "alloc_summary",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   ")",
   "alloc_summary",
   "[",
   "'max_long'",
   "]",
   "=",
   "longs",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "alloc_summary",
   "[",
   "'median_long'",
   "]",
   "=",
   "longs",
   ".",
   "median",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "alloc_summary",
   "[",
   "'median_short'",
   "]",
   "=",
   "shorts",
   ".",
   "median",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "alloc_summary",
   "[",
   "'max_short'",
   "]",
   "=",
   "shorts",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "return",
   "alloc_summary"
  ]
 },
 {
  "idx": "maxmin-760",
  "nl_tokens": [
   "Pad",
   "each",
   "cell",
   "to",
   "the",
   "size",
   "of",
   "the",
   "largest",
   "cell",
   "in",
   "its",
   "column",
   "."
  ],
  "pl_tokens": [
   "def",
   "pad_cells",
   "(",
   "table",
   ")",
   ":",
   "col_sizes",
   "=",
   "[",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "col",
   ")",
   ")",
   "for",
   "col",
   "in",
   "zip",
   "(",
   "*",
   "table",
   ")",
   "]",
   "for",
   "row",
   "in",
   "table",
   ":",
   "for",
   "cell_num",
   ",",
   "cell",
   "in",
   "enumerate",
   "(",
   "row",
   ")",
   ":",
   "row",
   "[",
   "cell_num",
   "]",
   "=",
   "pad_to",
   "(",
   "cell",
   ",",
   "col_sizes",
   "[",
   "cell_num",
   "]",
   ")",
   "return",
   "table"
  ]
 },
 {
  "idx": "maxmin-761",
  "nl_tokens": [
   "Removes",
   "any",
   "stored",
   "records",
   "within",
   "the",
   "range",
   "from",
   "start",
   "to",
   "end",
   ".",
   "Noninclusive",
   "of",
   "end",
   "."
  ],
  "pl_tokens": [
   "def",
   "_deleteRangeFromKNN",
   "(",
   "self",
   ",",
   "start",
   "=",
   "0",
   ",",
   "end",
   "=",
   "None",
   ")",
   ":",
   "prototype_idx",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "getParameter",
   "(",
   "'categoryRecencyList'",
   ")",
   ")",
   "if",
   "end",
   "is",
   "None",
   ":",
   "end",
   "=",
   "prototype_idx",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "1",
   "idsIdxToDelete",
   "=",
   "numpy",
   ".",
   "logical_and",
   "(",
   "prototype_idx",
   ">=",
   "start",
   ",",
   "prototype_idx",
   "<",
   "end",
   ")",
   "idsToDelete",
   "=",
   "prototype_idx",
   "[",
   "idsIdxToDelete",
   "]",
   "nProtos",
   "=",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "_knn",
   ".",
   "_numPatterns",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "_knn",
   ".",
   "removeIds",
   "(",
   "idsToDelete",
   ".",
   "tolist",
   "(",
   ")",
   ")",
   "assert",
   "self",
   ".",
   "_knnclassifier",
   ".",
   "_knn",
   ".",
   "_numPatterns",
   "==",
   "nProtos",
   "-",
   "len",
   "(",
   "idsToDelete",
   ")"
  ]
 },
 {
  "idx": "maxmin-762",
  "nl_tokens": [
   "Computes",
   "the",
   "predictive",
   "ability",
   "of",
   "a",
   "temporal",
   "memory",
   "(",
   "TM",
   ")",
   ".",
   "This",
   "routine",
   "returns",
   "a",
   "value",
   "which",
   "is",
   "the",
   "average",
   "number",
   "of",
   "time",
   "steps",
   "of",
   "prediction",
   "provided",
   "by",
   "the",
   "TM",
   ".",
   "It",
   "accepts",
   "as",
   "input",
   "the",
   "inputs",
   "outputs",
   "and",
   "resets",
   "provided",
   "to",
   "the",
   "TM",
   "as",
   "well",
   "as",
   "a",
   "minOverlapPct",
   "used",
   "to",
   "evalulate",
   "whether",
   "or",
   "not",
   "a",
   "prediction",
   "is",
   "a",
   "good",
   "enough",
   "match",
   "to",
   "the",
   "actual",
   "input",
   "."
  ],
  "pl_tokens": [
   "def",
   "predictionExtent",
   "(",
   "inputs",
   ",",
   "resets",
   ",",
   "outputs",
   ",",
   "minOverlapPct",
   "=",
   "100.0",
   ")",
   ":",
   "# List of how many times we encountered each prediction amount. Element 0",
   "#  is how many times we successfully predicted 0 steps in advance, element 1",
   "#  is how many times we predicted 1 step in advance, etc.",
   "predCounts",
   "=",
   "None",
   "# Total steps of prediction over all samples",
   "predTotal",
   "=",
   "0",
   "# Total number of samples",
   "nSamples",
   "=",
   "len",
   "(",
   "outputs",
   ")",
   "# Total steps of prediction for samples at the start of the sequence, or",
   "#  for samples whose prediction runs aren't cut short by the end of the",
   "#  sequence.",
   "predTotalNotLimited",
   "=",
   "0",
   "nSamplesNotLimited",
   "=",
   "0",
   "# Compute how many cells/column we have",
   "nCols",
   "=",
   "len",
   "(",
   "inputs",
   "[",
   "0",
   "]",
   ")",
   "nCellsPerCol",
   "=",
   "len",
   "(",
   "outputs",
   "[",
   "0",
   "]",
   ")",
   "//",
   "nCols",
   "# Evalulate prediction for each output sample",
   "for",
   "idx",
   "in",
   "xrange",
   "(",
   "nSamples",
   ")",
   ":",
   "# What are the active columns for this output?",
   "activeCols",
   "=",
   "outputs",
   "[",
   "idx",
   "]",
   ".",
   "reshape",
   "(",
   "nCols",
   ",",
   "nCellsPerCol",
   ")",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "# How many steps of prediction do we have?",
   "steps",
   "=",
   "0",
   "while",
   "(",
   "idx",
   "+",
   "steps",
   "+",
   "1",
   "<",
   "nSamples",
   ")",
   "and",
   "(",
   "resets",
   "[",
   "idx",
   "+",
   "steps",
   "+",
   "1",
   "]",
   "==",
   "0",
   ")",
   ":",
   "overlap",
   "=",
   "numpy",
   ".",
   "logical_and",
   "(",
   "inputs",
   "[",
   "idx",
   "+",
   "steps",
   "+",
   "1",
   "]",
   ",",
   "activeCols",
   ")",
   "overlapPct",
   "=",
   "100.0",
   "*",
   "float",
   "(",
   "overlap",
   ".",
   "sum",
   "(",
   ")",
   ")",
   "/",
   "inputs",
   "[",
   "idx",
   "+",
   "steps",
   "+",
   "1",
   "]",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "overlapPct",
   ">=",
   "minOverlapPct",
   ":",
   "steps",
   "+=",
   "1",
   "else",
   ":",
   "break",
   "# print \"idx:\", idx, \"steps:\", steps",
   "# Accumulate into our total",
   "predCounts",
   "=",
   "_accumulateFrequencyCounts",
   "(",
   "[",
   "steps",
   "]",
   ",",
   "predCounts",
   ")",
   "predTotal",
   "+=",
   "steps",
   "# If this sample was not cut short by the end of the sequence, include",
   "#  it into the \"NotLimited\" runs",
   "if",
   "resets",
   "[",
   "idx",
   "]",
   "or",
   "(",
   "(",
   "idx",
   "+",
   "steps",
   "+",
   "1",
   "<",
   "nSamples",
   ")",
   "and",
   "(",
   "not",
   "resets",
   "[",
   "idx",
   "+",
   "steps",
   "+",
   "1",
   "]",
   ")",
   ")",
   ":",
   "predTotalNotLimited",
   "+=",
   "steps",
   "nSamplesNotLimited",
   "+=",
   "1",
   "# Return results",
   "return",
   "(",
   "float",
   "(",
   "predTotal",
   ")",
   "/",
   "nSamples",
   ",",
   "float",
   "(",
   "predTotalNotLimited",
   ")",
   "/",
   "nSamplesNotLimited",
   ",",
   "predCounts",
   ")"
  ]
 },
 {
  "idx": "maxmin-763",
  "nl_tokens": [
   "Returns",
   "the",
   "distance",
   "from",
   "the",
   "point",
   "to",
   "the",
   "interval",
   ".",
   "Zero",
   "if",
   "the",
   "point",
   "lies",
   "inside",
   "the",
   "interval",
   "."
  ],
  "pl_tokens": [
   "def",
   "distance_to_point",
   "(",
   "self",
   ",",
   "p",
   ")",
   ":",
   "if",
   "self",
   ".",
   "start",
   "<=",
   "p",
   "<=",
   "self",
   ".",
   "end",
   ":",
   "return",
   "0",
   "else",
   ":",
   "return",
   "<mask>",
   "(",
   "abs",
   "(",
   "self",
   ".",
   "start",
   "-",
   "p",
   ")",
   ",",
   "abs",
   "(",
   "self",
   ".",
   "end",
   "-",
   "p",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-764",
  "nl_tokens": [
   "Count",
   "the",
   "GPUs",
   "on",
   "this",
   "machine",
   "."
  ],
  "pl_tokens": [
   "def",
   "gpu_count",
   "(",
   ")",
   ":",
   "if",
   "shutil",
   ".",
   "which",
   "(",
   "'nvidia-smi'",
   ")",
   "is",
   "None",
   ":",
   "return",
   "0",
   "output",
   "=",
   "subprocess",
   ".",
   "check_output",
   "(",
   "[",
   "'nvidia-smi'",
   ",",
   "'--query-gpu=gpu_name'",
   ",",
   "'--format=csv'",
   "]",
   ")",
   "return",
   "<mask>",
   "(",
   "0",
   ",",
   "len",
   "(",
   "output",
   ".",
   "split",
   "(",
   "b'\\n'",
   ")",
   ")",
   "-",
   "2",
   ")"
  ]
 },
 {
  "idx": "maxmin-765",
  "nl_tokens": [
   "Solves",
   "a",
   "symbolic",
   ":",
   "class",
   ":",
   "~manticore",
   ".",
   "core",
   ".",
   "smtlib",
   ".",
   "expression",
   ".",
   "Expression",
   "into",
   "its",
   "minimum",
   "solution"
  ],
  "pl_tokens": [
   "def",
   "solve_min",
   "(",
   "self",
   ",",
   "expr",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "expr",
   ",",
   "int",
   ")",
   ":",
   "return",
   "expr",
   "expr",
   "=",
   "self",
   ".",
   "migrate_expression",
   "(",
   "expr",
   ")",
   "return",
   "self",
   ".",
   "_solver",
   ".",
   "<mask>",
   "(",
   "self",
   ".",
   "_constraints",
   ",",
   "expr",
   ")"
  ]
 },
 {
  "idx": "maxmin-766",
  "nl_tokens": [
   "addition",
   "of",
   "a",
   "number",
   "of",
   "months"
  ],
  "pl_tokens": [
   "def",
   "add_months",
   "(",
   "self",
   ",",
   "month_int",
   ")",
   ":",
   "month_int",
   "+=",
   "self",
   ".",
   "month",
   "while",
   "month_int",
   ">",
   "12",
   ":",
   "self",
   "=",
   "BusinessDate",
   ".",
   "add_years",
   "(",
   "self",
   ",",
   "1",
   ")",
   "month_int",
   "-=",
   "12",
   "while",
   "month_int",
   "<",
   "1",
   ":",
   "self",
   "=",
   "BusinessDate",
   ".",
   "add_years",
   "(",
   "self",
   ",",
   "-",
   "1",
   ")",
   "month_int",
   "+=",
   "12",
   "l",
   "=",
   "monthrange",
   "(",
   "self",
   ".",
   "year",
   ",",
   "month_int",
   ")",
   "[",
   "1",
   "]",
   "return",
   "BusinessDate",
   ".",
   "from_ymd",
   "(",
   "self",
   ".",
   "year",
   ",",
   "month_int",
   ",",
   "<mask>",
   "(",
   "l",
   ",",
   "self",
   ".",
   "day",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-767",
  "nl_tokens": [
   "Plots",
   "DataFrame",
   "output",
   "of",
   "compute_style_factor_exposures",
   "as",
   "a",
   "line",
   "graph"
  ],
  "pl_tokens": [
   "def",
   "plot_style_factor_exposures",
   "(",
   "tot_style_factor_exposure",
   ",",
   "factor_name",
   "=",
   "None",
   ",",
   "ax",
   "=",
   "None",
   ")",
   ":",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   "if",
   "factor_name",
   "is",
   "None",
   ":",
   "factor_name",
   "=",
   "tot_style_factor_exposure",
   ".",
   "name",
   "ax",
   ".",
   "plot",
   "(",
   "tot_style_factor_exposure",
   ".",
   "index",
   ",",
   "tot_style_factor_exposure",
   ",",
   "label",
   "=",
   "factor_name",
   ")",
   "avg",
   "=",
   "tot_style_factor_exposure",
   ".",
   "mean",
   "(",
   ")",
   "ax",
   ".",
   "axhline",
   "(",
   "avg",
   ",",
   "linestyle",
   "=",
   "'-.'",
   ",",
   "label",
   "=",
   "'Mean = {:.3}'",
   ".",
   "format",
   "(",
   "avg",
   ")",
   ")",
   "ax",
   ".",
   "axhline",
   "(",
   "0",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "linestyle",
   "=",
   "'-'",
   ")",
   "_",
   ",",
   "_",
   ",",
   "y1",
   ",",
   "y2",
   "=",
   "plt",
   ".",
   "axis",
   "(",
   ")",
   "lim",
   "=",
   "<mask>",
   "(",
   "abs",
   "(",
   "y1",
   ")",
   ",",
   "abs",
   "(",
   "y2",
   ")",
   ")",
   "ax",
   ".",
   "set",
   "(",
   "title",
   "=",
   "'Exposure to {}'",
   ".",
   "format",
   "(",
   "factor_name",
   ")",
   ",",
   "ylabel",
   "=",
   "'{} \\n weighted exposure'",
   ".",
   "format",
   "(",
   "factor_name",
   ")",
   ",",
   "ylim",
   "=",
   "(",
   "-",
   "lim",
   ",",
   "lim",
   ")",
   ")",
   "ax",
   ".",
   "legend",
   "(",
   "frameon",
   "=",
   "True",
   ",",
   "framealpha",
   "=",
   "0.5",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-768",
  "nl_tokens": [
   "we",
   "expect",
   "foo",
   "=",
   "bar"
  ],
  "pl_tokens": [
   "def",
   "parse_segment",
   "(",
   "text",
   ")",
   ":",
   "if",
   "not",
   "len",
   "(",
   "text",
   ")",
   ":",
   "return",
   "NoopQuerySegment",
   "(",
   ")",
   "q",
   "=",
   "QuerySegment",
   "(",
   ")",
   "# First we need to split the segment into key/value pairs.  This is done",
   "# by attempting to split the sequence for each equality comparison.  Then",
   "# discard any that did not split properly.  Then chose the smallest key",
   "# (greedily chose the first comparator we encounter in the string)",
   "# followed by the smallest value (greedily chose the largest comparator",
   "# possible.)",
   "# translate into [('=', 'foo=bar')]",
   "equalities",
   "=",
   "zip",
   "(",
   "constants",
   ".",
   "OPERATOR_EQUALITIES",
   ",",
   "itertools",
   ".",
   "repeat",
   "(",
   "text",
   ")",
   ")",
   "# Translate into [('=', ['foo', 'bar'])]",
   "equalities",
   "=",
   "map",
   "(",
   "lambda",
   "x",
   ":",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "x",
   "[",
   "1",
   "]",
   ".",
   "split",
   "(",
   "x",
   "[",
   "0",
   "]",
   ",",
   "1",
   ")",
   ")",
   ",",
   "equalities",
   ")",
   "# Remove unsplit entries and translate into [('=': ['foo', 'bar'])]",
   "# Note that the result from this stage is iterated over twice.",
   "equalities",
   "=",
   "list",
   "(",
   "filter",
   "(",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   "[",
   "1",
   "]",
   ")",
   ">",
   "1",
   ",",
   "equalities",
   ")",
   ")",
   "# Get the smallest key and use the length of that to remove other items",
   "key_len",
   "=",
   "len",
   "(",
   "<mask>",
   "(",
   "(",
   "x",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   "for",
   "x",
   "in",
   "equalities",
   ")",
   ",",
   "key",
   "=",
   "len",
   ")",
   ")",
   "equalities",
   "=",
   "filter",
   "(",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ")",
   "==",
   "key_len",
   ",",
   "equalities",
   ")",
   "# Get the smallest value length. thus we have the earliest key and the",
   "# smallest value.",
   "op",
   ",",
   "(",
   "key",
   ",",
   "value",
   ")",
   "=",
   "min",
   "(",
   "equalities",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   ")",
   ")",
   "key",
   ",",
   "directive",
   "=",
   "parse_directive",
   "(",
   "key",
   ")",
   "if",
   "directive",
   ":",
   "op",
   "=",
   "constants",
   ".",
   "OPERATOR_EQUALITY_FALLBACK",
   "q",
   ".",
   "directive",
   "=",
   "directive",
   "# Process negation.  This comes in both foo.not= and foo!= forms.",
   "path",
   "=",
   "key",
   ".",
   "split",
   "(",
   "constants",
   ".",
   "SEP_PATH",
   ")",
   "last",
   "=",
   "path",
   "[",
   "-",
   "1",
   "]",
   "# Check for !=",
   "if",
   "last",
   ".",
   "endswith",
   "(",
   "constants",
   ".",
   "OPERATOR_NEGATION",
   ")",
   ":",
   "last",
   "=",
   "last",
   "[",
   ":",
   "-",
   "1",
   "]",
   "q",
   ".",
   "negated",
   "=",
   "not",
   "q",
   ".",
   "negated",
   "# Check for foo.not=",
   "if",
   "last",
   "==",
   "constants",
   ".",
   "PATH_NEGATION",
   ":",
   "path",
   ".",
   "pop",
   "(",
   "-",
   "1",
   ")",
   "q",
   ".",
   "negated",
   "=",
   "not",
   "q",
   ".",
   "negated",
   "q",
   ".",
   "values",
   "=",
   "value",
   ".",
   "split",
   "(",
   "constants",
   ".",
   "SEP_VALUE",
   ")",
   "# Check for suffixed operators (foo.gte=bar).  Prioritize suffixed",
   "# entries over actual equality checks.",
   "if",
   "path",
   "[",
   "-",
   "1",
   "]",
   "in",
   "constants",
   ".",
   "OPERATOR_SUFFIXES",
   ":",
   "# The case where foo.gte<=bar, which obviously makes no sense.",
   "if",
   "op",
   "not",
   "in",
   "constants",
   ".",
   "OPERATOR_FALLBACK",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Both path-style operator and equality style operator '",
   "'provided.  Please provide only a single style operator.'",
   ")",
   "q",
   ".",
   "operator",
   "=",
   "constants",
   ".",
   "OPERATOR_SUFFIX_MAP",
   "[",
   "path",
   "[",
   "-",
   "1",
   "]",
   "]",
   "path",
   ".",
   "pop",
   "(",
   "-",
   "1",
   ")",
   "else",
   ":",
   "q",
   ".",
   "operator",
   "=",
   "constants",
   ".",
   "OPERATOR_EQUALITY_MAP",
   "[",
   "op",
   "]",
   "if",
   "not",
   "len",
   "(",
   "path",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'No attribute navigation path provided.'",
   ")",
   "q",
   ".",
   "path",
   "=",
   "path",
   "return",
   "q"
  ]
 },
 {
  "idx": "maxmin-769",
  "nl_tokens": [
   "addition",
   "of",
   "a",
   "number",
   "of",
   "years"
  ],
  "pl_tokens": [
   "def",
   "add_years",
   "(",
   "date_obj",
   ",",
   "years_int",
   ")",
   ":",
   "y",
   ",",
   "m",
   ",",
   "d",
   "=",
   "BaseDateTuple",
   ".",
   "to_ymd",
   "(",
   "date_obj",
   ")",
   "y",
   "+=",
   "years_int",
   "if",
   "not",
   "is_leap_year",
   "(",
   "y",
   ")",
   "and",
   "m",
   "==",
   "2",
   ":",
   "d",
   "=",
   "<mask>",
   "(",
   "28",
   ",",
   "d",
   ")",
   "return",
   "BaseDateTuple",
   ".",
   "from_ymd",
   "(",
   "y",
   ",",
   "m",
   ",",
   "d",
   ")"
  ]
 },
 {
  "idx": "maxmin-770",
  "nl_tokens": [
   "Check",
   "to",
   "see",
   "if",
   "a",
   "proposed",
   "tuple",
   "of",
   "axes",
   "is",
   "a",
   "valid",
   "permutation",
   "of",
   "an",
   "old",
   "set",
   "of",
   "axes",
   ".",
   "Checks",
   "length",
   "axis",
   "repetion",
   "and",
   "bounds",
   "."
  ],
  "pl_tokens": [
   "def",
   "istransposeable",
   "(",
   "new",
   ",",
   "old",
   ")",
   ":",
   "new",
   ",",
   "old",
   "=",
   "tupleize",
   "(",
   "new",
   ")",
   ",",
   "tupleize",
   "(",
   "old",
   ")",
   "if",
   "not",
   "len",
   "(",
   "new",
   ")",
   "==",
   "len",
   "(",
   "old",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Axes do not match axes of keys\"",
   ")",
   "if",
   "not",
   "len",
   "(",
   "set",
   "(",
   "new",
   ")",
   ")",
   "==",
   "len",
   "(",
   "set",
   "(",
   "old",
   ")",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Repeated axes\"",
   ")",
   "if",
   "any",
   "(",
   "n",
   "<",
   "0",
   "for",
   "n",
   "in",
   "new",
   ")",
   "or",
   "<mask>",
   "(",
   "new",
   ")",
   ">",
   "len",
   "(",
   "old",
   ")",
   "-",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Invalid axes\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-771",
  "nl_tokens": [
   "Identify",
   "a",
   "filter",
   "by",
   "fuzzy",
   "string",
   "matching",
   "."
  ],
  "pl_tokens": [
   "def",
   "fuzzmatch",
   "(",
   "self",
   ",",
   "fuzzkey",
   ",",
   "multi",
   "=",
   "False",
   ")",
   ":",
   "keys",
   ",",
   "ratios",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "(",
   "f",
   ",",
   "seqm",
   "(",
   "None",
   ",",
   "fuzzkey",
   ",",
   "f",
   ")",
   ".",
   "ratio",
   "(",
   ")",
   ")",
   "for",
   "f",
   "in",
   "self",
   ".",
   "components",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   ".",
   "T",
   "mratio",
   "=",
   "<mask>",
   "(",
   "ratios",
   ")",
   "if",
   "multi",
   ":",
   "return",
   "keys",
   "[",
   "ratios",
   "==",
   "mratio",
   "]",
   "else",
   ":",
   "if",
   "sum",
   "(",
   "ratios",
   "==",
   "mratio",
   ")",
   "==",
   "1",
   ":",
   "return",
   "keys",
   "[",
   "ratios",
   "==",
   "mratio",
   "]",
   "[",
   "0",
   "]",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"\\nThe filter key provided ('{:}') matches two or more filter names equally well:\\n\"",
   ".",
   "format",
   "(",
   "fuzzkey",
   ")",
   "+",
   "', '",
   ".",
   "join",
   "(",
   "keys",
   "[",
   "ratios",
   "==",
   "mratio",
   "]",
   ")",
   "+",
   "\"\\nPlease be more specific!\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-772",
  "nl_tokens": [
   "Get",
   "the",
   "optimal",
   "read",
   "trim",
   "range",
   "from",
   "data",
   "files",
   "of",
   "paired",
   "FastQ",
   "reads",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_sample_trim",
   "(",
   "p1_data",
   ",",
   "p2_data",
   ")",
   ":",
   "sample_ranges",
   "=",
   "[",
   "trim_range",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "[",
   "p1_data",
   ",",
   "p2_data",
   "]",
   "]",
   "# Get the optimal trim position for 5' end",
   "optimal_5trim",
   "=",
   "<mask>",
   "(",
   "[",
   "x",
   "[",
   "0",
   "]",
   "for",
   "x",
   "in",
   "sample_ranges",
   "]",
   ")",
   "# Get optimal trim position for 3' end",
   "optimal_3trim",
   "=",
   "min",
   "(",
   "[",
   "x",
   "[",
   "1",
   "]",
   "for",
   "x",
   "in",
   "sample_ranges",
   "]",
   ")",
   "return",
   "optimal_5trim",
   ",",
   "optimal_3trim"
  ]
 },
 {
  "idx": "maxmin-773",
  "nl_tokens": [
   "Build",
   "the",
   "integer",
   "optionally",
   "providing",
   "a",
   "pre",
   "list",
   "that",
   "*",
   "may",
   "*",
   "be",
   "used",
   "to",
   "define",
   "prerequisites",
   "for",
   "a",
   "Field",
   "being",
   "built",
   "."
  ],
  "pl_tokens": [
   "def",
   "build",
   "(",
   "self",
   ",",
   "pre",
   "=",
   "None",
   ",",
   "shortest",
   "=",
   "False",
   ")",
   ":",
   "if",
   "pre",
   "is",
   "None",
   ":",
   "pre",
   "=",
   "[",
   "]",
   "if",
   "self",
   ".",
   "value",
   "is",
   "not",
   "None",
   "and",
   "rand",
   ".",
   "maybe",
   "(",
   ")",
   ":",
   "return",
   "utils",
   ".",
   "val",
   "(",
   "self",
   ".",
   "value",
   ",",
   "pre",
   ",",
   "shortest",
   "=",
   "shortest",
   ")",
   "if",
   "self",
   ".",
   "<mask>",
   "==",
   "self",
   ".",
   "max",
   ":",
   "return",
   "self",
   ".",
   "min",
   "res",
   "=",
   "self",
   ".",
   "_odds_val",
   "(",
   ")",
   "if",
   "self",
   ".",
   "neg",
   "and",
   "rand",
   ".",
   "maybe",
   "(",
   ")",
   ":",
   "res",
   "=",
   "-",
   "res",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-774",
  "nl_tokens": [
   "Convert",
   "a",
   "power",
   "spectrogram",
   "(",
   "amplitude",
   "squared",
   ")",
   "to",
   "decibel",
   "(",
   "dB",
   ")",
   "units"
  ],
  "pl_tokens": [
   "def",
   "power_to_db",
   "(",
   "S",
   ",",
   "ref",
   "=",
   "1.0",
   ",",
   "amin",
   "=",
   "1e-10",
   ",",
   "top_db",
   "=",
   "80.0",
   ")",
   ":",
   "S",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "S",
   ")",
   "if",
   "amin",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'amin must be strictly positive'",
   ")",
   "if",
   "np",
   ".",
   "issubdtype",
   "(",
   "S",
   ".",
   "dtype",
   ",",
   "np",
   ".",
   "complexfloating",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "'power_to_db was called on complex input so phase '",
   "'information will be discarded. To suppress this warning, '",
   "'call power_to_db(np.abs(D)**2) instead.'",
   ")",
   "magnitude",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "S",
   ")",
   "else",
   ":",
   "magnitude",
   "=",
   "S",
   "if",
   "six",
   ".",
   "callable",
   "(",
   "ref",
   ")",
   ":",
   "# User supplied a function to calculate reference power",
   "ref_value",
   "=",
   "ref",
   "(",
   "magnitude",
   ")",
   "else",
   ":",
   "ref_value",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "ref",
   ")",
   "log_spec",
   "=",
   "10.0",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "amin",
   ",",
   "magnitude",
   ")",
   ")",
   "log_spec",
   "-=",
   "10.0",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "amin",
   ",",
   "ref_value",
   ")",
   ")",
   "if",
   "top_db",
   "is",
   "not",
   "None",
   ":",
   "if",
   "top_db",
   "<",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'top_db must be non-negative'",
   ")",
   "log_spec",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "log_spec",
   ",",
   "log_spec",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "top_db",
   ")",
   "return",
   "log_spec"
  ]
 },
 {
  "idx": "maxmin-775",
  "nl_tokens": [
   "get",
   "merged",
   "info",
   "about",
   "phantom",
   "conf"
  ],
  "pl_tokens": [
   "def",
   "get_info",
   "(",
   "self",
   ")",
   ":",
   "result",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "self",
   ".",
   "streams",
   "[",
   "0",
   "]",
   ")",
   "result",
   ".",
   "stat_log",
   "=",
   "self",
   ".",
   "stat_log",
   "result",
   ".",
   "steps",
   "=",
   "[",
   "]",
   "result",
   ".",
   "ammo_file",
   "=",
   "''",
   "result",
   ".",
   "rps_schedule",
   "=",
   "None",
   "result",
   ".",
   "ammo_count",
   "=",
   "0",
   "result",
   ".",
   "duration",
   "=",
   "0",
   "result",
   ".",
   "instances",
   "=",
   "0",
   "result",
   ".",
   "loadscheme",
   "=",
   "[",
   "]",
   "result",
   ".",
   "loop_count",
   "=",
   "0",
   "for",
   "stream",
   "in",
   "self",
   ".",
   "streams",
   ":",
   "sec_no",
   "=",
   "0",
   "logger",
   ".",
   "debug",
   "(",
   "\"Steps: %s\"",
   ",",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "steps",
   ")",
   "for",
   "item",
   "in",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "steps",
   ":",
   "for",
   "x",
   "in",
   "range",
   "(",
   "0",
   ",",
   "item",
   "[",
   "1",
   "]",
   ")",
   ":",
   "if",
   "len",
   "(",
   "result",
   ".",
   "steps",
   ")",
   ">",
   "sec_no",
   ":",
   "result",
   ".",
   "steps",
   "[",
   "sec_no",
   "]",
   "[",
   "0",
   "]",
   "+=",
   "item",
   "[",
   "0",
   "]",
   "else",
   ":",
   "result",
   ".",
   "steps",
   ".",
   "append",
   "(",
   "[",
   "item",
   "[",
   "0",
   "]",
   ",",
   "1",
   "]",
   ")",
   "sec_no",
   "+=",
   "1",
   "if",
   "result",
   ".",
   "rps_schedule",
   ":",
   "result",
   ".",
   "rps_schedule",
   "=",
   "[",
   "]",
   "else",
   ":",
   "result",
   ".",
   "rps_schedule",
   "=",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "loadscheme",
   "if",
   "result",
   ".",
   "loadscheme",
   ":",
   "result",
   ".",
   "loadscheme",
   "=",
   "''",
   "else",
   ":",
   "# FIXME: add formatted load scheme for server:",
   "# <step_size,step_type,first_rps,last_rps,original_step_params>",
   "# as a string",
   "result",
   ".",
   "loadscheme",
   "=",
   "''",
   "if",
   "result",
   ".",
   "loop_count",
   ":",
   "result",
   ".",
   "loop_count",
   "=",
   "u'0'",
   "else",
   ":",
   "result",
   ".",
   "loop_count",
   "=",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "loop_count",
   "result",
   ".",
   "ammo_file",
   "+=",
   "'{} '",
   ".",
   "format",
   "(",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "ammo_file",
   ")",
   "result",
   ".",
   "ammo_count",
   "+=",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "ammo_count",
   "result",
   ".",
   "duration",
   "=",
   "<mask>",
   "(",
   "result",
   ".",
   "duration",
   ",",
   "stream",
   ".",
   "stepper_wrapper",
   ".",
   "duration",
   ")",
   "result",
   ".",
   "instances",
   "+=",
   "stream",
   ".",
   "instances",
   "if",
   "not",
   "result",
   ".",
   "ammo_count",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Total ammo count cannot be zero\"",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-776",
  "nl_tokens": [
   "Plot",
   "the",
   "variable",
   "importance",
   "for",
   "a",
   "trained",
   "model",
   "."
  ],
  "pl_tokens": [
   "def",
   "varimp_plot",
   "(",
   "self",
   ",",
   "num_of_features",
   "=",
   "None",
   ",",
   "server",
   "=",
   "False",
   ")",
   ":",
   "assert_is_type",
   "(",
   "num_of_features",
   ",",
   "None",
   ",",
   "int",
   ")",
   "assert_is_type",
   "(",
   "server",
   ",",
   "bool",
   ")",
   "plt",
   "=",
   "_get_matplotlib_pyplot",
   "(",
   "server",
   ")",
   "if",
   "not",
   "plt",
   ":",
   "return",
   "# get the variable importances as a list of tuples, do not use pandas dataframe",
   "importances",
   "=",
   "self",
   ".",
   "varimp",
   "(",
   "use_pandas",
   "=",
   "False",
   ")",
   "# features labels correspond to the first value of each tuple in the importances list",
   "feature_labels",
   "=",
   "[",
   "tup",
   "[",
   "0",
   "]",
   "for",
   "tup",
   "in",
   "importances",
   "]",
   "# relative importances correspond to the first value of each tuple in the importances list",
   "scaled_importances",
   "=",
   "[",
   "tup",
   "[",
   "2",
   "]",
   "for",
   "tup",
   "in",
   "importances",
   "]",
   "# specify bar centers on the y axis, but flip the order so largest bar appears at top",
   "pos",
   "=",
   "range",
   "(",
   "len",
   "(",
   "feature_labels",
   ")",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "# specify the bar lengths",
   "val",
   "=",
   "scaled_importances",
   "# # check that num_of_features is an integer",
   "# if num_of_features is None:",
   "#     num_of_features = len(val)",
   "# default to 10 or less features if num_of_features is not specified",
   "if",
   "num_of_features",
   "is",
   "None",
   ":",
   "num_of_features",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "val",
   ")",
   ",",
   "10",
   ")",
   "fig",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "1",
   ",",
   "1",
   ",",
   "figsize",
   "=",
   "(",
   "14",
   ",",
   "10",
   ")",
   ")",
   "# create separate plot for the case where num_of_features == 1",
   "if",
   "num_of_features",
   "==",
   "1",
   ":",
   "plt",
   ".",
   "barh",
   "(",
   "pos",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ",",
   "val",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ",",
   "align",
   "=",
   "\"center\"",
   ",",
   "height",
   "=",
   "0.8",
   ",",
   "color",
   "=",
   "\"#1F77B4\"",
   ",",
   "edgecolor",
   "=",
   "\"none\"",
   ")",
   "# Hide the right and top spines, color others grey",
   "ax",
   ".",
   "spines",
   "[",
   "\"right\"",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "\"top\"",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "\"bottom\"",
   "]",
   ".",
   "set_color",
   "(",
   "\"#7B7B7B\"",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "\"left\"",
   "]",
   ".",
   "set_color",
   "(",
   "\"#7B7B7B\"",
   ")",
   "# Only show ticks on the left and bottom spines",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_ticks_position",
   "(",
   "\"left\"",
   ")",
   "ax",
   ".",
   "xaxis",
   ".",
   "set_ticks_position",
   "(",
   "\"bottom\"",
   ")",
   "plt",
   ".",
   "yticks",
   "(",
   "pos",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ",",
   "feature_labels",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ")",
   "ax",
   ".",
   "margins",
   "(",
   "None",
   ",",
   "0.5",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "barh",
   "(",
   "pos",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ",",
   "val",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ",",
   "align",
   "=",
   "\"center\"",
   ",",
   "height",
   "=",
   "0.8",
   ",",
   "color",
   "=",
   "\"#1F77B4\"",
   ",",
   "edgecolor",
   "=",
   "\"none\"",
   ")",
   "# Hide the right and top spines, color others grey",
   "ax",
   ".",
   "spines",
   "[",
   "\"right\"",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "\"top\"",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "\"bottom\"",
   "]",
   ".",
   "set_color",
   "(",
   "\"#7B7B7B\"",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "\"left\"",
   "]",
   ".",
   "set_color",
   "(",
   "\"#7B7B7B\"",
   ")",
   "# Only show ticks on the left and bottom spines",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_ticks_position",
   "(",
   "\"left\"",
   ")",
   "ax",
   ".",
   "xaxis",
   ".",
   "set_ticks_position",
   "(",
   "\"bottom\"",
   ")",
   "plt",
   ".",
   "yticks",
   "(",
   "pos",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ",",
   "feature_labels",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ")",
   "plt",
   ".",
   "ylim",
   "(",
   "[",
   "min",
   "(",
   "pos",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ")",
   "-",
   "1",
   ",",
   "max",
   "(",
   "pos",
   "[",
   "0",
   ":",
   "num_of_features",
   "]",
   ")",
   "+",
   "1",
   "]",
   ")",
   "# ax.margins(y=0.5)",
   "# check which algorithm was used to select right plot title",
   "if",
   "self",
   ".",
   "_model_json",
   "[",
   "\"algo\"",
   "]",
   "==",
   "\"gbm\"",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "\"Variable Importance: H2O GBM\"",
   ",",
   "fontsize",
   "=",
   "20",
   ")",
   "if",
   "not",
   "server",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "elif",
   "self",
   ".",
   "_model_json",
   "[",
   "\"algo\"",
   "]",
   "==",
   "\"drf\"",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "\"Variable Importance: H2O DRF\"",
   ",",
   "fontsize",
   "=",
   "20",
   ")",
   "if",
   "not",
   "server",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "elif",
   "self",
   ".",
   "_model_json",
   "[",
   "\"algo\"",
   "]",
   "==",
   "\"xgboost\"",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "\"Variable Importance: H2O XGBoost\"",
   ",",
   "fontsize",
   "=",
   "20",
   ")",
   "if",
   "not",
   "server",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "# if H2ODeepLearningEstimator has variable_importances == True",
   "elif",
   "self",
   ".",
   "_model_json",
   "[",
   "\"algo\"",
   "]",
   "==",
   "\"deeplearning\"",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "\"Variable Importance: H2O Deep Learning\"",
   ",",
   "fontsize",
   "=",
   "20",
   ")",
   "if",
   "not",
   "server",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "elif",
   "self",
   ".",
   "_model_json",
   "[",
   "\"algo\"",
   "]",
   "==",
   "\"glm\"",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "\"Variable Importance: H2O GLM\"",
   ",",
   "fontsize",
   "=",
   "20",
   ")",
   "if",
   "not",
   "server",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "else",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"A variable importances plot is not implemented for this type of model\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-777",
  "nl_tokens": [
   "Computes",
   "the",
   "number",
   "of",
   "edges",
   "on",
   "longest",
   "path",
   "from",
   "node",
   "to",
   "root",
   "."
  ],
  "pl_tokens": [
   "def",
   "_depth",
   "(",
   "g",
   ")",
   ":",
   "def",
   "_explore",
   "(",
   "v",
   ")",
   ":",
   "if",
   "v",
   ".",
   "depth",
   "<",
   "0",
   ":",
   "v",
   ".",
   "depth",
   "=",
   "(",
   "(",
   "1",
   "+",
   "<mask>",
   "(",
   "[",
   "-",
   "1",
   "]",
   "+",
   "[",
   "_explore",
   "(",
   "annotated_graph",
   "[",
   "u",
   "]",
   ")",
   "for",
   "u",
   "in",
   "v",
   ".",
   "parents",
   "]",
   ")",
   ")",
   "if",
   "v",
   ".",
   "parents",
   "else",
   "0",
   ")",
   "return",
   "v",
   ".",
   "depth",
   "annotated_graph",
   "=",
   "{",
   "k",
   ":",
   "_Node",
   "(",
   "k",
   ",",
   "v",
   ")",
   "for",
   "k",
   ",",
   "v",
   "in",
   "g",
   ".",
   "items",
   "(",
   ")",
   "}",
   "for",
   "v",
   "in",
   "annotated_graph",
   ".",
   "values",
   "(",
   ")",
   ":",
   "_explore",
   "(",
   "v",
   ")",
   "return",
   "annotated_graph"
  ]
 },
 {
  "idx": "maxmin-778",
  "nl_tokens": [
   "Return",
   "a",
   "stack",
   "of",
   "frames",
   "which",
   "the",
   "debugger",
   "will",
   "use",
   "for",
   "in",
   "showing",
   "backtraces",
   "and",
   "in",
   "frame",
   "switching",
   ".",
   "As",
   "such",
   "various",
   "frame",
   "that",
   "are",
   "really",
   "around",
   "may",
   "be",
   "excluded",
   "unless",
   "we",
   "are",
   "debugging",
   "the",
   "sebugger",
   ".",
   "Also",
   "we",
   "will",
   "add",
   "traceback",
   "frame",
   "on",
   "top",
   "if",
   "that",
   "exists",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_stack",
   "(",
   "f",
   ",",
   "t",
   ",",
   "botframe",
   ",",
   "proc_obj",
   "=",
   "None",
   ")",
   ":",
   "exclude_frame",
   "=",
   "lambda",
   "f",
   ":",
   "False",
   "if",
   "proc_obj",
   ":",
   "settings",
   "=",
   "proc_obj",
   ".",
   "debugger",
   ".",
   "settings",
   "if",
   "not",
   "settings",
   "[",
   "'dbg_trepan'",
   "]",
   ":",
   "exclude_frame",
   "=",
   "lambda",
   "f",
   ":",
   "proc_obj",
   ".",
   "core",
   ".",
   "ignore_filter",
   ".",
   "is_included",
   "(",
   "f",
   ")",
   "pass",
   "pass",
   "stack",
   "=",
   "[",
   "]",
   "if",
   "t",
   "and",
   "t",
   ".",
   "tb_frame",
   "is",
   "f",
   ":",
   "t",
   "=",
   "t",
   ".",
   "tb_next",
   "while",
   "f",
   "is",
   "not",
   "None",
   ":",
   "if",
   "exclude_frame",
   "(",
   "f",
   ")",
   ":",
   "break",
   "# See commented alternative below",
   "stack",
   ".",
   "append",
   "(",
   "(",
   "f",
   ",",
   "f",
   ".",
   "f_lineno",
   ")",
   ")",
   "# bdb has:",
   "# if f is botframe: break",
   "f",
   "=",
   "f",
   ".",
   "f_back",
   "pass",
   "stack",
   ".",
   "reverse",
   "(",
   ")",
   "i",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "len",
   "(",
   "stack",
   ")",
   "-",
   "1",
   ")",
   "while",
   "t",
   "is",
   "not",
   "None",
   ":",
   "stack",
   ".",
   "append",
   "(",
   "(",
   "t",
   ".",
   "tb_frame",
   ",",
   "t",
   ".",
   "tb_lineno",
   ")",
   ")",
   "t",
   "=",
   "t",
   ".",
   "tb_next",
   "pass",
   "return",
   "stack",
   ",",
   "i"
  ]
 },
 {
  "idx": "maxmin-779",
  "nl_tokens": [
   "Shade",
   "*",
   "color",
   "*",
   "using",
   "normal",
   "vectors",
   "given",
   "by",
   "*",
   "normals",
   "*",
   ".",
   "*",
   "color",
   "*",
   "can",
   "also",
   "be",
   "an",
   "array",
   "of",
   "the",
   "same",
   "length",
   "as",
   "*",
   "normals",
   "*",
   "."
  ],
  "pl_tokens": [
   "def",
   "_shade_colors",
   "(",
   "color",
   ",",
   "normals",
   ",",
   "lightsource",
   "=",
   "None",
   ")",
   ":",
   "if",
   "lightsource",
   "is",
   "None",
   ":",
   "# chosen for backwards-compatibility",
   "lightsource",
   "=",
   "LightSource",
   "(",
   "azdeg",
   "=",
   "225",
   ",",
   "altdeg",
   "=",
   "19.4712",
   ")",
   "shade",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "dot",
   "(",
   "n",
   "/",
   "proj3d",
   ".",
   "mod",
   "(",
   "n",
   ")",
   ",",
   "lightsource",
   ".",
   "direction",
   ")",
   "if",
   "proj3d",
   ".",
   "mod",
   "(",
   "n",
   ")",
   "else",
   "np",
   ".",
   "nan",
   "for",
   "n",
   "in",
   "normals",
   "]",
   ")",
   "mask",
   "=",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "shade",
   ")",
   "if",
   "mask",
   ".",
   "any",
   "(",
   ")",
   ":",
   "norm",
   "=",
   "Normalize",
   "(",
   "<mask>",
   "(",
   "shade",
   "[",
   "mask",
   "]",
   ")",
   ",",
   "max",
   "(",
   "shade",
   "[",
   "mask",
   "]",
   ")",
   ")",
   "shade",
   "[",
   "~",
   "mask",
   "]",
   "=",
   "min",
   "(",
   "shade",
   "[",
   "mask",
   "]",
   ")",
   "color",
   "=",
   "mcolors",
   ".",
   "to_rgba_array",
   "(",
   "color",
   ")",
   "# shape of color should be (M, 4) (where M is number of faces)",
   "# shape of shade should be (M,)",
   "# colors should have final shape of (M, 4)",
   "alpha",
   "=",
   "color",
   "[",
   ":",
   ",",
   "3",
   "]",
   "colors",
   "=",
   "(",
   "0.5",
   "+",
   "norm",
   "(",
   "shade",
   ")",
   "[",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "*",
   "0.5",
   ")",
   "*",
   "color",
   "colors",
   "[",
   ":",
   ",",
   "3",
   "]",
   "=",
   "alpha",
   "else",
   ":",
   "colors",
   "=",
   "np",
   ".",
   "asanyarray",
   "(",
   "color",
   ")",
   ".",
   "copy",
   "(",
   ")",
   "return",
   "colors"
  ]
 },
 {
  "idx": "maxmin-780",
  "nl_tokens": [
   "Keeps",
   "track",
   "of",
   "the",
   "furthest",
   "point",
   "in",
   "the",
   "source",
   "code",
   "the",
   "parser",
   "has",
   "reached",
   "to",
   "this",
   "point",
   "."
  ],
  "pl_tokens": [
   "def",
   "_attempting",
   "(",
   "self",
   ",",
   "text",
   ")",
   ":",
   "consumed",
   "=",
   "len",
   "(",
   "self",
   ".",
   "original_text",
   ")",
   "-",
   "len",
   "(",
   "text",
   ")",
   "self",
   ".",
   "most_consumed",
   "=",
   "<mask>",
   "(",
   "consumed",
   ",",
   "self",
   ".",
   "most_consumed",
   ")"
  ]
 },
 {
  "idx": "maxmin-781",
  "nl_tokens": [
   "Pre",
   "-",
   "process",
   "list",
   "of",
   "SV",
   "variants",
   "."
  ],
  "pl_tokens": [
   "def",
   "sv_variants",
   "(",
   "store",
   ",",
   "institute_obj",
   ",",
   "case_obj",
   ",",
   "variants_query",
   ",",
   "page",
   "=",
   "1",
   ",",
   "per_page",
   "=",
   "50",
   ")",
   ":",
   "skip_count",
   "=",
   "(",
   "per_page",
   "*",
   "<mask>",
   "(",
   "page",
   "-",
   "1",
   ",",
   "0",
   ")",
   ")",
   "more_variants",
   "=",
   "True",
   "if",
   "variants_query",
   ".",
   "count",
   "(",
   ")",
   ">",
   "(",
   "skip_count",
   "+",
   "per_page",
   ")",
   "else",
   "False",
   "genome_build",
   "=",
   "case_obj",
   ".",
   "get",
   "(",
   "'genome_build'",
   ",",
   "'37'",
   ")",
   "if",
   "genome_build",
   "not",
   "in",
   "[",
   "'37'",
   ",",
   "'38'",
   "]",
   ":",
   "genome_build",
   "=",
   "'37'",
   "return",
   "{",
   "'variants'",
   ":",
   "(",
   "parse_variant",
   "(",
   "store",
   ",",
   "institute_obj",
   ",",
   "case_obj",
   ",",
   "variant",
   ",",
   "genome_build",
   "=",
   "genome_build",
   ")",
   "for",
   "variant",
   "in",
   "variants_query",
   ".",
   "skip",
   "(",
   "skip_count",
   ")",
   ".",
   "limit",
   "(",
   "per_page",
   ")",
   ")",
   ",",
   "'more_variants'",
   ":",
   "more_variants",
   ",",
   "}"
  ]
 },
 {
  "idx": "maxmin-782",
  "nl_tokens": [
   "Plot",
   "the",
   "fitted",
   "lognormal",
   "distribution"
  ],
  "pl_tokens": [
   "def",
   "plot_lognormal_pdf",
   "(",
   "self",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "self",
   ",",
   "'lognormal_dist'",
   ")",
   ":",
   "return",
   "normalized_pdf",
   "=",
   "self",
   ".",
   "lognormal_dist",
   ".",
   "pdf",
   "(",
   "self",
   ".",
   "data",
   ")",
   "/",
   "self",
   ".",
   "lognormal_dist",
   ".",
   "pdf",
   "(",
   "self",
   ".",
   "data",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "minY",
   ",",
   "maxY",
   "=",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "get_ylim",
   "(",
   ")",
   "pylab",
   ".",
   "plot",
   "(",
   "self",
   ".",
   "data",
   ",",
   "normalized_pdf",
   "*",
   "maxY",
   ",",
   "'.'",
   ",",
   "*",
   "*",
   "kwargs",
   ")"
  ]
 },
 {
  "idx": "maxmin-783",
  "nl_tokens": [
   "Function",
   "for",
   "calculating",
   "the",
   "ablation",
   "time",
   "for",
   "each",
   "ablation",
   "."
  ],
  "pl_tokens": [
   "def",
   "ablation_times",
   "(",
   "self",
   ")",
   ":",
   "ats",
   "=",
   "{",
   "}",
   "for",
   "n",
   "in",
   "np",
   ".",
   "arange",
   "(",
   "self",
   ".",
   "n",
   ")",
   "+",
   "1",
   ":",
   "t",
   "=",
   "self",
   ".",
   "Time",
   "[",
   "self",
   ".",
   "ns",
   "==",
   "n",
   "]",
   "ats",
   "[",
   "n",
   "-",
   "1",
   "]",
   "=",
   "t",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "t",
   ".",
   "min",
   "(",
   ")",
   "return",
   "ats"
  ]
 },
 {
  "idx": "maxmin-784",
  "nl_tokens": [
   "\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435",
   "h",
   "-",
   "\u044d\u0432\u0440\u0438\u0441\u0442\u0438\u043a\u0438",
   "\u0438\u0437",
   "\u0440\u0430\u0431\u043e\u0442\u044b",
   "Hulden",
   "2009",
   "\u0434\u043b\u044f",
   "\u0442\u0435\u043a\u0443\u0449\u0435\u0439",
   "\u0432\u0435\u0440\u0448\u0438\u043d\u044b",
   "\u0441\u043b\u043e\u0432\u0430\u0440\u044f"
  ],
  "pl_tokens": [
   "def",
   "_euristic_h_function",
   "(",
   "self",
   ",",
   "suffix",
   ",",
   "index",
   ")",
   ":",
   "if",
   "self",
   ".",
   "euristics",
   ">",
   "0",
   ":",
   "suffix",
   "=",
   "suffix",
   "[",
   ":",
   "self",
   ".",
   "euristics",
   "]",
   "# \u043a\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432",
   "index_temporary_euristics",
   "=",
   "self",
   ".",
   "_temporary_euristics",
   "[",
   "index",
   "]",
   "cost",
   "=",
   "index_temporary_euristics",
   ".",
   "get",
   "(",
   "suffix",
   ",",
   "None",
   ")",
   "if",
   "cost",
   "is",
   "not",
   "None",
   ":",
   "return",
   "cost",
   "# \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u0435 \u043d\u0443\u0436\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432",
   "absense_costs",
   "=",
   "self",
   ".",
   "_absense_costs_by_node",
   "[",
   "index",
   "]",
   "data",
   "=",
   "self",
   ".",
   "dictionary",
   ".",
   "data",
   "[",
   "index",
   "]",
   "costs",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ",",
   "shape",
   "=",
   "(",
   "self",
   ".",
   "euristics",
   ",",
   ")",
   ")",
   "# costs[j] --- \u043e\u0446\u0435\u043d\u043a\u0430 \u0448\u0442\u0440\u0430\u0444\u0430 \u043f\u0440\u0438 \u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0435 \u0432\u043f\u0435\u0440\u0451\u0434 \u043d\u0430 j \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432",
   "for",
   "i",
   ",",
   "a",
   "in",
   "enumerate",
   "(",
   "suffix",
   ")",
   ":",
   "costs",
   "[",
   "i",
   ":",
   "]",
   "+=",
   "absense_costs",
   "[",
   "a",
   "]",
   "[",
   "i",
   ":",
   "]",
   "cost",
   "=",
   "<mask>",
   "(",
   "costs",
   ")",
   "index_temporary_euristics",
   "[",
   "suffix",
   "]",
   "=",
   "cost",
   "return",
   "cost"
  ]
 },
 {
  "idx": "maxmin-785",
  "nl_tokens": [
   "Processes",
   "a",
   "collection",
   "in",
   "parallel",
   "batches",
   "each",
   "batch",
   "processes",
   "in",
   "series",
   "on",
   "a",
   "single",
   "process",
   ".",
   "Running",
   "batches",
   "in",
   "parallel",
   "can",
   "be",
   "more",
   "effficient",
   "that",
   "splitting",
   "a",
   "list",
   "across",
   "cores",
   "as",
   "in",
   "spin",
   ".",
   "parallel",
   "because",
   "of",
   "parallel",
   "processing",
   "has",
   "high",
   "IO",
   "requirements",
   "."
  ],
  "pl_tokens": [
   "def",
   "batch",
   "(",
   "collection",
   ",",
   "method",
   ",",
   "processes",
   "=",
   "None",
   ",",
   "batch_size",
   "=",
   "None",
   ",",
   "quiet",
   "=",
   "False",
   ",",
   "kwargs_to_dump",
   "=",
   "None",
   ",",
   "args",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "processes",
   "is",
   "None",
   ":",
   "# default to the number of processes, not exceeding 20 or the number of",
   "# subjects",
   "processes",
   "=",
   "<mask>",
   "(",
   "mp",
   ".",
   "cpu_count",
   "(",
   ")",
   ",",
   "20",
   ",",
   "len",
   "(",
   "collection",
   ")",
   ")",
   "if",
   "batch_size",
   "is",
   "None",
   ":",
   "# floor divide rounds down to nearest int",
   "batch_size",
   "=",
   "max",
   "(",
   "len",
   "(",
   "collection",
   ")",
   "//",
   "processes",
   ",",
   "1",
   ")",
   "print",
   "'size of each batch ='",
   ",",
   "batch_size",
   "mod",
   "=",
   "len",
   "(",
   "collection",
   ")",
   "%",
   "processes",
   "# batch_list is a list of cars broken in to batch size chunks",
   "batch_list",
   "=",
   "[",
   "collection",
   "[",
   "x",
   ":",
   "x",
   "+",
   "batch_size",
   "]",
   "for",
   "x",
   "in",
   "xrange",
   "(",
   "0",
   ",",
   "len",
   "(",
   "collection",
   ")",
   "-",
   "mod",
   ",",
   "batch_size",
   ")",
   "]",
   "# remainder handling",
   "if",
   "mod",
   "!=",
   "0",
   ":",
   "batch_list",
   "[",
   "len",
   "(",
   "batch_list",
   ")",
   "-",
   "1",
   "]",
   "+=",
   "collection",
   "[",
   "-",
   "mod",
   ":",
   "]",
   "print",
   "'number of batches ='",
   ",",
   "len",
   "(",
   "batch_list",
   ")",
   "# New args",
   "if",
   "args",
   "is",
   "None",
   ":",
   "args",
   "=",
   "method",
   "else",
   ":",
   "if",
   "isinstance",
   "(",
   "args",
   ",",
   "tuple",
   ")",
   "==",
   "False",
   ":",
   "args",
   "=",
   "(",
   "args",
   ",",
   ")",
   "args",
   "=",
   "(",
   "method",
   ",",
   ")",
   "+",
   "args",
   "# Applying the mp method w/ or w/o dumping using the custom operator",
   "# method",
   "if",
   "kwargs_to_dump",
   "is",
   "None",
   ":",
   "res",
   "=",
   "parallel",
   "(",
   "batch_list",
   ",",
   "new_function_batch",
   ",",
   "processes",
   "=",
   "processes",
   ",",
   "args",
   "=",
   "args",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "else",
   ":",
   "res",
   "=",
   "process_dump",
   "(",
   "batch_list",
   ",",
   "new_function_batch",
   ",",
   "kwargs_to_dump",
   ",",
   "processes",
   "=",
   "processes",
   ",",
   "args",
   "=",
   "args",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "returnList",
   "=",
   "[",
   "]",
   "for",
   "l",
   "in",
   "res",
   ":",
   "returnList",
   "+=",
   "l",
   "# toc = time.time()",
   "# elapsed = toc-tic",
   "# if quiet is False:",
   "# \tif processes is None:",
   "# \t\tprint \"Total Elapsed time: %s  :-)\" % str(elapsed)",
   "# \telse:",
   "# print \"Total Elapsed time: %s  on %s processes :-)\" %",
   "# (str(elapsed),str(processes))",
   "return",
   "returnList"
  ]
 },
 {
  "idx": "maxmin-786",
  "nl_tokens": [
   "This",
   "function",
   "is",
   "unique",
   "b",
   "/",
   "c",
   "it",
   "creates",
   "an",
   "empty",
   "defaultdict",
   "adds",
   "in",
   "the",
   "event",
   "occurrences",
   "by",
   "creating",
   "an",
   "instance",
   "of",
   "Repeater",
   "then",
   "returns",
   "the",
   "defaultdict",
   "likely",
   "to",
   "be",
   "merged",
   "into",
   "the",
   "main",
   "defaultdict",
   "(",
   "the",
   "one",
   "holding",
   "all",
   "event",
   "occurrences",
   "for",
   "this",
   "month",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "repeat_biweekly",
   "(",
   "self",
   ")",
   ":",
   "mycount",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "d",
   "=",
   "self",
   ".",
   "event",
   ".",
   "l_start_date",
   "while",
   "d",
   ".",
   "year",
   "!=",
   "self",
   ".",
   "year",
   "or",
   "d",
   ".",
   "month",
   "!=",
   "self",
   ".",
   "month",
   ":",
   "d",
   "+=",
   "timedelta",
   "(",
   "days",
   "=",
   "14",
   ")",
   "r",
   "=",
   "self",
   ".",
   "__class__",
   "(",
   "mycount",
   ",",
   "self",
   ".",
   "year",
   ",",
   "self",
   ".",
   "month",
   ",",
   "d",
   ".",
   "day",
   ",",
   "self",
   ".",
   "event",
   ".",
   "end_repeat",
   ",",
   "self",
   ".",
   "event",
   ",",
   "num",
   "=",
   "self",
   ".",
   "num",
   ",",
   "count_first",
   "=",
   "True",
   ")",
   "r",
   ".",
   "repeat",
   "(",
   ")",
   "if",
   "self",
   ".",
   "event",
   ".",
   "is_chunk",
   "(",
   ")",
   "and",
   "r",
   ".",
   "count",
   ":",
   "r",
   ".",
   "day",
   "=",
   "<mask>",
   "(",
   "r",
   ".",
   "count",
   ")",
   "r",
   ".",
   "repeat_chunk",
   "(",
   "self",
   ".",
   "event",
   ".",
   "start_end_diff",
   ")",
   "return",
   "r",
   ".",
   "count"
  ]
 },
 {
  "idx": "maxmin-787",
  "nl_tokens": [
   "Produce",
   "a",
   "sequence",
   "of",
   "formatted",
   "lines",
   "from",
   "info",
   "."
  ],
  "pl_tokens": [
   "def",
   "info_formatter",
   "(",
   "info",
   ")",
   ":",
   "label_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "l",
   ")",
   "for",
   "l",
   ",",
   "_d",
   "in",
   "info",
   "]",
   ")",
   "for",
   "label",
   ",",
   "data",
   "in",
   "info",
   ":",
   "if",
   "data",
   "==",
   "[",
   "]",
   ":",
   "data",
   "=",
   "\"-none-\"",
   "if",
   "isinstance",
   "(",
   "data",
   ",",
   "(",
   "list",
   ",",
   "tuple",
   ")",
   ")",
   ":",
   "prefix",
   "=",
   "\"%*s:\"",
   "%",
   "(",
   "label_len",
   ",",
   "label",
   ")",
   "for",
   "e",
   "in",
   "data",
   ":",
   "yield",
   "\"%*s %s\"",
   "%",
   "(",
   "label_len",
   "+",
   "1",
   ",",
   "prefix",
   ",",
   "e",
   ")",
   "prefix",
   "=",
   "\"\"",
   "else",
   ":",
   "yield",
   "\"%*s: %s\"",
   "%",
   "(",
   "label_len",
   ",",
   "label",
   ",",
   "data",
   ")"
  ]
 },
 {
  "idx": "maxmin-788",
  "nl_tokens": [
   "\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442",
   "\u0432\u0441\u0435",
   "\u0442\u0440\u0430\u043d\u0441\u0434\u0443\u043a\u0446\u0438\u0438",
   "\u043f\u0435\u0440\u0435\u0432\u043e\u0434\u044f\u0449\u0438\u0435",
   "first",
   "\u0432",
   "second",
   "\u0447\u044c\u044f",
   "\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c",
   "\u043d\u0435",
   "\u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0435\u0442",
   "threshold"
  ],
  "pl_tokens": [
   "def",
   "transduce",
   "(",
   "self",
   ",",
   "first",
   ",",
   "second",
   ",",
   "threshold",
   ")",
   ":",
   "add_pred",
   "=",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "x",
   "<=",
   "threshold",
   ")",
   "clear_pred",
   "=",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "False",
   ")",
   "update_func",
   "=",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "<mask>",
   "(",
   "x",
   ",",
   "y",
   ")",
   ")",
   "costs",
   ",",
   "backtraces",
   "=",
   "self",
   ".",
   "_fill_levenshtein_table",
   "(",
   "first",
   ",",
   "second",
   ",",
   "update_func",
   ",",
   "add_pred",
   ",",
   "clear_pred",
   ",",
   "threshold",
   "=",
   "threshold",
   ")",
   "result",
   "=",
   "self",
   ".",
   "_backtraces_to_transductions",
   "(",
   "first",
   ",",
   "second",
   ",",
   "backtraces",
   ",",
   "threshold",
   ",",
   "return_cost",
   "=",
   "True",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-789",
  "nl_tokens": [
   "Get",
   "file",
   "splits",
   "for",
   "upload",
   "/",
   "download",
   "/",
   "copy",
   "operation",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_file_splits",
   "(",
   "self",
   ",",
   "id",
   ",",
   "source",
   ",",
   "target",
   ",",
   "fsize",
   ",",
   "splitsize",
   ")",
   ":",
   "pos",
   "=",
   "0",
   "part",
   "=",
   "1",
   "# S3 part id starts from 1",
   "mpi",
   "=",
   "ThreadUtil",
   ".",
   "MultipartItem",
   "(",
   "id",
   ")",
   "splits",
   "=",
   "[",
   "]",
   "while",
   "pos",
   "<",
   "fsize",
   ":",
   "chunk",
   "=",
   "<mask>",
   "(",
   "splitsize",
   ",",
   "fsize",
   "-",
   "pos",
   ")",
   "assert",
   "(",
   "chunk",
   ">",
   "0",
   ")",
   "splits",
   ".",
   "append",
   "(",
   "(",
   "source",
   ",",
   "target",
   ",",
   "mpi",
   ",",
   "pos",
   ",",
   "chunk",
   ",",
   "part",
   ")",
   ")",
   "part",
   "+=",
   "1",
   "pos",
   "+=",
   "chunk",
   "mpi",
   ".",
   "total",
   "=",
   "len",
   "(",
   "splits",
   ")",
   "return",
   "splits"
  ]
 },
 {
  "idx": "maxmin-790",
  "nl_tokens": [
   "Align",
   "iteration",
   "with",
   "cacheline",
   "boundary",
   "."
  ],
  "pl_tokens": [
   "def",
   "_align_iteration_with_cl_boundary",
   "(",
   "self",
   ",",
   "iteration",
   ",",
   "subtract",
   "=",
   "True",
   ")",
   ":",
   "# FIXME handle multiple datatypes",
   "element_size",
   "=",
   "self",
   ".",
   "kernel",
   ".",
   "datatypes_size",
   "[",
   "self",
   ".",
   "kernel",
   ".",
   "datatype",
   "]",
   "cacheline_size",
   "=",
   "self",
   ".",
   "machine",
   "[",
   "'cacheline size'",
   "]",
   "elements_per_cacheline",
   "=",
   "int",
   "(",
   "cacheline_size",
   "//",
   "element_size",
   ")",
   "# Gathering some loop information:",
   "inner_loop",
   "=",
   "list",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "get_loop_stack",
   "(",
   "subs_consts",
   "=",
   "True",
   ")",
   ")",
   "[",
   "-",
   "1",
   "]",
   "inner_increment",
   "=",
   "inner_loop",
   "[",
   "'increment'",
   "]",
   "# do this by aligning either writes (preferred) or reads",
   "# Assumption: writes (and reads) increase linearly",
   "o",
   "=",
   "self",
   ".",
   "kernel",
   ".",
   "compile_global_offsets",
   "(",
   "iteration",
   "=",
   "iteration",
   ")",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "o",
   "[",
   "1",
   "]",
   ")",
   ":",
   "# we have a write to work with:",
   "first_offset",
   "=",
   "<mask>",
   "(",
   "o",
   "[",
   "1",
   "]",
   ")",
   "else",
   ":",
   "# we use reads",
   "first_offset",
   "=",
   "min",
   "(",
   "o",
   "[",
   "0",
   "]",
   ")",
   "diff",
   "=",
   "first_offset",
   "-",
   "(",
   "int",
   "(",
   "first_offset",
   ")",
   ">>",
   "self",
   ".",
   "csim",
   ".",
   "first_level",
   ".",
   "cl_bits",
   "<<",
   "self",
   ".",
   "csim",
   ".",
   "first_level",
   ".",
   "cl_bits",
   ")",
   "if",
   "diff",
   "==",
   "0",
   ":",
   "return",
   "iteration",
   "elif",
   "subtract",
   ":",
   "return",
   "iteration",
   "-",
   "(",
   "diff",
   "//",
   "element_size",
   ")",
   "//",
   "inner_increment",
   "else",
   ":",
   "return",
   "iteration",
   "+",
   "(",
   "elements_per_cacheline",
   "-",
   "diff",
   "//",
   "element_size",
   ")",
   "//",
   "inner_increment"
  ]
 },
 {
  "idx": "maxmin-791",
  "nl_tokens": [
   "List",
   "teams",
   "to",
   "which",
   "the",
   "authenticated",
   "user",
   "belongs",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield team objects created from the returned items JSON objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-792",
  "nl_tokens": [
   "Packs",
   "a",
   "sub",
   "field",
   "s",
   "array",
   "into",
   "another",
   "array",
   "using",
   "a",
   "mask"
  ],
  "pl_tokens": [
   "def",
   "pack",
   "(",
   "array",
   ",",
   "sub_field_array",
   ",",
   "mask",
   ",",
   "inplace",
   "=",
   "False",
   ")",
   ":",
   "lsb",
   "=",
   "least_significant_bit",
   "(",
   "mask",
   ")",
   "max_value",
   "=",
   "int",
   "(",
   "mask",
   ">>",
   "lsb",
   ")",
   "if",
   "sub_field_array",
   ".",
   "<mask>",
   "(",
   ")",
   ">",
   "max_value",
   ":",
   "raise",
   "OverflowError",
   "(",
   "\"value ({}) is greater than allowed (max: {})\"",
   ".",
   "format",
   "(",
   "sub_field_array",
   ".",
   "max",
   "(",
   ")",
   ",",
   "max_value",
   ")",
   ")",
   "if",
   "inplace",
   ":",
   "array",
   "[",
   ":",
   "]",
   "=",
   "array",
   "&",
   "~",
   "mask",
   "array",
   "[",
   ":",
   "]",
   "=",
   "array",
   "|",
   "(",
   "(",
   "sub_field_array",
   "<<",
   "lsb",
   ")",
   "&",
   "mask",
   ")",
   ".",
   "astype",
   "(",
   "array",
   ".",
   "dtype",
   ")",
   "else",
   ":",
   "array",
   "=",
   "array",
   "&",
   "~",
   "mask",
   "return",
   "array",
   "|",
   "(",
   "(",
   "sub_field_array",
   "<<",
   "lsb",
   ")",
   "&",
   "mask",
   ")",
   ".",
   "astype",
   "(",
   "array",
   ".",
   "dtype",
   ")"
  ]
 },
 {
  "idx": "maxmin-793",
  "nl_tokens": [
   "Update",
   "the",
   "timer",
   "to",
   "reflect",
   "a",
   "failed",
   "call"
  ],
  "pl_tokens": [
   "def",
   "failure",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "short_interval",
   "+=",
   "self",
   ".",
   "short_unit",
   "self",
   ".",
   "long_interval",
   "+=",
   "self",
   ".",
   "long_unit",
   "self",
   ".",
   "short_interval",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "short_interval",
   ",",
   "self",
   ".",
   "max_short_timer",
   ")",
   "self",
   ".",
   "long_interval",
   "=",
   "min",
   "(",
   "self",
   ".",
   "long_interval",
   ",",
   "self",
   ".",
   "max_long_timer",
   ")",
   "self",
   ".",
   "update_interval",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-794",
  "nl_tokens": [
   "Return",
   "a",
   "canonical",
   "version",
   "of",
   "slice",
   "s",
   "."
  ],
  "pl_tokens": [
   "def",
   "normalize_slice",
   "(",
   "s",
   ",",
   "total",
   ")",
   ":",
   "newstart",
   "=",
   "0",
   "if",
   "s",
   ".",
   "start",
   "is",
   "None",
   "else",
   "<mask>",
   "(",
   "0",
   ",",
   "s",
   ".",
   "start",
   "+",
   "total",
   ")",
   "if",
   "s",
   ".",
   "start",
   "<",
   "0",
   "else",
   "min",
   "(",
   "s",
   ".",
   "start",
   ",",
   "total",
   ")",
   "newstop",
   "=",
   "total",
   "if",
   "s",
   ".",
   "stop",
   "is",
   "None",
   "else",
   "max",
   "(",
   "0",
   ",",
   "s",
   ".",
   "stop",
   "+",
   "total",
   ")",
   "if",
   "s",
   ".",
   "stop",
   "<",
   "0",
   "else",
   "min",
   "(",
   "s",
   ".",
   "stop",
   ",",
   "total",
   ")",
   "newstep",
   "=",
   "1",
   "if",
   "s",
   ".",
   "step",
   "is",
   "None",
   "else",
   "s",
   ".",
   "step",
   "return",
   "slice",
   "(",
   "newstart",
   ",",
   "newstop",
   ",",
   "newstep",
   ")"
  ]
 },
 {
  "idx": "maxmin-795",
  "nl_tokens": [
   "Turn",
   "a",
   "1D",
   "array",
   "into",
   "a",
   "striplog",
   "given",
   "a",
   "cutoff",
   "."
  ],
  "pl_tokens": [
   "def",
   "from_log",
   "(",
   "cls",
   ",",
   "log",
   ",",
   "cutoff",
   "=",
   "None",
   ",",
   "components",
   "=",
   "None",
   ",",
   "legend",
   "=",
   "None",
   ",",
   "legend_field",
   "=",
   "None",
   ",",
   "field",
   "=",
   "None",
   ",",
   "right",
   "=",
   "False",
   ",",
   "basis",
   "=",
   "None",
   ",",
   "source",
   "=",
   "'Log'",
   ")",
   ":",
   "if",
   "(",
   "components",
   "is",
   "None",
   ")",
   "and",
   "(",
   "legend",
   "is",
   "None",
   ")",
   "and",
   "(",
   "field",
   "is",
   "None",
   ")",
   ":",
   "m",
   "=",
   "'You must provide a list of components, and legend, or a field.'",
   "raise",
   "StriplogError",
   "(",
   "m",
   ")",
   "if",
   "(",
   "legend",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "legend_field",
   "is",
   "None",
   ")",
   ":",
   "try",
   ":",
   "# To treat it like a legend.",
   "components",
   "=",
   "[",
   "deepcopy",
   "(",
   "decor",
   ".",
   "component",
   ")",
   "for",
   "decor",
   "in",
   "legend",
   "]",
   "except",
   "AttributeError",
   ":",
   "# It's just a list of components.",
   "pass",
   "if",
   "legend_field",
   "is",
   "not",
   "None",
   ":",
   "field_values",
   "=",
   "[",
   "getattr",
   "(",
   "d",
   ",",
   "legend_field",
   ",",
   "0",
   ")",
   "for",
   "d",
   "in",
   "legend",
   "]",
   "components",
   "=",
   "[",
   "Component",
   "(",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "int",
   "(",
   "<mask>",
   "(",
   "field_values",
   ")",
   "+",
   "1",
   ")",
   ")",
   "]",
   "for",
   "i",
   ",",
   "decor",
   "in",
   "enumerate",
   "(",
   "legend",
   ")",
   ":",
   "components",
   "[",
   "i",
   "]",
   "=",
   "deepcopy",
   "(",
   "decor",
   ".",
   "component",
   ")",
   "if",
   "cutoff",
   "is",
   "not",
   "None",
   ":",
   "# First make sure we have enough components.",
   "try",
   ":",
   "n",
   "=",
   "len",
   "(",
   "cutoff",
   ")",
   "except",
   "TypeError",
   ":",
   "n",
   "=",
   "1",
   "if",
   "len",
   "(",
   "components",
   ")",
   "<",
   "n",
   "+",
   "1",
   ":",
   "m",
   "=",
   "'For n cutoffs, you need to provide at least'",
   "m",
   "+=",
   "'n+1 components.'",
   "raise",
   "StriplogError",
   "(",
   "m",
   ")",
   "# Digitize.",
   "try",
   ":",
   "# To use cutoff as a list.",
   "a",
   "=",
   "np",
   ".",
   "digitize",
   "(",
   "log",
   ",",
   "cutoff",
   ",",
   "right",
   ")",
   "except",
   "ValueError",
   ":",
   "# It's just a number.",
   "a",
   "=",
   "np",
   ".",
   "digitize",
   "(",
   "log",
   ",",
   "[",
   "cutoff",
   "]",
   ",",
   "right",
   ")",
   "else",
   ":",
   "a",
   "=",
   "np",
   ".",
   "copy",
   "(",
   "log",
   ")",
   "tops",
   ",",
   "values",
   "=",
   "utils",
   ".",
   "tops_from_loglike",
   "(",
   "a",
   ")",
   "if",
   "basis",
   "is",
   "None",
   ":",
   "m",
   "=",
   "'You must provide a depth or elevation basis.'",
   "raise",
   "StriplogError",
   "(",
   "m",
   ")",
   "list_of_Intervals",
   "=",
   "cls",
   ".",
   "__intervals_from_tops",
   "(",
   "tops",
   ",",
   "values",
   ",",
   "basis",
   ",",
   "components",
   ",",
   "field",
   "=",
   "field",
   ")",
   "return",
   "cls",
   "(",
   "list_of_Intervals",
   ",",
   "source",
   "=",
   "source",
   ")"
  ]
 },
 {
  "idx": "maxmin-796",
  "nl_tokens": [
   "Give",
   "the",
   "full",
   "time",
   "interval",
   "of",
   "the",
   "file",
   ".",
   "Note",
   "that",
   "the",
   "real",
   "interval",
   "can",
   "be",
   "longer",
   "because",
   "the",
   "sound",
   "file",
   "attached",
   "can",
   "be",
   "longer",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_full_time_interval",
   "(",
   "self",
   ")",
   ":",
   "return",
   "(",
   "0",
   ",",
   "0",
   ")",
   "if",
   "not",
   "self",
   ".",
   "timeslots",
   "else",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "timeslots",
   ".",
   "values",
   "(",
   ")",
   ")",
   ",",
   "max",
   "(",
   "self",
   ".",
   "timeslots",
   ".",
   "values",
   "(",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-797",
  "nl_tokens": [
   "benjamini",
   "hocheberg",
   "fdr",
   "correction",
   ".",
   "inspired",
   "by",
   "statsmodels"
  ],
  "pl_tokens": [
   "def",
   "fdrcorrection",
   "(",
   "pvals",
   ",",
   "alpha",
   "=",
   "0.05",
   ")",
   ":",
   "# Implement copy from GOATools.",
   "pvals",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "pvals",
   ")",
   "pvals_sortind",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "pvals",
   ")",
   "pvals_sorted",
   "=",
   "np",
   ".",
   "take",
   "(",
   "pvals",
   ",",
   "pvals_sortind",
   ")",
   "ecdffactor",
   "=",
   "_ecdf",
   "(",
   "pvals_sorted",
   ")",
   "reject",
   "=",
   "pvals_sorted",
   "<=",
   "ecdffactor",
   "*",
   "alpha",
   "if",
   "reject",
   ".",
   "any",
   "(",
   ")",
   ":",
   "rejectmax",
   "=",
   "<mask>",
   "(",
   "np",
   ".",
   "nonzero",
   "(",
   "reject",
   ")",
   "[",
   "0",
   "]",
   ")",
   "reject",
   "[",
   ":",
   "rejectmax",
   "]",
   "=",
   "True",
   "pvals_corrected_raw",
   "=",
   "pvals_sorted",
   "/",
   "ecdffactor",
   "pvals_corrected",
   "=",
   "np",
   ".",
   "minimum",
   ".",
   "accumulate",
   "(",
   "pvals_corrected_raw",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "del",
   "pvals_corrected_raw",
   "pvals_corrected",
   "[",
   "pvals_corrected",
   ">",
   "1",
   "]",
   "=",
   "1",
   "pvals_corrected_",
   "=",
   "np",
   ".",
   "empty_like",
   "(",
   "pvals_corrected",
   ")",
   "pvals_corrected_",
   "[",
   "pvals_sortind",
   "]",
   "=",
   "pvals_corrected",
   "del",
   "pvals_corrected",
   "reject_",
   "=",
   "np",
   ".",
   "empty_like",
   "(",
   "reject",
   ")",
   "reject_",
   "[",
   "pvals_sortind",
   "]",
   "=",
   "reject",
   "return",
   "reject_",
   ",",
   "pvals_corrected_"
  ]
 },
 {
  "idx": "maxmin-798",
  "nl_tokens": [
   "What",
   "percentage",
   "(",
   "range",
   "0",
   "-",
   "1",
   ")",
   "of",
   "work",
   "is",
   "done",
   "(",
   "including",
   "submonitors",
   ")"
  ],
  "pl_tokens": [
   "def",
   "progress",
   "(",
   "self",
   ")",
   "->",
   "float",
   ":",
   "if",
   "self",
   ".",
   "total",
   "is",
   "None",
   ":",
   "return",
   "0",
   "my_progress",
   "=",
   "self",
   ".",
   "worked",
   "my_progress",
   "+=",
   "sum",
   "(",
   "s",
   ".",
   "progress",
   "*",
   "weight",
   "for",
   "(",
   "s",
   ",",
   "weight",
   ")",
   "in",
   "self",
   ".",
   "sub_monitors",
   ".",
   "items",
   "(",
   ")",
   ")",
   "return",
   "<mask>",
   "(",
   "1",
   ",",
   "my_progress",
   "/",
   "self",
   ".",
   "total",
   ")"
  ]
 },
 {
  "idx": "maxmin-799",
  "nl_tokens": [
   "Render",
   "the",
   "widget",
   "."
  ],
  "pl_tokens": [
   "def",
   "render",
   "(",
   "self",
   ",",
   "progress",
   ",",
   "width",
   "=",
   "None",
   ",",
   "status",
   "=",
   "None",
   ")",
   ":",
   "results",
   "=",
   "[",
   "widget",
   ".",
   "render",
   "(",
   "progress",
   ",",
   "width",
   "=",
   "self",
   ".",
   "_widget_lengths",
   "[",
   "i",
   "]",
   ",",
   "status",
   "=",
   "status",
   ")",
   "for",
   "i",
   ",",
   "widget",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "_widgets",
   ")",
   "]",
   "if",
   "self",
   ".",
   "_file_mode",
   ":",
   "res",
   "=",
   "\"\"",
   "for",
   "i",
   ",",
   "result",
   "in",
   "enumerate",
   "(",
   "results",
   ")",
   ":",
   "res",
   "+=",
   "result",
   ".",
   "rendered",
   "if",
   "result",
   ".",
   "length",
   "<",
   "self",
   ".",
   "_widget_lengths",
   "[",
   "i",
   "]",
   "and",
   "progress",
   "<",
   "1",
   ":",
   "break",
   "res",
   "+=",
   "\" \"",
   "if",
   "i",
   "<",
   "len",
   "(",
   "results",
   ")",
   "-",
   "1",
   "else",
   "\"\"",
   "rendered_str",
   "=",
   "res",
   "[",
   "len",
   "(",
   "self",
   ".",
   "_rendered",
   ")",
   ":",
   "]",
   "self",
   ".",
   "_rendered",
   "=",
   "res",
   "else",
   ":",
   "rendered_str",
   "=",
   "\" \"",
   ".",
   "join",
   "(",
   "r",
   ".",
   "rendered",
   "for",
   "r",
   "in",
   "results",
   ")",
   "if",
   "self",
   ".",
   "_to_render",
   ":",
   "rendered_str",
   "=",
   "self",
   ".",
   "_to_render",
   "+",
   "rendered_str",
   "self",
   ".",
   "_to_render",
   "=",
   "None",
   "next_progress",
   "=",
   "<mask>",
   "(",
   "r",
   ".",
   "next_progress",
   "for",
   "r",
   "in",
   "results",
   ")",
   "next_time",
   "=",
   "min",
   "(",
   "r",
   ".",
   "next_time",
   "for",
   "r",
   "in",
   "results",
   ")",
   "return",
   "RenderResult",
   "(",
   "rendered_str",
   ",",
   "next_progress",
   "=",
   "next_progress",
   ",",
   "next_time",
   "=",
   "next_time",
   ")"
  ]
 },
 {
  "idx": "maxmin-800",
  "nl_tokens": [
   "Populates",
   "a",
   "Layout",
   "from",
   "a",
   "dictionary",
   ".",
   "The",
   "dictionary",
   "must",
   "be",
   "a",
   "bijective",
   "mapping",
   "between",
   "virtual",
   "qubits",
   "(",
   "tuple",
   ")",
   "and",
   "physical",
   "qubits",
   "(",
   "int",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "from_dict",
   "(",
   "self",
   ",",
   "input_dict",
   ")",
   ":",
   "# TODO (luciano): Remove this full block after 0.8.",
   "#  its here to support {(\"qr\", 0): (\"q\", 0),...}",
   "if",
   "len",
   "(",
   "input_dict",
   ")",
   ">=",
   "1",
   ":",
   "key",
   "=",
   "list",
   "(",
   "input_dict",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "[",
   "0",
   "]",
   "value",
   "=",
   "input_dict",
   "[",
   "key",
   "]",
   "if",
   "(",
   "isinstance",
   "(",
   "key",
   ",",
   "tuple",
   ")",
   "and",
   "# pylint: disable=too-many-boolean-expressions",
   "len",
   "(",
   "key",
   ")",
   "==",
   "2",
   "and",
   "isinstance",
   "(",
   "key",
   "[",
   "0",
   "]",
   ",",
   "str",
   ")",
   "and",
   "isinstance",
   "(",
   "key",
   "[",
   "1",
   "]",
   ",",
   "int",
   ")",
   "and",
   "isinstance",
   "(",
   "value",
   ",",
   "tuple",
   ")",
   "and",
   "len",
   "(",
   "value",
   ")",
   "==",
   "2",
   "and",
   "isinstance",
   "(",
   "key",
   "[",
   "0",
   "]",
   ",",
   "str",
   ")",
   "and",
   "isinstance",
   "(",
   "key",
   "[",
   "1",
   "]",
   ",",
   "int",
   ")",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"This form of dictionary (i.e. {(\\\"%s\\\",%s):(\\\"%s\\\",%s), ...} is \"",
   "\"going to be deprecated after 0.8.\"",
   "%",
   "(",
   "key",
   "+",
   "value",
   ")",
   ",",
   "DeprecationWarning",
   ")",
   "qreg_names",
   "=",
   "{",
   "qubit",
   "[",
   "0",
   "]",
   "for",
   "qubit",
   "in",
   "input_dict",
   ".",
   "keys",
   "(",
   ")",
   "}",
   "qregs",
   "=",
   "{",
   "}",
   "for",
   "qreg_name",
   "in",
   "qreg_names",
   ":",
   "qregs",
   "[",
   "qreg_name",
   "]",
   "=",
   "QuantumRegister",
   "(",
   "<mask>",
   "(",
   "[",
   "qubit",
   "[",
   "1",
   "]",
   "for",
   "qubit",
   "in",
   "input_dict",
   ".",
   "keys",
   "(",
   ")",
   "if",
   "qubit",
   "[",
   "0",
   "]",
   "==",
   "qreg_name",
   "]",
   ")",
   "+",
   "1",
   ",",
   "qreg_name",
   ")",
   "new_input_dict",
   "=",
   "{",
   "}",
   "for",
   "key",
   ",",
   "value",
   "in",
   "input_dict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "new_input_dict",
   "[",
   "value",
   "[",
   "1",
   "]",
   "]",
   "=",
   "(",
   "qregs",
   "[",
   "key",
   "[",
   "0",
   "]",
   "]",
   ",",
   "key",
   "[",
   "1",
   "]",
   ")",
   "input_dict",
   "=",
   "new_input_dict",
   "for",
   "key",
   ",",
   "value",
   "in",
   "input_dict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "virtual",
   ",",
   "physical",
   "=",
   "Layout",
   ".",
   "order_based_on_type",
   "(",
   "key",
   ",",
   "value",
   ")",
   "self",
   ".",
   "_p2v",
   "[",
   "physical",
   "]",
   "=",
   "virtual",
   "if",
   "virtual",
   "is",
   "None",
   ":",
   "continue",
   "self",
   ".",
   "_v2p",
   "[",
   "virtual",
   "]",
   "=",
   "physical"
  ]
 },
 {
  "idx": "maxmin-801",
  "nl_tokens": [
   "compute",
   "the",
   "difference",
   "between",
   "two",
   "sets",
   "of",
   "timestamps",
   "The",
   "default",
   "behavior",
   "is",
   "to",
   "use",
   "the",
   "earliest",
   "of",
   "the",
   "first",
   "and",
   "the",
   "latest",
   "of",
   "the",
   "second",
   "list",
   "but",
   "this",
   "can",
   "be",
   "changed",
   "by",
   "passing",
   "a",
   "different",
   "Parameters",
   "----------",
   "start",
   ":",
   "one",
   "or",
   "more",
   "datetime",
   "objects",
   "(",
   "e",
   ".",
   "g",
   ".",
   "ar",
   ".",
   "submitted",
   ")",
   "end",
   ":",
   "one",
   "or",
   "more",
   "datetime",
   "objects",
   "(",
   "e",
   ".",
   "g",
   ".",
   "ar",
   ".",
   "received",
   ")",
   "start_key",
   ":",
   "callable",
   "Function",
   "to",
   "call",
   "on",
   "start",
   "to",
   "extract",
   "the",
   "relevant",
   "entry",
   "[",
   "defalt",
   ":",
   "min",
   "]",
   "end_key",
   ":",
   "callable",
   "Function",
   "to",
   "call",
   "on",
   "end",
   "to",
   "extract",
   "the",
   "relevant",
   "entry",
   "[",
   "default",
   ":",
   "max",
   "]",
   "Returns",
   "-------",
   "dt",
   ":",
   "float",
   "The",
   "time",
   "elapsed",
   "(",
   "in",
   "seconds",
   ")",
   "between",
   "the",
   "two",
   "selected",
   "timestamps",
   "."
  ],
  "pl_tokens": [
   "def",
   "timedelta",
   "(",
   "self",
   ",",
   "start",
   ",",
   "end",
   ",",
   "start_key",
   "=",
   "<mask>",
   ",",
   "end_key",
   "=",
   "max",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "start",
   ",",
   "datetime",
   ")",
   ":",
   "# handle single_result AsyncResults, where ar.stamp is single object,",
   "# not a list",
   "start",
   "=",
   "start_key",
   "(",
   "start",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "end",
   ",",
   "datetime",
   ")",
   ":",
   "# handle single_result AsyncResults, where ar.stamp is single object,",
   "# not a list",
   "end",
   "=",
   "end_key",
   "(",
   "end",
   ")",
   "return",
   "_total_seconds",
   "(",
   "end",
   "-",
   "start",
   ")"
  ]
 },
 {
  "idx": "maxmin-802",
  "nl_tokens": [
   "When",
   "the",
   "elements",
   "of",
   "the",
   "layer",
   "have",
   "different",
   "widths",
   "sets",
   "the",
   "width",
   "to",
   "the",
   "max",
   "elements",
   ".",
   "Args",
   ":",
   "layer",
   "(",
   "list",
   ")",
   ":",
   "A",
   "list",
   "of",
   "elements",
   "."
  ],
  "pl_tokens": [
   "def",
   "normalize_width",
   "(",
   "layer",
   ")",
   ":",
   "instructions",
   "=",
   "[",
   "instruction",
   "for",
   "instruction",
   "in",
   "filter",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "is",
   "not",
   "None",
   ",",
   "layer",
   ")",
   "]",
   "longest",
   "=",
   "<mask>",
   "(",
   "[",
   "instruction",
   ".",
   "length",
   "for",
   "instruction",
   "in",
   "instructions",
   "]",
   ")",
   "for",
   "instruction",
   "in",
   "instructions",
   ":",
   "instruction",
   ".",
   "layer_width",
   "=",
   "longest"
  ]
 },
 {
  "idx": "maxmin-803",
  "nl_tokens": [
   "This",
   "searches",
   "buffer",
   "for",
   "the",
   "first",
   "occurence",
   "of",
   "one",
   "of",
   "the",
   "regular",
   "expressions",
   ".",
   "freshlen",
   "must",
   "indicate",
   "the",
   "number",
   "of",
   "bytes",
   "at",
   "the",
   "end",
   "of",
   "buffer",
   "which",
   "have",
   "not",
   "been",
   "searched",
   "before",
   "."
  ],
  "pl_tokens": [
   "def",
   "search",
   "(",
   "self",
   ",",
   "buffer",
   ",",
   "freshlen",
   ",",
   "searchwindowsize",
   "=",
   "None",
   ")",
   ":",
   "absurd_match",
   "=",
   "len",
   "(",
   "buffer",
   ")",
   "first_match",
   "=",
   "absurd_match",
   "# 'freshlen' doesn't help here -- we cannot predict the",
   "# length of a match, and the re module provides no help.",
   "if",
   "searchwindowsize",
   "is",
   "None",
   ":",
   "searchstart",
   "=",
   "0",
   "else",
   ":",
   "searchstart",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "len",
   "(",
   "buffer",
   ")",
   "-",
   "searchwindowsize",
   ")",
   "for",
   "index",
   ",",
   "s",
   "in",
   "self",
   ".",
   "_searches",
   ":",
   "match",
   "=",
   "s",
   ".",
   "search",
   "(",
   "buffer",
   ",",
   "searchstart",
   ")",
   "if",
   "match",
   "is",
   "None",
   ":",
   "continue",
   "n",
   "=",
   "match",
   ".",
   "start",
   "(",
   ")",
   "if",
   "n",
   "<",
   "first_match",
   ":",
   "first_match",
   "=",
   "n",
   "the_match",
   "=",
   "match",
   "best_index",
   "=",
   "index",
   "if",
   "first_match",
   "==",
   "absurd_match",
   ":",
   "return",
   "-",
   "1",
   "self",
   ".",
   "start",
   "=",
   "first_match",
   "self",
   ".",
   "match",
   "=",
   "the_match",
   "self",
   ".",
   "end",
   "=",
   "self",
   ".",
   "match",
   ".",
   "end",
   "(",
   ")",
   "return",
   "best_index"
  ]
 },
 {
  "idx": "maxmin-804",
  "nl_tokens": [
   "Returns",
   "the",
   "offset_front_id",
   "which",
   "corresponds",
   "to",
   "the",
   "offset",
   "front",
   "which",
   "occurs",
   "first",
   "entirely",
   "after",
   "the",
   "given",
   "onset",
   "sample_idx",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_offset_front_id_after_onset_sample_idx",
   "(",
   "onset_sample_idx",
   ",",
   "offset_fronts",
   ")",
   ":",
   "# get all the offset_front_ids",
   "offset_front_ids",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "np",
   ".",
   "unique",
   "(",
   "offset_fronts",
   ")",
   "if",
   "i",
   "!=",
   "0",
   "]",
   "best_id_so_far",
   "=",
   "-",
   "1",
   "closest_offset_sample_idx",
   "=",
   "sys",
   ".",
   "maxsize",
   "for",
   "offset_front_id",
   "in",
   "offset_front_ids",
   ":",
   "# get all that offset front's indexes",
   "offset_front_idxs",
   "=",
   "_get_front_idxs_from_id",
   "(",
   "offset_fronts",
   ",",
   "offset_front_id",
   ")",
   "# get the sample indexes",
   "offset_front_sample_idxs",
   "=",
   "[",
   "s",
   "for",
   "_f",
   ",",
   "s",
   "in",
   "offset_front_idxs",
   "]",
   "# if each sample index is greater than onset_sample_idx, keep this offset front if it is the best one so far",
   "min_sample_idx",
   "=",
   "<mask>",
   "(",
   "offset_front_sample_idxs",
   ")",
   "if",
   "min_sample_idx",
   ">",
   "onset_sample_idx",
   "and",
   "min_sample_idx",
   "<",
   "closest_offset_sample_idx",
   ":",
   "closest_offset_sample_idx",
   "=",
   "min_sample_idx",
   "best_id_so_far",
   "=",
   "offset_front_id",
   "assert",
   "best_id_so_far",
   ">",
   "1",
   "or",
   "best_id_so_far",
   "==",
   "-",
   "1",
   "return",
   "best_id_so_far"
  ]
 },
 {
  "idx": "maxmin-805",
  "nl_tokens": [
   ":",
   "type",
   "package_name",
   ":",
   "str",
   ":",
   "type",
   "current_version",
   ":",
   "version",
   ".",
   "Version",
   ":",
   "type",
   "response",
   ":",
   "requests",
   ".",
   "models",
   ".",
   "Response"
  ],
  "pl_tokens": [
   "def",
   "_parse_pypi_json_package_info",
   "(",
   "self",
   ",",
   "package_name",
   ",",
   "current_version",
   ",",
   "response",
   ")",
   ":",
   "data",
   "=",
   "response",
   ".",
   "json",
   "(",
   ")",
   "all_versions",
   "=",
   "[",
   "version",
   ".",
   "parse",
   "(",
   "vers",
   ")",
   "for",
   "vers",
   "in",
   "data",
   "[",
   "'releases'",
   "]",
   ".",
   "keys",
   "(",
   ")",
   "]",
   "filtered_versions",
   "=",
   "[",
   "vers",
   "for",
   "vers",
   "in",
   "all_versions",
   "if",
   "not",
   "vers",
   ".",
   "is_prerelease",
   "and",
   "not",
   "vers",
   ".",
   "is_postrelease",
   "]",
   "if",
   "not",
   "filtered_versions",
   ":",
   "# pragma: nocover",
   "return",
   "False",
   ",",
   "'error while parsing version'",
   "latest_version",
   "=",
   "<mask>",
   "(",
   "filtered_versions",
   ")",
   "# even if user did not choose prerelease, if the package from requirements is pre/post release, use it",
   "if",
   "self",
   ".",
   "_prerelease",
   "or",
   "current_version",
   ".",
   "is_postrelease",
   "or",
   "current_version",
   ".",
   "is_prerelease",
   ":",
   "prerelease_versions",
   "=",
   "[",
   "vers",
   "for",
   "vers",
   "in",
   "all_versions",
   "if",
   "vers",
   ".",
   "is_prerelease",
   "or",
   "vers",
   ".",
   "is_postrelease",
   "]",
   "if",
   "prerelease_versions",
   ":",
   "latest_version",
   "=",
   "max",
   "(",
   "prerelease_versions",
   ")",
   "try",
   ":",
   "try",
   ":",
   "latest_version_info",
   "=",
   "data",
   "[",
   "'releases'",
   "]",
   "[",
   "str",
   "(",
   "latest_version",
   ")",
   "]",
   "[",
   "0",
   "]",
   "except",
   "KeyError",
   ":",
   "# pragma: nocover",
   "# non-RFC versions, get the latest from pypi response",
   "latest_version",
   "=",
   "version",
   ".",
   "parse",
   "(",
   "data",
   "[",
   "'info'",
   "]",
   "[",
   "'version'",
   "]",
   ")",
   "latest_version_info",
   "=",
   "data",
   "[",
   "'releases'",
   "]",
   "[",
   "str",
   "(",
   "latest_version",
   ")",
   "]",
   "[",
   "0",
   "]",
   "except",
   "Exception",
   ":",
   "# pragma: nocover",
   "return",
   "False",
   ",",
   "'error while parsing version'",
   "upload_time",
   "=",
   "latest_version_info",
   "[",
   "'upload_time'",
   "]",
   ".",
   "replace",
   "(",
   "'T'",
   ",",
   "' '",
   ")",
   "return",
   "{",
   "'name'",
   ":",
   "package_name",
   ",",
   "'current_version'",
   ":",
   "current_version",
   ",",
   "'latest_version'",
   ":",
   "latest_version",
   ",",
   "'upgrade_available'",
   ":",
   "current_version",
   "<",
   "latest_version",
   ",",
   "'upload_time'",
   ":",
   "upload_time",
   "}",
   ",",
   "'success'"
  ]
 },
 {
  "idx": "maxmin-806",
  "nl_tokens": [
   "The",
   "bounding",
   "box",
   "for",
   "nodes",
   "in",
   "this",
   "network",
   "[",
   "xmin",
   "ymin",
   "xmax",
   "ymax",
   "]"
  ],
  "pl_tokens": [
   "def",
   "bbox",
   "(",
   "self",
   ")",
   ":",
   "return",
   "[",
   "self",
   ".",
   "nodes_df",
   ".",
   "x",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "y",
   ".",
   "min",
   "(",
   ")",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "x",
   ".",
   "max",
   "(",
   ")",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "y",
   ".",
   "max",
   "(",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-807",
  "nl_tokens": [
   "r",
   "Construct",
   "a",
   "constant",
   "-",
   "Q",
   "basis",
   "."
  ],
  "pl_tokens": [
   "def",
   "constant_q",
   "(",
   "sr",
   ",",
   "fmin",
   "=",
   "None",
   ",",
   "n_bins",
   "=",
   "84",
   ",",
   "bins_per_octave",
   "=",
   "12",
   ",",
   "tuning",
   "=",
   "0.0",
   ",",
   "window",
   "=",
   "'hann'",
   ",",
   "filter_scale",
   "=",
   "1",
   ",",
   "pad_fft",
   "=",
   "True",
   ",",
   "norm",
   "=",
   "1",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "complex64",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "fmin",
   "is",
   "None",
   ":",
   "fmin",
   "=",
   "note_to_hz",
   "(",
   "'C1'",
   ")",
   "# Pass-through parameters to get the filter lengths",
   "lengths",
   "=",
   "constant_q_lengths",
   "(",
   "sr",
   ",",
   "fmin",
   ",",
   "n_bins",
   "=",
   "n_bins",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ",",
   "window",
   "=",
   "window",
   ",",
   "filter_scale",
   "=",
   "filter_scale",
   ")",
   "# Apply tuning correction",
   "correction",
   "=",
   "2.0",
   "**",
   "(",
   "float",
   "(",
   "tuning",
   ")",
   "/",
   "bins_per_octave",
   ")",
   "fmin",
   "=",
   "correction",
   "*",
   "fmin",
   "# Q should be capitalized here, so we suppress the name warning",
   "# pylint: disable=invalid-name",
   "Q",
   "=",
   "float",
   "(",
   "filter_scale",
   ")",
   "/",
   "(",
   "2.0",
   "**",
   "(",
   "1.",
   "/",
   "bins_per_octave",
   ")",
   "-",
   "1",
   ")",
   "# Convert lengths back to frequencies",
   "freqs",
   "=",
   "Q",
   "*",
   "sr",
   "/",
   "lengths",
   "# Build the filters",
   "filters",
   "=",
   "[",
   "]",
   "for",
   "ilen",
   ",",
   "freq",
   "in",
   "zip",
   "(",
   "lengths",
   ",",
   "freqs",
   ")",
   ":",
   "# Build the filter: note, length will be ceil(ilen)",
   "sig",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "-",
   "ilen",
   "//",
   "2",
   ",",
   "ilen",
   "//",
   "2",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "*",
   "1j",
   "*",
   "2",
   "*",
   "np",
   ".",
   "pi",
   "*",
   "freq",
   "/",
   "sr",
   ")",
   "# Apply the windowing function",
   "sig",
   "=",
   "sig",
   "*",
   "__float_window",
   "(",
   "window",
   ")",
   "(",
   "len",
   "(",
   "sig",
   ")",
   ")",
   "# Normalize",
   "sig",
   "=",
   "util",
   ".",
   "normalize",
   "(",
   "sig",
   ",",
   "norm",
   "=",
   "norm",
   ")",
   "filters",
   ".",
   "append",
   "(",
   "sig",
   ")",
   "# Pad and stack",
   "max_len",
   "=",
   "<mask>",
   "(",
   "lengths",
   ")",
   "if",
   "pad_fft",
   ":",
   "max_len",
   "=",
   "int",
   "(",
   "2.0",
   "**",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "log2",
   "(",
   "max_len",
   ")",
   ")",
   ")",
   ")",
   "else",
   ":",
   "max_len",
   "=",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "max_len",
   ")",
   ")",
   "filters",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "[",
   "util",
   ".",
   "pad_center",
   "(",
   "filt",
   ",",
   "max_len",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "for",
   "filt",
   "in",
   "filters",
   "]",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "return",
   "filters",
   ",",
   "np",
   ".",
   "asarray",
   "(",
   "lengths",
   ")"
  ]
 },
 {
  "idx": "maxmin-808",
  "nl_tokens": [
   "Create",
   "a",
   "Filterbank",
   "matrix",
   "to",
   "combine",
   "FFT",
   "bins",
   "into",
   "Mel",
   "-",
   "frequency",
   "bins"
  ],
  "pl_tokens": [
   "def",
   "mel",
   "(",
   "sr",
   ",",
   "n_fft",
   ",",
   "n_mels",
   "=",
   "128",
   ",",
   "fmin",
   "=",
   "0.0",
   ",",
   "fmax",
   "=",
   "None",
   ",",
   "htk",
   "=",
   "False",
   ",",
   "norm",
   "=",
   "1",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float32",
   ")",
   ":",
   "if",
   "fmax",
   "is",
   "None",
   ":",
   "fmax",
   "=",
   "float",
   "(",
   "sr",
   ")",
   "/",
   "2",
   "if",
   "norm",
   "is",
   "not",
   "None",
   "and",
   "norm",
   "!=",
   "1",
   "and",
   "norm",
   "!=",
   "np",
   ".",
   "inf",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Unsupported norm: {}'",
   ".",
   "format",
   "(",
   "repr",
   "(",
   "norm",
   ")",
   ")",
   ")",
   "# Initialize the weights",
   "n_mels",
   "=",
   "int",
   "(",
   "n_mels",
   ")",
   "weights",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "n_mels",
   ",",
   "int",
   "(",
   "1",
   "+",
   "n_fft",
   "//",
   "2",
   ")",
   ")",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "# Center freqs of each FFT bin",
   "fftfreqs",
   "=",
   "fft_frequencies",
   "(",
   "sr",
   "=",
   "sr",
   ",",
   "n_fft",
   "=",
   "n_fft",
   ")",
   "# 'Center freqs' of mel bands - uniformly spaced between limits",
   "mel_f",
   "=",
   "mel_frequencies",
   "(",
   "n_mels",
   "+",
   "2",
   ",",
   "fmin",
   "=",
   "fmin",
   ",",
   "fmax",
   "=",
   "fmax",
   ",",
   "htk",
   "=",
   "htk",
   ")",
   "fdiff",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "mel_f",
   ")",
   "ramps",
   "=",
   "np",
   ".",
   "subtract",
   ".",
   "outer",
   "(",
   "mel_f",
   ",",
   "fftfreqs",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n_mels",
   ")",
   ":",
   "# lower and upper slopes for all bins",
   "lower",
   "=",
   "-",
   "ramps",
   "[",
   "i",
   "]",
   "/",
   "fdiff",
   "[",
   "i",
   "]",
   "upper",
   "=",
   "ramps",
   "[",
   "i",
   "+",
   "2",
   "]",
   "/",
   "fdiff",
   "[",
   "i",
   "+",
   "1",
   "]",
   "# .. then intersect them with each other and zero",
   "weights",
   "[",
   "i",
   "]",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "0",
   ",",
   "np",
   ".",
   "minimum",
   "(",
   "lower",
   ",",
   "upper",
   ")",
   ")",
   "if",
   "norm",
   "==",
   "1",
   ":",
   "# Slaney-style mel is scaled to be approx constant energy per channel",
   "enorm",
   "=",
   "2.0",
   "/",
   "(",
   "mel_f",
   "[",
   "2",
   ":",
   "n_mels",
   "+",
   "2",
   "]",
   "-",
   "mel_f",
   "[",
   ":",
   "n_mels",
   "]",
   ")",
   "weights",
   "*=",
   "enorm",
   "[",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "# Only check weights if f_mel[0] is positive",
   "if",
   "not",
   "np",
   ".",
   "all",
   "(",
   "(",
   "mel_f",
   "[",
   ":",
   "-",
   "2",
   "]",
   "==",
   "0",
   ")",
   "|",
   "(",
   "weights",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ">",
   "0",
   ")",
   ")",
   ":",
   "# This means we have an empty channel somewhere",
   "warnings",
   ".",
   "warn",
   "(",
   "'Empty filters detected in mel frequency basis. '",
   "'Some channels will produce empty responses. '",
   "'Try increasing your sampling rate (and fmax) or '",
   "'reducing n_mels.'",
   ")",
   "return",
   "weights"
  ]
 },
 {
  "idx": "maxmin-809",
  "nl_tokens": [
   "Resolve",
   "ports",
   "of",
   "discovered",
   "memories"
  ],
  "pl_tokens": [
   "def",
   "finalize",
   "(",
   "self",
   ")",
   ":",
   "ff_to_remove",
   "=",
   "0",
   "res",
   "=",
   "self",
   ".",
   "resources",
   "for",
   "m",
   ",",
   "addrDict",
   "in",
   "self",
   ".",
   "memories",
   ".",
   "items",
   "(",
   ")",
   ":",
   "rwSyncPorts",
   ",",
   "rSyncPorts",
   ",",
   "wSyncPorts",
   "=",
   "0",
   ",",
   "0",
   ",",
   "0",
   "rwAsyncPorts",
   ",",
   "rAsyncPorts",
   ",",
   "wAsyncPorts",
   "=",
   "0",
   ",",
   "0",
   ",",
   "0",
   "rSync_wAsyncPorts",
   ",",
   "rAsync_wSyncPorts",
   "=",
   "0",
   ",",
   "0",
   "for",
   "_",
   ",",
   "(",
   "rSync",
   ",",
   "wSync",
   ",",
   "rAsync",
   ",",
   "wAsync",
   ")",
   "in",
   "addrDict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "rSync",
   ":",
   "ff_to_remove",
   "+=",
   "rSync",
   "*",
   "m",
   ".",
   "_dtype",
   ".",
   "elmType",
   ".",
   "bit_length",
   "(",
   ")",
   "# resolve port count for this addr signal",
   "rwSync",
   "=",
   "<mask>",
   "(",
   "rSync",
   ",",
   "wSync",
   ")",
   "rSync",
   "-=",
   "rwSync",
   "wSync",
   "-=",
   "rwSync",
   "rwAsync",
   "=",
   "min",
   "(",
   "rAsync",
   ",",
   "wAsync",
   ")",
   "rAsync",
   "-=",
   "rwAsync",
   "wAsync",
   "-=",
   "rwAsync",
   "rSync_wAsync",
   "=",
   "min",
   "(",
   "rSync",
   ",",
   "wAsync",
   ")",
   "rSync",
   "-=",
   "rSync_wAsync",
   "wAsync",
   "-=",
   "rSync_wAsync",
   "rAsync_wSync",
   "=",
   "min",
   "(",
   "rAsync",
   ",",
   "wSync",
   ")",
   "rAsync",
   "-=",
   "rAsync_wSync",
   "wSync",
   "-=",
   "rAsync_wSync",
   "# update port counts for mem",
   "rwSyncPorts",
   "+=",
   "rwSync",
   "rSyncPorts",
   "+=",
   "rSync",
   "wSyncPorts",
   "+=",
   "wSync",
   "rwAsyncPorts",
   "+=",
   "rwAsync",
   "rAsyncPorts",
   "+=",
   "rAsync",
   "wAsyncPorts",
   "+=",
   "wAsync",
   "rSync_wAsyncPorts",
   "+=",
   "rSync_wAsync",
   "rAsync_wSyncPorts",
   "+=",
   "rAsync_wSync",
   "k",
   "=",
   "ResourceRAM",
   "(",
   "m",
   ".",
   "_dtype",
   ".",
   "elmType",
   ".",
   "bit_length",
   "(",
   ")",
   ",",
   "int",
   "(",
   "m",
   ".",
   "_dtype",
   ".",
   "size",
   ")",
   ",",
   "rwSyncPorts",
   ",",
   "rSyncPorts",
   ",",
   "wSyncPorts",
   ",",
   "rSync_wAsyncPorts",
   ",",
   "rwAsyncPorts",
   ",",
   "rAsyncPorts",
   ",",
   "wAsyncPorts",
   ",",
   "rAsync_wSyncPorts",
   ")",
   "res",
   "[",
   "k",
   "]",
   "=",
   "res",
   ".",
   "get",
   "(",
   "k",
   ",",
   "0",
   ")",
   "+",
   "1",
   "self",
   ".",
   "memories",
   ".",
   "clear",
   "(",
   ")",
   "# remove register on read ports which will be merged into ram",
   "if",
   "ff_to_remove",
   ":",
   "ff_cnt",
   "=",
   "res",
   "[",
   "ResourceFF",
   "]",
   "ff_cnt",
   "-=",
   "ff_to_remove",
   "if",
   "ff_cnt",
   ":",
   "res",
   "[",
   "ResourceFF",
   "]",
   "=",
   "ff_cnt",
   "else",
   ":",
   "del",
   "res",
   "[",
   "ResourceFF",
   "]"
  ]
 },
 {
  "idx": "maxmin-810",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "Fast",
   "Fourier",
   "Transform",
   "of",
   "a",
   "waveform",
   "."
  ],
  "pl_tokens": [
   "def",
   "fft",
   "(",
   "wave",
   ",",
   "npoints",
   "=",
   "None",
   ",",
   "indep_min",
   "=",
   "None",
   ",",
   "indep_max",
   "=",
   "None",
   ")",
   ":",
   "ret",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "wave",
   ")",
   "_bound_waveform",
   "(",
   "ret",
   ",",
   "indep_min",
   ",",
   "indep_max",
   ")",
   "npoints",
   "=",
   "npoints",
   "or",
   "ret",
   ".",
   "_indep_vector",
   ".",
   "size",
   "fs",
   "=",
   "(",
   "npoints",
   "-",
   "1",
   ")",
   "/",
   "float",
   "(",
   "ret",
   ".",
   "_indep_vector",
   "[",
   "-",
   "1",
   "]",
   ")",
   "spoints",
   "=",
   "<mask>",
   "(",
   "ret",
   ".",
   "_indep_vector",
   ".",
   "size",
   ",",
   "npoints",
   ")",
   "sdiff",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "ret",
   ".",
   "_indep_vector",
   "[",
   ":",
   "spoints",
   "]",
   ")",
   "cond",
   "=",
   "not",
   "np",
   ".",
   "all",
   "(",
   "np",
   ".",
   "isclose",
   "(",
   "sdiff",
   ",",
   "sdiff",
   "[",
   "0",
   "]",
   "*",
   "np",
   ".",
   "ones",
   "(",
   "spoints",
   "-",
   "1",
   ")",
   ",",
   "FP_RTOL",
   ",",
   "FP_ATOL",
   ")",
   ")",
   "pexdoc",
   ".",
   "addex",
   "(",
   "RuntimeError",
   ",",
   "\"Non-uniform sampling\"",
   ",",
   "cond",
   ")",
   "finc",
   "=",
   "fs",
   "/",
   "float",
   "(",
   "npoints",
   "-",
   "1",
   ")",
   "indep_vector",
   "=",
   "_barange",
   "(",
   "-",
   "fs",
   "/",
   "2.0",
   ",",
   "+",
   "fs",
   "/",
   "2.0",
   ",",
   "finc",
   ")",
   "dep_vector",
   "=",
   "np",
   ".",
   "fft",
   ".",
   "fft",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ",",
   "npoints",
   ")",
   "return",
   "Waveform",
   "(",
   "indep_vector",
   "=",
   "indep_vector",
   ",",
   "dep_vector",
   "=",
   "dep_vector",
   ",",
   "dep_name",
   "=",
   "\"fft({0})\"",
   ".",
   "format",
   "(",
   "ret",
   ".",
   "dep_name",
   ")",
   ",",
   "indep_scale",
   "=",
   "\"LINEAR\"",
   ",",
   "dep_scale",
   "=",
   "\"LINEAR\"",
   ",",
   "indep_units",
   "=",
   "\"Hz\"",
   ",",
   "dep_units",
   "=",
   "\"\"",
   ",",
   ")"
  ]
 },
 {
  "idx": "maxmin-811",
  "nl_tokens": [
   "Return",
   "a",
   "random",
   "quantum",
   "state",
   "from",
   "the",
   "uniform",
   "(",
   "Haar",
   ")",
   "measure",
   "on",
   "state",
   "space",
   "."
  ],
  "pl_tokens": [
   "def",
   "random_state",
   "(",
   "dim",
   ",",
   "seed",
   "=",
   "None",
   ")",
   ":",
   "if",
   "seed",
   "is",
   "None",
   ":",
   "seed",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "np",
   ".",
   "iinfo",
   "(",
   "np",
   ".",
   "int32",
   ")",
   ".",
   "<mask>",
   ")",
   "rng",
   "=",
   "np",
   ".",
   "random",
   ".",
   "RandomState",
   "(",
   "seed",
   ")",
   "# Random array over interval (0, 1]",
   "x",
   "=",
   "rng",
   ".",
   "rand",
   "(",
   "dim",
   ")",
   "x",
   "+=",
   "x",
   "==",
   "0",
   "x",
   "=",
   "-",
   "np",
   ".",
   "log",
   "(",
   "x",
   ")",
   "sumx",
   "=",
   "sum",
   "(",
   "x",
   ")",
   "phases",
   "=",
   "rng",
   ".",
   "rand",
   "(",
   "dim",
   ")",
   "*",
   "2.0",
   "*",
   "np",
   ".",
   "pi",
   "return",
   "np",
   ".",
   "sqrt",
   "(",
   "x",
   "/",
   "sumx",
   ")",
   "*",
   "np",
   ".",
   "exp",
   "(",
   "1j",
   "*",
   "phases",
   ")"
  ]
 },
 {
  "idx": "maxmin-812",
  "nl_tokens": [
   "Optimise",
   "data",
   "selection",
   "based",
   "on",
   "specified",
   "analytes",
   "."
  ],
  "pl_tokens": [
   "def",
   "signal_optimiser",
   "(",
   "d",
   ",",
   "analytes",
   ",",
   "min_points",
   "=",
   "5",
   ",",
   "threshold_mode",
   "=",
   "'kde_first_max'",
   ",",
   "threshold_mult",
   "=",
   "1.",
   ",",
   "x_bias",
   "=",
   "0",
   ",",
   "weights",
   "=",
   "None",
   ",",
   "ind",
   "=",
   "None",
   ",",
   "mode",
   "=",
   "'minimise'",
   ")",
   ":",
   "errmsg",
   "=",
   "''",
   "if",
   "isinstance",
   "(",
   "analytes",
   ",",
   "str",
   ")",
   ":",
   "analytes",
   "=",
   "[",
   "analytes",
   "]",
   "if",
   "ind",
   "is",
   "None",
   ":",
   "ind",
   "=",
   "np",
   ".",
   "full",
   "(",
   "len",
   "(",
   "d",
   ".",
   "Time",
   ")",
   ",",
   "True",
   ")",
   "# initial catch",
   "if",
   "not",
   "any",
   "(",
   "ind",
   ")",
   "or",
   "(",
   "np",
   ".",
   "diff",
   "(",
   "bool_2_indices",
   "(",
   "ind",
   ")",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "<",
   "min_points",
   ")",
   ":",
   "errmsg",
   "=",
   "'Optmisation failed. No contiguous data regions longer than {:.0f} points.'",
   ".",
   "format",
   "(",
   "min_points",
   ")",
   "return",
   "Bunch",
   "(",
   "{",
   "'means'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'stds'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'mean_threshold'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'std_threshold'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'lims'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'filt'",
   ":",
   "ind",
   ",",
   "'threshold_mode'",
   ":",
   "threshold_mode",
   ",",
   "'min_points'",
   ":",
   "min_points",
   ",",
   "'analytes'",
   ":",
   "analytes",
   ",",
   "'opt_centre'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'opt_n_points'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'weights'",
   ":",
   "weights",
   ",",
   "'optimisation_success'",
   ":",
   "False",
   ",",
   "'errmsg'",
   ":",
   "errmsg",
   "}",
   ")",
   ",",
   "errmsg",
   "msmeans",
   ",",
   "msstds",
   "=",
   "calculate_optimisation_stats",
   "(",
   "d",
   ",",
   "analytes",
   ",",
   "min_points",
   ",",
   "weights",
   ",",
   "ind",
   ",",
   "x_bias",
   ")",
   "# second catch",
   "if",
   "all",
   "(",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ")",
   ".",
   "flat",
   ")",
   "or",
   "all",
   "(",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ")",
   ".",
   "flat",
   ")",
   ":",
   "errmsg",
   "=",
   "'Optmisation failed. No contiguous data regions longer than {:.0f} points.'",
   ".",
   "format",
   "(",
   "min_points",
   ")",
   "return",
   "Bunch",
   "(",
   "{",
   "'means'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'stds'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'mean_threshold'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'std_threshold'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'lims'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'filt'",
   ":",
   "ind",
   ",",
   "'threshold_mode'",
   ":",
   "threshold_mode",
   ",",
   "'min_points'",
   ":",
   "min_points",
   ",",
   "'analytes'",
   ":",
   "analytes",
   ",",
   "'opt_centre'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'opt_n_points'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'weights'",
   ":",
   "weights",
   ",",
   "'optimisation_success'",
   ":",
   "False",
   ",",
   "'errmsg'",
   ":",
   "errmsg",
   "}",
   ")",
   ",",
   "errmsg",
   "# define thresholds",
   "valid",
   "=",
   "[",
   "'kde_first_max'",
   ",",
   "'kde_max'",
   ",",
   "'median'",
   ",",
   "'bayes_mvs'",
   ",",
   "'mean'",
   "]",
   "n_under",
   "=",
   "0",
   "i",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "np",
   ".",
   "array",
   "(",
   "valid",
   ")",
   "==",
   "threshold_mode",
   ")",
   "[",
   "0",
   ",",
   "0",
   "]",
   "o_threshold_mode",
   "=",
   "threshold_mode",
   "while",
   "(",
   "n_under",
   "<=",
   "0",
   ")",
   "&",
   "(",
   "i",
   "<",
   "len",
   "(",
   "valid",
   ")",
   ")",
   ":",
   "if",
   "threshold_mode",
   "==",
   "'median'",
   ":",
   "# median - OK, but best?",
   "std_threshold",
   "=",
   "np",
   ".",
   "nanmedian",
   "(",
   "msstds",
   ")",
   "mean_threshold",
   "=",
   "np",
   ".",
   "nanmedian",
   "(",
   "msmeans",
   ")",
   "elif",
   "threshold_mode",
   "==",
   "'mean'",
   ":",
   "# mean",
   "std_threshold",
   "=",
   "np",
   ".",
   "nanmean",
   "(",
   "msstds",
   ")",
   "mean_threshold",
   "=",
   "np",
   ".",
   "nanmean",
   "(",
   "msmeans",
   ")",
   "elif",
   "threshold_mode",
   "==",
   "'kde_max'",
   ":",
   "# maximum of gaussian kernel density estimator",
   "mkd",
   "=",
   "gaussian_kde",
   "(",
   "msmeans",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ")",
   "]",
   ".",
   "flat",
   ")",
   "xm",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "*",
   "np",
   ".",
   "percentile",
   "(",
   "msmeans",
   ".",
   "flatten",
   "(",
   ")",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "]",
   ",",
   "(",
   "1",
   ",",
   "99",
   ")",
   ")",
   ",",
   "100",
   ")",
   "mdf",
   "=",
   "mkd",
   ".",
   "pdf",
   "(",
   "xm",
   ")",
   "mean_threshold",
   "=",
   "xm",
   "[",
   "np",
   ".",
   "argmax",
   "(",
   "mdf",
   ")",
   "]",
   "rkd",
   "=",
   "gaussian_kde",
   "(",
   "msstds",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msstds",
   ")",
   "]",
   ")",
   "xr",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "*",
   "np",
   ".",
   "percentile",
   "(",
   "msstds",
   ".",
   "flatten",
   "(",
   ")",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msstds",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "]",
   ",",
   "(",
   "1",
   ",",
   "99",
   ")",
   ")",
   ",",
   "100",
   ")",
   "rdf",
   "=",
   "rkd",
   ".",
   "pdf",
   "(",
   "xr",
   ")",
   "std_threshold",
   "=",
   "xr",
   "[",
   "np",
   ".",
   "argmax",
   "(",
   "rdf",
   ")",
   "]",
   "elif",
   "threshold_mode",
   "==",
   "'kde_first_max'",
   ":",
   "# first local maximum of gaussian kernel density estimator",
   "mkd",
   "=",
   "gaussian_kde",
   "(",
   "msmeans",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ")",
   "]",
   ".",
   "flat",
   ")",
   "xm",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "*",
   "np",
   ".",
   "percentile",
   "(",
   "msmeans",
   ".",
   "flatten",
   "(",
   ")",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "]",
   ",",
   "(",
   "1",
   ",",
   "99",
   ")",
   ")",
   ",",
   "100",
   ")",
   "mdf",
   "=",
   "mkd",
   ".",
   "pdf",
   "(",
   "xm",
   ")",
   "inds",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "np",
   ".",
   "r_",
   "[",
   "False",
   ",",
   "mdf",
   "[",
   "1",
   ":",
   "]",
   ">",
   "mdf",
   "[",
   ":",
   "-",
   "1",
   "]",
   "]",
   "&",
   "np",
   ".",
   "r_",
   "[",
   "mdf",
   "[",
   ":",
   "-",
   "1",
   "]",
   ">",
   "mdf",
   "[",
   "1",
   ":",
   "]",
   ",",
   "False",
   "]",
   "&",
   "(",
   "mdf",
   ">",
   "0.25",
   "*",
   "mdf",
   ".",
   "max",
   "(",
   ")",
   ")",
   ")",
   "mean_threshold",
   "=",
   "xm",
   "[",
   "np",
   ".",
   "min",
   "(",
   "inds",
   ")",
   "]",
   "rkd",
   "=",
   "gaussian_kde",
   "(",
   "msstds",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msstds",
   ")",
   "]",
   ")",
   "xr",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "*",
   "np",
   ".",
   "percentile",
   "(",
   "msstds",
   ".",
   "flatten",
   "(",
   ")",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msstds",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "]",
   ",",
   "(",
   "1",
   ",",
   "99",
   ")",
   ")",
   ",",
   "100",
   ")",
   "rdf",
   "=",
   "rkd",
   ".",
   "pdf",
   "(",
   "xr",
   ")",
   "inds",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "np",
   ".",
   "r_",
   "[",
   "False",
   ",",
   "rdf",
   "[",
   "1",
   ":",
   "]",
   ">",
   "rdf",
   "[",
   ":",
   "-",
   "1",
   "]",
   "]",
   "&",
   "np",
   ".",
   "r_",
   "[",
   "rdf",
   "[",
   ":",
   "-",
   "1",
   "]",
   ">",
   "rdf",
   "[",
   "1",
   ":",
   "]",
   ",",
   "False",
   "]",
   "&",
   "(",
   "rdf",
   ">",
   "0.25",
   "*",
   "rdf",
   ".",
   "max",
   "(",
   ")",
   ")",
   ")",
   "std_threshold",
   "=",
   "xr",
   "[",
   "np",
   ".",
   "min",
   "(",
   "inds",
   ")",
   "]",
   "elif",
   "threshold_mode",
   "==",
   "'bayes_mvs'",
   ":",
   "# bayesian mvs.",
   "bm",
   ",",
   "_",
   ",",
   "bs",
   "=",
   "bayes_mvs",
   "(",
   "msstds",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msstds",
   ")",
   "]",
   ")",
   "std_threshold",
   "=",
   "bm",
   ".",
   "statistic",
   "bm",
   ",",
   "_",
   ",",
   "bs",
   "=",
   "bayes_mvs",
   "(",
   "msmeans",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ")",
   "]",
   ")",
   "mean_threshold",
   "=",
   "bm",
   ".",
   "statistic",
   "elif",
   "callable",
   "(",
   "threshold_mode",
   ")",
   ":",
   "std_threshold",
   "=",
   "threshold_mode",
   "(",
   "msstds",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msstds",
   ")",
   "]",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "mean_threshold",
   "=",
   "threshold_mode",
   "(",
   "msmeans",
   "[",
   "~",
   "np",
   ".",
   "isnan",
   "(",
   "msmeans",
   ")",
   "]",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "else",
   ":",
   "try",
   ":",
   "mean_threshold",
   ",",
   "std_threshold",
   "=",
   "threshold_mode",
   "except",
   ":",
   "raise",
   "ValueError",
   "(",
   "'\\nthreshold_mode must be one of:\\n   '",
   "+",
   "', '",
   ".",
   "join",
   "(",
   "valid",
   ")",
   "+",
   "',\\na custom function, or a \\n(mean_threshold, std_threshold) tuple.'",
   ")",
   "# apply threshold_mult",
   "if",
   "isinstance",
   "(",
   "threshold_mult",
   ",",
   "(",
   "int",
   ",",
   "float",
   ")",
   ")",
   ":",
   "std_threshold",
   "*=",
   "threshold_mult",
   "mean_threshold",
   "*=",
   "threshold_mult",
   "elif",
   "len",
   "(",
   "threshold_mult",
   ")",
   "==",
   "2",
   ":",
   "mean_threshold",
   "*=",
   "threshold_mult",
   "[",
   "0",
   "]",
   "std_threshold",
   "*=",
   "threshold_mult",
   "[",
   "1",
   "]",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'\\nthreshold_mult must be a float, int or tuple of length 2.'",
   ")",
   "rind",
   "=",
   "(",
   "msstds",
   "<",
   "std_threshold",
   ")",
   "if",
   "mode",
   "==",
   "'minimise'",
   ":",
   "mind",
   "=",
   "(",
   "msmeans",
   "<",
   "mean_threshold",
   ")",
   "else",
   ":",
   "mind",
   "=",
   "(",
   "msmeans",
   ">",
   "mean_threshold",
   ")",
   "ind",
   "=",
   "rind",
   "&",
   "mind",
   "n_under",
   "=",
   "ind",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "n_under",
   "==",
   "0",
   ":",
   "i",
   "+=",
   "1",
   "if",
   "i",
   "<=",
   "len",
   "(",
   "valid",
   ")",
   "-",
   "1",
   ":",
   "threshold_mode",
   "=",
   "valid",
   "[",
   "i",
   "]",
   "else",
   ":",
   "errmsg",
   "=",
   "'Optimisation failed. No of the threshold_mode would work. Try reducting min_points.'",
   "return",
   "Bunch",
   "(",
   "{",
   "'means'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'stds'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'mean_threshold'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'std_threshold'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'lims'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'filt'",
   ":",
   "ind",
   ",",
   "'threshold_mode'",
   ":",
   "threshold_mode",
   ",",
   "'min_points'",
   ":",
   "min_points",
   ",",
   "'analytes'",
   ":",
   "analytes",
   ",",
   "'opt_centre'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'opt_n_points'",
   ":",
   "np",
   ".",
   "nan",
   ",",
   "'weights'",
   ":",
   "weights",
   ",",
   "'optimisation_success'",
   ":",
   "False",
   ",",
   "'errmsg'",
   ":",
   "errmsg",
   "}",
   ")",
   ",",
   "errmsg",
   "if",
   "i",
   ">",
   "0",
   ":",
   "errmsg",
   "=",
   "\"optimisation failed using threshold_mode='{:}', falling back to '{:}'\"",
   ".",
   "format",
   "(",
   "o_threshold_mode",
   ",",
   "threshold_mode",
   ")",
   "# identify max number of points within thresholds",
   "passing",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "ind",
   ")",
   "opt_n_points",
   "=",
   "passing",
   "[",
   ":",
   ",",
   "0",
   "]",
   ".",
   "max",
   "(",
   ")",
   "opt_centre",
   "=",
   "passing",
   "[",
   "passing",
   "[",
   ":",
   ",",
   "0",
   "]",
   "==",
   "opt_n_points",
   ",",
   "1",
   "]",
   ".",
   "min",
   "(",
   ")",
   "opt_n_points",
   "+=",
   "min_points",
   "# centres, npoints = np.meshgrid(np.arange(msmeans.shape[1]),",
   "#                                np.arange(min_points, min_points + msmeans.shape[0]))",
   "# opt_n_points = npoints[ind].max()",
   "# plus/minus one point to allow some freedom to shift selection window.",
   "# cind = ind & (npoints == opt_n_points)",
   "# opt_centre = centres[cind].min()",
   "if",
   "opt_n_points",
   "%",
   "2",
   "==",
   "0",
   ":",
   "lims",
   "=",
   "(",
   "opt_centre",
   "-",
   "opt_n_points",
   "//",
   "2",
   ",",
   "opt_centre",
   "+",
   "opt_n_points",
   "//",
   "2",
   ")",
   "else",
   ":",
   "lims",
   "=",
   "(",
   "opt_centre",
   "-",
   "opt_n_points",
   "//",
   "2",
   ",",
   "opt_centre",
   "+",
   "opt_n_points",
   "//",
   "2",
   "+",
   "1",
   ")",
   "filt",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "d",
   ".",
   "Time",
   ".",
   "shape",
   ",",
   "dtype",
   "=",
   "bool",
   ")",
   "filt",
   "[",
   "lims",
   "[",
   "0",
   "]",
   ":",
   "lims",
   "[",
   "1",
   "]",
   "]",
   "=",
   "True",
   "return",
   "Bunch",
   "(",
   "{",
   "'means'",
   ":",
   "msmeans",
   ",",
   "'stds'",
   ":",
   "msstds",
   ",",
   "'mean_threshold'",
   ":",
   "mean_threshold",
   ",",
   "'std_threshold'",
   ":",
   "std_threshold",
   ",",
   "'lims'",
   ":",
   "lims",
   ",",
   "'filt'",
   ":",
   "filt",
   ",",
   "'threshold_mode'",
   ":",
   "threshold_mode",
   ",",
   "'min_points'",
   ":",
   "min_points",
   ",",
   "'analytes'",
   ":",
   "analytes",
   ",",
   "'opt_centre'",
   ":",
   "opt_centre",
   ",",
   "'opt_n_points'",
   ":",
   "opt_n_points",
   ",",
   "'weights'",
   ":",
   "weights",
   ",",
   "'optimisation_success'",
   ":",
   "True",
   ",",
   "'errmsg'",
   ":",
   "errmsg",
   "}",
   ")",
   ",",
   "errmsg"
  ]
 },
 {
  "idx": "maxmin-813",
  "nl_tokens": [
   "Calculates",
   "the",
   "foundation",
   "capacity",
   "according",
   "Vesics",
   "(",
   "1975",
   ")",
   "#Gunaratne",
   "Manjriker",
   ".",
   "2006",
   ".",
   "Spread",
   "Footings",
   ":",
   "Analysis",
   "and",
   "Design",
   ".",
   "Ref",
   ":",
   "http",
   ":",
   "//",
   "geo",
   ".",
   "cv",
   ".",
   "nctu",
   ".",
   "edu",
   ".",
   "tw",
   "/",
   "foundation",
   "/",
   "download",
   "/",
   "BearingCapacityOfFoundations",
   ".",
   "pdf"
  ],
  "pl_tokens": [
   "def",
   "capacity_vesics_1975",
   "(",
   "sl",
   ",",
   "fd",
   ",",
   "h_l",
   "=",
   "0",
   ",",
   "h_b",
   "=",
   "0",
   ",",
   "vertical_load",
   "=",
   "1",
   ",",
   "slope",
   "=",
   "0",
   ",",
   "base_tilt",
   "=",
   "0",
   ",",
   "verbose",
   "=",
   "0",
   ",",
   "gwl",
   "=",
   "1e6",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"disable_requires\"",
   ",",
   "False",
   ")",
   ":",
   "models",
   ".",
   "check_required",
   "(",
   "sl",
   ",",
   "[",
   "\"phi_r\"",
   ",",
   "\"cohesion\"",
   ",",
   "\"unit_dry_weight\"",
   "]",
   ")",
   "models",
   ".",
   "check_required",
   "(",
   "fd",
   ",",
   "[",
   "\"length\"",
   ",",
   "\"width\"",
   ",",
   "\"depth\"",
   "]",
   ")",
   "area_foundation",
   "=",
   "fd",
   ".",
   "length",
   "*",
   "fd",
   ".",
   "width",
   "c_a",
   "=",
   "0.6",
   "-",
   "1.0",
   "*",
   "sl",
   ".",
   "cohesion",
   "horizontal_load",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "h_l",
   "**",
   "2",
   "+",
   "h_b",
   "**",
   "2",
   ")",
   "fd",
   ".",
   "nq_factor",
   "=",
   "(",
   "(",
   "np",
   ".",
   "tan",
   "(",
   "np",
   ".",
   "pi",
   "/",
   "4",
   "+",
   "sl",
   ".",
   "phi_r",
   "/",
   "2",
   ")",
   ")",
   "**",
   "2",
   "*",
   "np",
   ".",
   "exp",
   "(",
   "np",
   ".",
   "pi",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   ")",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "fd",
   ".",
   "nc_factor",
   "=",
   "5.14",
   "else",
   ":",
   "fd",
   ".",
   "nc_factor",
   "=",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "fd",
   ".",
   "ng_factor",
   "=",
   "2.0",
   "*",
   "(",
   "fd",
   ".",
   "nq_factor",
   "+",
   "1",
   ")",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "# shape factors:",
   "s_c",
   "=",
   "1.0",
   "+",
   "fd",
   ".",
   "nq_factor",
   "/",
   "fd",
   ".",
   "nc_factor",
   "*",
   "fd",
   ".",
   "width",
   "/",
   "fd",
   ".",
   "length",
   "s_q",
   "=",
   "1",
   "+",
   "fd",
   ".",
   "width",
   "/",
   "fd",
   ".",
   "length",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "s_g",
   "=",
   "<mask>",
   "(",
   "1.0",
   "-",
   "0.4",
   "*",
   "fd",
   ".",
   "width",
   "/",
   "fd",
   ".",
   "length",
   ",",
   "0.6",
   ")",
   "# add limit of 0.6 based on Vesic",
   "# depth factors:",
   "if",
   "fd",
   ".",
   "depth",
   "/",
   "fd",
   ".",
   "width",
   ">",
   "1",
   ":",
   "k",
   "=",
   "np",
   ".",
   "arctan",
   "(",
   "fd",
   ".",
   "depth",
   "/",
   "fd",
   ".",
   "width",
   ")",
   "else",
   ":",
   "k",
   "=",
   "fd",
   ".",
   "depth",
   "/",
   "fd",
   ".",
   "width",
   "d_c",
   "=",
   "1",
   "+",
   "0.4",
   "*",
   "k",
   "d_q",
   "=",
   "1",
   "+",
   "2",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "*",
   "(",
   "1",
   "-",
   "np",
   ".",
   "sin",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "**",
   "2",
   "*",
   "k",
   "d_g",
   "=",
   "1.0",
   "# load inclination factors",
   "m__b",
   "=",
   "(",
   "2.0",
   "+",
   "fd",
   ".",
   "width",
   "/",
   "fd",
   ".",
   "length",
   ")",
   "/",
   "(",
   "1",
   "+",
   "fd",
   ".",
   "width",
   "/",
   "fd",
   ".",
   "length",
   ")",
   "m_l",
   "=",
   "(",
   "2.0",
   "+",
   "fd",
   ".",
   "length",
   "/",
   "fd",
   ".",
   "width",
   ")",
   "/",
   "(",
   "1",
   "+",
   "fd",
   ".",
   "length",
   "/",
   "fd",
   ".",
   "width",
   ")",
   "m",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "m__b",
   "**",
   "2",
   "+",
   "m_l",
   "**",
   "2",
   ")",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "i_q",
   "=",
   "1.0",
   "i_g",
   "=",
   "1.0",
   "else",
   ":",
   "i_q",
   "=",
   "(",
   "1.0",
   "-",
   "horizontal_load",
   "/",
   "(",
   "vertical_load",
   "+",
   "area_foundation",
   "*",
   "c_a",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   ")",
   "**",
   "m",
   "i_g",
   "=",
   "(",
   "1.0",
   "-",
   "horizontal_load",
   "/",
   "(",
   "vertical_load",
   "+",
   "area_foundation",
   "*",
   "c_a",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   ")",
   "**",
   "(",
   "m",
   "+",
   "1",
   ")",
   "i_c",
   "=",
   "i_q",
   "-",
   "(",
   "1",
   "-",
   "i_q",
   ")",
   "/",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "check_i_c",
   "=",
   "1",
   "-",
   "m",
   "*",
   "horizontal_load",
   "/",
   "(",
   "area_foundation",
   "*",
   "c_a",
   "*",
   "fd",
   ".",
   "nc_factor",
   ")",
   "if",
   "abs",
   "(",
   "check_i_c",
   "-",
   "i_c",
   ")",
   "/",
   "i_c",
   ">",
   "0.001",
   ":",
   "raise",
   "DesignError",
   "# ground slope factors:",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "# g_c = slope / 5.14",
   "g_c",
   "=",
   "i_q",
   "else",
   ":",
   "g_c",
   "=",
   "i_q",
   "-",
   "(",
   "1",
   "-",
   "i_q",
   ")",
   "/",
   "(",
   "5.14",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "g_q",
   "=",
   "(",
   "1.0",
   "-",
   "np",
   ".",
   "tan",
   "(",
   "slope",
   ")",
   ")",
   "**",
   "2",
   "g_g",
   "=",
   "g_q",
   "# tilted base factors",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "b_c",
   "=",
   "g_c",
   "else",
   ":",
   "b_c",
   "=",
   "1",
   "-",
   "2",
   "*",
   "base_tilt",
   "/",
   "(",
   "5.14",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "b_q",
   "=",
   "(",
   "1.0",
   "-",
   "base_tilt",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "**",
   "2",
   "b_g",
   "=",
   "b_q",
   "# stress at footing base:",
   "if",
   "gwl",
   "==",
   "0",
   ":",
   "q_d",
   "=",
   "sl",
   ".",
   "unit_eff_weight",
   "*",
   "fd",
   ".",
   "depth",
   "unit_weight",
   "=",
   "sl",
   ".",
   "unit_bouy_weight",
   "elif",
   "gwl",
   ">",
   "0",
   "and",
   "gwl",
   "<",
   "fd",
   ".",
   "depth",
   ":",
   "q_d",
   "=",
   "(",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "gwl",
   ")",
   "+",
   "(",
   "sl",
   ".",
   "unit_bouy_weight",
   "*",
   "(",
   "fd",
   ".",
   "depth",
   "-",
   "gwl",
   ")",
   ")",
   "unit_weight",
   "=",
   "sl",
   ".",
   "unit_bouy_weight",
   "elif",
   "gwl",
   ">=",
   "fd",
   ".",
   "depth",
   "and",
   "gwl",
   "<=",
   "fd",
   ".",
   "depth",
   "+",
   "fd",
   ".",
   "width",
   ":",
   "sl",
   ".",
   "average_unit_bouy_weight",
   "=",
   "sl",
   ".",
   "unit_bouy_weight",
   "+",
   "(",
   "(",
   "(",
   "gwl",
   "-",
   "fd",
   ".",
   "depth",
   ")",
   "/",
   "fd",
   ".",
   "width",
   ")",
   "*",
   "(",
   "sl",
   ".",
   "unit_dry_weight",
   "-",
   "sl",
   ".",
   "unit_bouy_weight",
   ")",
   ")",
   "q_d",
   "=",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "fd",
   ".",
   "depth",
   "unit_weight",
   "=",
   "sl",
   ".",
   "average_unit_bouy_weight",
   "elif",
   "gwl",
   ">",
   "fd",
   ".",
   "depth",
   "+",
   "fd",
   ".",
   "width",
   ":",
   "q_d",
   "=",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "fd",
   ".",
   "depth",
   "unit_weight",
   "=",
   "sl",
   ".",
   "unit_dry_weight",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"Nc: \"",
   ",",
   "fd",
   ".",
   "nc_factor",
   ")",
   "log",
   "(",
   "\"N_qV: \"",
   ",",
   "fd",
   ".",
   "nq_factor",
   ")",
   "log",
   "(",
   "\"Ng: \"",
   ",",
   "fd",
   ".",
   "ng_factor",
   ")",
   "log",
   "(",
   "\"s_c: \"",
   ",",
   "s_c",
   ")",
   "log",
   "(",
   "\"s_q: \"",
   ",",
   "s_q",
   ")",
   "log",
   "(",
   "\"s_g: \"",
   ",",
   "s_g",
   ")",
   "log",
   "(",
   "\"d_c: \"",
   ",",
   "d_c",
   ")",
   "log",
   "(",
   "\"d_q: \"",
   ",",
   "d_q",
   ")",
   "log",
   "(",
   "\"d_g: \"",
   ",",
   "d_g",
   ")",
   "log",
   "(",
   "\"i_c: \"",
   ",",
   "i_c",
   ")",
   "log",
   "(",
   "\"i_q: \"",
   ",",
   "i_q",
   ")",
   "log",
   "(",
   "\"i_g: \"",
   ",",
   "i_g",
   ")",
   "log",
   "(",
   "\"g_c: \"",
   ",",
   "g_c",
   ")",
   "log",
   "(",
   "\"g_q: \"",
   ",",
   "g_q",
   ")",
   "log",
   "(",
   "\"g_g: \"",
   ",",
   "g_g",
   ")",
   "log",
   "(",
   "\"b_c: \"",
   ",",
   "b_c",
   ")",
   "log",
   "(",
   "\"b_q: \"",
   ",",
   "b_q",
   ")",
   "log",
   "(",
   "\"b_g: \"",
   ",",
   "b_g",
   ")",
   "log",
   "(",
   "\"q_d: \"",
   ",",
   "q_d",
   ")",
   "# Capacity",
   "fd",
   ".",
   "q_ult",
   "=",
   "(",
   "sl",
   ".",
   "cohesion",
   "*",
   "fd",
   ".",
   "nc_factor",
   "*",
   "s_c",
   "*",
   "d_c",
   "*",
   "i_c",
   "*",
   "g_c",
   "*",
   "b_c",
   "+",
   "q_d",
   "*",
   "fd",
   ".",
   "nq_factor",
   "*",
   "s_q",
   "*",
   "d_q",
   "*",
   "i_q",
   "*",
   "g_q",
   "*",
   "b_q",
   "+",
   "0.5",
   "*",
   "fd",
   ".",
   "width",
   "*",
   "unit_weight",
   "*",
   "fd",
   ".",
   "ng_factor",
   "*",
   "s_g",
   "*",
   "d_g",
   "*",
   "i_g",
   "*",
   "g_g",
   "*",
   "b_g",
   ")",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"qult: \"",
   ",",
   "fd",
   ".",
   "q_ult",
   ")",
   "return",
   "fd",
   ".",
   "q_ult"
  ]
 },
 {
  "idx": "maxmin-814",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "hyperbolic",
   "arc",
   "tangent",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "atanh",
   "(",
   "wave",
   ")",
   ":",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "ValueError",
   ",",
   "\"Math domain error\"",
   ",",
   "bool",
   "(",
   "(",
   "<mask>",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   "<",
   "-",
   "1",
   ")",
   "or",
   "(",
   "max",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   ">",
   "1",
   ")",
   ")",
   ",",
   ")",
   "return",
   "_operation",
   "(",
   "wave",
   ",",
   "\"atanh\"",
   ",",
   "\"\"",
   ",",
   "np",
   ".",
   "arctanh",
   ")"
  ]
 },
 {
  "idx": "maxmin-815",
  "nl_tokens": [
   "Gets",
   "the",
   "maximum",
   "length",
   "of",
   "each",
   "column"
  ],
  "pl_tokens": [
   "def",
   "getMetricsColumnLengths",
   "(",
   "self",
   ")",
   ":",
   "displayLen",
   "=",
   "0",
   "descLen",
   "=",
   "0",
   "for",
   "m",
   "in",
   "self",
   ".",
   "metrics",
   ":",
   "displayLen",
   "=",
   "<mask>",
   "(",
   "displayLen",
   ",",
   "len",
   "(",
   "m",
   "[",
   "'displayName'",
   "]",
   ")",
   ")",
   "descLen",
   "=",
   "max",
   "(",
   "descLen",
   ",",
   "len",
   "(",
   "m",
   "[",
   "'description'",
   "]",
   ")",
   ")",
   "return",
   "(",
   "displayLen",
   ",",
   "descLen",
   ")"
  ]
 },
 {
  "idx": "maxmin-816",
  "nl_tokens": [
   "Plot",
   "the",
   "cityscape",
   "of",
   "quantum",
   "state",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_state_city",
   "(",
   "rho",
   ",",
   "title",
   "=",
   "\"\"",
   ",",
   "figsize",
   "=",
   "None",
   ",",
   "color",
   "=",
   "None",
   ",",
   "alpha",
   "=",
   "1",
   ")",
   ":",
   "if",
   "not",
   "HAS_MATPLOTLIB",
   ":",
   "raise",
   "ImportError",
   "(",
   "'Must have Matplotlib installed.'",
   ")",
   "rho",
   "=",
   "_validate_input_state",
   "(",
   "rho",
   ")",
   "num",
   "=",
   "int",
   "(",
   "np",
   ".",
   "log2",
   "(",
   "len",
   "(",
   "rho",
   ")",
   ")",
   ")",
   "# get the real and imag parts of rho",
   "datareal",
   "=",
   "np",
   ".",
   "real",
   "(",
   "rho",
   ")",
   "dataimag",
   "=",
   "np",
   ".",
   "imag",
   "(",
   "rho",
   ")",
   "# get the labels",
   "column_names",
   "=",
   "[",
   "bin",
   "(",
   "i",
   ")",
   "[",
   "2",
   ":",
   "]",
   ".",
   "zfill",
   "(",
   "num",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   "]",
   "row_names",
   "=",
   "[",
   "bin",
   "(",
   "i",
   ")",
   "[",
   "2",
   ":",
   "]",
   ".",
   "zfill",
   "(",
   "num",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   "]",
   "lx",
   "=",
   "len",
   "(",
   "datareal",
   "[",
   "0",
   "]",
   ")",
   "# Work out matrix dimensions",
   "ly",
   "=",
   "len",
   "(",
   "datareal",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "xpos",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "lx",
   ",",
   "1",
   ")",
   "# Set up a mesh of positions",
   "ypos",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "ly",
   ",",
   "1",
   ")",
   "xpos",
   ",",
   "ypos",
   "=",
   "np",
   ".",
   "meshgrid",
   "(",
   "xpos",
   "+",
   "0.25",
   ",",
   "ypos",
   "+",
   "0.25",
   ")",
   "xpos",
   "=",
   "xpos",
   ".",
   "flatten",
   "(",
   ")",
   "ypos",
   "=",
   "ypos",
   ".",
   "flatten",
   "(",
   ")",
   "zpos",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "lx",
   "*",
   "ly",
   ")",
   "dx",
   "=",
   "0.5",
   "*",
   "np",
   ".",
   "ones_like",
   "(",
   "zpos",
   ")",
   "# width of bars",
   "dy",
   "=",
   "dx",
   ".",
   "copy",
   "(",
   ")",
   "dzr",
   "=",
   "datareal",
   ".",
   "flatten",
   "(",
   ")",
   "dzi",
   "=",
   "dataimag",
   ".",
   "flatten",
   "(",
   ")",
   "if",
   "color",
   "is",
   "None",
   ":",
   "color",
   "=",
   "[",
   "\"#648fff\"",
   ",",
   "\"#648fff\"",
   "]",
   "else",
   ":",
   "if",
   "len",
   "(",
   "color",
   ")",
   "!=",
   "2",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"'color' must be a list of len=2.\"",
   ")",
   "if",
   "color",
   "[",
   "0",
   "]",
   "is",
   "None",
   ":",
   "color",
   "[",
   "0",
   "]",
   "=",
   "\"#648fff\"",
   "if",
   "color",
   "[",
   "1",
   "]",
   "is",
   "None",
   ":",
   "color",
   "[",
   "1",
   "]",
   "=",
   "\"#648fff\"",
   "# set default figure size",
   "if",
   "figsize",
   "is",
   "None",
   ":",
   "figsize",
   "=",
   "(",
   "15",
   ",",
   "5",
   ")",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "figsize",
   ")",
   "ax1",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "1",
   ",",
   "2",
   ",",
   "1",
   ",",
   "projection",
   "=",
   "'3d'",
   ")",
   "x",
   "=",
   "[",
   "0",
   ",",
   "<mask>",
   "(",
   "xpos",
   ")",
   "+",
   "0.5",
   ",",
   "max",
   "(",
   "xpos",
   ")",
   "+",
   "0.5",
   ",",
   "0",
   "]",
   "y",
   "=",
   "[",
   "0",
   ",",
   "0",
   ",",
   "max",
   "(",
   "ypos",
   ")",
   "+",
   "0.5",
   ",",
   "max",
   "(",
   "ypos",
   ")",
   "+",
   "0.5",
   "]",
   "z",
   "=",
   "[",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0",
   "]",
   "verts",
   "=",
   "[",
   "list",
   "(",
   "zip",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ")",
   ")",
   "]",
   "fc1",
   "=",
   "generate_facecolors",
   "(",
   "xpos",
   ",",
   "ypos",
   ",",
   "zpos",
   ",",
   "dx",
   ",",
   "dy",
   ",",
   "dzr",
   ",",
   "color",
   "[",
   "0",
   "]",
   ")",
   "for",
   "idx",
   ",",
   "cur_zpos",
   "in",
   "enumerate",
   "(",
   "zpos",
   ")",
   ":",
   "if",
   "dzr",
   "[",
   "idx",
   "]",
   ">",
   "0",
   ":",
   "zorder",
   "=",
   "2",
   "else",
   ":",
   "zorder",
   "=",
   "0",
   "b1",
   "=",
   "ax1",
   ".",
   "bar3d",
   "(",
   "xpos",
   "[",
   "idx",
   "]",
   ",",
   "ypos",
   "[",
   "idx",
   "]",
   ",",
   "cur_zpos",
   ",",
   "dx",
   "[",
   "idx",
   "]",
   ",",
   "dy",
   "[",
   "idx",
   "]",
   ",",
   "dzr",
   "[",
   "idx",
   "]",
   ",",
   "alpha",
   "=",
   "alpha",
   ",",
   "zorder",
   "=",
   "zorder",
   ")",
   "b1",
   ".",
   "set_facecolors",
   "(",
   "fc1",
   "[",
   "6",
   "*",
   "idx",
   ":",
   "6",
   "*",
   "idx",
   "+",
   "6",
   "]",
   ")",
   "pc1",
   "=",
   "Poly3DCollection",
   "(",
   "verts",
   ",",
   "alpha",
   "=",
   "0.15",
   ",",
   "facecolor",
   "=",
   "'k'",
   ",",
   "linewidths",
   "=",
   "1",
   ",",
   "zorder",
   "=",
   "1",
   ")",
   "if",
   "min",
   "(",
   "dzr",
   ")",
   "<",
   "0",
   "<",
   "max",
   "(",
   "dzr",
   ")",
   ":",
   "ax1",
   ".",
   "add_collection3d",
   "(",
   "pc1",
   ")",
   "ax2",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "1",
   ",",
   "2",
   ",",
   "2",
   ",",
   "projection",
   "=",
   "'3d'",
   ")",
   "fc2",
   "=",
   "generate_facecolors",
   "(",
   "xpos",
   ",",
   "ypos",
   ",",
   "zpos",
   ",",
   "dx",
   ",",
   "dy",
   ",",
   "dzi",
   ",",
   "color",
   "[",
   "1",
   "]",
   ")",
   "for",
   "idx",
   ",",
   "cur_zpos",
   "in",
   "enumerate",
   "(",
   "zpos",
   ")",
   ":",
   "if",
   "dzi",
   "[",
   "idx",
   "]",
   ">",
   "0",
   ":",
   "zorder",
   "=",
   "2",
   "else",
   ":",
   "zorder",
   "=",
   "0",
   "b2",
   "=",
   "ax2",
   ".",
   "bar3d",
   "(",
   "xpos",
   "[",
   "idx",
   "]",
   ",",
   "ypos",
   "[",
   "idx",
   "]",
   ",",
   "cur_zpos",
   ",",
   "dx",
   "[",
   "idx",
   "]",
   ",",
   "dy",
   "[",
   "idx",
   "]",
   ",",
   "dzi",
   "[",
   "idx",
   "]",
   ",",
   "alpha",
   "=",
   "alpha",
   ",",
   "zorder",
   "=",
   "zorder",
   ")",
   "b2",
   ".",
   "set_facecolors",
   "(",
   "fc2",
   "[",
   "6",
   "*",
   "idx",
   ":",
   "6",
   "*",
   "idx",
   "+",
   "6",
   "]",
   ")",
   "pc2",
   "=",
   "Poly3DCollection",
   "(",
   "verts",
   ",",
   "alpha",
   "=",
   "0.2",
   ",",
   "facecolor",
   "=",
   "'k'",
   ",",
   "linewidths",
   "=",
   "1",
   ",",
   "zorder",
   "=",
   "1",
   ")",
   "if",
   "min",
   "(",
   "dzi",
   ")",
   "<",
   "0",
   "<",
   "max",
   "(",
   "dzi",
   ")",
   ":",
   "ax2",
   ".",
   "add_collection3d",
   "(",
   "pc2",
   ")",
   "ax1",
   ".",
   "set_xticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0.5",
   ",",
   "lx",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "ax1",
   ".",
   "set_yticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0.5",
   ",",
   "ly",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "max_dzr",
   "=",
   "max",
   "(",
   "dzr",
   ")",
   "min_dzr",
   "=",
   "min",
   "(",
   "dzr",
   ")",
   "if",
   "max_dzr",
   "!=",
   "min_dzr",
   ":",
   "ax1",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "np",
   ".",
   "min",
   "(",
   "dzr",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "dzr",
   ")",
   "+",
   "1e-9",
   ")",
   "else",
   ":",
   "if",
   "min_dzr",
   "==",
   "0",
   ":",
   "ax1",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "np",
   ".",
   "min",
   "(",
   "dzr",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "dzr",
   ")",
   "+",
   "1e-9",
   ")",
   "else",
   ":",
   "ax1",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "auto",
   "=",
   "True",
   ")",
   "ax1",
   ".",
   "zaxis",
   ".",
   "set_major_locator",
   "(",
   "MaxNLocator",
   "(",
   "5",
   ")",
   ")",
   "ax1",
   ".",
   "w_xaxis",
   ".",
   "set_ticklabels",
   "(",
   "row_names",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "45",
   ")",
   "ax1",
   ".",
   "w_yaxis",
   ".",
   "set_ticklabels",
   "(",
   "column_names",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "-",
   "22.5",
   ")",
   "ax1",
   ".",
   "set_zlabel",
   "(",
   "\"Real[rho]\"",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "for",
   "tick",
   "in",
   "ax1",
   ".",
   "zaxis",
   ".",
   "get_major_ticks",
   "(",
   ")",
   ":",
   "tick",
   ".",
   "label",
   ".",
   "set_fontsize",
   "(",
   "14",
   ")",
   "ax2",
   ".",
   "set_xticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0.5",
   ",",
   "lx",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "ax2",
   ".",
   "set_yticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0.5",
   ",",
   "ly",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "min_dzi",
   "=",
   "np",
   ".",
   "min",
   "(",
   "dzi",
   ")",
   "max_dzi",
   "=",
   "np",
   ".",
   "max",
   "(",
   "dzi",
   ")",
   "if",
   "min_dzi",
   "!=",
   "max_dzi",
   ":",
   "eps",
   "=",
   "0",
   "ax2",
   ".",
   "zaxis",
   ".",
   "set_major_locator",
   "(",
   "MaxNLocator",
   "(",
   "5",
   ")",
   ")",
   "ax2",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "np",
   ".",
   "min",
   "(",
   "dzi",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "dzi",
   ")",
   "+",
   "eps",
   ")",
   "else",
   ":",
   "if",
   "min_dzi",
   "==",
   "0",
   ":",
   "ax2",
   ".",
   "set_zticks",
   "(",
   "[",
   "0",
   "]",
   ")",
   "eps",
   "=",
   "1e-9",
   "ax2",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "np",
   ".",
   "min",
   "(",
   "dzi",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "dzi",
   ")",
   "+",
   "eps",
   ")",
   "else",
   ":",
   "ax2",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "auto",
   "=",
   "True",
   ")",
   "ax2",
   ".",
   "w_xaxis",
   ".",
   "set_ticklabels",
   "(",
   "row_names",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "45",
   ")",
   "ax2",
   ".",
   "w_yaxis",
   ".",
   "set_ticklabels",
   "(",
   "column_names",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "-",
   "22.5",
   ")",
   "ax2",
   ".",
   "set_zlabel",
   "(",
   "\"Imag[rho]\"",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "for",
   "tick",
   "in",
   "ax2",
   ".",
   "zaxis",
   ".",
   "get_major_ticks",
   "(",
   ")",
   ":",
   "tick",
   ".",
   "label",
   ".",
   "set_fontsize",
   "(",
   "14",
   ")",
   "plt",
   ".",
   "suptitle",
   "(",
   "title",
   ",",
   "fontsize",
   "=",
   "16",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "fig",
   ")",
   "return",
   "fig"
  ]
 },
 {
  "idx": "maxmin-817",
  "nl_tokens": [
   "Calculate",
   "the",
   "maximum",
   "proper",
   "motion",
   "errors",
   "from",
   "G",
   "and",
   "(",
   "V",
   "-",
   "I",
   ")",
   ".",
   "These",
   "correspond",
   "to",
   "the",
   "sky",
   "regions",
   "with",
   "the",
   "largest",
   "astrometric",
   "errors",
   "."
  ],
  "pl_tokens": [
   "def",
   "properMotionMaxError",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "0.0",
   ")",
   ":",
   "factor",
   "=",
   "errorScalingMissionLength",
   "(",
   "extension",
   ",",
   "-",
   "1.5",
   ")",
   "parallaxError",
   "=",
   "parallaxErrorSkyAvg",
   "(",
   "G",
   ",",
   "vmini",
   ")",
   "*",
   "factor",
   "indices",
   "=",
   "(",
   "parallaxError",
   "<",
   "_parallaxErrorMaxBright",
   ")",
   "parallaxError",
   "[",
   "indices",
   "]",
   "=",
   "_parallaxErrorMaxBright",
   "return",
   "_astrometricErrorFactors",
   "[",
   "'muAlphaStar'",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "parallaxError",
   ",",
   "_astrometricErrorFactors",
   "[",
   "'muDelta'",
   "]",
   ".",
   "max",
   "(",
   ")",
   "*",
   "parallaxError"
  ]
 },
 {
  "idx": "maxmin-818",
  "nl_tokens": [
   "Return",
   "random",
   "value",
   "for",
   "DecimalField"
  ],
  "pl_tokens": [
   "def",
   "decimal_field_data",
   "(",
   "field",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "min_value",
   "=",
   "0",
   "max_value",
   "=",
   "10",
   "from",
   "django",
   ".",
   "core",
   ".",
   "validators",
   "import",
   "MinValueValidator",
   ",",
   "MaxValueValidator",
   "for",
   "elem",
   "in",
   "field",
   ".",
   "validators",
   ":",
   "if",
   "isinstance",
   "(",
   "elem",
   ",",
   "MinValueValidator",
   ")",
   ":",
   "min_value",
   "=",
   "elem",
   ".",
   "limit_value",
   "if",
   "isinstance",
   "(",
   "elem",
   ",",
   "MaxValueValidator",
   ")",
   ":",
   "max_value",
   "=",
   "elem",
   ".",
   "limit_value",
   "if",
   "(",
   "field",
   ".",
   "max_digits",
   "and",
   "field",
   ".",
   "decimal_places",
   ")",
   ":",
   "from",
   "decimal",
   "import",
   "Decimal",
   "max_value",
   "=",
   "<mask>",
   "(",
   "max_value",
   ",",
   "Decimal",
   "(",
   "'%s.%s'",
   "%",
   "(",
   "'9'",
   "*",
   "(",
   "field",
   ".",
   "max_digits",
   "-",
   "field",
   ".",
   "decimal_places",
   ")",
   ",",
   "'9'",
   "*",
   "field",
   ".",
   "decimal_places",
   ")",
   ")",
   ")",
   "min_value",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'min_value'",
   ")",
   "or",
   "min_value",
   "max_value",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'max_value'",
   ")",
   "or",
   "max_value",
   "return",
   "str",
   "(",
   "xunit",
   ".",
   "any_decimal",
   "(",
   "min_value",
   "=",
   "min_value",
   ",",
   "max_value",
   "=",
   "max_value",
   ",",
   "decimal_places",
   "=",
   "field",
   ".",
   "decimal_places",
   "or",
   "2",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-819",
  "nl_tokens": [
   "Insert",
   "size",
   "bytes",
   "of",
   "empty",
   "space",
   "starting",
   "at",
   "offset",
   "."
  ],
  "pl_tokens": [
   "def",
   "insert_bytes",
   "(",
   "fobj",
   ",",
   "size",
   ",",
   "offset",
   ",",
   "BUFFER_SIZE",
   "=",
   "2",
   "**",
   "16",
   ")",
   ":",
   "assert",
   "0",
   "<",
   "size",
   "assert",
   "0",
   "<=",
   "offset",
   "locked",
   "=",
   "False",
   "fobj",
   ".",
   "seek",
   "(",
   "0",
   ",",
   "2",
   ")",
   "filesize",
   "=",
   "fobj",
   ".",
   "tell",
   "(",
   ")",
   "movesize",
   "=",
   "filesize",
   "-",
   "offset",
   "fobj",
   ".",
   "write",
   "(",
   "b'\\x00'",
   "*",
   "size",
   ")",
   "fobj",
   ".",
   "flush",
   "(",
   ")",
   "try",
   ":",
   "try",
   ":",
   "import",
   "mmap",
   "file_map",
   "=",
   "mmap",
   ".",
   "mmap",
   "(",
   "fobj",
   ".",
   "fileno",
   "(",
   ")",
   ",",
   "filesize",
   "+",
   "size",
   ")",
   "try",
   ":",
   "file_map",
   ".",
   "move",
   "(",
   "offset",
   "+",
   "size",
   ",",
   "offset",
   ",",
   "movesize",
   ")",
   "finally",
   ":",
   "file_map",
   ".",
   "close",
   "(",
   ")",
   "except",
   "(",
   "ValueError",
   ",",
   "EnvironmentError",
   ",",
   "ImportError",
   ")",
   ":",
   "# handle broken mmap scenarios",
   "locked",
   "=",
   "lock",
   "(",
   "fobj",
   ")",
   "fobj",
   ".",
   "truncate",
   "(",
   "filesize",
   ")",
   "fobj",
   ".",
   "seek",
   "(",
   "0",
   ",",
   "2",
   ")",
   "padsize",
   "=",
   "size",
   "# Don't generate an enormous string if we need to pad",
   "# the file out several megs.",
   "while",
   "padsize",
   ":",
   "addsize",
   "=",
   "<mask>",
   "(",
   "BUFFER_SIZE",
   ",",
   "padsize",
   ")",
   "fobj",
   ".",
   "write",
   "(",
   "b\"\\x00\"",
   "*",
   "addsize",
   ")",
   "padsize",
   "-=",
   "addsize",
   "fobj",
   ".",
   "seek",
   "(",
   "filesize",
   ",",
   "0",
   ")",
   "while",
   "movesize",
   ":",
   "# At the start of this loop, fobj is pointing at the end",
   "# of the data we need to move, which is of movesize length.",
   "thismove",
   "=",
   "min",
   "(",
   "BUFFER_SIZE",
   ",",
   "movesize",
   ")",
   "# Seek back however much we're going to read this frame.",
   "fobj",
   ".",
   "seek",
   "(",
   "-",
   "thismove",
   ",",
   "1",
   ")",
   "nextpos",
   "=",
   "fobj",
   ".",
   "tell",
   "(",
   ")",
   "# Read it, so we're back at the end.",
   "data",
   "=",
   "fobj",
   ".",
   "read",
   "(",
   "thismove",
   ")",
   "# Seek back to where we need to write it.",
   "fobj",
   ".",
   "seek",
   "(",
   "-",
   "thismove",
   "+",
   "size",
   ",",
   "1",
   ")",
   "# Write it.",
   "fobj",
   ".",
   "write",
   "(",
   "data",
   ")",
   "# And seek back to the end of the unmoved data.",
   "fobj",
   ".",
   "seek",
   "(",
   "nextpos",
   ")",
   "movesize",
   "-=",
   "thismove",
   "fobj",
   ".",
   "flush",
   "(",
   ")",
   "finally",
   ":",
   "if",
   "locked",
   ":",
   "unlock",
   "(",
   "fobj",
   ")"
  ]
 },
 {
  "idx": "maxmin-820",
  "nl_tokens": [
   "Returns",
   "the",
   "*",
   "argument",
   "*",
   "of",
   "the",
   "max",
   "of",
   "the",
   "likelihood",
   "of",
   "the",
   "data",
   "given",
   "an",
   "input",
   "xmin"
  ],
  "pl_tokens": [
   "def",
   "discrete_max_likelihood",
   "(",
   "data",
   ",",
   "xmin",
   ",",
   "alpharange",
   "=",
   "(",
   "1.5",
   ",",
   "3.5",
   ")",
   ",",
   "n_alpha",
   "=",
   "201",
   ")",
   ":",
   "likelihoods",
   "=",
   "discrete_likelihood_vector",
   "(",
   "data",
   ",",
   "xmin",
   ",",
   "alpharange",
   "=",
   "alpharange",
   ",",
   "n_alpha",
   "=",
   "n_alpha",
   ")",
   "Lmax",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "likelihoods",
   ")",
   "return",
   "Lmax"
  ]
 },
 {
  "idx": "maxmin-821",
  "nl_tokens": [
   "Get",
   "the",
   "ID",
   "corresponding",
   "to",
   "the",
   "offset",
   "which",
   "occurs",
   "first",
   "after",
   "the",
   "given",
   "onset_front_id",
   ".",
   "By",
   "first",
   "I",
   "mean",
   "the",
   "front",
   "which",
   "contains",
   "the",
   "offset",
   "which",
   "is",
   "closest",
   "to",
   "the",
   "latest",
   "point",
   "in",
   "the",
   "onset",
   "front",
   ".",
   "By",
   "after",
   "I",
   "mean",
   "that",
   "the",
   "offset",
   "must",
   "contain",
   "only",
   "offsets",
   "which",
   "occur",
   "after",
   "the",
   "latest",
   "onset",
   "in",
   "the",
   "onset",
   "front",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_offset_front_id_after_onset_front",
   "(",
   "onset_front_id",
   ",",
   "onset_fronts",
   ",",
   "offset_fronts",
   ")",
   ":",
   "# get the onset idxs for this front",
   "onset_idxs",
   "=",
   "_get_front_idxs_from_id",
   "(",
   "onset_fronts",
   ",",
   "onset_front_id",
   ")",
   "# get the sample idxs for this front",
   "onset_sample_idxs",
   "=",
   "[",
   "s",
   "for",
   "_f",
   ",",
   "s",
   "in",
   "onset_idxs",
   "]",
   "# get the latest onset in this onset front",
   "latest_onset_in_front",
   "=",
   "<mask>",
   "(",
   "onset_sample_idxs",
   ")",
   "offset_front_id_after_this_onset_front",
   "=",
   "_get_offset_front_id_after_onset_sample_idx",
   "(",
   "latest_onset_in_front",
   ",",
   "offset_fronts",
   ")",
   "return",
   "int",
   "(",
   "offset_front_id_after_this_onset_front",
   ")"
  ]
 },
 {
  "idx": "maxmin-822",
  "nl_tokens": [
   "Computes",
   "BLEU",
   "score",
   "of",
   "translated",
   "segments",
   "against",
   "one",
   "or",
   "more",
   "references",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_bleu",
   "(",
   "reference_corpus",
   ",",
   "translation_corpus",
   ",",
   "max_order",
   "=",
   "4",
   ",",
   "smooth",
   "=",
   "False",
   ")",
   ":",
   "matches_by_order",
   "=",
   "[",
   "0",
   "]",
   "*",
   "max_order",
   "possible_matches_by_order",
   "=",
   "[",
   "0",
   "]",
   "*",
   "max_order",
   "reference_length",
   "=",
   "0",
   "translation_length",
   "=",
   "0",
   "for",
   "(",
   "references",
   ",",
   "translation",
   ")",
   "in",
   "zip",
   "(",
   "reference_corpus",
   ",",
   "translation_corpus",
   ")",
   ":",
   "reference_length",
   "+=",
   "<mask>",
   "(",
   "len",
   "(",
   "r",
   ")",
   "for",
   "r",
   "in",
   "references",
   ")",
   "translation_length",
   "+=",
   "len",
   "(",
   "translation",
   ")",
   "merged_ref_ngram_counts",
   "=",
   "collections",
   ".",
   "Counter",
   "(",
   ")",
   "for",
   "reference",
   "in",
   "references",
   ":",
   "merged_ref_ngram_counts",
   "|=",
   "_get_ngrams",
   "(",
   "reference",
   ",",
   "max_order",
   ")",
   "translation_ngram_counts",
   "=",
   "_get_ngrams",
   "(",
   "translation",
   ",",
   "max_order",
   ")",
   "overlap",
   "=",
   "translation_ngram_counts",
   "&",
   "merged_ref_ngram_counts",
   "for",
   "ngram",
   "in",
   "overlap",
   ":",
   "matches_by_order",
   "[",
   "len",
   "(",
   "ngram",
   ")",
   "-",
   "1",
   "]",
   "+=",
   "overlap",
   "[",
   "ngram",
   "]",
   "for",
   "order",
   "in",
   "range",
   "(",
   "1",
   ",",
   "max_order",
   "+",
   "1",
   ")",
   ":",
   "possible_matches",
   "=",
   "len",
   "(",
   "translation",
   ")",
   "-",
   "order",
   "+",
   "1",
   "if",
   "possible_matches",
   ">",
   "0",
   ":",
   "possible_matches_by_order",
   "[",
   "order",
   "-",
   "1",
   "]",
   "+=",
   "possible_matches",
   "precisions",
   "=",
   "[",
   "0",
   "]",
   "*",
   "max_order",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "max_order",
   ")",
   ":",
   "if",
   "smooth",
   ":",
   "precisions",
   "[",
   "i",
   "]",
   "=",
   "(",
   "(",
   "matches_by_order",
   "[",
   "i",
   "]",
   "+",
   "1.",
   ")",
   "/",
   "(",
   "possible_matches_by_order",
   "[",
   "i",
   "]",
   "+",
   "1.",
   ")",
   ")",
   "else",
   ":",
   "if",
   "possible_matches_by_order",
   "[",
   "i",
   "]",
   ">",
   "0",
   ":",
   "precisions",
   "[",
   "i",
   "]",
   "=",
   "(",
   "float",
   "(",
   "matches_by_order",
   "[",
   "i",
   "]",
   ")",
   "/",
   "possible_matches_by_order",
   "[",
   "i",
   "]",
   ")",
   "else",
   ":",
   "precisions",
   "[",
   "i",
   "]",
   "=",
   "0.0",
   "if",
   "min",
   "(",
   "precisions",
   ")",
   ">",
   "0",
   ":",
   "p_log_sum",
   "=",
   "sum",
   "(",
   "(",
   "1.",
   "/",
   "max_order",
   ")",
   "*",
   "math",
   ".",
   "log",
   "(",
   "p",
   ")",
   "for",
   "p",
   "in",
   "precisions",
   ")",
   "geo_mean",
   "=",
   "math",
   ".",
   "exp",
   "(",
   "p_log_sum",
   ")",
   "else",
   ":",
   "geo_mean",
   "=",
   "0",
   "ratio",
   "=",
   "float",
   "(",
   "translation_length",
   ")",
   "/",
   "reference_length",
   "if",
   "ratio",
   ">",
   "1.0",
   ":",
   "bp",
   "=",
   "1.",
   "else",
   ":",
   "bp",
   "=",
   "math",
   ".",
   "exp",
   "(",
   "1",
   "-",
   "1.",
   "/",
   "ratio",
   ")",
   "bleu",
   "=",
   "geo_mean",
   "*",
   "bp",
   "return",
   "(",
   "bleu",
   ",",
   "precisions",
   ",",
   "bp",
   ",",
   "ratio",
   ",",
   "translation_length",
   ",",
   "reference_length",
   ")"
  ]
 },
 {
  "idx": "maxmin-823",
  "nl_tokens": [
   "computes",
   "the",
   "ideal",
   "conversion",
   "ratio",
   "for",
   "the",
   "given",
   "alphabet",
   ".",
   "A",
   "ratio",
   "is",
   "considered",
   "ideal",
   "when",
   "the",
   "number",
   "of",
   "bits",
   "in",
   "one",
   "output",
   "encoding",
   "chunk",
   "that",
   "don",
   "t",
   "add",
   "up",
   "to",
   "one",
   "input",
   "encoding",
   "chunk",
   "is",
   "minimal",
   "."
  ],
  "pl_tokens": [
   "def",
   "calc_chunklen",
   "(",
   "alph_len",
   ")",
   ":",
   "binlen",
   ",",
   "enclen",
   "=",
   "<mask>",
   "(",
   "[",
   "(",
   "i",
   ",",
   "i",
   "*",
   "8",
   "/",
   "math",
   ".",
   "log",
   "(",
   "alph_len",
   ",",
   "2",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "7",
   ")",
   "]",
   ",",
   "key",
   "=",
   "lambda",
   "k",
   ":",
   "k",
   "[",
   "1",
   "]",
   "%",
   "1",
   ")",
   "return",
   "binlen",
   ",",
   "int",
   "(",
   "enclen",
   ")"
  ]
 },
 {
  "idx": "maxmin-824",
  "nl_tokens": [
   "meaning",
   "pvalues",
   "presorted",
   "i",
   "descending",
   "order"
  ],
  "pl_tokens": [
   "def",
   "calc",
   "(",
   "pvalues",
   ",",
   "lamb",
   ")",
   ":",
   "m",
   "=",
   "len",
   "(",
   "pvalues",
   ")",
   "pi0",
   "=",
   "(",
   "pvalues",
   ">",
   "lamb",
   ")",
   ".",
   "sum",
   "(",
   ")",
   "/",
   "(",
   "(",
   "1",
   "-",
   "lamb",
   ")",
   "*",
   "m",
   ")",
   "pFDR",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "m",
   ")",
   "print",
   "(",
   "\"pFDR    y        Pr     fastPow\"",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "m",
   ")",
   ":",
   "y",
   "=",
   "pvalues",
   "[",
   "i",
   "]",
   "Pr",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "m",
   "-",
   "i",
   ")",
   "/",
   "float",
   "(",
   "m",
   ")",
   "pFDR",
   "[",
   "i",
   "]",
   "=",
   "(",
   "pi0",
   "*",
   "y",
   ")",
   "/",
   "(",
   "Pr",
   "*",
   "(",
   "1",
   "-",
   "math",
   ".",
   "pow",
   "(",
   "1",
   "-",
   "y",
   ",",
   "m",
   ")",
   ")",
   ")",
   "print",
   "(",
   "i",
   ",",
   "pFDR",
   "[",
   "i",
   "]",
   ",",
   "y",
   ",",
   "Pr",
   ",",
   "1.0",
   "-",
   "math",
   ".",
   "pow",
   "(",
   "1",
   "-",
   "y",
   ",",
   "m",
   ")",
   ")",
   "num_null",
   "=",
   "pi0",
   "*",
   "m",
   "num_alt",
   "=",
   "m",
   "-",
   "num_null",
   "num_negs",
   "=",
   "np",
   ".",
   "array",
   "(",
   "range",
   "(",
   "m",
   ")",
   ")",
   "num_pos",
   "=",
   "m",
   "-",
   "num_negs",
   "pp",
   "=",
   "num_pos",
   "/",
   "float",
   "(",
   "m",
   ")",
   "qvalues",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "m",
   ")",
   "qvalues",
   "[",
   "0",
   "]",
   "=",
   "pFDR",
   "[",
   "0",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "m",
   "-",
   "1",
   ")",
   ":",
   "qvalues",
   "[",
   "i",
   "+",
   "1",
   "]",
   "=",
   "min",
   "(",
   "qvalues",
   "[",
   "i",
   "]",
   ",",
   "pFDR",
   "[",
   "i",
   "+",
   "1",
   "]",
   ")",
   "sens",
   "=",
   "(",
   "(",
   "1.0",
   "-",
   "qvalues",
   ")",
   "*",
   "num_pos",
   ")",
   "/",
   "num_alt",
   "sens",
   "[",
   "sens",
   ">",
   "1.0",
   "]",
   "=",
   "1.0",
   "df",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "dict",
   "(",
   "pvalue",
   "=",
   "pvalues",
   ",",
   "qvalue",
   "=",
   "qvalues",
   ",",
   "FDR",
   "=",
   "pFDR",
   ",",
   "percentile_positive",
   "=",
   "pp",
   ",",
   "sens",
   "=",
   "sens",
   ")",
   ")",
   "df",
   "[",
   "\"svalue\"",
   "]",
   "=",
   "df",
   ".",
   "sens",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ".",
   "cummax",
   "(",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "return",
   "df",
   ",",
   "num_null",
   ",",
   "m"
  ]
 },
 {
  "idx": "maxmin-825",
  "nl_tokens": [
   "Compute",
   "edge",
   "ngram",
   "of",
   "token",
   "from",
   "min",
   ".",
   "Does",
   "not",
   "include",
   "token",
   "itself",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_edge_ngrams",
   "(",
   "token",
   ",",
   "<mask>",
   "=",
   "None",
   ")",
   ":",
   "if",
   "min",
   "is",
   "None",
   ":",
   "min",
   "=",
   "config",
   ".",
   "MIN_EDGE_NGRAMS",
   "token",
   "=",
   "token",
   "[",
   ":",
   "config",
   ".",
   "MAX_EDGE_NGRAMS",
   "+",
   "1",
   "]",
   "return",
   "[",
   "token",
   "[",
   ":",
   "i",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "min",
   ",",
   "len",
   "(",
   "token",
   ")",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-826",
  "nl_tokens": [
   "Computes",
   "the",
   "average",
   "precision",
   "at",
   "k",
   "."
  ],
  "pl_tokens": [
   "def",
   "apk",
   "(",
   "actual",
   ",",
   "predicted",
   ",",
   "k",
   "=",
   "10",
   ")",
   ":",
   "if",
   "len",
   "(",
   "predicted",
   ")",
   ">",
   "k",
   ":",
   "predicted",
   "=",
   "predicted",
   "[",
   ":",
   "k",
   "]",
   "score",
   "=",
   "0.0",
   "num_hits",
   "=",
   "0.0",
   "for",
   "i",
   ",",
   "p",
   "in",
   "enumerate",
   "(",
   "predicted",
   ")",
   ":",
   "if",
   "p",
   "in",
   "actual",
   "and",
   "p",
   "not",
   "in",
   "predicted",
   "[",
   ":",
   "i",
   "]",
   ":",
   "num_hits",
   "+=",
   "1.0",
   "score",
   "+=",
   "num_hits",
   "/",
   "(",
   "i",
   "+",
   "1.0",
   ")",
   "if",
   "len",
   "(",
   "actual",
   ")",
   "==",
   "0",
   ":",
   "return",
   "0.0",
   "return",
   "score",
   "/",
   "<mask>",
   "(",
   "len",
   "(",
   "actual",
   ")",
   ",",
   "k",
   ")"
  ]
 },
 {
  "idx": "maxmin-827",
  "nl_tokens": [
   "Returns",
   "the",
   "datetime",
   "of",
   "the",
   "form",
   "start_date",
   "+",
   "i",
   "*",
   "delta",
   "which",
   "is",
   "closest",
   "to",
   "dt",
   "for",
   "any",
   "non",
   "-",
   "negative",
   "integer",
   "i",
   ".",
   "Note",
   "that",
   "delta",
   "may",
   "be",
   "a",
   "datetime",
   ".",
   "timedelta",
   "or",
   "a",
   "dateutil",
   ".",
   "relativedelta",
   ">>>",
   "round_time",
   "(",
   "datetime",
   "(",
   "2015",
   "1",
   "1",
   "6",
   ")",
   "timedelta",
   "(",
   "days",
   "=",
   "1",
   "))",
   "datetime",
   ".",
   "datetime",
   "(",
   "2015",
   "1",
   "1",
   "0",
   "0",
   ")",
   ">>>",
   "round_time",
   "(",
   "datetime",
   "(",
   "2015",
   "1",
   "2",
   ")",
   "relativedelta",
   "(",
   "months",
   "=",
   "1",
   "))",
   "datetime",
   ".",
   "datetime",
   "(",
   "2015",
   "1",
   "1",
   "0",
   "0",
   ")",
   ">>>",
   "round_time",
   "(",
   "datetime",
   "(",
   "2015",
   "9",
   "16",
   "0",
   "0",
   ")",
   "timedelta",
   "(",
   "1",
   ")",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   "))",
   "datetime",
   ".",
   "datetime",
   "(",
   "2015",
   "9",
   "16",
   "0",
   "0",
   ")",
   ">>>",
   "round_time",
   "(",
   "datetime",
   "(",
   "2015",
   "9",
   "15",
   "0",
   "0",
   ")",
   "timedelta",
   "(",
   "1",
   ")",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   "))",
   "datetime",
   ".",
   "datetime",
   "(",
   "2015",
   "9",
   "15",
   "0",
   "0",
   ")",
   ">>>",
   "round_time",
   "(",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   ")",
   "timedelta",
   "(",
   "1",
   ")",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   "))",
   "datetime",
   ".",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   ")",
   ">>>",
   "round_time",
   "(",
   "datetime",
   "(",
   "2015",
   "9",
   "13",
   "0",
   "0",
   ")",
   "timedelta",
   "(",
   "1",
   ")",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   "))",
   "datetime",
   ".",
   "datetime",
   "(",
   "2015",
   "9",
   "14",
   "0",
   "0",
   ")"
  ],
  "pl_tokens": [
   "def",
   "round_time",
   "(",
   "dt",
   ",",
   "delta",
   ",",
   "start_date",
   "=",
   "timezone",
   ".",
   "make_aware",
   "(",
   "datetime",
   ".",
   "<mask>",
   ")",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "delta",
   ",",
   "six",
   ".",
   "string_types",
   ")",
   ":",
   "# It's cron based, so it's easy",
   "tz",
   "=",
   "start_date",
   ".",
   "tzinfo",
   "start_date",
   "=",
   "timezone",
   ".",
   "make_naive",
   "(",
   "start_date",
   ",",
   "tz",
   ")",
   "cron",
   "=",
   "croniter",
   "(",
   "delta",
   ",",
   "start_date",
   ")",
   "prev",
   "=",
   "cron",
   ".",
   "get_prev",
   "(",
   "datetime",
   ")",
   "if",
   "prev",
   "==",
   "start_date",
   ":",
   "return",
   "timezone",
   ".",
   "make_aware",
   "(",
   "start_date",
   ",",
   "tz",
   ")",
   "else",
   ":",
   "return",
   "timezone",
   ".",
   "make_aware",
   "(",
   "prev",
   ",",
   "tz",
   ")",
   "# Ignore the microseconds of dt",
   "dt",
   "-=",
   "timedelta",
   "(",
   "microseconds",
   "=",
   "dt",
   ".",
   "microsecond",
   ")",
   "# We are looking for a datetime in the form start_date + i * delta",
   "# which is as close as possible to dt. Since delta could be a relative",
   "# delta we don't know its exact length in seconds so we cannot rely on",
   "# division to find i. Instead we employ a binary search algorithm, first",
   "# finding an upper and lower limit and then disecting the interval until",
   "# we have found the closest match.",
   "# We first search an upper limit for i for which start_date + upper * delta",
   "# exceeds dt.",
   "upper",
   "=",
   "1",
   "while",
   "start_date",
   "+",
   "upper",
   "*",
   "delta",
   "<",
   "dt",
   ":",
   "# To speed up finding an upper limit we grow this exponentially by a",
   "# factor of 2",
   "upper",
   "*=",
   "2",
   "# Since upper is the first value for which start_date + upper * delta",
   "# exceeds dt, upper // 2 is below dt and therefore forms a lower limited",
   "# for the i we are looking for",
   "lower",
   "=",
   "upper",
   "//",
   "2",
   "# We now continue to intersect the interval between",
   "# start_date + lower * delta and start_date + upper * delta",
   "# until we find the closest value",
   "while",
   "True",
   ":",
   "# Invariant: start + lower * delta < dt <= start + upper * delta",
   "# If start_date + (lower + 1)*delta exceeds dt, then either lower or",
   "# lower+1 has to be the solution we are searching for",
   "if",
   "start_date",
   "+",
   "(",
   "lower",
   "+",
   "1",
   ")",
   "*",
   "delta",
   ">=",
   "dt",
   ":",
   "# Check if start_date + (lower + 1)*delta or",
   "# start_date + lower*delta is closer to dt and return the solution",
   "if",
   "(",
   "start_date",
   "+",
   "(",
   "lower",
   "+",
   "1",
   ")",
   "*",
   "delta",
   ")",
   "-",
   "dt",
   "<=",
   "dt",
   "-",
   "(",
   "start_date",
   "+",
   "lower",
   "*",
   "delta",
   ")",
   ":",
   "return",
   "start_date",
   "+",
   "(",
   "lower",
   "+",
   "1",
   ")",
   "*",
   "delta",
   "else",
   ":",
   "return",
   "start_date",
   "+",
   "lower",
   "*",
   "delta",
   "# We intersect the interval and either replace the lower or upper",
   "# limit with the candidate",
   "candidate",
   "=",
   "lower",
   "+",
   "(",
   "upper",
   "-",
   "lower",
   ")",
   "//",
   "2",
   "if",
   "start_date",
   "+",
   "candidate",
   "*",
   "delta",
   ">=",
   "dt",
   ":",
   "upper",
   "=",
   "candidate",
   "else",
   ":",
   "lower",
   "=",
   "candidate"
  ]
 },
 {
  "idx": "maxmin-828",
  "nl_tokens": [
   "Compute",
   "the",
   "number",
   "of",
   "early",
   "downsampling",
   "operations"
  ],
  "pl_tokens": [
   "def",
   "__early_downsample_count",
   "(",
   "nyquist",
   ",",
   "filter_cutoff",
   ",",
   "hop_length",
   ",",
   "n_octaves",
   ")",
   ":",
   "downsample_count1",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "log2",
   "(",
   "audio",
   ".",
   "BW_FASTEST",
   "*",
   "nyquist",
   "/",
   "filter_cutoff",
   ")",
   ")",
   "-",
   "1",
   ")",
   "-",
   "1",
   ")",
   "num_twos",
   "=",
   "__num_two_factors",
   "(",
   "hop_length",
   ")",
   "downsample_count2",
   "=",
   "max",
   "(",
   "0",
   ",",
   "num_twos",
   "-",
   "n_octaves",
   "+",
   "1",
   ")",
   "return",
   "min",
   "(",
   "downsample_count1",
   ",",
   "downsample_count2",
   ")"
  ]
 },
 {
  "idx": "maxmin-829",
  "nl_tokens": [
   "List",
   "team",
   "memberships",
   "for",
   "a",
   "team",
   "by",
   "ID",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "teamId",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "teamId",
   ",",
   "basestring",
   ",",
   "may_be_none",
   "=",
   "False",
   ")",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "teamId",
   "=",
   "teamId",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield team membership objects created from the returned items JSON",
   "# objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-830",
  "nl_tokens": [
   "Plots",
   "CDF",
   "and",
   "powerlaw"
  ],
  "pl_tokens": [
   "def",
   "plotcdf",
   "(",
   "self",
   ",",
   "x",
   "=",
   "None",
   ",",
   "xmin",
   "=",
   "None",
   ",",
   "alpha",
   "=",
   "None",
   ",",
   "pointcolor",
   "=",
   "'k'",
   ",",
   "dolog",
   "=",
   "True",
   ",",
   "zoom",
   "=",
   "True",
   ",",
   "pointmarker",
   "=",
   "'+'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "x",
   "is",
   "None",
   ":",
   "x",
   "=",
   "self",
   ".",
   "data",
   "if",
   "xmin",
   "is",
   "None",
   ":",
   "xmin",
   "=",
   "self",
   ".",
   "_xmin",
   "if",
   "alpha",
   "is",
   "None",
   ":",
   "alpha",
   "=",
   "self",
   ".",
   "_alpha",
   "x",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "x",
   ")",
   "n",
   "=",
   "len",
   "(",
   "x",
   ")",
   "xcdf",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "n",
   ",",
   "0",
   ",",
   "-",
   "1",
   ",",
   "dtype",
   "=",
   "'float'",
   ")",
   "/",
   "float",
   "(",
   "n",
   ")",
   "q",
   "=",
   "x",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "fcdf",
   "=",
   "(",
   "q",
   "/",
   "xmin",
   ")",
   "**",
   "(",
   "1",
   "-",
   "alpha",
   ")",
   "nc",
   "=",
   "xcdf",
   "[",
   "argmax",
   "(",
   "x",
   ">=",
   "xmin",
   ")",
   "]",
   "fcdf_norm",
   "=",
   "nc",
   "*",
   "fcdf",
   "D_location",
   "=",
   "argmax",
   "(",
   "xcdf",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "-",
   "fcdf_norm",
   ")",
   "pylab",
   ".",
   "vlines",
   "(",
   "q",
   "[",
   "D_location",
   "]",
   ",",
   "xcdf",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "[",
   "D_location",
   "]",
   ",",
   "fcdf_norm",
   "[",
   "D_location",
   "]",
   ",",
   "color",
   "=",
   "'m'",
   ",",
   "linewidth",
   "=",
   "2",
   ",",
   "zorder",
   "=",
   "2",
   ")",
   "pylab",
   ".",
   "plot",
   "(",
   "[",
   "q",
   "[",
   "D_location",
   "]",
   "]",
   "*",
   "2",
   ",",
   "[",
   "xcdf",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "[",
   "D_location",
   "]",
   ",",
   "fcdf_norm",
   "[",
   "D_location",
   "]",
   "]",
   ",",
   "color",
   "=",
   "'m'",
   ",",
   "marker",
   "=",
   "'s'",
   ",",
   "zorder",
   "=",
   "3",
   ")",
   "#plotx = pylab.linspace(q.min(),q.max(),1000)",
   "#ploty = (plotx/xmin)**(1-alpha) * nc",
   "if",
   "dolog",
   ":",
   "pylab",
   ".",
   "loglog",
   "(",
   "x",
   ",",
   "xcdf",
   ",",
   "marker",
   "=",
   "pointmarker",
   ",",
   "color",
   "=",
   "pointcolor",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "pylab",
   ".",
   "loglog",
   "(",
   "q",
   ",",
   "fcdf_norm",
   ",",
   "'r'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "else",
   ":",
   "pylab",
   ".",
   "semilogx",
   "(",
   "x",
   ",",
   "xcdf",
   ",",
   "marker",
   "=",
   "pointmarker",
   ",",
   "color",
   "=",
   "pointcolor",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "pylab",
   ".",
   "semilogx",
   "(",
   "q",
   ",",
   "fcdf_norm",
   ",",
   "'r'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "if",
   "zoom",
   ":",
   "pylab",
   ".",
   "axis",
   "(",
   "[",
   "xmin",
   ",",
   "x",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "xcdf",
   ".",
   "min",
   "(",
   ")",
   ",",
   "nc",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-831",
  "nl_tokens": [
   "Update",
   "the",
   "timer",
   "to",
   "reflect",
   "a",
   "successfull",
   "call"
  ],
  "pl_tokens": [
   "def",
   "success",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "interval",
   "==",
   "0.0",
   ":",
   "return",
   "self",
   ".",
   "short_interval",
   "-=",
   "self",
   ".",
   "short_unit",
   "self",
   ".",
   "long_interval",
   "-=",
   "self",
   ".",
   "long_unit",
   "self",
   ".",
   "short_interval",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "short_interval",
   ",",
   "Decimal",
   "(",
   "0",
   ")",
   ")",
   "self",
   ".",
   "long_interval",
   "=",
   "max",
   "(",
   "self",
   ".",
   "long_interval",
   ",",
   "Decimal",
   "(",
   "0",
   ")",
   ")",
   "self",
   ".",
   "update_interval",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-832",
  "nl_tokens": [
   "Returns",
   "a",
   "judgement",
   "on",
   "the",
   "overall",
   "frequency",
   "of",
   "the",
   "variant",
   "."
  ],
  "pl_tokens": [
   "def",
   "frequency",
   "(",
   "variant_obj",
   ")",
   ":",
   "most_common_frequency",
   "=",
   "<mask>",
   "(",
   "variant_obj",
   ".",
   "get",
   "(",
   "'thousand_genomes_frequency'",
   ")",
   "or",
   "0",
   ",",
   "variant_obj",
   ".",
   "get",
   "(",
   "'exac_frequency'",
   ")",
   "or",
   "0",
   ")",
   "if",
   "most_common_frequency",
   ">",
   ".05",
   ":",
   "return",
   "'common'",
   "elif",
   "most_common_frequency",
   ">",
   ".01",
   ":",
   "return",
   "'uncommon'",
   "else",
   ":",
   "return",
   "'rare'"
  ]
 },
 {
  "idx": "maxmin-833",
  "nl_tokens": [
   "Processes",
   "a",
   "scheduled",
   "consumption",
   "request",
   "that",
   "has",
   "completed"
  ],
  "pl_tokens": [
   "def",
   "process_scheduled_consumption",
   "(",
   "self",
   ",",
   "token",
   ")",
   ":",
   "scheduled_retry",
   "=",
   "self",
   ".",
   "_tokens_to_scheduled_consumption",
   ".",
   "pop",
   "(",
   "token",
   ")",
   "self",
   ".",
   "_total_wait",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_total_wait",
   "-",
   "scheduled_retry",
   "[",
   "'time_to_consume'",
   "]",
   ",",
   "0",
   ")"
  ]
 },
 {
  "idx": "maxmin-834",
  "nl_tokens": [
   "Returns",
   "the",
   "jQuery",
   "DataTables",
   "CSS",
   "file",
   "according",
   "to",
   "version",
   "number",
   "."
  ],
  "pl_tokens": [
   "def",
   "djfrontend_jquery_datatables_css",
   "(",
   "version",
   "=",
   "None",
   ")",
   ":",
   "if",
   "version",
   "is",
   "None",
   ":",
   "if",
   "not",
   "getattr",
   "(",
   "settings",
   ",",
   "'DJFRONTEND_JQUERY_DATATABLES_CSS'",
   ",",
   "False",
   ")",
   ":",
   "version",
   "=",
   "getattr",
   "(",
   "settings",
   ",",
   "'DJFRONTEND_JQUERY_DATATABLES_VERSION'",
   ",",
   "DJFRONTEND_JQUERY_DATATABLES_VERSION_DEFAULT",
   ")",
   "else",
   ":",
   "version",
   "=",
   "getattr",
   "(",
   "settings",
   ",",
   "'DJFRONTEND_JQUERY_DATATABLES_CSS'",
   ",",
   "DJFRONTEND_JQUERY_DATATABLES_VERSION_DEFAULT",
   ")",
   "return",
   "format_html",
   "(",
   "'<link rel=\"stylesheet\" href=\"{static}djfrontend/css/jquery/jquery.dataTables/{v}/jquery.dataTables{min}.css\">'",
   ",",
   "static",
   "=",
   "_static_url",
   ",",
   "v",
   "=",
   "version",
   ",",
   "<mask>",
   "=",
   "_min",
   ")"
  ]
 },
 {
  "idx": "maxmin-835",
  "nl_tokens": [
   "Extract",
   "(",
   "float",
   ")",
   "value",
   "of",
   "dependent",
   "tag",
   "or",
   "None",
   "if",
   "absent",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_dependent_value",
   "(",
   "tag_values",
   ",",
   "dependent_tag_id",
   ")",
   ":",
   "try",
   ":",
   "values",
   "=",
   "tag_values",
   "[",
   "dependent_tag_id",
   "]",
   ".",
   "split",
   "(",
   "\",\"",
   ")",
   "return",
   "<mask>",
   "(",
   "[",
   "float",
   "(",
   "value",
   ")",
   "for",
   "value",
   "in",
   "values",
   "]",
   ")",
   "except",
   "KeyError",
   ":",
   "return",
   "None",
   "except",
   "ValueError",
   ":",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-836",
  "nl_tokens": [
   "Returns",
   "the",
   "intersection",
   "of",
   "this",
   "and",
   "another",
   "Envelope",
   "."
  ],
  "pl_tokens": [
   "def",
   "intersect",
   "(",
   "self",
   ",",
   "other",
   ")",
   ":",
   "inter",
   "=",
   "Envelope",
   "(",
   "tuple",
   "(",
   "self",
   ")",
   ")",
   "if",
   "inter",
   ".",
   "intersects",
   "(",
   "other",
   ")",
   ":",
   "mid",
   "=",
   "len",
   "(",
   "other",
   ")",
   "//",
   "2",
   "inter",
   ".",
   "ll",
   "=",
   "map",
   "(",
   "<mask>",
   ",",
   "inter",
   ".",
   "ll",
   ",",
   "other",
   "[",
   ":",
   "mid",
   "]",
   ")",
   "inter",
   ".",
   "ur",
   "=",
   "map",
   "(",
   "min",
   ",",
   "inter",
   ".",
   "ur",
   ",",
   "other",
   "[",
   "mid",
   ":",
   "]",
   ")",
   "else",
   ":",
   "inter",
   ".",
   "ll",
   "=",
   "(",
   "0",
   ",",
   "0",
   ")",
   "inter",
   ".",
   "ur",
   "=",
   "(",
   "0",
   ",",
   "0",
   ")",
   "return",
   "inter"
  ]
 },
 {
  "idx": "maxmin-837",
  "nl_tokens": [
   "Fast",
   "forward",
   "selection",
   "algorithm"
  ],
  "pl_tokens": [
   "def",
   "fast_forward_selection",
   "(",
   "scenarios",
   ",",
   "number_of_reduced_scenarios",
   ",",
   "probability",
   "=",
   "None",
   ")",
   ":",
   "print",
   "(",
   "\"Running fast forward selection algorithm\"",
   ")",
   "number_of_scenarios",
   "=",
   "scenarios",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "logger",
   ".",
   "debug",
   "(",
   "\"Input number of scenarios = %d\"",
   ",",
   "number_of_scenarios",
   ")",
   "# if probability is not defined assign equal probability to all scenarios",
   "if",
   "probability",
   "is",
   "None",
   ":",
   "probability",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "1",
   "/",
   "number_of_scenarios",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   "]",
   ")",
   "# initialize z, c and J",
   "z",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "inf",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   "]",
   ")",
   "c",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "number_of_scenarios",
   ",",
   "number_of_scenarios",
   ")",
   ")",
   "J",
   "=",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   "# no reduction necessary",
   "if",
   "number_of_reduced_scenarios",
   ">=",
   "number_of_scenarios",
   ":",
   "return",
   "(",
   "scenarios",
   ",",
   "probability",
   ",",
   "J",
   ")",
   "for",
   "scenario_k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "for",
   "scenario_u",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_u",
   "]",
   "=",
   "distance",
   "(",
   "scenarios",
   "[",
   ":",
   ",",
   "scenario_k",
   "]",
   ",",
   "scenarios",
   "[",
   ":",
   ",",
   "scenario_u",
   "]",
   ")",
   "for",
   "scenario_u",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "summation",
   "=",
   "0",
   "for",
   "scenario_k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_k",
   "!=",
   "scenario_u",
   ":",
   "summation",
   "=",
   "summation",
   "+",
   "probability",
   "[",
   "scenario_k",
   "]",
   "*",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_u",
   "]",
   "z",
   "[",
   "scenario_u",
   "]",
   "=",
   "summation",
   "U",
   "=",
   "[",
   "np",
   ".",
   "argmin",
   "(",
   "z",
   ")",
   "]",
   "for",
   "u",
   "in",
   "U",
   ":",
   "J",
   ".",
   "remove",
   "(",
   "u",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   "-",
   "number_of_reduced_scenarios",
   "-",
   "1",
   ")",
   ":",
   "print",
   "(",
   "\"Running {}\"",
   ".",
   "format",
   "(",
   "_",
   ")",
   ")",
   "for",
   "scenario_u",
   "in",
   "J",
   ":",
   "for",
   "scenario_k",
   "in",
   "J",
   ":",
   "lowest_value",
   "=",
   "np",
   ".",
   "inf",
   "for",
   "scenario_number",
   "in",
   "U",
   ":",
   "lowest_value",
   "=",
   "<mask>",
   "(",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_u",
   "]",
   ",",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_number",
   "]",
   ")",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_u",
   "]",
   "=",
   "lowest_value",
   "for",
   "scenario_u",
   "in",
   "J",
   ":",
   "summation",
   "=",
   "0",
   "for",
   "scenario_k",
   "in",
   "J",
   ":",
   "if",
   "scenario_k",
   "not",
   "in",
   "U",
   ":",
   "summation",
   "=",
   "summation",
   "+",
   "probability",
   "[",
   "scenario_k",
   "]",
   "*",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_u",
   "]",
   "z",
   "[",
   "scenario_u",
   "]",
   "=",
   "summation",
   "u_i",
   "=",
   "np",
   ".",
   "argmin",
   "(",
   "[",
   "item",
   "if",
   "i",
   "in",
   "J",
   "else",
   "np",
   ".",
   "inf",
   "for",
   "i",
   ",",
   "item",
   "in",
   "enumerate",
   "(",
   "z",
   ")",
   "]",
   ")",
   "J",
   ".",
   "remove",
   "(",
   "u_i",
   ")",
   "U",
   ".",
   "append",
   "(",
   "u_i",
   ")",
   "reduced_scenario_set",
   "=",
   "U",
   "reduced_probability",
   "=",
   "[",
   "]",
   "reduced_probability",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "probability",
   ")",
   "for",
   "deleted_scenario_number",
   "in",
   "J",
   ":",
   "lowest_value",
   "=",
   "np",
   ".",
   "inf",
   "# find closest scenario_number",
   "for",
   "scenario_j",
   "in",
   "reduced_scenario_set",
   ":",
   "if",
   "c",
   "[",
   "deleted_scenario_number",
   ",",
   "scenario_j",
   "]",
   "<",
   "lowest_value",
   ":",
   "closest_scenario_number",
   "=",
   "scenario_j",
   "lowest_value",
   "=",
   "c",
   "[",
   "deleted_scenario_number",
   ",",
   "scenario_j",
   "]",
   "reduced_probability",
   "[",
   "closest_scenario_number",
   "]",
   "=",
   "reduced_probability",
   "[",
   "closest_scenario_number",
   "]",
   "+",
   "reduced_probability",
   "[",
   "deleted_scenario_number",
   "]",
   "reduced_scenarios",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "scenarios",
   "[",
   ":",
   ",",
   "reduced_scenario_set",
   "]",
   ")",
   "reduced_probability",
   "=",
   "reduced_probability",
   "[",
   "reduced_scenario_set",
   "]",
   "return",
   "reduced_scenarios",
   ",",
   "reduced_probability",
   ",",
   "reduced_scenario_set"
  ]
 },
 {
  "idx": "maxmin-838",
  "nl_tokens": [
   "From",
   "a",
   "list",
   "of",
   "feature",
   "segments",
   "return",
   "a",
   "list",
   "of",
   "2D",
   "-",
   "Fourier",
   "Magnitude",
   "Coefs",
   "using",
   "the",
   "maximum",
   "segment",
   "size",
   "as",
   "main",
   "size",
   "and",
   "zero",
   "pad",
   "the",
   "rest",
   "."
  ],
  "pl_tokens": [
   "def",
   "feat_segments_to_2dfmc_max",
   "(",
   "feat_segments",
   ",",
   "offset",
   "=",
   "4",
   ")",
   ":",
   "if",
   "len",
   "(",
   "feat_segments",
   ")",
   "==",
   "0",
   ":",
   "return",
   "[",
   "]",
   "# Get maximum segment size",
   "max_len",
   "=",
   "<mask>",
   "(",
   "[",
   "feat_segment",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "for",
   "feat_segment",
   "in",
   "feat_segments",
   "]",
   ")",
   "fmcs",
   "=",
   "[",
   "]",
   "for",
   "feat_segment",
   "in",
   "feat_segments",
   ":",
   "# Zero pad if needed",
   "X",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "max_len",
   ",",
   "feat_segment",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   "# Remove a set of frames in the beginning an end of the segment",
   "if",
   "feat_segment",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "<=",
   "offset",
   "or",
   "offset",
   "==",
   "0",
   ":",
   "X",
   "[",
   ":",
   "feat_segment",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   ":",
   "]",
   "=",
   "feat_segment",
   "else",
   ":",
   "X",
   "[",
   ":",
   "feat_segment",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "offset",
   ",",
   ":",
   "]",
   "=",
   "feat_segment",
   "[",
   "offset",
   "//",
   "2",
   ":",
   "-",
   "offset",
   "//",
   "2",
   ",",
   ":",
   "]",
   "# Compute the 2D-FMC",
   "try",
   ":",
   "fmcs",
   ".",
   "append",
   "(",
   "utils2d",
   ".",
   "compute_ffmc2d",
   "(",
   "X",
   ")",
   ")",
   "except",
   ":",
   "logging",
   ".",
   "warning",
   "(",
   "\"Couldn't compute the 2D Fourier Transform\"",
   ")",
   "fmcs",
   ".",
   "append",
   "(",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "*",
   "X",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "//",
   "2",
   "+",
   "1",
   ")",
   ")",
   "# Normalize",
   "# fmcs[-1] = fmcs[-1] / float(fmcs[-1].max())",
   "return",
   "np",
   ".",
   "asarray",
   "(",
   "fmcs",
   ")"
  ]
 },
 {
  "idx": "maxmin-839",
  "nl_tokens": [
   "Expands",
   "the",
   "vertical",
   "scrollbar",
   "beyond",
   "the",
   "range",
   "set",
   "by",
   "Qt",
   "."
  ],
  "pl_tokens": [
   "def",
   "_adjust_scrollbars",
   "(",
   "self",
   ")",
   ":",
   "# This code is adapted from _q_adjustScrollbars in qplaintextedit.cpp",
   "# and qtextedit.cpp.",
   "document",
   "=",
   "self",
   ".",
   "_control",
   ".",
   "document",
   "(",
   ")",
   "scrollbar",
   "=",
   "self",
   ".",
   "_control",
   ".",
   "verticalScrollBar",
   "(",
   ")",
   "viewport_height",
   "=",
   "self",
   ".",
   "_control",
   ".",
   "viewport",
   "(",
   ")",
   ".",
   "height",
   "(",
   ")",
   "if",
   "isinstance",
   "(",
   "self",
   ".",
   "_control",
   ",",
   "QtGui",
   ".",
   "QPlainTextEdit",
   ")",
   ":",
   "maximum",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "document",
   ".",
   "lineCount",
   "(",
   ")",
   "-",
   "1",
   ")",
   "step",
   "=",
   "viewport_height",
   "/",
   "self",
   ".",
   "_control",
   ".",
   "fontMetrics",
   "(",
   ")",
   ".",
   "lineSpacing",
   "(",
   ")",
   "else",
   ":",
   "# QTextEdit does not do line-based layout and blocks will not in",
   "# general have the same height. Therefore it does not make sense to",
   "# attempt to scroll in line height increments.",
   "maximum",
   "=",
   "document",
   ".",
   "size",
   "(",
   ")",
   ".",
   "height",
   "(",
   ")",
   "step",
   "=",
   "viewport_height",
   "diff",
   "=",
   "maximum",
   "-",
   "scrollbar",
   ".",
   "maximum",
   "(",
   ")",
   "scrollbar",
   ".",
   "setRange",
   "(",
   "0",
   ",",
   "maximum",
   ")",
   "scrollbar",
   ".",
   "setPageStep",
   "(",
   "step",
   ")",
   "# Compensate for undesirable scrolling that occurs automatically due to",
   "# maximumBlockCount() text truncation.",
   "if",
   "diff",
   "<",
   "0",
   "and",
   "document",
   ".",
   "blockCount",
   "(",
   ")",
   "==",
   "document",
   ".",
   "maximumBlockCount",
   "(",
   ")",
   ":",
   "scrollbar",
   ".",
   "setValue",
   "(",
   "scrollbar",
   ".",
   "value",
   "(",
   ")",
   "+",
   "diff",
   ")"
  ]
 },
 {
  "idx": "maxmin-840",
  "nl_tokens": [
   "Prints",
   "out",
   "table",
   "header",
   "based",
   "on",
   "the",
   "size",
   "of",
   "the",
   "data",
   "in",
   "columns"
  ],
  "pl_tokens": [
   "def",
   "printFieldsHeader",
   "(",
   "self",
   ",",
   "f",
   ",",
   "d",
   ")",
   ":",
   "fstr",
   "=",
   "\"Field Name\"",
   "dstr",
   "=",
   "\"Description\"",
   "f",
   "=",
   "<mask>",
   "(",
   "f",
   ",",
   "len",
   "(",
   "fstr",
   ")",
   ")",
   "d",
   "=",
   "max",
   "(",
   "d",
   ",",
   "len",
   "(",
   "dstr",
   ")",
   ")",
   "print",
   "(",
   "'|{0}{1}|{2}{3}|'",
   ".",
   "format",
   "(",
   "fstr",
   ",",
   "' '",
   "*",
   "(",
   "f",
   "-",
   "len",
   "(",
   "fstr",
   ")",
   ")",
   ",",
   "dstr",
   ",",
   "' '",
   "*",
   "(",
   "d",
   "-",
   "len",
   "(",
   "dstr",
   ")",
   ")",
   ")",
   ")",
   "print",
   "(",
   "'|:{0}|:{1}|'",
   ".",
   "format",
   "(",
   "'-'",
   "*",
   "(",
   "f",
   "-",
   "1",
   ")",
   ",",
   "'-'",
   "*",
   "(",
   "d",
   "-",
   "1",
   ")",
   ")",
   ")",
   "return",
   "(",
   "f",
   ",",
   "d",
   ")"
  ]
 },
 {
  "idx": "maxmin-841",
  "nl_tokens": [
   "Generate",
   "the",
   "next",
   "timeslot",
   "id",
   "this",
   "function",
   "is",
   "mainly",
   "used",
   "internally"
  ],
  "pl_tokens": [
   "def",
   "generate_ts_id",
   "(",
   "self",
   ",",
   "time",
   "=",
   "None",
   ")",
   ":",
   "if",
   "time",
   "and",
   "time",
   "<",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Time is negative...'",
   ")",
   "if",
   "not",
   "self",
   ".",
   "maxts",
   ":",
   "valid_ts",
   "=",
   "[",
   "int",
   "(",
   "''",
   ".",
   "join",
   "(",
   "filter",
   "(",
   "str",
   ".",
   "isdigit",
   ",",
   "a",
   ")",
   ")",
   ")",
   "for",
   "a",
   "in",
   "self",
   ".",
   "timeslots",
   "]",
   "self",
   ".",
   "maxts",
   "=",
   "<mask>",
   "(",
   "valid_ts",
   "+",
   "[",
   "1",
   "]",
   ")",
   "+",
   "1",
   "else",
   ":",
   "self",
   ".",
   "maxts",
   "+=",
   "1",
   "ts",
   "=",
   "'ts{:d}'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "maxts",
   ")",
   "self",
   ".",
   "timeslots",
   "[",
   "ts",
   "]",
   "=",
   "time",
   "return",
   "ts"
  ]
 },
 {
  "idx": "maxmin-842",
  "nl_tokens": [
   "Automatically",
   "separates",
   "signal",
   "and",
   "background",
   "in",
   "an",
   "on",
   "/",
   "off",
   "data",
   "stream",
   "."
  ],
  "pl_tokens": [
   "def",
   "autorange",
   "(",
   "t",
   ",",
   "sig",
   ",",
   "gwin",
   "=",
   "7",
   ",",
   "swin",
   "=",
   "None",
   ",",
   "win",
   "=",
   "30",
   ",",
   "on_mult",
   "=",
   "(",
   "1.5",
   ",",
   "1.",
   ")",
   ",",
   "off_mult",
   "=",
   "(",
   "1.",
   ",",
   "1.5",
   ")",
   ",",
   "nbin",
   "=",
   "10",
   ",",
   "transform",
   "=",
   "'log'",
   ",",
   "thresh",
   "=",
   "None",
   ")",
   ":",
   "failed",
   "=",
   "[",
   "]",
   "# smooth signal",
   "if",
   "swin",
   "is",
   "not",
   "None",
   ":",
   "sigs",
   "=",
   "fastsmooth",
   "(",
   "sig",
   ",",
   "swin",
   ")",
   "else",
   ":",
   "sigs",
   "=",
   "sig",
   "# transform signal",
   "if",
   "transform",
   "==",
   "'log'",
   ":",
   "tsigs",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "sigs",
   ")",
   "else",
   ":",
   "tsigs",
   "=",
   "sigs",
   "if",
   "thresh",
   "is",
   "None",
   ":",
   "bins",
   "=",
   "50",
   "kde_x",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "tsigs",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "tsigs",
   ".",
   "max",
   "(",
   ")",
   ",",
   "bins",
   ")",
   "kde",
   "=",
   "gaussian_kde",
   "(",
   "tsigs",
   ")",
   "yd",
   "=",
   "kde",
   ".",
   "pdf",
   "(",
   "kde_x",
   ")",
   "mins",
   "=",
   "findmins",
   "(",
   "kde_x",
   ",",
   "yd",
   ")",
   "# find minima in kde",
   "if",
   "len",
   "(",
   "mins",
   ")",
   ">",
   "0",
   ":",
   "bkg",
   "=",
   "tsigs",
   "<",
   "(",
   "mins",
   "[",
   "0",
   "]",
   ")",
   "# set background as lowest distribution",
   "else",
   ":",
   "bkg",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "tsigs",
   ".",
   "size",
   ",",
   "dtype",
   "=",
   "bool",
   ")",
   "# bkg[0] = True  # the first value must always be background",
   "else",
   ":",
   "bkg",
   "=",
   "tsigs",
   "<",
   "thresh",
   "# assign rough background and signal regions based on kde minima",
   "fbkg",
   "=",
   "bkg",
   "fsig",
   "=",
   "~",
   "bkg",
   "# remove transitions by fitting a gaussian to the gradients of",
   "# each transition",
   "# 1. determine the approximate index of each transition",
   "zeros",
   "=",
   "bool_2_indices",
   "(",
   "fsig",
   ")",
   "# 2. calculate the absolute gradient of the target trace.",
   "g",
   "=",
   "abs",
   "(",
   "fastgrad",
   "(",
   "sigs",
   ",",
   "gwin",
   ")",
   ")",
   "# gradient of untransformed data.",
   "if",
   "zeros",
   "is",
   "not",
   "None",
   ":",
   "zeros",
   "=",
   "zeros",
   ".",
   "flatten",
   "(",
   ")",
   "for",
   "z",
   "in",
   "zeros",
   ":",
   "# for each approximate transition",
   "# isolate the data around the transition",
   "if",
   "z",
   "-",
   "win",
   "<",
   "0",
   ":",
   "lo",
   "=",
   "gwin",
   "//",
   "2",
   "hi",
   "=",
   "int",
   "(",
   "z",
   "+",
   "win",
   ")",
   "elif",
   "z",
   "+",
   "win",
   ">",
   "(",
   "len",
   "(",
   "sig",
   ")",
   "-",
   "gwin",
   "//",
   "2",
   ")",
   ":",
   "lo",
   "=",
   "int",
   "(",
   "z",
   "-",
   "win",
   ")",
   "hi",
   "=",
   "len",
   "(",
   "sig",
   ")",
   "-",
   "gwin",
   "//",
   "2",
   "else",
   ":",
   "lo",
   "=",
   "int",
   "(",
   "z",
   "-",
   "win",
   ")",
   "hi",
   "=",
   "int",
   "(",
   "z",
   "+",
   "win",
   ")",
   "xs",
   "=",
   "t",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "ys",
   "=",
   "g",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "# determine type of transition (on/off)",
   "mid",
   "=",
   "(",
   "hi",
   "+",
   "lo",
   ")",
   "//",
   "2",
   "tp",
   "=",
   "sigs",
   "[",
   "mid",
   "+",
   "3",
   "]",
   ">",
   "sigs",
   "[",
   "mid",
   "-",
   "3",
   "]",
   "# True if 'on' transition.",
   "# fit a gaussian to the first derivative of each",
   "# transition. Initial guess parameters:",
   "#   - A: maximum gradient in data",
   "#   - mu: c",
   "#   - width: 2 * time step",
   "# The 'sigma' parameter of curve_fit:",
   "# This weights the fit by distance from c - i.e. data closer",
   "# to c are more important in the fit than data further away",
   "# from c. This allows the function to fit the correct curve,",
   "# even if the data window has captured two independent",
   "# transitions (i.e. end of one ablation and start of next)",
   "# ablation are < win time steps apart).",
   "c",
   "=",
   "t",
   "[",
   "z",
   "]",
   "# center of transition",
   "width",
   "=",
   "(",
   "t",
   "[",
   "1",
   "]",
   "-",
   "t",
   "[",
   "0",
   "]",
   ")",
   "*",
   "2",
   "try",
   ":",
   "pg",
   ",",
   "_",
   "=",
   "curve_fit",
   "(",
   "gauss",
   ",",
   "xs",
   ",",
   "ys",
   ",",
   "p0",
   "=",
   "(",
   "np",
   ".",
   "nanmax",
   "(",
   "ys",
   ")",
   ",",
   "c",
   ",",
   "width",
   ")",
   ",",
   "sigma",
   "=",
   "(",
   "xs",
   "-",
   "c",
   ")",
   "**",
   "2",
   "+",
   ".01",
   ")",
   "# get the x positions when the fitted gaussian is at 'conf' of",
   "# maximum",
   "# determine transition FWHM",
   "fwhm",
   "=",
   "abs",
   "(",
   "2",
   "*",
   "pg",
   "[",
   "-",
   "1",
   "]",
   "*",
   "np",
   ".",
   "sqrt",
   "(",
   "2",
   "*",
   "np",
   ".",
   "log",
   "(",
   "2",
   ")",
   ")",
   ")",
   "# apply on_mult or off_mult, as appropriate.",
   "if",
   "tp",
   ":",
   "lim",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "-",
   "fwhm",
   ",",
   "fwhm",
   "]",
   ")",
   "*",
   "on_mult",
   "+",
   "pg",
   "[",
   "1",
   "]",
   "else",
   ":",
   "lim",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "-",
   "fwhm",
   ",",
   "fwhm",
   "]",
   ")",
   "*",
   "off_mult",
   "+",
   "pg",
   "[",
   "1",
   "]",
   "fbkg",
   "[",
   "(",
   "t",
   ">",
   "lim",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<",
   "lim",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "False",
   "fsig",
   "[",
   "(",
   "t",
   ">",
   "lim",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<",
   "lim",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "False",
   "except",
   "RuntimeError",
   ":",
   "failed",
   ".",
   "append",
   "(",
   "[",
   "c",
   ",",
   "tp",
   "]",
   ")",
   "pass",
   "ftrn",
   "=",
   "~",
   "fbkg",
   "&",
   "~",
   "fsig",
   "# if there are any failed transitions, exclude the mean transition width",
   "# either side of the failures",
   "if",
   "len",
   "(",
   "failed",
   ")",
   ">",
   "0",
   ":",
   "trns",
   "=",
   "t",
   "[",
   "bool_2_indices",
   "(",
   "ftrn",
   ")",
   "]",
   "tr_mean",
   "=",
   "(",
   "trns",
   "[",
   ":",
   ",",
   "1",
   "]",
   "-",
   "trns",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   ".",
   "mean",
   "(",
   ")",
   "/",
   "2",
   "for",
   "f",
   ",",
   "tp",
   "in",
   "failed",
   ":",
   "if",
   "tp",
   ":",
   "ind",
   "=",
   "(",
   "t",
   ">=",
   "f",
   "-",
   "tr_mean",
   "*",
   "on_mult",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<=",
   "f",
   "+",
   "tr_mean",
   "*",
   "on_mult",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "ind",
   "=",
   "(",
   "t",
   ">=",
   "f",
   "-",
   "tr_mean",
   "*",
   "off_mult",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<=",
   "f",
   "+",
   "tr_mean",
   "*",
   "off_mult",
   "[",
   "0",
   "]",
   ")",
   "fsig",
   "[",
   "ind",
   "]",
   "=",
   "False",
   "fbkg",
   "[",
   "ind",
   "]",
   "=",
   "False",
   "ftrn",
   "[",
   "ind",
   "]",
   "=",
   "False",
   "return",
   "fbkg",
   ",",
   "fsig",
   ",",
   "ftrn",
   ",",
   "[",
   "f",
   "[",
   "0",
   "]",
   "for",
   "f",
   "in",
   "failed",
   "]"
  ]
 },
 {
  "idx": "maxmin-843",
  "nl_tokens": [
   "Build",
   "the",
   "Join",
   "field",
   "instance",
   ".",
   ":",
   "param",
   "list",
   "pre",
   ":",
   "The",
   "prerequisites",
   "list",
   ":",
   "param",
   "bool",
   "shortest",
   ":",
   "Whether",
   "or",
   "not",
   "the",
   "shortest",
   "reference",
   "-",
   "chain",
   "(",
   "most",
   "minimal",
   ")",
   "version",
   "of",
   "the",
   "field",
   "should",
   "be",
   "generated",
   "."
  ],
  "pl_tokens": [
   "def",
   "build",
   "(",
   "self",
   ",",
   "pre",
   "=",
   "None",
   ",",
   "shortest",
   "=",
   "False",
   ")",
   ":",
   "if",
   "pre",
   "is",
   "None",
   ":",
   "pre",
   "=",
   "[",
   "]",
   "if",
   "self",
   ".",
   "<mask>",
   "is",
   "not",
   "None",
   ":",
   "if",
   "shortest",
   ":",
   "vals",
   "=",
   "[",
   "self",
   ".",
   "values",
   "[",
   "0",
   "]",
   "]",
   "else",
   ":",
   "# +1 to make it inclusive",
   "vals",
   "=",
   "[",
   "self",
   ".",
   "values",
   "[",
   "0",
   "]",
   "]",
   "*",
   "rand",
   ".",
   "randint",
   "(",
   "1",
   ",",
   "self",
   ".",
   "max",
   "+",
   "1",
   ")",
   "else",
   ":",
   "vals",
   "=",
   "self",
   ".",
   "values",
   "joins",
   "=",
   "[",
   "]",
   "for",
   "val",
   "in",
   "vals",
   ":",
   "try",
   ":",
   "v",
   "=",
   "utils",
   ".",
   "val",
   "(",
   "val",
   ",",
   "pre",
   ",",
   "shortest",
   "=",
   "shortest",
   ")",
   "joins",
   ".",
   "append",
   "(",
   "v",
   ")",
   "except",
   "errors",
   ".",
   "OptGram",
   "as",
   "e",
   ":",
   "continue",
   "return",
   "self",
   ".",
   "sep",
   ".",
   "join",
   "(",
   "joins",
   ")"
  ]
 },
 {
  "idx": "maxmin-844",
  "nl_tokens": [
   ":",
   "type",
   "package_name",
   ":",
   "str",
   ":",
   "type",
   "current_version",
   ":",
   "version",
   ".",
   "Version",
   ":",
   "type",
   "response",
   ":",
   "requests",
   ".",
   "models",
   ".",
   "Response"
  ],
  "pl_tokens": [
   "def",
   "_parse_simple_html_package_info",
   "(",
   "self",
   ",",
   "package_name",
   ",",
   "current_version",
   ",",
   "response",
   ")",
   ":",
   "pattern",
   "=",
   "r'<a.*>.*{name}-([A-z0-9\\.-]*)(?:-py|\\.tar).*<\\/a>'",
   ".",
   "format",
   "(",
   "name",
   "=",
   "re",
   ".",
   "escape",
   "(",
   "package_name",
   ")",
   ")",
   "versions_match",
   "=",
   "re",
   ".",
   "findall",
   "(",
   "pattern",
   ",",
   "response",
   ".",
   "content",
   ".",
   "decode",
   "(",
   "'utf-8'",
   ")",
   ",",
   "flags",
   "=",
   "re",
   ".",
   "IGNORECASE",
   ")",
   "all_versions",
   "=",
   "[",
   "version",
   ".",
   "parse",
   "(",
   "vers",
   ")",
   "for",
   "vers",
   "in",
   "versions_match",
   "]",
   "filtered_versions",
   "=",
   "[",
   "vers",
   "for",
   "vers",
   "in",
   "all_versions",
   "if",
   "not",
   "vers",
   ".",
   "is_prerelease",
   "and",
   "not",
   "vers",
   ".",
   "is_postrelease",
   "]",
   "if",
   "not",
   "filtered_versions",
   ":",
   "# pragma: nocover",
   "return",
   "False",
   ",",
   "'error while parsing version'",
   "latest_version",
   "=",
   "<mask>",
   "(",
   "filtered_versions",
   ")",
   "# even if user did not choose prerelease, if the package from requirements is pre/post release, use it",
   "if",
   "self",
   ".",
   "_prerelease",
   "or",
   "current_version",
   ".",
   "is_postrelease",
   "or",
   "current_version",
   ".",
   "is_prerelease",
   ":",
   "prerelease_versions",
   "=",
   "[",
   "vers",
   "for",
   "vers",
   "in",
   "all_versions",
   "if",
   "vers",
   ".",
   "is_prerelease",
   "or",
   "vers",
   ".",
   "is_postrelease",
   "]",
   "if",
   "prerelease_versions",
   ":",
   "latest_version",
   "=",
   "max",
   "(",
   "prerelease_versions",
   ")",
   "return",
   "{",
   "'name'",
   ":",
   "package_name",
   ",",
   "'current_version'",
   ":",
   "current_version",
   ",",
   "'latest_version'",
   ":",
   "latest_version",
   ",",
   "'upgrade_available'",
   ":",
   "current_version",
   "<",
   "latest_version",
   ",",
   "'upload_time'",
   ":",
   "'-'",
   "}",
   ",",
   "'success'"
  ]
 },
 {
  "idx": "maxmin-845",
  "nl_tokens": [
   "For",
   "each",
   "onset",
   "front",
   "for",
   "each",
   "frequency",
   "in",
   "that",
   "front",
   "break",
   "the",
   "onset",
   "front",
   "if",
   "the",
   "signals",
   "between",
   "this",
   "frequency",
   "s",
   "onset",
   "and",
   "the",
   "next",
   "frequency",
   "s",
   "onset",
   "are",
   "not",
   "similar",
   "enough",
   "."
  ],
  "pl_tokens": [
   "def",
   "_break_poorly_matched_fronts",
   "(",
   "fronts",
   ",",
   "threshold",
   "=",
   "0.1",
   ",",
   "threshold_overlap_samples",
   "=",
   "3",
   ")",
   ":",
   "assert",
   "threshold_overlap_samples",
   ">",
   "0",
   ",",
   "\"Number of samples of overlap must be greater than zero\"",
   "breaks_after",
   "=",
   "{",
   "}",
   "for",
   "front_id",
   "in",
   "_get_front_ids_one_at_a_time",
   "(",
   "fronts",
   ")",
   ":",
   "front",
   "=",
   "_get_front_idxs_from_id",
   "(",
   "fronts",
   ",",
   "front_id",
   ")",
   "for",
   "i",
   ",",
   "(",
   "f",
   ",",
   "s",
   ")",
   "in",
   "enumerate",
   "(",
   "front",
   ")",
   ":",
   "if",
   "i",
   "<",
   "len",
   "(",
   "front",
   ")",
   "-",
   "1",
   ":",
   "# Get the signal from f, s to f, s+1 and the signal from f+1, s to f+1, s+1",
   "next_f",
   ",",
   "next_s",
   "=",
   "front",
   "[",
   "i",
   "+",
   "1",
   "]",
   "low_s",
   "=",
   "<mask>",
   "(",
   "s",
   ",",
   "next_s",
   ")",
   "high_s",
   "=",
   "max",
   "(",
   "s",
   ",",
   "next_s",
   ")",
   "sig_this_f",
   "=",
   "fronts",
   "[",
   "f",
   ",",
   "low_s",
   ":",
   "high_s",
   "]",
   "sig_next_f",
   "=",
   "fronts",
   "[",
   "next_f",
   ",",
   "low_s",
   ":",
   "high_s",
   "]",
   "assert",
   "len",
   "(",
   "sig_next_f",
   ")",
   "==",
   "len",
   "(",
   "sig_this_f",
   ")",
   "if",
   "len",
   "(",
   "sig_next_f",
   ")",
   ">",
   "threshold_overlap_samples",
   ":",
   "# If these two signals are not sufficiently close in form, this front should be broken up",
   "correlation",
   "=",
   "signal",
   ".",
   "correlate",
   "(",
   "sig_this_f",
   ",",
   "sig_next_f",
   ",",
   "mode",
   "=",
   "'same'",
   ")",
   "assert",
   "len",
   "(",
   "correlation",
   ")",
   ">",
   "0",
   "correlation",
   "=",
   "correlation",
   "/",
   "max",
   "(",
   "correlation",
   "+",
   "1E-9",
   ")",
   "similarity",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "correlation",
   ")",
   "/",
   "len",
   "(",
   "correlation",
   ")",
   "# TODO: the above stuff probably needs to be figured out",
   "if",
   "similarity",
   "<",
   "threshold",
   ":",
   "if",
   "front_id",
   "in",
   "breaks_after",
   ":",
   "breaks_after",
   "[",
   "front_id",
   "]",
   ".",
   "append",
   "(",
   "(",
   "f",
   ",",
   "s",
   ")",
   ")",
   "else",
   ":",
   "breaks_after",
   "[",
   "front_id",
   "]",
   "=",
   "[",
   "]",
   "# Now update the fronts matrix by breaking up any fronts at the points we just identified",
   "# and assign the newly created fronts new IDs",
   "taken_ids",
   "=",
   "sorted",
   "(",
   "np",
   ".",
   "unique",
   "(",
   "fronts",
   ")",
   ")",
   "next_id",
   "=",
   "taken_ids",
   "[",
   "-",
   "1",
   "]",
   "+",
   "1",
   "for",
   "id",
   "in",
   "breaks_after",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "for",
   "f",
   ",",
   "s",
   "in",
   "breaks_after",
   "[",
   "id",
   "]",
   ":",
   "fidxs",
   ",",
   "sidxs",
   "=",
   "np",
   ".",
   "where",
   "(",
   "fronts",
   "==",
   "id",
   ")",
   "idxs_greater_than_f",
   "=",
   "[",
   "fidx",
   "for",
   "fidx",
   "in",
   "fidxs",
   "if",
   "fidx",
   ">",
   "f",
   "]",
   "start",
   "=",
   "len",
   "(",
   "sidxs",
   ")",
   "-",
   "len",
   "(",
   "idxs_greater_than_f",
   ")",
   "indexes",
   "=",
   "(",
   "idxs_greater_than_f",
   ",",
   "sidxs",
   "[",
   "start",
   ":",
   "]",
   ")",
   "fronts",
   "[",
   "indexes",
   "]",
   "=",
   "next_id",
   "next_id",
   "+=",
   "1",
   "_remove_fronts_that_are_too_small",
   "(",
   "fronts",
   ",",
   "3",
   ")"
  ]
 },
 {
  "idx": "maxmin-846",
  "nl_tokens": [
   "Visualize",
   "the",
   "dataframe",
   "."
  ],
  "pl_tokens": [
   "def",
   "heatmap",
   "(",
   "df",
   ",",
   "z_score",
   "=",
   "None",
   ",",
   "title",
   "=",
   "''",
   ",",
   "figsize",
   "=",
   "(",
   "5",
   ",",
   "5",
   ")",
   ",",
   "cmap",
   "=",
   "'RdBu_r'",
   ",",
   "xticklabels",
   "=",
   "True",
   ",",
   "yticklabels",
   "=",
   "True",
   ",",
   "ofname",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "df",
   "=",
   "zscore",
   "(",
   "df",
   ",",
   "axis",
   "=",
   "z_score",
   ")",
   "df",
   "=",
   "df",
   ".",
   "iloc",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "# Get the positions and used label for the ticks",
   "ny",
   ",",
   "nx",
   "=",
   "df",
   ".",
   "shape",
   "xticks",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "nx",
   ",",
   "1",
   ")",
   "+",
   ".5",
   "yticks",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "ny",
   ",",
   "1",
   ")",
   "+",
   ".5",
   "# If working on commandline, don't show figure",
   "if",
   "hasattr",
   "(",
   "sys",
   ",",
   "'ps1'",
   ")",
   "and",
   "(",
   "ofname",
   "is",
   "None",
   ")",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "figsize",
   ")",
   "else",
   ":",
   "fig",
   "=",
   "Figure",
   "(",
   "figsize",
   "=",
   "figsize",
   ")",
   "canvas",
   "=",
   "FigureCanvas",
   "(",
   "fig",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "111",
   ")",
   "vmin",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "df",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "2",
   ")",
   "vmax",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "df",
   ".",
   "max",
   "(",
   ")",
   ",",
   "98",
   ")",
   "matrix",
   "=",
   "ax",
   ".",
   "pcolormesh",
   "(",
   "df",
   ".",
   "values",
   ",",
   "cmap",
   "=",
   "cmap",
   ",",
   "vmin",
   "=",
   "vmin",
   ",",
   "vmax",
   "=",
   "vmax",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "[",
   "0",
   ",",
   "len",
   "(",
   "df",
   ")",
   "]",
   ")",
   "ax",
   ".",
   "set",
   "(",
   "xticks",
   "=",
   "xticks",
   ",",
   "yticks",
   "=",
   "yticks",
   ")",
   "ax",
   ".",
   "set_xticklabels",
   "(",
   "df",
   ".",
   "columns",
   ".",
   "values",
   "if",
   "xticklabels",
   "else",
   "''",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "90",
   ")",
   "ax",
   ".",
   "set_yticklabels",
   "(",
   "df",
   ".",
   "index",
   ".",
   "values",
   "if",
   "yticklabels",
   "else",
   "''",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "ax",
   ".",
   "set_title",
   "(",
   "\"%s\\nHeatmap of the Analyzed Geneset\"",
   "%",
   "title",
   ",",
   "fontsize",
   "=",
   "20",
   ")",
   "ax",
   ".",
   "tick_params",
   "(",
   "axis",
   "=",
   "'both'",
   ",",
   "which",
   "=",
   "'both'",
   ",",
   "bottom",
   "=",
   "False",
   ",",
   "top",
   "=",
   "False",
   ",",
   "right",
   "=",
   "False",
   ",",
   "left",
   "=",
   "False",
   ")",
   "# cax=fig.add_axes([0.93,0.25,0.05,0.20])",
   "# cbar = fig.colorbar(matrix, cax=cax)",
   "cbar",
   "=",
   "colorbar",
   "(",
   "matrix",
   ")",
   "cbar",
   ".",
   "ax",
   ".",
   "tick_params",
   "(",
   "axis",
   "=",
   "'both'",
   ",",
   "which",
   "=",
   "'both'",
   ",",
   "bottom",
   "=",
   "False",
   ",",
   "top",
   "=",
   "False",
   ",",
   "right",
   "=",
   "False",
   ",",
   "left",
   "=",
   "False",
   ")",
   "for",
   "side",
   "in",
   "[",
   "\"top\"",
   ",",
   "\"right\"",
   ",",
   "\"left\"",
   ",",
   "\"bottom\"",
   "]",
   ":",
   "ax",
   ".",
   "spines",
   "[",
   "side",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "cbar",
   ".",
   "ax",
   ".",
   "spines",
   "[",
   "side",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "# cbar.ax.set_title('',loc='left')",
   "if",
   "ofname",
   "is",
   "not",
   "None",
   ":",
   "# canvas.print_figure(ofname, bbox_inches='tight', dpi=300)",
   "fig",
   ".",
   "savefig",
   "(",
   "ofname",
   ",",
   "bbox_inches",
   "=",
   "'tight'",
   ",",
   "dpi",
   "=",
   "300",
   ")",
   "return"
  ]
 },
 {
  "idx": "maxmin-847",
  "nl_tokens": [
   "Parses",
   "the",
   "drawing",
   "directive",
   "updating",
   "the",
   "node",
   "components",
   "."
  ],
  "pl_tokens": [
   "def",
   "parse_xdot_drawing_directive",
   "(",
   "self",
   ",",
   "new",
   ")",
   ":",
   "components",
   "=",
   "XdotAttrParser",
   "(",
   ")",
   ".",
   "parse_xdot_data",
   "(",
   "new",
   ")",
   "max_x",
   "=",
   "<mask>",
   "(",
   "[",
   "c",
   ".",
   "bounds",
   "[",
   "0",
   "]",
   "for",
   "c",
   "in",
   "components",
   "]",
   "+",
   "[",
   "1",
   "]",
   ")",
   "max_y",
   "=",
   "max",
   "(",
   "[",
   "c",
   ".",
   "bounds",
   "[",
   "1",
   "]",
   "for",
   "c",
   "in",
   "components",
   "]",
   "+",
   "[",
   "1",
   "]",
   ")",
   "pos_x",
   "=",
   "min",
   "(",
   "[",
   "c",
   ".",
   "x",
   "for",
   "c",
   "in",
   "components",
   "]",
   ")",
   "pos_y",
   "=",
   "min",
   "(",
   "[",
   "c",
   ".",
   "y",
   "for",
   "c",
   "in",
   "components",
   "]",
   ")",
   "move_to_origin",
   "(",
   "components",
   ")",
   "container",
   "=",
   "Container",
   "(",
   "auto_size",
   "=",
   "True",
   ",",
   "position",
   "=",
   "[",
   "pos_x",
   "-",
   "self",
   ".",
   "pos",
   "[",
   "0",
   "]",
   ",",
   "pos_y",
   "-",
   "self",
   ".",
   "pos",
   "[",
   "1",
   "]",
   "]",
   ",",
   "bgcolor",
   "=",
   "\"blue\"",
   ")",
   "#        self.bounds = bounds=[max_x, max_y]",
   "#        container = Container(fit_window=False, auto_size=True, bgcolor=\"blue\")",
   "container",
   ".",
   "add",
   "(",
   "*",
   "components",
   ")",
   "self",
   ".",
   "drawing",
   "=",
   "container"
  ]
 },
 {
  "idx": "maxmin-848",
  "nl_tokens": [
   "Return",
   "best",
   "matching",
   "substring",
   "of",
   "corpus",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_best_string",
   "(",
   "query",
   ",",
   "corpus",
   ",",
   "step",
   "=",
   "4",
   ",",
   "flex",
   "=",
   "3",
   ",",
   "case_sensitive",
   "=",
   "False",
   ")",
   ":",
   "def",
   "ratio",
   "(",
   "a",
   ",",
   "b",
   ")",
   ":",
   "\"\"\"Compact alias for SequenceMatcher.\"\"\"",
   "return",
   "SequenceMatcher",
   "(",
   "None",
   ",",
   "a",
   ",",
   "b",
   ")",
   ".",
   "ratio",
   "(",
   ")",
   "def",
   "scan_corpus",
   "(",
   "step",
   ")",
   ":",
   "\"\"\"Return list of match values from corpus-wide scan.\"\"\"",
   "match_values",
   "=",
   "[",
   "]",
   "m",
   "=",
   "0",
   "while",
   "m",
   "+",
   "qlen",
   "-",
   "step",
   "<=",
   "len",
   "(",
   "corpus",
   ")",
   ":",
   "match_values",
   ".",
   "append",
   "(",
   "ratio",
   "(",
   "query",
   ",",
   "corpus",
   "[",
   "m",
   ":",
   "m",
   "-",
   "1",
   "+",
   "qlen",
   "]",
   ")",
   ")",
   "m",
   "+=",
   "step",
   "return",
   "match_values",
   "def",
   "index_max",
   "(",
   "v",
   ")",
   ":",
   "\"\"\"Return index of max value.\"\"\"",
   "return",
   "<mask>",
   "(",
   "range",
   "(",
   "len",
   "(",
   "v",
   ")",
   ")",
   ",",
   "key",
   "=",
   "v",
   ".",
   "__getitem__",
   ")",
   "def",
   "adjust_left_right_positions",
   "(",
   ")",
   ":",
   "\"\"\"Return left/right positions for best string match.\"\"\"",
   "# bp_* is synonym for 'Best Position Left/Right' and are adjusted",
   "# to optimize bmv_*",
   "p_l",
   ",",
   "bp_l",
   "=",
   "[",
   "pos",
   "]",
   "*",
   "2",
   "p_r",
   ",",
   "bp_r",
   "=",
   "[",
   "pos",
   "+",
   "qlen",
   "]",
   "*",
   "2",
   "# bmv_* are declared here in case they are untouched in optimization",
   "bmv_l",
   "=",
   "match_values",
   "[",
   "round_decimal",
   "(",
   "p_l",
   "/",
   "step",
   ")",
   "]",
   "bmv_r",
   "=",
   "match_values",
   "[",
   "round_decimal",
   "(",
   "p_r",
   "/",
   "step",
   ")",
   "]",
   "for",
   "f",
   "in",
   "range",
   "(",
   "flex",
   ")",
   ":",
   "ll",
   "=",
   "ratio",
   "(",
   "query",
   ",",
   "corpus",
   "[",
   "p_l",
   "-",
   "f",
   ":",
   "p_r",
   "]",
   ")",
   "if",
   "ll",
   ">",
   "bmv_l",
   ":",
   "bmv_l",
   "=",
   "ll",
   "bp_l",
   "=",
   "p_l",
   "-",
   "f",
   "lr",
   "=",
   "ratio",
   "(",
   "query",
   ",",
   "corpus",
   "[",
   "p_l",
   "+",
   "f",
   ":",
   "p_r",
   "]",
   ")",
   "if",
   "lr",
   ">",
   "bmv_l",
   ":",
   "bmv_l",
   "=",
   "lr",
   "bp_l",
   "=",
   "p_l",
   "+",
   "f",
   "rl",
   "=",
   "ratio",
   "(",
   "query",
   ",",
   "corpus",
   "[",
   "p_l",
   ":",
   "p_r",
   "-",
   "f",
   "]",
   ")",
   "if",
   "rl",
   ">",
   "bmv_r",
   ":",
   "bmv_r",
   "=",
   "rl",
   "bp_r",
   "=",
   "p_r",
   "-",
   "f",
   "rr",
   "=",
   "ratio",
   "(",
   "query",
   ",",
   "corpus",
   "[",
   "p_l",
   ":",
   "p_r",
   "+",
   "f",
   "]",
   ")",
   "if",
   "rr",
   ">",
   "bmv_r",
   ":",
   "bmv_r",
   "=",
   "rr",
   "bp_r",
   "=",
   "p_r",
   "+",
   "f",
   "return",
   "bp_l",
   ",",
   "bp_r",
   ",",
   "ratio",
   "(",
   "query",
   ",",
   "corpus",
   "[",
   "bp_l",
   ":",
   "bp_r",
   "]",
   ")",
   "if",
   "not",
   "case_sensitive",
   ":",
   "query",
   "=",
   "query",
   ".",
   "lower",
   "(",
   ")",
   "corpus",
   "=",
   "corpus",
   ".",
   "lower",
   "(",
   ")",
   "qlen",
   "=",
   "len",
   "(",
   "query",
   ")",
   "if",
   "flex",
   ">=",
   "qlen",
   "/",
   "2",
   ":",
   "print",
   "(",
   "\"Warning: flex exceeds length of query / 2. Setting to default.\"",
   ")",
   "flex",
   "=",
   "3",
   "match_values",
   "=",
   "scan_corpus",
   "(",
   "step",
   ")",
   "pos",
   "=",
   "index_max",
   "(",
   "match_values",
   ")",
   "*",
   "step",
   "pos_left",
   ",",
   "pos_right",
   ",",
   "match_value",
   "=",
   "adjust_left_right_positions",
   "(",
   ")",
   "return",
   "corpus",
   "[",
   "pos_left",
   ":",
   "pos_right",
   "]",
   ".",
   "strip",
   "(",
   ")",
   ",",
   "match_value"
  ]
 },
 {
  "idx": "maxmin-849",
  "nl_tokens": [
   "Make",
   "a",
   "grid",
   "of",
   "images",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_grid",
   "(",
   "tensor",
   ",",
   "nrow",
   "=",
   "8",
   ",",
   "padding",
   "=",
   "2",
   ",",
   "normalize",
   "=",
   "False",
   ",",
   "range",
   "=",
   "None",
   ",",
   "scale_each",
   "=",
   "False",
   ",",
   "pad_value",
   "=",
   "0",
   ")",
   ":",
   "if",
   "not",
   "(",
   "torch",
   ".",
   "is_tensor",
   "(",
   "tensor",
   ")",
   "or",
   "(",
   "isinstance",
   "(",
   "tensor",
   ",",
   "list",
   ")",
   "and",
   "all",
   "(",
   "torch",
   ".",
   "is_tensor",
   "(",
   "t",
   ")",
   "for",
   "t",
   "in",
   "tensor",
   ")",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "'tensor or list of tensors expected, got {}'",
   ".",
   "format",
   "(",
   "type",
   "(",
   "tensor",
   ")",
   ")",
   ")",
   "# if list of tensors, convert to a 4D mini-batch Tensor",
   "if",
   "isinstance",
   "(",
   "tensor",
   ",",
   "list",
   ")",
   ":",
   "tensor",
   "=",
   "torch",
   ".",
   "stack",
   "(",
   "tensor",
   ",",
   "dim",
   "=",
   "0",
   ")",
   "if",
   "tensor",
   ".",
   "dim",
   "(",
   ")",
   "==",
   "2",
   ":",
   "# single image H x W",
   "tensor",
   "=",
   "tensor",
   ".",
   "unsqueeze",
   "(",
   "0",
   ")",
   "if",
   "tensor",
   ".",
   "dim",
   "(",
   ")",
   "==",
   "3",
   ":",
   "# single image",
   "if",
   "tensor",
   ".",
   "size",
   "(",
   "0",
   ")",
   "==",
   "1",
   ":",
   "# if single-channel, convert to 3-channel",
   "tensor",
   "=",
   "torch",
   ".",
   "cat",
   "(",
   "(",
   "tensor",
   ",",
   "tensor",
   ",",
   "tensor",
   ")",
   ",",
   "0",
   ")",
   "tensor",
   "=",
   "tensor",
   ".",
   "unsqueeze",
   "(",
   "0",
   ")",
   "if",
   "tensor",
   ".",
   "dim",
   "(",
   ")",
   "==",
   "4",
   "and",
   "tensor",
   ".",
   "size",
   "(",
   "1",
   ")",
   "==",
   "1",
   ":",
   "# single-channel images",
   "tensor",
   "=",
   "torch",
   ".",
   "cat",
   "(",
   "(",
   "tensor",
   ",",
   "tensor",
   ",",
   "tensor",
   ")",
   ",",
   "1",
   ")",
   "if",
   "normalize",
   "is",
   "True",
   ":",
   "tensor",
   "=",
   "tensor",
   ".",
   "clone",
   "(",
   ")",
   "# avoid modifying tensor in-place",
   "if",
   "range",
   "is",
   "not",
   "None",
   ":",
   "assert",
   "isinstance",
   "(",
   "range",
   ",",
   "tuple",
   ")",
   ",",
   "\"range has to be a tuple (min, max) if specified. min and max are numbers\"",
   "def",
   "norm_ip",
   "(",
   "img",
   ",",
   "<mask>",
   ",",
   "max",
   ")",
   ":",
   "img",
   ".",
   "clamp_",
   "(",
   "min",
   "=",
   "min",
   ",",
   "max",
   "=",
   "max",
   ")",
   "img",
   ".",
   "add_",
   "(",
   "-",
   "min",
   ")",
   ".",
   "div_",
   "(",
   "max",
   "-",
   "min",
   "+",
   "1e-5",
   ")",
   "def",
   "norm_range",
   "(",
   "t",
   ",",
   "range",
   ")",
   ":",
   "if",
   "range",
   "is",
   "not",
   "None",
   ":",
   "norm_ip",
   "(",
   "t",
   ",",
   "range",
   "[",
   "0",
   "]",
   ",",
   "range",
   "[",
   "1",
   "]",
   ")",
   "else",
   ":",
   "norm_ip",
   "(",
   "t",
   ",",
   "float",
   "(",
   "t",
   ".",
   "min",
   "(",
   ")",
   ")",
   ",",
   "float",
   "(",
   "t",
   ".",
   "max",
   "(",
   ")",
   ")",
   ")",
   "if",
   "scale_each",
   "is",
   "True",
   ":",
   "for",
   "t",
   "in",
   "tensor",
   ":",
   "# loop over mini-batch dimension",
   "norm_range",
   "(",
   "t",
   ",",
   "range",
   ")",
   "else",
   ":",
   "norm_range",
   "(",
   "tensor",
   ",",
   "range",
   ")",
   "if",
   "tensor",
   ".",
   "size",
   "(",
   "0",
   ")",
   "==",
   "1",
   ":",
   "return",
   "tensor",
   ".",
   "squeeze",
   "(",
   ")",
   "# make the mini-batch of images into a grid",
   "nmaps",
   "=",
   "tensor",
   ".",
   "size",
   "(",
   "0",
   ")",
   "xmaps",
   "=",
   "min",
   "(",
   "nrow",
   ",",
   "nmaps",
   ")",
   "ymaps",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "float",
   "(",
   "nmaps",
   ")",
   "/",
   "xmaps",
   ")",
   ")",
   "height",
   ",",
   "width",
   "=",
   "int",
   "(",
   "tensor",
   ".",
   "size",
   "(",
   "2",
   ")",
   "+",
   "padding",
   ")",
   ",",
   "int",
   "(",
   "tensor",
   ".",
   "size",
   "(",
   "3",
   ")",
   "+",
   "padding",
   ")",
   "grid",
   "=",
   "tensor",
   ".",
   "new_full",
   "(",
   "(",
   "3",
   ",",
   "height",
   "*",
   "ymaps",
   "+",
   "padding",
   ",",
   "width",
   "*",
   "xmaps",
   "+",
   "padding",
   ")",
   ",",
   "pad_value",
   ")",
   "k",
   "=",
   "0",
   "for",
   "y",
   "in",
   "irange",
   "(",
   "ymaps",
   ")",
   ":",
   "for",
   "x",
   "in",
   "irange",
   "(",
   "xmaps",
   ")",
   ":",
   "if",
   "k",
   ">=",
   "nmaps",
   ":",
   "break",
   "grid",
   ".",
   "narrow",
   "(",
   "1",
   ",",
   "y",
   "*",
   "height",
   "+",
   "padding",
   ",",
   "height",
   "-",
   "padding",
   ")",
   ".",
   "narrow",
   "(",
   "2",
   ",",
   "x",
   "*",
   "width",
   "+",
   "padding",
   ",",
   "width",
   "-",
   "padding",
   ")",
   ".",
   "copy_",
   "(",
   "tensor",
   "[",
   "k",
   "]",
   ")",
   "k",
   "=",
   "k",
   "+",
   "1",
   "return",
   "grid"
  ]
 },
 {
  "idx": "maxmin-850",
  "nl_tokens": [
   "return",
   "a",
   "random",
   "floating",
   "number"
  ],
  "pl_tokens": [
   "def",
   "amount",
   "(",
   "<mask>",
   "=",
   "1",
   ",",
   "max",
   "=",
   "sys",
   ".",
   "maxsize",
   ",",
   "decimal_places",
   "=",
   "2",
   ")",
   ":",
   "q",
   "=",
   "'.%s1'",
   "%",
   "'0'",
   "*",
   "(",
   "decimal_places",
   "-",
   "1",
   ")",
   "return",
   "decimal",
   ".",
   "Decimal",
   "(",
   "uniform",
   "(",
   "min",
   ",",
   "max",
   ")",
   ")",
   ".",
   "quantize",
   "(",
   "decimal",
   ".",
   "Decimal",
   "(",
   "q",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-851",
  "nl_tokens": [
   "Give",
   "the",
   "ref",
   "annotation",
   "before",
   "a",
   "time",
   ".",
   "If",
   "an",
   "annotation",
   "overlaps",
   "with",
   "time",
   "that",
   "annotation",
   "will",
   "be",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_ref_annotation_data_before_time",
   "(",
   "self",
   ",",
   "id_tier",
   ",",
   "time",
   ")",
   ":",
   "befores",
   "=",
   "self",
   ".",
   "get_ref_annotation_data_between_times",
   "(",
   "id_tier",
   ",",
   "0",
   ",",
   "time",
   ")",
   "if",
   "befores",
   ":",
   "return",
   "[",
   "<mask>",
   "(",
   "befores",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   "]",
   "else",
   ":",
   "return",
   "[",
   "]"
  ]
 },
 {
  "idx": "maxmin-852",
  "nl_tokens": [
   "Enumerate",
   "all",
   "possible",
   "tautomers",
   "and",
   "return",
   "them",
   "as",
   "a",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "enumerate",
   "(",
   "self",
   ",",
   "mol",
   ")",
   ":",
   "smiles",
   "=",
   "Chem",
   ".",
   "MolToSmiles",
   "(",
   "mol",
   ",",
   "isomericSmiles",
   "=",
   "True",
   ")",
   "tautomers",
   "=",
   "{",
   "smiles",
   ":",
   "copy",
   ".",
   "deepcopy",
   "(",
   "mol",
   ")",
   "}",
   "# Create a kekulized form of the molecule to match the SMARTS against",
   "kekulized",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "mol",
   ")",
   "Chem",
   ".",
   "Kekulize",
   "(",
   "kekulized",
   ")",
   "kekulized",
   "=",
   "{",
   "smiles",
   ":",
   "kekulized",
   "}",
   "done",
   "=",
   "set",
   "(",
   ")",
   "while",
   "len",
   "(",
   "tautomers",
   ")",
   "<",
   "self",
   ".",
   "max_tautomers",
   ":",
   "for",
   "tsmiles",
   "in",
   "sorted",
   "(",
   "tautomers",
   ")",
   ":",
   "if",
   "tsmiles",
   "in",
   "done",
   ":",
   "continue",
   "for",
   "transform",
   "in",
   "self",
   ".",
   "transforms",
   ":",
   "for",
   "match",
   "in",
   "kekulized",
   "[",
   "tsmiles",
   "]",
   ".",
   "GetSubstructMatches",
   "(",
   "transform",
   ".",
   "tautomer",
   ")",
   ":",
   "# log.debug('Matched rule: %s to %s for %s', transform.name, tsmiles, match)",
   "# Create a copy of in the input molecule so we can modify it",
   "# Use kekule form so bonds are explicitly single/double instead of aromatic",
   "product",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "kekulized",
   "[",
   "tsmiles",
   "]",
   ")",
   "# Remove a hydrogen from the first matched atom and add one to the last",
   "first",
   "=",
   "product",
   ".",
   "GetAtomWithIdx",
   "(",
   "match",
   "[",
   "0",
   "]",
   ")",
   "last",
   "=",
   "product",
   ".",
   "GetAtomWithIdx",
   "(",
   "match",
   "[",
   "-",
   "1",
   "]",
   ")",
   "# log.debug('%s: H%s -> H%s' % (first.GetSymbol(), first.GetTotalNumHs(), first.GetTotalNumHs() - 1))",
   "# log.debug('%s: H%s -> H%s' % (last.GetSymbol(), last.GetTotalNumHs(), last.GetTotalNumHs() + 1))",
   "first",
   ".",
   "SetNumExplicitHs",
   "(",
   "<mask>",
   "(",
   "0",
   ",",
   "first",
   ".",
   "GetTotalNumHs",
   "(",
   ")",
   "-",
   "1",
   ")",
   ")",
   "last",
   ".",
   "SetNumExplicitHs",
   "(",
   "last",
   ".",
   "GetTotalNumHs",
   "(",
   ")",
   "+",
   "1",
   ")",
   "# Remove any implicit hydrogens from the first and last atoms now we have set the count explicitly",
   "first",
   ".",
   "SetNoImplicit",
   "(",
   "True",
   ")",
   "last",
   ".",
   "SetNoImplicit",
   "(",
   "True",
   ")",
   "# Adjust bond orders",
   "for",
   "bi",
   ",",
   "pair",
   "in",
   "enumerate",
   "(",
   "pairwise",
   "(",
   "match",
   ")",
   ")",
   ":",
   "if",
   "transform",
   ".",
   "bonds",
   ":",
   "# Set the resulting bond types as manually specified in the transform",
   "# log.debug('%s-%s: %s -> %s' % (product.GetAtomWithIdx(pair[0]).GetSymbol(), product.GetAtomWithIdx(pair[1]).GetSymbol(), product.GetBondBetweenAtoms(*pair).GetBondType(), transform.bonds[bi]))",
   "product",
   ".",
   "GetBondBetweenAtoms",
   "(",
   "*",
   "pair",
   ")",
   ".",
   "SetBondType",
   "(",
   "transform",
   ".",
   "bonds",
   "[",
   "bi",
   "]",
   ")",
   "else",
   ":",
   "# If no manually specified bond types, just swap single and double bonds",
   "current_bond_type",
   "=",
   "product",
   ".",
   "GetBondBetweenAtoms",
   "(",
   "*",
   "pair",
   ")",
   ".",
   "GetBondType",
   "(",
   ")",
   "product",
   ".",
   "GetBondBetweenAtoms",
   "(",
   "*",
   "pair",
   ")",
   ".",
   "SetBondType",
   "(",
   "BondType",
   ".",
   "DOUBLE",
   "if",
   "current_bond_type",
   "==",
   "BondType",
   ".",
   "SINGLE",
   "else",
   "BondType",
   ".",
   "SINGLE",
   ")",
   "# log.debug('%s-%s: %s -> %s' % (product.GetAtomWithIdx(pair[0]).GetSymbol(), product.GetAtomWithIdx(pair[1]).GetSymbol(), current_bond_type, product.GetBondBetweenAtoms(*pair).GetBondType()))",
   "# Adjust charges",
   "if",
   "transform",
   ".",
   "charges",
   ":",
   "for",
   "ci",
   ",",
   "idx",
   "in",
   "enumerate",
   "(",
   "match",
   ")",
   ":",
   "atom",
   "=",
   "product",
   ".",
   "GetAtomWithIdx",
   "(",
   "idx",
   ")",
   "# log.debug('%s: C%s -> C%s' % (atom.GetSymbol(), atom.GetFormalCharge(), atom.GetFormalCharge() + transform.charges[ci]))",
   "atom",
   ".",
   "SetFormalCharge",
   "(",
   "atom",
   ".",
   "GetFormalCharge",
   "(",
   ")",
   "+",
   "transform",
   ".",
   "charges",
   "[",
   "ci",
   "]",
   ")",
   "try",
   ":",
   "Chem",
   ".",
   "SanitizeMol",
   "(",
   "product",
   ")",
   "smiles",
   "=",
   "Chem",
   ".",
   "MolToSmiles",
   "(",
   "product",
   ",",
   "isomericSmiles",
   "=",
   "True",
   ")",
   "log",
   ".",
   "debug",
   "(",
   "'Applied rule: %s to %s'",
   ",",
   "transform",
   ".",
   "name",
   ",",
   "tsmiles",
   ")",
   "if",
   "smiles",
   "not",
   "in",
   "tautomers",
   ":",
   "log",
   ".",
   "debug",
   "(",
   "'New tautomer produced: %s'",
   "%",
   "smiles",
   ")",
   "kekulized_product",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "product",
   ")",
   "Chem",
   ".",
   "Kekulize",
   "(",
   "kekulized_product",
   ")",
   "tautomers",
   "[",
   "smiles",
   "]",
   "=",
   "product",
   "kekulized",
   "[",
   "smiles",
   "]",
   "=",
   "kekulized_product",
   "else",
   ":",
   "log",
   ".",
   "debug",
   "(",
   "'Previous tautomer produced again: %s'",
   "%",
   "smiles",
   ")",
   "except",
   "ValueError",
   ":",
   "log",
   ".",
   "debug",
   "(",
   "'ValueError Applying rule: %s'",
   ",",
   "transform",
   ".",
   "name",
   ")",
   "done",
   ".",
   "add",
   "(",
   "tsmiles",
   ")",
   "if",
   "len",
   "(",
   "tautomers",
   ")",
   "==",
   "len",
   "(",
   "done",
   ")",
   ":",
   "break",
   "else",
   ":",
   "log",
   ".",
   "warning",
   "(",
   "'Tautomer enumeration stopped at maximum %s'",
   ",",
   "self",
   ".",
   "max_tautomers",
   ")",
   "# Clean up stereochemistry",
   "for",
   "tautomer",
   "in",
   "tautomers",
   ".",
   "values",
   "(",
   ")",
   ":",
   "Chem",
   ".",
   "AssignStereochemistry",
   "(",
   "tautomer",
   ",",
   "force",
   "=",
   "True",
   ",",
   "cleanIt",
   "=",
   "True",
   ")",
   "for",
   "bond",
   "in",
   "tautomer",
   ".",
   "GetBonds",
   "(",
   ")",
   ":",
   "if",
   "bond",
   ".",
   "GetBondType",
   "(",
   ")",
   "==",
   "BondType",
   ".",
   "DOUBLE",
   "and",
   "bond",
   ".",
   "GetStereo",
   "(",
   ")",
   ">",
   "BondStereo",
   ".",
   "STEREOANY",
   ":",
   "begin",
   "=",
   "bond",
   ".",
   "GetBeginAtomIdx",
   "(",
   ")",
   "end",
   "=",
   "bond",
   ".",
   "GetEndAtomIdx",
   "(",
   ")",
   "for",
   "othertautomer",
   "in",
   "tautomers",
   ".",
   "values",
   "(",
   ")",
   ":",
   "if",
   "not",
   "othertautomer",
   ".",
   "GetBondBetweenAtoms",
   "(",
   "begin",
   ",",
   "end",
   ")",
   ".",
   "GetBondType",
   "(",
   ")",
   "==",
   "BondType",
   ".",
   "DOUBLE",
   ":",
   "neighbours",
   "=",
   "tautomer",
   ".",
   "GetAtomWithIdx",
   "(",
   "begin",
   ")",
   ".",
   "GetBonds",
   "(",
   ")",
   "+",
   "tautomer",
   ".",
   "GetAtomWithIdx",
   "(",
   "end",
   ")",
   ".",
   "GetBonds",
   "(",
   ")",
   "for",
   "otherbond",
   "in",
   "neighbours",
   ":",
   "if",
   "otherbond",
   ".",
   "GetBondDir",
   "(",
   ")",
   "in",
   "{",
   "BondDir",
   ".",
   "ENDUPRIGHT",
   ",",
   "BondDir",
   ".",
   "ENDDOWNRIGHT",
   "}",
   ":",
   "otherbond",
   ".",
   "SetBondDir",
   "(",
   "BondDir",
   ".",
   "NONE",
   ")",
   "Chem",
   ".",
   "AssignStereochemistry",
   "(",
   "tautomer",
   ",",
   "force",
   "=",
   "True",
   ",",
   "cleanIt",
   "=",
   "True",
   ")",
   "log",
   ".",
   "debug",
   "(",
   "'Removed stereochemistry from unfixed double bond'",
   ")",
   "break",
   "return",
   "list",
   "(",
   "tautomers",
   ".",
   "values",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-853",
  "nl_tokens": [
   "Format",
   "*",
   "data",
   "*",
   "and",
   "*",
   "headers",
   "*",
   "as",
   "an",
   "vertical",
   "table",
   "."
  ],
  "pl_tokens": [
   "def",
   "vertical_table",
   "(",
   "data",
   ",",
   "headers",
   ",",
   "sep_title",
   "=",
   "'{n}. row'",
   ",",
   "sep_character",
   "=",
   "'*'",
   ",",
   "sep_length",
   "=",
   "27",
   ")",
   ":",
   "header_len",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "headers",
   "]",
   ")",
   "padded_headers",
   "=",
   "[",
   "x",
   ".",
   "ljust",
   "(",
   "header_len",
   ")",
   "for",
   "x",
   "in",
   "headers",
   "]",
   "formatted_rows",
   "=",
   "[",
   "_format_row",
   "(",
   "padded_headers",
   ",",
   "row",
   ")",
   "for",
   "row",
   "in",
   "data",
   "]",
   "output",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "result",
   "in",
   "enumerate",
   "(",
   "formatted_rows",
   ")",
   ":",
   "yield",
   "_get_separator",
   "(",
   "i",
   ",",
   "sep_title",
   ",",
   "sep_character",
   ",",
   "sep_length",
   ")",
   "+",
   "result"
  ]
 },
 {
  "idx": "maxmin-854",
  "nl_tokens": [
   "Give",
   "the",
   "ref",
   "annotation",
   "after",
   "a",
   "time",
   ".",
   "If",
   "an",
   "annotation",
   "overlaps",
   "with",
   "ktime",
   "that",
   "annotation",
   "will",
   "be",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_ref_annotation_data_after_time",
   "(",
   "self",
   ",",
   "id_tier",
   ",",
   "time",
   ")",
   ":",
   "befores",
   "=",
   "self",
   ".",
   "get_ref_annotation_data_between_times",
   "(",
   "id_tier",
   ",",
   "time",
   ",",
   "self",
   ".",
   "get_full_time_interval",
   "(",
   ")",
   ")",
   "if",
   "befores",
   ":",
   "return",
   "[",
   "<mask>",
   "(",
   "befores",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   "]",
   "else",
   ":",
   "return",
   "[",
   "]"
  ]
 },
 {
  "idx": "maxmin-855",
  "nl_tokens": [
   "Check",
   "all",
   "API",
   "tokens",
   "defined",
   "and",
   "choose",
   "one",
   "with",
   "most",
   "remaining",
   "API",
   "points"
  ],
  "pl_tokens": [
   "def",
   "_choose_best_api_token",
   "(",
   "self",
   ")",
   ":",
   "# Return if no tokens given",
   "if",
   "self",
   ".",
   "n_tokens",
   "==",
   "0",
   ":",
   "return",
   "# If multiple tokens given, choose best",
   "token_idx",
   "=",
   "0",
   "if",
   "self",
   ".",
   "n_tokens",
   ">",
   "1",
   ":",
   "remainings",
   "=",
   "self",
   ".",
   "_get_tokens_rate_limits",
   "(",
   ")",
   "token_idx",
   "=",
   "remainings",
   ".",
   "index",
   "(",
   "<mask>",
   "(",
   "remainings",
   ")",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Remaining API points: {}, choosen index: {}\"",
   ".",
   "format",
   "(",
   "remainings",
   ",",
   "token_idx",
   ")",
   ")",
   "# If we have any tokens - use best of them",
   "self",
   ".",
   "current_token",
   "=",
   "self",
   ".",
   "tokens",
   "[",
   "token_idx",
   "]",
   "self",
   ".",
   "session",
   ".",
   "headers",
   ".",
   "update",
   "(",
   "{",
   "'Authorization'",
   ":",
   "'token '",
   "+",
   "self",
   ".",
   "current_token",
   "}",
   ")",
   "# Update rate limit data for the current token",
   "self",
   ".",
   "_update_current_rate_limit",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-856",
  "nl_tokens": [
   "Sets",
   "the",
   "rotation",
   "of",
   "this",
   "bone",
   "on",
   "the",
   "given",
   "entity",
   ".",
   "data",
   "is",
   "the",
   "entity",
   "to",
   "modify",
   "in",
   "dictionary",
   "form",
   ".",
   "rot",
   "is",
   "the",
   "rotation",
   "of",
   "the",
   "bone",
   "in",
   "the",
   "format",
   "used",
   "in",
   ":",
   "py",
   ":",
   "func",
   ":",
   "calcSphereCoordinates",
   "()",
   "\\",
   "."
  ],
  "pl_tokens": [
   "def",
   "setRot",
   "(",
   "self",
   ",",
   "data",
   ",",
   "rot",
   ")",
   ":",
   "self",
   ".",
   "ensureBones",
   "(",
   "data",
   ")",
   "rot",
   "=",
   "rot",
   "[",
   "0",
   "]",
   "%",
   "360",
   ",",
   "<mask>",
   "(",
   "-",
   "90",
   ",",
   "min",
   "(",
   "90",
   ",",
   "rot",
   "[",
   "1",
   "]",
   ")",
   ")",
   "data",
   "[",
   "\"_bones\"",
   "]",
   "[",
   "self",
   ".",
   "name",
   "]",
   "[",
   "\"rot\"",
   "]",
   "=",
   "rot"
  ]
 },
 {
  "idx": "maxmin-857",
  "nl_tokens": [
   "bandwidths",
   "are",
   "inaccurate",
   "as",
   "we",
   "don",
   "t",
   "account",
   "for",
   "parallel",
   "transfers",
   "here"
  ],
  "pl_tokens": [
   "def",
   "delay",
   "(",
   "self",
   ",",
   "sender",
   ",",
   "receiver",
   ",",
   "packet",
   ",",
   "add_delay",
   "=",
   "0",
   ")",
   ":",
   "bw",
   "=",
   "<mask>",
   "(",
   "sender",
   ".",
   "ul_bandwidth",
   ",",
   "receiver",
   ".",
   "dl_bandwidth",
   ")",
   "delay",
   "=",
   "sender",
   ".",
   "base_latency",
   "+",
   "receiver",
   ".",
   "base_latency",
   "delay",
   "+=",
   "len",
   "(",
   "packet",
   ")",
   "/",
   "bw",
   "delay",
   "+=",
   "add_delay",
   "return",
   "delay"
  ]
 },
 {
  "idx": "maxmin-858",
  "nl_tokens": [
   "TODO",
   ":",
   "Docstring",
   "for",
   "clean_multigame_features",
   "."
  ],
  "pl_tokens": [
   "def",
   "clean_multigame_features",
   "(",
   "df",
   ")",
   ":",
   "df",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "df",
   ")",
   "if",
   "df",
   ".",
   "index",
   ".",
   "value_counts",
   "(",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   ">",
   "1",
   ":",
   "df",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "df",
   "=",
   "clean_features",
   "(",
   "df",
   ")",
   "# if it's many games in one DataFrame, make poss_id and play_id unique",
   "for",
   "col",
   "in",
   "(",
   "'play_id'",
   ",",
   "'poss_id'",
   ")",
   ":",
   "diffs",
   "=",
   "df",
   "[",
   "col",
   "]",
   ".",
   "diff",
   "(",
   ")",
   ".",
   "fillna",
   "(",
   "0",
   ")",
   "if",
   "(",
   "diffs",
   "<",
   "0",
   ")",
   ".",
   "any",
   "(",
   ")",
   ":",
   "new_col",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "diffs",
   ".",
   "astype",
   "(",
   "bool",
   ")",
   ")",
   "df",
   ".",
   "eval",
   "(",
   "'{} = @new_col'",
   ".",
   "format",
   "(",
   "col",
   ")",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "return",
   "df"
  ]
 },
 {
  "idx": "maxmin-859",
  "nl_tokens": [
   "From",
   "a",
   "dataset",
   "containing",
   "dates",
   "in",
   "a",
   "column",
   "return",
   "a",
   "dataset",
   "with",
   "at",
   "least",
   "3",
   "columns",
   ":",
   "-",
   "DATE",
   ":",
   "Label",
   "of",
   "date",
   "-",
   "DATETIME",
   ":",
   "Date",
   "in",
   "datetime",
   "dtype",
   "-",
   "GRANULARITY",
   ":",
   "Granularity",
   "of",
   "date"
  ],
  "pl_tokens": [
   "def",
   "date_requester_generator",
   "(",
   "df",
   ":",
   "pd",
   ".",
   "DataFrame",
   ",",
   "date_column",
   ":",
   "str",
   ",",
   "frequency",
   ":",
   "str",
   ",",
   "date_column_format",
   ":",
   "str",
   "=",
   "None",
   ",",
   "format",
   ":",
   "str",
   "=",
   "'%Y-%m-%d'",
   ",",
   "granularities",
   ":",
   "Dict",
   "[",
   "str",
   ",",
   "str",
   "]",
   "=",
   "None",
   ",",
   "others_format",
   ":",
   "Dict",
   "[",
   "str",
   ",",
   "str",
   "]",
   "=",
   "None",
   ",",
   "times_delta",
   ":",
   "Dict",
   "[",
   "str",
   ",",
   "str",
   "]",
   "=",
   "None",
   ")",
   "->",
   "pd",
   ".",
   "DataFrame",
   ":",
   "start_date",
   "=",
   "pd",
   ".",
   "to_datetime",
   "(",
   "df",
   "[",
   "date_column",
   "]",
   ",",
   "format",
   "=",
   "date_column_format",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "end_date",
   "=",
   "pd",
   ".",
   "to_datetime",
   "(",
   "df",
   "[",
   "date_column",
   "]",
   ",",
   "format",
   "=",
   "date_column_format",
   ")",
   ".",
   "max",
   "(",
   ")",
   "granularities",
   "=",
   "granularities",
   "or",
   "{",
   "'date'",
   ":",
   "format",
   "}",
   "others_format",
   "=",
   "others_format",
   "or",
   "{",
   "}",
   "times_delta",
   "=",
   "times_delta",
   "or",
   "{",
   "}",
   "# Base DataFrame",
   "columns_list",
   "=",
   "[",
   "'DATE'",
   ",",
   "'DATETIME'",
   ",",
   "'GRANULARITY'",
   ",",
   "*",
   "others_format",
   ",",
   "*",
   "times_delta",
   "]",
   "result_df",
   "=",
   "{",
   "col_name",
   ":",
   "[",
   "]",
   "for",
   "col_name",
   "in",
   "columns_list",
   "}",
   "# Generate the range",
   "date_range",
   "=",
   "pd",
   ".",
   "date_range",
   "(",
   "start",
   "=",
   "start_date",
   ",",
   "end",
   "=",
   "end_date",
   ",",
   "freq",
   "=",
   "frequency",
   ")",
   "for",
   "granularity_name",
   ",",
   "granularity_format",
   "in",
   "granularities",
   ".",
   "items",
   "(",
   ")",
   ":",
   "date_range_label",
   "=",
   "date_range",
   ".",
   "strftime",
   "(",
   "granularity_format",
   ")",
   "a",
   "=",
   "list",
   "(",
   "set",
   "(",
   "date_range_label",
   ")",
   ")",
   "index_unique",
   "=",
   "list",
   "(",
   "set",
   "(",
   "[",
   "a",
   ".",
   "index",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "date_range_label",
   "]",
   ")",
   ")",
   "date_range_datetime",
   "=",
   "date_range",
   "[",
   "index_unique",
   "]",
   "date_range_label",
   "=",
   "date_range_label",
   ".",
   "unique",
   "(",
   ")",
   "result_df",
   "[",
   "'DATE'",
   "]",
   "+=",
   "list",
   "(",
   "date_range_label",
   ")",
   "result_df",
   "[",
   "'DATETIME'",
   "]",
   "+=",
   "list",
   "(",
   "date_range_datetime",
   ")",
   "result_df",
   "[",
   "'GRANULARITY'",
   "]",
   "+=",
   "[",
   "granularity_name",
   "]",
   "*",
   "len",
   "(",
   "date_range_label",
   ")",
   "for",
   "col_name",
   ",",
   "other_format",
   "in",
   "others_format",
   ".",
   "items",
   "(",
   ")",
   ":",
   "result_df",
   "[",
   "col_name",
   "]",
   "+=",
   "list",
   "(",
   "date_range_datetime",
   ".",
   "strftime",
   "(",
   "other_format",
   ")",
   ")",
   "for",
   "col_name",
   ",",
   "time_delta",
   "in",
   "times_delta",
   ".",
   "items",
   "(",
   ")",
   ":",
   "result_df",
   "[",
   "col_name",
   "]",
   "+=",
   "list",
   "(",
   "(",
   "date_range_datetime",
   "+",
   "pd",
   ".",
   "Timedelta",
   "(",
   "time_delta",
   ")",
   ")",
   ".",
   "strftime",
   "(",
   "granularity_format",
   ")",
   ")",
   "return",
   "pd",
   ".",
   "DataFrame",
   "(",
   "result_df",
   ")"
  ]
 },
 {
  "idx": "maxmin-860",
  "nl_tokens": [
   "Converts",
   "branch",
   "length",
   "to",
   "years",
   "and",
   "plots",
   "the",
   "time",
   "tree",
   "on",
   "a",
   "time",
   "axis",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_vs_years",
   "(",
   "tt",
   ",",
   "step",
   "=",
   "None",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "confidence",
   "=",
   "None",
   ",",
   "ticks",
   "=",
   "True",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "tt",
   ".",
   "branch_length_to_years",
   "(",
   ")",
   "nleafs",
   "=",
   "tt",
   ".",
   "tree",
   ".",
   "count_terminals",
   "(",
   ")",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "12",
   ",",
   "10",
   ")",
   ")",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "111",
   ")",
   "else",
   ":",
   "fig",
   "=",
   "None",
   "# draw tree",
   "if",
   "\"label_func\"",
   "not",
   "in",
   "kwargs",
   ":",
   "kwargs",
   "[",
   "\"label_func\"",
   "]",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   ".",
   "name",
   "if",
   "(",
   "x",
   ".",
   "is_terminal",
   "(",
   ")",
   "and",
   "nleafs",
   "<",
   "30",
   ")",
   "else",
   "\"\"",
   "Phylo",
   ".",
   "draw",
   "(",
   "tt",
   ".",
   "tree",
   ",",
   "axes",
   "=",
   "ax",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "offset",
   "=",
   "tt",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "numdate",
   "-",
   "tt",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "branch_length",
   "date_range",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "n",
   ".",
   "numdate",
   "for",
   "n",
   "in",
   "tt",
   ".",
   "tree",
   ".",
   "get_terminals",
   "(",
   ")",
   "]",
   ")",
   "-",
   "offset",
   "# estimate year intervals if not explicitly specified",
   "if",
   "step",
   "is",
   "None",
   "or",
   "(",
   "step",
   ">",
   "0",
   "and",
   "date_range",
   "/",
   "step",
   ">",
   "100",
   ")",
   ":",
   "step",
   "=",
   "10",
   "**",
   "np",
   ".",
   "floor",
   "(",
   "np",
   ".",
   "log10",
   "(",
   "date_range",
   ")",
   ")",
   "if",
   "date_range",
   "/",
   "step",
   "<",
   "2",
   ":",
   "step",
   "/=",
   "5",
   "elif",
   "date_range",
   "/",
   "step",
   "<",
   "5",
   ":",
   "step",
   "/=",
   "2",
   "step",
   "=",
   "max",
   "(",
   "1.0",
   "/",
   "12",
   ",",
   "step",
   ")",
   "# set axis labels",
   "if",
   "step",
   ":",
   "dtick",
   "=",
   "step",
   "min_tick",
   "=",
   "step",
   "*",
   "(",
   "offset",
   "//",
   "step",
   ")",
   "extra",
   "=",
   "dtick",
   "if",
   "dtick",
   "<",
   "date_range",
   "else",
   "dtick",
   "tick_vals",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "min_tick",
   ",",
   "min_tick",
   "+",
   "date_range",
   "+",
   "extra",
   ",",
   "dtick",
   ")",
   "xticks",
   "=",
   "tick_vals",
   "-",
   "offset",
   "else",
   ":",
   "xticks",
   "=",
   "ax",
   ".",
   "get_xticks",
   "(",
   ")",
   "dtick",
   "=",
   "xticks",
   "[",
   "1",
   "]",
   "-",
   "xticks",
   "[",
   "0",
   "]",
   "shift",
   "=",
   "offset",
   "-",
   "dtick",
   "*",
   "(",
   "offset",
   "//",
   "dtick",
   ")",
   "xticks",
   "-=",
   "shift",
   "tick_vals",
   "=",
   "[",
   "x",
   "+",
   "offset",
   "-",
   "shift",
   "for",
   "x",
   "in",
   "xticks",
   "]",
   "ax",
   ".",
   "set_xticks",
   "(",
   "xticks",
   ")",
   "ax",
   ".",
   "set_xticklabels",
   "(",
   "map",
   "(",
   "str",
   ",",
   "tick_vals",
   ")",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "'year'",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "''",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "0",
   ",",
   "date_range",
   ")",
   ")",
   "# put shaded boxes to delineate years",
   "if",
   "step",
   ":",
   "ylim",
   "=",
   "ax",
   ".",
   "get_ylim",
   "(",
   ")",
   "xlim",
   "=",
   "ax",
   ".",
   "get_xlim",
   "(",
   ")",
   "from",
   "matplotlib",
   ".",
   "patches",
   "import",
   "Rectangle",
   "for",
   "yi",
   ",",
   "year",
   "in",
   "enumerate",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "np",
   ".",
   "floor",
   "(",
   "tick_vals",
   "[",
   "0",
   "]",
   ")",
   ",",
   "tick_vals",
   "[",
   "-",
   "1",
   "]",
   "+",
   ".01",
   ",",
   "step",
   ")",
   ")",
   ":",
   "pos",
   "=",
   "year",
   "-",
   "offset",
   "r",
   "=",
   "Rectangle",
   "(",
   "(",
   "pos",
   ",",
   "ylim",
   "[",
   "1",
   "]",
   "-",
   "5",
   ")",
   ",",
   "step",
   ",",
   "ylim",
   "[",
   "0",
   "]",
   "-",
   "ylim",
   "[",
   "1",
   "]",
   "+",
   "10",
   ",",
   "facecolor",
   "=",
   "[",
   "0.7",
   "+",
   "0.1",
   "*",
   "(",
   "1",
   "+",
   "yi",
   "%",
   "2",
   ")",
   "]",
   "*",
   "3",
   ",",
   "edgecolor",
   "=",
   "[",
   "1",
   ",",
   "1",
   ",",
   "1",
   "]",
   ")",
   "ax",
   ".",
   "add_patch",
   "(",
   "r",
   ")",
   "if",
   "year",
   "in",
   "tick_vals",
   "and",
   "pos",
   ">=",
   "xlim",
   "[",
   "0",
   "]",
   "and",
   "pos",
   "<=",
   "xlim",
   "[",
   "1",
   "]",
   "and",
   "ticks",
   ":",
   "label_str",
   "=",
   "str",
   "(",
   "step",
   "*",
   "(",
   "year",
   "//",
   "step",
   ")",
   ")",
   "if",
   "step",
   "<",
   "1",
   "else",
   "str",
   "(",
   "int",
   "(",
   "year",
   ")",
   ")",
   "ax",
   ".",
   "text",
   "(",
   "pos",
   ",",
   "ylim",
   "[",
   "0",
   "]",
   "-",
   "0.04",
   "*",
   "(",
   "ylim",
   "[",
   "1",
   "]",
   "-",
   "ylim",
   "[",
   "0",
   "]",
   ")",
   ",",
   "label_str",
   ",",
   "horizontalalignment",
   "=",
   "'center'",
   ")",
   "ax",
   ".",
   "set_axis_off",
   "(",
   ")",
   "# add confidence intervals to the tree graph -- grey bars",
   "if",
   "confidence",
   ":",
   "tree_layout",
   "(",
   "tt",
   ".",
   "tree",
   ")",
   "if",
   "not",
   "hasattr",
   "(",
   "tt",
   ".",
   "tree",
   ".",
   "root",
   ",",
   "\"marginal_inverse_cdf\"",
   ")",
   ":",
   "print",
   "(",
   "\"marginal time tree reconstruction required for confidence intervals\"",
   ")",
   "return",
   "ttconf",
   ".",
   "ERROR",
   "elif",
   "type",
   "(",
   "confidence",
   ")",
   "is",
   "float",
   ":",
   "cfunc",
   "=",
   "tt",
   ".",
   "get_max_posterior_region",
   "elif",
   "len",
   "(",
   "confidence",
   ")",
   "==",
   "2",
   ":",
   "cfunc",
   "=",
   "tt",
   ".",
   "get_confidence_interval",
   "else",
   ":",
   "print",
   "(",
   "\"confidence needs to be either a float (for max posterior region) or a two numbers specifying lower and upper bounds\"",
   ")",
   "return",
   "ttconf",
   ".",
   "ERROR",
   "for",
   "n",
   "in",
   "tt",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "pos",
   "=",
   "cfunc",
   "(",
   "n",
   ",",
   "confidence",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "pos",
   "-",
   "offset",
   ",",
   "np",
   ".",
   "ones",
   "(",
   "len",
   "(",
   "pos",
   ")",
   ")",
   "*",
   "n",
   ".",
   "ypos",
   ",",
   "lw",
   "=",
   "3",
   ",",
   "c",
   "=",
   "(",
   "0.5",
   ",",
   "0.5",
   ",",
   "0.5",
   ")",
   ")",
   "return",
   "fig",
   ",",
   "ax"
  ]
 },
 {
  "idx": "maxmin-861",
  "nl_tokens": [
   "Calculates",
   "F",
   "-",
   "1",
   "score",
   "between",
   "y_true",
   "and",
   "y_predicted",
   "F",
   "-",
   "1",
   "score",
   "uses",
   "the",
   "best",
   "matching",
   "y_true",
   "answer"
  ],
  "pl_tokens": [
   "def",
   "squad_v2_f1",
   "(",
   "y_true",
   ":",
   "List",
   "[",
   "List",
   "[",
   "str",
   "]",
   "]",
   ",",
   "y_predicted",
   ":",
   "List",
   "[",
   "str",
   "]",
   ")",
   "->",
   "float",
   ":",
   "f1_total",
   "=",
   "0.0",
   "for",
   "ground_truth",
   ",",
   "prediction",
   "in",
   "zip",
   "(",
   "y_true",
   ",",
   "y_predicted",
   ")",
   ":",
   "prediction_tokens",
   "=",
   "normalize_answer",
   "(",
   "prediction",
   ")",
   ".",
   "split",
   "(",
   ")",
   "f1s",
   "=",
   "[",
   "]",
   "for",
   "gt",
   "in",
   "ground_truth",
   ":",
   "gt_tokens",
   "=",
   "normalize_answer",
   "(",
   "gt",
   ")",
   ".",
   "split",
   "(",
   ")",
   "if",
   "len",
   "(",
   "gt_tokens",
   ")",
   "==",
   "0",
   "or",
   "len",
   "(",
   "prediction_tokens",
   ")",
   "==",
   "0",
   ":",
   "f1s",
   ".",
   "append",
   "(",
   "float",
   "(",
   "gt_tokens",
   "==",
   "prediction_tokens",
   ")",
   ")",
   "continue",
   "common",
   "=",
   "Counter",
   "(",
   "prediction_tokens",
   ")",
   "&",
   "Counter",
   "(",
   "gt_tokens",
   ")",
   "num_same",
   "=",
   "sum",
   "(",
   "common",
   ".",
   "values",
   "(",
   ")",
   ")",
   "if",
   "num_same",
   "==",
   "0",
   ":",
   "f1s",
   ".",
   "append",
   "(",
   "0.0",
   ")",
   "continue",
   "precision",
   "=",
   "1.0",
   "*",
   "num_same",
   "/",
   "len",
   "(",
   "prediction_tokens",
   ")",
   "recall",
   "=",
   "1.0",
   "*",
   "num_same",
   "/",
   "len",
   "(",
   "gt_tokens",
   ")",
   "f1",
   "=",
   "(",
   "2",
   "*",
   "precision",
   "*",
   "recall",
   ")",
   "/",
   "(",
   "precision",
   "+",
   "recall",
   ")",
   "f1s",
   ".",
   "append",
   "(",
   "f1",
   ")",
   "f1_total",
   "+=",
   "<mask>",
   "(",
   "f1s",
   ")",
   "return",
   "100",
   "*",
   "f1_total",
   "/",
   "len",
   "(",
   "y_true",
   ")",
   "if",
   "len",
   "(",
   "y_true",
   ")",
   ">",
   "0",
   "else",
   "0"
  ]
 },
 {
  "idx": "maxmin-862",
  "nl_tokens": [
   "Function",
   "to",
   "resolve",
   "polytomies",
   "for",
   "a",
   "given",
   "parent",
   "node",
   ".",
   "If",
   "the",
   "number",
   "of",
   "the",
   "direct",
   "decendants",
   "is",
   "less",
   "than",
   "three",
   "(",
   "not",
   "a",
   "polytomy",
   ")",
   "does",
   "nothing",
   ".",
   "Otherwise",
   "for",
   "each",
   "pair",
   "of",
   "nodes",
   "assess",
   "the",
   "possible",
   "LH",
   "increase",
   "which",
   "could",
   "be",
   "gained",
   "by",
   "merging",
   "the",
   "two",
   "nodes",
   ".",
   "The",
   "increase",
   "in",
   "the",
   "LH",
   "is",
   "basically",
   "the",
   "tradeoff",
   "between",
   "the",
   "gain",
   "of",
   "the",
   "LH",
   "due",
   "to",
   "the",
   "changing",
   "the",
   "branch",
   "lenghts",
   "towards",
   "the",
   "optimal",
   "values",
   "and",
   "the",
   "decrease",
   "due",
   "to",
   "the",
   "introduction",
   "of",
   "the",
   "new",
   "branch",
   "with",
   "zero",
   "optimal",
   "length",
   "."
  ],
  "pl_tokens": [
   "def",
   "_poly",
   "(",
   "self",
   ",",
   "clade",
   ",",
   "merge_compressed",
   ")",
   ":",
   "from",
   ".",
   "branch_len_interpolator",
   "import",
   "BranchLenInterpolator",
   "zero_branch_slope",
   "=",
   "self",
   ".",
   "gtr",
   ".",
   "mu",
   "*",
   "self",
   ".",
   "seq_len",
   "def",
   "_c_gain",
   "(",
   "t",
   ",",
   "n1",
   ",",
   "n2",
   ",",
   "parent",
   ")",
   ":",
   "\"\"\"\n            cost gain if nodes n1, n2 are joined and their parent is placed at time t\n            cost gain = (LH loss now) - (LH loss when placed at time t)\n            \"\"\"",
   "cg2",
   "=",
   "n2",
   ".",
   "branch_length_interpolator",
   "(",
   "parent",
   ".",
   "time_before_present",
   "-",
   "n2",
   ".",
   "time_before_present",
   ")",
   "-",
   "n2",
   ".",
   "branch_length_interpolator",
   "(",
   "t",
   "-",
   "n2",
   ".",
   "time_before_present",
   ")",
   "cg1",
   "=",
   "n1",
   ".",
   "branch_length_interpolator",
   "(",
   "parent",
   ".",
   "time_before_present",
   "-",
   "n1",
   ".",
   "time_before_present",
   ")",
   "-",
   "n1",
   ".",
   "branch_length_interpolator",
   "(",
   "t",
   "-",
   "n1",
   ".",
   "time_before_present",
   ")",
   "cg_new",
   "=",
   "-",
   "zero_branch_slope",
   "*",
   "(",
   "parent",
   ".",
   "time_before_present",
   "-",
   "t",
   ")",
   "# loss in LH due to the new branch",
   "return",
   "-",
   "(",
   "cg2",
   "+",
   "cg1",
   "+",
   "cg_new",
   ")",
   "def",
   "cost_gain",
   "(",
   "n1",
   ",",
   "n2",
   ",",
   "parent",
   ")",
   ":",
   "\"\"\"\n            cost gained if the two nodes would have been connected.\n            \"\"\"",
   "try",
   ":",
   "cg",
   "=",
   "sciopt",
   ".",
   "minimize_scalar",
   "(",
   "_c_gain",
   ",",
   "bounds",
   "=",
   "[",
   "<mask>",
   "(",
   "n1",
   ".",
   "time_before_present",
   ",",
   "n2",
   ".",
   "time_before_present",
   ")",
   ",",
   "parent",
   ".",
   "time_before_present",
   "]",
   ",",
   "method",
   "=",
   "'Bounded'",
   ",",
   "args",
   "=",
   "(",
   "n1",
   ",",
   "n2",
   ",",
   "parent",
   ")",
   ")",
   "return",
   "cg",
   "[",
   "'x'",
   "]",
   ",",
   "-",
   "cg",
   "[",
   "'fun'",
   "]",
   "except",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeTime._poly.cost_gain: optimization of gain failed\"",
   ",",
   "3",
   ",",
   "warn",
   "=",
   "True",
   ")",
   "return",
   "parent",
   ".",
   "time_before_present",
   ",",
   "0.0",
   "def",
   "merge_nodes",
   "(",
   "source_arr",
   ",",
   "isall",
   "=",
   "False",
   ")",
   ":",
   "mergers",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "cost_gain",
   "(",
   "n1",
   ",",
   "n2",
   ",",
   "clade",
   ")",
   "if",
   "i1",
   "<",
   "i2",
   "else",
   "(",
   "0.0",
   ",",
   "-",
   "1.0",
   ")",
   "for",
   "i1",
   ",",
   "n1",
   "in",
   "enumerate",
   "(",
   "source_arr",
   ")",
   "]",
   "for",
   "i2",
   ",",
   "n2",
   "in",
   "enumerate",
   "(",
   "source_arr",
   ")",
   "]",
   ")",
   "LH",
   "=",
   "0",
   "while",
   "len",
   "(",
   "source_arr",
   ")",
   ">",
   "1",
   "+",
   "int",
   "(",
   "isall",
   ")",
   ":",
   "# max possible gains of the cost when connecting the nodes:",
   "# this is only a rough approximation because it assumes the new node positions",
   "# to be optimal",
   "new_positions",
   "=",
   "mergers",
   "[",
   ":",
   ",",
   ":",
   ",",
   "0",
   "]",
   "cost_gains",
   "=",
   "mergers",
   "[",
   ":",
   ",",
   ":",
   ",",
   "1",
   "]",
   "# set zero to large negative value and find optimal pair",
   "np",
   ".",
   "fill_diagonal",
   "(",
   "cost_gains",
   ",",
   "-",
   "1e11",
   ")",
   "idxs",
   "=",
   "np",
   ".",
   "unravel_index",
   "(",
   "cost_gains",
   ".",
   "argmax",
   "(",
   ")",
   ",",
   "cost_gains",
   ".",
   "shape",
   ")",
   "if",
   "(",
   "idxs",
   "[",
   "0",
   "]",
   "==",
   "idxs",
   "[",
   "1",
   "]",
   ")",
   "or",
   "cost_gains",
   ".",
   "max",
   "(",
   ")",
   "<",
   "0",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeTime._poly.merge_nodes: node is not fully resolved \"",
   "+",
   "clade",
   ".",
   "name",
   ",",
   "4",
   ")",
   "return",
   "LH",
   "n1",
   ",",
   "n2",
   "=",
   "source_arr",
   "[",
   "idxs",
   "[",
   "0",
   "]",
   "]",
   ",",
   "source_arr",
   "[",
   "idxs",
   "[",
   "1",
   "]",
   "]",
   "LH",
   "+=",
   "cost_gains",
   "[",
   "idxs",
   "]",
   "new_node",
   "=",
   "Phylo",
   ".",
   "BaseTree",
   ".",
   "Clade",
   "(",
   ")",
   "# fix positions and branch lengths",
   "new_node",
   ".",
   "time_before_present",
   "=",
   "new_positions",
   "[",
   "idxs",
   "]",
   "new_node",
   ".",
   "branch_length",
   "=",
   "clade",
   ".",
   "time_before_present",
   "-",
   "new_node",
   ".",
   "time_before_present",
   "new_node",
   ".",
   "clades",
   "=",
   "[",
   "n1",
   ",",
   "n2",
   "]",
   "n1",
   ".",
   "branch_length",
   "=",
   "new_node",
   ".",
   "time_before_present",
   "-",
   "n1",
   ".",
   "time_before_present",
   "n2",
   ".",
   "branch_length",
   "=",
   "new_node",
   ".",
   "time_before_present",
   "-",
   "n2",
   ".",
   "time_before_present",
   "# set parameters for the new node",
   "new_node",
   ".",
   "up",
   "=",
   "clade",
   "n1",
   ".",
   "up",
   "=",
   "new_node",
   "n2",
   ".",
   "up",
   "=",
   "new_node",
   "if",
   "hasattr",
   "(",
   "clade",
   ",",
   "\"cseq\"",
   ")",
   ":",
   "new_node",
   ".",
   "cseq",
   "=",
   "clade",
   ".",
   "cseq",
   "self",
   ".",
   "_store_compressed_sequence_to_node",
   "(",
   "new_node",
   ")",
   "new_node",
   ".",
   "mutations",
   "=",
   "[",
   "]",
   "new_node",
   ".",
   "mutation_length",
   "=",
   "0.0",
   "new_node",
   ".",
   "branch_length_interpolator",
   "=",
   "BranchLenInterpolator",
   "(",
   "new_node",
   ",",
   "self",
   ".",
   "gtr",
   ",",
   "one_mutation",
   "=",
   "self",
   ".",
   "one_mutation",
   ",",
   "branch_length_mode",
   "=",
   "self",
   ".",
   "branch_length_mode",
   ")",
   "clade",
   ".",
   "clades",
   ".",
   "remove",
   "(",
   "n1",
   ")",
   "clade",
   ".",
   "clades",
   ".",
   "remove",
   "(",
   "n2",
   ")",
   "clade",
   ".",
   "clades",
   ".",
   "append",
   "(",
   "new_node",
   ")",
   "self",
   ".",
   "logger",
   "(",
   "'TreeTime._poly.merge_nodes: creating new node as child of '",
   "+",
   "clade",
   ".",
   "name",
   ",",
   "3",
   ")",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeTime._poly.merge_nodes: Delta-LH = \"",
   "+",
   "str",
   "(",
   "cost_gains",
   "[",
   "idxs",
   "]",
   ".",
   "round",
   "(",
   "3",
   ")",
   ")",
   ",",
   "3",
   ")",
   "# and modify source_arr array for the next loop",
   "if",
   "len",
   "(",
   "source_arr",
   ")",
   ">",
   "2",
   ":",
   "# if more than 3 nodes in polytomy, replace row/column",
   "for",
   "ii",
   "in",
   "np",
   ".",
   "sort",
   "(",
   "idxs",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ":",
   "tmp_ind",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "mergers",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "!=",
   "ii",
   "mergers",
   "=",
   "mergers",
   "[",
   "tmp_ind",
   "]",
   ".",
   "swapaxes",
   "(",
   "0",
   ",",
   "1",
   ")",
   "mergers",
   "=",
   "mergers",
   "[",
   "tmp_ind",
   "]",
   ".",
   "swapaxes",
   "(",
   "0",
   ",",
   "1",
   ")",
   "source_arr",
   ".",
   "remove",
   "(",
   "n1",
   ")",
   "source_arr",
   ".",
   "remove",
   "(",
   "n2",
   ")",
   "new_gains",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "cost_gain",
   "(",
   "n1",
   ",",
   "new_node",
   ",",
   "clade",
   ")",
   "for",
   "n1",
   "in",
   "source_arr",
   "]",
   "]",
   ")",
   "mergers",
   "=",
   "np",
   ".",
   "vstack",
   "(",
   "(",
   "mergers",
   ",",
   "new_gains",
   ")",
   ")",
   ".",
   "swapaxes",
   "(",
   "0",
   ",",
   "1",
   ")",
   "source_arr",
   ".",
   "append",
   "(",
   "new_node",
   ")",
   "new_gains",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "cost_gain",
   "(",
   "n1",
   ",",
   "new_node",
   ",",
   "clade",
   ")",
   "for",
   "n1",
   "in",
   "source_arr",
   "]",
   "]",
   ")",
   "mergers",
   "=",
   "np",
   ".",
   "vstack",
   "(",
   "(",
   "mergers",
   ",",
   "new_gains",
   ")",
   ")",
   ".",
   "swapaxes",
   "(",
   "0",
   ",",
   "1",
   ")",
   "else",
   ":",
   "# otherwise just recalculate matrix",
   "source_arr",
   ".",
   "remove",
   "(",
   "n1",
   ")",
   "source_arr",
   ".",
   "remove",
   "(",
   "n2",
   ")",
   "source_arr",
   ".",
   "append",
   "(",
   "new_node",
   ")",
   "mergers",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "[",
   "cost_gain",
   "(",
   "n1",
   ",",
   "n2",
   ",",
   "clade",
   ")",
   "for",
   "n1",
   "in",
   "source_arr",
   "]",
   "for",
   "n2",
   "in",
   "source_arr",
   "]",
   ")",
   "return",
   "LH",
   "stretched",
   "=",
   "[",
   "c",
   "for",
   "c",
   "in",
   "clade",
   ".",
   "clades",
   "if",
   "c",
   ".",
   "mutation_length",
   "<",
   "c",
   ".",
   "clock_length",
   "]",
   "compressed",
   "=",
   "[",
   "c",
   "for",
   "c",
   "in",
   "clade",
   ".",
   "clades",
   "if",
   "c",
   "not",
   "in",
   "stretched",
   "]",
   "if",
   "len",
   "(",
   "stretched",
   ")",
   "==",
   "1",
   "and",
   "merge_compressed",
   "is",
   "False",
   ":",
   "return",
   "0.0",
   "LH",
   "=",
   "merge_nodes",
   "(",
   "stretched",
   ",",
   "isall",
   "=",
   "len",
   "(",
   "stretched",
   ")",
   "==",
   "len",
   "(",
   "clade",
   ".",
   "clades",
   ")",
   ")",
   "if",
   "merge_compressed",
   "and",
   "len",
   "(",
   "compressed",
   ")",
   ">",
   "1",
   ":",
   "LH",
   "+=",
   "merge_nodes",
   "(",
   "compressed",
   ",",
   "isall",
   "=",
   "len",
   "(",
   "compressed",
   ")",
   "==",
   "len",
   "(",
   "clade",
   ".",
   "clades",
   ")",
   ")",
   "return",
   "LH"
  ]
 },
 {
  "idx": "maxmin-863",
  "nl_tokens": [
   "Get",
   "a",
   "block",
   "of",
   "data",
   "from",
   "the",
   "node",
   "at",
   "path",
   "."
  ],
  "pl_tokens": [
   "def",
   "__get_batch",
   "(",
   "self",
   ",",
   "path",
   ",",
   "length",
   ",",
   "last",
   "=",
   "False",
   ")",
   ":",
   "import",
   "tables",
   "h5_file",
   "=",
   "tables",
   ".",
   "open_file",
   "(",
   "self",
   ".",
   "filename",
   ",",
   "'r'",
   ")",
   "h5_node",
   "=",
   "h5_file",
   ".",
   "get_node",
   "(",
   "path",
   ")",
   "if",
   "len",
   "(",
   "h5_node",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Cannot read from empty dataset.\"",
   ")",
   "# If the length isn't specified, then fall back to default values.",
   "if",
   "length",
   "is",
   "None",
   ":",
   "chunkshape",
   "=",
   "h5_node",
   ".",
   "chunkshape",
   "# If the array isn't chunked, then try to make the block close to 128KB.",
   "if",
   "chunkshape",
   "is",
   "None",
   ":",
   "default_length",
   "=",
   "128",
   "*",
   "2",
   "**",
   "10",
   "//",
   "h5_node",
   "[",
   "0",
   "]",
   ".",
   "nbytes",
   "# Divides by one row of the dataset.",
   "length",
   "=",
   "<mask>",
   "(",
   "h5_node",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "default_length",
   ")",
   "# If it is chunked, then use the chunkshape for best performance.",
   "else",
   ":",
   "length",
   "=",
   "chunkshape",
   "[",
   "0",
   "]",
   "if",
   "last",
   ":",
   "example",
   "=",
   "h5_node",
   "[",
   "length",
   "*",
   "(",
   "len",
   "(",
   "h5_node",
   ")",
   "//",
   "length",
   ")",
   ":",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "else",
   ":",
   "example",
   "=",
   "h5_node",
   "[",
   ":",
   "length",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "h5_file",
   ".",
   "close",
   "(",
   ")",
   "return",
   "example"
  ]
 },
 {
  "idx": "maxmin-864",
  "nl_tokens": [
   "If",
   "temporal",
   "reconstruction",
   "was",
   "done",
   "using",
   "the",
   "marginal",
   "ML",
   "mode",
   "the",
   "entire",
   "distribution",
   "of",
   "times",
   "is",
   "available",
   ".",
   "This",
   "function",
   "determines",
   "the",
   "interval",
   "around",
   "the",
   "highest",
   "posterior",
   "probability",
   "region",
   "that",
   "contains",
   "the",
   "specified",
   "fraction",
   "of",
   "the",
   "probability",
   "mass",
   ".",
   "In",
   "absense",
   "of",
   "marginal",
   "reconstruction",
   "it",
   "will",
   "return",
   "uncertainty",
   "based",
   "on",
   "rate",
   "variation",
   ".",
   "If",
   "both",
   "are",
   "present",
   "the",
   "wider",
   "interval",
   "will",
   "be",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_max_posterior_region",
   "(",
   "self",
   ",",
   "node",
   ",",
   "fraction",
   "=",
   "0.9",
   ")",
   ":",
   "if",
   "node",
   ".",
   "marginal_inverse_cdf",
   "==",
   "\"delta\"",
   ":",
   "return",
   "np",
   ".",
   "array",
   "(",
   "[",
   "node",
   ".",
   "numdate",
   ",",
   "node",
   ".",
   "numdate",
   "]",
   ")",
   "min_max",
   "=",
   "(",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "xmin",
   ",",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "xmax",
   ")",
   "min_date",
   ",",
   "max_date",
   "=",
   "[",
   "self",
   ".",
   "date2dist",
   ".",
   "to_numdate",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "min_max",
   "]",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "if",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "peak_pos",
   "==",
   "min_max",
   "[",
   "0",
   "]",
   ":",
   "#peak on the left",
   "return",
   "self",
   ".",
   "get_confidence_interval",
   "(",
   "node",
   ",",
   "(",
   "0",
   ",",
   "fraction",
   ")",
   ")",
   "elif",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "peak_pos",
   "==",
   "min_max",
   "[",
   "1",
   "]",
   ":",
   "#peak on the right",
   "return",
   "self",
   ".",
   "get_confidence_interval",
   "(",
   "node",
   ",",
   "(",
   "1.0",
   "-",
   "fraction",
   ",",
   "1.0",
   ")",
   ")",
   "else",
   ":",
   "# peak in the center of the distribution",
   "rate_contribution",
   "=",
   "self",
   ".",
   "date_uncertainty_due_to_rate",
   "(",
   "node",
   ",",
   "(",
   "(",
   "1",
   "-",
   "fraction",
   ")",
   "*",
   "0.5",
   ",",
   "1.0",
   "-",
   "(",
   "1.0",
   "-",
   "fraction",
   ")",
   "*",
   "0.5",
   ")",
   ")",
   "# construct height to position interpolators left and right of the peak",
   "# this assumes there is only one peak --- might fail in odd cases",
   "from",
   "scipy",
   ".",
   "interpolate",
   "import",
   "interp1d",
   "from",
   "scipy",
   ".",
   "optimize",
   "import",
   "minimize_scalar",
   "as",
   "minimize",
   "pidx",
   "=",
   "np",
   ".",
   "argmin",
   "(",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "y",
   ")",
   "pval",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "y",
   ")",
   "left",
   "=",
   "interp1d",
   "(",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "y",
   "[",
   ":",
   "(",
   "pidx",
   "+",
   "1",
   ")",
   "]",
   "-",
   "pval",
   ",",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "x",
   "[",
   ":",
   "(",
   "pidx",
   "+",
   "1",
   ")",
   "]",
   ",",
   "kind",
   "=",
   "'linear'",
   ",",
   "fill_value",
   "=",
   "min_max",
   "[",
   "0",
   "]",
   ",",
   "bounds_error",
   "=",
   "False",
   ")",
   "right",
   "=",
   "interp1d",
   "(",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "y",
   "[",
   "pidx",
   ":",
   "]",
   "-",
   "pval",
   ",",
   "node",
   ".",
   "marginal_pos_LH",
   ".",
   "x",
   "[",
   "pidx",
   ":",
   "]",
   ",",
   "kind",
   "=",
   "'linear'",
   ",",
   "fill_value",
   "=",
   "min_max",
   "[",
   "1",
   "]",
   ",",
   "bounds_error",
   "=",
   "False",
   ")",
   "# function to minimize -- squared difference between prob mass and desired fracion",
   "def",
   "func",
   "(",
   "x",
   ",",
   "thres",
   ")",
   ":",
   "interval",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "left",
   "(",
   "x",
   ")",
   ",",
   "right",
   "(",
   "x",
   ")",
   "]",
   ")",
   ".",
   "squeeze",
   "(",
   ")",
   "return",
   "(",
   "thres",
   "-",
   "np",
   ".",
   "diff",
   "(",
   "node",
   ".",
   "marginal_cdf",
   "(",
   "np",
   ".",
   "array",
   "(",
   "interval",
   ")",
   ")",
   ")",
   ")",
   "**",
   "2",
   "# minimza and determine success",
   "sol",
   "=",
   "minimize",
   "(",
   "func",
   ",",
   "bracket",
   "=",
   "[",
   "0",
   ",",
   "10",
   "]",
   ",",
   "args",
   "=",
   "(",
   "fraction",
   ",",
   ")",
   ")",
   "if",
   "sol",
   "[",
   "'success'",
   "]",
   ":",
   "mutation_contribution",
   "=",
   "self",
   ".",
   "date2dist",
   ".",
   "to_numdate",
   "(",
   "np",
   ".",
   "array",
   "(",
   "[",
   "right",
   "(",
   "sol",
   "[",
   "'x'",
   "]",
   ")",
   ",",
   "left",
   "(",
   "sol",
   "[",
   "'x'",
   "]",
   ")",
   "]",
   ")",
   ".",
   "squeeze",
   "(",
   ")",
   ")",
   "else",
   ":",
   "# on failure, return standard confidence interval",
   "mutation_contribution",
   "=",
   "None",
   "return",
   "self",
   ".",
   "combine_confidence",
   "(",
   "node",
   ".",
   "numdate",
   ",",
   "(",
   "min_date",
   ",",
   "max_date",
   ")",
   ",",
   "c1",
   "=",
   "rate_contribution",
   ",",
   "c2",
   "=",
   "mutation_contribution",
   ")"
  ]
 },
 {
  "idx": "maxmin-865",
  "nl_tokens": [
   "Clears",
   "a",
   "set",
   "of",
   "task",
   "instances",
   "but",
   "makes",
   "sure",
   "the",
   "running",
   "ones",
   "get",
   "killed",
   "."
  ],
  "pl_tokens": [
   "def",
   "clear_task_instances",
   "(",
   "tis",
   ",",
   "session",
   ",",
   "activate_dag_runs",
   "=",
   "True",
   ",",
   "dag",
   "=",
   "None",
   ",",
   ")",
   ":",
   "job_ids",
   "=",
   "[",
   "]",
   "for",
   "ti",
   "in",
   "tis",
   ":",
   "if",
   "ti",
   ".",
   "state",
   "==",
   "State",
   ".",
   "RUNNING",
   ":",
   "if",
   "ti",
   ".",
   "job_id",
   ":",
   "ti",
   ".",
   "state",
   "=",
   "State",
   ".",
   "SHUTDOWN",
   "job_ids",
   ".",
   "append",
   "(",
   "ti",
   ".",
   "job_id",
   ")",
   "else",
   ":",
   "task_id",
   "=",
   "ti",
   ".",
   "task_id",
   "if",
   "dag",
   "and",
   "dag",
   ".",
   "has_task",
   "(",
   "task_id",
   ")",
   ":",
   "task",
   "=",
   "dag",
   ".",
   "get_task",
   "(",
   "task_id",
   ")",
   "task_retries",
   "=",
   "task",
   ".",
   "retries",
   "ti",
   ".",
   "max_tries",
   "=",
   "ti",
   ".",
   "try_number",
   "+",
   "task_retries",
   "-",
   "1",
   "else",
   ":",
   "# Ignore errors when updating max_tries if dag is None or",
   "# task not found in dag since database records could be",
   "# outdated. We make max_tries the maximum value of its",
   "# original max_tries or the current task try number.",
   "ti",
   ".",
   "max_tries",
   "=",
   "<mask>",
   "(",
   "ti",
   ".",
   "max_tries",
   ",",
   "ti",
   ".",
   "try_number",
   "-",
   "1",
   ")",
   "ti",
   ".",
   "state",
   "=",
   "State",
   ".",
   "NONE",
   "session",
   ".",
   "merge",
   "(",
   "ti",
   ")",
   "if",
   "job_ids",
   ":",
   "from",
   "airflow",
   ".",
   "jobs",
   "import",
   "BaseJob",
   "as",
   "BJ",
   "for",
   "job",
   "in",
   "session",
   ".",
   "query",
   "(",
   "BJ",
   ")",
   ".",
   "filter",
   "(",
   "BJ",
   ".",
   "id",
   ".",
   "in_",
   "(",
   "job_ids",
   ")",
   ")",
   ".",
   "all",
   "(",
   ")",
   ":",
   "job",
   ".",
   "state",
   "=",
   "State",
   ".",
   "SHUTDOWN",
   "if",
   "activate_dag_runs",
   "and",
   "tis",
   ":",
   "from",
   "airflow",
   ".",
   "models",
   ".",
   "dagrun",
   "import",
   "DagRun",
   "# Avoid circular import",
   "drs",
   "=",
   "session",
   ".",
   "query",
   "(",
   "DagRun",
   ")",
   ".",
   "filter",
   "(",
   "DagRun",
   ".",
   "dag_id",
   ".",
   "in_",
   "(",
   "{",
   "ti",
   ".",
   "dag_id",
   "for",
   "ti",
   "in",
   "tis",
   "}",
   ")",
   ",",
   "DagRun",
   ".",
   "execution_date",
   ".",
   "in_",
   "(",
   "{",
   "ti",
   ".",
   "execution_date",
   "for",
   "ti",
   "in",
   "tis",
   "}",
   ")",
   ",",
   ")",
   ".",
   "all",
   "(",
   ")",
   "for",
   "dr",
   "in",
   "drs",
   ":",
   "dr",
   ".",
   "state",
   "=",
   "State",
   ".",
   "RUNNING",
   "dr",
   ".",
   "start_date",
   "=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-866",
  "nl_tokens": [
   "Squeeze",
   "trits",
   "from",
   "the",
   "sponge",
   "."
  ],
  "pl_tokens": [
   "def",
   "squeeze",
   "(",
   "self",
   ",",
   "trits",
   ",",
   "offset",
   "=",
   "0",
   ",",
   "length",
   "=",
   "HASH_LENGTH",
   ")",
   ":",
   "# type: (MutableSequence[int], Optional[int], Optional[int]) -> None",
   "# Squeeze is kind of like the opposite of absorb; it copies",
   "# trits from internal state to the ``trits`` parameter, one hash",
   "# at a time, and transforming internal state in between hashes.",
   "#",
   "# However, only the first hash of the state is \"public\", so we",
   "# can simplify the implementation somewhat.",
   "# Ensure length can be mod by HASH_LENGTH",
   "if",
   "length",
   "%",
   "HASH_LENGTH",
   "!=",
   "0",
   ":",
   "raise",
   "with_context",
   "(",
   "exc",
   "=",
   "ValueError",
   "(",
   "'Invalid length passed to ``squeeze`.'",
   ")",
   ",",
   "context",
   "=",
   "{",
   "'trits'",
   ":",
   "trits",
   ",",
   "'offset'",
   ":",
   "offset",
   ",",
   "'length'",
   ":",
   "length",
   ",",
   "}",
   ")",
   "# Ensure that ``trits`` can hold at least one hash worth of",
   "# trits.",
   "trits",
   ".",
   "extend",
   "(",
   "[",
   "0",
   "]",
   "*",
   "<mask>",
   "(",
   "0",
   ",",
   "length",
   "-",
   "len",
   "(",
   "trits",
   ")",
   ")",
   ")",
   "# Check trits with offset can handle hash length",
   "if",
   "len",
   "(",
   "trits",
   ")",
   "-",
   "offset",
   "<",
   "HASH_LENGTH",
   ":",
   "raise",
   "with_context",
   "(",
   "exc",
   "=",
   "ValueError",
   "(",
   "'Invalid offset passed to ``squeeze``.'",
   ")",
   ",",
   "context",
   "=",
   "{",
   "'trits'",
   ":",
   "trits",
   ",",
   "'offset'",
   ":",
   "offset",
   ",",
   "'length'",
   ":",
   "length",
   "}",
   ",",
   ")",
   "while",
   "length",
   ">=",
   "HASH_LENGTH",
   ":",
   "# Copy exactly one hash.",
   "trits",
   "[",
   "offset",
   ":",
   "offset",
   "+",
   "HASH_LENGTH",
   "]",
   "=",
   "self",
   ".",
   "_state",
   "[",
   "0",
   ":",
   "HASH_LENGTH",
   "]",
   "# One hash worth of trits copied; now transform.",
   "self",
   ".",
   "_transform",
   "(",
   ")",
   "offset",
   "+=",
   "HASH_LENGTH",
   "length",
   "-=",
   "HASH_LENGTH"
  ]
 },
 {
  "idx": "maxmin-867",
  "nl_tokens": [
   "Get",
   "the",
   "timestamp",
   "where",
   "we",
   "are",
   "going",
   "to",
   "save",
   "our",
   "current",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "_timestamp",
   "(",
   "self",
   ")",
   ":",
   "if",
   "PyFunceble",
   ".",
   "CONFIGURATION",
   "[",
   "\"inactive_database\"",
   "]",
   ":",
   "# The database subsystem is activated.",
   "if",
   "(",
   "\"inactive_db\"",
   "in",
   "PyFunceble",
   ".",
   "INTERN",
   "and",
   "PyFunceble",
   ".",
   "INTERN",
   "[",
   "\"file_to_test\"",
   "]",
   "in",
   "PyFunceble",
   ".",
   "INTERN",
   "[",
   "\"inactive_db\"",
   "]",
   "and",
   "PyFunceble",
   ".",
   "INTERN",
   "[",
   "\"inactive_db\"",
   "]",
   "[",
   "PyFunceble",
   ".",
   "INTERN",
   "[",
   "\"file_to_test\"",
   "]",
   "]",
   ")",
   ":",
   "# The file we are testing is into the database and its content",
   "# is not empty.",
   "# We get the indexes of the current file (in the dabase).",
   "database_keys",
   "=",
   "[",
   "x",
   "for",
   "x",
   "in",
   "PyFunceble",
   ".",
   "INTERN",
   "[",
   "\"inactive_db\"",
   "]",
   "[",
   "PyFunceble",
   ".",
   "INTERN",
   "[",
   "\"file_to_test\"",
   "]",
   "]",
   ".",
   "keys",
   "(",
   ")",
   "if",
   "x",
   ".",
   "isdigit",
   "(",
   ")",
   "]",
   "if",
   "database_keys",
   ":",
   "# The list of keys is not empty.",
   "# We get the most recent date.",
   "recent_date",
   "=",
   "<mask>",
   "(",
   "database_keys",
   ")",
   "else",
   ":",
   "# pragma: no cover",
   "# The list of keys is empty.",
   "# We return the current time.",
   "return",
   "int",
   "(",
   "PyFunceble",
   ".",
   "time",
   "(",
   ")",
   ")",
   "if",
   "int",
   "(",
   "PyFunceble",
   ".",
   "time",
   "(",
   ")",
   ")",
   ">",
   "int",
   "(",
   "recent_date",
   ")",
   "+",
   "self",
   ".",
   "one_day_in_seconds",
   ":",
   "# The most recent time was in more than one day.",
   "# We return the current time.",
   "return",
   "int",
   "(",
   "PyFunceble",
   ".",
   "time",
   "(",
   ")",
   ")",
   "# The most recent time was in less than one day.",
   "if",
   "int",
   "(",
   "PyFunceble",
   ".",
   "time",
   "(",
   ")",
   ")",
   "<",
   "int",
   "(",
   "recent_date",
   ")",
   "+",
   "self",
   ".",
   "days_in_seconds",
   ":",
   "# The most recent time was in less than the expected number of day for",
   "# retesting.",
   "# We return the most recent data.",
   "return",
   "int",
   "(",
   "recent_date",
   ")",
   "# The database subsystem is not activated.",
   "# We return the current time.",
   "return",
   "int",
   "(",
   "PyFunceble",
   ".",
   "time",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-868",
  "nl_tokens": [
   "Start",
   "processing",
   "an",
   "OSM",
   "changeset",
   "stream",
   "and",
   "yield",
   "one",
   "(",
   "action",
   "primitive",
   ")",
   "tuple",
   "at",
   "a",
   "time",
   "to",
   "the",
   "caller",
   "."
  ],
  "pl_tokens": [
   "def",
   "iter_changeset_stream",
   "(",
   "start_sqn",
   "=",
   "None",
   ",",
   "base_url",
   "=",
   "'https://planet.openstreetmap.org/replication/changesets'",
   ",",
   "expected_interval",
   "=",
   "60",
   ",",
   "parse_timestamps",
   "=",
   "True",
   ",",
   "state_dir",
   "=",
   "None",
   ")",
   ":",
   "# This is a lot like the other osm_stream except there's no",
   "# state file for each of the diffs, so just push ahead until",
   "# we run into a 404.",
   "# If the user specifies a state_dir, read the state from the statefile there",
   "if",
   "state_dir",
   ":",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "state_dir",
   ")",
   ":",
   "raise",
   "Exception",
   "(",
   "'Specified state_dir \"%s\" doesn\\'t exist.'",
   "%",
   "state_dir",
   ")",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "'%s/state.yaml'",
   "%",
   "state_dir",
   ")",
   ":",
   "with",
   "open",
   "(",
   "'%s/state.yaml'",
   "%",
   "state_dir",
   ")",
   "as",
   "f",
   ":",
   "state",
   "=",
   "readState",
   "(",
   "f",
   ",",
   "': '",
   ")",
   "start_sqn",
   "=",
   "state",
   "[",
   "'sequence'",
   "]",
   "# If no start_sqn, assume to start from the most recent changeset file",
   "if",
   "not",
   "start_sqn",
   ":",
   "u",
   "=",
   "urllib2",
   ".",
   "urlopen",
   "(",
   "'%s/state.yaml'",
   "%",
   "base_url",
   ")",
   "state",
   "=",
   "readState",
   "(",
   "u",
   ",",
   "': '",
   ")",
   "sequenceNumber",
   "=",
   "int",
   "(",
   "state",
   "[",
   "'sequence'",
   "]",
   ")",
   "else",
   ":",
   "sequenceNumber",
   "=",
   "int",
   "(",
   "start_sqn",
   ")",
   "interval_fudge",
   "=",
   "0.0",
   "while",
   "True",
   ":",
   "sqnStr",
   "=",
   "str",
   "(",
   "sequenceNumber",
   ")",
   ".",
   "zfill",
   "(",
   "9",
   ")",
   "url",
   "=",
   "'%s/%s/%s/%s.osm.gz'",
   "%",
   "(",
   "base_url",
   ",",
   "sqnStr",
   "[",
   "0",
   ":",
   "3",
   "]",
   ",",
   "sqnStr",
   "[",
   "3",
   ":",
   "6",
   "]",
   ",",
   "sqnStr",
   "[",
   "6",
   ":",
   "9",
   "]",
   ")",
   "delay",
   "=",
   "1.0",
   "while",
   "True",
   ":",
   "try",
   ":",
   "content",
   "=",
   "urllib2",
   ".",
   "urlopen",
   "(",
   "url",
   ")",
   "content",
   "=",
   "StringIO",
   ".",
   "StringIO",
   "(",
   "content",
   ".",
   "read",
   "(",
   ")",
   ")",
   "gzipper",
   "=",
   "gzip",
   ".",
   "GzipFile",
   "(",
   "fileobj",
   "=",
   "content",
   ")",
   "interval_fudge",
   "-=",
   "(",
   "interval_fudge",
   "/",
   "2.0",
   ")",
   "break",
   "except",
   "urllib2",
   ".",
   "HTTPError",
   "as",
   "e",
   ":",
   "if",
   "e",
   ".",
   "code",
   "==",
   "404",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "delay",
   ")",
   "delay",
   "=",
   "<mask>",
   "(",
   "delay",
   "*",
   "2",
   ",",
   "13",
   ")",
   "interval_fudge",
   "+=",
   "delay",
   "obj",
   "=",
   "None",
   "for",
   "event",
   ",",
   "elem",
   "in",
   "etree",
   ".",
   "iterparse",
   "(",
   "gzipper",
   ",",
   "events",
   "=",
   "(",
   "'start'",
   ",",
   "'end'",
   ")",
   ")",
   ":",
   "if",
   "event",
   "==",
   "'start'",
   ":",
   "if",
   "elem",
   ".",
   "tag",
   "==",
   "'changeset'",
   ":",
   "obj",
   "=",
   "model",
   ".",
   "Changeset",
   "(",
   "int",
   "(",
   "elem",
   ".",
   "attrib",
   "[",
   "'id'",
   "]",
   ")",
   ",",
   "isoToDatetime",
   "(",
   "elem",
   ".",
   "attrib",
   ".",
   "get",
   "(",
   "'created_at'",
   ")",
   ")",
   "if",
   "parse_timestamps",
   "else",
   "elem",
   ".",
   "attrib",
   ".",
   "get",
   "(",
   "'created_at'",
   ")",
   ",",
   "isoToDatetime",
   "(",
   "elem",
   ".",
   "attrib",
   ".",
   "get",
   "(",
   "'closed_at'",
   ")",
   ")",
   "if",
   "parse_timestamps",
   "else",
   "elem",
   ".",
   "attrib",
   ".",
   "get",
   "(",
   "'closed_at'",
   ")",
   ",",
   "maybeBool",
   "(",
   "elem",
   ".",
   "attrib",
   "[",
   "'open'",
   "]",
   ")",
   ",",
   "maybeFloat",
   "(",
   "elem",
   ".",
   "get",
   "(",
   "'min_lat'",
   ")",
   ")",
   ",",
   "maybeFloat",
   "(",
   "elem",
   ".",
   "get",
   "(",
   "'max_lat'",
   ")",
   ")",
   ",",
   "maybeFloat",
   "(",
   "elem",
   ".",
   "get",
   "(",
   "'min_lon'",
   ")",
   ")",
   ",",
   "maybeFloat",
   "(",
   "elem",
   ".",
   "get",
   "(",
   "'max_lon'",
   ")",
   ")",
   ",",
   "elem",
   ".",
   "attrib",
   ".",
   "get",
   "(",
   "'user'",
   ")",
   ",",
   "maybeInt",
   "(",
   "elem",
   ".",
   "attrib",
   ".",
   "get",
   "(",
   "'uid'",
   ")",
   ")",
   ",",
   "[",
   "]",
   ")",
   "elif",
   "elem",
   ".",
   "tag",
   "==",
   "'tag'",
   ":",
   "obj",
   ".",
   "tags",
   ".",
   "append",
   "(",
   "model",
   ".",
   "Tag",
   "(",
   "elem",
   ".",
   "attrib",
   "[",
   "'k'",
   "]",
   ",",
   "elem",
   ".",
   "attrib",
   "[",
   "'v'",
   "]",
   ")",
   ")",
   "elif",
   "event",
   "==",
   "'end'",
   ":",
   "if",
   "elem",
   ".",
   "tag",
   "==",
   "'changeset'",
   ":",
   "yield",
   "obj",
   "obj",
   "=",
   "None",
   "yield",
   "model",
   ".",
   "Finished",
   "(",
   "sequenceNumber",
   ",",
   "None",
   ")",
   "sequenceNumber",
   "+=",
   "1",
   "if",
   "state_dir",
   ":",
   "with",
   "open",
   "(",
   "'%s/state.yaml'",
   "%",
   "state_dir",
   ",",
   "'w'",
   ")",
   "as",
   "f",
   ":",
   "f",
   ".",
   "write",
   "(",
   "'sequence: %d'",
   "%",
   "sequenceNumber",
   ")"
  ]
 },
 {
  "idx": "maxmin-869",
  "nl_tokens": [
   "Modify",
   "the",
   "content",
   "of",
   "filepath",
   "replacing",
   "old",
   "for",
   "new",
   "."
  ],
  "pl_tokens": [
   "def",
   "replace_file_content",
   "(",
   "filepath",
   ",",
   "old",
   ",",
   "new",
   ",",
   "<mask>",
   "=",
   "1",
   ")",
   ":",
   "with",
   "open",
   "(",
   "filepath",
   ",",
   "'r'",
   ")",
   "as",
   "f",
   ":",
   "content",
   "=",
   "f",
   ".",
   "read",
   "(",
   ")",
   "content",
   "=",
   "content",
   ".",
   "replace",
   "(",
   "old",
   ",",
   "new",
   ",",
   "max",
   ")",
   "with",
   "open",
   "(",
   "filepath",
   ",",
   "'w'",
   ")",
   "as",
   "f",
   ":",
   "f",
   ".",
   "write",
   "(",
   "content",
   ")"
  ]
 },
 {
  "idx": "maxmin-870",
  "nl_tokens": [
   "Return",
   "the",
   "number",
   "of",
   "CPUs",
   "the",
   "current",
   "process",
   "can",
   "use",
   "."
  ],
  "pl_tokens": [
   "def",
   "cpu_count",
   "(",
   ")",
   ":",
   "import",
   "math",
   "try",
   ":",
   "cpu_count_mp",
   "=",
   "mp",
   ".",
   "cpu_count",
   "(",
   ")",
   "except",
   "NotImplementedError",
   ":",
   "cpu_count_mp",
   "=",
   "1",
   "# Number of available CPUs given affinity settings",
   "cpu_count_affinity",
   "=",
   "cpu_count_mp",
   "if",
   "hasattr",
   "(",
   "os",
   ",",
   "'sched_getaffinity'",
   ")",
   ":",
   "try",
   ":",
   "cpu_count_affinity",
   "=",
   "len",
   "(",
   "os",
   ".",
   "sched_getaffinity",
   "(",
   "0",
   ")",
   ")",
   "except",
   "NotImplementedError",
   ":",
   "pass",
   "# CFS scheduler CPU bandwidth limit",
   "# available in Linux since 2.6 kernel",
   "cpu_count_cfs",
   "=",
   "cpu_count_mp",
   "cfs_quota_fname",
   "=",
   "\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\"",
   "cfs_period_fname",
   "=",
   "\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\"",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "cfs_quota_fname",
   ")",
   "and",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "cfs_period_fname",
   ")",
   ":",
   "with",
   "open",
   "(",
   "cfs_quota_fname",
   ",",
   "'r'",
   ")",
   "as",
   "fh",
   ":",
   "cfs_quota_us",
   "=",
   "int",
   "(",
   "fh",
   ".",
   "read",
   "(",
   ")",
   ")",
   "with",
   "open",
   "(",
   "cfs_period_fname",
   ",",
   "'r'",
   ")",
   "as",
   "fh",
   ":",
   "cfs_period_us",
   "=",
   "int",
   "(",
   "fh",
   ".",
   "read",
   "(",
   ")",
   ")",
   "if",
   "cfs_quota_us",
   ">",
   "0",
   "and",
   "cfs_period_us",
   ">",
   "0",
   ":",
   "# Make sure this quantity is an int as math.ceil returns a",
   "# float in python2.7. (See issue #165)",
   "cpu_count_cfs",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "cfs_quota_us",
   "/",
   "cfs_period_us",
   ")",
   ")",
   "# User defined soft-limit passed as an loky specific environment variable.",
   "cpu_count_loky",
   "=",
   "int",
   "(",
   "os",
   ".",
   "environ",
   ".",
   "get",
   "(",
   "'LOKY_MAX_CPU_COUNT'",
   ",",
   "cpu_count_mp",
   ")",
   ")",
   "aggregate_cpu_count",
   "=",
   "<mask>",
   "(",
   "cpu_count_mp",
   ",",
   "cpu_count_affinity",
   ",",
   "cpu_count_cfs",
   ",",
   "cpu_count_loky",
   ")",
   "return",
   "max",
   "(",
   "aggregate_cpu_count",
   ",",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-871",
  "nl_tokens": [
   "Get",
   "height",
   "width",
   "&",
   "scale",
   "attributes",
   "for",
   "the",
   "beamer",
   "page",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_beamer_page",
   "(",
   "self",
   ")",
   ":",
   "# PIL python package limits image size to around a quarter gigabyte",
   "# this means the beamer image should be limited to < 50000",
   "# if you want to avoid a \"warning\" too, set it to < 25000",
   "PIL_limit",
   "=",
   "40000",
   "# the beamer latex template limits each dimension to < 19 feet",
   "# (i.e. 575cm)",
   "beamer_limit",
   "=",
   "550",
   "# columns are roughly twice as big as rows",
   "aspect_ratio",
   "=",
   "self",
   ".",
   "sum_row_heights",
   "/",
   "self",
   ".",
   "sum_column_widths",
   "# choose a page margin so circuit is not cropped",
   "margin_factor",
   "=",
   "1.5",
   "height",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "sum_row_heights",
   "*",
   "margin_factor",
   ",",
   "beamer_limit",
   ")",
   "width",
   "=",
   "min",
   "(",
   "self",
   ".",
   "sum_column_widths",
   "*",
   "margin_factor",
   ",",
   "beamer_limit",
   ")",
   "# if too large, make it fit",
   "if",
   "height",
   "*",
   "width",
   ">",
   "PIL_limit",
   ":",
   "height",
   "=",
   "min",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "PIL_limit",
   "*",
   "aspect_ratio",
   ")",
   ",",
   "beamer_limit",
   ")",
   "width",
   "=",
   "min",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "PIL_limit",
   "/",
   "aspect_ratio",
   ")",
   ",",
   "beamer_limit",
   ")",
   "# if too small, give it a minimum size",
   "height",
   "=",
   "max",
   "(",
   "height",
   ",",
   "10",
   ")",
   "width",
   "=",
   "max",
   "(",
   "width",
   ",",
   "10",
   ")",
   "return",
   "(",
   "height",
   ",",
   "width",
   ",",
   "self",
   ".",
   "scale",
   ")"
  ]
 },
 {
  "idx": "maxmin-872",
  "nl_tokens": [
   "Get",
   "the",
   "number",
   "and",
   "size",
   "of",
   "unique",
   "registers",
   "from",
   "bit_labels",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_register_specs",
   "(",
   "bit_labels",
   ")",
   ":",
   "it",
   "=",
   "itertools",
   ".",
   "groupby",
   "(",
   "bit_labels",
   ",",
   "operator",
   ".",
   "itemgetter",
   "(",
   "0",
   ")",
   ")",
   "for",
   "register_name",
   ",",
   "sub_it",
   "in",
   "it",
   ":",
   "yield",
   "register_name",
   ",",
   "<mask>",
   "(",
   "ind",
   "[",
   "1",
   "]",
   "for",
   "ind",
   "in",
   "sub_it",
   ")",
   "+",
   "1"
  ]
 },
 {
  "idx": "maxmin-873",
  "nl_tokens": [
   "Returns",
   "a",
   "list",
   "of",
   "degree",
   "vectors",
   "one",
   "for",
   "each",
   "input",
   "and",
   "hidden",
   "layer",
   "."
  ],
  "pl_tokens": [
   "def",
   "_create_degrees",
   "(",
   "input_size",
   ",",
   "hidden_units",
   "=",
   "None",
   ",",
   "input_order",
   "=",
   "\"left-to-right\"",
   ",",
   "hidden_degrees",
   "=",
   "\"equal\"",
   ")",
   ":",
   "input_order",
   "=",
   "_create_input_order",
   "(",
   "input_size",
   ",",
   "input_order",
   ")",
   "degrees",
   "=",
   "[",
   "input_order",
   "]",
   "if",
   "hidden_units",
   "is",
   "None",
   ":",
   "hidden_units",
   "=",
   "[",
   "]",
   "for",
   "units",
   "in",
   "hidden_units",
   ":",
   "if",
   "isinstance",
   "(",
   "hidden_degrees",
   ",",
   "six",
   ".",
   "string_types",
   ")",
   ":",
   "if",
   "hidden_degrees",
   "==",
   "\"random\"",
   ":",
   "# samples from: [low, high)",
   "degrees",
   ".",
   "append",
   "(",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "low",
   "=",
   "<mask>",
   "(",
   "np",
   ".",
   "min",
   "(",
   "degrees",
   "[",
   "-",
   "1",
   "]",
   ")",
   ",",
   "input_size",
   "-",
   "1",
   ")",
   ",",
   "high",
   "=",
   "input_size",
   ",",
   "size",
   "=",
   "units",
   ")",
   ")",
   "elif",
   "hidden_degrees",
   "==",
   "\"equal\"",
   ":",
   "min_degree",
   "=",
   "min",
   "(",
   "np",
   ".",
   "min",
   "(",
   "degrees",
   "[",
   "-",
   "1",
   "]",
   ")",
   ",",
   "input_size",
   "-",
   "1",
   ")",
   "degrees",
   ".",
   "append",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "min_degree",
   ",",
   "# Evenly divide the range `[1, input_size - 1]` in to `units + 1`",
   "# segments, and pick the boundaries between the segments as degrees.",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "1",
   ",",
   "units",
   "+",
   "1",
   ")",
   "*",
   "(",
   "input_size",
   "-",
   "1",
   ")",
   "/",
   "float",
   "(",
   "units",
   "+",
   "1",
   ")",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "int32",
   ")",
   ")",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Invalid hidden order: \"{}\".'",
   ".",
   "format",
   "(",
   "hidden_degrees",
   ")",
   ")",
   "return",
   "degrees"
  ]
 },
 {
  "idx": "maxmin-874",
  "nl_tokens": [
   "display",
   "a",
   "table",
   "as",
   "text"
  ],
  "pl_tokens": [
   "def",
   "visit_table",
   "(",
   "self",
   ",",
   "layout",
   ")",
   ":",
   "table_content",
   "=",
   "self",
   ".",
   "get_table_content",
   "(",
   "layout",
   ")",
   "# get columns width",
   "cols_width",
   "=",
   "[",
   "0",
   "]",
   "*",
   "len",
   "(",
   "table_content",
   "[",
   "0",
   "]",
   ")",
   "for",
   "row",
   "in",
   "table_content",
   ":",
   "for",
   "index",
   ",",
   "col",
   "in",
   "enumerate",
   "(",
   "row",
   ")",
   ":",
   "cols_width",
   "[",
   "index",
   "]",
   "=",
   "<mask>",
   "(",
   "cols_width",
   "[",
   "index",
   "]",
   ",",
   "len",
   "(",
   "col",
   ")",
   ")",
   "self",
   ".",
   "default_table",
   "(",
   "layout",
   ",",
   "table_content",
   ",",
   "cols_width",
   ")",
   "self",
   ".",
   "writeln",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-875",
  "nl_tokens": [
   "Sub",
   "-",
   "divide",
   "a",
   "segmentation",
   "by",
   "feature",
   "clustering",
   "."
  ],
  "pl_tokens": [
   "def",
   "subsegment",
   "(",
   "data",
   ",",
   "frames",
   ",",
   "n_segments",
   "=",
   "4",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   ":",
   "frames",
   "=",
   "util",
   ".",
   "fix_frames",
   "(",
   "frames",
   ",",
   "x_min",
   "=",
   "0",
   ",",
   "x_max",
   "=",
   "data",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   ",",
   "pad",
   "=",
   "True",
   ")",
   "if",
   "n_segments",
   "<",
   "1",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'n_segments must be a positive integer'",
   ")",
   "boundaries",
   "=",
   "[",
   "]",
   "idx_slices",
   "=",
   "[",
   "slice",
   "(",
   "None",
   ")",
   "]",
   "*",
   "data",
   ".",
   "ndim",
   "for",
   "seg_start",
   ",",
   "seg_end",
   "in",
   "zip",
   "(",
   "frames",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "frames",
   "[",
   "1",
   ":",
   "]",
   ")",
   ":",
   "idx_slices",
   "[",
   "axis",
   "]",
   "=",
   "slice",
   "(",
   "seg_start",
   ",",
   "seg_end",
   ")",
   "boundaries",
   ".",
   "extend",
   "(",
   "seg_start",
   "+",
   "agglomerative",
   "(",
   "data",
   "[",
   "tuple",
   "(",
   "idx_slices",
   ")",
   "]",
   ",",
   "<mask>",
   "(",
   "seg_end",
   "-",
   "seg_start",
   ",",
   "n_segments",
   ")",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   ")",
   "return",
   "np",
   ".",
   "ascontiguousarray",
   "(",
   "boundaries",
   ")"
  ]
 },
 {
  "idx": "maxmin-876",
  "nl_tokens": [
   "How",
   "many",
   "Celery",
   "tasks",
   "should",
   "each",
   "worker",
   "process",
   "send",
   "."
  ],
  "pl_tokens": [
   "def",
   "_num_tasks_per_send_process",
   "(",
   "self",
   ",",
   "to_send_count",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "1",
   ",",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "1.0",
   "*",
   "to_send_count",
   "/",
   "self",
   ".",
   "_sync_parallelism",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-877",
  "nl_tokens": [
   "Feature",
   "-",
   "extraction",
   "for",
   "audio",
   "segmentation",
   "Arguments",
   ":",
   "file_struct",
   "--",
   "msaf",
   ".",
   "io",
   ".",
   "FileStruct",
   "paths",
   "to",
   "the",
   "input",
   "files",
   "in",
   "the",
   "Segmentation",
   "dataset"
  ],
  "pl_tokens": [
   "def",
   "features",
   "(",
   "file_struct",
   ",",
   "annot_beats",
   "=",
   "False",
   ",",
   "framesync",
   "=",
   "False",
   ")",
   ":",
   "def",
   "compress_data",
   "(",
   "X",
   ",",
   "k",
   ")",
   ":",
   "Xtemp",
   "=",
   "X",
   ".",
   "dot",
   "(",
   "X",
   ".",
   "T",
   ")",
   "if",
   "len",
   "(",
   "Xtemp",
   ")",
   "==",
   "0",
   ":",
   "return",
   "None",
   "e_vals",
   ",",
   "e_vecs",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "eig",
   "(",
   "Xtemp",
   ")",
   "e_vals",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "0.0",
   ",",
   "np",
   ".",
   "real",
   "(",
   "e_vals",
   ")",
   ")",
   "e_vecs",
   "=",
   "np",
   ".",
   "real",
   "(",
   "e_vecs",
   ")",
   "idx",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "e_vals",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "e_vals",
   "=",
   "e_vals",
   "[",
   "idx",
   "]",
   "e_vecs",
   "=",
   "e_vecs",
   "[",
   ":",
   ",",
   "idx",
   "]",
   "# Truncate to k dimensions",
   "if",
   "k",
   "<",
   "len",
   "(",
   "e_vals",
   ")",
   ":",
   "e_vals",
   "=",
   "e_vals",
   "[",
   ":",
   "k",
   "]",
   "e_vecs",
   "=",
   "e_vecs",
   "[",
   ":",
   ",",
   ":",
   "k",
   "]",
   "# Normalize by the leading singular value of X",
   "Z",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "e_vals",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "if",
   "Z",
   ">",
   "0",
   ":",
   "e_vecs",
   "=",
   "e_vecs",
   "/",
   "Z",
   "return",
   "e_vecs",
   ".",
   "T",
   ".",
   "dot",
   "(",
   "X",
   ")",
   "# Latent factor repetition features",
   "def",
   "repetition",
   "(",
   "X",
   ",",
   "metric",
   "=",
   "'euclidean'",
   ")",
   ":",
   "R",
   "=",
   "librosa",
   ".",
   "segment",
   ".",
   "recurrence_matrix",
   "(",
   "X",
   ",",
   "k",
   "=",
   "2",
   "*",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "X",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   ")",
   ",",
   "width",
   "=",
   "REP_WIDTH",
   ",",
   "metric",
   "=",
   "metric",
   ",",
   "sym",
   "=",
   "False",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float32",
   ")",
   "P",
   "=",
   "scipy",
   ".",
   "signal",
   ".",
   "medfilt2d",
   "(",
   "librosa",
   ".",
   "segment",
   ".",
   "recurrence_to_lag",
   "(",
   "R",
   ")",
   ",",
   "[",
   "1",
   ",",
   "REP_FILTER",
   "]",
   ")",
   "# Discard empty rows.",
   "# This should give an equivalent SVD, but resolves some numerical",
   "# instabilities.",
   "P",
   "=",
   "P",
   "[",
   "P",
   ".",
   "any",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "]",
   "return",
   "compress_data",
   "(",
   "P",
   ",",
   "N_REP",
   ")",
   "#########",
   "# '\\tloading annotations and features of ', audio_path",
   "pcp_obj",
   "=",
   "Features",
   ".",
   "select_features",
   "(",
   "\"pcp\"",
   ",",
   "file_struct",
   ",",
   "annot_beats",
   ",",
   "framesync",
   ")",
   "mfcc_obj",
   "=",
   "Features",
   ".",
   "select_features",
   "(",
   "\"mfcc\"",
   ",",
   "file_struct",
   ",",
   "annot_beats",
   ",",
   "framesync",
   ")",
   "chroma",
   "=",
   "pcp_obj",
   ".",
   "features",
   "mfcc",
   "=",
   "mfcc_obj",
   ".",
   "features",
   "beats",
   "=",
   "pcp_obj",
   ".",
   "frame_times",
   "dur",
   "=",
   "pcp_obj",
   ".",
   "dur",
   "# Sampling Rate",
   "sr",
   "=",
   "msaf",
   ".",
   "config",
   ".",
   "sample_rate",
   "##########",
   "# print '\\treading beats'",
   "B",
   "=",
   "beats",
   "[",
   ":",
   "chroma",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "]",
   "# beat_frames = librosa.time_to_frames(B, sr=sr,",
   "#hop_length=msaf.config.hop_size)",
   "#print beat_frames, len(beat_frames), uidx",
   "#########",
   "M",
   "=",
   "mfcc",
   ".",
   "T",
   "#plt.imshow(M, interpolation=\"nearest\", aspect=\"auto\"); plt.show()",
   "#########",
   "# Get the beat-sync chroma",
   "C",
   "=",
   "chroma",
   ".",
   "T",
   "C",
   "+=",
   "C",
   ".",
   "min",
   "(",
   ")",
   "+",
   "0.1",
   "C",
   "=",
   "C",
   "/",
   "C",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "C",
   "=",
   "80",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "C",
   ")",
   "# Normalize from -80 to 0",
   "#plt.imshow(C, interpolation=\"nearest\", aspect=\"auto\"); plt.show()",
   "# Time-stamp features",
   "N",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "float",
   "(",
   "chroma",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ")",
   "#########",
   "#print '\\tgenerating structure features'",
   "# TODO:  This might fail if audio file (or number of beats) is too small",
   "R_timbre",
   "=",
   "repetition",
   "(",
   "librosa",
   ".",
   "feature",
   ".",
   "stack_memory",
   "(",
   "M",
   ")",
   ")",
   "R_chroma",
   "=",
   "repetition",
   "(",
   "librosa",
   ".",
   "feature",
   ".",
   "stack_memory",
   "(",
   "C",
   ")",
   ")",
   "if",
   "R_timbre",
   "is",
   "None",
   "or",
   "R_chroma",
   "is",
   "None",
   ":",
   "return",
   "None",
   ",",
   "dur",
   "R_timbre",
   "+=",
   "R_timbre",
   ".",
   "min",
   "(",
   ")",
   "R_timbre",
   "/=",
   "R_timbre",
   ".",
   "max",
   "(",
   ")",
   "R_chroma",
   "+=",
   "R_chroma",
   ".",
   "min",
   "(",
   ")",
   "R_chroma",
   "/=",
   "R_chroma",
   ".",
   "max",
   "(",
   ")",
   "#plt.imshow(R_chroma, interpolation=\"nearest\", aspect=\"auto\"); plt.show()",
   "# Stack it all up",
   "#print M.shape, C.shape, R_timbre.shape, R_chroma.shape, len(B), len(N)",
   "X",
   "=",
   "np",
   ".",
   "vstack",
   "(",
   "[",
   "M",
   ",",
   "C",
   ",",
   "R_timbre",
   ",",
   "R_chroma",
   ",",
   "B",
   ",",
   "B",
   "/",
   "dur",
   ",",
   "N",
   ",",
   "N",
   "/",
   "float",
   "(",
   "chroma",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "]",
   ")",
   "#plt.imshow(X, interpolation=\"nearest\", aspect=\"auto\"); plt.show()",
   "return",
   "X",
   ",",
   "dur"
  ]
 },
 {
  "idx": "maxmin-878",
  "nl_tokens": [
   "Will",
   "return",
   "the",
   "total",
   "count",
   "of",
   "the",
   "objects",
   "that",
   "match",
   "the",
   "specified",
   "filters",
   ".",
   "::"
  ],
  "pl_tokens": [
   "def",
   "count",
   "(",
   "self",
   ")",
   ":",
   "filters",
   "=",
   "self",
   ".",
   "_filters",
   "if",
   "self",
   ".",
   "_order_by",
   ":",
   "filters",
   "+=",
   "(",
   "self",
   ".",
   "_order_by",
   ".",
   "lstrip",
   "(",
   "'-'",
   ")",
   ",",
   ")",
   "if",
   "not",
   "filters",
   ":",
   "# We can actually count entities here...",
   "size",
   "=",
   "_connect",
   "(",
   "self",
   ".",
   "_model",
   ")",
   ".",
   "hlen",
   "(",
   "self",
   ".",
   "_model",
   ".",
   "_namespace",
   "+",
   "'::'",
   ")",
   "limit",
   "=",
   "self",
   ".",
   "_limit",
   "or",
   "(",
   "0",
   ",",
   "2",
   "**",
   "64",
   ")",
   "size",
   "=",
   "<mask>",
   "(",
   "size",
   "-",
   "max",
   "(",
   "limit",
   "[",
   "0",
   "]",
   ",",
   "0",
   ")",
   ",",
   "0",
   ")",
   "return",
   "min",
   "(",
   "size",
   ",",
   "limit",
   "[",
   "1",
   "]",
   ")",
   "return",
   "self",
   ".",
   "_model",
   ".",
   "_gindex",
   ".",
   "count",
   "(",
   "_connect",
   "(",
   "self",
   ".",
   "_model",
   ")",
   ",",
   "filters",
   ")"
  ]
 },
 {
  "idx": "maxmin-879",
  "nl_tokens": [
   "Plot",
   "the",
   "amplitude",
   "envelope",
   "of",
   "a",
   "waveform",
   "."
  ],
  "pl_tokens": [
   "def",
   "waveplot",
   "(",
   "y",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "max_points",
   "=",
   "5e4",
   ",",
   "x_axis",
   "=",
   "'time'",
   ",",
   "offset",
   "=",
   "0.0",
   ",",
   "max_sr",
   "=",
   "1000",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "util",
   ".",
   "valid_audio",
   "(",
   "y",
   ",",
   "mono",
   "=",
   "False",
   ")",
   "if",
   "not",
   "(",
   "isinstance",
   "(",
   "max_sr",
   ",",
   "int",
   ")",
   "and",
   "max_sr",
   ">",
   "0",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'max_sr must be a non-negative integer'",
   ")",
   "target_sr",
   "=",
   "sr",
   "hop_length",
   "=",
   "1",
   "if",
   "max_points",
   "is",
   "not",
   "None",
   ":",
   "if",
   "max_points",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'max_points must be strictly positive'",
   ")",
   "if",
   "max_points",
   "<",
   "y",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ":",
   "target_sr",
   "=",
   "<mask>",
   "(",
   "max_sr",
   ",",
   "(",
   "sr",
   "*",
   "y",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ")",
   "//",
   "max_points",
   ")",
   "hop_length",
   "=",
   "sr",
   "//",
   "target_sr",
   "if",
   "y",
   ".",
   "ndim",
   "==",
   "1",
   ":",
   "y",
   "=",
   "__envelope",
   "(",
   "y",
   ",",
   "hop_length",
   ")",
   "else",
   ":",
   "y",
   "=",
   "np",
   ".",
   "vstack",
   "(",
   "[",
   "__envelope",
   "(",
   "_",
   ",",
   "hop_length",
   ")",
   "for",
   "_",
   "in",
   "y",
   "]",
   ")",
   "if",
   "y",
   ".",
   "ndim",
   ">",
   "1",
   ":",
   "y_top",
   "=",
   "y",
   "[",
   "0",
   "]",
   "y_bottom",
   "=",
   "-",
   "y",
   "[",
   "1",
   "]",
   "else",
   ":",
   "y_top",
   "=",
   "y",
   "y_bottom",
   "=",
   "-",
   "y",
   "axes",
   "=",
   "__check_axes",
   "(",
   "ax",
   ")",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'color'",
   ",",
   "next",
   "(",
   "axes",
   ".",
   "_get_lines",
   ".",
   "prop_cycler",
   ")",
   "[",
   "'color'",
   "]",
   ")",
   "locs",
   "=",
   "offset",
   "+",
   "core",
   ".",
   "frames_to_time",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "y_top",
   ")",
   ")",
   ",",
   "sr",
   "=",
   "sr",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "out",
   "=",
   "axes",
   ".",
   "fill_between",
   "(",
   "locs",
   ",",
   "y_bottom",
   ",",
   "y_top",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "axes",
   ".",
   "set_xlim",
   "(",
   "[",
   "locs",
   ".",
   "min",
   "(",
   ")",
   ",",
   "locs",
   ".",
   "max",
   "(",
   ")",
   "]",
   ")",
   "if",
   "x_axis",
   "==",
   "'time'",
   ":",
   "axes",
   ".",
   "xaxis",
   ".",
   "set_major_formatter",
   "(",
   "TimeFormatter",
   "(",
   "lag",
   "=",
   "False",
   ")",
   ")",
   "axes",
   ".",
   "xaxis",
   ".",
   "set_label_text",
   "(",
   "'Time'",
   ")",
   "elif",
   "x_axis",
   "is",
   "None",
   "or",
   "x_axis",
   "in",
   "[",
   "'off'",
   ",",
   "'none'",
   "]",
   ":",
   "axes",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "else",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Unknown x_axis value: {}'",
   ".",
   "format",
   "(",
   "x_axis",
   ")",
   ")",
   "return",
   "out"
  ]
 },
 {
  "idx": "maxmin-880",
  "nl_tokens": [
   "This",
   "utility",
   "function",
   "will",
   "iterate",
   "over",
   "all",
   "entities",
   "of",
   "a",
   "provided",
   "model",
   "refreshing",
   "their",
   "indices",
   ".",
   "This",
   "is",
   "primarily",
   "useful",
   "after",
   "adding",
   "an",
   "index",
   "on",
   "a",
   "column",
   "."
  ],
  "pl_tokens": [
   "def",
   "refresh_indices",
   "(",
   "model",
   ",",
   "block_size",
   "=",
   "100",
   ")",
   ":",
   "conn",
   "=",
   "_connect",
   "(",
   "model",
   ")",
   "max_id",
   "=",
   "int",
   "(",
   "conn",
   ".",
   "get",
   "(",
   "'%s:%s:'",
   "%",
   "(",
   "model",
   ".",
   "_namespace",
   ",",
   "model",
   ".",
   "_pkey",
   ")",
   ")",
   "or",
   "'0'",
   ")",
   "block_size",
   "=",
   "<mask>",
   "(",
   "block_size",
   ",",
   "10",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "max_id",
   "+",
   "1",
   ",",
   "block_size",
   ")",
   ":",
   "# fetches entities, keeping a record in the session",
   "models",
   "=",
   "model",
   ".",
   "get",
   "(",
   "list",
   "(",
   "range",
   "(",
   "i",
   ",",
   "i",
   "+",
   "block_size",
   ")",
   ")",
   ")",
   "models",
   "# for pyflakes",
   "# re-save un-modified data, resulting in index-only updates",
   "session",
   ".",
   "commit",
   "(",
   "all",
   "=",
   "True",
   ")",
   "yield",
   "min",
   "(",
   "i",
   "+",
   "block_size",
   ",",
   "max_id",
   ")",
   ",",
   "max_id"
  ]
 },
 {
  "idx": "maxmin-881",
  "nl_tokens": [
   "Point",
   "to",
   "a",
   "position",
   "in",
   "source",
   "code",
   "."
  ],
  "pl_tokens": [
   "def",
   "point_to_source",
   "(",
   "source",
   ",",
   "position",
   ",",
   "fmt",
   "=",
   "(",
   "2",
   ",",
   "True",
   ",",
   "\"~~~~~\"",
   ",",
   "\"^\"",
   ")",
   ")",
   ":",
   "surrounding_lines",
   ",",
   "show_line_numbers",
   ",",
   "tail_body",
   ",",
   "pointer_char",
   "=",
   "fmt",
   "line_no",
   ",",
   "char_no",
   "=",
   "position",
   "lines",
   "=",
   "source",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   "line",
   "=",
   "lines",
   "[",
   "line_no",
   "]",
   "if",
   "char_no",
   ">=",
   "len",
   "(",
   "tail_body",
   ")",
   ":",
   "tail",
   "=",
   "\" \"",
   "*",
   "(",
   "char_no",
   "-",
   "len",
   "(",
   "tail_body",
   ")",
   ")",
   "+",
   "tail_body",
   "+",
   "pointer_char",
   "else",
   ":",
   "tail",
   "=",
   "\" \"",
   "*",
   "char_no",
   "+",
   "pointer_char",
   "+",
   "tail_body",
   "if",
   "show_line_numbers",
   ":",
   "line_no_width",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "math",
   ".",
   "log10",
   "(",
   "<mask>",
   "(",
   "1",
   ",",
   "line_no",
   "+",
   "surrounding_lines",
   ")",
   ")",
   ")",
   "+",
   "1",
   ")",
   "line_fmt",
   "=",
   "\"{0:\"",
   "+",
   "str",
   "(",
   "line_no_width",
   ")",
   "+",
   "\"}: {1}\"",
   "else",
   ":",
   "line_fmt",
   "=",
   "\"{1}\"",
   "pivot",
   "=",
   "line_no",
   "+",
   "1",
   "output_lines",
   "=",
   "[",
   "(",
   "pivot",
   ",",
   "line",
   ")",
   ",",
   "(",
   "\"\"",
   ",",
   "tail",
   ")",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "surrounding_lines",
   ")",
   ":",
   "upper_ofst",
   "=",
   "i",
   "+",
   "1",
   "upper_idx",
   "=",
   "line_no",
   "+",
   "upper_ofst",
   "lower_ofst",
   "=",
   "-",
   "upper_ofst",
   "lower_idx",
   "=",
   "line_no",
   "+",
   "lower_ofst",
   "if",
   "lower_idx",
   ">=",
   "0",
   ":",
   "output_lines",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "(",
   "pivot",
   "+",
   "lower_ofst",
   ",",
   "lines",
   "[",
   "lower_idx",
   "]",
   ")",
   ")",
   "if",
   "upper_idx",
   "<",
   "len",
   "(",
   "lines",
   ")",
   ":",
   "output_lines",
   ".",
   "append",
   "(",
   "(",
   "pivot",
   "+",
   "upper_ofst",
   ",",
   "lines",
   "[",
   "upper_idx",
   "]",
   ")",
   ")",
   "return",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "line_fmt",
   ".",
   "format",
   "(",
   "n",
   ",",
   "c",
   ")",
   "for",
   "n",
   ",",
   "c",
   "in",
   "output_lines",
   ")"
  ]
 },
 {
  "idx": "maxmin-882",
  "nl_tokens": [
   "Send",
   "all",
   "data",
   "on",
   "the",
   "connection",
   ".",
   "This",
   "calls",
   "send",
   "()",
   "repeatedly",
   "until",
   "all",
   "data",
   "is",
   "sent",
   ".",
   "If",
   "an",
   "error",
   "occurs",
   "it",
   "s",
   "impossible",
   "to",
   "tell",
   "how",
   "much",
   "data",
   "has",
   "been",
   "sent",
   "."
  ],
  "pl_tokens": [
   "def",
   "sendall",
   "(",
   "self",
   ",",
   "buf",
   ",",
   "flags",
   "=",
   "0",
   ")",
   ":",
   "buf",
   "=",
   "_text_to_bytes_and_warn",
   "(",
   "\"buf\"",
   ",",
   "buf",
   ")",
   "if",
   "isinstance",
   "(",
   "buf",
   ",",
   "memoryview",
   ")",
   ":",
   "buf",
   "=",
   "buf",
   ".",
   "tobytes",
   "(",
   ")",
   "if",
   "isinstance",
   "(",
   "buf",
   ",",
   "_buffer",
   ")",
   ":",
   "buf",
   "=",
   "str",
   "(",
   "buf",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "buf",
   ",",
   "bytes",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"buf must be a memoryview, buffer or byte string\"",
   ")",
   "left_to_send",
   "=",
   "len",
   "(",
   "buf",
   ")",
   "total_sent",
   "=",
   "0",
   "data",
   "=",
   "_ffi",
   ".",
   "new",
   "(",
   "\"char[]\"",
   ",",
   "buf",
   ")",
   "while",
   "left_to_send",
   ":",
   "# SSL_write's num arg is an int,",
   "# so we cannot send more than 2**31-1 bytes at once.",
   "result",
   "=",
   "_lib",
   ".",
   "SSL_write",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "data",
   "+",
   "total_sent",
   ",",
   "<mask>",
   "(",
   "left_to_send",
   ",",
   "2147483647",
   ")",
   ")",
   "self",
   ".",
   "_raise_ssl_error",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "result",
   ")",
   "total_sent",
   "+=",
   "result",
   "left_to_send",
   "-=",
   "result"
  ]
 },
 {
  "idx": "maxmin-883",
  "nl_tokens": [
   "Pre",
   "-",
   "process",
   "list",
   "of",
   "variants",
   "."
  ],
  "pl_tokens": [
   "def",
   "gene_variants",
   "(",
   "store",
   ",",
   "variants_query",
   ",",
   "page",
   "=",
   "1",
   ",",
   "per_page",
   "=",
   "50",
   ")",
   ":",
   "variant_count",
   "=",
   "variants_query",
   ".",
   "count",
   "(",
   ")",
   "skip_count",
   "=",
   "per_page",
   "*",
   "<mask>",
   "(",
   "page",
   "-",
   "1",
   ",",
   "0",
   ")",
   "more_variants",
   "=",
   "True",
   "if",
   "variant_count",
   ">",
   "(",
   "skip_count",
   "+",
   "per_page",
   ")",
   "else",
   "False",
   "variant_res",
   "=",
   "variants_query",
   ".",
   "skip",
   "(",
   "skip_count",
   ")",
   ".",
   "limit",
   "(",
   "per_page",
   ")",
   "my_institutes",
   "=",
   "list",
   "(",
   "inst",
   "[",
   "'_id'",
   "]",
   "for",
   "inst",
   "in",
   "user_institutes",
   "(",
   "store",
   ",",
   "current_user",
   ")",
   ")",
   "variants",
   "=",
   "[",
   "]",
   "for",
   "variant_obj",
   "in",
   "variant_res",
   ":",
   "# hide other institutes for now",
   "if",
   "variant_obj",
   "[",
   "'institute'",
   "]",
   "not",
   "in",
   "my_institutes",
   ":",
   "LOG",
   ".",
   "warning",
   "(",
   "\"Institute {} not allowed.\"",
   ".",
   "format",
   "(",
   "variant_obj",
   "[",
   "'institute'",
   "]",
   ")",
   ")",
   "continue",
   "# Populate variant case_display_name",
   "variant_case_obj",
   "=",
   "store",
   ".",
   "case",
   "(",
   "case_id",
   "=",
   "variant_obj",
   "[",
   "'case_id'",
   "]",
   ")",
   "if",
   "not",
   "variant_case_obj",
   ":",
   "# A variant with missing case was encountered",
   "continue",
   "case_display_name",
   "=",
   "variant_case_obj",
   ".",
   "get",
   "(",
   "'display_name'",
   ")",
   "variant_obj",
   "[",
   "'case_display_name'",
   "]",
   "=",
   "case_display_name",
   "genome_build",
   "=",
   "variant_case_obj",
   ".",
   "get",
   "(",
   "'genome_build'",
   ",",
   "'37'",
   ")",
   "if",
   "genome_build",
   "not",
   "in",
   "[",
   "'37'",
   ",",
   "'38'",
   "]",
   ":",
   "genome_build",
   "=",
   "'37'",
   "# Update the HGNC symbols if they are not set",
   "variant_genes",
   "=",
   "variant_obj",
   ".",
   "get",
   "(",
   "'genes'",
   ")",
   "if",
   "variant_genes",
   "is",
   "not",
   "None",
   ":",
   "for",
   "gene_obj",
   "in",
   "variant_genes",
   ":",
   "# If there is no hgnc id there is nothin we can do",
   "if",
   "not",
   "gene_obj",
   "[",
   "'hgnc_id'",
   "]",
   ":",
   "continue",
   "# Else we collect the gene object and check the id",
   "if",
   "gene_obj",
   ".",
   "get",
   "(",
   "'hgnc_symbol'",
   ")",
   "is",
   "None",
   "or",
   "gene_obj",
   ".",
   "get",
   "(",
   "'description'",
   ")",
   "is",
   "None",
   ":",
   "hgnc_gene",
   "=",
   "store",
   ".",
   "hgnc_gene",
   "(",
   "gene_obj",
   "[",
   "'hgnc_id'",
   "]",
   ",",
   "build",
   "=",
   "genome_build",
   ")",
   "if",
   "not",
   "hgnc_gene",
   ":",
   "continue",
   "gene_obj",
   "[",
   "'hgnc_symbol'",
   "]",
   "=",
   "hgnc_gene",
   "[",
   "'hgnc_symbol'",
   "]",
   "gene_obj",
   "[",
   "'description'",
   "]",
   "=",
   "hgnc_gene",
   "[",
   "'description'",
   "]",
   "# Populate variant HGVS and predictions",
   "gene_ids",
   "=",
   "[",
   "]",
   "gene_symbols",
   "=",
   "[",
   "]",
   "hgvs_c",
   "=",
   "[",
   "]",
   "hgvs_p",
   "=",
   "[",
   "]",
   "variant_genes",
   "=",
   "variant_obj",
   ".",
   "get",
   "(",
   "'genes'",
   ")",
   "if",
   "variant_genes",
   "is",
   "not",
   "None",
   ":",
   "functional_annotation",
   "=",
   "''",
   "for",
   "gene_obj",
   "in",
   "variant_genes",
   ":",
   "hgnc_id",
   "=",
   "gene_obj",
   "[",
   "'hgnc_id'",
   "]",
   "gene_symbol",
   "=",
   "gene",
   "(",
   "store",
   ",",
   "hgnc_id",
   ")",
   "[",
   "'symbol'",
   "]",
   "gene_ids",
   ".",
   "append",
   "(",
   "hgnc_id",
   ")",
   "gene_symbols",
   ".",
   "append",
   "(",
   "gene_symbol",
   ")",
   "hgvs_nucleotide",
   "=",
   "'-'",
   "# gather HGVS info from gene transcripts",
   "transcripts_list",
   "=",
   "gene_obj",
   ".",
   "get",
   "(",
   "'transcripts'",
   ")",
   "for",
   "transcript_obj",
   "in",
   "transcripts_list",
   ":",
   "if",
   "transcript_obj",
   ".",
   "get",
   "(",
   "'is_canonical'",
   ")",
   "and",
   "transcript_obj",
   ".",
   "get",
   "(",
   "'is_canonical'",
   ")",
   "is",
   "True",
   ":",
   "hgvs_nucleotide",
   "=",
   "str",
   "(",
   "transcript_obj",
   ".",
   "get",
   "(",
   "'coding_sequence_name'",
   ")",
   ")",
   "hgvs_protein",
   "=",
   "str",
   "(",
   "transcript_obj",
   ".",
   "get",
   "(",
   "'protein_sequence_name'",
   ")",
   ")",
   "hgvs_c",
   ".",
   "append",
   "(",
   "hgvs_nucleotide",
   ")",
   "hgvs_p",
   ".",
   "append",
   "(",
   "hgvs_protein",
   ")",
   "if",
   "len",
   "(",
   "gene_symbols",
   ")",
   "==",
   "1",
   ":",
   "if",
   "(",
   "hgvs_p",
   "[",
   "0",
   "]",
   "!=",
   "\"None\"",
   ")",
   ":",
   "hgvs",
   "=",
   "hgvs_p",
   "[",
   "0",
   "]",
   "elif",
   "(",
   "hgvs_c",
   "[",
   "0",
   "]",
   "!=",
   "\"None\"",
   ")",
   ":",
   "hgvs",
   "=",
   "hgvs_c",
   "[",
   "0",
   "]",
   "else",
   ":",
   "hgvs",
   "=",
   "\"-\"",
   "variant_obj",
   "[",
   "'hgvs'",
   "]",
   "=",
   "hgvs",
   "# populate variant predictions for display",
   "variant_obj",
   ".",
   "update",
   "(",
   "get_predictions",
   "(",
   "variant_genes",
   ")",
   ")",
   "variants",
   ".",
   "append",
   "(",
   "variant_obj",
   ")",
   "return",
   "{",
   "'variants'",
   ":",
   "variants",
   ",",
   "'more_variants'",
   ":",
   "more_variants",
   ",",
   "}"
  ]
 },
 {
  "idx": "maxmin-884",
  "nl_tokens": [
   "Plot",
   "a",
   "hinton",
   "diagram",
   "for",
   "the",
   "quanum",
   "state",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_state_hinton",
   "(",
   "rho",
   ",",
   "title",
   "=",
   "''",
   ",",
   "figsize",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "HAS_MATPLOTLIB",
   ":",
   "raise",
   "ImportError",
   "(",
   "'Must have Matplotlib installed.'",
   ")",
   "rho",
   "=",
   "_validate_input_state",
   "(",
   "rho",
   ")",
   "if",
   "figsize",
   "is",
   "None",
   ":",
   "figsize",
   "=",
   "(",
   "8",
   ",",
   "5",
   ")",
   "num",
   "=",
   "int",
   "(",
   "np",
   ".",
   "log2",
   "(",
   "len",
   "(",
   "rho",
   ")",
   ")",
   ")",
   "fig",
   ",",
   "(",
   "ax1",
   ",",
   "ax2",
   ")",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "1",
   ",",
   "2",
   ",",
   "figsize",
   "=",
   "figsize",
   ")",
   "max_weight",
   "=",
   "2",
   "**",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "log",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "rho",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "/",
   "np",
   ".",
   "log",
   "(",
   "2",
   ")",
   ")",
   "datareal",
   "=",
   "np",
   ".",
   "real",
   "(",
   "rho",
   ")",
   "dataimag",
   "=",
   "np",
   ".",
   "imag",
   "(",
   "rho",
   ")",
   "column_names",
   "=",
   "[",
   "bin",
   "(",
   "i",
   ")",
   "[",
   "2",
   ":",
   "]",
   ".",
   "zfill",
   "(",
   "num",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   "]",
   "row_names",
   "=",
   "[",
   "bin",
   "(",
   "i",
   ")",
   "[",
   "2",
   ":",
   "]",
   ".",
   "zfill",
   "(",
   "num",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   "]",
   "lx",
   "=",
   "len",
   "(",
   "datareal",
   "[",
   "0",
   "]",
   ")",
   "# Work out matrix dimensions",
   "ly",
   "=",
   "len",
   "(",
   "datareal",
   "[",
   ":",
   ",",
   "0",
   "]",
   ")",
   "# Real",
   "ax1",
   ".",
   "patch",
   ".",
   "set_facecolor",
   "(",
   "'gray'",
   ")",
   "ax1",
   ".",
   "set_aspect",
   "(",
   "'equal'",
   ",",
   "'box'",
   ")",
   "ax1",
   ".",
   "xaxis",
   ".",
   "set_major_locator",
   "(",
   "plt",
   ".",
   "NullLocator",
   "(",
   ")",
   ")",
   "ax1",
   ".",
   "yaxis",
   ".",
   "set_major_locator",
   "(",
   "plt",
   ".",
   "NullLocator",
   "(",
   ")",
   ")",
   "for",
   "(",
   "x",
   ",",
   "y",
   ")",
   ",",
   "w",
   "in",
   "np",
   ".",
   "ndenumerate",
   "(",
   "datareal",
   ")",
   ":",
   "color",
   "=",
   "'white'",
   "if",
   "w",
   ">",
   "0",
   "else",
   "'black'",
   "size",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "w",
   ")",
   "/",
   "max_weight",
   ")",
   "rect",
   "=",
   "plt",
   ".",
   "Rectangle",
   "(",
   "[",
   "x",
   "-",
   "size",
   "/",
   "2",
   ",",
   "y",
   "-",
   "size",
   "/",
   "2",
   "]",
   ",",
   "size",
   ",",
   "size",
   ",",
   "facecolor",
   "=",
   "color",
   ",",
   "edgecolor",
   "=",
   "color",
   ")",
   "ax1",
   ".",
   "add_patch",
   "(",
   "rect",
   ")",
   "ax1",
   ".",
   "set_xticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "lx",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "ax1",
   ".",
   "set_yticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "ly",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "ax1",
   ".",
   "set_yticklabels",
   "(",
   "row_names",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "ax1",
   ".",
   "set_xticklabels",
   "(",
   "column_names",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "90",
   ")",
   "ax1",
   ".",
   "autoscale_view",
   "(",
   ")",
   "ax1",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "ax1",
   ".",
   "set_title",
   "(",
   "'Real[rho]'",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "# Imaginary",
   "ax2",
   ".",
   "patch",
   ".",
   "set_facecolor",
   "(",
   "'gray'",
   ")",
   "ax2",
   ".",
   "set_aspect",
   "(",
   "'equal'",
   ",",
   "'box'",
   ")",
   "ax2",
   ".",
   "xaxis",
   ".",
   "set_major_locator",
   "(",
   "plt",
   ".",
   "NullLocator",
   "(",
   ")",
   ")",
   "ax2",
   ".",
   "yaxis",
   ".",
   "set_major_locator",
   "(",
   "plt",
   ".",
   "NullLocator",
   "(",
   ")",
   ")",
   "for",
   "(",
   "x",
   ",",
   "y",
   ")",
   ",",
   "w",
   "in",
   "np",
   ".",
   "ndenumerate",
   "(",
   "dataimag",
   ")",
   ":",
   "color",
   "=",
   "'white'",
   "if",
   "w",
   ">",
   "0",
   "else",
   "'black'",
   "size",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "w",
   ")",
   "/",
   "max_weight",
   ")",
   "rect",
   "=",
   "plt",
   ".",
   "Rectangle",
   "(",
   "[",
   "x",
   "-",
   "size",
   "/",
   "2",
   ",",
   "y",
   "-",
   "size",
   "/",
   "2",
   "]",
   ",",
   "size",
   ",",
   "size",
   ",",
   "facecolor",
   "=",
   "color",
   ",",
   "edgecolor",
   "=",
   "color",
   ")",
   "ax2",
   ".",
   "add_patch",
   "(",
   "rect",
   ")",
   "if",
   "np",
   ".",
   "any",
   "(",
   "dataimag",
   "!=",
   "0",
   ")",
   ":",
   "ax2",
   ".",
   "set_xticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "lx",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "ax2",
   ".",
   "set_yticks",
   "(",
   "np",
   ".",
   "arange",
   "(",
   "0",
   ",",
   "ly",
   "+",
   "0.5",
   ",",
   "1",
   ")",
   ")",
   "ax2",
   ".",
   "set_yticklabels",
   "(",
   "row_names",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "ax2",
   ".",
   "set_xticklabels",
   "(",
   "column_names",
   ",",
   "fontsize",
   "=",
   "14",
   ",",
   "rotation",
   "=",
   "90",
   ")",
   "ax2",
   ".",
   "autoscale_view",
   "(",
   ")",
   "ax2",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "ax2",
   ".",
   "set_title",
   "(",
   "'Imag[rho]'",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "if",
   "title",
   ":",
   "fig",
   ".",
   "suptitle",
   "(",
   "title",
   ",",
   "fontsize",
   "=",
   "16",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "fig",
   ")",
   "return",
   "fig"
  ]
 },
 {
  "idx": "maxmin-885",
  "nl_tokens": [
   "Returns",
   "Twitter",
   "Bootstrap",
   "CSS",
   "file",
   ".",
   "TEMPLATE_DEBUG",
   "returns",
   "full",
   "file",
   "otherwise",
   "returns",
   "minified",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "djfrontend_twbs_css",
   "(",
   "version",
   "=",
   "None",
   ")",
   ":",
   "if",
   "version",
   "is",
   "None",
   ":",
   "if",
   "not",
   "getattr",
   "(",
   "settings",
   ",",
   "'DJFRONTEND_TWBS_CSS'",
   ",",
   "False",
   ")",
   ":",
   "version",
   "=",
   "getattr",
   "(",
   "settings",
   ",",
   "'DJFRONTEND_TWBS_VERSION'",
   ",",
   "DJFRONTEND_TWBS_VERSION_DEFAULT",
   ")",
   "else",
   ":",
   "version",
   "=",
   "getattr",
   "(",
   "settings",
   ",",
   "'DJFRONTEND_TWBS_CSS'",
   ",",
   "DJFRONTEND_TWBS_VERSION_DEFAULT",
   ")",
   "return",
   "format_html",
   "(",
   "'<link rel=\"stylesheet\" href=\"{static}djfrontend/css/twbs/{v}/bootstrap{min}.css\">'",
   ",",
   "static",
   "=",
   "_static_url",
   ",",
   "v",
   "=",
   "version",
   ",",
   "<mask>",
   "=",
   "_min",
   ")"
  ]
 },
 {
  "idx": "maxmin-886",
  "nl_tokens": [
   "Split",
   "the",
   "storage",
   "to",
   "run",
   "of",
   "char",
   "types",
   "at",
   "the",
   "same",
   "level",
   "."
  ],
  "pl_tokens": [
   "def",
   "calc_level_runs",
   "(",
   "storage",
   ")",
   ":",
   "# run level depends on the higher of the two levels on either side of",
   "# the boundary If the higher level is odd, the type is R; otherwise,",
   "# it is L",
   "storage",
   "[",
   "'runs'",
   "]",
   ".",
   "clear",
   "(",
   ")",
   "chars",
   "=",
   "storage",
   "[",
   "'chars'",
   "]",
   "# empty string ?",
   "if",
   "not",
   "chars",
   ":",
   "return",
   "def",
   "calc_level_run",
   "(",
   "b_l",
   ",",
   "b_r",
   ")",
   ":",
   "return",
   "[",
   "'L'",
   ",",
   "'R'",
   "]",
   "[",
   "<mask>",
   "(",
   "b_l",
   ",",
   "b_r",
   ")",
   "%",
   "2",
   "]",
   "first_char",
   "=",
   "chars",
   "[",
   "0",
   "]",
   "sor",
   "=",
   "calc_level_run",
   "(",
   "storage",
   "[",
   "'base_level'",
   "]",
   ",",
   "first_char",
   "[",
   "'level'",
   "]",
   ")",
   "eor",
   "=",
   "None",
   "run_start",
   "=",
   "run_length",
   "=",
   "0",
   "prev_level",
   ",",
   "prev_type",
   "=",
   "first_char",
   "[",
   "'level'",
   "]",
   ",",
   "first_char",
   "[",
   "'type'",
   "]",
   "for",
   "_ch",
   "in",
   "chars",
   ":",
   "curr_level",
   ",",
   "curr_type",
   "=",
   "_ch",
   "[",
   "'level'",
   "]",
   ",",
   "_ch",
   "[",
   "'type'",
   "]",
   "if",
   "curr_level",
   "==",
   "prev_level",
   ":",
   "run_length",
   "+=",
   "1",
   "else",
   ":",
   "eor",
   "=",
   "calc_level_run",
   "(",
   "prev_level",
   ",",
   "curr_level",
   ")",
   "storage",
   "[",
   "'runs'",
   "]",
   ".",
   "append",
   "(",
   "{",
   "'sor'",
   ":",
   "sor",
   ",",
   "'eor'",
   ":",
   "eor",
   ",",
   "'start'",
   ":",
   "run_start",
   ",",
   "'type'",
   ":",
   "prev_type",
   ",",
   "'length'",
   ":",
   "run_length",
   "}",
   ")",
   "sor",
   "=",
   "eor",
   "run_start",
   "+=",
   "run_length",
   "run_length",
   "=",
   "1",
   "prev_level",
   ",",
   "prev_type",
   "=",
   "curr_level",
   ",",
   "curr_type",
   "# for the last char/runlevel",
   "eor",
   "=",
   "calc_level_run",
   "(",
   "curr_level",
   ",",
   "storage",
   "[",
   "'base_level'",
   "]",
   ")",
   "storage",
   "[",
   "'runs'",
   "]",
   ".",
   "append",
   "(",
   "{",
   "'sor'",
   ":",
   "sor",
   ",",
   "'eor'",
   ":",
   "eor",
   ",",
   "'start'",
   ":",
   "run_start",
   ",",
   "'type'",
   ":",
   "curr_type",
   ",",
   "'length'",
   ":",
   "run_length",
   "}",
   ")"
  ]
 },
 {
  "idx": "maxmin-887",
  "nl_tokens": [
   "Count",
   "of",
   "complete",
   "words",
   "between",
   "two",
   "addresses"
  ],
  "pl_tokens": [
   "def",
   "fullWordCnt",
   "(",
   "self",
   ",",
   "start",
   ":",
   "int",
   ",",
   "end",
   ":",
   "int",
   ")",
   ":",
   "assert",
   "end",
   ">=",
   "start",
   ",",
   "(",
   "start",
   ",",
   "end",
   ")",
   "gap",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "(",
   "end",
   "-",
   "start",
   ")",
   "-",
   "(",
   "start",
   "%",
   "self",
   ".",
   "wordWidth",
   ")",
   ")",
   "return",
   "gap",
   "//",
   "self",
   ".",
   "wordWidth"
  ]
 },
 {
  "idx": "maxmin-888",
  "nl_tokens": [
   "Computes",
   "the",
   "min_event_ndims",
   "associated",
   "with",
   "the",
   "give",
   "list",
   "of",
   "bijectors",
   "."
  ],
  "pl_tokens": [
   "def",
   "_compute_min_event_ndims",
   "(",
   "bijector_list",
   ",",
   "compute_forward",
   "=",
   "True",
   ")",
   ":",
   "min_event_ndims",
   "=",
   "0",
   "# This is a mouthful, but what this encapsulates is that if not for rank",
   "# changing bijectors, we'd only need to compute the largest of the min",
   "# required ndims. Hence \"max_min\". Due to rank changing bijectors, we need to",
   "# account for synthetic rank growth / synthetic rank decrease from a rank",
   "# changing bijector.",
   "rank_changed_adjusted_max_min_event_ndims",
   "=",
   "0",
   "if",
   "compute_forward",
   ":",
   "bijector_list",
   "=",
   "reversed",
   "(",
   "bijector_list",
   ")",
   "for",
   "b",
   "in",
   "bijector_list",
   ":",
   "if",
   "compute_forward",
   ":",
   "current_min_event_ndims",
   "=",
   "b",
   ".",
   "forward_min_event_ndims",
   "current_inverse_min_event_ndims",
   "=",
   "b",
   ".",
   "inverse_min_event_ndims",
   "else",
   ":",
   "current_min_event_ndims",
   "=",
   "b",
   ".",
   "inverse_min_event_ndims",
   "current_inverse_min_event_ndims",
   "=",
   "b",
   ".",
   "forward_min_event_ndims",
   "# New dimensions were touched.",
   "if",
   "rank_changed_adjusted_max_min_event_ndims",
   "<",
   "current_min_event_ndims",
   ":",
   "min_event_ndims",
   "+=",
   "(",
   "current_min_event_ndims",
   "-",
   "rank_changed_adjusted_max_min_event_ndims",
   ")",
   "rank_changed_adjusted_max_min_event_ndims",
   "=",
   "<mask>",
   "(",
   "current_min_event_ndims",
   ",",
   "rank_changed_adjusted_max_min_event_ndims",
   ")",
   "# If the number of dimensions has increased via forward, then",
   "# inverse_min_event_ndims > forward_min_event_ndims, and hence the",
   "# dimensions we computed on, have moved left (so we have operated",
   "# on additional dimensions).",
   "# Conversely, if the number of dimensions has decreased via forward,",
   "# then we have inverse_min_event_ndims < forward_min_event_ndims,",
   "# and so we will have operated on fewer right most dimensions.",
   "number_of_changed_dimensions",
   "=",
   "(",
   "current_min_event_ndims",
   "-",
   "current_inverse_min_event_ndims",
   ")",
   "rank_changed_adjusted_max_min_event_ndims",
   "-=",
   "number_of_changed_dimensions",
   "return",
   "min_event_ndims"
  ]
 },
 {
  "idx": "maxmin-889",
  "nl_tokens": [
   "Internal",
   "function",
   "that",
   "updates",
   "the",
   "status",
   "of",
   "a",
   "HTML",
   "job",
   "monitor",
   "."
  ],
  "pl_tokens": [
   "def",
   "_html_checker",
   "(",
   "job_var",
   ",",
   "interval",
   ",",
   "status",
   ",",
   "header",
   ",",
   "_interval_set",
   "=",
   "False",
   ")",
   ":",
   "job_status",
   "=",
   "job_var",
   ".",
   "status",
   "(",
   ")",
   "job_status_name",
   "=",
   "job_status",
   ".",
   "name",
   "job_status_msg",
   "=",
   "job_status",
   ".",
   "value",
   "status",
   ".",
   "value",
   "=",
   "header",
   "%",
   "(",
   "job_status_msg",
   ")",
   "while",
   "job_status_name",
   "not",
   "in",
   "[",
   "'DONE'",
   ",",
   "'CANCELLED'",
   "]",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "interval",
   ")",
   "job_status",
   "=",
   "job_var",
   ".",
   "status",
   "(",
   ")",
   "job_status_name",
   "=",
   "job_status",
   ".",
   "name",
   "job_status_msg",
   "=",
   "job_status",
   ".",
   "value",
   "if",
   "job_status_name",
   "==",
   "'ERROR'",
   ":",
   "break",
   "else",
   ":",
   "if",
   "job_status_name",
   "==",
   "'QUEUED'",
   ":",
   "job_status_msg",
   "+=",
   "' (%s)'",
   "%",
   "job_var",
   ".",
   "queue_position",
   "(",
   ")",
   "if",
   "not",
   "_interval_set",
   ":",
   "interval",
   "=",
   "<mask>",
   "(",
   "job_var",
   ".",
   "queue_position",
   "(",
   ")",
   ",",
   "2",
   ")",
   "else",
   ":",
   "if",
   "not",
   "_interval_set",
   ":",
   "interval",
   "=",
   "2",
   "status",
   ".",
   "value",
   "=",
   "header",
   "%",
   "(",
   "job_status_msg",
   ")",
   "status",
   ".",
   "value",
   "=",
   "header",
   "%",
   "(",
   "job_status_msg",
   ")"
  ]
 },
 {
  "idx": "maxmin-890",
  "nl_tokens": [
   "Print",
   "a",
   "string",
   "piping",
   "through",
   "a",
   "pager",
   "after",
   "a",
   "certain",
   "length",
   "."
  ],
  "pl_tokens": [
   "def",
   "page",
   "(",
   "strng",
   ",",
   "start",
   "=",
   "0",
   ",",
   "screen_lines",
   "=",
   "0",
   ",",
   "pager_cmd",
   "=",
   "None",
   ")",
   ":",
   "# Some routines may auto-compute start offsets incorrectly and pass a",
   "# negative value.  Offset to 0 for robustness.",
   "start",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "start",
   ")",
   "# first, try the hook",
   "ip",
   "=",
   "ipapi",
   ".",
   "get",
   "(",
   ")",
   "if",
   "ip",
   ":",
   "try",
   ":",
   "ip",
   ".",
   "hooks",
   ".",
   "show_in_pager",
   "(",
   "strng",
   ")",
   "return",
   "except",
   "TryNext",
   ":",
   "pass",
   "# Ugly kludge, but calling curses.initscr() flat out crashes in emacs",
   "TERM",
   "=",
   "os",
   ".",
   "environ",
   ".",
   "get",
   "(",
   "'TERM'",
   ",",
   "'dumb'",
   ")",
   "if",
   "TERM",
   "in",
   "[",
   "'dumb'",
   ",",
   "'emacs'",
   "]",
   "and",
   "os",
   ".",
   "name",
   "!=",
   "'nt'",
   ":",
   "print",
   "strng",
   "return",
   "# chop off the topmost part of the string we don't want to see",
   "str_lines",
   "=",
   "strng",
   ".",
   "splitlines",
   "(",
   ")",
   "[",
   "start",
   ":",
   "]",
   "str_toprint",
   "=",
   "os",
   ".",
   "linesep",
   ".",
   "join",
   "(",
   "str_lines",
   ")",
   "num_newlines",
   "=",
   "len",
   "(",
   "str_lines",
   ")",
   "len_str",
   "=",
   "len",
   "(",
   "str_toprint",
   ")",
   "# Dumb heuristics to guesstimate number of on-screen lines the string",
   "# takes.  Very basic, but good enough for docstrings in reasonable",
   "# terminals. If someone later feels like refining it, it's not hard.",
   "numlines",
   "=",
   "max",
   "(",
   "num_newlines",
   ",",
   "int",
   "(",
   "len_str",
   "/",
   "80",
   ")",
   "+",
   "1",
   ")",
   "screen_lines_def",
   "=",
   "get_terminal_size",
   "(",
   ")",
   "[",
   "1",
   "]",
   "# auto-determine screen size",
   "if",
   "screen_lines",
   "<=",
   "0",
   ":",
   "try",
   ":",
   "screen_lines",
   "+=",
   "_detect_screen_size",
   "(",
   "use_curses",
   ",",
   "screen_lines_def",
   ")",
   "except",
   "(",
   "TypeError",
   ",",
   "UnsupportedOperation",
   ")",
   ":",
   "print",
   ">>",
   "io",
   ".",
   "stdout",
   ",",
   "str_toprint",
   "return",
   "#print 'numlines',numlines,'screenlines',screen_lines  # dbg",
   "if",
   "numlines",
   "<=",
   "screen_lines",
   ":",
   "#print '*** normal print'  # dbg",
   "print",
   ">>",
   "io",
   ".",
   "stdout",
   ",",
   "str_toprint",
   "else",
   ":",
   "# Try to open pager and default to internal one if that fails.",
   "# All failure modes are tagged as 'retval=1', to match the return",
   "# value of a failed system command.  If any intermediate attempt",
   "# sets retval to 1, at the end we resort to our own page_dumb() pager.",
   "pager_cmd",
   "=",
   "get_pager_cmd",
   "(",
   "pager_cmd",
   ")",
   "pager_cmd",
   "+=",
   "' '",
   "+",
   "get_pager_start",
   "(",
   "pager_cmd",
   ",",
   "start",
   ")",
   "if",
   "os",
   ".",
   "name",
   "==",
   "'nt'",
   ":",
   "if",
   "pager_cmd",
   ".",
   "startswith",
   "(",
   "'type'",
   ")",
   ":",
   "# The default WinXP 'type' command is failing on complex strings.",
   "retval",
   "=",
   "1",
   "else",
   ":",
   "tmpname",
   "=",
   "tempfile",
   ".",
   "mktemp",
   "(",
   "'.txt'",
   ")",
   "tmpfile",
   "=",
   "open",
   "(",
   "tmpname",
   ",",
   "'wt'",
   ")",
   "tmpfile",
   ".",
   "write",
   "(",
   "strng",
   ")",
   "tmpfile",
   ".",
   "close",
   "(",
   ")",
   "cmd",
   "=",
   "\"%s < %s\"",
   "%",
   "(",
   "pager_cmd",
   ",",
   "tmpname",
   ")",
   "if",
   "os",
   ".",
   "system",
   "(",
   "cmd",
   ")",
   ":",
   "retval",
   "=",
   "1",
   "else",
   ":",
   "retval",
   "=",
   "None",
   "os",
   ".",
   "remove",
   "(",
   "tmpname",
   ")",
   "else",
   ":",
   "try",
   ":",
   "retval",
   "=",
   "None",
   "# if I use popen4, things hang. No idea why.",
   "#pager,shell_out = os.popen4(pager_cmd)",
   "pager",
   "=",
   "os",
   ".",
   "popen",
   "(",
   "pager_cmd",
   ",",
   "'w'",
   ")",
   "pager",
   ".",
   "write",
   "(",
   "strng",
   ")",
   "pager",
   ".",
   "close",
   "(",
   ")",
   "retval",
   "=",
   "pager",
   ".",
   "close",
   "(",
   ")",
   "# success returns None",
   "except",
   "IOError",
   ",",
   "msg",
   ":",
   "# broken pipe when user quits",
   "if",
   "msg",
   ".",
   "args",
   "==",
   "(",
   "32",
   ",",
   "'Broken pipe'",
   ")",
   ":",
   "retval",
   "=",
   "None",
   "else",
   ":",
   "retval",
   "=",
   "1",
   "except",
   "OSError",
   ":",
   "# Other strange problems, sometimes seen in Win2k/cygwin",
   "retval",
   "=",
   "1",
   "if",
   "retval",
   "is",
   "not",
   "None",
   ":",
   "page_dumb",
   "(",
   "strng",
   ",",
   "screen_lines",
   "=",
   "screen_lines",
   ")"
  ]
 },
 {
  "idx": "maxmin-891",
  "nl_tokens": [
   "Set",
   "branch",
   "lengths",
   "to",
   "either",
   "mutation",
   "lengths",
   "of",
   "given",
   "branch",
   "lengths",
   ".",
   "The",
   "assigend",
   "values",
   "are",
   "to",
   "be",
   "used",
   "in",
   "the",
   "following",
   "ML",
   "analysis",
   "."
  ],
  "pl_tokens": [
   "def",
   "_branch_length_to_gtr",
   "(",
   "self",
   ",",
   "node",
   ")",
   ":",
   "if",
   "self",
   ".",
   "use_mutation_length",
   ":",
   "return",
   "<mask>",
   "(",
   "ttconf",
   ".",
   "MIN_BRANCH_LENGTH",
   "*",
   "self",
   ".",
   "one_mutation",
   ",",
   "node",
   ".",
   "mutation_length",
   ")",
   "else",
   ":",
   "return",
   "max",
   "(",
   "ttconf",
   ".",
   "MIN_BRANCH_LENGTH",
   "*",
   "self",
   ".",
   "one_mutation",
   ",",
   "node",
   ".",
   "branch_length",
   ")"
  ]
 },
 {
  "idx": "maxmin-892",
  "nl_tokens": [
   "Parameters",
   "----------",
   "model_name",
   ":",
   "str",
   "default",
   "None",
   "if",
   "given",
   "will",
   "be",
   "used",
   "as",
   "external",
   "file",
   "directory",
   "base",
   "name"
  ],
  "pl_tokens": [
   "def",
   "to_idf",
   "(",
   "self",
   ",",
   "model_name",
   "=",
   "None",
   ")",
   ":",
   "json_data",
   "=",
   "self",
   ".",
   "to_json_data",
   "(",
   "model_name",
   "=",
   "model_name",
   ")",
   "# record descriptor ref",
   "s",
   "=",
   "f\"{self._table._dev_descriptor.table_name},\\n\"",
   "# fields",
   "# fields_nb: we don't use len(self) but max(self). We wan't to stop if no more values (even base fields)",
   "#   because some idd records are defined without extensibles (although they should used them), for example",
   "#   construction, and eplus does not know what to do...",
   "fields_nb",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_data",
   ")",
   "+",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "fields_nb",
   ")",
   ":",
   "# value",
   "tab",
   "=",
   "\" \"",
   "*",
   "TAB_LEN",
   "raw_value",
   "=",
   "json_data",
   ".",
   "get",
   "(",
   "i",
   ",",
   "\"\"",
   ")",
   "content",
   "=",
   "f\"{tab}{raw_value}{';' if i == fields_nb-1 else ','}\"",
   "# comment",
   "spaces_nb",
   "=",
   "COMMENT_COLUMN_START",
   "-",
   "len",
   "(",
   "content",
   ")",
   "if",
   "spaces_nb",
   "<",
   "0",
   ":",
   "spaces_nb",
   "=",
   "TAB_LEN",
   "# comment",
   "name",
   "=",
   "self",
   ".",
   "_table",
   ".",
   "_dev_descriptor",
   ".",
   "get_extended_name",
   "(",
   "i",
   ")",
   "comment",
   "=",
   "\"\"",
   "if",
   "name",
   "is",
   "None",
   "else",
   "\" \"",
   "*",
   "spaces_nb",
   "+",
   "f\"! {name}\"",
   "# store",
   "s",
   "+=",
   "f\"{content}{comment}\\n\"",
   "return",
   "s"
  ]
 },
 {
  "idx": "maxmin-893",
  "nl_tokens": [
   "Get",
   "datetime",
   "of",
   "the",
   "next",
   "retry",
   "if",
   "the",
   "task",
   "instance",
   "fails",
   ".",
   "For",
   "exponential",
   "backoff",
   "retry_delay",
   "is",
   "used",
   "as",
   "base",
   "and",
   "will",
   "be",
   "converted",
   "to",
   "seconds",
   "."
  ],
  "pl_tokens": [
   "def",
   "next_retry_datetime",
   "(",
   "self",
   ")",
   ":",
   "delay",
   "=",
   "self",
   ".",
   "task",
   ".",
   "retry_delay",
   "if",
   "self",
   ".",
   "task",
   ".",
   "retry_exponential_backoff",
   ":",
   "min_backoff",
   "=",
   "int",
   "(",
   "delay",
   ".",
   "total_seconds",
   "(",
   ")",
   "*",
   "(",
   "2",
   "**",
   "(",
   "self",
   ".",
   "try_number",
   "-",
   "2",
   ")",
   ")",
   ")",
   "# deterministic per task instance",
   "hash",
   "=",
   "int",
   "(",
   "hashlib",
   ".",
   "sha1",
   "(",
   "\"{}#{}#{}#{}\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "dag_id",
   ",",
   "self",
   ".",
   "task_id",
   ",",
   "self",
   ".",
   "execution_date",
   ",",
   "self",
   ".",
   "try_number",
   ")",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")",
   ")",
   ".",
   "hexdigest",
   "(",
   ")",
   ",",
   "16",
   ")",
   "# between 0.5 * delay * (2^retry_number) and 1.0 * delay * (2^retry_number)",
   "modded_hash",
   "=",
   "min_backoff",
   "+",
   "hash",
   "%",
   "min_backoff",
   "# timedelta has a maximum representable value. The exponentiation",
   "# here means this value can be exceeded after a certain number",
   "# of tries (around 50 if the initial delay is 1s, even fewer if",
   "# the delay is larger). Cap the value here before creating a",
   "# timedelta object so the operation doesn't fail.",
   "delay_backoff_in_seconds",
   "=",
   "<mask>",
   "(",
   "modded_hash",
   ",",
   "timedelta",
   ".",
   "max",
   ".",
   "total_seconds",
   "(",
   ")",
   "-",
   "1",
   ")",
   "delay",
   "=",
   "timedelta",
   "(",
   "seconds",
   "=",
   "delay_backoff_in_seconds",
   ")",
   "if",
   "self",
   ".",
   "task",
   ".",
   "max_retry_delay",
   ":",
   "delay",
   "=",
   "min",
   "(",
   "self",
   ".",
   "task",
   ".",
   "max_retry_delay",
   ",",
   "delay",
   ")",
   "return",
   "self",
   ".",
   "end_date",
   "+",
   "delay"
  ]
 },
 {
  "idx": "maxmin-894",
  "nl_tokens": [
   "Estimates",
   "K",
   "running",
   "X",
   "-",
   "means",
   "algorithm",
   "(",
   "Pelleg",
   "&",
   "Moore",
   "2000",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "estimate_K_xmeans",
   "(",
   "self",
   ",",
   "th",
   "=",
   "0.2",
   ",",
   "maxK",
   "=",
   "10",
   ")",
   ":",
   "# Run initial K-means",
   "means",
   ",",
   "labels",
   "=",
   "self",
   ".",
   "run_kmeans",
   "(",
   "self",
   ".",
   "X",
   ",",
   "self",
   ".",
   "init_K",
   ")",
   "# Run X-means algorithm",
   "stop",
   "=",
   "False",
   "curr_K",
   "=",
   "self",
   ".",
   "init_K",
   "while",
   "not",
   "stop",
   ":",
   "stop",
   "=",
   "True",
   "final_means",
   "=",
   "[",
   "]",
   "for",
   "k",
   "in",
   "range",
   "(",
   "curr_K",
   ")",
   ":",
   "# Find the data that corresponds to the k-th cluster",
   "D",
   "=",
   "self",
   ".",
   "get_clustered_data",
   "(",
   "self",
   ".",
   "X",
   ",",
   "labels",
   ",",
   "k",
   ")",
   "if",
   "len",
   "(",
   "D",
   ")",
   "==",
   "0",
   "or",
   "D",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "==",
   "1",
   ":",
   "continue",
   "# Whiten and find whitened mean",
   "stdD",
   "=",
   "np",
   ".",
   "std",
   "(",
   "D",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "#D = vq.whiten(D)",
   "D",
   "/=",
   "float",
   "(",
   "stdD",
   ")",
   "# Same as line above",
   "mean",
   "=",
   "D",
   ".",
   "mean",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "# Cluster this subspace by half (K=2)",
   "half_means",
   ",",
   "half_labels",
   "=",
   "self",
   ".",
   "run_kmeans",
   "(",
   "D",
   ",",
   "K",
   "=",
   "2",
   ")",
   "# Compute BICs",
   "bic1",
   "=",
   "self",
   ".",
   "compute_bic",
   "(",
   "D",
   ",",
   "[",
   "mean",
   "]",
   ",",
   "K",
   "=",
   "1",
   ",",
   "labels",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "D",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ",",
   "R",
   "=",
   "D",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "bic2",
   "=",
   "self",
   ".",
   "compute_bic",
   "(",
   "D",
   ",",
   "half_means",
   ",",
   "K",
   "=",
   "2",
   ",",
   "labels",
   "=",
   "half_labels",
   ",",
   "R",
   "=",
   "D",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "# Split or not",
   "max_bic",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "np",
   ".",
   "abs",
   "(",
   "bic1",
   ")",
   ",",
   "np",
   ".",
   "abs",
   "(",
   "bic2",
   ")",
   "]",
   ")",
   "norm_bic1",
   "=",
   "bic1",
   "/",
   "float",
   "(",
   "max_bic",
   ")",
   "norm_bic2",
   "=",
   "bic2",
   "/",
   "float",
   "(",
   "max_bic",
   ")",
   "diff_bic",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "norm_bic1",
   "-",
   "norm_bic2",
   ")",
   "# Split!",
   "#print \"diff_bic\", diff_bic",
   "if",
   "diff_bic",
   ">",
   "th",
   ":",
   "final_means",
   ".",
   "append",
   "(",
   "half_means",
   "[",
   "0",
   "]",
   "*",
   "stdD",
   ")",
   "final_means",
   ".",
   "append",
   "(",
   "half_means",
   "[",
   "1",
   "]",
   "*",
   "stdD",
   ")",
   "curr_K",
   "+=",
   "1",
   "stop",
   "=",
   "False",
   "# Don't split",
   "else",
   ":",
   "final_means",
   ".",
   "append",
   "(",
   "mean",
   "*",
   "stdD",
   ")",
   "final_means",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "final_means",
   ")",
   "#print \"Estimated K: \", curr_K",
   "if",
   "self",
   ".",
   "plot",
   ":",
   "plt",
   ".",
   "scatter",
   "(",
   "self",
   ".",
   "X",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "self",
   ".",
   "X",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "plt",
   ".",
   "scatter",
   "(",
   "final_means",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "final_means",
   "[",
   ":",
   ",",
   "1",
   "]",
   ",",
   "color",
   "=",
   "\"y\"",
   ")",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "if",
   "curr_K",
   ">=",
   "maxK",
   "or",
   "self",
   ".",
   "X",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   "!=",
   "final_means",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ":",
   "stop",
   "=",
   "True",
   "else",
   ":",
   "labels",
   ",",
   "dist",
   "=",
   "vq",
   ".",
   "vq",
   "(",
   "self",
   ".",
   "X",
   ",",
   "final_means",
   ")",
   "return",
   "curr_K"
  ]
 },
 {
  "idx": "maxmin-895",
  "nl_tokens": [
   "calculates",
   "the",
   "wind",
   "chill",
   "value",
   "based",
   "upon",
   "the",
   "temperature",
   "(",
   "F",
   ")",
   "and",
   "wind",
   "."
  ],
  "pl_tokens": [
   "def",
   "calc_wind_chill",
   "(",
   "t",
   ",",
   "windspeed",
   ",",
   "windspeed10min",
   "=",
   "None",
   ")",
   ":",
   "w",
   "=",
   "<mask>",
   "(",
   "windspeed10min",
   ",",
   "windspeed",
   ")",
   "return",
   "35.74",
   "+",
   "0.6215",
   "*",
   "t",
   "-",
   "35.75",
   "*",
   "(",
   "w",
   "**",
   "0.16",
   ")",
   "+",
   "0.4275",
   "*",
   "t",
   "*",
   "(",
   "w",
   "**",
   "0.16",
   ")"
  ]
 },
 {
  "idx": "maxmin-896",
  "nl_tokens": [
   "Update",
   "the",
   "HyperLogLog",
   "with",
   "a",
   "new",
   "data",
   "value",
   "in",
   "bytes",
   ".",
   "The",
   "value",
   "will",
   "be",
   "hashed",
   "using",
   "the",
   "hash",
   "function",
   "specified",
   "by",
   "the",
   "hashfunc",
   "argument",
   "in",
   "the",
   "constructor",
   "."
  ],
  "pl_tokens": [
   "def",
   "update",
   "(",
   "self",
   ",",
   "b",
   ")",
   ":",
   "# Digest the hash object to get the hash value",
   "hv",
   "=",
   "self",
   ".",
   "hashfunc",
   "(",
   "b",
   ")",
   "# Get the index of the register using the first p bits of the hash",
   "reg_index",
   "=",
   "hv",
   "&",
   "(",
   "self",
   ".",
   "m",
   "-",
   "1",
   ")",
   "# Get the rest of the hash",
   "bits",
   "=",
   "hv",
   ">>",
   "self",
   ".",
   "p",
   "# Update the register",
   "self",
   ".",
   "reg",
   "[",
   "reg_index",
   "]",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "reg",
   "[",
   "reg_index",
   "]",
   ",",
   "self",
   ".",
   "_get_rank",
   "(",
   "bits",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-897",
  "nl_tokens": [
   "List",
   "events",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "resource",
   "=",
   "None",
   ",",
   "type",
   "=",
   "None",
   ",",
   "actorId",
   "=",
   "None",
   ",",
   "_from",
   "=",
   "None",
   ",",
   "to",
   "=",
   "None",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "resource",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "type",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "actorId",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "_from",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "to",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "resource",
   "=",
   "resource",
   ",",
   "type",
   "=",
   "type",
   ",",
   "actorId",
   "=",
   "actorId",
   ",",
   "_from",
   "=",
   "_from",
   ",",
   "to",
   "=",
   "to",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "if",
   "_from",
   ":",
   "params",
   "[",
   "\"from\"",
   "]",
   "=",
   "params",
   ".",
   "pop",
   "(",
   "\"_from\"",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield event objects created from the returned items JSON objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-898",
  "nl_tokens": [
   "Returns",
   "a",
   "front",
   "ID",
   "which",
   "is",
   "the",
   "id",
   "of",
   "the",
   "offset",
   "front",
   "that",
   "contains",
   "the",
   "most",
   "overlap",
   "with",
   "offsets",
   "that",
   "correspond",
   "to",
   "the",
   "given",
   "onset",
   "front",
   "ID",
   "."
  ],
  "pl_tokens": [
   "def",
   "_choose_front_id_from_candidates",
   "(",
   "candidate_offset_front_ids",
   ",",
   "offset_fronts",
   ",",
   "offsets_corresponding_to_onsets",
   ")",
   ":",
   "noverlaps",
   "=",
   "[",
   "]",
   "# will contain tuples of the form (number_overlapping, offset_front_id)",
   "for",
   "offset_front_id",
   "in",
   "candidate_offset_front_ids",
   ":",
   "offset_front_f_idxs",
   ",",
   "offset_front_s_idxs",
   "=",
   "np",
   ".",
   "where",
   "(",
   "offset_fronts",
   "==",
   "offset_front_id",
   ")",
   "offset_front_idxs",
   "=",
   "[",
   "(",
   "f",
   ",",
   "i",
   ")",
   "for",
   "f",
   ",",
   "i",
   "in",
   "zip",
   "(",
   "offset_front_f_idxs",
   ",",
   "offset_front_s_idxs",
   ")",
   "]",
   "noverlap_this_id",
   "=",
   "len",
   "(",
   "set",
   "(",
   "offset_front_idxs",
   ")",
   ".",
   "symmetric_difference",
   "(",
   "set",
   "(",
   "offsets_corresponding_to_onsets",
   ")",
   ")",
   ")",
   "noverlaps",
   ".",
   "append",
   "(",
   "(",
   "noverlap_this_id",
   ",",
   "offset_front_id",
   ")",
   ")",
   "_overlapped",
   ",",
   "chosen_offset_front_id",
   "=",
   "<mask>",
   "(",
   "noverlaps",
   ",",
   "key",
   "=",
   "lambda",
   "t",
   ":",
   "t",
   "[",
   "0",
   "]",
   ")",
   "return",
   "int",
   "(",
   "chosen_offset_front_id",
   ")"
  ]
 },
 {
  "idx": "maxmin-899",
  "nl_tokens": [
   "List",
   "rooms",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "teamId",
   "=",
   "None",
   ",",
   "type",
   "=",
   "None",
   ",",
   "sortBy",
   "=",
   "None",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "teamId",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "type",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "sortBy",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "teamId",
   "=",
   "teamId",
   ",",
   "type",
   "=",
   "type",
   ",",
   "sortBy",
   "=",
   "sortBy",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield room objects created from the returned items JSON objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-900",
  "nl_tokens": [
   "Construct",
   "a",
   "localized",
   "transition",
   "matrix",
   "."
  ],
  "pl_tokens": [
   "def",
   "transition_local",
   "(",
   "n_states",
   ",",
   "width",
   ",",
   "window",
   "=",
   "'triangle'",
   ",",
   "wrap",
   "=",
   "False",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "n_states",
   ",",
   "int",
   ")",
   "or",
   "n_states",
   "<=",
   "1",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'n_states={} must be a positive integer > 1'",
   ")",
   "width",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "width",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   "if",
   "width",
   ".",
   "ndim",
   "==",
   "0",
   ":",
   "width",
   "=",
   "np",
   ".",
   "tile",
   "(",
   "width",
   ",",
   "n_states",
   ")",
   "if",
   "width",
   ".",
   "shape",
   "!=",
   "(",
   "n_states",
   ",",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'width={} must have length equal to n_states={}'",
   ".",
   "format",
   "(",
   "width",
   ",",
   "n_states",
   ")",
   ")",
   "if",
   "np",
   ".",
   "any",
   "(",
   "width",
   "<",
   "1",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'width={} must be at least 1'",
   ")",
   "transition",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "n_states",
   ",",
   "n_states",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float",
   ")",
   "# Fill in the widths.  This is inefficient, but simple",
   "for",
   "i",
   ",",
   "width_i",
   "in",
   "enumerate",
   "(",
   "width",
   ")",
   ":",
   "trans_row",
   "=",
   "pad_center",
   "(",
   "get_window",
   "(",
   "window",
   ",",
   "width_i",
   ",",
   "fftbins",
   "=",
   "False",
   ")",
   ",",
   "n_states",
   ")",
   "trans_row",
   "=",
   "np",
   ".",
   "roll",
   "(",
   "trans_row",
   ",",
   "n_states",
   "//",
   "2",
   "+",
   "i",
   "+",
   "1",
   ")",
   "if",
   "not",
   "wrap",
   ":",
   "# Knock out the off-diagonal-band elements",
   "trans_row",
   "[",
   "<mask>",
   "(",
   "n_states",
   ",",
   "i",
   "+",
   "width_i",
   "//",
   "2",
   "+",
   "1",
   ")",
   ":",
   "]",
   "=",
   "0",
   "trans_row",
   "[",
   ":",
   "max",
   "(",
   "0",
   ",",
   "i",
   "-",
   "width_i",
   "//",
   "2",
   ")",
   "]",
   "=",
   "0",
   "transition",
   "[",
   "i",
   "]",
   "=",
   "trans_row",
   "# Row-normalize",
   "transition",
   "/=",
   "transition",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ",",
   "keepdims",
   "=",
   "True",
   ")",
   "return",
   "transition"
  ]
 },
 {
  "idx": "maxmin-901",
  "nl_tokens": [
   "Pick",
   "two",
   "at",
   "random",
   "use",
   "the",
   "LRU",
   "of",
   "the",
   "two",
   "."
  ],
  "pl_tokens": [
   "def",
   "twobin",
   "(",
   "loads",
   ")",
   ":",
   "n",
   "=",
   "len",
   "(",
   "loads",
   ")",
   "a",
   "=",
   "randint",
   "(",
   "0",
   ",",
   "n",
   "-",
   "1",
   ")",
   "b",
   "=",
   "randint",
   "(",
   "0",
   ",",
   "n",
   "-",
   "1",
   ")",
   "return",
   "<mask>",
   "(",
   "a",
   ",",
   "b",
   ")"
  ]
 },
 {
  "idx": "maxmin-902",
  "nl_tokens": [
   "Make",
   "the",
   "plot",
   "with",
   "parallax",
   "horizons",
   ".",
   "The",
   "plot",
   "shows",
   "V",
   "-",
   "band",
   "magnitude",
   "vs",
   "distance",
   "for",
   "a",
   "number",
   "of",
   "spectral",
   "types",
   "and",
   "over",
   "the",
   "range",
   "5",
   ".",
   "7<G<20",
   ".",
   "In",
   "addition",
   "a",
   "set",
   "of",
   "crudely",
   "drawn",
   "contours",
   "show",
   "the",
   "points",
   "where",
   "0",
   ".",
   "1",
   "1",
   "and",
   "10",
   "per",
   "cent",
   "relative",
   "parallax",
   "accracy",
   "are",
   "reached",
   "."
  ],
  "pl_tokens": [
   "def",
   "makePlot",
   "(",
   "args",
   ")",
   ":",
   "distances",
   "=",
   "10.0",
   "**",
   "np",
   ".",
   "linspace",
   "(",
   "1",
   ",",
   "6",
   ",",
   "10001",
   ")",
   "spts",
   "=",
   "[",
   "'B0V'",
   ",",
   "'A0V'",
   ",",
   "'F0V'",
   ",",
   "'G0V'",
   ",",
   "'K0V'",
   ",",
   "'K4V'",
   ",",
   "'K1III'",
   "]",
   "twokmsRV",
   "=",
   "[",
   "]",
   "twokmsV",
   "=",
   "[",
   "]",
   "vabsTwokms",
   "=",
   "[",
   "]",
   "fivekmsRV",
   "=",
   "[",
   "]",
   "fivekmsV",
   "=",
   "[",
   "]",
   "vabsFivekms",
   "=",
   "[",
   "]",
   "tenkmsRV",
   "=",
   "[",
   "]",
   "tenkmsV",
   "=",
   "[",
   "]",
   "vabsTenkms",
   "=",
   "[",
   "]",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "11",
   ",",
   "7.8",
   ")",
   ")",
   "deltaHue",
   "=",
   "240.0",
   "/",
   "(",
   "len",
   "(",
   "spts",
   ")",
   "-",
   "1",
   ")",
   "hues",
   "=",
   "(",
   "240.0",
   "-",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "spts",
   ")",
   ")",
   "*",
   "deltaHue",
   ")",
   "/",
   "360.0",
   "hsv",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "1",
   ",",
   "1",
   ",",
   "3",
   ")",
   ")",
   "hsv",
   "[",
   "0",
   ",",
   "0",
   ",",
   "1",
   "]",
   "=",
   "1.0",
   "hsv",
   "[",
   "0",
   ",",
   "0",
   ",",
   "2",
   "]",
   "=",
   "0.9",
   "for",
   "hue",
   ",",
   "spt",
   "in",
   "zip",
   "(",
   "hues",
   ",",
   "spts",
   ")",
   ":",
   "hsv",
   "[",
   "0",
   ",",
   "0",
   ",",
   "0",
   "]",
   "=",
   "hue",
   "vmags",
   "=",
   "vabsFromSpt",
   "(",
   "spt",
   ")",
   "+",
   "5.0",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "distances",
   ")",
   "-",
   "5.0",
   "vmini",
   "=",
   "vminiFromSpt",
   "(",
   "spt",
   ")",
   "grvsmags",
   "=",
   "vmags",
   "-",
   "vminGrvsFromVmini",
   "(",
   "vmini",
   ")",
   "rvError",
   "=",
   "vradErrorSkyAvg",
   "(",
   "vmags",
   ",",
   "spt",
   ")",
   "observed",
   "=",
   "(",
   "grvsmags",
   ">=",
   "5.7",
   ")",
   "&",
   "(",
   "grvsmags",
   "<=",
   "16.1",
   ")",
   "rvError",
   "=",
   "rvError",
   "[",
   "observed",
   "]",
   "# Identify the points where the relative parallax accuracy is 0.1, 1, or 10 per cent.",
   "if",
   "(",
   "rvError",
   ".",
   "<mask>",
   "(",
   ")",
   "<=",
   "2.0",
   ")",
   ":",
   "index",
   "=",
   "len",
   "(",
   "rvError",
   "[",
   "rvError",
   "<=",
   "2.0",
   "]",
   ")",
   "-",
   "1",
   "twokmsRV",
   ".",
   "append",
   "(",
   "distances",
   "[",
   "observed",
   "]",
   "[",
   "index",
   "]",
   ")",
   "twokmsV",
   ".",
   "append",
   "(",
   "vmags",
   "[",
   "observed",
   "]",
   "[",
   "index",
   "]",
   ")",
   "vabsTwokms",
   ".",
   "append",
   "(",
   "vabsFromSpt",
   "(",
   "spt",
   ")",
   ")",
   "if",
   "(",
   "rvError",
   ".",
   "min",
   "(",
   ")",
   "<=",
   "5.0",
   ")",
   ":",
   "index",
   "=",
   "len",
   "(",
   "rvError",
   "[",
   "rvError",
   "<=",
   "5.0",
   "]",
   ")",
   "-",
   "1",
   "fivekmsRV",
   ".",
   "append",
   "(",
   "distances",
   "[",
   "observed",
   "]",
   "[",
   "index",
   "]",
   ")",
   "fivekmsV",
   ".",
   "append",
   "(",
   "vmags",
   "[",
   "observed",
   "]",
   "[",
   "index",
   "]",
   ")",
   "vabsFivekms",
   ".",
   "append",
   "(",
   "vabsFromSpt",
   "(",
   "spt",
   ")",
   ")",
   "if",
   "(",
   "rvError",
   ".",
   "min",
   "(",
   ")",
   "<=",
   "10.0",
   ")",
   ":",
   "index",
   "=",
   "len",
   "(",
   "rvError",
   "[",
   "rvError",
   "<=",
   "10.0",
   "]",
   ")",
   "-",
   "1",
   "tenkmsRV",
   ".",
   "append",
   "(",
   "distances",
   "[",
   "observed",
   "]",
   "[",
   "index",
   "]",
   ")",
   "tenkmsV",
   ".",
   "append",
   "(",
   "vmags",
   "[",
   "observed",
   "]",
   "[",
   "index",
   "]",
   ")",
   "vabsTenkms",
   ".",
   "append",
   "(",
   "vabsFromSpt",
   "(",
   "spt",
   ")",
   ")",
   "plt",
   ".",
   "semilogx",
   "(",
   "distances",
   "[",
   "observed",
   "]",
   ",",
   "vmags",
   "[",
   "observed",
   "]",
   ",",
   "'-'",
   ",",
   "label",
   "=",
   "spt",
   ",",
   "color",
   "=",
   "hsv_to_rgb",
   "(",
   "hsv",
   ")",
   "[",
   "0",
   ",",
   "0",
   ",",
   ":",
   "]",
   ")",
   "plt",
   ".",
   "text",
   "(",
   "distances",
   "[",
   "observed",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   "vmags",
   "[",
   "observed",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   "spt",
   ",",
   "horizontalalignment",
   "=",
   "'center'",
   ",",
   "verticalalignment",
   "=",
   "'bottom'",
   ",",
   "fontsize",
   "=",
   "14",
   ")",
   "# Draw the \"contours\" of constant radial velocity accuracy.",
   "twokmsRV",
   "=",
   "np",
   ".",
   "array",
   "(",
   "twokmsRV",
   ")",
   "twokmsV",
   "=",
   "np",
   ".",
   "array",
   "(",
   "twokmsV",
   ")",
   "indices",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "vabsTwokms",
   ")",
   "plt",
   ".",
   "semilogx",
   "(",
   "twokmsRV",
   "[",
   "indices",
   "]",
   ",",
   "twokmsV",
   "[",
   "indices",
   "]",
   ",",
   "'k--'",
   ")",
   "plt",
   ".",
   "text",
   "(",
   "twokmsRV",
   "[",
   "indices",
   "]",
   "[",
   "-",
   "1",
   "]",
   "*",
   "0.8",
   ",",
   "twokmsV",
   "[",
   "indices",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   "\"$2$ km s$^{-1}$\"",
   ",",
   "ha",
   "=",
   "'right'",
   ",",
   "size",
   "=",
   "16",
   ",",
   "bbox",
   "=",
   "dict",
   "(",
   "boxstyle",
   "=",
   "\"round, pad=0.3\"",
   ",",
   "ec",
   "=",
   "(",
   "0.0",
   ",",
   "0.0",
   ",",
   "0.0",
   ")",
   ",",
   "fc",
   "=",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ")",
   ",",
   ")",
   ")",
   "fivekmsRV",
   "=",
   "np",
   ".",
   "array",
   "(",
   "fivekmsRV",
   ")",
   "fivekmsV",
   "=",
   "np",
   ".",
   "array",
   "(",
   "fivekmsV",
   ")",
   "indices",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "vabsFivekms",
   ")",
   "plt",
   ".",
   "semilogx",
   "(",
   "fivekmsRV",
   "[",
   "indices",
   "]",
   ",",
   "fivekmsV",
   "[",
   "indices",
   "]",
   ",",
   "'k--'",
   ")",
   "plt",
   ".",
   "text",
   "(",
   "fivekmsRV",
   "[",
   "indices",
   "]",
   "[",
   "-",
   "1",
   "]",
   "*",
   "0.8",
   ",",
   "fivekmsV",
   "[",
   "indices",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   "\"$5$ km s$^{-1}$\"",
   ",",
   "ha",
   "=",
   "'right'",
   ",",
   "size",
   "=",
   "16",
   ",",
   "bbox",
   "=",
   "dict",
   "(",
   "boxstyle",
   "=",
   "\"round, pad=0.3\"",
   ",",
   "ec",
   "=",
   "(",
   "0.0",
   ",",
   "0.0",
   ",",
   "0.0",
   ")",
   ",",
   "fc",
   "=",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ")",
   ",",
   ")",
   ")",
   "tenkmsRV",
   "=",
   "np",
   ".",
   "array",
   "(",
   "tenkmsRV",
   ")",
   "tenkmsV",
   "=",
   "np",
   ".",
   "array",
   "(",
   "tenkmsV",
   ")",
   "indices",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "vabsTenkms",
   ")",
   "plt",
   ".",
   "semilogx",
   "(",
   "tenkmsRV",
   "[",
   "indices",
   "]",
   ",",
   "tenkmsV",
   "[",
   "indices",
   "]",
   ",",
   "'k--'",
   ")",
   "plt",
   ".",
   "text",
   "(",
   "tenkmsRV",
   "[",
   "indices",
   "]",
   "[",
   "-",
   "1",
   "]",
   "*",
   "0.8",
   ",",
   "tenkmsV",
   "[",
   "indices",
   "]",
   "[",
   "-",
   "1",
   "]",
   "+",
   "0.5",
   ",",
   "\"$10$ km s$^{-1}$\"",
   ",",
   "ha",
   "=",
   "'right'",
   ",",
   "size",
   "=",
   "16",
   ",",
   "bbox",
   "=",
   "dict",
   "(",
   "boxstyle",
   "=",
   "\"round, pad=0.3\"",
   ",",
   "ec",
   "=",
   "(",
   "0.0",
   ",",
   "0.0",
   ",",
   "0.0",
   ")",
   ",",
   "fc",
   "=",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ")",
   ",",
   ")",
   ")",
   "plt",
   ".",
   "title",
   "(",
   "'Radial velocity accuracy horizons ($A_V=0$)'",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "'Distance [pc]'",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "'V'",
   ")",
   "plt",
   ".",
   "grid",
   "(",
   ")",
   "#leg=plt.legend(loc=4, fontsize=14, labelspacing=0.5)",
   "plt",
   ".",
   "ylim",
   "(",
   "5",
   ",",
   "20",
   ")",
   "basename",
   "=",
   "'RadialVelocityHorizons'",
   "if",
   "(",
   "args",
   "[",
   "'pdfOutput'",
   "]",
   ")",
   ":",
   "plt",
   ".",
   "savefig",
   "(",
   "basename",
   "+",
   "'.pdf'",
   ")",
   "elif",
   "(",
   "args",
   "[",
   "'pngOutput'",
   "]",
   ")",
   ":",
   "plt",
   ".",
   "savefig",
   "(",
   "basename",
   "+",
   "'.png'",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "show",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-903",
  "nl_tokens": [
   "Creates",
   "a",
   "layer",
   "with",
   "InputWire",
   "elements",
   ".",
   "Args",
   ":",
   "names",
   "(",
   "list",
   ")",
   ":",
   "List",
   "of",
   "names",
   "for",
   "the",
   "wires",
   "."
  ],
  "pl_tokens": [
   "def",
   "fillup_layer",
   "(",
   "names",
   ")",
   ":",
   "# pylint: disable=arguments-differ",
   "longest",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "name",
   ")",
   "for",
   "name",
   "in",
   "names",
   "]",
   ")",
   "inputs_wires",
   "=",
   "[",
   "]",
   "for",
   "name",
   "in",
   "names",
   ":",
   "inputs_wires",
   ".",
   "append",
   "(",
   "InputWire",
   "(",
   "name",
   ".",
   "rjust",
   "(",
   "longest",
   ")",
   ")",
   ")",
   "return",
   "inputs_wires"
  ]
 },
 {
  "idx": "maxmin-904",
  "nl_tokens": [
   "Uses",
   "a",
   "flexible",
   "heuristic",
   "to",
   "pick",
   "peaks",
   "in",
   "a",
   "signal",
   "."
  ],
  "pl_tokens": [
   "def",
   "peak_pick",
   "(",
   "x",
   ",",
   "pre_max",
   ",",
   "post_max",
   ",",
   "pre_avg",
   ",",
   "post_avg",
   ",",
   "delta",
   ",",
   "wait",
   ")",
   ":",
   "if",
   "pre_max",
   "<",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'pre_max must be non-negative'",
   ")",
   "if",
   "pre_avg",
   "<",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'pre_avg must be non-negative'",
   ")",
   "if",
   "delta",
   "<",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'delta must be non-negative'",
   ")",
   "if",
   "wait",
   "<",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'wait must be non-negative'",
   ")",
   "if",
   "post_max",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'post_max must be positive'",
   ")",
   "if",
   "post_avg",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'post_avg must be positive'",
   ")",
   "if",
   "x",
   ".",
   "ndim",
   "!=",
   "1",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'input array must be one-dimensional'",
   ")",
   "# Ensure valid index types",
   "pre_max",
   "=",
   "valid_int",
   "(",
   "pre_max",
   ",",
   "cast",
   "=",
   "np",
   ".",
   "ceil",
   ")",
   "post_max",
   "=",
   "valid_int",
   "(",
   "post_max",
   ",",
   "cast",
   "=",
   "np",
   ".",
   "ceil",
   ")",
   "pre_avg",
   "=",
   "valid_int",
   "(",
   "pre_avg",
   ",",
   "cast",
   "=",
   "np",
   ".",
   "ceil",
   ")",
   "post_avg",
   "=",
   "valid_int",
   "(",
   "post_avg",
   ",",
   "cast",
   "=",
   "np",
   ".",
   "ceil",
   ")",
   "wait",
   "=",
   "valid_int",
   "(",
   "wait",
   ",",
   "cast",
   "=",
   "np",
   ".",
   "ceil",
   ")",
   "# Get the maximum of the signal over a sliding window",
   "max_length",
   "=",
   "pre_max",
   "+",
   "post_max",
   "max_origin",
   "=",
   "np",
   ".",
   "ceil",
   "(",
   "0.5",
   "*",
   "(",
   "pre_max",
   "-",
   "post_max",
   ")",
   ")",
   "# Using mode='constant' and cval=x.min() effectively truncates",
   "# the sliding window at the boundaries",
   "mov_max",
   "=",
   "scipy",
   ".",
   "ndimage",
   ".",
   "filters",
   ".",
   "maximum_filter1d",
   "(",
   "x",
   ",",
   "int",
   "(",
   "max_length",
   ")",
   ",",
   "mode",
   "=",
   "'constant'",
   ",",
   "origin",
   "=",
   "int",
   "(",
   "max_origin",
   ")",
   ",",
   "cval",
   "=",
   "x",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "# Get the mean of the signal over a sliding window",
   "avg_length",
   "=",
   "pre_avg",
   "+",
   "post_avg",
   "avg_origin",
   "=",
   "np",
   ".",
   "ceil",
   "(",
   "0.5",
   "*",
   "(",
   "pre_avg",
   "-",
   "post_avg",
   ")",
   ")",
   "# Here, there is no mode which results in the behavior we want,",
   "# so we'll correct below.",
   "mov_avg",
   "=",
   "scipy",
   ".",
   "ndimage",
   ".",
   "filters",
   ".",
   "uniform_filter1d",
   "(",
   "x",
   ",",
   "int",
   "(",
   "avg_length",
   ")",
   ",",
   "mode",
   "=",
   "'nearest'",
   ",",
   "origin",
   "=",
   "int",
   "(",
   "avg_origin",
   ")",
   ")",
   "# Correct sliding average at the beginning",
   "n",
   "=",
   "0",
   "# Only need to correct in the range where the window needs to be truncated",
   "while",
   "n",
   "-",
   "pre_avg",
   "<",
   "0",
   "and",
   "n",
   "<",
   "x",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   "# This just explicitly does mean(x[n - pre_avg:n + post_avg])",
   "# with truncation",
   "start",
   "=",
   "n",
   "-",
   "pre_avg",
   "start",
   "=",
   "start",
   "if",
   "start",
   ">",
   "0",
   "else",
   "0",
   "mov_avg",
   "[",
   "n",
   "]",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "x",
   "[",
   "start",
   ":",
   "n",
   "+",
   "post_avg",
   "]",
   ")",
   "n",
   "+=",
   "1",
   "# Correct sliding average at the end",
   "n",
   "=",
   "x",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "post_avg",
   "# When post_avg > x.shape[0] (weird case), reset to 0",
   "n",
   "=",
   "n",
   "if",
   "n",
   ">",
   "0",
   "else",
   "0",
   "while",
   "n",
   "<",
   "x",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   "start",
   "=",
   "n",
   "-",
   "pre_avg",
   "start",
   "=",
   "start",
   "if",
   "start",
   ">",
   "0",
   "else",
   "0",
   "mov_avg",
   "[",
   "n",
   "]",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "x",
   "[",
   "start",
   ":",
   "n",
   "+",
   "post_avg",
   "]",
   ")",
   "n",
   "+=",
   "1",
   "# First mask out all entries not equal to the local max",
   "detections",
   "=",
   "x",
   "*",
   "(",
   "x",
   "==",
   "mov_max",
   ")",
   "# Then mask out all entries less than the thresholded average",
   "detections",
   "=",
   "detections",
   "*",
   "(",
   "detections",
   ">=",
   "(",
   "mov_avg",
   "+",
   "delta",
   ")",
   ")",
   "# Initialize peaks array, to be filled greedily",
   "peaks",
   "=",
   "[",
   "]",
   "# Remove onsets which are close together in time",
   "last_onset",
   "=",
   "-",
   "np",
   ".",
   "inf",
   "for",
   "i",
   "in",
   "np",
   ".",
   "nonzero",
   "(",
   "detections",
   ")",
   "[",
   "0",
   "]",
   ":",
   "# Only report an onset if the \"wait\" samples was reported",
   "if",
   "i",
   ">",
   "last_onset",
   "+",
   "wait",
   ":",
   "peaks",
   ".",
   "append",
   "(",
   "i",
   ")",
   "# Save last reported onset",
   "last_onset",
   "=",
   "i",
   "return",
   "np",
   ".",
   "array",
   "(",
   "peaks",
   ")"
  ]
 },
 {
  "idx": "maxmin-905",
  "nl_tokens": [
   "Check",
   "that",
   "wiremap",
   "neither",
   "fragments",
   "nor",
   "leaves",
   "duplicate",
   "registers",
   "."
  ],
  "pl_tokens": [
   "def",
   "_check_edgemap_registers",
   "(",
   "self",
   ",",
   "edge_map",
   ",",
   "keyregs",
   ",",
   "valregs",
   ",",
   "valreg",
   "=",
   "True",
   ")",
   ":",
   "# FIXME: some mixing of objects and strings here are awkward (due to",
   "# self.qregs/self.cregs still keying on string.",
   "add_regs",
   "=",
   "set",
   "(",
   ")",
   "reg_frag_chk",
   "=",
   "{",
   "}",
   "for",
   "v",
   "in",
   "keyregs",
   ".",
   "values",
   "(",
   ")",
   ":",
   "reg_frag_chk",
   "[",
   "v",
   "]",
   "=",
   "{",
   "j",
   ":",
   "False",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "v",
   ")",
   ")",
   "}",
   "for",
   "k",
   "in",
   "edge_map",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "if",
   "k",
   "[",
   "0",
   "]",
   ".",
   "name",
   "in",
   "keyregs",
   ":",
   "reg_frag_chk",
   "[",
   "k",
   "[",
   "0",
   "]",
   "]",
   "[",
   "k",
   "[",
   "1",
   "]",
   "]",
   "=",
   "True",
   "for",
   "k",
   ",",
   "v",
   "in",
   "reg_frag_chk",
   ".",
   "items",
   "(",
   ")",
   ":",
   "s",
   "=",
   "set",
   "(",
   "v",
   ".",
   "values",
   "(",
   ")",
   ")",
   "if",
   "len",
   "(",
   "s",
   ")",
   "==",
   "2",
   ":",
   "raise",
   "DAGCircuitError",
   "(",
   "\"edge_map fragments reg %s\"",
   "%",
   "k",
   ")",
   "elif",
   "s",
   "==",
   "set",
   "(",
   "[",
   "False",
   "]",
   ")",
   ":",
   "if",
   "k",
   "in",
   "self",
   ".",
   "qregs",
   ".",
   "values",
   "(",
   ")",
   "or",
   "k",
   "in",
   "self",
   ".",
   "cregs",
   ".",
   "values",
   "(",
   ")",
   ":",
   "raise",
   "DAGCircuitError",
   "(",
   "\"unmapped duplicate reg %s\"",
   "%",
   "k",
   ")",
   "else",
   ":",
   "# Add registers that appear only in keyregs",
   "add_regs",
   ".",
   "add",
   "(",
   "k",
   ")",
   "else",
   ":",
   "if",
   "valreg",
   ":",
   "# If mapping to a register not in valregs, add it.",
   "# (k,0) exists in edge_map because edge_map doesn't",
   "# fragment k",
   "if",
   "not",
   "edge_map",
   "[",
   "(",
   "k",
   ",",
   "0",
   ")",
   "]",
   "[",
   "0",
   "]",
   ".",
   "name",
   "in",
   "valregs",
   ":",
   "size",
   "=",
   "<mask>",
   "(",
   "map",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "1",
   "]",
   ",",
   "filter",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   "==",
   "edge_map",
   "[",
   "(",
   "k",
   ",",
   "0",
   ")",
   "]",
   "[",
   "0",
   "]",
   ",",
   "edge_map",
   ".",
   "values",
   "(",
   ")",
   ")",
   ")",
   ")",
   "qreg",
   "=",
   "QuantumRegister",
   "(",
   "size",
   "+",
   "1",
   ",",
   "edge_map",
   "[",
   "(",
   "k",
   ",",
   "0",
   ")",
   "]",
   "[",
   "0",
   "]",
   ".",
   "name",
   ")",
   "add_regs",
   ".",
   "add",
   "(",
   "qreg",
   ")",
   "return",
   "add_regs"
  ]
 },
 {
  "idx": "maxmin-906",
  "nl_tokens": [
   "return",
   "the",
   "time",
   "tree",
   "estimation",
   "of",
   "evolutionary",
   "rates",
   "+",
   "/",
   "-",
   "one",
   "standard",
   "deviation",
   "form",
   "the",
   "ML",
   "estimate",
   "."
  ],
  "pl_tokens": [
   "def",
   "calc_rate_susceptibility",
   "(",
   "self",
   ",",
   "rate_std",
   "=",
   "None",
   ",",
   "params",
   "=",
   "None",
   ")",
   ":",
   "params",
   "=",
   "params",
   "or",
   "{",
   "}",
   "if",
   "rate_std",
   "is",
   "None",
   ":",
   "if",
   "not",
   "(",
   "self",
   ".",
   "clock_model",
   "[",
   "'valid_confidence'",
   "]",
   "and",
   "'cov'",
   "in",
   "self",
   ".",
   "clock_model",
   ")",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"ClockTree.calc_rate_susceptibility: need valid standard deviation of the clock rate to estimate dating error.\"",
   ",",
   "1",
   ",",
   "warn",
   "=",
   "True",
   ")",
   "return",
   "ttconf",
   ".",
   "ERROR",
   "rate_std",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "self",
   ".",
   "clock_model",
   "[",
   "'cov'",
   "]",
   "[",
   "0",
   ",",
   "0",
   "]",
   ")",
   "current_rate",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "self",
   ".",
   "clock_model",
   "[",
   "'slope'",
   "]",
   ")",
   "upper_rate",
   "=",
   "self",
   ".",
   "clock_model",
   "[",
   "'slope'",
   "]",
   "+",
   "rate_std",
   "lower_rate",
   "=",
   "<mask>",
   "(",
   "0.1",
   "*",
   "current_rate",
   ",",
   "self",
   ".",
   "clock_model",
   "[",
   "'slope'",
   "]",
   "-",
   "rate_std",
   ")",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "if",
   "n",
   ".",
   "up",
   ":",
   "n",
   ".",
   "_orig_gamma",
   "=",
   "n",
   ".",
   "branch_length_interpolator",
   ".",
   "gamma",
   "n",
   ".",
   "branch_length_interpolator",
   ".",
   "gamma",
   "=",
   "n",
   ".",
   "_orig_gamma",
   "*",
   "upper_rate",
   "/",
   "current_rate",
   "self",
   ".",
   "logger",
   "(",
   "\"###ClockTree.calc_rate_susceptibility: run with upper bound of rate estimate\"",
   ",",
   "1",
   ")",
   "self",
   ".",
   "make_time_tree",
   "(",
   "*",
   "*",
   "params",
   ")",
   "self",
   ".",
   "logger",
   "(",
   "\"###ClockTree.calc_rate_susceptibility: rate: %f, LH:%f\"",
   "%",
   "(",
   "upper_rate",
   ",",
   "self",
   ".",
   "tree",
   ".",
   "positional_joint_LH",
   ")",
   ",",
   "2",
   ")",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "n",
   ".",
   "numdate_rate_variation",
   "=",
   "[",
   "(",
   "upper_rate",
   ",",
   "n",
   ".",
   "numdate",
   ")",
   "]",
   "if",
   "n",
   ".",
   "up",
   ":",
   "n",
   ".",
   "branch_length_interpolator",
   ".",
   "gamma",
   "=",
   "n",
   ".",
   "_orig_gamma",
   "*",
   "lower_rate",
   "/",
   "current_rate",
   "self",
   ".",
   "logger",
   "(",
   "\"###ClockTree.calc_rate_susceptibility: run with lower bound of rate estimate\"",
   ",",
   "1",
   ")",
   "self",
   ".",
   "make_time_tree",
   "(",
   "*",
   "*",
   "params",
   ")",
   "self",
   ".",
   "logger",
   "(",
   "\"###ClockTree.calc_rate_susceptibility: rate: %f, LH:%f\"",
   "%",
   "(",
   "lower_rate",
   ",",
   "self",
   ".",
   "tree",
   ".",
   "positional_joint_LH",
   ")",
   ",",
   "2",
   ")",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "n",
   ".",
   "numdate_rate_variation",
   ".",
   "append",
   "(",
   "(",
   "lower_rate",
   ",",
   "n",
   ".",
   "numdate",
   ")",
   ")",
   "if",
   "n",
   ".",
   "up",
   ":",
   "n",
   ".",
   "branch_length_interpolator",
   ".",
   "gamma",
   "=",
   "n",
   ".",
   "_orig_gamma",
   "self",
   ".",
   "logger",
   "(",
   "\"###ClockTree.calc_rate_susceptibility: run with central rate estimate\"",
   ",",
   "1",
   ")",
   "self",
   ".",
   "make_time_tree",
   "(",
   "*",
   "*",
   "params",
   ")",
   "self",
   ".",
   "logger",
   "(",
   "\"###ClockTree.calc_rate_susceptibility: rate: %f, LH:%f\"",
   "%",
   "(",
   "current_rate",
   ",",
   "self",
   ".",
   "tree",
   ".",
   "positional_joint_LH",
   ")",
   ",",
   "2",
   ")",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "n",
   ".",
   "numdate_rate_variation",
   ".",
   "append",
   "(",
   "(",
   "current_rate",
   ",",
   "n",
   ".",
   "numdate",
   ")",
   ")",
   "n",
   ".",
   "numdate_rate_variation",
   ".",
   "sort",
   "(",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "1",
   "]",
   ")",
   "# sort estimates for different rates by numdate",
   "return",
   "ttconf",
   ".",
   "SUCCESS"
  ]
 },
 {
  "idx": "maxmin-907",
  "nl_tokens": [
   "Add",
   "keyword",
   "arguments",
   "to",
   "kwargs",
   "(",
   "in",
   "-",
   "place",
   ")",
   "based",
   "on",
   "the",
   "passed",
   "in",
   "Column",
   "<sqlalchemy",
   ".",
   "schema",
   ".",
   "Column",
   ">",
   "."
  ],
  "pl_tokens": [
   "def",
   "_add_column_kwargs",
   "(",
   "self",
   ",",
   "kwargs",
   ",",
   "column",
   ")",
   ":",
   "if",
   "column",
   ".",
   "nullable",
   ":",
   "kwargs",
   "[",
   "\"allow_none\"",
   "]",
   "=",
   "True",
   "kwargs",
   "[",
   "\"required\"",
   "]",
   "=",
   "not",
   "column",
   ".",
   "nullable",
   "and",
   "not",
   "_has_default",
   "(",
   "column",
   ")",
   "if",
   "hasattr",
   "(",
   "column",
   ".",
   "type",
   ",",
   "\"enums\"",
   ")",
   ":",
   "kwargs",
   "[",
   "\"validate\"",
   "]",
   ".",
   "append",
   "(",
   "validate",
   ".",
   "OneOf",
   "(",
   "choices",
   "=",
   "column",
   ".",
   "type",
   ".",
   "enums",
   ")",
   ")",
   "# Add a length validator if a max length is set on the column",
   "# Skip UUID columns",
   "# (see https://github.com/marshmallow-code/marshmallow-sqlalchemy/issues/54)",
   "if",
   "hasattr",
   "(",
   "column",
   ".",
   "type",
   ",",
   "\"length\"",
   ")",
   ":",
   "try",
   ":",
   "python_type",
   "=",
   "column",
   ".",
   "type",
   ".",
   "python_type",
   "except",
   "(",
   "AttributeError",
   ",",
   "NotImplementedError",
   ")",
   ":",
   "python_type",
   "=",
   "None",
   "if",
   "not",
   "python_type",
   "or",
   "not",
   "issubclass",
   "(",
   "python_type",
   ",",
   "uuid",
   ".",
   "UUID",
   ")",
   ":",
   "kwargs",
   "[",
   "\"validate\"",
   "]",
   ".",
   "append",
   "(",
   "validate",
   ".",
   "Length",
   "(",
   "<mask>",
   "=",
   "column",
   ".",
   "type",
   ".",
   "length",
   ")",
   ")",
   "if",
   "hasattr",
   "(",
   "column",
   ".",
   "type",
   ",",
   "\"scale\"",
   ")",
   ":",
   "kwargs",
   "[",
   "\"places\"",
   "]",
   "=",
   "getattr",
   "(",
   "column",
   ".",
   "type",
   ",",
   "\"scale\"",
   ",",
   "None",
   ")"
  ]
 },
 {
  "idx": "maxmin-908",
  "nl_tokens": [
   "Run",
   "it",
   "return",
   "whether",
   "to",
   "end",
   "training",
   "."
  ],
  "pl_tokens": [
   "def",
   "invoke",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "_iter",
   "+=",
   "1",
   "if",
   "self",
   ".",
   "_iter",
   "-",
   "<mask>",
   "(",
   "self",
   ".",
   "_trainer",
   ".",
   "best_iter",
   ",",
   "self",
   ".",
   "_annealed_iter",
   ")",
   ">=",
   "self",
   ".",
   "_patience",
   ":",
   "if",
   "self",
   ".",
   "_annealed_times",
   ">=",
   "self",
   ".",
   "_anneal_times",
   ":",
   "logging",
   ".",
   "info",
   "(",
   "\"ending\"",
   ")",
   "self",
   ".",
   "_trainer",
   ".",
   "exit",
   "(",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_trainer",
   ".",
   "set_params",
   "(",
   "*",
   "self",
   ".",
   "_trainer",
   ".",
   "best_params",
   ")",
   "self",
   ".",
   "_learning_rate",
   ".",
   "set_value",
   "(",
   "self",
   ".",
   "_learning_rate",
   ".",
   "get_value",
   "(",
   ")",
   "*",
   "0.5",
   ")",
   "self",
   ".",
   "_annealed_times",
   "+=",
   "1",
   "self",
   ".",
   "_annealed_iter",
   "=",
   "self",
   ".",
   "_iter",
   "logging",
   ".",
   "info",
   "(",
   "\"annealed learning rate to %f\"",
   "%",
   "self",
   ".",
   "_learning_rate",
   ".",
   "get_value",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-909",
  "nl_tokens": [
   "Display",
   "a",
   "spectrogram",
   "/",
   "chromagram",
   "/",
   "cqt",
   "/",
   "etc",
   "."
  ],
  "pl_tokens": [
   "def",
   "specshow",
   "(",
   "data",
   ",",
   "x_coords",
   "=",
   "None",
   ",",
   "y_coords",
   "=",
   "None",
   ",",
   "x_axis",
   "=",
   "None",
   ",",
   "y_axis",
   "=",
   "None",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "fmin",
   "=",
   "None",
   ",",
   "fmax",
   "=",
   "None",
   ",",
   "bins_per_octave",
   "=",
   "12",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "np",
   ".",
   "issubdtype",
   "(",
   "data",
   ".",
   "dtype",
   ",",
   "np",
   ".",
   "complexfloating",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "'Trying to display complex-valued input. '",
   "'Showing magnitude instead.'",
   ")",
   "data",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "data",
   ")",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'cmap'",
   ",",
   "cmap",
   "(",
   "data",
   ")",
   ")",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'rasterized'",
   ",",
   "True",
   ")",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'edgecolors'",
   ",",
   "'None'",
   ")",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'shading'",
   ",",
   "'flat'",
   ")",
   "all_params",
   "=",
   "dict",
   "(",
   "kwargs",
   "=",
   "kwargs",
   ",",
   "sr",
   "=",
   "sr",
   ",",
   "fmin",
   "=",
   "fmin",
   ",",
   "fmax",
   "=",
   "fmax",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "# Get the x and y coordinates",
   "y_coords",
   "=",
   "__mesh_coords",
   "(",
   "y_axis",
   ",",
   "y_coords",
   ",",
   "data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "*",
   "*",
   "all_params",
   ")",
   "x_coords",
   "=",
   "__mesh_coords",
   "(",
   "x_axis",
   ",",
   "x_coords",
   ",",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "*",
   "*",
   "all_params",
   ")",
   "axes",
   "=",
   "__check_axes",
   "(",
   "ax",
   ")",
   "out",
   "=",
   "axes",
   ".",
   "pcolormesh",
   "(",
   "x_coords",
   ",",
   "y_coords",
   ",",
   "data",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "__set_current_image",
   "(",
   "ax",
   ",",
   "out",
   ")",
   "axes",
   ".",
   "set_xlim",
   "(",
   "x_coords",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "x_coords",
   ".",
   "max",
   "(",
   ")",
   ")",
   "axes",
   ".",
   "set_ylim",
   "(",
   "y_coords",
   ".",
   "min",
   "(",
   ")",
   ",",
   "y_coords",
   ".",
   "max",
   "(",
   ")",
   ")",
   "# Set up axis scaling",
   "__scale_axes",
   "(",
   "axes",
   ",",
   "x_axis",
   ",",
   "'x'",
   ")",
   "__scale_axes",
   "(",
   "axes",
   ",",
   "y_axis",
   ",",
   "'y'",
   ")",
   "# Construct tickers and locators",
   "__decorate_axis",
   "(",
   "axes",
   ".",
   "xaxis",
   ",",
   "x_axis",
   ")",
   "__decorate_axis",
   "(",
   "axes",
   ".",
   "yaxis",
   ",",
   "y_axis",
   ")",
   "return",
   "axes"
  ]
 },
 {
  "idx": "maxmin-910",
  "nl_tokens": [
   "Pre",
   "-",
   "process",
   "list",
   "of",
   "variants",
   "."
  ],
  "pl_tokens": [
   "def",
   "variants",
   "(",
   "store",
   ",",
   "institute_obj",
   ",",
   "case_obj",
   ",",
   "variants_query",
   ",",
   "page",
   "=",
   "1",
   ",",
   "per_page",
   "=",
   "50",
   ")",
   ":",
   "variant_count",
   "=",
   "variants_query",
   ".",
   "count",
   "(",
   ")",
   "skip_count",
   "=",
   "per_page",
   "*",
   "<mask>",
   "(",
   "page",
   "-",
   "1",
   ",",
   "0",
   ")",
   "more_variants",
   "=",
   "True",
   "if",
   "variant_count",
   ">",
   "(",
   "skip_count",
   "+",
   "per_page",
   ")",
   "else",
   "False",
   "variant_res",
   "=",
   "variants_query",
   ".",
   "skip",
   "(",
   "skip_count",
   ")",
   ".",
   "limit",
   "(",
   "per_page",
   ")",
   "genome_build",
   "=",
   "case_obj",
   ".",
   "get",
   "(",
   "'genome_build'",
   ",",
   "'37'",
   ")",
   "if",
   "genome_build",
   "not",
   "in",
   "[",
   "'37'",
   ",",
   "'38'",
   "]",
   ":",
   "genome_build",
   "=",
   "'37'",
   "variants",
   "=",
   "[",
   "]",
   "for",
   "variant_obj",
   "in",
   "variant_res",
   ":",
   "overlapping_svs",
   "=",
   "[",
   "sv",
   "for",
   "sv",
   "in",
   "store",
   ".",
   "overlapping",
   "(",
   "variant_obj",
   ")",
   "]",
   "variant_obj",
   "[",
   "'overlapping'",
   "]",
   "=",
   "overlapping_svs",
   "or",
   "None",
   "variants",
   ".",
   "append",
   "(",
   "parse_variant",
   "(",
   "store",
   ",",
   "institute_obj",
   ",",
   "case_obj",
   ",",
   "variant_obj",
   ",",
   "update",
   "=",
   "True",
   ",",
   "genome_build",
   "=",
   "genome_build",
   ")",
   ")",
   "return",
   "{",
   "'variants'",
   ":",
   "variants",
   ",",
   "'more_variants'",
   ":",
   "more_variants",
   ",",
   "}"
  ]
 },
 {
  "idx": "maxmin-911",
  "nl_tokens": [
   "Cuts",
   "the",
   "AudioSegment",
   "into",
   "seconds",
   "segments",
   "(",
   "at",
   "most",
   ")",
   ".",
   "So",
   "for",
   "example",
   "if",
   "seconds",
   "=",
   "10",
   "this",
   "will",
   "return",
   "a",
   "list",
   "of",
   "AudioSegments",
   "in",
   "order",
   "where",
   "each",
   "one",
   "is",
   "at",
   "most",
   "10",
   "seconds",
   "long",
   ".",
   "If",
   "zero_pad",
   "is",
   "True",
   "the",
   "last",
   "item",
   "AudioSegment",
   "object",
   "will",
   "be",
   "zero",
   "padded",
   "to",
   "result",
   "in",
   "seconds",
   "seconds",
   "."
  ],
  "pl_tokens": [
   "def",
   "dice",
   "(",
   "self",
   ",",
   "seconds",
   ",",
   "zero_pad",
   "=",
   "False",
   ")",
   ":",
   "try",
   ":",
   "total_s",
   "=",
   "sum",
   "(",
   "seconds",
   ")",
   "if",
   "not",
   "(",
   "self",
   ".",
   "duration_seconds",
   "<=",
   "total_s",
   "+",
   "1",
   "and",
   "self",
   ".",
   "duration_seconds",
   ">=",
   "total_s",
   "-",
   "1",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"`seconds` does not sum to within one second of the duration of this AudioSegment.\\\n                                 given total seconds: %s and self.duration_seconds: %s\"",
   "%",
   "(",
   "total_s",
   ",",
   "self",
   ".",
   "duration_seconds",
   ")",
   ")",
   "starts",
   "=",
   "[",
   "]",
   "stops",
   "=",
   "[",
   "]",
   "time_ms",
   "=",
   "0",
   "for",
   "dur",
   "in",
   "seconds",
   ":",
   "starts",
   ".",
   "append",
   "(",
   "time_ms",
   ")",
   "time_ms",
   "+=",
   "dur",
   "*",
   "MS_PER_S",
   "stops",
   ".",
   "append",
   "(",
   "time_ms",
   ")",
   "zero_pad",
   "=",
   "False",
   "except",
   "TypeError",
   ":",
   "# `seconds` is not a list",
   "starts",
   "=",
   "range",
   "(",
   "0",
   ",",
   "int",
   "(",
   "round",
   "(",
   "self",
   ".",
   "duration_seconds",
   "*",
   "MS_PER_S",
   ")",
   ")",
   ",",
   "int",
   "(",
   "round",
   "(",
   "seconds",
   "*",
   "MS_PER_S",
   ")",
   ")",
   ")",
   "stops",
   "=",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "duration_seconds",
   "*",
   "MS_PER_S",
   ",",
   "start",
   "+",
   "seconds",
   "*",
   "MS_PER_S",
   ")",
   "for",
   "start",
   "in",
   "starts",
   ")",
   "outs",
   "=",
   "[",
   "self",
   "[",
   "start",
   ":",
   "stop",
   "]",
   "for",
   "start",
   ",",
   "stop",
   "in",
   "zip",
   "(",
   "starts",
   ",",
   "stops",
   ")",
   "]",
   "out_lens",
   "=",
   "[",
   "out",
   ".",
   "duration_seconds",
   "for",
   "out",
   "in",
   "outs",
   "]",
   "# Check if our last slice is within one ms of expected - if so, we don't need to zero pad",
   "if",
   "zero_pad",
   "and",
   "not",
   "(",
   "out_lens",
   "[",
   "-",
   "1",
   "]",
   "<=",
   "seconds",
   "*",
   "MS_PER_S",
   "+",
   "1",
   "and",
   "out_lens",
   "[",
   "-",
   "1",
   "]",
   ">=",
   "seconds",
   "*",
   "MS_PER_S",
   "-",
   "1",
   ")",
   ":",
   "num_zeros",
   "=",
   "self",
   ".",
   "frame_rate",
   "*",
   "(",
   "seconds",
   "*",
   "MS_PER_S",
   "-",
   "out_lens",
   "[",
   "-",
   "1",
   "]",
   ")",
   "outs",
   "[",
   "-",
   "1",
   "]",
   "=",
   "outs",
   "[",
   "-",
   "1",
   "]",
   ".",
   "zero_extend",
   "(",
   "num_samples",
   "=",
   "num_zeros",
   ")",
   "return",
   "outs"
  ]
 },
 {
  "idx": "maxmin-912",
  "nl_tokens": [
   "Estimates",
   "the",
   "K",
   "using",
   "K",
   "-",
   "means",
   "and",
   "BIC",
   "by",
   "sweeping",
   "various",
   "K",
   "and",
   "choosing",
   "the",
   "optimal",
   "BIC",
   "."
  ],
  "pl_tokens": [
   "def",
   "estimate_K_knee",
   "(",
   "self",
   ",",
   "th",
   "=",
   ".015",
   ",",
   "maxK",
   "=",
   "12",
   ")",
   ":",
   "# Sweep K-means",
   "if",
   "self",
   ".",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "<",
   "maxK",
   ":",
   "maxK",
   "=",
   "self",
   ".",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "if",
   "maxK",
   "<",
   "2",
   ":",
   "maxK",
   "=",
   "2",
   "K",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "1",
   ",",
   "maxK",
   ")",
   "bics",
   "=",
   "[",
   "]",
   "for",
   "k",
   "in",
   "K",
   ":",
   "means",
   ",",
   "labels",
   "=",
   "self",
   ".",
   "run_kmeans",
   "(",
   "self",
   ".",
   "X",
   ",",
   "k",
   ")",
   "bic",
   "=",
   "self",
   ".",
   "compute_bic",
   "(",
   "self",
   ".",
   "X",
   ",",
   "means",
   ",",
   "labels",
   ",",
   "K",
   "=",
   "k",
   ",",
   "R",
   "=",
   "self",
   ".",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "bics",
   ".",
   "append",
   "(",
   "bic",
   ")",
   "diff_bics",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "bics",
   ")",
   "finalK",
   "=",
   "K",
   "[",
   "-",
   "1",
   "]",
   "if",
   "len",
   "(",
   "bics",
   ")",
   "==",
   "1",
   ":",
   "finalK",
   "=",
   "2",
   "else",
   ":",
   "# Normalize",
   "bics",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "bics",
   ")",
   "bics",
   "-=",
   "bics",
   ".",
   "<mask>",
   "(",
   ")",
   "#bics /= bics.max()",
   "diff_bics",
   "-=",
   "diff_bics",
   ".",
   "min",
   "(",
   ")",
   "#diff_bics /= diff_bics.max()",
   "#print bics, diff_bics",
   "# Find optimum K",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "K",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   ")",
   ":",
   "#if bics[i] > diff_bics[i]:",
   "if",
   "diff_bics",
   "[",
   "i",
   "]",
   "<",
   "th",
   "and",
   "K",
   "[",
   "i",
   "]",
   "!=",
   "1",
   ":",
   "finalK",
   "=",
   "K",
   "[",
   "i",
   "]",
   "break",
   "#print \"Estimated K: \", finalK",
   "if",
   "self",
   ".",
   "plot",
   ":",
   "plt",
   ".",
   "subplot",
   "(",
   "2",
   ",",
   "1",
   ",",
   "1",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "K",
   ",",
   "bics",
   ",",
   "label",
   "=",
   "\"BIC\"",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "K",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "diff_bics",
   ",",
   "label",
   "=",
   "\"BIC diff\"",
   ")",
   "plt",
   ".",
   "legend",
   "(",
   "loc",
   "=",
   "2",
   ")",
   "plt",
   ".",
   "subplot",
   "(",
   "2",
   ",",
   "1",
   ",",
   "2",
   ")",
   "plt",
   ".",
   "scatter",
   "(",
   "self",
   ".",
   "X",
   "[",
   ":",
   ",",
   "0",
   "]",
   ",",
   "self",
   ".",
   "X",
   "[",
   ":",
   ",",
   "1",
   "]",
   ")",
   "plt",
   ".",
   "show",
   "(",
   ")",
   "return",
   "finalK"
  ]
 },
 {
  "idx": "maxmin-913",
  "nl_tokens": [
   "Processes",
   "a",
   "level",
   "of",
   "segmentation",
   "and",
   "converts",
   "it",
   "into",
   "times",
   "."
  ],
  "pl_tokens": [
   "def",
   "process_segmentation_level",
   "(",
   "est_idxs",
   ",",
   "est_labels",
   ",",
   "N",
   ",",
   "frame_times",
   ",",
   "dur",
   ")",
   ":",
   "assert",
   "est_idxs",
   "[",
   "0",
   "]",
   "==",
   "0",
   "and",
   "est_idxs",
   "[",
   "-",
   "1",
   "]",
   "==",
   "N",
   "-",
   "1",
   "assert",
   "len",
   "(",
   "est_idxs",
   ")",
   "-",
   "1",
   "==",
   "len",
   "(",
   "est_labels",
   ")",
   "# Add silences, if needed",
   "est_times",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "[",
   "0",
   "]",
   ",",
   "frame_times",
   "[",
   "est_idxs",
   "]",
   ",",
   "[",
   "dur",
   "]",
   ")",
   ")",
   "silence_label",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "est_labels",
   ")",
   "+",
   "1",
   "est_labels",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "[",
   "silence_label",
   "]",
   ",",
   "est_labels",
   ",",
   "[",
   "silence_label",
   "]",
   ")",
   ")",
   "# Remove empty segments if needed",
   "est_times",
   ",",
   "est_labels",
   "=",
   "remove_empty_segments",
   "(",
   "est_times",
   ",",
   "est_labels",
   ")",
   "# Make sure that the first and last times are 0 and duration, respectively",
   "assert",
   "np",
   ".",
   "allclose",
   "(",
   "[",
   "est_times",
   "[",
   "0",
   "]",
   "]",
   ",",
   "[",
   "0",
   "]",
   ")",
   "and",
   "np",
   ".",
   "allclose",
   "(",
   "[",
   "est_times",
   "[",
   "-",
   "1",
   "]",
   "]",
   ",",
   "[",
   "dur",
   "]",
   ")",
   "return",
   "est_times",
   ",",
   "est_labels"
  ]
 },
 {
  "idx": "maxmin-914",
  "nl_tokens": [
   "Creates",
   "a",
   "subset",
   "of",
   "samples",
   "which",
   "can",
   "be",
   "treated",
   "independently",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_subset",
   "(",
   "self",
   ",",
   "samples",
   "=",
   "None",
   ",",
   "name",
   "=",
   "None",
   ")",
   ":",
   "# Check if a subset containing the same samples already exists.",
   "for",
   "k",
   ",",
   "v",
   "in",
   "self",
   ".",
   "subsets",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "set",
   "(",
   "v",
   ")",
   "==",
   "set",
   "(",
   "samples",
   ")",
   "and",
   "k",
   "!=",
   "'not_in_set'",
   ":",
   "return",
   "k",
   "if",
   "isinstance",
   "(",
   "samples",
   ",",
   "str",
   ")",
   ":",
   "samples",
   "=",
   "[",
   "samples",
   "]",
   "not_exists",
   "=",
   "[",
   "s",
   "for",
   "s",
   "in",
   "samples",
   "if",
   "s",
   "not",
   "in",
   "self",
   ".",
   "subsets",
   "[",
   "'All_Analyses'",
   "]",
   "]",
   "if",
   "len",
   "(",
   "not_exists",
   ")",
   ">",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "', '",
   ".",
   "join",
   "(",
   "not_exists",
   ")",
   "+",
   "' not in the list of sample names.\\nPlease check your sample names.\\nNote: Sample names are stored in the .samples attribute of your analysis.'",
   ")",
   "if",
   "name",
   "is",
   "None",
   ":",
   "name",
   "=",
   "<mask>",
   "(",
   "[",
   "-",
   "1",
   "]",
   "+",
   "[",
   "x",
   "for",
   "x",
   "in",
   "self",
   ".",
   "subsets",
   ".",
   "keys",
   "(",
   ")",
   "if",
   "isinstance",
   "(",
   "x",
   ",",
   "int",
   ")",
   "]",
   ")",
   "+",
   "1",
   "self",
   ".",
   "_subset_names",
   ".",
   "append",
   "(",
   "name",
   ")",
   "if",
   "samples",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "subsets",
   "[",
   "name",
   "]",
   "=",
   "samples",
   "for",
   "s",
   "in",
   "samples",
   ":",
   "try",
   ":",
   "self",
   ".",
   "subsets",
   "[",
   "'not_in_set'",
   "]",
   ".",
   "remove",
   "(",
   "s",
   ")",
   "except",
   "ValueError",
   ":",
   "pass",
   "self",
   ".",
   "_has_subsets",
   "=",
   "True",
   "# for subset in np.unique(list(self.subsets.values())):",
   "#     self.subsets[subset] = sorted([k for k, v in self.subsets.items() if str(v) == subset])",
   "return",
   "name"
  ]
 },
 {
  "idx": "maxmin-915",
  "nl_tokens": [
   "Right",
   "-",
   "pad",
   "lines",
   "of",
   "block",
   "to",
   "equal",
   "width"
  ],
  "pl_tokens": [
   "def",
   "fill_rectangle",
   "(",
   "self",
   ",",
   "prepared",
   ")",
   ":",
   "result",
   "=",
   "[",
   "]",
   "width",
   "=",
   "<mask>",
   "(",
   "[",
   "self",
   ".",
   "clean_len",
   "(",
   "line",
   ")",
   "for",
   "line",
   "in",
   "prepared",
   "]",
   ")",
   "for",
   "line",
   "in",
   "prepared",
   ":",
   "spacer",
   "=",
   "' '",
   "*",
   "(",
   "width",
   "-",
   "self",
   ".",
   "clean_len",
   "(",
   "line",
   ")",
   ")",
   "result",
   ".",
   "append",
   "(",
   "line",
   "+",
   "(",
   "self",
   ".",
   "screen",
   ".",
   "markup",
   ".",
   "RESET",
   ",",
   "spacer",
   ")",
   ")",
   "return",
   "(",
   "width",
   ",",
   "result",
   ")"
  ]
 },
 {
  "idx": "maxmin-916",
  "nl_tokens": [
   "Plot",
   "a",
   "fitted",
   "PCA",
   "and",
   "all",
   "components",
   "."
  ],
  "pl_tokens": [
   "def",
   "pca_plot",
   "(",
   "pca",
   ",",
   "dt",
   ",",
   "xlabs",
   "=",
   "None",
   ",",
   "mode",
   "=",
   "'scatter'",
   ",",
   "lognorm",
   "=",
   "True",
   ")",
   ":",
   "nc",
   "=",
   "pca",
   ".",
   "n_components",
   "f",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "pca",
   ".",
   "n_features_",
   ")",
   "cs",
   "=",
   "list",
   "(",
   "itertools",
   ".",
   "combinations",
   "(",
   "range",
   "(",
   "nc",
   ")",
   ",",
   "2",
   ")",
   ")",
   "ind",
   "=",
   "~",
   "np",
   ".",
   "apply_along_axis",
   "(",
   "any",
   ",",
   "1",
   ",",
   "np",
   ".",
   "isnan",
   "(",
   "dt",
   ")",
   ")",
   "cylim",
   "=",
   "(",
   "pca",
   ".",
   "components_",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "pca",
   ".",
   "components_",
   ".",
   "max",
   "(",
   ")",
   ")",
   "yd",
   "=",
   "cylim",
   "[",
   "1",
   "]",
   "-",
   "cylim",
   "[",
   "0",
   "]",
   "# Make figure",
   "fig",
   ",",
   "axs",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "nc",
   ",",
   "nc",
   ",",
   "figsize",
   "=",
   "[",
   "3",
   "*",
   "nc",
   ",",
   "nc",
   "*",
   "3",
   "]",
   ",",
   "tight_layout",
   "=",
   "True",
   ")",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "*",
   "np",
   ".",
   "triu_indices",
   "(",
   "nc",
   ")",
   ")",
   ":",
   "if",
   "x",
   "==",
   "y",
   ":",
   "tax",
   "=",
   "axs",
   "[",
   "x",
   ",",
   "y",
   "]",
   "tax",
   ".",
   "bar",
   "(",
   "f",
   ",",
   "pca",
   ".",
   "components_",
   "[",
   "x",
   "]",
   ",",
   "0.8",
   ")",
   "tax",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "tax",
   ".",
   "axhline",
   "(",
   "0",
   ",",
   "zorder",
   "=",
   "-",
   "1",
   ",",
   "c",
   "=",
   "(",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0.6",
   ")",
   ")",
   "# labels            ",
   "tax",
   ".",
   "set_ylim",
   "(",
   "cylim",
   "[",
   "0",
   "]",
   "-",
   "0.2",
   "*",
   "yd",
   ",",
   "cylim",
   "[",
   "1",
   "]",
   "+",
   "0.2",
   "*",
   "yd",
   ")",
   "for",
   "xi",
   ",",
   "yi",
   ",",
   "lab",
   "in",
   "zip",
   "(",
   "f",
   ",",
   "pca",
   ".",
   "components_",
   "[",
   "x",
   "]",
   ",",
   "xlabs",
   ")",
   ":",
   "if",
   "yi",
   ">",
   "0",
   ":",
   "yo",
   "=",
   "yd",
   "*",
   "0.03",
   "va",
   "=",
   "'bottom'",
   "else",
   ":",
   "yo",
   "=",
   "yd",
   "*",
   "-",
   "0.02",
   "va",
   "=",
   "'top'",
   "tax",
   ".",
   "text",
   "(",
   "xi",
   ",",
   "yi",
   "+",
   "yo",
   ",",
   "lab",
   ",",
   "ha",
   "=",
   "'center'",
   ",",
   "va",
   "=",
   "va",
   ",",
   "rotation",
   "=",
   "90",
   ",",
   "fontsize",
   "=",
   "8",
   ")",
   "else",
   ":",
   "xv",
   "=",
   "dt",
   "[",
   "ind",
   ",",
   "x",
   "]",
   "yv",
   "=",
   "dt",
   "[",
   "ind",
   ",",
   "y",
   "]",
   "if",
   "mode",
   "==",
   "'scatter'",
   ":",
   "axs",
   "[",
   "x",
   ",",
   "y",
   "]",
   ".",
   "scatter",
   "(",
   "xv",
   ",",
   "yv",
   ",",
   "alpha",
   "=",
   "0.2",
   ")",
   "axs",
   "[",
   "y",
   ",",
   "x",
   "]",
   ".",
   "scatter",
   "(",
   "yv",
   ",",
   "xv",
   ",",
   "alpha",
   "=",
   "0.2",
   ")",
   "if",
   "mode",
   "==",
   "'hist2d'",
   ":",
   "if",
   "lognorm",
   ":",
   "norm",
   "=",
   "mpl",
   ".",
   "colors",
   ".",
   "LogNorm",
   "(",
   ")",
   "else",
   ":",
   "norm",
   "=",
   "None",
   "axs",
   "[",
   "x",
   ",",
   "y",
   "]",
   ".",
   "hist2d",
   "(",
   "xv",
   ",",
   "yv",
   ",",
   "50",
   ",",
   "cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "Blues",
   ",",
   "norm",
   "=",
   "norm",
   ")",
   "axs",
   "[",
   "y",
   ",",
   "x",
   "]",
   ".",
   "hist2d",
   "(",
   "yv",
   ",",
   "xv",
   ",",
   "50",
   ",",
   "cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "Blues",
   ",",
   "norm",
   "=",
   "norm",
   ")",
   "if",
   "x",
   "==",
   "0",
   ":",
   "axs",
   "[",
   "y",
   ",",
   "x",
   "]",
   ".",
   "set_ylabel",
   "(",
   "'PC{:.0f}'",
   ".",
   "format",
   "(",
   "y",
   "+",
   "1",
   ")",
   ")",
   "if",
   "y",
   "==",
   "nc",
   "-",
   "1",
   ":",
   "axs",
   "[",
   "y",
   ",",
   "x",
   "]",
   ".",
   "set_xlabel",
   "(",
   "'PC{:.0f}'",
   ".",
   "format",
   "(",
   "x",
   "+",
   "1",
   ")",
   ")",
   "return",
   "fig",
   ",",
   "axs",
   ",",
   "xv",
   ",",
   "yv"
  ]
 },
 {
  "idx": "maxmin-917",
  "nl_tokens": [
   "Prepare",
   "the",
   "rows",
   "so",
   "they",
   "re",
   "all",
   "strings",
   "and",
   "all",
   "the",
   "same",
   "length",
   "."
  ],
  "pl_tokens": [
   "def",
   "prepare_rows",
   "(",
   "table",
   ")",
   ":",
   "num_columns",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "row",
   ")",
   "for",
   "row",
   "in",
   "table",
   ")",
   "for",
   "row",
   "in",
   "table",
   ":",
   "while",
   "len",
   "(",
   "row",
   ")",
   "<",
   "num_columns",
   ":",
   "row",
   ".",
   "append",
   "(",
   "''",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "num_columns",
   ")",
   ":",
   "row",
   "[",
   "i",
   "]",
   "=",
   "str",
   "(",
   "row",
   "[",
   "i",
   "]",
   ")",
   "if",
   "row",
   "[",
   "i",
   "]",
   "is",
   "not",
   "None",
   "else",
   "''",
   "return",
   "table"
  ]
 },
 {
  "idx": "maxmin-918",
  "nl_tokens": [
   "Get",
   "maximum",
   "_instId",
   "from",
   "all",
   "assigments",
   "in",
   "statement"
  ],
  "pl_tokens": [
   "def",
   "getMaxStmIdForStm",
   "(",
   "stm",
   ")",
   ":",
   "maxId",
   "=",
   "0",
   "if",
   "isinstance",
   "(",
   "stm",
   ",",
   "Assignment",
   ")",
   ":",
   "return",
   "stm",
   ".",
   "_instId",
   "elif",
   "isinstance",
   "(",
   "stm",
   ",",
   "WaitStm",
   ")",
   ":",
   "return",
   "maxId",
   "else",
   ":",
   "for",
   "_stm",
   "in",
   "stm",
   ".",
   "_iter_stms",
   "(",
   ")",
   ":",
   "maxId",
   "=",
   "<mask>",
   "(",
   "maxId",
   ",",
   "getMaxStmIdForStm",
   "(",
   "_stm",
   ")",
   ")",
   "return",
   "maxId"
  ]
 },
 {
  "idx": "maxmin-919",
  "nl_tokens": [
   "Y",
   "=",
   "resample_mx",
   "(",
   "X",
   "incolpos",
   "outcolpos",
   ")",
   "X",
   "is",
   "taken",
   "as",
   "a",
   "set",
   "of",
   "columns",
   "each",
   "starting",
   "at",
   "time",
   "colpos",
   "and",
   "continuing",
   "until",
   "the",
   "start",
   "of",
   "the",
   "next",
   "column",
   ".",
   "Y",
   "is",
   "a",
   "similar",
   "matrix",
   "with",
   "time",
   "boundaries",
   "defined",
   "by",
   "outcolpos",
   ".",
   "Each",
   "column",
   "of",
   "Y",
   "is",
   "a",
   "duration",
   "-",
   "weighted",
   "average",
   "of",
   "the",
   "overlapping",
   "columns",
   "of",
   "X",
   ".",
   "2010",
   "-",
   "04",
   "-",
   "14",
   "Dan",
   "Ellis",
   "dpwe"
  ],
  "pl_tokens": [
   "def",
   "resample_mx",
   "(",
   "X",
   ",",
   "incolpos",
   ",",
   "outcolpos",
   ")",
   ":",
   "noutcols",
   "=",
   "len",
   "(",
   "outcolpos",
   ")",
   "Y",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "noutcols",
   ")",
   ")",
   "# assign 'end times' to final columns",
   "if",
   "outcolpos",
   ".",
   "<mask>",
   "(",
   ")",
   ">",
   "incolpos",
   ".",
   "max",
   "(",
   ")",
   ":",
   "incolpos",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "incolpos",
   ",",
   "[",
   "outcolpos",
   ".",
   "max",
   "(",
   ")",
   "]",
   "]",
   ")",
   "X",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "X",
   ",",
   "X",
   "[",
   ":",
   ",",
   "-",
   "1",
   "]",
   ".",
   "reshape",
   "(",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "1",
   ")",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "outcolpos",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "outcolpos",
   ",",
   "[",
   "outcolpos",
   "[",
   "-",
   "1",
   "]",
   "]",
   "]",
   ")",
   "# durations (default weights) of input columns)",
   "incoldurs",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "np",
   ".",
   "diff",
   "(",
   "incolpos",
   ")",
   ",",
   "[",
   "1",
   "]",
   "]",
   ")",
   "for",
   "c",
   "in",
   "range",
   "(",
   "noutcols",
   ")",
   ":",
   "firstincol",
   "=",
   "np",
   ".",
   "where",
   "(",
   "incolpos",
   "<=",
   "outcolpos",
   "[",
   "c",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "-",
   "1",
   "]",
   "firstincolnext",
   "=",
   "np",
   ".",
   "where",
   "(",
   "incolpos",
   "<",
   "outcolpos",
   "[",
   "c",
   "+",
   "1",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "-",
   "1",
   "]",
   "lastincol",
   "=",
   "max",
   "(",
   "firstincol",
   ",",
   "firstincolnext",
   ")",
   "# default weights",
   "wts",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "incoldurs",
   "[",
   "firstincol",
   ":",
   "lastincol",
   "+",
   "1",
   "]",
   ")",
   "# now fix up by partial overlap at ends",
   "if",
   "len",
   "(",
   "wts",
   ")",
   ">",
   "1",
   ":",
   "wts",
   "[",
   "0",
   "]",
   "=",
   "wts",
   "[",
   "0",
   "]",
   "-",
   "(",
   "outcolpos",
   "[",
   "c",
   "]",
   "-",
   "incolpos",
   "[",
   "firstincol",
   "]",
   ")",
   "wts",
   "[",
   "-",
   "1",
   "]",
   "=",
   "wts",
   "[",
   "-",
   "1",
   "]",
   "-",
   "(",
   "incolpos",
   "[",
   "lastincol",
   "+",
   "1",
   "]",
   "-",
   "outcolpos",
   "[",
   "c",
   "+",
   "1",
   "]",
   ")",
   "wts",
   "=",
   "wts",
   "*",
   "1.",
   "/",
   "float",
   "(",
   "sum",
   "(",
   "wts",
   ")",
   ")",
   "Y",
   "[",
   ":",
   ",",
   "c",
   "]",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "X",
   "[",
   ":",
   ",",
   "firstincol",
   ":",
   "lastincol",
   "+",
   "1",
   "]",
   ",",
   "wts",
   ")",
   "# done",
   "return",
   "Y"
  ]
 },
 {
  "idx": "maxmin-920",
  "nl_tokens": [
   "Computes",
   "the",
   "labels",
   "using",
   "the",
   "bounds",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_labels",
   "(",
   "X",
   ",",
   "rank",
   ",",
   "R",
   ",",
   "bound_idxs",
   ",",
   "niter",
   "=",
   "300",
   ")",
   ":",
   "try",
   ":",
   "F",
   ",",
   "G",
   "=",
   "cnmf",
   "(",
   "X",
   ",",
   "rank",
   ",",
   "niter",
   "=",
   "niter",
   ",",
   "hull",
   "=",
   "False",
   ")",
   "except",
   ":",
   "return",
   "[",
   "1",
   "]",
   "label_frames",
   "=",
   "filter_activation_matrix",
   "(",
   "G",
   ".",
   "T",
   ",",
   "R",
   ")",
   "label_frames",
   "=",
   "np",
   ".",
   "asarray",
   "(",
   "label_frames",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   "#labels = [label_frames[0]]",
   "labels",
   "=",
   "[",
   "]",
   "bound_inters",
   "=",
   "zip",
   "(",
   "bound_idxs",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "bound_idxs",
   "[",
   "1",
   ":",
   "]",
   ")",
   "for",
   "bound_inter",
   "in",
   "bound_inters",
   ":",
   "if",
   "bound_inter",
   "[",
   "1",
   "]",
   "-",
   "bound_inter",
   "[",
   "0",
   "]",
   "<=",
   "0",
   ":",
   "labels",
   ".",
   "append",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "label_frames",
   ")",
   "+",
   "1",
   ")",
   "else",
   ":",
   "labels",
   ".",
   "append",
   "(",
   "most_frequent",
   "(",
   "label_frames",
   "[",
   "bound_inter",
   "[",
   "0",
   "]",
   ":",
   "bound_inter",
   "[",
   "1",
   "]",
   "]",
   ")",
   ")",
   "#print bound_inter, labels[-1]",
   "#labels.append(label_frames[-1])",
   "return",
   "labels"
  ]
 },
 {
  "idx": "maxmin-921",
  "nl_tokens": [
   "Create",
   "new",
   "independent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_indep_vector",
   "(",
   "wave_a",
   ",",
   "wave_b",
   ")",
   ":",
   "exobj",
   "=",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "RuntimeError",
   ",",
   "\"Independent variable ranges do not overlap\"",
   ")",
   "min_bound",
   "=",
   "<mask>",
   "(",
   "np",
   ".",
   "min",
   "(",
   "wave_a",
   ".",
   "indep_vector",
   ")",
   ",",
   "np",
   ".",
   "min",
   "(",
   "wave_b",
   ".",
   "indep_vector",
   ")",
   ")",
   "max_bound",
   "=",
   "min",
   "(",
   "np",
   ".",
   "max",
   "(",
   "wave_a",
   ".",
   "indep_vector",
   ")",
   ",",
   "np",
   ".",
   "max",
   "(",
   "wave_b",
   ".",
   "indep_vector",
   ")",
   ")",
   "exobj",
   "(",
   "bool",
   "(",
   "min_bound",
   ">",
   "max_bound",
   ")",
   ")",
   "raw_range",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "wave_a",
   ".",
   "indep_vector",
   ",",
   "wave_b",
   ".",
   "indep_vector",
   ")",
   ")",
   ")",
   "return",
   "raw_range",
   "[",
   "np",
   ".",
   "logical_and",
   "(",
   "min_bound",
   "<=",
   "raw_range",
   ",",
   "raw_range",
   "<=",
   "max_bound",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-922",
  "nl_tokens": [
   "Returns",
   "the",
   "next",
   "occurrence",
   "of",
   "a",
   "given",
   "event",
   "relative",
   "to",
   "now",
   ".",
   "The",
   "event",
   "arg",
   "should",
   "be",
   "an",
   "iterable",
   "containing",
   "one",
   "element",
   "namely",
   "the",
   "event",
   "we",
   "d",
   "like",
   "to",
   "find",
   "the",
   "occurrence",
   "of",
   ".",
   "The",
   "reason",
   "for",
   "this",
   "is",
   "b",
   "/",
   "c",
   "the",
   "get_count",
   "()",
   "function",
   "of",
   "CountHandler",
   "which",
   "this",
   "func",
   "makes",
   "use",
   "of",
   "expects",
   "an",
   "iterable",
   ".",
   "CHANGED",
   ":",
   "The",
   "now",
   "arg",
   "must",
   "be",
   "an",
   "instance",
   "of",
   "datetime",
   ".",
   "datetime",
   "()",
   "to",
   "allow",
   "time",
   "comparison",
   "(",
   "used",
   "to",
   "accept",
   "datetime",
   ".",
   "date",
   "()",
   "as",
   "well",
   ")"
  ],
  "pl_tokens": [
   "def",
   "get_next_event",
   "(",
   "event",
   ",",
   "now",
   ")",
   ":",
   "year",
   "=",
   "now",
   ".",
   "year",
   "month",
   "=",
   "now",
   ".",
   "month",
   "day",
   "=",
   "now",
   ".",
   "day",
   "e_day",
   "=",
   "event",
   "[",
   "0",
   "]",
   ".",
   "l_start_date",
   ".",
   "day",
   "e_end_day",
   "=",
   "event",
   "[",
   "0",
   "]",
   ".",
   "l_end_date",
   ".",
   "day",
   "good_today",
   "=",
   "True",
   "if",
   "event",
   "[",
   "0",
   "]",
   ".",
   "l_start_date",
   ".",
   "time",
   "(",
   ")",
   ">=",
   "now",
   ".",
   "time",
   "(",
   ")",
   "else",
   "False",
   "if",
   "event",
   "[",
   "0",
   "]",
   ".",
   "starts_same_year_month_as",
   "(",
   "year",
   ",",
   "month",
   ")",
   "and",
   "e_day",
   "<=",
   "now",
   ".",
   "day",
   "<=",
   "e_end_day",
   ":",
   "occurrences",
   "=",
   "CountHandler",
   "(",
   "year",
   ",",
   "month",
   ",",
   "event",
   ")",
   ".",
   "get_count",
   "(",
   ")",
   "future_dates",
   "=",
   "(",
   "x",
   "for",
   "x",
   "in",
   "occurrences",
   "if",
   "x",
   ">=",
   "now",
   ".",
   "day",
   ")",
   "day",
   "=",
   "<mask>",
   "(",
   "future_dates",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "abs",
   "(",
   "x",
   "-",
   "now",
   ".",
   "day",
   ")",
   ")",
   "else",
   ":",
   "e_year",
   "=",
   "event",
   "[",
   "0",
   "]",
   ".",
   "l_start_date",
   ".",
   "year",
   "e_month",
   "=",
   "event",
   "[",
   "0",
   "]",
   ".",
   "l_start_date",
   ".",
   "month",
   "# convert to datetime.date() to be sure we can make a comparison",
   "if",
   "date",
   "(",
   "e_year",
   ",",
   "e_month",
   ",",
   "e_day",
   ")",
   ">",
   "date",
   "(",
   "now",
   ".",
   "year",
   ",",
   "now",
   ".",
   "month",
   ",",
   "now",
   ".",
   "day",
   ")",
   ":",
   "# if the event hasn't started yet, then its next occurrence will",
   "# be on its start date, so return that.",
   "year",
   "=",
   "e_year",
   "month",
   "=",
   "e_month",
   "day",
   "=",
   "e_day",
   "else",
   ":",
   "occurrences",
   "=",
   "CountHandler",
   "(",
   "year",
   ",",
   "month",
   ",",
   "event",
   ")",
   ".",
   "get_count",
   "(",
   ")",
   "future_dates",
   "=",
   "[",
   "x",
   "for",
   "x",
   "in",
   "occurrences",
   "if",
   "x",
   ">=",
   "now",
   ".",
   "day",
   "]",
   "e_end_month",
   "=",
   "event",
   "[",
   "0",
   "]",
   ".",
   "l_end_date",
   ".",
   "month",
   "if",
   "future_dates",
   "and",
   "future_dates",
   "[",
   "0",
   "]",
   "is",
   "day",
   "and",
   "not",
   "good_today",
   ":",
   "future_dates",
   ".",
   "pop",
   "(",
   "0",
   ")",
   "while",
   "not",
   "future_dates",
   ":",
   "month",
   ",",
   "year",
   "=",
   "inc_month",
   "(",
   "month",
   ",",
   "year",
   ")",
   "if",
   "event",
   "[",
   "0",
   "]",
   ".",
   "repeats",
   "(",
   "'YEARLY'",
   ")",
   "and",
   "(",
   "month",
   "!=",
   "e_month",
   "or",
   "month",
   "!=",
   "e_end_month",
   ")",
   ":",
   "continue",
   "occurrences",
   "=",
   "CountHandler",
   "(",
   "year",
   ",",
   "month",
   ",",
   "event",
   ")",
   ".",
   "get_count",
   "(",
   ")",
   "# we don't check for now.day here, b/c we're in a month past",
   "# whatever now is. As an example, if we checked for now.day",
   "# we'd get stuck in an infinite loop if this were a",
   "# monthly repeating event and our 'now' was on a day after the",
   "# event's l_end_date.day",
   "future_dates",
   "=",
   "[",
   "x",
   "for",
   "x",
   "in",
   "occurrences",
   "]",
   "day",
   "=",
   "min",
   "(",
   "future_dates",
   ")",
   "if",
   "event",
   "[",
   "0",
   "]",
   ".",
   "repeats",
   "(",
   "'WEEKDAY'",
   ")",
   ":",
   "return",
   "check_weekday",
   "(",
   "year",
   ",",
   "month",
   ",",
   "day",
   ")",
   "return",
   "year",
   ",",
   "month",
   ",",
   "day"
  ]
 },
 {
  "idx": "maxmin-923",
  "nl_tokens": [
   "Computes",
   "the",
   "novelty",
   "curve",
   "from",
   "the",
   "self",
   "-",
   "similarity",
   "matrix",
   "X",
   "and",
   "the",
   "gaussian",
   "kernel",
   "G",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_nc",
   "(",
   "X",
   ",",
   "G",
   ")",
   ":",
   "N",
   "=",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "M",
   "=",
   "G",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "nc",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "N",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "M",
   "//",
   "2",
   ",",
   "N",
   "-",
   "M",
   "//",
   "2",
   "+",
   "1",
   ")",
   ":",
   "nc",
   "[",
   "i",
   "]",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "X",
   "[",
   "i",
   "-",
   "M",
   "//",
   "2",
   ":",
   "i",
   "+",
   "M",
   "//",
   "2",
   ",",
   "i",
   "-",
   "M",
   "//",
   "2",
   ":",
   "i",
   "+",
   "M",
   "//",
   "2",
   "]",
   "*",
   "G",
   ")",
   "# Normalize",
   "nc",
   "+=",
   "nc",
   ".",
   "<mask>",
   "(",
   ")",
   "nc",
   "/=",
   "nc",
   ".",
   "max",
   "(",
   ")",
   "return",
   "nc"
  ]
 },
 {
  "idx": "maxmin-924",
  "nl_tokens": [
   "Change",
   "the",
   "font",
   "size",
   "by",
   "the",
   "specified",
   "amount",
   "(",
   "in",
   "points",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "change_font_size",
   "(",
   "self",
   ",",
   "delta",
   ")",
   ":",
   "font",
   "=",
   "self",
   ".",
   "font",
   "size",
   "=",
   "<mask>",
   "(",
   "font",
   ".",
   "pointSize",
   "(",
   ")",
   "+",
   "delta",
   ",",
   "1",
   ")",
   "# minimum 1 point",
   "font",
   ".",
   "setPointSize",
   "(",
   "size",
   ")",
   "self",
   ".",
   "_set_font",
   "(",
   "font",
   ")"
  ]
 },
 {
  "idx": "maxmin-925",
  "nl_tokens": [
   "Generator",
   "that",
   "decrypts",
   "a",
   "content",
   "stream",
   "using",
   "AES",
   "256",
   "in",
   "CBC",
   "mode",
   "."
  ],
  "pl_tokens": [
   "def",
   "aes_decrypt",
   "(",
   "key",
   ",",
   "stdin",
   ",",
   "chunk_size",
   "=",
   "65536",
   ")",
   ":",
   "if",
   "not",
   "AES256CBC_Support",
   ":",
   "raise",
   "Exception",
   "(",
   "'AES256CBC not supported; likely pycrypto is not installed'",
   ")",
   "# Always use 256-bit key",
   "key",
   "=",
   "hashlib",
   ".",
   "sha256",
   "(",
   "key",
   ")",
   ".",
   "digest",
   "(",
   ")",
   "# At least 16 and a multiple of 16",
   "chunk_size",
   "=",
   "<mask>",
   "(",
   "16",
   ",",
   "chunk_size",
   ">>",
   "4",
   "<<",
   "4",
   ")",
   "iv",
   "=",
   "stdin",
   ".",
   "read",
   "(",
   "16",
   ")",
   "while",
   "len",
   "(",
   "iv",
   ")",
   "<",
   "16",
   ":",
   "chunk",
   "=",
   "stdin",
   ".",
   "read",
   "(",
   "16",
   "-",
   "len",
   "(",
   "iv",
   ")",
   ")",
   "if",
   "not",
   "chunk",
   ":",
   "raise",
   "IOError",
   "(",
   "'EOF reading IV'",
   ")",
   "decryptor",
   "=",
   "Crypto",
   ".",
   "Cipher",
   ".",
   "AES",
   ".",
   "new",
   "(",
   "key",
   ",",
   "Crypto",
   ".",
   "Cipher",
   ".",
   "AES",
   ".",
   "MODE_CBC",
   ",",
   "iv",
   ")",
   "data",
   "=",
   "''",
   "while",
   "True",
   ":",
   "chunk",
   "=",
   "stdin",
   ".",
   "read",
   "(",
   "chunk_size",
   ")",
   "if",
   "not",
   "chunk",
   ":",
   "if",
   "len",
   "(",
   "data",
   ")",
   "!=",
   "16",
   ":",
   "raise",
   "IOError",
   "(",
   "'EOF reading encrypted stream'",
   ")",
   "data",
   "=",
   "decryptor",
   ".",
   "decrypt",
   "(",
   "data",
   ")",
   "trailing",
   "=",
   "ord",
   "(",
   "data",
   "[",
   "-",
   "1",
   "]",
   ")",
   "if",
   "trailing",
   ">",
   "15",
   ":",
   "raise",
   "IOError",
   "(",
   "'EOF reading encrypted stream or trailing value corrupted '",
   "'%s'",
   "%",
   "trailing",
   ")",
   "yield",
   "data",
   "[",
   ":",
   "trailing",
   "]",
   "break",
   "data",
   "+=",
   "chunk",
   "if",
   "len",
   "(",
   "data",
   ")",
   ">",
   "16",
   ":",
   "# Always leave at least one byte pending",
   "trailing",
   "=",
   "(",
   "len",
   "(",
   "data",
   ")",
   "%",
   "16",
   ")",
   "or",
   "16",
   "yield",
   "decryptor",
   ".",
   "decrypt",
   "(",
   "data",
   "[",
   ":",
   "-",
   "trailing",
   "]",
   ")",
   "data",
   "=",
   "data",
   "[",
   "-",
   "trailing",
   ":",
   "]"
  ]
 },
 {
  "idx": "maxmin-926",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "minimum",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "nmin",
   "(",
   "wave",
   ",",
   "indep_min",
   "=",
   "None",
   ",",
   "indep_max",
   "=",
   "None",
   ")",
   ":",
   "ret",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "wave",
   ")",
   "_bound_waveform",
   "(",
   "ret",
   ",",
   "indep_min",
   ",",
   "indep_max",
   ")",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")"
  ]
 },
 {
  "idx": "maxmin-927",
  "nl_tokens": [
   "Estimate",
   "tx",
   "gas",
   ".",
   "Use",
   "the",
   "max",
   "of",
   "calculation",
   "using",
   "safe",
   "method",
   "and",
   "web3",
   "if",
   "operation",
   "==",
   "CALL",
   "or",
   "use",
   "just",
   "the",
   "safe",
   "calculation",
   "otherwise"
  ],
  "pl_tokens": [
   "def",
   "estimate_tx_gas",
   "(",
   "self",
   ",",
   "safe_address",
   ":",
   "str",
   ",",
   "to",
   ":",
   "str",
   ",",
   "value",
   ":",
   "int",
   ",",
   "data",
   ":",
   "bytes",
   ",",
   "operation",
   ":",
   "int",
   ")",
   "->",
   "int",
   ":",
   "# Costs to route through the proxy and nested calls",
   "proxy_gas",
   "=",
   "1000",
   "# https://github.com/ethereum/solidity/blob/dfe3193c7382c80f1814247a162663a97c3f5e67/libsolidity/codegen/ExpressionCompiler.cpp#L1764",
   "# This was `false` before solc 0.4.21 -> `m_context.evmVersion().canOverchargeGasForCall()`",
   "# So gas needed by caller will be around 35k",
   "old_call_gas",
   "=",
   "35000",
   "safe_gas_estimation",
   "=",
   "(",
   "self",
   ".",
   "estimate_tx_gas_with_safe",
   "(",
   "safe_address",
   ",",
   "to",
   ",",
   "value",
   ",",
   "data",
   ",",
   "operation",
   ")",
   "+",
   "proxy_gas",
   "+",
   "old_call_gas",
   ")",
   "# We cannot estimate DELEGATECALL (different storage)",
   "if",
   "SafeOperation",
   "(",
   "operation",
   ")",
   "==",
   "SafeOperation",
   ".",
   "CALL",
   ":",
   "try",
   ":",
   "web3_gas_estimation",
   "=",
   "(",
   "self",
   ".",
   "estimate_tx_gas_with_web3",
   "(",
   "safe_address",
   ",",
   "to",
   ",",
   "value",
   ",",
   "data",
   ")",
   "+",
   "proxy_gas",
   "+",
   "old_call_gas",
   ")",
   "except",
   "ValueError",
   ":",
   "web3_gas_estimation",
   "=",
   "0",
   "return",
   "<mask>",
   "(",
   "safe_gas_estimation",
   ",",
   "web3_gas_estimation",
   ")",
   "else",
   ":",
   "return",
   "safe_gas_estimation"
  ]
 },
 {
  "idx": "maxmin-928",
  "nl_tokens": [
   "Return",
   "a",
   "pretty",
   "-",
   "print",
   "of",
   "self",
   ".",
   "string",
   "as",
   "string",
   "."
  ],
  "pl_tokens": [
   "def",
   "pformat",
   "(",
   "self",
   ",",
   "indent",
   ":",
   "str",
   "=",
   "'    '",
   ",",
   "remove_comments",
   "=",
   "False",
   ")",
   "->",
   "str",
   ":",
   "ws",
   "=",
   "WS",
   "# Do not try to do inplace pformat. It will overwrite on some spans.",
   "string",
   "=",
   "self",
   ".",
   "string",
   "parsed",
   "=",
   "WikiText",
   "(",
   "[",
   "string",
   "]",
   ",",
   "self",
   ".",
   "_pp_type_to_spans",
   "(",
   ")",
   ")",
   "# Since _type_to_spans arg of WikiText has been used, parsed._span",
   "# is not set yet.",
   "span",
   "=",
   "[",
   "0",
   ",",
   "len",
   "(",
   "string",
   ")",
   "]",
   "parsed",
   ".",
   "_span",
   "=",
   "span",
   "parsed",
   ".",
   "_type_to_spans",
   "[",
   "'WikiText'",
   "]",
   "=",
   "[",
   "span",
   "]",
   "if",
   "remove_comments",
   ":",
   "for",
   "c",
   "in",
   "parsed",
   ".",
   "comments",
   ":",
   "del",
   "c",
   "[",
   ":",
   "]",
   "else",
   ":",
   "# Only remove comments that contain whitespace.",
   "for",
   "c",
   "in",
   "parsed",
   ".",
   "comments",
   ":",
   "if",
   "not",
   "c",
   ".",
   "contents",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   ":",
   "del",
   "c",
   "[",
   ":",
   "]",
   "# First remove all current spacings.",
   "for",
   "template",
   "in",
   "reversed",
   "(",
   "parsed",
   ".",
   "templates",
   ")",
   ":",
   "stripped_tl_name",
   "=",
   "template",
   ".",
   "name",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "template",
   ".",
   "name",
   "=",
   "(",
   "' '",
   "+",
   "stripped_tl_name",
   "+",
   "' '",
   "if",
   "stripped_tl_name",
   "[",
   "0",
   "]",
   "==",
   "'{'",
   "else",
   "stripped_tl_name",
   ")",
   "args",
   "=",
   "template",
   ".",
   "arguments",
   "if",
   "not",
   "args",
   ":",
   "continue",
   "if",
   "':'",
   "in",
   "stripped_tl_name",
   ":",
   "# Don't use False because we don't know for sure.",
   "not_a_parser_function",
   "=",
   "None",
   "else",
   ":",
   "not_a_parser_function",
   "=",
   "True",
   "# Required for alignment",
   "arg_stripped_names",
   "=",
   "[",
   "a",
   ".",
   "name",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "for",
   "a",
   "in",
   "args",
   "]",
   "arg_positionalities",
   "=",
   "[",
   "a",
   ".",
   "positional",
   "for",
   "a",
   "in",
   "args",
   "]",
   "arg_name_lengths",
   "=",
   "[",
   "wcswidth",
   "(",
   "n",
   ".",
   "replace",
   "(",
   "'\u0644\u0627', ",
   "'",
   "'))",
   "",
   "",
   "if",
   "not",
   "p",
   "else",
   "0",
   "for",
   "n",
   ",",
   "p",
   "in",
   "zip",
   "(",
   "arg_stripped_names",
   ",",
   "arg_positionalities",
   ")",
   "]",
   "max_name_len",
   "=",
   "<mask>",
   "(",
   "arg_name_lengths",
   ")",
   "# Format template.name.",
   "level",
   "=",
   "template",
   ".",
   "nesting_level",
   "newline_indent",
   "=",
   "'\\n'",
   "+",
   "indent",
   "*",
   "level",
   "template",
   ".",
   "name",
   "+=",
   "newline_indent",
   "if",
   "level",
   "==",
   "1",
   ":",
   "last_comment_indent",
   "=",
   "'<!--\\n-->'",
   "else",
   ":",
   "last_comment_indent",
   "=",
   "'<!--\\n'",
   "+",
   "indent",
   "*",
   "(",
   "level",
   "-",
   "2",
   ")",
   "+",
   "' -->'",
   "# Special formatting for the last argument.",
   "last_arg",
   "=",
   "args",
   ".",
   "pop",
   "(",
   ")",
   "last_is_positional",
   "=",
   "arg_positionalities",
   ".",
   "pop",
   "(",
   ")",
   "last_value",
   "=",
   "last_arg",
   ".",
   "value",
   "last_stripped_value",
   "=",
   "last_value",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "if",
   "last_is_positional",
   "and",
   "last_value",
   "!=",
   "last_stripped_value",
   ":",
   "stop_conversion",
   "=",
   "True",
   "if",
   "not",
   "last_value",
   ".",
   "endswith",
   "(",
   "'\\n'",
   "+",
   "indent",
   "*",
   "(",
   "level",
   "-",
   "1",
   ")",
   ")",
   ":",
   "last_arg",
   ".",
   "value",
   "=",
   "last_value",
   "+",
   "last_comment_indent",
   "elif",
   "not_a_parser_function",
   ":",
   "stop_conversion",
   "=",
   "False",
   "last_arg",
   ".",
   "name",
   "=",
   "(",
   "' '",
   "+",
   "arg_stripped_names",
   ".",
   "pop",
   "(",
   ")",
   "+",
   "' '",
   "+",
   "' '",
   "*",
   "(",
   "max_name_len",
   "-",
   "arg_name_lengths",
   ".",
   "pop",
   "(",
   ")",
   ")",
   ")",
   "last_arg",
   ".",
   "value",
   "=",
   "(",
   "' '",
   "+",
   "last_stripped_value",
   "+",
   "'\\n'",
   "+",
   "indent",
   "*",
   "(",
   "level",
   "-",
   "1",
   ")",
   ")",
   "elif",
   "last_is_positional",
   ":",
   "# (last_value == last_stripped_value",
   "# and not_a_parser_function is not True)",
   "stop_conversion",
   "=",
   "True",
   "# Can't strip or adjust the position of the value",
   "# because this could be a positional argument in a template.",
   "last_arg",
   ".",
   "value",
   "=",
   "last_value",
   "+",
   "last_comment_indent",
   "else",
   ":",
   "stop_conversion",
   "=",
   "True",
   "# This is either a parser function or a keyword",
   "# argument in a template. In both cases the name",
   "# can be lstripped and the value can be rstripped.",
   "last_arg",
   ".",
   "name",
   "=",
   "' '",
   "+",
   "last_arg",
   ".",
   "name",
   ".",
   "lstrip",
   "(",
   "ws",
   ")",
   "if",
   "not",
   "last_value",
   ".",
   "endswith",
   "(",
   "'\\n'",
   "+",
   "indent",
   "*",
   "(",
   "level",
   "-",
   "1",
   ")",
   ")",
   ":",
   "last_arg",
   ".",
   "value",
   "=",
   "(",
   "last_value",
   ".",
   "rstrip",
   "(",
   "ws",
   ")",
   "+",
   "' '",
   "+",
   "last_comment_indent",
   ")",
   "if",
   "not",
   "args",
   ":",
   "continue",
   "comment_indent",
   "=",
   "'<!--\\n'",
   "+",
   "indent",
   "*",
   "(",
   "level",
   "-",
   "1",
   ")",
   "+",
   "' -->'",
   "for",
   "arg",
   ",",
   "stripped_name",
   ",",
   "positional",
   ",",
   "arg_name_len",
   "in",
   "zip",
   "(",
   "reversed",
   "(",
   "args",
   ")",
   ",",
   "reversed",
   "(",
   "arg_stripped_names",
   ")",
   ",",
   "reversed",
   "(",
   "arg_positionalities",
   ")",
   ",",
   "reversed",
   "(",
   "arg_name_lengths",
   ")",
   ",",
   ")",
   ":",
   "value",
   "=",
   "arg",
   ".",
   "value",
   "stripped_value",
   "=",
   "value",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "# Positional arguments of templates are sensitive to",
   "# whitespace. See:",
   "# https://meta.wikimedia.org/wiki/Help:Newlines_and_spaces",
   "if",
   "stop_conversion",
   ":",
   "if",
   "not",
   "value",
   ".",
   "endswith",
   "(",
   "newline_indent",
   ")",
   ":",
   "arg",
   ".",
   "value",
   "+=",
   "comment_indent",
   "elif",
   "positional",
   "and",
   "value",
   "!=",
   "stripped_value",
   ":",
   "stop_conversion",
   "=",
   "True",
   "if",
   "not",
   "value",
   ".",
   "endswith",
   "(",
   "newline_indent",
   ")",
   ":",
   "arg",
   ".",
   "value",
   "+=",
   "comment_indent",
   "elif",
   "not_a_parser_function",
   ":",
   "arg",
   ".",
   "name",
   "=",
   "(",
   "' '",
   "+",
   "stripped_name",
   "+",
   "' '",
   "+",
   "' '",
   "*",
   "(",
   "max_name_len",
   "-",
   "arg_name_len",
   ")",
   ")",
   "arg",
   ".",
   "value",
   "=",
   "' '",
   "+",
   "stripped_value",
   "+",
   "newline_indent",
   "i",
   "=",
   "0",
   "functions",
   "=",
   "parsed",
   ".",
   "parser_functions",
   "while",
   "i",
   "<",
   "len",
   "(",
   "functions",
   ")",
   ":",
   "func",
   "=",
   "functions",
   "[",
   "i",
   "]",
   "i",
   "+=",
   "1",
   "name",
   "=",
   "func",
   ".",
   "name",
   "ls_name",
   "=",
   "name",
   ".",
   "lstrip",
   "(",
   "ws",
   ")",
   "lws",
   "=",
   "len",
   "(",
   "name",
   ")",
   "-",
   "len",
   "(",
   "ls_name",
   ")",
   "if",
   "lws",
   ":",
   "del",
   "func",
   "[",
   "2",
   ":",
   "lws",
   "+",
   "2",
   "]",
   "if",
   "ls_name",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "(",
   "'#tag'",
   ",",
   "'#invoke'",
   ",",
   "''",
   ")",
   ":",
   "# The 2nd argument of `tag` parser function is an exception",
   "# and cannot be stripped.",
   "# So in `{{#tag:tagname|arg1|...}}`, no whitespace should be",
   "# added/removed to/from arg1.",
   "# See: [[mw:Help:Extension:ParserFunctions#Miscellaneous]]",
   "# All args of #invoke are also whitespace-sensitive.",
   "# Todo: Instead use comments to indent.",
   "continue",
   "args",
   "=",
   "func",
   ".",
   "arguments",
   "# Whitespace, including newlines, tabs, and spaces is stripped",
   "# from the beginning and end of all the parameters of",
   "# parser functions. See:",
   "# www.mediawiki.org/wiki/Help:Extension:ParserFunctions#",
   "#    Stripping_whitespace",
   "level",
   "=",
   "func",
   ".",
   "nesting_level",
   "short_indent",
   "=",
   "'\\n'",
   "+",
   "indent",
   "*",
   "(",
   "level",
   "-",
   "1",
   ")",
   "newline_indent",
   "=",
   "short_indent",
   "+",
   "indent",
   "if",
   "len",
   "(",
   "args",
   ")",
   "==",
   "1",
   ":",
   "arg",
   "=",
   "args",
   "[",
   "0",
   "]",
   "# the first arg is both the first and last argument",
   "if",
   "arg",
   ".",
   "positional",
   ":",
   "arg",
   ".",
   "value",
   "=",
   "(",
   "newline_indent",
   "+",
   "arg",
   ".",
   "value",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "+",
   "short_indent",
   ")",
   "else",
   ":",
   "# Note that we don't add spaces before and after the",
   "# '=' in parser functions because it could be part of",
   "# an ordinary string.",
   "arg",
   ".",
   "name",
   "=",
   "newline_indent",
   "+",
   "arg",
   ".",
   "name",
   ".",
   "lstrip",
   "(",
   "ws",
   ")",
   "arg",
   ".",
   "value",
   "=",
   "arg",
   ".",
   "value",
   ".",
   "rstrip",
   "(",
   "ws",
   ")",
   "+",
   "short_indent",
   "functions",
   "=",
   "parsed",
   ".",
   "parser_functions",
   "continue",
   "# Special formatting for the first argument",
   "arg",
   "=",
   "args",
   "[",
   "0",
   "]",
   "if",
   "arg",
   ".",
   "positional",
   ":",
   "arg",
   ".",
   "value",
   "=",
   "newline_indent",
   "+",
   "arg",
   ".",
   "value",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "+",
   "newline_indent",
   "else",
   ":",
   "arg",
   ".",
   "name",
   "=",
   "newline_indent",
   "+",
   "arg",
   ".",
   "name",
   ".",
   "lstrip",
   "(",
   "ws",
   ")",
   "arg",
   ".",
   "value",
   "=",
   "arg",
   ".",
   "value",
   ".",
   "rstrip",
   "(",
   "ws",
   ")",
   "+",
   "newline_indent",
   "# Formatting the middle arguments",
   "for",
   "arg",
   "in",
   "args",
   "[",
   "1",
   ":",
   "-",
   "1",
   "]",
   ":",
   "if",
   "arg",
   ".",
   "positional",
   ":",
   "arg",
   ".",
   "value",
   "=",
   "' '",
   "+",
   "arg",
   ".",
   "value",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "+",
   "newline_indent",
   "else",
   ":",
   "arg",
   ".",
   "name",
   "=",
   "' '",
   "+",
   "arg",
   ".",
   "name",
   ".",
   "lstrip",
   "(",
   "ws",
   ")",
   "arg",
   ".",
   "value",
   "=",
   "arg",
   ".",
   "value",
   ".",
   "rstrip",
   "(",
   "ws",
   ")",
   "+",
   "newline_indent",
   "# Special formatting for the last argument",
   "arg",
   "=",
   "args",
   "[",
   "-",
   "1",
   "]",
   "if",
   "arg",
   ".",
   "positional",
   ":",
   "arg",
   ".",
   "value",
   "=",
   "' '",
   "+",
   "arg",
   ".",
   "value",
   ".",
   "strip",
   "(",
   "ws",
   ")",
   "+",
   "short_indent",
   "else",
   ":",
   "arg",
   ".",
   "name",
   "=",
   "' '",
   "+",
   "arg",
   ".",
   "name",
   ".",
   "lstrip",
   "(",
   "ws",
   ")",
   "arg",
   ".",
   "value",
   "=",
   "arg",
   ".",
   "value",
   ".",
   "rstrip",
   "(",
   "ws",
   ")",
   "+",
   "short_indent",
   "functions",
   "=",
   "parsed",
   ".",
   "parser_functions",
   "return",
   "parsed",
   ".",
   "string"
  ]
 },
 {
  "idx": "maxmin-929",
  "nl_tokens": [
   "encoding",
   "--",
   ">",
   "str",
   ":",
   "one",
   "of",
   "ENCODINGS",
   "avoid",
   "--",
   ">",
   "list",
   "of",
   "int",
   ":",
   "to",
   "void",
   "(",
   "unprintable",
   "chars",
   "etc",
   ")",
   "Returns",
   "--",
   ">",
   "int",
   "that",
   "can",
   "be",
   "converted",
   "to",
   "requested",
   "encoding",
   "which",
   "is",
   "NOT",
   "in",
   "avoid"
  ],
  "pl_tokens": [
   "def",
   "get_rand_int",
   "(",
   "encoding",
   "=",
   "'latin1'",
   ",",
   "avoid",
   "=",
   "[",
   "]",
   ")",
   ":",
   "UNICODE_LIMIT",
   "=",
   "0x10ffff",
   "# See: https://en.wikipedia.org/wiki/UTF-8#Invalid_code_points",
   "SURROGATE_RANGE",
   "=",
   "(",
   "0xD800",
   ",",
   "0xDFFF",
   ")",
   "if",
   "encoding",
   "not",
   "in",
   "ENCODINGS",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Unsupported encoding: '",
   "+",
   "str",
   "(",
   "encoding",
   ")",
   ")",
   "if",
   "encoding",
   "==",
   "'ascii'",
   ":",
   "maxord",
   "=",
   "2",
   "**",
   "7",
   "elif",
   "encoding",
   "==",
   "'latin1'",
   ":",
   "maxord",
   "=",
   "2",
   "**",
   "8",
   "elif",
   "encoding",
   "==",
   "'utf16'",
   ":",
   "maxord",
   "=",
   "2",
   "**",
   "16",
   "elif",
   "encoding",
   "==",
   "'utf8'",
   ":",
   "maxord",
   "=",
   "2",
   "**",
   "32",
   "elif",
   "encoding",
   "==",
   "'utf32'",
   ":",
   "maxord",
   "=",
   "2",
   "**",
   "32",
   "rndint",
   "=",
   "random",
   ".",
   "randrange",
   "(",
   "0",
   ",",
   "<mask>",
   "(",
   "maxord",
   ",",
   "UNICODE_LIMIT",
   ")",
   ")",
   "while",
   "(",
   "(",
   "rndint",
   "in",
   "avoid",
   ")",
   "or",
   "(",
   "SURROGATE_RANGE",
   "[",
   "0",
   "]",
   "<=",
   "rndint",
   "<=",
   "SURROGATE_RANGE",
   "[",
   "1",
   "]",
   ")",
   ")",
   ":",
   "rndint",
   "=",
   "random",
   ".",
   "randrange",
   "(",
   "0",
   ",",
   "min",
   "(",
   "maxord",
   ",",
   "UNICODE_LIMIT",
   ")",
   ")",
   "return",
   "rndint"
  ]
 },
 {
  "idx": "maxmin-930",
  "nl_tokens": [
   "Parses",
   "arguments",
   "for",
   "the",
   "list",
   "command",
   "and",
   "returns",
   "the",
   "tuple",
   ":",
   "(",
   "filename",
   "first",
   "line",
   "number",
   "last",
   "line",
   "number",
   ")",
   "or",
   "sets",
   "these",
   "to",
   "None",
   "if",
   "there",
   "was",
   "some",
   "problem",
   "."
  ],
  "pl_tokens": [
   "def",
   "parse_addr_list_cmd",
   "(",
   "proc",
   ",",
   "args",
   ",",
   "listsize",
   "=",
   "40",
   ")",
   ":",
   "text",
   "=",
   "proc",
   ".",
   "current_command",
   "[",
   "len",
   "(",
   "args",
   "[",
   "0",
   "]",
   ")",
   "+",
   "1",
   ":",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "if",
   "text",
   "in",
   "frozenset",
   "(",
   "(",
   "''",
   ",",
   "'.'",
   ",",
   "'+'",
   ",",
   "'-'",
   ")",
   ")",
   ":",
   "if",
   "text",
   "==",
   "'.'",
   ":",
   "location",
   "=",
   "resolve_address_location",
   "(",
   "proc",
   ",",
   "'.'",
   ")",
   "return",
   "(",
   "location",
   ".",
   "path",
   ",",
   "location",
   ".",
   "line_number",
   ",",
   "True",
   ",",
   "location",
   ".",
   "line_number",
   "+",
   "listsize",
   ",",
   "True",
   ",",
   "location",
   ".",
   "method",
   ")",
   "if",
   "proc",
   ".",
   "list_offset",
   "is",
   "None",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Don't have previous list location\"",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "filename",
   "=",
   "proc",
   ".",
   "list_filename",
   "if",
   "text",
   "==",
   "'+'",
   ":",
   "first",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "proc",
   ".",
   "list_offset",
   "-",
   "1",
   ")",
   "elif",
   "text",
   "==",
   "'-'",
   ":",
   "# FIXME: not quite right for offsets",
   "if",
   "proc",
   ".",
   "list_lineno",
   "==",
   "1",
   "+",
   "listsize",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Already at start of %s.\"",
   "%",
   "proc",
   ".",
   "list_filename",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "first",
   "=",
   "max",
   "(",
   "1",
   ",",
   "proc",
   ".",
   "list_lineno",
   "-",
   "(",
   "2",
   "*",
   "listsize",
   ")",
   "-",
   "1",
   ")",
   "elif",
   "text",
   "==",
   "''",
   ":",
   "# Continue from where we last left off",
   "first",
   "=",
   "proc",
   ".",
   "list_offset",
   "+",
   "1",
   "last",
   "=",
   "first",
   "+",
   "listsize",
   "-",
   "1",
   "return",
   "filename",
   ",",
   "first",
   ",",
   "True",
   ",",
   "last",
   ",",
   "True",
   ",",
   "proc",
   ".",
   "list_object",
   "last",
   "=",
   "first",
   "+",
   "listsize",
   "-",
   "1",
   "return",
   "filename",
   ",",
   "first",
   ",",
   "True",
   ",",
   "last",
   ",",
   "True",
   ",",
   "proc",
   ".",
   "list_object",
   "else",
   ":",
   "try",
   ":",
   "list_range",
   "=",
   "build_arange",
   "(",
   "text",
   ")",
   "except",
   "LocationError",
   "as",
   "e",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Error in parsing list range at or around:\"",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text_cursor",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "except",
   "ScannerError",
   "as",
   "e",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Lexical error in parsing list range at or around:\"",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text_cursor",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "if",
   "list_range",
   ".",
   "first",
   "is",
   "None",
   ":",
   "# Last must have been given",
   "assert",
   "isinstance",
   "(",
   "list_range",
   ".",
   "last",
   ",",
   "Location",
   ")",
   "location",
   "=",
   "resolve_address_location",
   "(",
   "proc",
   ",",
   "list_range",
   ".",
   "last",
   ")",
   "if",
   "not",
   "location",
   ":",
   "return",
   "INVALID_PARSE_LIST",
   "last",
   "=",
   "location",
   ".",
   "line_number",
   "if",
   "location",
   ".",
   "is_address",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"We don't handle ending offsets\"",
   ")",
   "else",
   ":",
   "first",
   "=",
   "max",
   "(",
   "1",
   ",",
   "last",
   "-",
   "listsize",
   ")",
   "return",
   "location",
   ".",
   "path",
   ",",
   "first",
   ",",
   "False",
   ",",
   "last",
   ",",
   "False",
   ",",
   "location",
   ".",
   "method",
   "elif",
   "isinstance",
   "(",
   "list_range",
   ".",
   "first",
   ",",
   "int",
   ")",
   ":",
   "first",
   "=",
   "list_range",
   ".",
   "first",
   "location",
   "=",
   "resolve_address_location",
   "(",
   "proc",
   ",",
   "list_range",
   ".",
   "last",
   ")",
   "if",
   "not",
   "location",
   ":",
   "return",
   "INVALID_PARSE_LIST",
   "filename",
   "=",
   "location",
   ".",
   "path",
   "last",
   "=",
   "location",
   ".",
   "line_number",
   "if",
   "not",
   "location",
   ".",
   "is_address",
   "and",
   "last",
   "<",
   "first",
   ":",
   "# Treat as a count rather than an absolute location",
   "last",
   "=",
   "first",
   "+",
   "last",
   "return",
   "location",
   ".",
   "path",
   ",",
   "first",
   ",",
   "False",
   ",",
   "last",
   ",",
   "location",
   ".",
   "is_address",
   ",",
   "location",
   ".",
   "method",
   "else",
   ":",
   "# First is location. Last may be empty or a number/address",
   "assert",
   "isinstance",
   "(",
   "list_range",
   ".",
   "first",
   ",",
   "Location",
   ")",
   "location",
   "=",
   "resolve_address_location",
   "(",
   "proc",
   ",",
   "list_range",
   ".",
   "first",
   ")",
   "if",
   "not",
   "location",
   ":",
   "return",
   "INVALID_PARSE_LIST",
   "first",
   "=",
   "location",
   ".",
   "line_number",
   "first_is_addr",
   "=",
   "location",
   ".",
   "is_address",
   "last_is_addr",
   "=",
   "False",
   "last",
   "=",
   "list_range",
   ".",
   "last",
   "if",
   "isinstance",
   "(",
   "last",
   ",",
   "str",
   ")",
   ":",
   "# Is an offset +number",
   "assert",
   "last",
   "[",
   "0",
   "]",
   "in",
   "(",
   "'+'",
   ",",
   "'*'",
   ")",
   "last_is_addr",
   "=",
   "last",
   "[",
   "0",
   "]",
   "==",
   "'*'",
   "if",
   "last_is_addr",
   ":",
   "last",
   "=",
   "int",
   "(",
   "last",
   "[",
   "1",
   ":",
   "]",
   ")",
   "else",
   ":",
   "last",
   "=",
   "first",
   "+",
   "int",
   "(",
   "last",
   "[",
   "1",
   ":",
   "]",
   ")",
   "elif",
   "not",
   "last",
   ":",
   "last_is_addr",
   "=",
   "True",
   "last",
   "=",
   "first",
   "+",
   "listsize",
   "elif",
   "last",
   "<",
   "first",
   ":",
   "# Treat as a count rather than an absolute location",
   "last",
   "=",
   "first",
   "+",
   "last",
   "return",
   "location",
   ".",
   "path",
   ",",
   "first",
   ",",
   "first_is_addr",
   ",",
   "last",
   ",",
   "last_is_addr",
   ",",
   "location",
   ".",
   "method",
   "pass",
   "return"
  ]
 },
 {
  "idx": "maxmin-931",
  "nl_tokens": [
   "Add",
   "missing",
   "row",
   "to",
   "a",
   "df",
   "base",
   "on",
   "a",
   "reference",
   "column"
  ],
  "pl_tokens": [
   "def",
   "add_missing_row",
   "(",
   "df",
   ":",
   "pd",
   ".",
   "DataFrame",
   ",",
   "id_cols",
   ":",
   "List",
   "[",
   "str",
   "]",
   ",",
   "reference_col",
   ":",
   "str",
   ",",
   "complete_index",
   ":",
   "Union",
   "[",
   "Dict",
   "[",
   "str",
   ",",
   "str",
   "]",
   ",",
   "List",
   "[",
   "str",
   "]",
   "]",
   "=",
   "None",
   ",",
   "method",
   ":",
   "str",
   "=",
   "None",
   ",",
   "cols_to_keep",
   ":",
   "List",
   "[",
   "str",
   "]",
   "=",
   "None",
   ")",
   "->",
   "pd",
   ".",
   "DataFrame",
   ":",
   "if",
   "cols_to_keep",
   "is",
   "None",
   ":",
   "cols_for_index",
   "=",
   "[",
   "reference_col",
   "]",
   "else",
   ":",
   "cols_for_index",
   "=",
   "[",
   "reference_col",
   "]",
   "+",
   "cols_to_keep",
   "check_params_columns_duplicate",
   "(",
   "id_cols",
   "+",
   "cols_for_index",
   ")",
   "if",
   "method",
   "==",
   "'between'",
   "or",
   "method",
   "==",
   "'between_and_after'",
   ":",
   "df",
   "[",
   "'start'",
   "]",
   "=",
   "df",
   ".",
   "groupby",
   "(",
   "id_cols",
   ")",
   "[",
   "reference_col",
   "]",
   ".",
   "transform",
   "(",
   "<mask>",
   ")",
   "id_cols",
   "+=",
   "[",
   "'start'",
   "]",
   "if",
   "method",
   "==",
   "'between'",
   "or",
   "method",
   "==",
   "'between_and_before'",
   ":",
   "df",
   "[",
   "'end'",
   "]",
   "=",
   "df",
   ".",
   "groupby",
   "(",
   "id_cols",
   ")",
   "[",
   "reference_col",
   "]",
   ".",
   "transform",
   "(",
   "max",
   ")",
   "id_cols",
   "+=",
   "[",
   "'end'",
   "]",
   "names",
   "=",
   "id_cols",
   "+",
   "cols_for_index",
   "new_df",
   "=",
   "df",
   ".",
   "set_index",
   "(",
   "names",
   ")",
   "index_values",
   "=",
   "df",
   ".",
   "groupby",
   "(",
   "id_cols",
   ")",
   ".",
   "sum",
   "(",
   ")",
   ".",
   "index",
   ".",
   "values",
   "if",
   "complete_index",
   "is",
   "None",
   ":",
   "complete_index",
   "=",
   "df",
   ".",
   "groupby",
   "(",
   "cols_for_index",
   ")",
   ".",
   "sum",
   "(",
   ")",
   ".",
   "index",
   ".",
   "values",
   "elif",
   "isinstance",
   "(",
   "complete_index",
   ",",
   "dict",
   ")",
   ":",
   "if",
   "complete_index",
   "[",
   "'type'",
   "]",
   "==",
   "'date'",
   ":",
   "freq",
   "=",
   "complete_index",
   "[",
   "'freq'",
   "]",
   "date_format",
   "=",
   "complete_index",
   "[",
   "'format'",
   "]",
   "start",
   "=",
   "complete_index",
   "[",
   "'start'",
   "]",
   "end",
   "=",
   "complete_index",
   "[",
   "'end'",
   "]",
   "if",
   "isinstance",
   "(",
   "freq",
   ",",
   "dict",
   ")",
   ":",
   "freq",
   "=",
   "pd",
   ".",
   "DateOffset",
   "(",
   "*",
   "*",
   "{",
   "k",
   ":",
   "int",
   "(",
   "v",
   ")",
   "for",
   "k",
   ",",
   "v",
   "in",
   "freq",
   ".",
   "items",
   "(",
   ")",
   "}",
   ")",
   "complete_index",
   "=",
   "pd",
   ".",
   "date_range",
   "(",
   "start",
   "=",
   "start",
   ",",
   "end",
   "=",
   "end",
   ",",
   "freq",
   "=",
   "freq",
   ")",
   "complete_index",
   "=",
   "complete_index",
   ".",
   "strftime",
   "(",
   "date_format",
   ")",
   "else",
   ":",
   "raise",
   "ParamsValueError",
   "(",
   "f'Unknown complete index type: '",
   "f'{complete_index[\"type\"]}'",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "index_values",
   "[",
   "0",
   "]",
   ",",
   "tuple",
   ")",
   ":",
   "index_values",
   "=",
   "[",
   "(",
   "x",
   ",",
   ")",
   "for",
   "x",
   "in",
   "index_values",
   "]",
   "if",
   "not",
   "isinstance",
   "(",
   "complete_index",
   "[",
   "0",
   "]",
   ",",
   "tuple",
   ")",
   ":",
   "complete_index",
   "=",
   "[",
   "(",
   "x",
   ",",
   ")",
   "for",
   "x",
   "in",
   "complete_index",
   "]",
   "new_tuples_index",
   "=",
   "[",
   "x",
   "+",
   "y",
   "for",
   "x",
   "in",
   "index_values",
   "for",
   "y",
   "in",
   "complete_index",
   "]",
   "new_index",
   "=",
   "pd",
   ".",
   "MultiIndex",
   ".",
   "from_tuples",
   "(",
   "new_tuples_index",
   ",",
   "names",
   "=",
   "names",
   ")",
   "new_df",
   "=",
   "new_df",
   ".",
   "reindex",
   "(",
   "new_index",
   ")",
   ".",
   "reset_index",
   "(",
   ")",
   "if",
   "method",
   "==",
   "'between'",
   "or",
   "method",
   "==",
   "'between_and_after'",
   ":",
   "new_df",
   "=",
   "new_df",
   "[",
   "new_df",
   "[",
   "reference_col",
   "]",
   ">=",
   "new_df",
   "[",
   "'start'",
   "]",
   "]",
   "del",
   "new_df",
   "[",
   "'start'",
   "]",
   "if",
   "method",
   "==",
   "'between'",
   "or",
   "method",
   "==",
   "'between_and_before'",
   ":",
   "new_df",
   "=",
   "new_df",
   "[",
   "new_df",
   "[",
   "reference_col",
   "]",
   "<=",
   "new_df",
   "[",
   "'end'",
   "]",
   "]",
   "del",
   "new_df",
   "[",
   "'end'",
   "]",
   "return",
   "new_df"
  ]
 },
 {
  "idx": "maxmin-932",
  "nl_tokens": [
   "Create",
   "a",
   "plot",
   "of",
   "conv",
   "filters",
   "visualized",
   "as",
   "pixel",
   "arrays",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_filters",
   "(",
   "filters",
   ")",
   ":",
   "imgs",
   "=",
   "filters",
   ".",
   "get_value",
   "(",
   ")",
   "N",
   ",",
   "channels",
   ",",
   "x",
   ",",
   "y",
   "=",
   "imgs",
   ".",
   "shape",
   "n",
   "=",
   "int",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "N",
   ")",
   ")",
   "assert",
   "n",
   "*",
   "n",
   "==",
   "N",
   ",",
   "'filters must contain a square number of rows!'",
   "assert",
   "channels",
   "==",
   "1",
   "or",
   "channels",
   "==",
   "3",
   ",",
   "'can only plot grayscale or rgb filters!'",
   "img",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "(",
   "y",
   "+",
   "1",
   ")",
   "*",
   "n",
   "-",
   "1",
   ",",
   "(",
   "x",
   "+",
   "1",
   ")",
   "*",
   "n",
   "-",
   "1",
   ",",
   "channels",
   ")",
   ",",
   "dtype",
   "=",
   "imgs",
   "[",
   "0",
   "]",
   ".",
   "dtype",
   ")",
   "for",
   "i",
   ",",
   "pix",
   "in",
   "enumerate",
   "(",
   "imgs",
   ")",
   ":",
   "r",
   ",",
   "c",
   "=",
   "divmod",
   "(",
   "i",
   ",",
   "n",
   ")",
   "img",
   "[",
   "r",
   "*",
   "(",
   "y",
   "+",
   "1",
   ")",
   ":",
   "(",
   "r",
   "+",
   "1",
   ")",
   "*",
   "(",
   "y",
   "+",
   "1",
   ")",
   "-",
   "1",
   ",",
   "c",
   "*",
   "(",
   "x",
   "+",
   "1",
   ")",
   ":",
   "(",
   "c",
   "+",
   "1",
   ")",
   "*",
   "(",
   "x",
   "+",
   "1",
   ")",
   "-",
   "1",
   "]",
   "=",
   "pix",
   ".",
   "transpose",
   "(",
   "(",
   "1",
   ",",
   "2",
   ",",
   "0",
   ")",
   ")",
   "img",
   "-=",
   "img",
   ".",
   "<mask>",
   "(",
   ")",
   "img",
   "/=",
   "img",
   ".",
   "max",
   "(",
   ")",
   "ax",
   "=",
   "plt",
   ".",
   "gcf",
   "(",
   ")",
   ".",
   "add_subplot",
   "(",
   "111",
   ")",
   "ax",
   ".",
   "xaxis",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "set_frame_on",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "imshow",
   "(",
   "img",
   ".",
   "squeeze",
   "(",
   ")",
   ",",
   "cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "gray",
   ")"
  ]
 },
 {
  "idx": "maxmin-933",
  "nl_tokens": [
   "Convert",
   "a",
   "video",
   "to",
   "frame",
   "images"
  ],
  "pl_tokens": [
   "def",
   "cvt2frames",
   "(",
   "self",
   ",",
   "frame_dir",
   ",",
   "file_start",
   "=",
   "0",
   ",",
   "filename_tmpl",
   "=",
   "'{:06d}.jpg'",
   ",",
   "start",
   "=",
   "0",
   ",",
   "max_num",
   "=",
   "0",
   ",",
   "show_progress",
   "=",
   "True",
   ")",
   ":",
   "mkdir_or_exist",
   "(",
   "frame_dir",
   ")",
   "if",
   "max_num",
   "==",
   "0",
   ":",
   "task_num",
   "=",
   "self",
   ".",
   "frame_cnt",
   "-",
   "start",
   "else",
   ":",
   "task_num",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "frame_cnt",
   "-",
   "start",
   ",",
   "max_num",
   ")",
   "if",
   "task_num",
   "<=",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'start must be less than total frame number'",
   ")",
   "if",
   "start",
   ">",
   "0",
   ":",
   "self",
   ".",
   "_set_real_position",
   "(",
   "start",
   ")",
   "def",
   "write_frame",
   "(",
   "file_idx",
   ")",
   ":",
   "img",
   "=",
   "self",
   ".",
   "read",
   "(",
   ")",
   "filename",
   "=",
   "osp",
   ".",
   "join",
   "(",
   "frame_dir",
   ",",
   "filename_tmpl",
   ".",
   "format",
   "(",
   "file_idx",
   ")",
   ")",
   "cv2",
   ".",
   "imwrite",
   "(",
   "filename",
   ",",
   "img",
   ")",
   "if",
   "show_progress",
   ":",
   "track_progress",
   "(",
   "write_frame",
   ",",
   "range",
   "(",
   "file_start",
   ",",
   "file_start",
   "+",
   "task_num",
   ")",
   ")",
   "else",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "task_num",
   ")",
   ":",
   "img",
   "=",
   "self",
   ".",
   "read",
   "(",
   ")",
   "if",
   "img",
   "is",
   "None",
   ":",
   "break",
   "filename",
   "=",
   "osp",
   ".",
   "join",
   "(",
   "frame_dir",
   ",",
   "filename_tmpl",
   ".",
   "format",
   "(",
   "i",
   "+",
   "file_start",
   ")",
   ")",
   "cv2",
   ".",
   "imwrite",
   "(",
   "filename",
   ",",
   "img",
   ")"
  ]
 },
 {
  "idx": "maxmin-934",
  "nl_tokens": [
   "Calculate",
   "optimal",
   "info",
   "to",
   "columnize",
   "a",
   "list",
   "of",
   "string"
  ],
  "pl_tokens": [
   "def",
   "_find_optimal",
   "(",
   "rlist",
   ",",
   "separator_size",
   "=",
   "2",
   ",",
   "displaywidth",
   "=",
   "80",
   ")",
   ":",
   "for",
   "nrow",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "rlist",
   ")",
   "+",
   "1",
   ")",
   ":",
   "chk",
   "=",
   "map",
   "(",
   "<mask>",
   ",",
   "_chunks",
   "(",
   "rlist",
   ",",
   "nrow",
   ")",
   ")",
   "sumlength",
   "=",
   "sum",
   "(",
   "chk",
   ")",
   "ncols",
   "=",
   "len",
   "(",
   "chk",
   ")",
   "if",
   "sumlength",
   "+",
   "separator_size",
   "*",
   "(",
   "ncols",
   "-",
   "1",
   ")",
   "<=",
   "displaywidth",
   ":",
   "break",
   "return",
   "{",
   "'columns_numbers'",
   ":",
   "ncols",
   ",",
   "'optimal_separator_width'",
   ":",
   "(",
   "displaywidth",
   "-",
   "sumlength",
   ")",
   "/",
   "(",
   "ncols",
   "-",
   "1",
   ")",
   "if",
   "(",
   "ncols",
   "-",
   "1",
   ")",
   "else",
   "0",
   ",",
   "'rows_numbers'",
   ":",
   "nrow",
   ",",
   "'columns_width'",
   ":",
   "chk",
   "}"
  ]
 },
 {
  "idx": "maxmin-935",
  "nl_tokens": [
   "Return",
   "the",
   "effective",
   "number",
   "of",
   "CPUs",
   "in",
   "the",
   "system",
   "as",
   "an",
   "integer",
   "."
  ],
  "pl_tokens": [
   "def",
   "num_cpus",
   "(",
   ")",
   ":",
   "# Many thanks to the Parallel Python project (http://www.parallelpython.com)",
   "# for the names of the keys we needed to look up for this function.  This",
   "# code was inspired by their equivalent function.",
   "ncpufuncs",
   "=",
   "{",
   "'Linux'",
   ":",
   "_num_cpus_unix",
   ",",
   "'Darwin'",
   ":",
   "_num_cpus_darwin",
   ",",
   "'Windows'",
   ":",
   "_num_cpus_windows",
   ",",
   "# On Vista, python < 2.5.2 has a bug and returns 'Microsoft'",
   "# See http://bugs.python.org/issue1082 for details.",
   "'Microsoft'",
   ":",
   "_num_cpus_windows",
   ",",
   "}",
   "ncpufunc",
   "=",
   "ncpufuncs",
   ".",
   "get",
   "(",
   "platform",
   ".",
   "system",
   "(",
   ")",
   ",",
   "# default to unix version (Solaris, AIX, etc)",
   "_num_cpus_unix",
   ")",
   "try",
   ":",
   "ncpus",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "int",
   "(",
   "ncpufunc",
   "(",
   ")",
   ")",
   ")",
   "except",
   ":",
   "ncpus",
   "=",
   "1",
   "return",
   "ncpus"
  ]
 },
 {
  "idx": "maxmin-936",
  "nl_tokens": [
   "This",
   "function",
   "finds",
   "the",
   "date",
   "in",
   "a",
   "list",
   "closest",
   "to",
   "the",
   "target",
   "date",
   ".",
   "An",
   "optional",
   "parameter",
   "can",
   "be",
   "given",
   "to",
   "get",
   "the",
   "closest",
   "before",
   "or",
   "after",
   "."
  ],
  "pl_tokens": [
   "def",
   "_closest_date",
   "(",
   "target_dt",
   ",",
   "date_list",
   ",",
   "before_target",
   "=",
   "None",
   ")",
   ":",
   "fb",
   "=",
   "lambda",
   "d",
   ":",
   "target_dt",
   "-",
   "d",
   "if",
   "d",
   "<=",
   "target_dt",
   "else",
   "datetime",
   ".",
   "timedelta",
   ".",
   "<mask>",
   "fa",
   "=",
   "lambda",
   "d",
   ":",
   "d",
   "-",
   "target_dt",
   "if",
   "d",
   ">=",
   "target_dt",
   "else",
   "datetime",
   ".",
   "timedelta",
   ".",
   "max",
   "fnone",
   "=",
   "lambda",
   "d",
   ":",
   "target_dt",
   "-",
   "d",
   "if",
   "d",
   "<",
   "target_dt",
   "else",
   "d",
   "-",
   "target_dt",
   "if",
   "before_target",
   "is",
   "None",
   ":",
   "return",
   "min",
   "(",
   "date_list",
   ",",
   "key",
   "=",
   "fnone",
   ")",
   ".",
   "date",
   "(",
   ")",
   "if",
   "before_target",
   ":",
   "return",
   "min",
   "(",
   "date_list",
   ",",
   "key",
   "=",
   "fb",
   ")",
   ".",
   "date",
   "(",
   ")",
   "else",
   ":",
   "return",
   "min",
   "(",
   "date_list",
   ",",
   "key",
   "=",
   "fa",
   ")",
   ".",
   "date",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-937",
  "nl_tokens": [
   "Core",
   "dynamic",
   "program",
   "for",
   "beat",
   "tracking"
  ],
  "pl_tokens": [
   "def",
   "__beat_track_dp",
   "(",
   "localscore",
   ",",
   "period",
   ",",
   "tightness",
   ")",
   ":",
   "backlink",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "localscore",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   "cumscore",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "localscore",
   ")",
   "# Search range for previous beat",
   "window",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "-",
   "2",
   "*",
   "period",
   ",",
   "-",
   "np",
   ".",
   "round",
   "(",
   "period",
   "/",
   "2",
   ")",
   "+",
   "1",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   "# Make a score window, which begins biased toward start_bpm and skewed",
   "if",
   "tightness",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'tightness must be strictly positive'",
   ")",
   "txwt",
   "=",
   "-",
   "tightness",
   "*",
   "(",
   "np",
   ".",
   "log",
   "(",
   "-",
   "window",
   "/",
   "period",
   ")",
   "**",
   "2",
   ")",
   "# Are we on the first beat?",
   "first_beat",
   "=",
   "True",
   "for",
   "i",
   ",",
   "score_i",
   "in",
   "enumerate",
   "(",
   "localscore",
   ")",
   ":",
   "# Are we reaching back before time 0?",
   "z_pad",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "0",
   ",",
   "<mask>",
   "(",
   "-",
   "window",
   "[",
   "0",
   "]",
   ",",
   "len",
   "(",
   "window",
   ")",
   ")",
   ")",
   "# Search over all possible predecessors",
   "candidates",
   "=",
   "txwt",
   ".",
   "copy",
   "(",
   ")",
   "candidates",
   "[",
   "z_pad",
   ":",
   "]",
   "=",
   "candidates",
   "[",
   "z_pad",
   ":",
   "]",
   "+",
   "cumscore",
   "[",
   "window",
   "[",
   "z_pad",
   ":",
   "]",
   "]",
   "# Find the best preceding beat",
   "beat_location",
   "=",
   "np",
   ".",
   "argmax",
   "(",
   "candidates",
   ")",
   "# Add the local score",
   "cumscore",
   "[",
   "i",
   "]",
   "=",
   "score_i",
   "+",
   "candidates",
   "[",
   "beat_location",
   "]",
   "# Special case the first onset.  Stop if the localscore is small",
   "if",
   "first_beat",
   "and",
   "score_i",
   "<",
   "0.01",
   "*",
   "localscore",
   ".",
   "max",
   "(",
   ")",
   ":",
   "backlink",
   "[",
   "i",
   "]",
   "=",
   "-",
   "1",
   "else",
   ":",
   "backlink",
   "[",
   "i",
   "]",
   "=",
   "window",
   "[",
   "beat_location",
   "]",
   "first_beat",
   "=",
   "False",
   "# Update the time range",
   "window",
   "=",
   "window",
   "+",
   "1",
   "return",
   "backlink",
   ",",
   "cumscore"
  ]
 },
 {
  "idx": "maxmin-938",
  "nl_tokens": [
   "An",
   "endpoint",
   "helping",
   "check",
   "the",
   "health",
   "status",
   "of",
   "the",
   "Airflow",
   "instance",
   "including",
   "metadatabase",
   "and",
   "scheduler",
   "."
  ],
  "pl_tokens": [
   "def",
   "health",
   "(",
   "self",
   ",",
   "session",
   "=",
   "None",
   ")",
   ":",
   "BJ",
   "=",
   "jobs",
   ".",
   "BaseJob",
   "payload",
   "=",
   "{",
   "}",
   "scheduler_health_check_threshold",
   "=",
   "timedelta",
   "(",
   "seconds",
   "=",
   "conf",
   ".",
   "getint",
   "(",
   "'scheduler'",
   ",",
   "'scheduler_health_check_threshold'",
   ")",
   ")",
   "latest_scheduler_heartbeat",
   "=",
   "None",
   "payload",
   "[",
   "'metadatabase'",
   "]",
   "=",
   "{",
   "'status'",
   ":",
   "'healthy'",
   "}",
   "try",
   ":",
   "latest_scheduler_heartbeat",
   "=",
   "session",
   ".",
   "query",
   "(",
   "func",
   ".",
   "<mask>",
   "(",
   "BJ",
   ".",
   "latest_heartbeat",
   ")",
   ")",
   ".",
   "filter",
   "(",
   "BJ",
   ".",
   "state",
   "==",
   "'running'",
   ",",
   "BJ",
   ".",
   "job_type",
   "==",
   "'SchedulerJob'",
   ")",
   ".",
   "scalar",
   "(",
   ")",
   "except",
   "Exception",
   ":",
   "payload",
   "[",
   "'metadatabase'",
   "]",
   "[",
   "'status'",
   "]",
   "=",
   "'unhealthy'",
   "if",
   "not",
   "latest_scheduler_heartbeat",
   ":",
   "scheduler_status",
   "=",
   "'unhealthy'",
   "else",
   ":",
   "if",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "-",
   "latest_scheduler_heartbeat",
   "<=",
   "scheduler_health_check_threshold",
   ":",
   "scheduler_status",
   "=",
   "'healthy'",
   "else",
   ":",
   "scheduler_status",
   "=",
   "'unhealthy'",
   "payload",
   "[",
   "'scheduler'",
   "]",
   "=",
   "{",
   "'status'",
   ":",
   "scheduler_status",
   ",",
   "'latest_scheduler_heartbeat'",
   ":",
   "str",
   "(",
   "latest_scheduler_heartbeat",
   ")",
   "}",
   "return",
   "wwwutils",
   ".",
   "json_response",
   "(",
   "payload",
   ")"
  ]
 },
 {
  "idx": "maxmin-939",
  "nl_tokens": [
   "Sort",
   "clusters",
   "by",
   "the",
   "concentration",
   "of",
   "a",
   "particular",
   "analyte",
   "."
  ],
  "pl_tokens": [
   "def",
   "sort_clusters",
   "(",
   "self",
   ",",
   "data",
   ",",
   "cs",
   ",",
   "sort_by",
   ")",
   ":",
   "# label the clusters according to their contents",
   "sdat",
   "=",
   "data",
   "[",
   "sort_by",
   "]",
   "means",
   "=",
   "[",
   "]",
   "nclusts",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "cs",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "1",
   ")",
   "for",
   "c",
   "in",
   "nclusts",
   ":",
   "means",
   ".",
   "append",
   "(",
   "np",
   ".",
   "nanmean",
   "(",
   "sdat",
   "[",
   "cs",
   "==",
   "c",
   "]",
   ")",
   ")",
   "# create ranks",
   "means",
   "=",
   "np",
   ".",
   "array",
   "(",
   "means",
   ")",
   "rank",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "means",
   ".",
   "size",
   ")",
   "rank",
   "[",
   "np",
   ".",
   "argsort",
   "(",
   "means",
   ")",
   "]",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "means",
   ".",
   "size",
   ")",
   "csn",
   "=",
   "cs",
   ".",
   "copy",
   "(",
   ")",
   "for",
   "c",
   ",",
   "o",
   "in",
   "zip",
   "(",
   "nclusts",
   ",",
   "rank",
   ")",
   ":",
   "csn",
   "[",
   "cs",
   "==",
   "c",
   "]",
   "=",
   "o",
   "return",
   "csn"
  ]
 },
 {
  "idx": "maxmin-940",
  "nl_tokens": [
   "Calculate",
   "the",
   "maximum",
   "position",
   "errors",
   "from",
   "G",
   "and",
   "(",
   "V",
   "-",
   "I",
   ")",
   ".",
   "These",
   "correspond",
   "to",
   "the",
   "sky",
   "regions",
   "with",
   "the",
   "largest",
   "astrometric",
   "errors",
   "."
  ],
  "pl_tokens": [
   "def",
   "positionMaxError",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "0.0",
   ")",
   ":",
   "parallaxError",
   "=",
   "parallaxErrorSkyAvg",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   ")",
   "return",
   "_astrometricErrorFactors",
   "[",
   "'alphaStar'",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "parallaxError",
   ",",
   "_astrometricErrorFactors",
   "[",
   "'delta'",
   "]",
   ".",
   "max",
   "(",
   ")",
   "*",
   "parallaxError"
  ]
 },
 {
  "idx": "maxmin-941",
  "nl_tokens": [
   "poll",
   "for",
   "heartbeat",
   "replies",
   "until",
   "we",
   "reach",
   "self",
   ".",
   "time_to_dead",
   "Ignores",
   "interrupts",
   "and",
   "returns",
   "the",
   "result",
   "of",
   "poll",
   "()",
   "which",
   "will",
   "be",
   "an",
   "empty",
   "list",
   "if",
   "no",
   "messages",
   "arrived",
   "before",
   "the",
   "timeout",
   "or",
   "the",
   "event",
   "tuple",
   "if",
   "there",
   "is",
   "a",
   "message",
   "to",
   "receive",
   "."
  ],
  "pl_tokens": [
   "def",
   "_poll",
   "(",
   "self",
   ",",
   "start_time",
   ")",
   ":",
   "until_dead",
   "=",
   "self",
   ".",
   "time_to_dead",
   "-",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start_time",
   ")",
   "# ensure poll at least once",
   "until_dead",
   "=",
   "<mask>",
   "(",
   "until_dead",
   ",",
   "1e-3",
   ")",
   "events",
   "=",
   "[",
   "]",
   "while",
   "True",
   ":",
   "try",
   ":",
   "events",
   "=",
   "self",
   ".",
   "poller",
   ".",
   "poll",
   "(",
   "1000",
   "*",
   "until_dead",
   ")",
   "except",
   "ZMQError",
   "as",
   "e",
   ":",
   "if",
   "e",
   ".",
   "errno",
   "==",
   "errno",
   ".",
   "EINTR",
   ":",
   "# ignore interrupts during heartbeat",
   "# this may never actually happen",
   "until_dead",
   "=",
   "self",
   ".",
   "time_to_dead",
   "-",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start_time",
   ")",
   "until_dead",
   "=",
   "max",
   "(",
   "until_dead",
   ",",
   "1e-3",
   ")",
   "pass",
   "else",
   ":",
   "raise",
   "except",
   "Exception",
   ":",
   "if",
   "self",
   ".",
   "_exiting",
   ":",
   "break",
   "else",
   ":",
   "raise",
   "else",
   ":",
   "break",
   "return",
   "events"
  ]
 },
 {
  "idx": "maxmin-942",
  "nl_tokens": [
   "Returns",
   "the",
   "longest",
   "string",
   "size",
   "for",
   "a",
   "string",
   "entry",
   "across",
   "data",
   "."
  ],
  "pl_tokens": [
   "def",
   "_prm_get_longest_stringsize",
   "(",
   "string_list",
   ")",
   ":",
   "maxlength",
   "=",
   "1",
   "for",
   "stringar",
   "in",
   "string_list",
   ":",
   "if",
   "isinstance",
   "(",
   "stringar",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "if",
   "stringar",
   ".",
   "ndim",
   ">",
   "0",
   ":",
   "for",
   "string",
   "in",
   "stringar",
   ".",
   "ravel",
   "(",
   ")",
   ":",
   "maxlength",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "string",
   ")",
   ",",
   "maxlength",
   ")",
   "else",
   ":",
   "maxlength",
   "=",
   "max",
   "(",
   "len",
   "(",
   "stringar",
   ".",
   "tolist",
   "(",
   ")",
   ")",
   ",",
   "maxlength",
   ")",
   "else",
   ":",
   "maxlength",
   "=",
   "max",
   "(",
   "len",
   "(",
   "stringar",
   ")",
   ",",
   "maxlength",
   ")",
   "# Make the string Col longer than needed in order to allow later on slightly larger strings",
   "return",
   "int",
   "(",
   "maxlength",
   "*",
   "1.5",
   ")"
  ]
 },
 {
  "idx": "maxmin-943",
  "nl_tokens": [
   "Run",
   "the",
   "StochasticSwap",
   "pass",
   "on",
   "dag",
   "."
  ],
  "pl_tokens": [
   "def",
   "run",
   "(",
   "self",
   ",",
   "dag",
   ")",
   ":",
   "if",
   "self",
   ".",
   "initial_layout",
   "is",
   "None",
   ":",
   "if",
   "self",
   ".",
   "property_set",
   "[",
   "\"layout\"",
   "]",
   ":",
   "self",
   ".",
   "initial_layout",
   "=",
   "self",
   ".",
   "property_set",
   "[",
   "\"layout\"",
   "]",
   "else",
   ":",
   "self",
   ".",
   "initial_layout",
   "=",
   "Layout",
   ".",
   "generate_trivial_layout",
   "(",
   "*",
   "dag",
   ".",
   "qregs",
   ".",
   "values",
   "(",
   ")",
   ")",
   "if",
   "len",
   "(",
   "dag",
   ".",
   "qubits",
   "(",
   ")",
   ")",
   "!=",
   "len",
   "(",
   "self",
   ".",
   "initial_layout",
   ")",
   ":",
   "raise",
   "TranspilerError",
   "(",
   "'The layout does not match the amount of qubits in the DAG'",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "coupling_map",
   ".",
   "physical_qubits",
   ")",
   "!=",
   "len",
   "(",
   "self",
   ".",
   "initial_layout",
   ")",
   ":",
   "raise",
   "TranspilerError",
   "(",
   "\"Mappers require to have the layout to be the same size as the coupling map\"",
   ")",
   "self",
   ".",
   "input_layout",
   "=",
   "self",
   ".",
   "initial_layout",
   ".",
   "copy",
   "(",
   ")",
   "self",
   ".",
   "qregs",
   "=",
   "dag",
   ".",
   "qregs",
   "if",
   "self",
   ".",
   "seed",
   "is",
   "None",
   ":",
   "self",
   ".",
   "seed",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "np",
   ".",
   "iinfo",
   "(",
   "np",
   ".",
   "int32",
   ")",
   ".",
   "<mask>",
   ")",
   "self",
   ".",
   "rng",
   "=",
   "np",
   ".",
   "random",
   ".",
   "RandomState",
   "(",
   "self",
   ".",
   "seed",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"StochasticSwap RandomState seeded with seed=%s\"",
   ",",
   "self",
   ".",
   "seed",
   ")",
   "new_dag",
   "=",
   "self",
   ".",
   "_mapper",
   "(",
   "dag",
   ",",
   "self",
   ".",
   "coupling_map",
   ",",
   "trials",
   "=",
   "self",
   ".",
   "trials",
   ")",
   "# self.property_set[\"layout\"] = self.initial_layout",
   "return",
   "new_dag"
  ]
 },
 {
  "idx": "maxmin-944",
  "nl_tokens": [
   "Simultaneous",
   "backward",
   "reduction",
   "algorithm"
  ],
  "pl_tokens": [
   "def",
   "simultaneous_backward_reduction",
   "(",
   "scenarios",
   ",",
   "number_of_reduced_scenarios",
   ",",
   "probability",
   "=",
   "None",
   ")",
   ":",
   "print",
   "(",
   "\"Running simultaneous backward reduction algorithm\"",
   ")",
   "number_of_scenarios",
   "=",
   "scenarios",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "logger",
   ".",
   "debug",
   "(",
   "\"Input number of scenarios = %d\"",
   ",",
   "number_of_scenarios",
   ")",
   "# if probability is not defined assign equal probability to all scenarios",
   "if",
   "probability",
   "is",
   "None",
   ":",
   "probability",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "1",
   "/",
   "number_of_scenarios",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   "]",
   ")",
   "# initialize z, c and J",
   "z",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "inf",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   "]",
   ")",
   "c",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "number_of_scenarios",
   ",",
   "number_of_scenarios",
   ")",
   ")",
   "J",
   "=",
   "[",
   "]",
   "# no reduction necessary",
   "if",
   "number_of_reduced_scenarios",
   ">=",
   "number_of_scenarios",
   ":",
   "return",
   "(",
   "scenarios",
   ",",
   "probability",
   ",",
   "J",
   ")",
   "\"\"\"compute the distance of scenario pairs\"\"\"",
   "for",
   "scenario_k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "for",
   "scenario_j",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_j",
   "]",
   "=",
   "distance",
   "(",
   "scenarios",
   "[",
   ":",
   ",",
   "scenario_k",
   "]",
   ",",
   "scenarios",
   "[",
   ":",
   ",",
   "scenario_j",
   "]",
   ")",
   "for",
   "scenario_l",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "lowest_value",
   "=",
   "np",
   ".",
   "inf",
   "for",
   "scenario_j",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_l",
   "==",
   "scenario_j",
   ":",
   "continue",
   "lowest_value",
   "=",
   "<mask>",
   "(",
   "lowest_value",
   ",",
   "c",
   "[",
   "scenario_l",
   ",",
   "scenario_j",
   "]",
   ")",
   "c",
   "[",
   "scenario_l",
   ",",
   "scenario_l",
   "]",
   "=",
   "lowest_value",
   "z",
   "[",
   "scenario_l",
   "]",
   "=",
   "probability",
   "[",
   "scenario_l",
   "]",
   "*",
   "c",
   "[",
   "scenario_l",
   ",",
   "scenario_l",
   "]",
   "J",
   ".",
   "append",
   "(",
   "np",
   ".",
   "argmin",
   "(",
   "z",
   ")",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   "-",
   "number_of_reduced_scenarios",
   "-",
   "1",
   ")",
   ":",
   "for",
   "scenario_l",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "for",
   "scenario_k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_k",
   "in",
   "J",
   "or",
   "scenario_k",
   "==",
   "scenario_l",
   ":",
   "if",
   "scenario_l",
   "not",
   "in",
   "J",
   ":",
   "lowest_value",
   "=",
   "np",
   ".",
   "inf",
   "for",
   "scenario_j",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_j",
   "not",
   "in",
   "J",
   "and",
   "scenario_j",
   "!=",
   "scenario_l",
   ":",
   "lowest_value",
   "=",
   "min",
   "(",
   "lowest_value",
   ",",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_j",
   "]",
   ")",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_l",
   "]",
   "=",
   "lowest_value",
   "for",
   "scenario_l",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_l",
   "not",
   "in",
   "J",
   ":",
   "summation",
   "=",
   "0",
   "for",
   "scenario_k",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_k",
   "in",
   "J",
   "or",
   "scenario_k",
   "==",
   "scenario_l",
   ":",
   "summation",
   "=",
   "summation",
   "+",
   "probability",
   "[",
   "scenario_k",
   "]",
   "*",
   "c",
   "[",
   "scenario_k",
   ",",
   "scenario_l",
   "]",
   "z",
   "[",
   "scenario_l",
   "]",
   "=",
   "summation",
   "J",
   ".",
   "append",
   "(",
   "np",
   ".",
   "argmin",
   "(",
   "[",
   "item",
   "if",
   "i",
   "not",
   "in",
   "J",
   "else",
   "np",
   ".",
   "inf",
   "for",
   "i",
   ",",
   "item",
   "in",
   "enumerate",
   "(",
   "z",
   ")",
   "]",
   ")",
   ")",
   "reduced_scenario_set",
   "=",
   "[",
   "]",
   "for",
   "scenario_number",
   "in",
   "range",
   "(",
   "0",
   ",",
   "number_of_scenarios",
   ")",
   ":",
   "if",
   "scenario_number",
   "not",
   "in",
   "J",
   ":",
   "reduced_scenario_set",
   ".",
   "append",
   "(",
   "scenario_number",
   ")",
   "reduced_probability",
   "=",
   "[",
   "]",
   "reduced_probability",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "probability",
   ")",
   "for",
   "deleted_scenario_number",
   "in",
   "J",
   ":",
   "lowest_value",
   "=",
   "np",
   ".",
   "inf",
   "# find closest scenario_number",
   "for",
   "scenario_j",
   "in",
   "reduced_scenario_set",
   ":",
   "if",
   "c",
   "[",
   "deleted_scenario_number",
   ",",
   "scenario_j",
   "]",
   "<",
   "lowest_value",
   ":",
   "closest_scenario_number",
   "=",
   "scenario_j",
   "lowest_value",
   "=",
   "c",
   "[",
   "deleted_scenario_number",
   ",",
   "scenario_j",
   "]",
   "reduced_probability",
   "[",
   "closest_scenario_number",
   "]",
   "=",
   "reduced_probability",
   "[",
   "closest_scenario_number",
   "]",
   "+",
   "reduced_probability",
   "[",
   "deleted_scenario_number",
   "]",
   "reduced_scenarios",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "scenarios",
   "[",
   ":",
   ",",
   "reduced_scenario_set",
   "]",
   ")",
   "reduced_probability",
   "=",
   "reduced_probability",
   "[",
   "reduced_scenario_set",
   "]",
   "return",
   "(",
   "reduced_scenarios",
   ",",
   "reduced_probability",
   ",",
   "reduced_scenario_set",
   ")"
  ]
 },
 {
  "idx": "maxmin-945",
  "nl_tokens": [
   "find",
   "similarities",
   "in",
   "the",
   "two",
   "given",
   "linesets"
  ],
  "pl_tokens": [
   "def",
   "_find_common",
   "(",
   "self",
   ",",
   "lineset1",
   ",",
   "lineset2",
   ")",
   ":",
   "lines1",
   "=",
   "lineset1",
   ".",
   "enumerate_stripped",
   "lines2",
   "=",
   "lineset2",
   ".",
   "enumerate_stripped",
   "find",
   "=",
   "lineset2",
   ".",
   "find",
   "index1",
   "=",
   "0",
   "min_lines",
   "=",
   "self",
   ".",
   "min_lines",
   "while",
   "index1",
   "<",
   "len",
   "(",
   "lineset1",
   ")",
   ":",
   "skip",
   "=",
   "1",
   "num",
   "=",
   "0",
   "for",
   "index2",
   "in",
   "find",
   "(",
   "lineset1",
   "[",
   "index1",
   "]",
   ")",
   ":",
   "non_blank",
   "=",
   "0",
   "for",
   "num",
   ",",
   "(",
   "(",
   "_",
   ",",
   "line1",
   ")",
   ",",
   "(",
   "_",
   ",",
   "line2",
   ")",
   ")",
   "in",
   "enumerate",
   "(",
   "zip",
   "(",
   "lines1",
   "(",
   "index1",
   ")",
   ",",
   "lines2",
   "(",
   "index2",
   ")",
   ")",
   ")",
   ":",
   "if",
   "line1",
   "!=",
   "line2",
   ":",
   "if",
   "non_blank",
   ">",
   "min_lines",
   ":",
   "yield",
   "num",
   ",",
   "lineset1",
   ",",
   "index1",
   ",",
   "lineset2",
   ",",
   "index2",
   "skip",
   "=",
   "<mask>",
   "(",
   "skip",
   ",",
   "num",
   ")",
   "break",
   "if",
   "line1",
   ":",
   "non_blank",
   "+=",
   "1",
   "else",
   ":",
   "# we may have reach the end",
   "num",
   "+=",
   "1",
   "if",
   "non_blank",
   ">",
   "min_lines",
   ":",
   "yield",
   "num",
   ",",
   "lineset1",
   ",",
   "index1",
   ",",
   "lineset2",
   ",",
   "index2",
   "skip",
   "=",
   "max",
   "(",
   "skip",
   ",",
   "num",
   ")",
   "index1",
   "+=",
   "skip"
  ]
 },
 {
  "idx": "maxmin-946",
  "nl_tokens": [
   "Determine",
   "the",
   "most",
   "appropriate",
   "time",
   "unit",
   "for",
   "an",
   "array",
   "of",
   "time",
   "durations",
   "specified",
   "in",
   "seconds",
   ".",
   "e",
   ".",
   "g",
   ".",
   "5400",
   "seconds",
   "=",
   ">",
   "minutes",
   "36000",
   "seconds",
   "=",
   ">",
   "hours"
  ],
  "pl_tokens": [
   "def",
   "infer_time_unit",
   "(",
   "time_seconds_arr",
   ")",
   ":",
   "if",
   "len",
   "(",
   "time_seconds_arr",
   ")",
   "==",
   "0",
   ":",
   "return",
   "'hours'",
   "max_time_seconds",
   "=",
   "<mask>",
   "(",
   "time_seconds_arr",
   ")",
   "if",
   "max_time_seconds",
   "<=",
   "60",
   "*",
   "2",
   ":",
   "return",
   "'seconds'",
   "elif",
   "max_time_seconds",
   "<=",
   "60",
   "*",
   "60",
   "*",
   "2",
   ":",
   "return",
   "'minutes'",
   "elif",
   "max_time_seconds",
   "<=",
   "24",
   "*",
   "60",
   "*",
   "60",
   "*",
   "2",
   ":",
   "return",
   "'hours'",
   "else",
   ":",
   "return",
   "'days'"
  ]
 },
 {
  "idx": "maxmin-947",
  "nl_tokens": [
   "Plot",
   "an",
   "array",
   "of",
   "images",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_images",
   "(",
   "imgs",
   ",",
   "loc",
   ",",
   "title",
   "=",
   "None",
   ",",
   "channels",
   "=",
   "1",
   ")",
   ":",
   "n",
   "=",
   "int",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "len",
   "(",
   "imgs",
   ")",
   ")",
   ")",
   "assert",
   "n",
   "*",
   "n",
   "==",
   "len",
   "(",
   "imgs",
   ")",
   ",",
   "'images array must contain a square number of rows!'",
   "s",
   "=",
   "int",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "len",
   "(",
   "imgs",
   "[",
   "0",
   "]",
   ")",
   "/",
   "channels",
   ")",
   ")",
   "assert",
   "s",
   "*",
   "s",
   "==",
   "len",
   "(",
   "imgs",
   "[",
   "0",
   "]",
   ")",
   "/",
   "channels",
   ",",
   "'images must be square!'",
   "img",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "(",
   "s",
   "+",
   "1",
   ")",
   "*",
   "n",
   "-",
   "1",
   ",",
   "(",
   "s",
   "+",
   "1",
   ")",
   "*",
   "n",
   "-",
   "1",
   ",",
   "channels",
   ")",
   ",",
   "dtype",
   "=",
   "imgs",
   "[",
   "0",
   "]",
   ".",
   "dtype",
   ")",
   "for",
   "i",
   ",",
   "pix",
   "in",
   "enumerate",
   "(",
   "imgs",
   ")",
   ":",
   "r",
   ",",
   "c",
   "=",
   "divmod",
   "(",
   "i",
   ",",
   "n",
   ")",
   "img",
   "[",
   "r",
   "*",
   "(",
   "s",
   "+",
   "1",
   ")",
   ":",
   "(",
   "r",
   "+",
   "1",
   ")",
   "*",
   "(",
   "s",
   "+",
   "1",
   ")",
   "-",
   "1",
   ",",
   "c",
   "*",
   "(",
   "s",
   "+",
   "1",
   ")",
   ":",
   "(",
   "c",
   "+",
   "1",
   ")",
   "*",
   "(",
   "s",
   "+",
   "1",
   ")",
   "-",
   "1",
   "]",
   "=",
   "pix",
   ".",
   "reshape",
   "(",
   "(",
   "s",
   ",",
   "s",
   ",",
   "channels",
   ")",
   ")",
   "img",
   "-=",
   "img",
   ".",
   "<mask>",
   "(",
   ")",
   "img",
   "/=",
   "img",
   ".",
   "max",
   "(",
   ")",
   "ax",
   "=",
   "plt",
   ".",
   "gcf",
   "(",
   ")",
   ".",
   "add_subplot",
   "(",
   "loc",
   ")",
   "ax",
   ".",
   "xaxis",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "set_frame_on",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "imshow",
   "(",
   "img",
   ".",
   "squeeze",
   "(",
   ")",
   ",",
   "cmap",
   "=",
   "plt",
   ".",
   "cm",
   ".",
   "gray",
   ")",
   "if",
   "title",
   ":",
   "ax",
   ".",
   "set_title",
   "(",
   "title",
   ")"
  ]
 },
 {
  "idx": "maxmin-948",
  "nl_tokens": [
   "Transform",
   "a",
   "list",
   "of",
   "strings",
   "into",
   "a",
   "single",
   "string",
   "with",
   "columns",
   "."
  ],
  "pl_tokens": [
   "def",
   "_format_as_columns",
   "(",
   "self",
   ",",
   "items",
   ",",
   "separator",
   "=",
   "'  '",
   ")",
   ":",
   "# Calculate the number of characters available.",
   "width",
   "=",
   "self",
   ".",
   "_control",
   ".",
   "viewport",
   "(",
   ")",
   ".",
   "width",
   "(",
   ")",
   "char_width",
   "=",
   "QtGui",
   ".",
   "QFontMetrics",
   "(",
   "self",
   ".",
   "font",
   ")",
   ".",
   "width",
   "(",
   "' '",
   ")",
   "displaywidth",
   "=",
   "<mask>",
   "(",
   "10",
   ",",
   "(",
   "width",
   "/",
   "char_width",
   ")",
   "-",
   "1",
   ")",
   "return",
   "columnize",
   "(",
   "items",
   ",",
   "separator",
   ",",
   "displaywidth",
   ")"
  ]
 },
 {
  "idx": "maxmin-949",
  "nl_tokens": [
   "Find",
   "a",
   "swap",
   "circuit",
   "that",
   "implements",
   "a",
   "permutation",
   "for",
   "this",
   "layer",
   "."
  ],
  "pl_tokens": [
   "def",
   "layer_permutation",
   "(",
   "self",
   ",",
   "layer_partition",
   ",",
   "layout",
   ",",
   "qubit_subset",
   ")",
   ":",
   "if",
   "self",
   ".",
   "seed",
   "is",
   "None",
   ":",
   "self",
   ".",
   "seed",
   "=",
   "np",
   ".",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "np",
   ".",
   "iinfo",
   "(",
   "np",
   ".",
   "int32",
   ")",
   ".",
   "<mask>",
   ")",
   "rng",
   "=",
   "np",
   ".",
   "random",
   ".",
   "RandomState",
   "(",
   "self",
   ".",
   "seed",
   ")",
   "rev_layout",
   "=",
   "{",
   "b",
   ":",
   "a",
   "for",
   "a",
   ",",
   "b",
   "in",
   "layout",
   ".",
   "items",
   "(",
   ")",
   "}",
   "gates",
   "=",
   "[",
   "]",
   "for",
   "layer",
   "in",
   "layer_partition",
   ":",
   "if",
   "len",
   "(",
   "layer",
   ")",
   ">",
   "2",
   ":",
   "raise",
   "TranspilerError",
   "(",
   "\"Layer contains >2 qubit gates\"",
   ")",
   "elif",
   "len",
   "(",
   "layer",
   ")",
   "==",
   "2",
   ":",
   "gates",
   ".",
   "append",
   "(",
   "tuple",
   "(",
   "layer",
   ")",
   ")",
   "# Can we already apply the gates?",
   "dist",
   "=",
   "sum",
   "(",
   "[",
   "self",
   ".",
   "coupling_map",
   ".",
   "distance",
   "(",
   "layout",
   "[",
   "g",
   "[",
   "0",
   "]",
   "]",
   "[",
   "1",
   "]",
   ",",
   "layout",
   "[",
   "g",
   "[",
   "1",
   "]",
   "]",
   "[",
   "1",
   "]",
   ")",
   "for",
   "g",
   "in",
   "gates",
   "]",
   ")",
   "if",
   "dist",
   "==",
   "len",
   "(",
   "gates",
   ")",
   ":",
   "circ",
   "=",
   "DAGCircuit",
   "(",
   ")",
   "circ",
   ".",
   "add_qreg",
   "(",
   "QuantumRegister",
   "(",
   "self",
   ".",
   "coupling_map",
   ".",
   "size",
   "(",
   ")",
   ",",
   "\"q\"",
   ")",
   ")",
   "return",
   "True",
   ",",
   "circ",
   ",",
   "0",
   ",",
   "layout",
   ",",
   "bool",
   "(",
   "gates",
   ")",
   "# Begin loop over trials of randomized algorithm",
   "n",
   "=",
   "self",
   ".",
   "coupling_map",
   ".",
   "size",
   "(",
   ")",
   "best_d",
   "=",
   "sys",
   ".",
   "maxsize",
   "# initialize best depth",
   "best_circ",
   "=",
   "None",
   "# initialize best swap circuit",
   "best_layout",
   "=",
   "None",
   "# initialize best final layout",
   "QR",
   "=",
   "QuantumRegister",
   "(",
   "self",
   ".",
   "coupling_map",
   ".",
   "size",
   "(",
   ")",
   ",",
   "\"q\"",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "self",
   ".",
   "trials",
   ")",
   ":",
   "trial_layout",
   "=",
   "layout",
   ".",
   "copy",
   "(",
   ")",
   "rev_trial_layout",
   "=",
   "rev_layout",
   ".",
   "copy",
   "(",
   ")",
   "# SWAP circuit constructed this trial",
   "trial_circ",
   "=",
   "DAGCircuit",
   "(",
   ")",
   "trial_circ",
   ".",
   "add_qreg",
   "(",
   "QR",
   ")",
   "# Compute Sergey's randomized distance",
   "xi",
   "=",
   "{",
   "}",
   "for",
   "i",
   "in",
   "self",
   ".",
   "coupling_map",
   ".",
   "physical_qubits",
   ":",
   "xi",
   "[",
   "(",
   "QR",
   ",",
   "i",
   ")",
   "]",
   "=",
   "{",
   "}",
   "for",
   "i",
   "in",
   "self",
   ".",
   "coupling_map",
   ".",
   "physical_qubits",
   ":",
   "i",
   "=",
   "(",
   "QR",
   ",",
   "i",
   ")",
   "for",
   "j",
   "in",
   "self",
   ".",
   "coupling_map",
   ".",
   "physical_qubits",
   ":",
   "j",
   "=",
   "(",
   "QR",
   ",",
   "j",
   ")",
   "scale",
   "=",
   "1",
   "+",
   "rng",
   ".",
   "normal",
   "(",
   "0",
   ",",
   "1",
   "/",
   "n",
   ")",
   "xi",
   "[",
   "i",
   "]",
   "[",
   "j",
   "]",
   "=",
   "scale",
   "*",
   "self",
   ".",
   "coupling_map",
   ".",
   "distance",
   "(",
   "i",
   "[",
   "1",
   "]",
   ",",
   "j",
   "[",
   "1",
   "]",
   ")",
   "**",
   "2",
   "xi",
   "[",
   "j",
   "]",
   "[",
   "i",
   "]",
   "=",
   "xi",
   "[",
   "i",
   "]",
   "[",
   "j",
   "]",
   "# Loop over depths d up to a max depth of 2n+1",
   "d",
   "=",
   "1",
   "# Circuit for this swap slice",
   "circ",
   "=",
   "DAGCircuit",
   "(",
   ")",
   "circ",
   ".",
   "add_qreg",
   "(",
   "QR",
   ")",
   "# Identity wire-map for composing the circuits",
   "identity_wire_map",
   "=",
   "{",
   "(",
   "QR",
   ",",
   "j",
   ")",
   ":",
   "(",
   "QR",
   ",",
   "j",
   ")",
   "for",
   "j",
   "in",
   "range",
   "(",
   "n",
   ")",
   "}",
   "while",
   "d",
   "<",
   "2",
   "*",
   "n",
   "+",
   "1",
   ":",
   "# Set of available qubits",
   "qubit_set",
   "=",
   "set",
   "(",
   "qubit_subset",
   ")",
   "# While there are still qubits available",
   "while",
   "qubit_set",
   ":",
   "# Compute the objective function",
   "min_cost",
   "=",
   "sum",
   "(",
   "[",
   "xi",
   "[",
   "trial_layout",
   "[",
   "g",
   "[",
   "0",
   "]",
   "]",
   "]",
   "[",
   "trial_layout",
   "[",
   "g",
   "[",
   "1",
   "]",
   "]",
   "]",
   "for",
   "g",
   "in",
   "gates",
   "]",
   ")",
   "# Try to decrease objective function",
   "progress_made",
   "=",
   "False",
   "# Loop over edges of coupling graph",
   "for",
   "e",
   "in",
   "self",
   ".",
   "coupling_map",
   ".",
   "get_edges",
   "(",
   ")",
   ":",
   "e",
   "=",
   "[",
   "(",
   "QR",
   ",",
   "edge",
   ")",
   "for",
   "edge",
   "in",
   "e",
   "]",
   "# Are the qubits available?",
   "if",
   "e",
   "[",
   "0",
   "]",
   "in",
   "qubit_set",
   "and",
   "e",
   "[",
   "1",
   "]",
   "in",
   "qubit_set",
   ":",
   "# Try this edge to reduce the cost",
   "new_layout",
   "=",
   "trial_layout",
   ".",
   "copy",
   "(",
   ")",
   "new_layout",
   "[",
   "rev_trial_layout",
   "[",
   "e",
   "[",
   "0",
   "]",
   "]",
   "]",
   "=",
   "e",
   "[",
   "1",
   "]",
   "new_layout",
   "[",
   "rev_trial_layout",
   "[",
   "e",
   "[",
   "1",
   "]",
   "]",
   "]",
   "=",
   "e",
   "[",
   "0",
   "]",
   "rev_new_layout",
   "=",
   "rev_trial_layout",
   ".",
   "copy",
   "(",
   ")",
   "rev_new_layout",
   "[",
   "e",
   "[",
   "0",
   "]",
   "]",
   "=",
   "rev_trial_layout",
   "[",
   "e",
   "[",
   "1",
   "]",
   "]",
   "rev_new_layout",
   "[",
   "e",
   "[",
   "1",
   "]",
   "]",
   "=",
   "rev_trial_layout",
   "[",
   "e",
   "[",
   "0",
   "]",
   "]",
   "# Compute the objective function",
   "new_cost",
   "=",
   "sum",
   "(",
   "[",
   "xi",
   "[",
   "new_layout",
   "[",
   "g",
   "[",
   "0",
   "]",
   "]",
   "]",
   "[",
   "new_layout",
   "[",
   "g",
   "[",
   "1",
   "]",
   "]",
   "]",
   "for",
   "g",
   "in",
   "gates",
   "]",
   ")",
   "# Record progress if we succceed",
   "if",
   "new_cost",
   "<",
   "min_cost",
   ":",
   "progress_made",
   "=",
   "True",
   "min_cost",
   "=",
   "new_cost",
   "opt_layout",
   "=",
   "new_layout",
   "rev_opt_layout",
   "=",
   "rev_new_layout",
   "opt_edge",
   "=",
   "e",
   "# Were there any good choices?",
   "if",
   "progress_made",
   ":",
   "qubit_set",
   ".",
   "remove",
   "(",
   "opt_edge",
   "[",
   "0",
   "]",
   ")",
   "qubit_set",
   ".",
   "remove",
   "(",
   "opt_edge",
   "[",
   "1",
   "]",
   ")",
   "trial_layout",
   "=",
   "opt_layout",
   "rev_trial_layout",
   "=",
   "rev_opt_layout",
   "circ",
   ".",
   "apply_operation_back",
   "(",
   "SwapGate",
   "(",
   ")",
   ",",
   "[",
   "(",
   "opt_edge",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ",",
   "opt_edge",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   ")",
   ",",
   "(",
   "opt_edge",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ",",
   "opt_edge",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   ")",
   "]",
   ",",
   "[",
   "]",
   ")",
   "else",
   ":",
   "break",
   "# We have either run out of qubits or failed to improve",
   "# Compute the coupling graph distance_qubits",
   "dist",
   "=",
   "sum",
   "(",
   "[",
   "self",
   ".",
   "coupling_map",
   ".",
   "distance",
   "(",
   "trial_layout",
   "[",
   "g",
   "[",
   "0",
   "]",
   "]",
   "[",
   "1",
   "]",
   ",",
   "trial_layout",
   "[",
   "g",
   "[",
   "1",
   "]",
   "]",
   "[",
   "1",
   "]",
   ")",
   "for",
   "g",
   "in",
   "gates",
   "]",
   ")",
   "# If all gates can be applied now, we are finished",
   "# Otherwise we need to consider a deeper swap circuit",
   "if",
   "dist",
   "==",
   "len",
   "(",
   "gates",
   ")",
   ":",
   "trial_circ",
   ".",
   "compose_back",
   "(",
   "circ",
   ",",
   "identity_wire_map",
   ")",
   "break",
   "# Increment the depth",
   "d",
   "+=",
   "1",
   "# Either we have succeeded at some depth d < dmax or failed",
   "dist",
   "=",
   "sum",
   "(",
   "[",
   "self",
   ".",
   "coupling_map",
   ".",
   "distance",
   "(",
   "trial_layout",
   "[",
   "g",
   "[",
   "0",
   "]",
   "]",
   "[",
   "1",
   "]",
   ",",
   "trial_layout",
   "[",
   "g",
   "[",
   "1",
   "]",
   "]",
   "[",
   "1",
   "]",
   ")",
   "for",
   "g",
   "in",
   "gates",
   "]",
   ")",
   "if",
   "dist",
   "==",
   "len",
   "(",
   "gates",
   ")",
   ":",
   "if",
   "d",
   "<",
   "best_d",
   ":",
   "best_circ",
   "=",
   "trial_circ",
   "best_layout",
   "=",
   "trial_layout",
   "best_d",
   "=",
   "min",
   "(",
   "best_d",
   ",",
   "d",
   ")",
   "if",
   "best_circ",
   "is",
   "None",
   ":",
   "return",
   "False",
   ",",
   "None",
   ",",
   "None",
   ",",
   "None",
   ",",
   "False",
   "return",
   "True",
   ",",
   "best_circ",
   ",",
   "best_d",
   ",",
   "best_layout",
   ",",
   "False"
  ]
 },
 {
  "idx": "maxmin-950",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "arc",
   "cosine",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "acos",
   "(",
   "wave",
   ")",
   ":",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "ValueError",
   ",",
   "\"Math domain error\"",
   ",",
   "bool",
   "(",
   "(",
   "<mask>",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   "<",
   "-",
   "1",
   ")",
   "or",
   "(",
   "max",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   ">",
   "1",
   ")",
   ")",
   ",",
   ")",
   "return",
   "_operation",
   "(",
   "wave",
   ",",
   "\"acos\"",
   ",",
   "\"rad\"",
   ",",
   "np",
   ".",
   "arccos",
   ")"
  ]
 },
 {
  "idx": "maxmin-951",
  "nl_tokens": [
   "if",
   "branch_length",
   "mode",
   "is",
   "not",
   "explicitly",
   "set",
   "set",
   "according",
   "to",
   "empirical",
   "branch",
   "length",
   "distribution",
   "in",
   "input",
   "tree"
  ],
  "pl_tokens": [
   "def",
   "_set_branch_length_mode",
   "(",
   "self",
   ",",
   "branch_length_mode",
   ")",
   ":",
   "if",
   "branch_length_mode",
   "in",
   "[",
   "'joint'",
   ",",
   "'marginal'",
   ",",
   "'input'",
   "]",
   ":",
   "self",
   ".",
   "branch_length_mode",
   "=",
   "branch_length_mode",
   "elif",
   "self",
   ".",
   "aln",
   ":",
   "bl_dis",
   "=",
   "[",
   "n",
   ".",
   "branch_length",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   "if",
   "n",
   ".",
   "up",
   "]",
   "max_bl",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "bl_dis",
   ")",
   "if",
   "max_bl",
   ">",
   "0.1",
   ":",
   "bl_mode",
   "=",
   "'input'",
   "else",
   ":",
   "bl_mode",
   "=",
   "'joint'",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeTime._set_branch_length_mode: maximum branch length is %1.3e, using branch length mode %s\"",
   "%",
   "(",
   "max_bl",
   ",",
   "bl_mode",
   ")",
   ",",
   "1",
   ")",
   "self",
   ".",
   "branch_length_mode",
   "=",
   "bl_mode",
   "else",
   ":",
   "self",
   ".",
   "branch_length_mode",
   "=",
   "'input'"
  ]
 },
 {
  "idx": "maxmin-952",
  "nl_tokens": [
   "Overrideable",
   "function",
   "that",
   "generates",
   "the",
   "colors",
   "to",
   "be",
   "used",
   "by",
   "various",
   "borderstyles",
   ".",
   "Should",
   "return",
   "a",
   "5",
   "-",
   "tuple",
   "of",
   "(",
   "bg",
   "o",
   "i",
   "s",
   "h",
   ")",
   "\\",
   ".",
   "bg",
   "is",
   "the",
   "base",
   "color",
   "of",
   "the",
   "background",
   ".",
   "o",
   "is",
   "the",
   "outer",
   "color",
   "it",
   "is",
   "usually",
   "the",
   "same",
   "as",
   "the",
   "background",
   "color",
   ".",
   "i",
   "is",
   "the",
   "inner",
   "color",
   "it",
   "is",
   "usually",
   "lighter",
   "than",
   "the",
   "background",
   "color",
   ".",
   "s",
   "is",
   "the",
   "shadow",
   "color",
   "it",
   "is",
   "usually",
   "quite",
   "a",
   "bit",
   "darker",
   "than",
   "the",
   "background",
   ".",
   "h",
   "is",
   "the",
   "highlight",
   "color",
   "it",
   "is",
   "usually",
   "quite",
   "a",
   "bit",
   "lighter",
   "than",
   "the",
   "background",
   "."
  ],
  "pl_tokens": [
   "def",
   "getColors",
   "(",
   "self",
   ")",
   ":",
   "bg",
   "=",
   "self",
   ".",
   "submenu",
   ".",
   "bg",
   "[",
   ":",
   "3",
   "]",
   "if",
   "isinstance",
   "(",
   "self",
   ".",
   "submenu",
   ".",
   "bg",
   ",",
   "list",
   ")",
   "or",
   "isinstance",
   "(",
   "self",
   ".",
   "submenu",
   ".",
   "bg",
   ",",
   "tuple",
   ")",
   "else",
   "[",
   "242",
   ",",
   "241",
   ",",
   "240",
   "]",
   "o",
   ",",
   "i",
   "=",
   "bg",
   ",",
   "[",
   "<mask>",
   "(",
   "bg",
   "[",
   "0",
   "]",
   "+",
   "8",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "1",
   "]",
   "+",
   "8",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "2",
   "]",
   "+",
   "8",
   ",",
   "255",
   ")",
   "]",
   "s",
   ",",
   "h",
   "=",
   "[",
   "max",
   "(",
   "bg",
   "[",
   "0",
   "]",
   "-",
   "40",
   ",",
   "0",
   ")",
   ",",
   "max",
   "(",
   "bg",
   "[",
   "1",
   "]",
   "-",
   "40",
   ",",
   "0",
   ")",
   ",",
   "max",
   "(",
   "bg",
   "[",
   "2",
   "]",
   "-",
   "40",
   ",",
   "0",
   ")",
   "]",
   ",",
   "[",
   "min",
   "(",
   "bg",
   "[",
   "0",
   "]",
   "+",
   "12",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "1",
   "]",
   "+",
   "12",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "2",
   "]",
   "+",
   "12",
   ",",
   "255",
   ")",
   "]",
   "# Outer,Inner,Shadow,Highlight",
   "return",
   "bg",
   ",",
   "o",
   ",",
   "i",
   ",",
   "s",
   ",",
   "h"
  ]
 },
 {
  "idx": "maxmin-953",
  "nl_tokens": [
   "Plots",
   "all",
   "the",
   "labels",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_labels",
   "(",
   "all_labels",
   ",",
   "gt_times",
   ",",
   "est_file",
   ",",
   "algo_ids",
   "=",
   "None",
   ",",
   "title",
   "=",
   "None",
   ",",
   "output_file",
   "=",
   "None",
   ")",
   ":",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "N",
   "=",
   "len",
   "(",
   "all_labels",
   ")",
   "# Number of lists of labels",
   "if",
   "algo_ids",
   "is",
   "None",
   ":",
   "algo_ids",
   "=",
   "io",
   ".",
   "get_algo_ids",
   "(",
   "est_file",
   ")",
   "# Translate ids",
   "for",
   "i",
   ",",
   "algo_id",
   "in",
   "enumerate",
   "(",
   "algo_ids",
   ")",
   ":",
   "algo_ids",
   "[",
   "i",
   "]",
   "=",
   "translate_ids",
   "[",
   "algo_id",
   "]",
   "algo_ids",
   "=",
   "[",
   "\"GT\"",
   "]",
   "+",
   "algo_ids",
   "# Index the labels to normalize them",
   "for",
   "i",
   ",",
   "labels",
   "in",
   "enumerate",
   "(",
   "all_labels",
   ")",
   ":",
   "all_labels",
   "[",
   "i",
   "]",
   "=",
   "mir_eval",
   ".",
   "util",
   ".",
   "index_labels",
   "(",
   "labels",
   ")",
   "[",
   "0",
   "]",
   "# Get color map",
   "cm",
   "=",
   "plt",
   ".",
   "get_cmap",
   "(",
   "'gist_rainbow'",
   ")",
   "max_label",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "labels",
   ")",
   "for",
   "labels",
   "in",
   "all_labels",
   ")",
   "# To intervals",
   "gt_inters",
   "=",
   "utils",
   ".",
   "times_to_intervals",
   "(",
   "gt_times",
   ")",
   "# Plot labels",
   "figsize",
   "=",
   "(",
   "6",
   ",",
   "4",
   ")",
   "plt",
   ".",
   "figure",
   "(",
   "1",
   ",",
   "figsize",
   "=",
   "figsize",
   ",",
   "dpi",
   "=",
   "120",
   ",",
   "facecolor",
   "=",
   "'w'",
   ",",
   "edgecolor",
   "=",
   "'k'",
   ")",
   "for",
   "i",
   ",",
   "labels",
   "in",
   "enumerate",
   "(",
   "all_labels",
   ")",
   ":",
   "for",
   "label",
   ",",
   "inter",
   "in",
   "zip",
   "(",
   "labels",
   ",",
   "gt_inters",
   ")",
   ":",
   "plt",
   ".",
   "axvspan",
   "(",
   "inter",
   "[",
   "0",
   "]",
   ",",
   "inter",
   "[",
   "1",
   "]",
   ",",
   "ymin",
   "=",
   "i",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "ymax",
   "=",
   "(",
   "i",
   "+",
   "1",
   ")",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "alpha",
   "=",
   "0.6",
   ",",
   "color",
   "=",
   "cm",
   "(",
   "label",
   "/",
   "float",
   "(",
   "max_label",
   ")",
   ")",
   ")",
   "plt",
   ".",
   "axhline",
   "(",
   "i",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "color",
   "=",
   "\"k\"",
   ",",
   "linewidth",
   "=",
   "1",
   ")",
   "# Draw the boundary lines",
   "for",
   "bound",
   "in",
   "gt_times",
   ":",
   "plt",
   ".",
   "axvline",
   "(",
   "bound",
   ",",
   "color",
   "=",
   "\"g\"",
   ")",
   "# Format plot",
   "_plot_formatting",
   "(",
   "title",
   ",",
   "est_file",
   ",",
   "algo_ids",
   ",",
   "gt_times",
   "[",
   "-",
   "1",
   "]",
   ",",
   "N",
   ",",
   "output_file",
   ")"
  ]
 },
 {
  "idx": "maxmin-954",
  "nl_tokens": [
   "Make",
   "a",
   "RST",
   "-",
   "compatible",
   "table"
  ],
  "pl_tokens": [
   "def",
   "make_table",
   "(",
   "grid",
   ")",
   ":",
   "cell_width",
   "=",
   "2",
   "+",
   "<mask>",
   "(",
   "reduce",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "x",
   "+",
   "y",
   ",",
   "[",
   "[",
   "len",
   "(",
   "item",
   ")",
   "for",
   "item",
   "in",
   "row",
   "]",
   "for",
   "row",
   "in",
   "grid",
   "]",
   ",",
   "[",
   "]",
   ")",
   ")",
   "num_cols",
   "=",
   "len",
   "(",
   "grid",
   "[",
   "0",
   "]",
   ")",
   "rst",
   "=",
   "table_div",
   "(",
   "num_cols",
   ",",
   "cell_width",
   ",",
   "0",
   ")",
   "header_flag",
   "=",
   "1",
   "for",
   "row",
   "in",
   "grid",
   ":",
   "rst",
   "=",
   "rst",
   "+",
   "'| '",
   "+",
   "'| '",
   ".",
   "join",
   "(",
   "[",
   "normalize_cell",
   "(",
   "x",
   ",",
   "cell_width",
   "-",
   "1",
   ")",
   "for",
   "x",
   "in",
   "row",
   "]",
   ")",
   "+",
   "'|\\n'",
   "rst",
   "=",
   "rst",
   "+",
   "table_div",
   "(",
   "num_cols",
   ",",
   "cell_width",
   ",",
   "header_flag",
   ")",
   "header_flag",
   "=",
   "0",
   "return",
   "rst"
  ]
 },
 {
  "idx": "maxmin-955",
  "nl_tokens": [
   "Normalize",
   "an",
   "array",
   "along",
   "a",
   "chosen",
   "axis",
   "."
  ],
  "pl_tokens": [
   "def",
   "normalize",
   "(",
   "S",
   ",",
   "norm",
   "=",
   "np",
   ".",
   "inf",
   ",",
   "axis",
   "=",
   "0",
   ",",
   "threshold",
   "=",
   "None",
   ",",
   "fill",
   "=",
   "None",
   ")",
   ":",
   "# Avoid div-by-zero",
   "if",
   "threshold",
   "is",
   "None",
   ":",
   "threshold",
   "=",
   "tiny",
   "(",
   "S",
   ")",
   "elif",
   "threshold",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'threshold={} must be strictly '",
   "'positive'",
   ".",
   "format",
   "(",
   "threshold",
   ")",
   ")",
   "if",
   "fill",
   "not",
   "in",
   "[",
   "None",
   ",",
   "False",
   ",",
   "True",
   "]",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'fill={} must be None or boolean'",
   ".",
   "format",
   "(",
   "fill",
   ")",
   ")",
   "if",
   "not",
   "np",
   ".",
   "all",
   "(",
   "np",
   ".",
   "isfinite",
   "(",
   "S",
   ")",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Input must be finite'",
   ")",
   "# All norms only depend on magnitude, let's do that first",
   "mag",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "S",
   ")",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float",
   ")",
   "# For max/min norms, filling with 1 works",
   "fill_norm",
   "=",
   "1",
   "if",
   "norm",
   "==",
   "np",
   ".",
   "inf",
   ":",
   "length",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "mag",
   ",",
   "axis",
   "=",
   "axis",
   ",",
   "keepdims",
   "=",
   "True",
   ")",
   "elif",
   "norm",
   "==",
   "-",
   "np",
   ".",
   "inf",
   ":",
   "length",
   "=",
   "np",
   ".",
   "min",
   "(",
   "mag",
   ",",
   "axis",
   "=",
   "axis",
   ",",
   "keepdims",
   "=",
   "True",
   ")",
   "elif",
   "norm",
   "==",
   "0",
   ":",
   "if",
   "fill",
   "is",
   "True",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Cannot normalize with norm=0 and fill=True'",
   ")",
   "length",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "mag",
   ">",
   "0",
   ",",
   "axis",
   "=",
   "axis",
   ",",
   "keepdims",
   "=",
   "True",
   ",",
   "dtype",
   "=",
   "mag",
   ".",
   "dtype",
   ")",
   "elif",
   "np",
   ".",
   "issubdtype",
   "(",
   "type",
   "(",
   "norm",
   ")",
   ",",
   "np",
   ".",
   "number",
   ")",
   "and",
   "norm",
   ">",
   "0",
   ":",
   "length",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "mag",
   "**",
   "norm",
   ",",
   "axis",
   "=",
   "axis",
   ",",
   "keepdims",
   "=",
   "True",
   ")",
   "**",
   "(",
   "1.",
   "/",
   "norm",
   ")",
   "if",
   "axis",
   "is",
   "None",
   ":",
   "fill_norm",
   "=",
   "mag",
   ".",
   "size",
   "**",
   "(",
   "-",
   "1.",
   "/",
   "norm",
   ")",
   "else",
   ":",
   "fill_norm",
   "=",
   "mag",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   "**",
   "(",
   "-",
   "1.",
   "/",
   "norm",
   ")",
   "elif",
   "norm",
   "is",
   "None",
   ":",
   "return",
   "S",
   "else",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Unsupported norm: {}'",
   ".",
   "format",
   "(",
   "repr",
   "(",
   "norm",
   ")",
   ")",
   ")",
   "# indices where norm is below the threshold",
   "small_idx",
   "=",
   "length",
   "<",
   "threshold",
   "Snorm",
   "=",
   "np",
   ".",
   "empty_like",
   "(",
   "S",
   ")",
   "if",
   "fill",
   "is",
   "None",
   ":",
   "# Leave small indices un-normalized",
   "length",
   "[",
   "small_idx",
   "]",
   "=",
   "1.0",
   "Snorm",
   "[",
   ":",
   "]",
   "=",
   "S",
   "/",
   "length",
   "elif",
   "fill",
   ":",
   "# If we have a non-zero fill value, we locate those entries by",
   "# doing a nan-divide.",
   "# If S was finite, then length is finite (except for small positions)",
   "length",
   "[",
   "small_idx",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "Snorm",
   "[",
   ":",
   "]",
   "=",
   "S",
   "/",
   "length",
   "Snorm",
   "[",
   "np",
   ".",
   "isnan",
   "(",
   "Snorm",
   ")",
   "]",
   "=",
   "fill_norm",
   "else",
   ":",
   "# Set small values to zero by doing an inf-divide.",
   "# This is safe (by IEEE-754) as long as S is finite.",
   "length",
   "[",
   "small_idx",
   "]",
   "=",
   "np",
   ".",
   "inf",
   "Snorm",
   "[",
   ":",
   "]",
   "=",
   "S",
   "/",
   "length",
   "return",
   "Snorm"
  ]
 },
 {
  "idx": "maxmin-956",
  "nl_tokens": [
   "Renders",
   "a",
   "list",
   "of",
   "columns",
   "."
  ],
  "pl_tokens": [
   "def",
   "render_columns",
   "(",
   "columns",
   ",",
   "write_borders",
   "=",
   "True",
   ",",
   "column_colors",
   "=",
   "None",
   ")",
   ":",
   "if",
   "column_colors",
   "is",
   "not",
   "None",
   "and",
   "len",
   "(",
   "column_colors",
   ")",
   "!=",
   "len",
   "(",
   "columns",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Wrong number of column colors'",
   ")",
   "widths",
   "=",
   "[",
   "<mask>",
   "(",
   "len",
   "(",
   "cell",
   ")",
   "for",
   "cell",
   "in",
   "column",
   ")",
   "for",
   "column",
   "in",
   "columns",
   "]",
   "max_column_length",
   "=",
   "max",
   "(",
   "len",
   "(",
   "column",
   ")",
   "for",
   "column",
   "in",
   "columns",
   ")",
   "result",
   "=",
   "'\\n'",
   ".",
   "join",
   "(",
   "render_row",
   "(",
   "i",
   ",",
   "columns",
   ",",
   "widths",
   ",",
   "column_colors",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "max_column_length",
   ")",
   ")",
   "if",
   "write_borders",
   ":",
   "border",
   "=",
   "'+%s+'",
   "%",
   "'|'",
   ".",
   "join",
   "(",
   "'-'",
   "*",
   "(",
   "w",
   "+",
   "2",
   ")",
   "for",
   "w",
   "in",
   "widths",
   ")",
   "return",
   "'%s\\n%s\\n%s'",
   "%",
   "(",
   "border",
   ",",
   "result",
   ",",
   "border",
   ")",
   "else",
   ":",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-957",
  "nl_tokens": [
   "Automatically",
   "separates",
   "signal",
   "and",
   "background",
   "data",
   "regions",
   "."
  ],
  "pl_tokens": [
   "def",
   "autorange",
   "(",
   "self",
   ",",
   "analyte",
   "=",
   "'total_counts'",
   ",",
   "gwin",
   "=",
   "5",
   ",",
   "swin",
   "=",
   "3",
   ",",
   "win",
   "=",
   "20",
   ",",
   "on_mult",
   "=",
   "[",
   "1.",
   ",",
   "1.5",
   "]",
   ",",
   "off_mult",
   "=",
   "[",
   "1.5",
   ",",
   "1",
   "]",
   ",",
   "transform",
   "=",
   "'log'",
   ",",
   "ploterrs",
   "=",
   "True",
   ",",
   "focus_stage",
   "=",
   "'despiked'",
   ")",
   ":",
   "if",
   "focus_stage",
   "==",
   "'despiked'",
   ":",
   "if",
   "'despiked'",
   "not",
   "in",
   "self",
   ".",
   "stages_complete",
   ":",
   "focus_stage",
   "=",
   "'rawdata'",
   "if",
   "analyte",
   "is",
   "None",
   ":",
   "analyte",
   "=",
   "self",
   ".",
   "internal_standard",
   "elif",
   "analyte",
   "in",
   "self",
   ".",
   "analytes",
   ":",
   "self",
   ".",
   "minimal_analytes",
   ".",
   "update",
   "(",
   "[",
   "analyte",
   "]",
   ")",
   "fails",
   "=",
   "{",
   "}",
   "# list for catching failures.",
   "with",
   "self",
   ".",
   "pbar",
   ".",
   "set",
   "(",
   "total",
   "=",
   "len",
   "(",
   "self",
   ".",
   "data",
   ")",
   ",",
   "desc",
   "=",
   "'AutoRange'",
   ")",
   "as",
   "prog",
   ":",
   "for",
   "s",
   ",",
   "d",
   "in",
   "self",
   ".",
   "data",
   ".",
   "items",
   "(",
   ")",
   ":",
   "f",
   "=",
   "d",
   ".",
   "autorange",
   "(",
   "analyte",
   "=",
   "analyte",
   ",",
   "gwin",
   "=",
   "gwin",
   ",",
   "swin",
   "=",
   "swin",
   ",",
   "win",
   "=",
   "win",
   ",",
   "on_mult",
   "=",
   "on_mult",
   ",",
   "off_mult",
   "=",
   "off_mult",
   ",",
   "ploterrs",
   "=",
   "ploterrs",
   ",",
   "transform",
   "=",
   "transform",
   ")",
   "if",
   "f",
   "is",
   "not",
   "None",
   ":",
   "fails",
   "[",
   "s",
   "]",
   "=",
   "f",
   "prog",
   ".",
   "update",
   "(",
   ")",
   "# advance progress bar",
   "# handle failures",
   "if",
   "len",
   "(",
   "fails",
   ")",
   ">",
   "0",
   ":",
   "wstr",
   "=",
   "(",
   "'\\n\\n'",
   "+",
   "'*'",
   "*",
   "41",
   "+",
   "'\\n'",
   "+",
   "'                 WARNING\\n'",
   "+",
   "'*'",
   "*",
   "41",
   "+",
   "'\\n'",
   "+",
   "'Autorange failed for some samples:\\n'",
   ")",
   "kwidth",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "k",
   ")",
   "for",
   "k",
   "in",
   "fails",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "+",
   "1",
   "fstr",
   "=",
   "'  {:'",
   "+",
   "'{}'",
   ".",
   "format",
   "(",
   "kwidth",
   ")",
   "+",
   "'s}: '",
   "for",
   "k",
   "in",
   "sorted",
   "(",
   "fails",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ":",
   "wstr",
   "+=",
   "fstr",
   ".",
   "format",
   "(",
   "k",
   ")",
   "+",
   "', '",
   ".",
   "join",
   "(",
   "[",
   "'{:.1f}'",
   ".",
   "format",
   "(",
   "f",
   ")",
   "for",
   "f",
   "in",
   "fails",
   "[",
   "k",
   "]",
   "[",
   "-",
   "1",
   "]",
   "]",
   ")",
   "+",
   "'\\n'",
   "wstr",
   "+=",
   "(",
   "'\\n*** THIS IS NOT NECESSARILY A PROBLEM ***\\n'",
   "+",
   "'But please check the plots below to make\\n'",
   "+",
   "'sure they look OK. Failures are marked by\\n'",
   "+",
   "'dashed vertical red lines.\\n\\n'",
   "+",
   "'To examine an autorange failure in more\\n'",
   "+",
   "'detail, use the `autorange_plot` method\\n'",
   "+",
   "'of the failing data object, e.g.:\\n'",
   "+",
   "\"dat.data['Sample'].autorange_plot(params)\\n\"",
   "+",
   "'*'",
   "*",
   "41",
   "+",
   "'\\n'",
   ")",
   "warnings",
   ".",
   "warn",
   "(",
   "wstr",
   ")",
   "self",
   ".",
   "stages_complete",
   ".",
   "update",
   "(",
   "[",
   "'autorange'",
   "]",
   ")",
   "return"
  ]
 },
 {
  "idx": "maxmin-958",
  "nl_tokens": [
   ":",
   "param",
   "text",
   ":",
   "tag",
   "-",
   "free",
   "UTF",
   "-",
   "8",
   "string",
   "of",
   "free",
   "text",
   ":",
   "returns",
   "string",
   ":",
   "32",
   "-",
   "character",
   "md5",
   "hash",
   "in",
   "hexadecimal"
  ],
  "pl_tokens": [
   "def",
   "tps",
   "(",
   "text",
   ",",
   "min_token_len",
   "=",
   "2",
   ",",
   "quant_rate",
   "=",
   "0.01",
   ")",
   ":",
   "counts",
   "=",
   "Counter",
   "(",
   "ifilter",
   "(",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   ")",
   ">=",
   "min_token_len",
   ",",
   "imap",
   "(",
   "cleanse",
   ",",
   "text",
   ".",
   "split",
   "(",
   ")",
   ")",
   ")",
   ")",
   "max_freq",
   "=",
   "counts",
   ".",
   "most_common",
   "(",
   "1",
   ")",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "if",
   "max_freq",
   "<=",
   "1",
   ":",
   "quant",
   "=",
   "1",
   "else",
   ":",
   "quant",
   "=",
   "<mask>",
   "(",
   "2",
   ",",
   "round",
   "(",
   "max_freq",
   "*",
   "quant_rate",
   ")",
   ")",
   "to_hash",
   "=",
   "[",
   "]",
   "for",
   "word",
   ",",
   "count",
   "in",
   "counts",
   ".",
   "most_common",
   "(",
   ")",
   ":",
   "if",
   "count",
   "<=",
   "quant",
   ":",
   "break",
   "to_hash",
   "+=",
   "[",
   "word",
   ",",
   "str",
   "(",
   "int",
   "(",
   "math",
   ".",
   "floor",
   "(",
   "count",
   "/",
   "quant",
   ")",
   ")",
   ")",
   "]",
   "to_hash",
   "=",
   "u' '",
   ".",
   "join",
   "(",
   "to_hash",
   ")",
   "return",
   "hashlib",
   ".",
   "md5",
   "(",
   "to_hash",
   ".",
   "encode",
   "(",
   "'utf8'",
   ")",
   ")",
   ".",
   "hexdigest",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-959",
  "nl_tokens": [
   "Returns",
   "the",
   "maximum",
   "representable",
   "value",
   "in",
   "this",
   "data",
   "type",
   "."
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "dtype",
   ")",
   ":",
   "# pylint: disable=redefined-builtin",
   "dtype",
   "=",
   "tf",
   ".",
   "as_dtype",
   "(",
   "dtype",
   ")",
   "if",
   "hasattr",
   "(",
   "dtype",
   ",",
   "'max'",
   ")",
   ":",
   "return",
   "dtype",
   ".",
   "max",
   "use_finfo",
   "=",
   "is_floating",
   "(",
   "dtype",
   ")",
   "or",
   "is_complex",
   "(",
   "dtype",
   ")",
   "return",
   "np",
   ".",
   "finfo",
   "(",
   "dtype",
   ")",
   ".",
   "max",
   "if",
   "use_finfo",
   "else",
   "np",
   ".",
   "iinfo",
   "(",
   "dtype",
   ")",
   ".",
   "max"
  ]
 },
 {
  "idx": "maxmin-960",
  "nl_tokens": [
   "\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442",
   "\u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e",
   "\u0434\u043b\u0438\u043d\u0443",
   "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430",
   "low",
   "\u0432",
   "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0440\u043d\u043e\u0439",
   "\u0442\u0440\u0430\u043d\u0441\u0434\u0443\u043a\u0446\u0438\u0438",
   "(",
   "up",
   "low",
   ")",
   "\u0434\u043b\u044f",
   "\u043a\u0430\u0436\u0434\u043e\u0433\u043e",
   "up",
   "\u0438",
   "\u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e",
   "\u0434\u043b\u0438\u043d\u0443",
   "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430",
   "up",
   "\u0432",
   "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0440\u043d\u043e\u0439",
   "\u0442\u0440\u0430\u043d\u0441\u0434\u0443\u043a\u0446\u0438\u0438",
   "(",
   "up",
   "low",
   ")",
   "\u0434\u043b\u044f",
   "\u043a\u0430\u0436\u0434\u043e\u0433\u043e",
   "low"
  ],
  "pl_tokens": [
   "def",
   "_make_maximal_key_lengths",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "max_up_length",
   "=",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "up",
   ")",
   "for",
   "up",
   "in",
   "self",
   ".",
   "operation_costs",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "operation_costs",
   ")",
   ">",
   "0",
   "else",
   "-",
   "1",
   ")",
   "self",
   ".",
   "max_low_length",
   "=",
   "(",
   "max",
   "(",
   "len",
   "(",
   "low",
   ")",
   "for",
   "low",
   "in",
   "self",
   ".",
   "_reversed_operation_costs",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "_reversed_operation_costs",
   ")",
   ">",
   "0",
   "else",
   "-",
   "1",
   ")",
   "self",
   ".",
   "max_low_lengths_by_up",
   ",",
   "self",
   ".",
   "max_up_lengths_by_low",
   "=",
   "dict",
   "(",
   ")",
   ",",
   "dict",
   "(",
   ")",
   "for",
   "up",
   ",",
   "costs",
   "in",
   "self",
   ".",
   "operation_costs",
   ".",
   "items",
   "(",
   ")",
   ":",
   "self",
   ".",
   "max_low_lengths_by_up",
   "[",
   "up",
   "]",
   "=",
   "max",
   "(",
   "len",
   "(",
   "low",
   ")",
   "for",
   "low",
   "in",
   "costs",
   ")",
   "if",
   "len",
   "(",
   "costs",
   ")",
   ">",
   "0",
   "else",
   "-",
   "1",
   "for",
   "low",
   ",",
   "costs",
   "in",
   "self",
   ".",
   "_reversed_operation_costs",
   ".",
   "items",
   "(",
   ")",
   ":",
   "self",
   ".",
   "max_up_lengths_by_low",
   "[",
   "low",
   "]",
   "=",
   "max",
   "(",
   "len",
   "(",
   "up",
   ")",
   "for",
   "up",
   "in",
   "costs",
   ")",
   "if",
   "len",
   "(",
   "costs",
   ")",
   ">",
   "0",
   "else",
   "-",
   "1"
  ]
 },
 {
  "idx": "maxmin-961",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "natural",
   "logarithm",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "log",
   "(",
   "wave",
   ")",
   ":",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "ValueError",
   ",",
   "\"Math domain error\"",
   ",",
   "bool",
   "(",
   "(",
   "<mask>",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   "<=",
   "0",
   ")",
   ")",
   ")",
   "return",
   "_operation",
   "(",
   "wave",
   ",",
   "\"log\"",
   ",",
   "\"\"",
   ",",
   "np",
   ".",
   "log",
   ")"
  ]
 },
 {
  "idx": "maxmin-962",
  "nl_tokens": [
   "Get",
   "parameters",
   "for",
   "crop",
   "for",
   "a",
   "random",
   "sized",
   "crop",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_params",
   "(",
   "img",
   ",",
   "scale",
   ",",
   "ratio",
   ")",
   ":",
   "area",
   "=",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "*",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   "for",
   "attempt",
   "in",
   "range",
   "(",
   "10",
   ")",
   ":",
   "target_area",
   "=",
   "random",
   ".",
   "uniform",
   "(",
   "*",
   "scale",
   ")",
   "*",
   "area",
   "log_ratio",
   "=",
   "(",
   "math",
   ".",
   "log",
   "(",
   "ratio",
   "[",
   "0",
   "]",
   ")",
   ",",
   "math",
   ".",
   "log",
   "(",
   "ratio",
   "[",
   "1",
   "]",
   ")",
   ")",
   "aspect_ratio",
   "=",
   "math",
   ".",
   "exp",
   "(",
   "random",
   ".",
   "uniform",
   "(",
   "*",
   "log_ratio",
   ")",
   ")",
   "w",
   "=",
   "int",
   "(",
   "round",
   "(",
   "math",
   ".",
   "sqrt",
   "(",
   "target_area",
   "*",
   "aspect_ratio",
   ")",
   ")",
   ")",
   "h",
   "=",
   "int",
   "(",
   "round",
   "(",
   "math",
   ".",
   "sqrt",
   "(",
   "target_area",
   "/",
   "aspect_ratio",
   ")",
   ")",
   ")",
   "if",
   "w",
   "<=",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "and",
   "h",
   "<=",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   ":",
   "i",
   "=",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   "-",
   "h",
   ")",
   "j",
   "=",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "-",
   "w",
   ")",
   "return",
   "i",
   ",",
   "j",
   ",",
   "h",
   ",",
   "w",
   "# Fallback to central crop",
   "in_ratio",
   "=",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "/",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   "if",
   "(",
   "in_ratio",
   "<",
   "<mask>",
   "(",
   "ratio",
   ")",
   ")",
   ":",
   "w",
   "=",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "h",
   "=",
   "w",
   "/",
   "min",
   "(",
   "ratio",
   ")",
   "elif",
   "(",
   "in_ratio",
   ">",
   "max",
   "(",
   "ratio",
   ")",
   ")",
   ":",
   "h",
   "=",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   "w",
   "=",
   "h",
   "*",
   "max",
   "(",
   "ratio",
   ")",
   "else",
   ":",
   "# whole image",
   "w",
   "=",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "h",
   "=",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   "i",
   "=",
   "(",
   "img",
   ".",
   "size",
   "[",
   "1",
   "]",
   "-",
   "h",
   ")",
   "//",
   "2",
   "j",
   "=",
   "(",
   "img",
   ".",
   "size",
   "[",
   "0",
   "]",
   "-",
   "w",
   ")",
   "//",
   "2",
   "return",
   "i",
   ",",
   "j",
   ",",
   "h",
   ",",
   "w"
  ]
 },
 {
  "idx": "maxmin-963",
  "nl_tokens": [
   "Compute",
   "the",
   "hybrid",
   "constant",
   "-",
   "Q",
   "transform",
   "of",
   "an",
   "audio",
   "signal",
   "."
  ],
  "pl_tokens": [
   "def",
   "hybrid_cqt",
   "(",
   "y",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "fmin",
   "=",
   "None",
   ",",
   "n_bins",
   "=",
   "84",
   ",",
   "bins_per_octave",
   "=",
   "12",
   ",",
   "tuning",
   "=",
   "0.0",
   ",",
   "filter_scale",
   "=",
   "1",
   ",",
   "norm",
   "=",
   "1",
   ",",
   "sparsity",
   "=",
   "0.01",
   ",",
   "window",
   "=",
   "'hann'",
   ",",
   "scale",
   "=",
   "True",
   ",",
   "pad_mode",
   "=",
   "'reflect'",
   ",",
   "res_type",
   "=",
   "None",
   ")",
   ":",
   "if",
   "fmin",
   "is",
   "None",
   ":",
   "# C1 by default",
   "fmin",
   "=",
   "note_to_hz",
   "(",
   "'C1'",
   ")",
   "if",
   "tuning",
   "is",
   "None",
   ":",
   "tuning",
   "=",
   "estimate_tuning",
   "(",
   "y",
   "=",
   "y",
   ",",
   "sr",
   "=",
   "sr",
   ")",
   "# Get all CQT frequencies",
   "freqs",
   "=",
   "cqt_frequencies",
   "(",
   "n_bins",
   ",",
   "fmin",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ")",
   "# Compute the length of each constant-Q basis function",
   "lengths",
   "=",
   "filters",
   ".",
   "constant_q_lengths",
   "(",
   "sr",
   ",",
   "fmin",
   ",",
   "n_bins",
   "=",
   "n_bins",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ",",
   "filter_scale",
   "=",
   "filter_scale",
   ",",
   "window",
   "=",
   "window",
   ")",
   "# Determine which filters to use with Pseudo CQT",
   "# These are the ones that fit within 2 hop lengths after padding",
   "pseudo_filters",
   "=",
   "2.0",
   "**",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "log2",
   "(",
   "lengths",
   ")",
   ")",
   "<",
   "2",
   "*",
   "hop_length",
   "n_bins_pseudo",
   "=",
   "int",
   "(",
   "np",
   ".",
   "sum",
   "(",
   "pseudo_filters",
   ")",
   ")",
   "n_bins_full",
   "=",
   "n_bins",
   "-",
   "n_bins_pseudo",
   "cqt_resp",
   "=",
   "[",
   "]",
   "if",
   "n_bins_pseudo",
   ">",
   "0",
   ":",
   "fmin_pseudo",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "freqs",
   "[",
   "pseudo_filters",
   "]",
   ")",
   "cqt_resp",
   ".",
   "append",
   "(",
   "pseudo_cqt",
   "(",
   "y",
   ",",
   "sr",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ",",
   "fmin",
   "=",
   "fmin_pseudo",
   ",",
   "n_bins",
   "=",
   "n_bins_pseudo",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ",",
   "filter_scale",
   "=",
   "filter_scale",
   ",",
   "norm",
   "=",
   "norm",
   ",",
   "sparsity",
   "=",
   "sparsity",
   ",",
   "window",
   "=",
   "window",
   ",",
   "scale",
   "=",
   "scale",
   ",",
   "pad_mode",
   "=",
   "pad_mode",
   ")",
   ")",
   "if",
   "n_bins_full",
   ">",
   "0",
   ":",
   "cqt_resp",
   ".",
   "append",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "cqt",
   "(",
   "y",
   ",",
   "sr",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ",",
   "fmin",
   "=",
   "fmin",
   ",",
   "n_bins",
   "=",
   "n_bins_full",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ",",
   "filter_scale",
   "=",
   "filter_scale",
   ",",
   "norm",
   "=",
   "norm",
   ",",
   "sparsity",
   "=",
   "sparsity",
   ",",
   "window",
   "=",
   "window",
   ",",
   "scale",
   "=",
   "scale",
   ",",
   "pad_mode",
   "=",
   "pad_mode",
   ",",
   "res_type",
   "=",
   "res_type",
   ")",
   ")",
   ")",
   "return",
   "__trim_stack",
   "(",
   "cqt_resp",
   ",",
   "n_bins",
   ")"
  ]
 },
 {
  "idx": "maxmin-964",
  "nl_tokens": [
   "Return",
   "a",
   "shallow",
   "copy",
   "a",
   "DataFrame",
   "with",
   "the",
   "last",
   "n",
   "rows",
   "."
  ],
  "pl_tokens": [
   "def",
   "tail",
   "(",
   "self",
   ",",
   "n",
   "=",
   "10",
   ")",
   ":",
   "N",
   "=",
   "len",
   "(",
   "self",
   ")",
   "# self.cat(i1=max(0, N-n), i2=min(len(self), N))",
   "return",
   "self",
   "[",
   "<mask>",
   "(",
   "0",
   ",",
   "N",
   "-",
   "n",
   ")",
   ":",
   "min",
   "(",
   "len",
   "(",
   "self",
   ")",
   ",",
   "N",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-965",
  "nl_tokens": [
   "calculates",
   "the",
   "capacity",
   "according",
   "to",
   "THe",
   "Engineering",
   "of",
   "Foundations",
   "textbook",
   "by",
   "Salgado"
  ],
  "pl_tokens": [
   "def",
   "capacity_salgado_2008",
   "(",
   "sl",
   ",",
   "fd",
   ",",
   "h_l",
   "=",
   "0",
   ",",
   "h_b",
   "=",
   "0",
   ",",
   "vertical_load",
   "=",
   "1",
   ",",
   "verbose",
   "=",
   "0",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# Need to make adjustments if sand  has DR<40% or",
   "# clay has liquidity indices greater than 0.7",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"disable_requires\"",
   ",",
   "False",
   ")",
   ":",
   "models",
   ".",
   "check_required",
   "(",
   "sl",
   ",",
   "[",
   "\"phi_r\"",
   ",",
   "\"cohesion\"",
   ",",
   "\"unit_dry_weight\"",
   "]",
   ")",
   "models",
   ".",
   "check_required",
   "(",
   "fd",
   ",",
   "[",
   "\"length\"",
   ",",
   "\"width\"",
   ",",
   "\"depth\"",
   "]",
   ")",
   "h_eff_b",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"h_eff_b\"",
   ",",
   "0",
   ")",
   "h_eff_l",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"h_eff_l\"",
   ",",
   "0",
   ")",
   "loc_v_l",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"loc_v_l\"",
   ",",
   "fd",
   ".",
   "length",
   "/",
   "2",
   ")",
   "loc_v_b",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"loc_v_b\"",
   ",",
   "fd",
   ".",
   "width",
   "/",
   "2",
   ")",
   "ecc_b",
   "=",
   "h_b",
   "*",
   "h_eff_b",
   "/",
   "vertical_load",
   "ecc_l",
   "=",
   "h_l",
   "*",
   "h_eff_l",
   "/",
   "vertical_load",
   "width_eff",
   "=",
   "<mask>",
   "(",
   "fd",
   ".",
   "width",
   ",",
   "2",
   "*",
   "(",
   "loc_v_b",
   "+",
   "ecc_b",
   ")",
   ",",
   "2",
   "*",
   "(",
   "fd",
   ".",
   "width",
   "-",
   "loc_v_b",
   "-",
   "ecc_b",
   ")",
   ")",
   "length_eff",
   "=",
   "min",
   "(",
   "fd",
   ".",
   "length",
   ",",
   "2",
   "*",
   "(",
   "loc_v_l",
   "+",
   "ecc_l",
   ")",
   ",",
   "2",
   "*",
   "(",
   "fd",
   ".",
   "length",
   "-",
   "loc_v_l",
   "-",
   "ecc_l",
   ")",
   ")",
   "# check para 3.4.1",
   "if",
   "width_eff",
   "/",
   "2",
   "<",
   "fd",
   ".",
   "width",
   "/",
   "6",
   ":",
   "DesignError",
   "(",
   "\"failed on eccentricity\"",
   ")",
   "# LOAD FACTORS:",
   "fd",
   ".",
   "nq_factor",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "np",
   ".",
   "pi",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "*",
   "(",
   "1",
   "+",
   "np",
   ".",
   "sin",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "/",
   "(",
   "1",
   "-",
   "np",
   ".",
   "sin",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "fd",
   ".",
   "ng_factor",
   "=",
   "1.5",
   "*",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "# fd.ng_factor = (fd.nq_factor - 1) * np.tan(1.32 * sl.phi_r)",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "fd",
   ".",
   "nc_factor",
   "=",
   "5.14",
   "else",
   ":",
   "fd",
   ".",
   "nc_factor",
   "=",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "# shape factors:",
   "s_q",
   "=",
   "1",
   "+",
   "(",
   "width_eff",
   "/",
   "length_eff",
   ")",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "s_g",
   "=",
   "max",
   "(",
   "1",
   "-",
   "0.4",
   "*",
   "width_eff",
   "/",
   "length_eff",
   ",",
   "0.6",
   ")",
   "s_c",
   "=",
   "1.0",
   "# depth factors:",
   "d_q",
   "=",
   "1",
   "+",
   "2",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "*",
   "(",
   "1",
   "-",
   "np",
   ".",
   "sin",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "**",
   "2",
   "*",
   "fd",
   ".",
   "depth",
   "/",
   "width_eff",
   "d_g",
   "=",
   "1.0",
   "d_c",
   "=",
   "1.0",
   "# stress at footing base:",
   "q_d",
   "=",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "fd",
   ".",
   "depth",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"width_eff: \"",
   ",",
   "width_eff",
   ")",
   "log",
   "(",
   "\"length_eff: \"",
   ",",
   "length_eff",
   ")",
   "log",
   "(",
   "\"Nc: \"",
   ",",
   "fd",
   ".",
   "nc_factor",
   ")",
   "log",
   "(",
   "\"Nq: \"",
   ",",
   "fd",
   ".",
   "nq_factor",
   ")",
   "log",
   "(",
   "\"Ng: \"",
   ",",
   "fd",
   ".",
   "ng_factor",
   ")",
   "log",
   "(",
   "\"s_c: \"",
   ",",
   "s_c",
   ")",
   "log",
   "(",
   "\"s_q: \"",
   ",",
   "s_q",
   ")",
   "log",
   "(",
   "\"s_g: \"",
   ",",
   "s_g",
   ")",
   "log",
   "(",
   "\"d_c: \"",
   ",",
   "d_c",
   ")",
   "log",
   "(",
   "\"d_q: \"",
   ",",
   "d_q",
   ")",
   "log",
   "(",
   "\"d_g: \"",
   ",",
   "d_g",
   ")",
   "log",
   "(",
   "\"q_d: \"",
   ",",
   "q_d",
   ")",
   "# Capacity",
   "fd",
   ".",
   "q_ult",
   "=",
   "(",
   "sl",
   ".",
   "cohesion",
   "*",
   "fd",
   ".",
   "nc_factor",
   "*",
   "s_c",
   "*",
   "d_c",
   "+",
   "q_d",
   "*",
   "fd",
   ".",
   "nq_factor",
   "*",
   "s_q",
   "*",
   "d_q",
   "+",
   "0.5",
   "*",
   "width_eff",
   "*",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "fd",
   ".",
   "ng_factor",
   "*",
   "s_g",
   "*",
   "d_g",
   ")",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"qult: \"",
   ",",
   "fd",
   ".",
   "q_ult",
   ")",
   "return",
   "fd",
   ".",
   "q_ult"
  ]
 },
 {
  "idx": "maxmin-966",
  "nl_tokens": [
   "Helper",
   "function",
   "for",
   "window",
   "sum",
   "-",
   "square",
   "calculation",
   "."
  ],
  "pl_tokens": [
   "def",
   "__window_ss_fill",
   "(",
   "x",
   ",",
   "win_sq",
   ",",
   "n_frames",
   ",",
   "hop_length",
   ")",
   ":",
   "# pragma: no cover",
   "n",
   "=",
   "len",
   "(",
   "x",
   ")",
   "n_fft",
   "=",
   "len",
   "(",
   "win_sq",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n_frames",
   ")",
   ":",
   "sample",
   "=",
   "i",
   "*",
   "hop_length",
   "x",
   "[",
   "sample",
   ":",
   "<mask>",
   "(",
   "n",
   ",",
   "sample",
   "+",
   "n_fft",
   ")",
   "]",
   "+=",
   "win_sq",
   "[",
   ":",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "n_fft",
   ",",
   "n",
   "-",
   "sample",
   ")",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-967",
  "nl_tokens": [
   "Parse",
   "Retry",
   "-",
   "After",
   "header",
   "from",
   "response",
   "if",
   "it",
   "is",
   "set",
   "."
  ],
  "pl_tokens": [
   "def",
   "_parse_retry_after",
   "(",
   "self",
   ",",
   "response",
   ")",
   ":",
   "value",
   "=",
   "response",
   ".",
   "headers",
   ".",
   "get",
   "(",
   "'Retry-After'",
   ")",
   "if",
   "not",
   "value",
   ":",
   "seconds",
   "=",
   "0",
   "elif",
   "re",
   ".",
   "match",
   "(",
   "r'^\\s*[0-9]+\\s*$'",
   ",",
   "value",
   ")",
   ":",
   "seconds",
   "=",
   "int",
   "(",
   "value",
   ")",
   "else",
   ":",
   "date_tuple",
   "=",
   "email",
   ".",
   "utils",
   ".",
   "parsedate",
   "(",
   "value",
   ")",
   "if",
   "date_tuple",
   "is",
   "None",
   ":",
   "seconds",
   "=",
   "0",
   "else",
   ":",
   "seconds",
   "=",
   "time",
   ".",
   "mktime",
   "(",
   "date_tuple",
   ")",
   "-",
   "time",
   ".",
   "time",
   "(",
   ")",
   "return",
   "<mask>",
   "(",
   "0",
   ",",
   "seconds",
   ")"
  ]
 },
 {
  "idx": "maxmin-968",
  "nl_tokens": [
   "Keep",
   "the",
   "row",
   "of",
   "the",
   "data",
   "corresponding",
   "to",
   "the",
   "minimal",
   "value",
   "in",
   "a",
   "column"
  ],
  "pl_tokens": [
   "def",
   "argmin",
   "(",
   "df",
   ",",
   "column",
   ":",
   "str",
   ",",
   "groups",
   ":",
   "Union",
   "[",
   "str",
   ",",
   "List",
   "[",
   "str",
   "]",
   "]",
   "=",
   "None",
   ")",
   ":",
   "if",
   "groups",
   "is",
   "None",
   ":",
   "df",
   "=",
   "df",
   "[",
   "df",
   "[",
   "column",
   "]",
   "==",
   "df",
   "[",
   "column",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "]",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ")",
   "else",
   ":",
   "group_min",
   "=",
   "df",
   ".",
   "groupby",
   "(",
   "groups",
   ")",
   "[",
   "column",
   "]",
   ".",
   "transform",
   "(",
   "'min'",
   ")",
   "df",
   "=",
   "(",
   "df",
   ".",
   "loc",
   "[",
   "df",
   "[",
   "column",
   "]",
   "==",
   "group_min",
   ",",
   ":",
   "]",
   ".",
   "drop_duplicates",
   "(",
   ")",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ")",
   ")",
   "return",
   "df"
  ]
 },
 {
  "idx": "maxmin-969",
  "nl_tokens": [
   "Get",
   "range",
   "of",
   "the",
   "Unicode",
   "encode",
   "range",
   "for",
   "a",
   "given",
   "string",
   "of",
   "characters",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_qual_range",
   "(",
   "qual_str",
   ")",
   ":",
   "vals",
   "=",
   "[",
   "ord",
   "(",
   "c",
   ")",
   "for",
   "c",
   "in",
   "qual_str",
   "]",
   "return",
   "<mask>",
   "(",
   "vals",
   ")",
   ",",
   "max",
   "(",
   "vals",
   ")"
  ]
 },
 {
  "idx": "maxmin-970",
  "nl_tokens": [
   "Widget",
   "for",
   "displaying",
   "detailed",
   "noise",
   "map",
   "."
  ],
  "pl_tokens": [
   "def",
   "detailed_map",
   "(",
   "backend",
   ")",
   ":",
   "props",
   "=",
   "backend",
   ".",
   "properties",
   "(",
   ")",
   ".",
   "to_dict",
   "(",
   ")",
   "config",
   "=",
   "backend",
   ".",
   "configuration",
   "(",
   ")",
   ".",
   "to_dict",
   "(",
   ")",
   "single_gate_errors",
   "=",
   "[",
   "q",
   "[",
   "'parameters'",
   "]",
   "[",
   "0",
   "]",
   "[",
   "'value'",
   "]",
   "for",
   "q",
   "in",
   "props",
   "[",
   "'gates'",
   "]",
   "[",
   "2",
   ":",
   "3",
   "*",
   "config",
   "[",
   "'n_qubits'",
   "]",
   ":",
   "3",
   "]",
   "]",
   "single_norm",
   "=",
   "matplotlib",
   ".",
   "colors",
   ".",
   "Normalize",
   "(",
   "vmin",
   "=",
   "<mask>",
   "(",
   "single_gate_errors",
   ")",
   ",",
   "vmax",
   "=",
   "max",
   "(",
   "single_gate_errors",
   ")",
   ")",
   "q_colors",
   "=",
   "[",
   "cm",
   ".",
   "viridis",
   "(",
   "single_norm",
   "(",
   "err",
   ")",
   ")",
   "for",
   "err",
   "in",
   "single_gate_errors",
   "]",
   "cmap",
   "=",
   "config",
   "[",
   "'coupling_map'",
   "]",
   "cx_errors",
   "=",
   "[",
   "]",
   "for",
   "line",
   "in",
   "cmap",
   ":",
   "for",
   "item",
   "in",
   "props",
   "[",
   "'gates'",
   "]",
   "[",
   "3",
   "*",
   "config",
   "[",
   "'n_qubits'",
   "]",
   ":",
   "]",
   ":",
   "if",
   "item",
   "[",
   "'qubits'",
   "]",
   "==",
   "line",
   ":",
   "cx_errors",
   ".",
   "append",
   "(",
   "item",
   "[",
   "'parameters'",
   "]",
   "[",
   "0",
   "]",
   "[",
   "'value'",
   "]",
   ")",
   "break",
   "else",
   ":",
   "continue",
   "cx_norm",
   "=",
   "matplotlib",
   ".",
   "colors",
   ".",
   "Normalize",
   "(",
   "vmin",
   "=",
   "min",
   "(",
   "cx_errors",
   ")",
   ",",
   "vmax",
   "=",
   "max",
   "(",
   "cx_errors",
   ")",
   ")",
   "line_colors",
   "=",
   "[",
   "cm",
   ".",
   "viridis",
   "(",
   "cx_norm",
   "(",
   "err",
   ")",
   ")",
   "for",
   "err",
   "in",
   "cx_errors",
   "]",
   "single_widget",
   "=",
   "widgets",
   ".",
   "Output",
   "(",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "display",
   "=",
   "'flex-inline'",
   ",",
   "grid_area",
   "=",
   "'left'",
   ",",
   "align_items",
   "=",
   "'center'",
   ")",
   ")",
   "cmap_widget",
   "=",
   "widgets",
   ".",
   "Output",
   "(",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "display",
   "=",
   "'flex-inline'",
   ",",
   "grid_area",
   "=",
   "'top'",
   ",",
   "width",
   "=",
   "'auto'",
   ",",
   "height",
   "=",
   "'auto'",
   ",",
   "align_items",
   "=",
   "'center'",
   ")",
   ")",
   "cx_widget",
   "=",
   "widgets",
   ".",
   "Output",
   "(",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "display",
   "=",
   "'flex-inline'",
   ",",
   "grid_area",
   "=",
   "'right'",
   ",",
   "align_items",
   "=",
   "'center'",
   ")",
   ")",
   "tick_locator",
   "=",
   "mpl",
   ".",
   "ticker",
   ".",
   "MaxNLocator",
   "(",
   "nbins",
   "=",
   "5",
   ")",
   "with",
   "cmap_widget",
   ":",
   "noise_map",
   "=",
   "plot_gate_map",
   "(",
   "backend",
   ",",
   "qubit_color",
   "=",
   "q_colors",
   ",",
   "line_color",
   "=",
   "line_colors",
   ",",
   "qubit_size",
   "=",
   "28",
   ",",
   "plot_directed",
   "=",
   "True",
   ")",
   "width",
   ",",
   "height",
   "=",
   "noise_map",
   ".",
   "get_size_inches",
   "(",
   ")",
   "noise_map",
   ".",
   "set_size_inches",
   "(",
   "1.25",
   "*",
   "width",
   ",",
   "1.25",
   "*",
   "height",
   ")",
   "display",
   "(",
   "noise_map",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "noise_map",
   ")",
   "with",
   "single_widget",
   ":",
   "cbl_fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "3",
   ",",
   "1",
   ")",
   ")",
   "ax1",
   "=",
   "cbl_fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.05",
   ",",
   "0.80",
   ",",
   "0.9",
   ",",
   "0.15",
   "]",
   ")",
   "single_cb",
   "=",
   "mpl",
   ".",
   "colorbar",
   ".",
   "ColorbarBase",
   "(",
   "ax1",
   ",",
   "cmap",
   "=",
   "cm",
   ".",
   "viridis",
   ",",
   "norm",
   "=",
   "single_norm",
   ",",
   "orientation",
   "=",
   "'horizontal'",
   ")",
   "single_cb",
   ".",
   "locator",
   "=",
   "tick_locator",
   "single_cb",
   ".",
   "update_ticks",
   "(",
   ")",
   "ax1",
   ".",
   "set_title",
   "(",
   "'Single-qubit U3 error rate'",
   ")",
   "display",
   "(",
   "cbl_fig",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "cbl_fig",
   ")",
   "with",
   "cx_widget",
   ":",
   "cx_fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "3",
   ",",
   "1",
   ")",
   ")",
   "ax2",
   "=",
   "cx_fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.05",
   ",",
   "0.80",
   ",",
   "0.9",
   ",",
   "0.15",
   "]",
   ")",
   "cx_cb",
   "=",
   "mpl",
   ".",
   "colorbar",
   ".",
   "ColorbarBase",
   "(",
   "ax2",
   ",",
   "cmap",
   "=",
   "cm",
   ".",
   "viridis",
   ",",
   "norm",
   "=",
   "cx_norm",
   ",",
   "orientation",
   "=",
   "'horizontal'",
   ")",
   "cx_cb",
   ".",
   "locator",
   "=",
   "tick_locator",
   "cx_cb",
   ".",
   "update_ticks",
   "(",
   ")",
   "ax2",
   ".",
   "set_title",
   "(",
   "'CNOT error rate'",
   ")",
   "display",
   "(",
   "cx_fig",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "cx_fig",
   ")",
   "out_box",
   "=",
   "widgets",
   ".",
   "GridBox",
   "(",
   "[",
   "single_widget",
   ",",
   "cmap_widget",
   ",",
   "cx_widget",
   "]",
   ",",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "grid_template_rows",
   "=",
   "'auto auto'",
   ",",
   "grid_template_columns",
   "=",
   "'33% 33% 33%'",
   ",",
   "grid_template_areas",
   "=",
   "'''\n                                                \"top top top\"\n                                                \"left . right\"\n                                                '''",
   ",",
   "grid_gap",
   "=",
   "'0px 0px'",
   ")",
   ")",
   "return",
   "out_box"
  ]
 },
 {
  "idx": "maxmin-971",
  "nl_tokens": [
   "0",
   "-",
   ">",
   "no",
   "terms",
   "idd",
   "1",
   "-",
   ">",
   "most",
   "term",
   "idd",
   "are",
   "shared",
   "in",
   "root",
   "morphem",
   "2",
   "-",
   ">",
   "most",
   "term",
   "idd",
   "are",
   "shared",
   "in",
   "flexing",
   "morphem",
   "3",
   "-",
   ">",
   "most",
   "term",
   "idd",
   "are",
   "shared",
   "root",
   "<",
   "-",
   ">",
   "flexing",
   "(",
   "crossed",
   ")",
   ":",
   "param",
   "w0",
   ":",
   ":",
   "param",
   "w1",
   ":",
   ":",
   "return",
   ":"
  ],
  "pl_tokens": [
   "def",
   "count_id",
   "(",
   "w0",
   ")",
   ":",
   "def",
   "f",
   "(",
   "w1",
   ")",
   ":",
   "count",
   "=",
   "[",
   "set",
   "(",
   "w0",
   ".",
   "root",
   ")",
   ".",
   "intersection",
   "(",
   "w1",
   ".",
   "root",
   ")",
   ",",
   "set",
   "(",
   "w0",
   ".",
   "flexing",
   ")",
   ".",
   "intersection",
   "(",
   "w1",
   ".",
   "flexing",
   ")",
   ",",
   "set",
   "(",
   "w0",
   ".",
   "root",
   ")",
   ".",
   "intersection",
   "(",
   "w1",
   ".",
   "flexing",
   ")",
   "|",
   "set",
   "(",
   "w1",
   ".",
   "root",
   ")",
   ".",
   "intersection",
   "(",
   "w0",
   ".",
   "flexing",
   ")",
   "]",
   "if",
   "any",
   "(",
   "count",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "(",
   "1",
   ",",
   "2",
   ",",
   "3",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "i",
   ":",
   "len",
   "(",
   "count",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   ")",
   "else",
   ":",
   "return",
   "0",
   "return",
   "f"
  ]
 },
 {
  "idx": "maxmin-972",
  "nl_tokens": [
   "Get",
   "source",
   "from",
   "a",
   "traceback",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "tbsource",
   "(",
   "tb",
   ",",
   "context",
   "=",
   "6",
   ")",
   ":",
   "lineno",
   "=",
   "tb",
   ".",
   "tb_lineno",
   "frame",
   "=",
   "tb",
   ".",
   "tb_frame",
   "if",
   "context",
   ">",
   "0",
   ":",
   "start",
   "=",
   "lineno",
   "-",
   "1",
   "-",
   "context",
   "//",
   "2",
   "log",
   ".",
   "debug",
   "(",
   "\"lineno: %s start: %s\"",
   ",",
   "lineno",
   ",",
   "start",
   ")",
   "try",
   ":",
   "lines",
   ",",
   "dummy",
   "=",
   "inspect",
   ".",
   "findsource",
   "(",
   "frame",
   ")",
   "except",
   "IOError",
   ":",
   "lines",
   ",",
   "index",
   "=",
   "[",
   "''",
   "]",
   ",",
   "0",
   "else",
   ":",
   "all_lines",
   "=",
   "lines",
   "start",
   "=",
   "<mask>",
   "(",
   "start",
   ",",
   "1",
   ")",
   "start",
   "=",
   "max",
   "(",
   "0",
   ",",
   "min",
   "(",
   "start",
   ",",
   "len",
   "(",
   "lines",
   ")",
   "-",
   "context",
   ")",
   ")",
   "lines",
   "=",
   "lines",
   "[",
   "start",
   ":",
   "start",
   "+",
   "context",
   "]",
   "index",
   "=",
   "lineno",
   "-",
   "1",
   "-",
   "start",
   "# python 2.5 compat: if previous line ends in a continuation,",
   "# decrement start by 1 to match 2.4 behavior                ",
   "if",
   "sys",
   ".",
   "version_info",
   ">=",
   "(",
   "2",
   ",",
   "5",
   ")",
   "and",
   "index",
   ">",
   "0",
   ":",
   "while",
   "lines",
   "[",
   "index",
   "-",
   "1",
   "]",
   ".",
   "strip",
   "(",
   ")",
   ".",
   "endswith",
   "(",
   "'\\\\'",
   ")",
   ":",
   "start",
   "-=",
   "1",
   "lines",
   "=",
   "all_lines",
   "[",
   "start",
   ":",
   "start",
   "+",
   "context",
   "]",
   "else",
   ":",
   "lines",
   ",",
   "index",
   "=",
   "[",
   "''",
   "]",
   ",",
   "0",
   "log",
   ".",
   "debug",
   "(",
   "\"tbsource lines '''%s''' around index %s\"",
   ",",
   "lines",
   ",",
   "index",
   ")",
   "return",
   "(",
   "lines",
   ",",
   "index",
   ")"
  ]
 },
 {
  "idx": "maxmin-973",
  "nl_tokens": [
   "Computes",
   "the",
   "optimal",
   "partitions",
   "given",
   "the",
   "size",
   "distributions",
   "and",
   "computed",
   "number",
   "of",
   "expected",
   "false",
   "positives",
   "for",
   "all",
   "sub",
   "-",
   "intervals",
   "."
  ],
  "pl_tokens": [
   "def",
   "_compute_best_partitions",
   "(",
   "num_part",
   ",",
   "sizes",
   ",",
   "nfps",
   ")",
   ":",
   "if",
   "num_part",
   "<",
   "2",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"num_part cannot be less than 2\"",
   ")",
   "if",
   "num_part",
   ">",
   "len",
   "(",
   "sizes",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"num_part cannot be greater than the domain size of \"",
   "\"all set sizes\"",
   ")",
   "# If number of partitions is 2, then simply find the upper bound",
   "# of the first partition.",
   "if",
   "num_part",
   "==",
   "2",
   ":",
   "total_nfps",
   ",",
   "u",
   "=",
   "<mask>",
   "(",
   "(",
   "nfps",
   "[",
   "0",
   ",",
   "u1",
   "]",
   "+",
   "nfps",
   "[",
   "u1",
   "+",
   "1",
   ",",
   "len",
   "(",
   "sizes",
   ")",
   "-",
   "1",
   "]",
   ",",
   "u1",
   ")",
   "for",
   "u1",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "sizes",
   ")",
   "-",
   "1",
   ")",
   ")",
   "return",
   "[",
   "(",
   "sizes",
   "[",
   "0",
   "]",
   ",",
   "sizes",
   "[",
   "u",
   "]",
   ")",
   ",",
   "(",
   "sizes",
   "[",
   "u",
   "+",
   "1",
   "]",
   ",",
   "sizes",
   "[",
   "-",
   "1",
   "]",
   ")",
   ",",
   "]",
   ",",
   "total_nfps",
   ",",
   "None",
   "# Initialize subproblem total NFPs.",
   "cost",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "len",
   "(",
   "sizes",
   ")",
   ",",
   "num_part",
   "-",
   "2",
   ")",
   ")",
   "# Note: p is the number of partitions in the subproblem.",
   "# p2i translates the number of partition into the index in the matrix.",
   "p2i",
   "=",
   "lambda",
   "p",
   ":",
   "p",
   "-",
   "2",
   "# Compute p >= 2 until before p = num_part.",
   "for",
   "p",
   "in",
   "range",
   "(",
   "2",
   ",",
   "num_part",
   ")",
   ":",
   "# Compute best partition for subproblems with increasing",
   "# max index u, starting from the smallest possible u given the p.",
   "# The smallest possible u can be considered as the max index that",
   "# generates p partitions each with only one size.",
   "for",
   "u",
   "in",
   "range",
   "(",
   "p",
   "-",
   "1",
   ",",
   "len",
   "(",
   "sizes",
   ")",
   ")",
   ":",
   "if",
   "p",
   "==",
   "2",
   ":",
   "cost",
   "[",
   "u",
   ",",
   "p2i",
   "(",
   "p",
   ")",
   "]",
   "=",
   "min",
   "(",
   "nfps",
   "[",
   "0",
   ",",
   "u1",
   "]",
   "+",
   "nfps",
   "[",
   "u1",
   "+",
   "1",
   ",",
   "u",
   "]",
   "for",
   "u1",
   "in",
   "range",
   "(",
   "u",
   ")",
   ")",
   "else",
   ":",
   "cost",
   "[",
   "u",
   ",",
   "p2i",
   "(",
   "p",
   ")",
   "]",
   "=",
   "min",
   "(",
   "cost",
   "[",
   "u1",
   ",",
   "p2i",
   "(",
   "p",
   "-",
   "1",
   ")",
   "]",
   "+",
   "nfps",
   "[",
   "u1",
   "+",
   "1",
   ",",
   "u",
   "]",
   "for",
   "u1",
   "in",
   "range",
   "(",
   "(",
   "p",
   "-",
   "1",
   ")",
   "-",
   "1",
   ",",
   "u",
   ")",
   ")",
   "p",
   "=",
   "num_part",
   "# Find the optimal upper bound index of the 2nd right-most partition given",
   "# the number of partitions (p).",
   "total_nfps",
   ",",
   "u",
   "=",
   "min",
   "(",
   "(",
   "cost",
   "[",
   "u1",
   ",",
   "p2i",
   "(",
   "p",
   "-",
   "1",
   ")",
   "]",
   "+",
   "nfps",
   "[",
   "u1",
   "+",
   "1",
   ",",
   "len",
   "(",
   "sizes",
   ")",
   "-",
   "1",
   "]",
   ",",
   "u1",
   ")",
   "for",
   "u1",
   "in",
   "range",
   "(",
   "(",
   "p",
   "-",
   "1",
   ")",
   "-",
   "1",
   ",",
   "len",
   "(",
   "sizes",
   ")",
   "-",
   "1",
   ")",
   ")",
   "partitions",
   "=",
   "[",
   "(",
   "sizes",
   "[",
   "u",
   "+",
   "1",
   "]",
   ",",
   "sizes",
   "[",
   "-",
   "1",
   "]",
   ")",
   ",",
   "]",
   "p",
   "-=",
   "1",
   "# Back track to find the best partitions.",
   "while",
   "p",
   ">",
   "1",
   ":",
   "# Find the optimal upper bound index of the 2nd right-most partition",
   "# givne the number of partitions (p) and upper bound index (u) in this",
   "# sub-problem.",
   "_",
   ",",
   "u1_best",
   "=",
   "min",
   "(",
   "(",
   "cost",
   "[",
   "u1",
   ",",
   "p2i",
   "(",
   "p",
   ")",
   "]",
   "+",
   "nfps",
   "[",
   "u1",
   "+",
   "1",
   ",",
   "u",
   "]",
   ",",
   "u1",
   ")",
   "for",
   "u1",
   "in",
   "range",
   "(",
   "(",
   "p",
   "-",
   "1",
   ")",
   "-",
   "1",
   ",",
   "u",
   ")",
   ")",
   "partitions",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "(",
   "sizes",
   "[",
   "u1_best",
   "+",
   "1",
   "]",
   ",",
   "sizes",
   "[",
   "u",
   "]",
   ")",
   ")",
   "u",
   "=",
   "u1_best",
   "p",
   "-=",
   "1",
   "partitions",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "(",
   "sizes",
   "[",
   "0",
   "]",
   ",",
   "sizes",
   "[",
   "u",
   "]",
   ")",
   ")",
   "return",
   "[",
   "partitions",
   ",",
   "total_nfps",
   ",",
   "cost",
   "]"
  ]
 },
 {
  "idx": "maxmin-974",
  "nl_tokens": [
   "Evaluates",
   "int_tau",
   "f",
   "(",
   "t",
   "+",
   "tau",
   ")",
   "*",
   "g",
   "(",
   "tau",
   ")",
   "or",
   "int_tau",
   "f",
   "(",
   "t",
   "-",
   "tau",
   ")",
   "g",
   "(",
   "tau",
   ")",
   "if",
   "inverse",
   "time",
   "is",
   "TRUE"
  ],
  "pl_tokens": [
   "def",
   "_convolution_integrand",
   "(",
   "t_val",
   ",",
   "f",
   ",",
   "g",
   ",",
   "inverse_time",
   "=",
   "None",
   ",",
   "return_log",
   "=",
   "False",
   ")",
   ":",
   "if",
   "inverse_time",
   "is",
   "None",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Inverse time argument must be set!\"",
   ")",
   "# determine integration boundaries:",
   "if",
   "inverse_time",
   ":",
   "## tau>g.xmin and t-tau<f.xmax",
   "tau_min",
   "=",
   "<mask>",
   "(",
   "t_val",
   "-",
   "f",
   ".",
   "xmax",
   ",",
   "g",
   ".",
   "xmin",
   ")",
   "## tau<g.xmax and t-tau>f.xmin",
   "tau_max",
   "=",
   "min",
   "(",
   "t_val",
   "-",
   "f",
   ".",
   "xmin",
   ",",
   "g",
   ".",
   "xmax",
   ")",
   "else",
   ":",
   "## tau>g.xmin and t+tau>f.xmin",
   "tau_min",
   "=",
   "max",
   "(",
   "f",
   ".",
   "xmin",
   "-",
   "t_val",
   ",",
   "g",
   ".",
   "xmin",
   ")",
   "## tau<g.xmax and t+tau<f.xmax",
   "tau_max",
   "=",
   "min",
   "(",
   "f",
   ".",
   "xmax",
   "-",
   "t_val",
   ",",
   "g",
   ".",
   "xmax",
   ")",
   "#print(tau_min, tau_max)",
   "if",
   "tau_max",
   "<=",
   "tau_min",
   ":",
   "if",
   "return_log",
   ":",
   "return",
   "ttconf",
   ".",
   "BIG_NUMBER",
   "else",
   ":",
   "return",
   "0.0",
   "#  functions do not overlap",
   "else",
   ":",
   "# create the tau-grid for the interpolation object in the overlap region",
   "if",
   "inverse_time",
   ":",
   "tau",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "g",
   ".",
   "x",
   ",",
   "t_val",
   "-",
   "f",
   ".",
   "x",
   ",",
   "[",
   "tau_min",
   ",",
   "tau_max",
   "]",
   ")",
   ")",
   ")",
   "else",
   ":",
   "tau",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "g",
   ".",
   "x",
   ",",
   "f",
   ".",
   "x",
   "-",
   "t_val",
   ",",
   "[",
   "tau_min",
   ",",
   "tau_max",
   "]",
   ")",
   ")",
   ")",
   "tau",
   "=",
   "tau",
   "[",
   "(",
   "tau",
   ">",
   "tau_min",
   "-",
   "ttconf",
   ".",
   "TINY_NUMBER",
   ")",
   "&",
   "(",
   "tau",
   "<",
   "tau_max",
   "+",
   "ttconf",
   ".",
   "TINY_NUMBER",
   ")",
   "]",
   "if",
   "len",
   "(",
   "tau",
   ")",
   "<",
   "10",
   ":",
   "tau",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "tau_min",
   ",",
   "tau_max",
   ",",
   "10",
   ")",
   "if",
   "inverse_time",
   ":",
   "# add negative logarithms",
   "tnode",
   "=",
   "t_val",
   "-",
   "tau",
   "fg",
   "=",
   "f",
   "(",
   "tnode",
   ")",
   "+",
   "g",
   "(",
   "tau",
   ",",
   "tnode",
   "=",
   "tnode",
   ")",
   "else",
   ":",
   "fg",
   "=",
   "f",
   "(",
   "t_val",
   "+",
   "tau",
   ")",
   "+",
   "g",
   "(",
   "tau",
   ",",
   "tnode",
   "=",
   "t_val",
   ")",
   "# create the interpolation object on this grid",
   "FG",
   "=",
   "Distribution",
   "(",
   "tau",
   ",",
   "fg",
   ",",
   "is_log",
   "=",
   "True",
   ",",
   "min_width",
   "=",
   "np",
   ".",
   "max",
   "(",
   "[",
   "f",
   ".",
   "min_width",
   ",",
   "g",
   ".",
   "min_width",
   "]",
   ")",
   ",",
   "kind",
   "=",
   "'linear'",
   ",",
   "assume_sorted",
   "=",
   "True",
   ")",
   "return",
   "FG"
  ]
 },
 {
  "idx": "maxmin-975",
  "nl_tokens": [
   "Assess",
   "the",
   "width",
   "of",
   "the",
   "probability",
   "distribution",
   ".",
   "This",
   "returns",
   "full",
   "-",
   "width",
   "-",
   "half",
   "-",
   "max"
  ],
  "pl_tokens": [
   "def",
   "calc_fwhm",
   "(",
   "distribution",
   ",",
   "is_neg_log",
   "=",
   "True",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "distribution",
   ",",
   "interp1d",
   ")",
   ":",
   "if",
   "is_neg_log",
   ":",
   "ymin",
   "=",
   "distribution",
   ".",
   "y",
   ".",
   "<mask>",
   "(",
   ")",
   "log_prob",
   "=",
   "distribution",
   ".",
   "y",
   "-",
   "ymin",
   "else",
   ":",
   "log_prob",
   "=",
   "-",
   "np",
   ".",
   "log",
   "(",
   "distribution",
   ".",
   "y",
   ")",
   "log_prob",
   "-=",
   "log_prob",
   ".",
   "min",
   "(",
   ")",
   "xvals",
   "=",
   "distribution",
   ".",
   "x",
   "elif",
   "isinstance",
   "(",
   "distribution",
   ",",
   "Distribution",
   ")",
   ":",
   "# Distribution always stores neg log-prob with the peak value subtracted",
   "xvals",
   "=",
   "distribution",
   ".",
   "_func",
   ".",
   "x",
   "log_prob",
   "=",
   "distribution",
   ".",
   "_func",
   ".",
   "y",
   "else",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Error in computing the FWHM for the distribution. \"",
   "\" The input should be either Distribution or interpolation object\"",
   ")",
   "L",
   "=",
   "xvals",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "# 0.69... is log(2), there is always one value for which this is true since",
   "# the minimum is subtracted",
   "tmp",
   "=",
   "np",
   ".",
   "where",
   "(",
   "log_prob",
   "<",
   "0.693147",
   ")",
   "[",
   "0",
   "]",
   "x_l",
   ",",
   "x_u",
   "=",
   "tmp",
   "[",
   "0",
   "]",
   ",",
   "tmp",
   "[",
   "-",
   "1",
   "]",
   "if",
   "L",
   "<",
   "2",
   ":",
   "print",
   "(",
   "\"Not enough points to compute FWHM: returning zero\"",
   ")",
   "return",
   "min",
   "(",
   "TINY_NUMBER",
   ",",
   "distribution",
   ".",
   "xmax",
   "-",
   "distribution",
   ".",
   "xmin",
   ")",
   "else",
   ":",
   "# need to guard against out-of-bounds errors",
   "return",
   "max",
   "(",
   "TINY_NUMBER",
   ",",
   "xvals",
   "[",
   "min",
   "(",
   "x_u",
   "+",
   "1",
   ",",
   "L",
   "-",
   "1",
   ")",
   "]",
   "-",
   "xvals",
   "[",
   "max",
   "(",
   "0",
   ",",
   "x_l",
   "-",
   "1",
   ")",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-976",
  "nl_tokens": [
   "Sets",
   "the",
   "blob",
   "dimmentions",
   "trying",
   "to",
   "read",
   "around",
   "1024",
   "MiB",
   "at",
   "a",
   "time",
   ".",
   "This",
   "is",
   "assuming",
   "a",
   "chunk",
   "is",
   "about",
   "1",
   "MiB",
   "."
  ],
  "pl_tokens": [
   "def",
   "__get_blob_dimensions",
   "(",
   "self",
   ",",
   "chunk_dim",
   ")",
   ":",
   "#Taking the size into consideration, but avoiding having multiple blobs within a single time bin.",
   "if",
   "self",
   ".",
   "selection_shape",
   "[",
   "self",
   ".",
   "freq_axis",
   "]",
   ">",
   "chunk_dim",
   "[",
   "self",
   ".",
   "freq_axis",
   "]",
   "*",
   "MAX_BLOB_MB",
   ":",
   "freq_axis_size",
   "=",
   "self",
   ".",
   "selection_shape",
   "[",
   "self",
   ".",
   "freq_axis",
   "]",
   "#             while freq_axis_size > chunk_dim[self.freq_axis]*MAX_BLOB_MB:",
   "#                 freq_axis_size /= 2",
   "time_axis_size",
   "=",
   "1",
   "else",
   ":",
   "freq_axis_size",
   "=",
   "self",
   ".",
   "selection_shape",
   "[",
   "self",
   ".",
   "freq_axis",
   "]",
   "time_axis_size",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "chunk_dim",
   "[",
   "self",
   ".",
   "time_axis",
   "]",
   "*",
   "MAX_BLOB_MB",
   "*",
   "chunk_dim",
   "[",
   "self",
   ".",
   "freq_axis",
   "]",
   "/",
   "freq_axis_size",
   ",",
   "self",
   ".",
   "selection_shape",
   "[",
   "self",
   ".",
   "time_axis",
   "]",
   "]",
   ")",
   "blob_dim",
   "=",
   "(",
   "int",
   "(",
   "time_axis_size",
   ")",
   ",",
   "1",
   ",",
   "freq_axis_size",
   ")",
   "return",
   "blob_dim"
  ]
 },
 {
  "idx": "maxmin-977",
  "nl_tokens": [
   ":",
   "type",
   "bunch_stack",
   ":",
   "list",
   "of",
   "list"
  ],
  "pl_tokens": [
   "def",
   "_pad_zeros",
   "(",
   "self",
   ",",
   "bunch_stack",
   ")",
   ":",
   "min_len",
   "=",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "bunch_stack",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "bunch_stack",
   ")",
   ")",
   ":",
   "bunch_stack",
   "[",
   "i",
   "]",
   "=",
   "bunch_stack",
   "[",
   "i",
   "]",
   "[",
   ":",
   "min_len",
   "]"
  ]
 },
 {
  "idx": "maxmin-978",
  "nl_tokens": [
   "Convenience",
   "function",
   "to",
   "output",
   "headers",
   "in",
   "a",
   "formatted",
   "fashion",
   "to",
   "a",
   "file",
   "-",
   "like",
   "fp",
   "optionally",
   "muting",
   "any",
   "headers",
   "in",
   "the",
   "mute",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "write_headers",
   "(",
   "self",
   ",",
   "fp",
   ",",
   "headers",
   ",",
   "mute",
   "=",
   "None",
   ")",
   ":",
   "if",
   "headers",
   ":",
   "if",
   "not",
   "mute",
   ":",
   "mute",
   "=",
   "[",
   "]",
   "fmt",
   "=",
   "'%%-%ds %%s\\n'",
   "%",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "k",
   ")",
   "for",
   "k",
   "in",
   "headers",
   ")",
   "+",
   "1",
   ")",
   "for",
   "key",
   "in",
   "sorted",
   "(",
   "headers",
   ")",
   ":",
   "if",
   "key",
   "in",
   "mute",
   ":",
   "continue",
   "fp",
   ".",
   "write",
   "(",
   "fmt",
   "%",
   "(",
   "key",
   ".",
   "title",
   "(",
   ")",
   "+",
   "':'",
   ",",
   "headers",
   "[",
   "key",
   "]",
   ")",
   ")",
   "fp",
   ".",
   "flush",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-979",
  "nl_tokens": [
   "Returns",
   "a",
   "dataframe",
   "of",
   "the",
   "play",
   "-",
   "by",
   "-",
   "play",
   "data",
   "from",
   "the",
   "game",
   "."
  ],
  "pl_tokens": [
   "def",
   "pbp",
   "(",
   "self",
   ",",
   "dense_lineups",
   "=",
   "False",
   ",",
   "sparse_lineups",
   "=",
   "False",
   ")",
   ":",
   "try",
   ":",
   "doc",
   "=",
   "self",
   ".",
   "get_subpage_doc",
   "(",
   "'pbp'",
   ")",
   "except",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Error fetching PBP subpage for boxscore {}'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "boxscore_id",
   ")",
   ")",
   "table",
   "=",
   "doc",
   "(",
   "'table#pbp'",
   ")",
   "trs",
   "=",
   "[",
   "tr",
   "for",
   "tr",
   "in",
   "table",
   "(",
   "'tr'",
   ")",
   ".",
   "items",
   "(",
   ")",
   "if",
   "(",
   "not",
   "tr",
   ".",
   "attr",
   "[",
   "'class'",
   "]",
   "or",
   "# regular data rows",
   "tr",
   ".",
   "attr",
   "[",
   "'id'",
   "]",
   "and",
   "tr",
   ".",
   "attr",
   "[",
   "'id'",
   "]",
   ".",
   "startswith",
   "(",
   "'q'",
   ")",
   ")",
   "# qtr bounds",
   "]",
   "rows",
   "=",
   "[",
   "tr",
   ".",
   "children",
   "(",
   "'td'",
   ")",
   "for",
   "tr",
   "in",
   "trs",
   "]",
   "n_rows",
   "=",
   "len",
   "(",
   "trs",
   ")",
   "data",
   "=",
   "[",
   "]",
   "cur_qtr",
   "=",
   "0",
   "bsid",
   "=",
   "self",
   ".",
   "boxscore_id",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n_rows",
   ")",
   ":",
   "tr",
   "=",
   "trs",
   "[",
   "i",
   "]",
   "row",
   "=",
   "rows",
   "[",
   "i",
   "]",
   "p",
   "=",
   "{",
   "}",
   "# increment cur_qtr when we hit a new quarter",
   "if",
   "tr",
   ".",
   "attr",
   "[",
   "'id'",
   "]",
   "and",
   "tr",
   ".",
   "attr",
   "[",
   "'id'",
   "]",
   ".",
   "startswith",
   "(",
   "'q'",
   ")",
   ":",
   "assert",
   "int",
   "(",
   "tr",
   ".",
   "attr",
   "[",
   "'id'",
   "]",
   "[",
   "1",
   ":",
   "]",
   ")",
   "==",
   "cur_qtr",
   "+",
   "1",
   "cur_qtr",
   "+=",
   "1",
   "continue",
   "# add time of play to entry",
   "t_str",
   "=",
   "row",
   ".",
   "eq",
   "(",
   "0",
   ")",
   ".",
   "text",
   "(",
   ")",
   "t_regex",
   "=",
   "r'(\\d+):(\\d+)\\.(\\d+)'",
   "mins",
   ",",
   "secs",
   ",",
   "tenths",
   "=",
   "map",
   "(",
   "int",
   ",",
   "re",
   ".",
   "match",
   "(",
   "t_regex",
   ",",
   "t_str",
   ")",
   ".",
   "groups",
   "(",
   ")",
   ")",
   "endQ",
   "=",
   "(",
   "12",
   "*",
   "60",
   "*",
   "<mask>",
   "(",
   "cur_qtr",
   ",",
   "4",
   ")",
   "+",
   "5",
   "*",
   "60",
   "*",
   "(",
   "cur_qtr",
   "-",
   "4",
   "if",
   "cur_qtr",
   ">",
   "4",
   "else",
   "0",
   ")",
   ")",
   "secsElapsed",
   "=",
   "endQ",
   "-",
   "(",
   "60",
   "*",
   "mins",
   "+",
   "secs",
   "+",
   "0.1",
   "*",
   "tenths",
   ")",
   "p",
   "[",
   "'secs_elapsed'",
   "]",
   "=",
   "secsElapsed",
   "p",
   "[",
   "'clock_time'",
   "]",
   "=",
   "t_str",
   "p",
   "[",
   "'quarter'",
   "]",
   "=",
   "cur_qtr",
   "# handle single play description",
   "# ex: beginning/end of quarter, jump ball",
   "if",
   "row",
   ".",
   "length",
   "==",
   "2",
   ":",
   "desc",
   "=",
   "row",
   ".",
   "eq",
   "(",
   "1",
   ")",
   "# handle jump balls",
   "if",
   "desc",
   ".",
   "text",
   "(",
   ")",
   ".",
   "lower",
   "(",
   ")",
   ".",
   "startswith",
   "(",
   "'jump ball: '",
   ")",
   ":",
   "p",
   "[",
   "'is_jump_ball'",
   "]",
   "=",
   "True",
   "jb_str",
   "=",
   "sportsref",
   ".",
   "utils",
   ".",
   "flatten_links",
   "(",
   "desc",
   ")",
   "p",
   ".",
   "update",
   "(",
   "sportsref",
   ".",
   "nba",
   ".",
   "pbp",
   ".",
   "parse_play",
   "(",
   "bsid",
   ",",
   "jb_str",
   ",",
   "None",
   ")",
   ")",
   "# ignore rows marking beginning/end of quarters",
   "elif",
   "(",
   "desc",
   ".",
   "text",
   "(",
   ")",
   ".",
   "lower",
   "(",
   ")",
   ".",
   "startswith",
   "(",
   "'start of '",
   ")",
   "or",
   "desc",
   ".",
   "text",
   "(",
   ")",
   ".",
   "lower",
   "(",
   ")",
   ".",
   "startswith",
   "(",
   "'end of '",
   ")",
   ")",
   ":",
   "continue",
   "# if another case, log and continue",
   "else",
   ":",
   "if",
   "not",
   "desc",
   ".",
   "text",
   "(",
   ")",
   ".",
   "lower",
   "(",
   ")",
   ".",
   "startswith",
   "(",
   "'end of '",
   ")",
   ":",
   "print",
   "(",
   "'{}, Q{}, {} other case: {}'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "boxscore_id",
   ",",
   "cur_qtr",
   ",",
   "t_str",
   ",",
   "desc",
   ".",
   "text",
   "(",
   ")",
   ")",
   ")",
   "continue",
   "# handle team play description",
   "# ex: shot, turnover, rebound, foul, sub, etc.",
   "elif",
   "row",
   ".",
   "length",
   "==",
   "6",
   ":",
   "aw_desc",
   ",",
   "hm_desc",
   "=",
   "row",
   ".",
   "eq",
   "(",
   "1",
   ")",
   ",",
   "row",
   ".",
   "eq",
   "(",
   "5",
   ")",
   "is_hm_play",
   "=",
   "bool",
   "(",
   "hm_desc",
   ".",
   "text",
   "(",
   ")",
   ")",
   "desc",
   "=",
   "hm_desc",
   "if",
   "is_hm_play",
   "else",
   "aw_desc",
   "desc",
   "=",
   "sportsref",
   ".",
   "utils",
   ".",
   "flatten_links",
   "(",
   "desc",
   ")",
   "# parse the play",
   "new_p",
   "=",
   "sportsref",
   ".",
   "nba",
   ".",
   "pbp",
   ".",
   "parse_play",
   "(",
   "bsid",
   ",",
   "desc",
   ",",
   "is_hm_play",
   ")",
   "if",
   "not",
   "new_p",
   ":",
   "continue",
   "elif",
   "isinstance",
   "(",
   "new_p",
   ",",
   "list",
   ")",
   ":",
   "# this happens when a row needs to be expanded to 2 rows;",
   "# ex: double personal foul -> two PF rows",
   "# first, update and append the first row",
   "orig_p",
   "=",
   "dict",
   "(",
   "p",
   ")",
   "p",
   ".",
   "update",
   "(",
   "new_p",
   "[",
   "0",
   "]",
   ")",
   "data",
   ".",
   "append",
   "(",
   "p",
   ")",
   "# second, set up the second row to be appended below",
   "p",
   "=",
   "orig_p",
   "new_p",
   "=",
   "new_p",
   "[",
   "1",
   "]",
   "elif",
   "new_p",
   ".",
   "get",
   "(",
   "'is_error'",
   ")",
   ":",
   "print",
   "(",
   "\"can't parse: {}, boxscore: {}\"",
   ".",
   "format",
   "(",
   "desc",
   ",",
   "self",
   ".",
   "boxscore_id",
   ")",
   ")",
   "# import pdb; pdb.set_trace()",
   "p",
   ".",
   "update",
   "(",
   "new_p",
   ")",
   "# otherwise, I don't know what this was",
   "else",
   ":",
   "raise",
   "Exception",
   "(",
   "(",
   "\"don't know how to handle row of length {}\"",
   ".",
   "format",
   "(",
   "row",
   ".",
   "length",
   ")",
   ")",
   ")",
   "data",
   ".",
   "append",
   "(",
   "p",
   ")",
   "# convert to DataFrame and clean columns",
   "df",
   "=",
   "pd",
   ".",
   "DataFrame",
   ".",
   "from_records",
   "(",
   "data",
   ")",
   "df",
   ".",
   "sort_values",
   "(",
   "'secs_elapsed'",
   ",",
   "inplace",
   "=",
   "True",
   ",",
   "kind",
   "=",
   "'mergesort'",
   ")",
   "df",
   "=",
   "sportsref",
   ".",
   "nba",
   ".",
   "pbp",
   ".",
   "clean_features",
   "(",
   "df",
   ")",
   "# add columns for home team, away team, boxscore_id, date",
   "away",
   ",",
   "home",
   "=",
   "self",
   ".",
   "away",
   "(",
   ")",
   ",",
   "self",
   ".",
   "home",
   "(",
   ")",
   "df",
   "[",
   "'home'",
   "]",
   "=",
   "home",
   "df",
   "[",
   "'away'",
   "]",
   "=",
   "away",
   "df",
   "[",
   "'boxscore_id'",
   "]",
   "=",
   "self",
   ".",
   "boxscore_id",
   "df",
   "[",
   "'season'",
   "]",
   "=",
   "self",
   ".",
   "season",
   "(",
   ")",
   "date",
   "=",
   "self",
   ".",
   "date",
   "(",
   ")",
   "df",
   "[",
   "'year'",
   "]",
   "=",
   "date",
   ".",
   "year",
   "df",
   "[",
   "'month'",
   "]",
   "=",
   "date",
   ".",
   "month",
   "df",
   "[",
   "'day'",
   "]",
   "=",
   "date",
   ".",
   "day",
   "def",
   "_clean_rebs",
   "(",
   "df",
   ")",
   ":",
   "df",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "no_reb_after",
   "=",
   "(",
   "(",
   "df",
   ".",
   "fta_num",
   "<",
   "df",
   ".",
   "tot_fta",
   ")",
   "|",
   "df",
   ".",
   "is_ftm",
   "|",
   "df",
   ".",
   "get",
   "(",
   "'is_tech_fta'",
   ",",
   "False",
   ")",
   ")",
   ".",
   "shift",
   "(",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   "no_reb_before",
   "=",
   "(",
   "(",
   "df",
   ".",
   "fta_num",
   "==",
   "df",
   ".",
   "tot_fta",
   ")",
   ")",
   ".",
   "shift",
   "(",
   "-",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   "se_end_qtr",
   "=",
   "df",
   ".",
   "loc",
   "[",
   "df",
   ".",
   "clock_time",
   "==",
   "'0:00.0'",
   ",",
   "'secs_elapsed'",
   "]",
   ".",
   "unique",
   "(",
   ")",
   "no_reb_when",
   "=",
   "df",
   ".",
   "secs_elapsed",
   ".",
   "isin",
   "(",
   "se_end_qtr",
   ")",
   "drop_mask",
   "=",
   "(",
   "(",
   "df",
   ".",
   "rebounder",
   "==",
   "'Team'",
   ")",
   "&",
   "(",
   "no_reb_after",
   "|",
   "no_reb_before",
   "|",
   "no_reb_when",
   ")",
   ")",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "0",
   "]",
   "df",
   ".",
   "drop",
   "(",
   "drop_mask",
   ",",
   "axis",
   "=",
   "0",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "df",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "return",
   "df",
   "# get rid of 'rebounds' after FTM, non-final FTA, or tech FTA",
   "df",
   "=",
   "_clean_rebs",
   "(",
   "df",
   ")",
   "# track possession number for each possession",
   "# TODO: see 201604130PHO, secs_elapsed == 2756",
   "# things that end a poss:",
   "# FGM, dreb, TO, end of Q, made last FT, lost jump ball,",
   "# def goaltending, shot clock violation",
   "new_poss",
   "=",
   "(",
   "df",
   ".",
   "off_team",
   "==",
   "df",
   ".",
   "home",
   ")",
   ".",
   "diff",
   "(",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   "# def rebound considered part of the new possession",
   "df",
   "[",
   "'poss_id'",
   "]",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "new_poss",
   ")",
   "+",
   "df",
   ".",
   "is_dreb",
   "# create poss_id with rebs -> new possessions for granular groupbys",
   "poss_id_reb",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "new_poss",
   "|",
   "df",
   ".",
   "is_reb",
   ")",
   "# make sure plays with the same clock time are in the right order",
   "# TODO: make sort_cols depend on what cols are in the play?",
   "# or combine related plays, like and-1 shot and foul",
   "# issues come up with FGA after timeout in 201604130LAL",
   "# issues come up with PF between FGA and DREB in 201604120SAS",
   "sort_cols",
   "=",
   "[",
   "col",
   "for",
   "col",
   "in",
   "[",
   "'is_reb'",
   ",",
   "'is_fga'",
   ",",
   "'is_pf'",
   ",",
   "'is_tech_foul'",
   ",",
   "'is_ejection'",
   ",",
   "'is_tech_fta'",
   ",",
   "'is_timeout'",
   ",",
   "'is_pf_fta'",
   ",",
   "'fta_num'",
   ",",
   "'is_viol'",
   ",",
   "'is_to'",
   ",",
   "'is_jump_ball'",
   ",",
   "'is_sub'",
   "]",
   "if",
   "col",
   "in",
   "df",
   ".",
   "columns",
   "]",
   "asc_true",
   "=",
   "[",
   "'fta_num'",
   "]",
   "ascend",
   "=",
   "[",
   "(",
   "col",
   "in",
   "asc_true",
   ")",
   "for",
   "col",
   "in",
   "sort_cols",
   "]",
   "for",
   "label",
   ",",
   "group",
   "in",
   "df",
   ".",
   "groupby",
   "(",
   "[",
   "df",
   ".",
   "secs_elapsed",
   ",",
   "poss_id_reb",
   "]",
   ")",
   ":",
   "if",
   "len",
   "(",
   "group",
   ")",
   ">",
   "1",
   ":",
   "df",
   ".",
   "loc",
   "[",
   "group",
   ".",
   "index",
   ",",
   ":",
   "]",
   "=",
   "group",
   ".",
   "sort_values",
   "(",
   "sort_cols",
   ",",
   "ascending",
   "=",
   "ascend",
   ",",
   "kind",
   "=",
   "'mergesort'",
   ")",
   ".",
   "values",
   "# 2nd pass: get rid of 'rebounds' after FTM, non-final FTA, etc.",
   "df",
   "=",
   "_clean_rebs",
   "(",
   "df",
   ")",
   "# makes sure off/def and poss_id are correct for subs after rearranging",
   "# some possessions above",
   "df",
   ".",
   "loc",
   "[",
   "df",
   "[",
   "'is_sub'",
   "]",
   ",",
   "[",
   "'off_team'",
   ",",
   "'def_team'",
   ",",
   "'poss_id'",
   "]",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "df",
   ".",
   "off_team",
   ".",
   "fillna",
   "(",
   "method",
   "=",
   "'bfill'",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "df",
   ".",
   "def_team",
   ".",
   "fillna",
   "(",
   "method",
   "=",
   "'bfill'",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "df",
   ".",
   "poss_id",
   ".",
   "fillna",
   "(",
   "method",
   "=",
   "'bfill'",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "# make off_team and def_team NaN for jump balls",
   "if",
   "'is_jump_ball'",
   "in",
   "df",
   ".",
   "columns",
   ":",
   "df",
   ".",
   "loc",
   "[",
   "df",
   "[",
   "'is_jump_ball'",
   "]",
   ",",
   "[",
   "'off_team'",
   ",",
   "'def_team'",
   "]",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "# make sure 'off_team' is always the team shooting FTs, even on techs",
   "# (impt for keeping track of the score)",
   "if",
   "'is_tech_fta'",
   "in",
   "df",
   ".",
   "columns",
   ":",
   "tech_fta",
   "=",
   "df",
   "[",
   "'is_tech_fta'",
   "]",
   "df",
   ".",
   "loc",
   "[",
   "tech_fta",
   ",",
   "'off_team'",
   "]",
   "=",
   "df",
   ".",
   "loc",
   "[",
   "tech_fta",
   ",",
   "'fta_team'",
   "]",
   "df",
   ".",
   "loc",
   "[",
   "tech_fta",
   ",",
   "'def_team'",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "df",
   ".",
   "loc",
   "[",
   "tech_fta",
   ",",
   "'off_team'",
   "]",
   "==",
   "home",
   ",",
   "away",
   ",",
   "home",
   ")",
   "df",
   ".",
   "drop",
   "(",
   "'fta_team'",
   ",",
   "axis",
   "=",
   "1",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "# redefine poss_id_reb",
   "new_poss",
   "=",
   "(",
   "df",
   ".",
   "off_team",
   "==",
   "df",
   ".",
   "home",
   ")",
   ".",
   "diff",
   "(",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   "poss_id_reb",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "new_poss",
   "|",
   "df",
   ".",
   "is_reb",
   ")",
   "# get rid of redundant subs",
   "for",
   "(",
   "se",
   ",",
   "tm",
   ",",
   "pnum",
   ")",
   ",",
   "group",
   "in",
   "df",
   "[",
   "df",
   ".",
   "is_sub",
   "]",
   ".",
   "groupby",
   "(",
   "[",
   "df",
   ".",
   "secs_elapsed",
   ",",
   "df",
   ".",
   "sub_team",
   ",",
   "poss_id_reb",
   "]",
   ")",
   ":",
   "if",
   "len",
   "(",
   "group",
   ")",
   ">",
   "1",
   ":",
   "sub_in",
   "=",
   "set",
   "(",
   ")",
   "sub_out",
   "=",
   "set",
   "(",
   ")",
   "# first, figure out who's in and who's out after subs",
   "for",
   "i",
   ",",
   "row",
   "in",
   "group",
   ".",
   "iterrows",
   "(",
   ")",
   ":",
   "if",
   "row",
   "[",
   "'sub_in'",
   "]",
   "in",
   "sub_out",
   ":",
   "sub_out",
   ".",
   "remove",
   "(",
   "row",
   "[",
   "'sub_in'",
   "]",
   ")",
   "else",
   ":",
   "sub_in",
   ".",
   "add",
   "(",
   "row",
   "[",
   "'sub_in'",
   "]",
   ")",
   "if",
   "row",
   "[",
   "'sub_out'",
   "]",
   "in",
   "sub_in",
   ":",
   "sub_in",
   ".",
   "remove",
   "(",
   "row",
   "[",
   "'sub_out'",
   "]",
   ")",
   "else",
   ":",
   "sub_out",
   ".",
   "add",
   "(",
   "row",
   "[",
   "'sub_out'",
   "]",
   ")",
   "assert",
   "len",
   "(",
   "sub_in",
   ")",
   "==",
   "len",
   "(",
   "sub_out",
   ")",
   "# second, add those subs",
   "n_subs",
   "=",
   "len",
   "(",
   "sub_in",
   ")",
   "for",
   "idx",
   ",",
   "p_in",
   ",",
   "p_out",
   "in",
   "zip",
   "(",
   "group",
   ".",
   "index",
   "[",
   ":",
   "n_subs",
   "]",
   ",",
   "sub_in",
   ",",
   "sub_out",
   ")",
   ":",
   "assert",
   "df",
   ".",
   "loc",
   "[",
   "idx",
   ",",
   "'is_sub'",
   "]",
   "df",
   ".",
   "loc",
   "[",
   "idx",
   ",",
   "'sub_in'",
   "]",
   "=",
   "p_in",
   "df",
   ".",
   "loc",
   "[",
   "idx",
   ",",
   "'sub_out'",
   "]",
   "=",
   "p_out",
   "df",
   ".",
   "loc",
   "[",
   "idx",
   ",",
   "'sub_team'",
   "]",
   "=",
   "tm",
   "df",
   ".",
   "loc",
   "[",
   "idx",
   ",",
   "'detail'",
   "]",
   "=",
   "(",
   "'{} enters the game for {}'",
   ".",
   "format",
   "(",
   "p_in",
   ",",
   "p_out",
   ")",
   ")",
   "# third, if applicable, remove old sub entries when there are",
   "# redundant subs",
   "n_extra",
   "=",
   "len",
   "(",
   "group",
   ")",
   "-",
   "len",
   "(",
   "sub_in",
   ")",
   "if",
   "n_extra",
   ":",
   "extra_idxs",
   "=",
   "group",
   ".",
   "index",
   "[",
   "-",
   "n_extra",
   ":",
   "]",
   "df",
   ".",
   "drop",
   "(",
   "extra_idxs",
   ",",
   "axis",
   "=",
   "0",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "df",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "# add column for pts and score",
   "df",
   "[",
   "'pts'",
   "]",
   "=",
   "(",
   "df",
   "[",
   "'is_ftm'",
   "]",
   "+",
   "2",
   "*",
   "df",
   "[",
   "'is_fgm'",
   "]",
   "+",
   "(",
   "df",
   "[",
   "'is_fgm'",
   "]",
   "&",
   "df",
   "[",
   "'is_three'",
   "]",
   ")",
   ")",
   "df",
   "[",
   "'hm_pts'",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "df",
   ".",
   "off_team",
   "==",
   "df",
   ".",
   "home",
   ",",
   "df",
   ".",
   "pts",
   ",",
   "0",
   ")",
   "df",
   "[",
   "'aw_pts'",
   "]",
   "=",
   "np",
   ".",
   "where",
   "(",
   "df",
   ".",
   "off_team",
   "==",
   "df",
   ".",
   "away",
   ",",
   "df",
   ".",
   "pts",
   ",",
   "0",
   ")",
   "df",
   "[",
   "'hm_score'",
   "]",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "df",
   "[",
   "'hm_pts'",
   "]",
   ")",
   "df",
   "[",
   "'aw_score'",
   "]",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "df",
   "[",
   "'aw_pts'",
   "]",
   ")",
   "# more helpful columns",
   "# \"play\" is differentiated from \"poss\" by counting OReb as new play",
   "# \"plays\" end with non-and1 FGA, TO, last non-tech FTA, or end of qtr",
   "# (or double lane viol)",
   "new_qtr",
   "=",
   "df",
   ".",
   "quarter",
   ".",
   "diff",
   "(",
   ")",
   ".",
   "shift",
   "(",
   "-",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   ".",
   "astype",
   "(",
   "bool",
   ")",
   "and1",
   "=",
   "(",
   "df",
   ".",
   "is_fgm",
   "&",
   "df",
   ".",
   "is_pf",
   ".",
   "shift",
   "(",
   "-",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   "&",
   "df",
   ".",
   "is_fta",
   ".",
   "shift",
   "(",
   "-",
   "2",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   "&",
   "~",
   "df",
   ".",
   "secs_elapsed",
   ".",
   "diff",
   "(",
   ")",
   ".",
   "shift",
   "(",
   "-",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "False",
   ")",
   ".",
   "astype",
   "(",
   "bool",
   ")",
   ")",
   "double_lane",
   "=",
   "(",
   "df",
   ".",
   "get",
   "(",
   "'viol_type'",
   ")",
   "==",
   "'double lane'",
   ")",
   "new_play",
   "=",
   "df",
   ".",
   "eval",
   "(",
   "'(is_fga & ~(@and1)) | is_to | @new_qtr |'",
   "'(is_fta & ~is_tech_fta & fta_num == tot_fta) |'",
   "'@double_lane'",
   ")",
   "df",
   "[",
   "'play_id'",
   "]",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "new_play",
   ")",
   ".",
   "shift",
   "(",
   "1",
   ")",
   ".",
   "fillna",
   "(",
   "0",
   ")",
   "df",
   "[",
   "'hm_off'",
   "]",
   "=",
   "df",
   ".",
   "off_team",
   "==",
   "df",
   ".",
   "home",
   "# get lineup data",
   "if",
   "dense_lineups",
   ":",
   "df",
   "=",
   "pd",
   ".",
   "concat",
   "(",
   "(",
   "df",
   ",",
   "sportsref",
   ".",
   "nba",
   ".",
   "pbp",
   ".",
   "get_dense_lineups",
   "(",
   "df",
   ")",
   ")",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "if",
   "sparse_lineups",
   ":",
   "df",
   "=",
   "pd",
   ".",
   "concat",
   "(",
   "(",
   "df",
   ",",
   "sportsref",
   ".",
   "nba",
   ".",
   "pbp",
   ".",
   "get_sparse_lineups",
   "(",
   "df",
   ")",
   ")",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "# TODO: add shot clock as a feature",
   "return",
   "df"
  ]
 },
 {
  "idx": "maxmin-980",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "maximum",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "nmax",
   "(",
   "wave",
   ",",
   "indep_min",
   "=",
   "None",
   ",",
   "indep_max",
   "=",
   "None",
   ")",
   ":",
   "ret",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "wave",
   ")",
   "_bound_waveform",
   "(",
   "ret",
   ",",
   "indep_min",
   ",",
   "indep_max",
   ")",
   "return",
   "np",
   ".",
   "<mask>",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")"
  ]
 },
 {
  "idx": "maxmin-981",
  "nl_tokens": [
   "Evaluates",
   "max_tau",
   "f",
   "(",
   "t",
   "+",
   "tau",
   ")",
   "*",
   "g",
   "(",
   "tau",
   ")",
   "or",
   "max_tau",
   "f",
   "(",
   "t",
   "-",
   "tau",
   ")",
   "g",
   "(",
   "tau",
   ")",
   "if",
   "inverse",
   "time",
   "is",
   "TRUE"
  ],
  "pl_tokens": [
   "def",
   "_max_of_integrand",
   "(",
   "t_val",
   ",",
   "f",
   ",",
   "g",
   ",",
   "inverse_time",
   "=",
   "None",
   ",",
   "return_log",
   "=",
   "False",
   ")",
   ":",
   "# return log is always True",
   "FG",
   "=",
   "_convolution_integrand",
   "(",
   "t_val",
   ",",
   "f",
   ",",
   "g",
   ",",
   "inverse_time",
   ",",
   "return_log",
   "=",
   "True",
   ")",
   "if",
   "FG",
   "==",
   "ttconf",
   ".",
   "BIG_NUMBER",
   ":",
   "res",
   "=",
   "ttconf",
   ".",
   "BIG_NUMBER",
   ",",
   "0",
   "else",
   ":",
   "X",
   "=",
   "FG",
   ".",
   "x",
   "[",
   "FG",
   ".",
   "y",
   ".",
   "argmin",
   "(",
   ")",
   "]",
   "Y",
   "=",
   "FG",
   ".",
   "y",
   ".",
   "<mask>",
   "(",
   ")",
   "res",
   "=",
   "Y",
   ",",
   "X",
   "if",
   "not",
   "return_log",
   ":",
   "res",
   "[",
   "0",
   "]",
   "=",
   "np",
   ".",
   "log",
   "(",
   "res",
   "[",
   "0",
   "]",
   ")",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-982",
  "nl_tokens": [
   "Updates",
   "the",
   "cart",
   "s",
   "time",
   "last",
   "updated",
   "value",
   "which",
   "is",
   "used",
   "to",
   "determine",
   "whether",
   "the",
   "cart",
   "has",
   "reserved",
   "the",
   "items",
   "and",
   "discounts",
   "it",
   "holds",
   "."
  ],
  "pl_tokens": [
   "def",
   "_autoextend_reservation",
   "(",
   "self",
   ")",
   ":",
   "time",
   "=",
   "timezone",
   ".",
   "now",
   "(",
   ")",
   "# Calculate the residual of the _old_ reservation duration",
   "# if it's greater than what's in the cart now, keep it.",
   "time_elapsed_since_updated",
   "=",
   "(",
   "time",
   "-",
   "self",
   ".",
   "cart",
   ".",
   "time_last_updated",
   ")",
   "residual",
   "=",
   "self",
   ".",
   "cart",
   ".",
   "reservation_duration",
   "-",
   "time_elapsed_since_updated",
   "reservations",
   "=",
   "[",
   "datetime",
   ".",
   "timedelta",
   "(",
   "0",
   ")",
   ",",
   "residual",
   "]",
   "# If we have vouchers, we're entitled to an hour at minimum.",
   "if",
   "len",
   "(",
   "self",
   ".",
   "cart",
   ".",
   "vouchers",
   ".",
   "all",
   "(",
   ")",
   ")",
   ">=",
   "1",
   ":",
   "reservations",
   ".",
   "append",
   "(",
   "inventory",
   ".",
   "Voucher",
   ".",
   "RESERVATION_DURATION",
   ")",
   "# Else, it's the maximum of the included products",
   "items",
   "=",
   "commerce",
   ".",
   "ProductItem",
   ".",
   "objects",
   ".",
   "filter",
   "(",
   "cart",
   "=",
   "self",
   ".",
   "cart",
   ")",
   "agg",
   "=",
   "items",
   ".",
   "aggregate",
   "(",
   "Max",
   "(",
   "\"product__reservation_duration\"",
   ")",
   ")",
   "product_max",
   "=",
   "agg",
   "[",
   "\"product__reservation_duration__max\"",
   "]",
   "if",
   "product_max",
   "is",
   "not",
   "None",
   ":",
   "reservations",
   ".",
   "append",
   "(",
   "product_max",
   ")",
   "self",
   ".",
   "cart",
   ".",
   "time_last_updated",
   "=",
   "time",
   "self",
   ".",
   "cart",
   ".",
   "reservation_duration",
   "=",
   "<mask>",
   "(",
   "reservations",
   ")"
  ]
 },
 {
  "idx": "maxmin-983",
  "nl_tokens": [
   "Increment",
   "the",
   "monitor",
   "with",
   "N",
   "units",
   "worked",
   "and",
   "an",
   "optional",
   "message"
  ],
  "pl_tokens": [
   "def",
   "update",
   "(",
   "self",
   ",",
   "units",
   ":",
   "int",
   "=",
   "1",
   ",",
   "message",
   ":",
   "str",
   "=",
   "None",
   ")",
   ":",
   "if",
   "self",
   ".",
   "total",
   "is",
   "None",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Cannot call progressmonitor.update before calling begin\"",
   ")",
   "self",
   ".",
   "worked",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "total",
   ",",
   "self",
   ".",
   "worked",
   "+",
   "units",
   ")",
   "if",
   "message",
   ":",
   "self",
   ".",
   "message",
   "=",
   "message",
   "for",
   "listener",
   "in",
   "self",
   ".",
   "listeners",
   ":",
   "listener",
   "(",
   "self",
   ")"
  ]
 },
 {
  "idx": "maxmin-984",
  "nl_tokens": [
   "r",
   "Return",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "expressed",
   "in",
   "decibels",
   "."
  ],
  "pl_tokens": [
   "def",
   "db",
   "(",
   "wave",
   ")",
   ":",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "ValueError",
   ",",
   "\"Math domain error\"",
   ",",
   "bool",
   "(",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   ")",
   "<=",
   "0",
   ")",
   ")",
   ")",
   "ret",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "wave",
   ")",
   "ret",
   ".",
   "dep_units",
   "=",
   "\"dB\"",
   "ret",
   ".",
   "dep_name",
   "=",
   "\"db({0})\"",
   ".",
   "format",
   "(",
   "ret",
   ".",
   "dep_name",
   ")",
   "ret",
   ".",
   "_dep_vector",
   "=",
   "20.0",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")",
   ")",
   "return",
   "ret"
  ]
 },
 {
  "idx": "maxmin-985",
  "nl_tokens": [
   "Heartbeats",
   "update",
   "the",
   "job",
   "s",
   "entry",
   "in",
   "the",
   "database",
   "with",
   "a",
   "timestamp",
   "for",
   "the",
   "latest_heartbeat",
   "and",
   "allows",
   "for",
   "the",
   "job",
   "to",
   "be",
   "killed",
   "externally",
   ".",
   "This",
   "allows",
   "at",
   "the",
   "system",
   "level",
   "to",
   "monitor",
   "what",
   "is",
   "actually",
   "active",
   "."
  ],
  "pl_tokens": [
   "def",
   "heartbeat",
   "(",
   "self",
   ")",
   ":",
   "try",
   ":",
   "with",
   "create_session",
   "(",
   ")",
   "as",
   "session",
   ":",
   "job",
   "=",
   "session",
   ".",
   "query",
   "(",
   "BaseJob",
   ")",
   ".",
   "filter_by",
   "(",
   "id",
   "=",
   "self",
   ".",
   "id",
   ")",
   ".",
   "one",
   "(",
   ")",
   "make_transient",
   "(",
   "job",
   ")",
   "session",
   ".",
   "commit",
   "(",
   ")",
   "if",
   "job",
   ".",
   "state",
   "==",
   "State",
   ".",
   "SHUTDOWN",
   ":",
   "self",
   ".",
   "kill",
   "(",
   ")",
   "is_unit_test",
   "=",
   "conf",
   ".",
   "getboolean",
   "(",
   "'core'",
   ",",
   "'unit_test_mode'",
   ")",
   "if",
   "not",
   "is_unit_test",
   ":",
   "# Figure out how long to sleep for",
   "sleep_for",
   "=",
   "0",
   "if",
   "job",
   ".",
   "latest_heartbeat",
   ":",
   "seconds_remaining",
   "=",
   "self",
   ".",
   "heartrate",
   "-",
   "(",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "-",
   "job",
   ".",
   "latest_heartbeat",
   ")",
   ".",
   "total_seconds",
   "(",
   ")",
   "sleep_for",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "seconds_remaining",
   ")",
   "sleep",
   "(",
   "sleep_for",
   ")",
   "# Update last heartbeat time",
   "with",
   "create_session",
   "(",
   ")",
   "as",
   "session",
   ":",
   "job",
   "=",
   "session",
   ".",
   "query",
   "(",
   "BaseJob",
   ")",
   ".",
   "filter",
   "(",
   "BaseJob",
   ".",
   "id",
   "==",
   "self",
   ".",
   "id",
   ")",
   ".",
   "first",
   "(",
   ")",
   "job",
   ".",
   "latest_heartbeat",
   "=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "session",
   ".",
   "merge",
   "(",
   "job",
   ")",
   "session",
   ".",
   "commit",
   "(",
   ")",
   "self",
   ".",
   "heartbeat_callback",
   "(",
   "session",
   "=",
   "session",
   ")",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "'[heartbeat]'",
   ")",
   "except",
   "OperationalError",
   "as",
   "e",
   ":",
   "self",
   ".",
   "log",
   ".",
   "error",
   "(",
   "\"Scheduler heartbeat got an exception: %s\"",
   ",",
   "str",
   "(",
   "e",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-986",
  "nl_tokens": [
   "Returns",
   "a",
   "list",
   "of",
   "event",
   "data",
   "from",
   "submitted",
   "IO",
   "blocks",
   "."
  ],
  "pl_tokens": [
   "def",
   "getEvents",
   "(",
   "self",
   ",",
   "min_nr",
   "=",
   "1",
   ",",
   "nr",
   "=",
   "None",
   ",",
   "timeout",
   "=",
   "None",
   ")",
   ":",
   "if",
   "min_nr",
   "is",
   "None",
   ":",
   "min_nr",
   "=",
   "len",
   "(",
   "self",
   ".",
   "_submitted",
   ")",
   "if",
   "nr",
   "is",
   "None",
   ":",
   "nr",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_submitted",
   ")",
   ",",
   "self",
   ".",
   "_maxevents",
   ")",
   "if",
   "timeout",
   "is",
   "None",
   ":",
   "timeoutp",
   "=",
   "None",
   "else",
   ":",
   "sec",
   "=",
   "int",
   "(",
   "timeout",
   ")",
   "timeout",
   "=",
   "libaio",
   ".",
   "timespec",
   "(",
   "sec",
   ",",
   "int",
   "(",
   "(",
   "timeout",
   "-",
   "sec",
   ")",
   "*",
   "1e9",
   ")",
   ")",
   "timeoutp",
   "=",
   "byref",
   "(",
   "timeout",
   ")",
   "event_buffer",
   "=",
   "(",
   "libaio",
   ".",
   "io_event",
   "*",
   "nr",
   ")",
   "(",
   ")",
   "actual_nr",
   "=",
   "libaio",
   ".",
   "io_getevents",
   "(",
   "self",
   ".",
   "_ctx",
   ",",
   "min_nr",
   ",",
   "nr",
   ",",
   "event_buffer",
   ",",
   "timeoutp",
   ",",
   ")",
   "return",
   "[",
   "self",
   ".",
   "_eventToPython",
   "(",
   "event_buffer",
   "[",
   "x",
   "]",
   ")",
   "for",
   "x",
   "in",
   "xrange",
   "(",
   "actual_nr",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-987",
  "nl_tokens": [
   "Return",
   "a",
   "dictionary",
   "with",
   "chromosomes",
   "as",
   "keys",
   "and",
   "interval",
   "trees",
   "as",
   "values"
  ],
  "pl_tokens": [
   "def",
   "get_coding_intervals",
   "(",
   "self",
   ",",
   "build",
   "=",
   "'37'",
   ",",
   "genes",
   "=",
   "None",
   ")",
   ":",
   "intervals",
   "=",
   "{",
   "}",
   "if",
   "not",
   "genes",
   ":",
   "genes",
   "=",
   "self",
   ".",
   "all_genes",
   "(",
   "build",
   "=",
   "build",
   ")",
   "LOG",
   ".",
   "info",
   "(",
   "\"Building interval trees...\"",
   ")",
   "for",
   "i",
   ",",
   "hgnc_obj",
   "in",
   "enumerate",
   "(",
   "genes",
   ")",
   ":",
   "chrom",
   "=",
   "hgnc_obj",
   "[",
   "'chromosome'",
   "]",
   "start",
   "=",
   "<mask>",
   "(",
   "(",
   "hgnc_obj",
   "[",
   "'start'",
   "]",
   "-",
   "5000",
   ")",
   ",",
   "1",
   ")",
   "end",
   "=",
   "hgnc_obj",
   "[",
   "'end'",
   "]",
   "+",
   "5000",
   "# If this is the first time a chromosome is seen we create a new",
   "# interval tree with current interval",
   "if",
   "chrom",
   "not",
   "in",
   "intervals",
   ":",
   "intervals",
   "[",
   "chrom",
   "]",
   "=",
   "intervaltree",
   ".",
   "IntervalTree",
   "(",
   ")",
   "intervals",
   "[",
   "chrom",
   "]",
   ".",
   "addi",
   "(",
   "start",
   ",",
   "end",
   ",",
   "i",
   ")",
   "continue",
   "res",
   "=",
   "intervals",
   "[",
   "chrom",
   "]",
   ".",
   "search",
   "(",
   "start",
   ",",
   "end",
   ")",
   "# If the interval did not overlap any other intervals we insert it and continue",
   "if",
   "not",
   "res",
   ":",
   "intervals",
   "[",
   "chrom",
   "]",
   ".",
   "addi",
   "(",
   "start",
   ",",
   "end",
   ",",
   "i",
   ")",
   "continue",
   "# Loop over the overlapping intervals",
   "for",
   "interval",
   "in",
   "res",
   ":",
   "# Update the positions to new max and mins",
   "if",
   "interval",
   ".",
   "begin",
   "<",
   "start",
   ":",
   "start",
   "=",
   "interval",
   ".",
   "begin",
   "if",
   "interval",
   ".",
   "end",
   ">",
   "end",
   ":",
   "end",
   "=",
   "interval",
   ".",
   "end",
   "# Delete the old interval",
   "intervals",
   "[",
   "chrom",
   "]",
   ".",
   "remove",
   "(",
   "interval",
   ")",
   "# Add the new interval consisting och the overlapping ones",
   "intervals",
   "[",
   "chrom",
   "]",
   ".",
   "addi",
   "(",
   "start",
   ",",
   "end",
   ",",
   "i",
   ")",
   "return",
   "intervals"
  ]
 },
 {
  "idx": "maxmin-988",
  "nl_tokens": [
   "Runs",
   "the",
   "program",
   ".",
   "Takes",
   "a",
   "list",
   "of",
   "postcodes",
   "or",
   "coordinates",
   "and",
   "returns",
   "various",
   "information",
   "about",
   "them",
   ".",
   "If",
   "using",
   "the",
   "cli",
   "make",
   "sure",
   "to",
   "update",
   "the",
   "bikes",
   "database",
   "with",
   "the",
   "-",
   "u",
   "command",
   "."
  ],
  "pl_tokens": [
   "def",
   "run",
   "(",
   "locations",
   ",",
   "random",
   ",",
   "bikes",
   ",",
   "crime",
   ",",
   "nearby",
   ",",
   "json",
   ",",
   "update_bikes",
   ",",
   "api_server",
   ",",
   "cross_origin",
   ",",
   "host",
   ",",
   "port",
   ",",
   "db_path",
   ",",
   "verbose",
   ")",
   ":",
   "log_levels",
   "=",
   "[",
   "logging",
   ".",
   "WARNING",
   ",",
   "logging",
   ".",
   "INFO",
   ",",
   "logging",
   ".",
   "DEBUG",
   "]",
   "logging",
   ".",
   "basicConfig",
   "(",
   "level",
   "=",
   "log_levels",
   "[",
   "<mask>",
   "(",
   "verbose",
   ",",
   "2",
   ")",
   "]",
   ")",
   "initialize_database",
   "(",
   "db_path",
   ")",
   "loop",
   "=",
   "get_event_loop",
   "(",
   ")",
   "if",
   "update_bikes",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"Force updating bikes.\"",
   ")",
   "loop",
   ".",
   "run_until_complete",
   "(",
   "util",
   ".",
   "update_bikes",
   "(",
   ")",
   ")",
   "if",
   "api_server",
   ":",
   "if",
   "cross_origin",
   ":",
   "enable_cross_origin",
   "(",
   "app",
   ")",
   "try",
   ":",
   "web",
   ".",
   "run_app",
   "(",
   "app",
   ",",
   "host",
   "=",
   "host",
   ",",
   "port",
   "=",
   "port",
   ")",
   "except",
   "CancelledError",
   "as",
   "e",
   ":",
   "if",
   "e",
   ".",
   "__context__",
   "is",
   "not",
   "None",
   ":",
   "click",
   ".",
   "echo",
   "(",
   "Fore",
   ".",
   "RED",
   "+",
   "(",
   "f\"Could not bind to address {host}:{port}\"",
   "if",
   "e",
   ".",
   "__context__",
   ".",
   "errno",
   "==",
   "48",
   "else",
   "e",
   ".",
   "__context__",
   ")",
   ")",
   "exit",
   "(",
   "1",
   ")",
   "else",
   ":",
   "click",
   ".",
   "echo",
   "(",
   "\"Goodbye!\"",
   ")",
   "elif",
   "len",
   "(",
   "locations",
   ")",
   ">",
   "0",
   "or",
   "random",
   ">",
   "0",
   ":",
   "exit",
   "(",
   "loop",
   ".",
   "run_until_complete",
   "(",
   "cli",
   "(",
   "locations",
   ",",
   "random",
   ",",
   "bikes",
   "=",
   "bikes",
   ",",
   "crime",
   "=",
   "crime",
   ",",
   "nearby",
   "=",
   "nearby",
   ",",
   "as_json",
   "=",
   "json",
   ")",
   ")",
   ")",
   "else",
   ":",
   "click",
   ".",
   "echo",
   "(",
   "Fore",
   ".",
   "RED",
   "+",
   "\"Either include a post code, or the --api-server flag.\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-989",
  "nl_tokens": [
   "Handles",
   "the",
   "containers",
   "of",
   "drawing",
   "components",
   "being",
   "set",
   "."
  ],
  "pl_tokens": [
   "def",
   "_on_drawing",
   "(",
   "self",
   ",",
   "object",
   ",",
   "name",
   ",",
   "old",
   ",",
   "new",
   ")",
   ":",
   "attrs",
   "=",
   "[",
   "\"drawing\"",
   ",",
   "\"arrowhead_drawing\"",
   "]",
   "others",
   "=",
   "[",
   "getattr",
   "(",
   "self",
   ",",
   "a",
   ")",
   "for",
   "a",
   "in",
   "attrs",
   "if",
   "(",
   "a",
   "!=",
   "name",
   ")",
   "and",
   "(",
   "getattr",
   "(",
   "self",
   ",",
   "a",
   ")",
   "is",
   "not",
   "None",
   ")",
   "]",
   "x",
   ",",
   "y",
   "=",
   "self",
   ".",
   "component",
   ".",
   "position",
   "print",
   "\"POS:\"",
   ",",
   "x",
   ",",
   "y",
   ",",
   "self",
   ".",
   "component",
   ".",
   "position",
   "abs_x",
   "=",
   "[",
   "d",
   ".",
   "x",
   "+",
   "x",
   "for",
   "d",
   "in",
   "others",
   "]",
   "abs_y",
   "=",
   "[",
   "d",
   ".",
   "y",
   "+",
   "y",
   "for",
   "d",
   "in",
   "others",
   "]",
   "print",
   "\"ABS:\"",
   ",",
   "abs_x",
   ",",
   "abs_y",
   "# Assume that he new drawing is positioned relative to graph origin.",
   "x1",
   "=",
   "<mask>",
   "(",
   "abs_x",
   "+",
   "[",
   "new",
   ".",
   "x",
   "]",
   ")",
   "y1",
   "=",
   "min",
   "(",
   "abs_y",
   "+",
   "[",
   "new",
   ".",
   "y",
   "]",
   ")",
   "print",
   "\"DRAW:\"",
   ",",
   "new",
   ".",
   "position",
   "new",
   ".",
   "position",
   "=",
   "[",
   "new",
   ".",
   "x",
   "-",
   "x1",
   ",",
   "new",
   ".",
   "y",
   "-",
   "y1",
   "]",
   "print",
   "\"DRAW:\"",
   ",",
   "new",
   ".",
   "position",
   "#        for i, b in enumerate( others ):",
   "#            self.drawing.position = [100, 100]",
   "#            self.drawing.request_redraw()",
   "#            print \"OTHER:\", b.position, abs_x[i] - x1",
   "#            b.position = [ abs_x[i] - x1, abs_y[i] - y1 ]",
   "#            b.x = 50",
   "#            b.y = 50",
   "#            print \"OTHER:\", b.position, abs_x[i], x1",
   "#        for attr in attrs:",
   "#            if attr != name:",
   "#                if getattr(self, attr) is not None:",
   "#                    drawing = getattr(self, attr)",
   "#                    drawing.position = [50, 50]",
   "if",
   "old",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "component",
   ".",
   "remove",
   "(",
   "old",
   ")",
   "if",
   "new",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "component",
   ".",
   "add",
   "(",
   "new",
   ")",
   "print",
   "\"POS NEW:\"",
   ",",
   "self",
   ".",
   "component",
   ".",
   "position",
   "self",
   ".",
   "component",
   ".",
   "position",
   "=",
   "[",
   "x1",
   ",",
   "y1",
   "]",
   "print",
   "\"POS NEW:\"",
   ",",
   "self",
   ".",
   "component",
   ".",
   "position",
   "self",
   ".",
   "component",
   ".",
   "request_redraw",
   "(",
   ")",
   "print",
   "\"POS NEW:\"",
   ",",
   "self",
   ".",
   "component",
   ".",
   "position"
  ]
 },
 {
  "idx": "maxmin-990",
  "nl_tokens": [
   "Return",
   "the",
   "maximum",
   "revision",
   "for",
   "all",
   "files",
   "under",
   "a",
   "given",
   "location"
  ],
  "pl_tokens": [
   "def",
   "get_revision",
   "(",
   "self",
   ",",
   "location",
   ")",
   ":",
   "# Note: taken from setuptools.command.egg_info",
   "revision",
   "=",
   "0",
   "for",
   "base",
   ",",
   "dirs",
   ",",
   "files",
   "in",
   "os",
   ".",
   "walk",
   "(",
   "location",
   ")",
   ":",
   "if",
   "self",
   ".",
   "dirname",
   "not",
   "in",
   "dirs",
   ":",
   "dirs",
   "[",
   ":",
   "]",
   "=",
   "[",
   "]",
   "continue",
   "# no sense walking uncontrolled subdirs",
   "dirs",
   ".",
   "remove",
   "(",
   "self",
   ".",
   "dirname",
   ")",
   "entries_fn",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "base",
   ",",
   "self",
   ".",
   "dirname",
   ",",
   "'entries'",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "entries_fn",
   ")",
   ":",
   "# FIXME: should we warn?",
   "continue",
   "dirurl",
   ",",
   "localrev",
   "=",
   "self",
   ".",
   "_get_svn_url_rev",
   "(",
   "base",
   ")",
   "if",
   "base",
   "==",
   "location",
   ":",
   "base_url",
   "=",
   "dirurl",
   "+",
   "'/'",
   "# save the root url",
   "elif",
   "not",
   "dirurl",
   "or",
   "not",
   "dirurl",
   ".",
   "startswith",
   "(",
   "base_url",
   ")",
   ":",
   "dirs",
   "[",
   ":",
   "]",
   "=",
   "[",
   "]",
   "continue",
   "# not part of the same svn tree, skip it",
   "revision",
   "=",
   "<mask>",
   "(",
   "revision",
   ",",
   "localrev",
   ")",
   "return",
   "revision"
  ]
 },
 {
  "idx": "maxmin-991",
  "nl_tokens": [
   "Build",
   "/",
   "return",
   "a",
   "list",
   "of",
   "[",
   "(",
   "bead",
   "x",
   "y",
   "z",
   ")",
   "...",
   "]"
  ],
  "pl_tokens": [
   "def",
   "build",
   "(",
   "self",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "coords",
   ":",
   "if",
   "self",
   ".",
   "beads",
   "and",
   "self",
   ".",
   "template",
   ":",
   "stuff",
   "=",
   "zip",
   "(",
   "self",
   ".",
   "beads",
   ",",
   "self",
   ".",
   "template",
   ")",
   "self",
   ".",
   "coords",
   "=",
   "[",
   "[",
   "i",
   ",",
   "x",
   ",",
   "y",
   ",",
   "z",
   "]",
   "for",
   "i",
   ",",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ")",
   "in",
   "stuff",
   "if",
   "i",
   "!=",
   "\"-\"",
   "]",
   "else",
   ":",
   "# Set beads/structure from head/link/tail",
   "# Set bead names",
   "if",
   "self",
   ".",
   "beads",
   ":",
   "beads",
   "=",
   "list",
   "(",
   "self",
   ".",
   "beads",
   ")",
   "else",
   ":",
   "beads",
   "=",
   "[",
   "HEADBEADS",
   "[",
   "i",
   "]",
   "for",
   "i",
   "in",
   "self",
   ".",
   "head",
   "]",
   "beads",
   ".",
   "extend",
   "(",
   "[",
   "LINKBEADS",
   "[",
   "n",
   "]",
   "+",
   "str",
   "(",
   "i",
   "+",
   "1",
   ")",
   "for",
   "i",
   ",",
   "n",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "link",
   ")",
   "]",
   ")",
   "for",
   "i",
   ",",
   "t",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "tail",
   ")",
   ":",
   "beads",
   ".",
   "extend",
   "(",
   "[",
   "n",
   "+",
   "chr",
   "(",
   "65",
   "+",
   "i",
   ")",
   "+",
   "str",
   "(",
   "j",
   "+",
   "1",
   ")",
   "for",
   "j",
   ",",
   "n",
   "in",
   "enumerate",
   "(",
   "t",
   ")",
   "]",
   ")",
   "taillength",
   "=",
   "<mask>",
   "(",
   "[",
   "0",
   "]",
   "+",
   "[",
   "len",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "tail",
   "]",
   ")",
   "length",
   "=",
   "len",
   "(",
   "self",
   ".",
   "head",
   ")",
   "+",
   "taillength",
   "# Add the pseudocoordinates for the head",
   "rl",
   "=",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "head",
   ")",
   ")",
   "struc",
   "=",
   "[",
   "(",
   "0",
   ",",
   "0",
   ",",
   "length",
   "-",
   "i",
   ")",
   "for",
   "i",
   "in",
   "rl",
   "]",
   "# Add the linkers",
   "rl",
   "=",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "link",
   ")",
   ")",
   "struc",
   ".",
   "extend",
   "(",
   "[",
   "(",
   "i",
   "%",
   "2",
   ",",
   "i",
   "//",
   "2",
   ",",
   "taillength",
   ")",
   "for",
   "i",
   "in",
   "rl",
   "]",
   ")",
   "# Add the tails",
   "for",
   "j",
   ",",
   "tail",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "tail",
   ")",
   ":",
   "rl",
   "=",
   "range",
   "(",
   "len",
   "(",
   "tail",
   ")",
   ")",
   "struc",
   ".",
   "extend",
   "(",
   "[",
   "(",
   "j",
   "%",
   "2",
   ",",
   "j",
   "//",
   "2",
   ",",
   "taillength",
   "-",
   "1",
   "-",
   "i",
   ")",
   "for",
   "i",
   "in",
   "rl",
   "]",
   ")",
   "mx",
   ",",
   "my",
   ",",
   "mz",
   "=",
   "[",
   "(",
   "max",
   "(",
   "i",
   ")",
   "+",
   "min",
   "(",
   "i",
   ")",
   ")",
   "/",
   "2",
   "for",
   "i",
   "in",
   "zip",
   "(",
   "*",
   "struc",
   ")",
   "]",
   "self",
   ".",
   "coords",
   "=",
   "[",
   "[",
   "i",
   ",",
   "0.25",
   "*",
   "(",
   "x",
   "-",
   "mx",
   ")",
   ",",
   "0.25",
   "*",
   "(",
   "y",
   "-",
   "my",
   ")",
   ",",
   "z",
   "]",
   "for",
   "i",
   ",",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ")",
   "in",
   "zip",
   "(",
   "beads",
   ",",
   "struc",
   ")",
   "]",
   "# Scale the x/y based on the lipid's APL - diameter is less than sqrt(APL)",
   "diam",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"diam\"",
   ",",
   "self",
   ".",
   "diam",
   ")",
   "radius",
   "=",
   "diam",
   "*",
   "0.45",
   "minmax",
   "=",
   "[",
   "(",
   "min",
   "(",
   "i",
   ")",
   ",",
   "max",
   "(",
   "i",
   ")",
   ")",
   "for",
   "i",
   "in",
   "list",
   "(",
   "zip",
   "(",
   "*",
   "self",
   ".",
   "coords",
   ")",
   ")",
   "[",
   "1",
   ":",
   "]",
   "]",
   "mx",
   ",",
   "my",
   ",",
   "mz",
   "=",
   "[",
   "sum",
   "(",
   "i",
   ")",
   "/",
   "2.",
   "for",
   "i",
   "in",
   "minmax",
   "]",
   "scale",
   "=",
   "radius",
   "/",
   "math",
   ".",
   "sqrt",
   "(",
   "(",
   "minmax",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "-",
   "mx",
   ")",
   "**",
   "2",
   "+",
   "(",
   "minmax",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   "-",
   "my",
   ")",
   "**",
   "2",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "coords",
   ":",
   "i",
   "[",
   "1",
   "]",
   "=",
   "scale",
   "*",
   "(",
   "i",
   "[",
   "1",
   "]",
   "-",
   "mx",
   ")",
   "i",
   "[",
   "2",
   "]",
   "=",
   "scale",
   "*",
   "(",
   "i",
   "[",
   "2",
   "]",
   "-",
   "my",
   ")",
   "i",
   "[",
   "3",
   "]",
   "-=",
   "minmax",
   "[",
   "2",
   "]",
   "[",
   "0",
   "]",
   "return",
   "self",
   ".",
   "coords"
  ]
 },
 {
  "idx": "maxmin-992",
  "nl_tokens": [
   "Shortcut",
   "for",
   "ds",
   ".",
   "min",
   "(",
   "expression",
   "...",
   ")",
   "see",
   "Dataset",
   ".",
   "min"
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "binby",
   "=",
   "[",
   "]",
   ",",
   "limits",
   "=",
   "None",
   ",",
   "shape",
   "=",
   "default_shape",
   ",",
   "selection",
   "=",
   "False",
   ",",
   "delay",
   "=",
   "False",
   ",",
   "progress",
   "=",
   "None",
   ")",
   ":",
   "kwargs",
   "=",
   "dict",
   "(",
   "locals",
   "(",
   ")",
   ")",
   "del",
   "kwargs",
   "[",
   "'self'",
   "]",
   "kwargs",
   "[",
   "'expression'",
   "]",
   "=",
   "self",
   ".",
   "expression",
   "return",
   "self",
   ".",
   "ds",
   ".",
   "min",
   "(",
   "*",
   "*",
   "kwargs",
   ")"
  ]
 },
 {
  "idx": "maxmin-993",
  "nl_tokens": [
   "Plotting",
   "but",
   "only",
   "for",
   "points",
   "(",
   "as",
   "opposed",
   "to",
   "intervals",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_points",
   "(",
   "self",
   ",",
   "ax",
   ",",
   "legend",
   "=",
   "None",
   ",",
   "field",
   "=",
   "None",
   ",",
   "field_function",
   "=",
   "None",
   ",",
   "undefined",
   "=",
   "0",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "ys",
   "=",
   "[",
   "iv",
   ".",
   "top",
   ".",
   "z",
   "for",
   "iv",
   "in",
   "self",
   "]",
   "if",
   "field",
   "is",
   "not",
   "None",
   ":",
   "f",
   "=",
   "field_function",
   "or",
   "utils",
   ".",
   "null",
   "xs",
   "=",
   "[",
   "f",
   "(",
   "iv",
   ".",
   "data",
   ".",
   "get",
   "(",
   "field",
   ",",
   "undefined",
   ")",
   ")",
   "for",
   "iv",
   "in",
   "self",
   "]",
   "else",
   ":",
   "xs",
   "=",
   "[",
   "1",
   "for",
   "iv",
   "in",
   "self",
   "]",
   "ax",
   ".",
   "set_xlim",
   "(",
   "(",
   "<mask>",
   "(",
   "xs",
   ")",
   ",",
   "max",
   "(",
   "xs",
   ")",
   ")",
   ")",
   "for",
   "x",
   ",",
   "y",
   "in",
   "zip",
   "(",
   "xs",
   ",",
   "ys",
   ")",
   ":",
   "ax",
   ".",
   "axhline",
   "(",
   "y",
   ",",
   "color",
   "=",
   "'lightgray'",
   ",",
   "zorder",
   "=",
   "0",
   ")",
   "ax",
   ".",
   "scatter",
   "(",
   "xs",
   ",",
   "ys",
   ",",
   "clip_on",
   "=",
   "False",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-994",
  "nl_tokens": [
   "Loads",
   "a",
   "single",
   "trajectory",
   "from",
   "a",
   "given",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "_trj_load_trajectory",
   "(",
   "self",
   ",",
   "traj",
   ",",
   "as_new",
   ",",
   "load_parameters",
   ",",
   "load_derived_parameters",
   ",",
   "load_results",
   ",",
   "load_other_data",
   ",",
   "recursive",
   ",",
   "max_depth",
   ",",
   "with_run_information",
   ",",
   "with_meta_data",
   ",",
   "force",
   ")",
   ":",
   "# Some validity checks, if `as_new` is used correctly",
   "if",
   "(",
   "as_new",
   "and",
   "(",
   "load_derived_parameters",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   "or",
   "load_results",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   "or",
   "load_other_data",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   ")",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'You cannot load a trajectory as new and load the derived '",
   "'parameters and results. Only parameters are allowed.'",
   ")",
   "if",
   "as_new",
   "and",
   "load_parameters",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_DATA",
   ":",
   "raise",
   "ValueError",
   "(",
   "'You cannot load the trajectory as new and not load the data of '",
   "'the parameters.'",
   ")",
   "loadconstants",
   "=",
   "(",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   ",",
   "pypetconstants",
   ".",
   "LOAD_SKELETON",
   ",",
   "pypetconstants",
   ".",
   "LOAD_DATA",
   ",",
   "pypetconstants",
   ".",
   "OVERWRITE_DATA",
   ")",
   "if",
   "not",
   "(",
   "load_parameters",
   "in",
   "loadconstants",
   "and",
   "load_derived_parameters",
   "in",
   "loadconstants",
   "and",
   "load_results",
   "in",
   "loadconstants",
   "and",
   "load_other_data",
   "in",
   "loadconstants",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Please give a valid option on how to load data. Options for '",
   "'`load_parameter`, `load_derived_parameters`, `load_results`, '",
   "'and `load_other_data` are %s. See function documentation for '",
   "'the semantics of the values.'",
   "%",
   "str",
   "(",
   "loadconstants",
   ")",
   ")",
   "traj",
   ".",
   "_stored",
   "=",
   "not",
   "as_new",
   "# Loads meta data like the name, timestamps etc.",
   "# load_data is only used here to determine how to load the annotations",
   "load_data",
   "=",
   "<mask>",
   "(",
   "load_parameters",
   ",",
   "load_derived_parameters",
   ",",
   "load_results",
   ",",
   "load_other_data",
   ")",
   "if",
   "with_meta_data",
   ":",
   "self",
   ".",
   "_trj_load_meta_data",
   "(",
   "traj",
   ",",
   "load_data",
   ",",
   "as_new",
   ",",
   "with_run_information",
   ",",
   "force",
   ")",
   "if",
   "(",
   "load_parameters",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   "or",
   "load_derived_parameters",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   "or",
   "load_results",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   "or",
   "load_other_data",
   "!=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   ")",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'Loading trajectory `%s`.'",
   "%",
   "traj",
   ".",
   "v_name",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'Checked meta data of trajectory `%s`.'",
   "%",
   "traj",
   ".",
   "v_name",
   ")",
   "return",
   "maximum_display_other",
   "=",
   "10",
   "counter",
   "=",
   "0",
   "for",
   "children",
   "in",
   "[",
   "self",
   ".",
   "_trajectory_group",
   ".",
   "_v_groups",
   ",",
   "self",
   ".",
   "_trajectory_group",
   ".",
   "_v_links",
   "]",
   ":",
   "for",
   "hdf5_group_name",
   "in",
   "children",
   ":",
   "hdf5_group",
   "=",
   "children",
   "[",
   "hdf5_group_name",
   "]",
   "child_name",
   "=",
   "hdf5_group",
   ".",
   "_v_name",
   "load_subbranch",
   "=",
   "True",
   "if",
   "child_name",
   "==",
   "'config'",
   ":",
   "if",
   "as_new",
   ":",
   "loading",
   "=",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   "else",
   ":",
   "# If the trajectory is loaded as new, we don't care about old config stuff",
   "# and only load the parameters",
   "loading",
   "=",
   "load_parameters",
   "elif",
   "child_name",
   "==",
   "'parameters'",
   ":",
   "loading",
   "=",
   "load_parameters",
   "elif",
   "child_name",
   "==",
   "'results'",
   ":",
   "loading",
   "=",
   "load_results",
   "elif",
   "child_name",
   "==",
   "'derived_parameters'",
   ":",
   "loading",
   "=",
   "load_derived_parameters",
   "elif",
   "child_name",
   "==",
   "'overview'",
   ":",
   "continue",
   "else",
   ":",
   "loading",
   "=",
   "load_other_data",
   "load_subbranch",
   "=",
   "False",
   "if",
   "loading",
   "==",
   "pypetconstants",
   ".",
   "LOAD_NOTHING",
   ":",
   "continue",
   "if",
   "load_subbranch",
   ":",
   "# Load the subbranches recursively",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'Loading branch `%s` in mode `%s`.'",
   "%",
   "(",
   "child_name",
   ",",
   "str",
   "(",
   "loading",
   ")",
   ")",
   ")",
   "else",
   ":",
   "if",
   "counter",
   "<",
   "maximum_display_other",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'Loading branch/node `%s` in mode `%s`.'",
   "%",
   "(",
   "child_name",
   ",",
   "str",
   "(",
   "loading",
   ")",
   ")",
   ")",
   "elif",
   "counter",
   "==",
   "maximum_display_other",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "'To many branchs or nodes at root for display. '",
   "'I will not inform you about loading anymore. '",
   "'Branches are loaded silently '",
   "'in the background. Do not worry, '",
   "'I will not freeze! Pinky promise!!!'",
   ")",
   "counter",
   "+=",
   "1",
   "self",
   ".",
   "_tree_load_sub_branch",
   "(",
   "traj",
   ",",
   "child_name",
   ",",
   "load_data",
   "=",
   "loading",
   ",",
   "with_links",
   "=",
   "True",
   ",",
   "recursive",
   "=",
   "recursive",
   ",",
   "max_depth",
   "=",
   "max_depth",
   ",",
   "_trajectory",
   "=",
   "traj",
   ",",
   "_as_new",
   "=",
   "as_new",
   ",",
   "_hdf5_group",
   "=",
   "self",
   ".",
   "_trajectory_group",
   ")"
  ]
 },
 {
  "idx": "maxmin-995",
  "nl_tokens": [
   "The",
   "maximum",
   "width",
   "of",
   "all",
   "the",
   "Decors",
   "in",
   "the",
   "Legend",
   ".",
   "This",
   "is",
   "needed",
   "to",
   "scale",
   "a",
   "Legend",
   "or",
   "Striplog",
   "when",
   "plotting",
   "with",
   "widths",
   "turned",
   "on",
   "."
  ],
  "pl_tokens": [
   "def",
   "max_width",
   "(",
   "self",
   ")",
   ":",
   "try",
   ":",
   "maximum",
   "=",
   "<mask>",
   "(",
   "[",
   "row",
   ".",
   "width",
   "for",
   "row",
   "in",
   "self",
   ".",
   "__list",
   "if",
   "row",
   ".",
   "width",
   "is",
   "not",
   "None",
   "]",
   ")",
   "return",
   "maximum",
   "except",
   ":",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-996",
  "nl_tokens": [
   "Return",
   "a",
   "list",
   "of",
   "strings",
   "as",
   "a",
   "compact",
   "set",
   "of",
   "columns",
   "arranged",
   "horizontally",
   "or",
   "vertically",
   "."
  ],
  "pl_tokens": [
   "def",
   "columnize",
   "(",
   "array",
   ",",
   "displaywidth",
   "=",
   "80",
   ",",
   "colsep",
   "=",
   "'  '",
   ",",
   "arrange_vertical",
   "=",
   "True",
   ",",
   "ljust",
   "=",
   "True",
   ",",
   "lineprefix",
   "=",
   "''",
   ",",
   "opts",
   "=",
   "{",
   "}",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "array",
   ",",
   "(",
   "list",
   ",",
   "tuple",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "(",
   "'array needs to be an instance of a list or a tuple'",
   ")",
   ")",
   "o",
   "=",
   "{",
   "}",
   "if",
   "len",
   "(",
   "opts",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ">",
   "0",
   ":",
   "for",
   "key",
   "in",
   "default_opts",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "o",
   "[",
   "key",
   "]",
   "=",
   "get_option",
   "(",
   "key",
   ",",
   "opts",
   ")",
   "pass",
   "if",
   "o",
   "[",
   "'arrange_array'",
   "]",
   ":",
   "o",
   "[",
   "'array_prefix'",
   "]",
   "=",
   "'['",
   "o",
   "[",
   "'lineprefix'",
   "]",
   "=",
   "' '",
   "o",
   "[",
   "'linesuffix'",
   "]",
   "=",
   "\",\\n\"",
   "o",
   "[",
   "'array_suffix'",
   "]",
   "=",
   "\"]\\n\"",
   "o",
   "[",
   "'colsep'",
   "]",
   "=",
   "', '",
   "o",
   "[",
   "'arrange_vertical'",
   "]",
   "=",
   "False",
   "pass",
   "else",
   ":",
   "o",
   "=",
   "default_opts",
   ".",
   "copy",
   "(",
   ")",
   "o",
   "[",
   "'displaywidth'",
   "]",
   "=",
   "displaywidth",
   "o",
   "[",
   "'colsep'",
   "]",
   "=",
   "colsep",
   "o",
   "[",
   "'arrange_vertical'",
   "]",
   "=",
   "arrange_vertical",
   "o",
   "[",
   "'ljust'",
   "]",
   "=",
   "ljust",
   "o",
   "[",
   "'lineprefix'",
   "]",
   "=",
   "lineprefix",
   "pass",
   "# if o['ljust'] is None:",
   "#     o['ljust'] = !(list.all?{|datum| datum.kind_of?(Numeric)})",
   "#     pass",
   "if",
   "o",
   "[",
   "'colfmt'",
   "]",
   ":",
   "array",
   "=",
   "[",
   "(",
   "o",
   "[",
   "'colfmt'",
   "]",
   "%",
   "i",
   ")",
   "for",
   "i",
   "in",
   "array",
   "]",
   "else",
   ":",
   "array",
   "=",
   "[",
   "str",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "array",
   "]",
   "pass",
   "# Some degenerate cases",
   "size",
   "=",
   "len",
   "(",
   "array",
   ")",
   "if",
   "0",
   "==",
   "size",
   ":",
   "return",
   "\"<empty>\\n\"",
   "elif",
   "size",
   "==",
   "1",
   ":",
   "return",
   "'%s%s%s\\n'",
   "%",
   "(",
   "o",
   "[",
   "'array_prefix'",
   "]",
   ",",
   "str",
   "(",
   "array",
   "[",
   "0",
   "]",
   ")",
   ",",
   "o",
   "[",
   "'array_suffix'",
   "]",
   ")",
   "o",
   "[",
   "'displaywidth'",
   "]",
   "=",
   "<mask>",
   "(",
   "4",
   ",",
   "o",
   "[",
   "'displaywidth'",
   "]",
   "-",
   "len",
   "(",
   "o",
   "[",
   "'lineprefix'",
   "]",
   ")",
   ")",
   "if",
   "o",
   "[",
   "'arrange_vertical'",
   "]",
   ":",
   "array_index",
   "=",
   "lambda",
   "nrows",
   ",",
   "row",
   ",",
   "col",
   ":",
   "nrows",
   "*",
   "col",
   "+",
   "row",
   "# Try every row count from 1 upwards",
   "for",
   "nrows",
   "in",
   "range",
   "(",
   "1",
   ",",
   "size",
   "+",
   "1",
   ")",
   ":",
   "ncols",
   "=",
   "(",
   "size",
   "+",
   "nrows",
   "-",
   "1",
   ")",
   "//",
   "nrows",
   "colwidths",
   "=",
   "[",
   "]",
   "totwidth",
   "=",
   "-",
   "len",
   "(",
   "o",
   "[",
   "'colsep'",
   "]",
   ")",
   "for",
   "col",
   "in",
   "range",
   "(",
   "ncols",
   ")",
   ":",
   "# get max column width for this column",
   "colwidth",
   "=",
   "0",
   "for",
   "row",
   "in",
   "range",
   "(",
   "nrows",
   ")",
   ":",
   "i",
   "=",
   "array_index",
   "(",
   "nrows",
   ",",
   "row",
   ",",
   "col",
   ")",
   "if",
   "i",
   ">=",
   "size",
   ":",
   "break",
   "x",
   "=",
   "array",
   "[",
   "i",
   "]",
   "colwidth",
   "=",
   "max",
   "(",
   "colwidth",
   ",",
   "len",
   "(",
   "x",
   ")",
   ")",
   "pass",
   "colwidths",
   ".",
   "append",
   "(",
   "colwidth",
   ")",
   "totwidth",
   "+=",
   "colwidth",
   "+",
   "len",
   "(",
   "o",
   "[",
   "'colsep'",
   "]",
   ")",
   "if",
   "totwidth",
   ">",
   "o",
   "[",
   "'displaywidth'",
   "]",
   ":",
   "break",
   "pass",
   "if",
   "totwidth",
   "<=",
   "o",
   "[",
   "'displaywidth'",
   "]",
   ":",
   "break",
   "pass",
   "# The smallest number of rows computed and the",
   "# max widths for each column has been obtained.",
   "# Now we just have to format each of the",
   "# rows.",
   "s",
   "=",
   "''",
   "for",
   "row",
   "in",
   "range",
   "(",
   "nrows",
   ")",
   ":",
   "texts",
   "=",
   "[",
   "]",
   "for",
   "col",
   "in",
   "range",
   "(",
   "ncols",
   ")",
   ":",
   "i",
   "=",
   "row",
   "+",
   "nrows",
   "*",
   "col",
   "if",
   "i",
   ">=",
   "size",
   ":",
   "x",
   "=",
   "\"\"",
   "else",
   ":",
   "x",
   "=",
   "array",
   "[",
   "i",
   "]",
   "texts",
   ".",
   "append",
   "(",
   "x",
   ")",
   "while",
   "texts",
   "and",
   "not",
   "texts",
   "[",
   "-",
   "1",
   "]",
   ":",
   "del",
   "texts",
   "[",
   "-",
   "1",
   "]",
   "for",
   "col",
   "in",
   "range",
   "(",
   "len",
   "(",
   "texts",
   ")",
   ")",
   ":",
   "if",
   "o",
   "[",
   "'ljust'",
   "]",
   ":",
   "texts",
   "[",
   "col",
   "]",
   "=",
   "texts",
   "[",
   "col",
   "]",
   ".",
   "ljust",
   "(",
   "colwidths",
   "[",
   "col",
   "]",
   ")",
   "else",
   ":",
   "texts",
   "[",
   "col",
   "]",
   "=",
   "texts",
   "[",
   "col",
   "]",
   ".",
   "rjust",
   "(",
   "colwidths",
   "[",
   "col",
   "]",
   ")",
   "pass",
   "pass",
   "s",
   "+=",
   "\"%s%s%s\"",
   "%",
   "(",
   "o",
   "[",
   "'lineprefix'",
   "]",
   ",",
   "str",
   "(",
   "o",
   "[",
   "'colsep'",
   "]",
   ".",
   "join",
   "(",
   "texts",
   ")",
   ")",
   ",",
   "o",
   "[",
   "'linesuffix'",
   "]",
   ")",
   "pass",
   "return",
   "s",
   "else",
   ":",
   "array_index",
   "=",
   "lambda",
   "ncols",
   ",",
   "row",
   ",",
   "col",
   ":",
   "ncols",
   "*",
   "(",
   "row",
   "-",
   "1",
   ")",
   "+",
   "col",
   "# Try every column count from size downwards",
   "colwidths",
   "=",
   "[",
   "]",
   "for",
   "ncols",
   "in",
   "range",
   "(",
   "size",
   ",",
   "0",
   ",",
   "-",
   "1",
   ")",
   ":",
   "# Try every row count from 1 upwards",
   "min_rows",
   "=",
   "(",
   "size",
   "+",
   "ncols",
   "-",
   "1",
   ")",
   "//",
   "ncols",
   "nrows",
   "=",
   "min_rows",
   "-",
   "1",
   "while",
   "nrows",
   "<",
   "size",
   ":",
   "nrows",
   "+=",
   "1",
   "rounded_size",
   "=",
   "nrows",
   "*",
   "ncols",
   "colwidths",
   "=",
   "[",
   "]",
   "totwidth",
   "=",
   "-",
   "len",
   "(",
   "o",
   "[",
   "'colsep'",
   "]",
   ")",
   "for",
   "col",
   "in",
   "range",
   "(",
   "ncols",
   ")",
   ":",
   "# get max column width for this column",
   "colwidth",
   "=",
   "0",
   "for",
   "row",
   "in",
   "range",
   "(",
   "1",
   ",",
   "nrows",
   "+",
   "1",
   ")",
   ":",
   "i",
   "=",
   "array_index",
   "(",
   "ncols",
   ",",
   "row",
   ",",
   "col",
   ")",
   "if",
   "i",
   ">=",
   "rounded_size",
   ":",
   "break",
   "elif",
   "i",
   "<",
   "size",
   ":",
   "x",
   "=",
   "array",
   "[",
   "i",
   "]",
   "colwidth",
   "=",
   "max",
   "(",
   "colwidth",
   ",",
   "len",
   "(",
   "x",
   ")",
   ")",
   "pass",
   "pass",
   "colwidths",
   ".",
   "append",
   "(",
   "colwidth",
   ")",
   "totwidth",
   "+=",
   "colwidth",
   "+",
   "len",
   "(",
   "o",
   "[",
   "'colsep'",
   "]",
   ")",
   "if",
   "totwidth",
   ">=",
   "o",
   "[",
   "'displaywidth'",
   "]",
   ":",
   "break",
   "pass",
   "if",
   "totwidth",
   "<=",
   "o",
   "[",
   "'displaywidth'",
   "]",
   "and",
   "i",
   ">=",
   "rounded_size",
   "-",
   "1",
   ":",
   "# Found the right nrows and ncols",
   "# print \"right nrows and ncols\"",
   "nrows",
   "=",
   "row",
   "break",
   "elif",
   "totwidth",
   ">=",
   "o",
   "[",
   "'displaywidth'",
   "]",
   ":",
   "# print \"reduce ncols\", ncols",
   "# Need to reduce ncols",
   "break",
   "pass",
   "if",
   "totwidth",
   "<=",
   "o",
   "[",
   "'displaywidth'",
   "]",
   "and",
   "i",
   ">=",
   "rounded_size",
   "-",
   "1",
   ":",
   "break",
   "pass",
   "# The smallest number of rows computed and the",
   "# max widths for each column has been obtained.",
   "# Now we just have to format each of the",
   "# rows.",
   "s",
   "=",
   "''",
   "if",
   "len",
   "(",
   "o",
   "[",
   "'array_prefix'",
   "]",
   ")",
   "!=",
   "0",
   ":",
   "prefix",
   "=",
   "o",
   "[",
   "'array_prefix'",
   "]",
   "else",
   ":",
   "prefix",
   "=",
   "o",
   "[",
   "'lineprefix'",
   "]",
   "pass",
   "for",
   "row",
   "in",
   "range",
   "(",
   "1",
   ",",
   "nrows",
   "+",
   "1",
   ")",
   ":",
   "texts",
   "=",
   "[",
   "]",
   "for",
   "col",
   "in",
   "range",
   "(",
   "ncols",
   ")",
   ":",
   "i",
   "=",
   "array_index",
   "(",
   "ncols",
   ",",
   "row",
   ",",
   "col",
   ")",
   "if",
   "i",
   ">=",
   "size",
   ":",
   "break",
   "else",
   ":",
   "x",
   "=",
   "array",
   "[",
   "i",
   "]",
   "texts",
   ".",
   "append",
   "(",
   "x",
   ")",
   "pass",
   "for",
   "col",
   "in",
   "range",
   "(",
   "len",
   "(",
   "texts",
   ")",
   ")",
   ":",
   "if",
   "o",
   "[",
   "'ljust'",
   "]",
   ":",
   "texts",
   "[",
   "col",
   "]",
   "=",
   "texts",
   "[",
   "col",
   "]",
   ".",
   "ljust",
   "(",
   "colwidths",
   "[",
   "col",
   "]",
   ")",
   "else",
   ":",
   "texts",
   "[",
   "col",
   "]",
   "=",
   "texts",
   "[",
   "col",
   "]",
   ".",
   "rjust",
   "(",
   "colwidths",
   "[",
   "col",
   "]",
   ")",
   "pass",
   "pass",
   "s",
   "+=",
   "\"%s%s%s\"",
   "%",
   "(",
   "prefix",
   ",",
   "str",
   "(",
   "o",
   "[",
   "'colsep'",
   "]",
   ".",
   "join",
   "(",
   "texts",
   ")",
   ")",
   ",",
   "o",
   "[",
   "'linesuffix'",
   "]",
   ")",
   "prefix",
   "=",
   "o",
   "[",
   "'lineprefix'",
   "]",
   "pass",
   "if",
   "o",
   "[",
   "'arrange_array'",
   "]",
   ":",
   "colsep",
   "=",
   "o",
   "[",
   "'colsep'",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   "colsep_pos",
   "=",
   "-",
   "(",
   "len",
   "(",
   "colsep",
   ")",
   "+",
   "1",
   ")",
   "if",
   "s",
   "[",
   "colsep_pos",
   ":",
   "]",
   "==",
   "colsep",
   "+",
   "\"\\n\"",
   ":",
   "s",
   "=",
   "s",
   "[",
   ":",
   "colsep_pos",
   "]",
   "+",
   "o",
   "[",
   "'array_suffix'",
   "]",
   "+",
   "\"\\n\"",
   "pass",
   "pass",
   "else",
   ":",
   "s",
   "+=",
   "o",
   "[",
   "'array_suffix'",
   "]",
   "pass",
   "return",
   "s",
   "pass"
  ]
 },
 {
  "idx": "maxmin-997",
  "nl_tokens": [
   "Find",
   "the",
   "median",
   "of",
   "the",
   "function",
   "represented",
   "as",
   "an",
   "interpolation",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "median_interp",
   "(",
   "interp_object",
   ")",
   ":",
   "new_grid",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "interp_object",
   ".",
   "x",
   "[",
   ":",
   "-",
   "1",
   "]",
   "+",
   "0.1",
   "*",
   "ii",
   "*",
   "np",
   ".",
   "diff",
   "(",
   "interp_object",
   ".",
   "x",
   ")",
   "for",
   "ii",
   "in",
   "range",
   "(",
   "10",
   ")",
   "]",
   ")",
   ".",
   "flatten",
   "(",
   ")",
   ")",
   "tmp_prop",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "-",
   "(",
   "interp_object",
   "(",
   "new_grid",
   ")",
   "-",
   "interp_object",
   ".",
   "y",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   ")",
   "tmp_cumsum",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "0.5",
   "*",
   "(",
   "tmp_prop",
   "[",
   "1",
   ":",
   "]",
   "+",
   "tmp_prop",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   "*",
   "np",
   ".",
   "diff",
   "(",
   "new_grid",
   ")",
   ")",
   "median_index",
   "=",
   "min",
   "(",
   "len",
   "(",
   "tmp_cumsum",
   ")",
   "-",
   "3",
   ",",
   "max",
   "(",
   "2",
   ",",
   "np",
   ".",
   "searchsorted",
   "(",
   "tmp_cumsum",
   ",",
   "tmp_cumsum",
   "[",
   "-",
   "1",
   "]",
   "*",
   "0.5",
   ")",
   "+",
   "1",
   ")",
   ")",
   "return",
   "new_grid",
   "[",
   "median_index",
   "]"
  ]
 },
 {
  "idx": "maxmin-998",
  "nl_tokens": [
   "get",
   "max",
   "statement",
   "id",
   "used",
   "for",
   "sorting",
   "of",
   "processes",
   "in",
   "architecture"
  ],
  "pl_tokens": [
   "def",
   "maxStmId",
   "(",
   "proc",
   ")",
   ":",
   "maxId",
   "=",
   "0",
   "for",
   "stm",
   "in",
   "proc",
   ".",
   "statements",
   ":",
   "maxId",
   "=",
   "<mask>",
   "(",
   "maxId",
   ",",
   "getMaxStmIdForStm",
   "(",
   "stm",
   ")",
   ")",
   "return",
   "maxId"
  ]
 },
 {
  "idx": "maxmin-999",
  "nl_tokens": [
   "Returns",
   "the",
   "components",
   "underlying",
   "the",
   "autorange",
   "algorithm",
   "."
  ],
  "pl_tokens": [
   "def",
   "autorange_components",
   "(",
   "t",
   ",",
   "sig",
   ",",
   "transform",
   "=",
   "'log'",
   ",",
   "gwin",
   "=",
   "7",
   ",",
   "swin",
   "=",
   "None",
   ",",
   "win",
   "=",
   "30",
   ",",
   "on_mult",
   "=",
   "(",
   "1.5",
   ",",
   "1.",
   ")",
   ",",
   "off_mult",
   "=",
   "(",
   "1.",
   ",",
   "1.5",
   ")",
   ",",
   "thresh",
   "=",
   "None",
   ")",
   ":",
   "failed",
   "=",
   "[",
   "]",
   "# smooth signal",
   "if",
   "swin",
   "is",
   "not",
   "None",
   ":",
   "sigs",
   "=",
   "fastsmooth",
   "(",
   "sig",
   ",",
   "swin",
   ")",
   "else",
   ":",
   "sigs",
   "=",
   "sig",
   "# transform signal",
   "if",
   "transform",
   "==",
   "'log'",
   ":",
   "tsigs",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "sigs",
   ")",
   "tsig",
   "=",
   "np",
   ".",
   "log10",
   "(",
   "sig",
   ")",
   "else",
   ":",
   "tsigs",
   "=",
   "sigs",
   "tsig",
   "=",
   "sig",
   "if",
   "thresh",
   "is",
   "None",
   ":",
   "bins",
   "=",
   "50",
   "kde_x",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "tsigs",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "tsigs",
   ".",
   "max",
   "(",
   ")",
   ",",
   "bins",
   ")",
   "kde",
   "=",
   "gaussian_kde",
   "(",
   "tsigs",
   ")",
   "yd",
   "=",
   "kde",
   ".",
   "pdf",
   "(",
   "kde_x",
   ")",
   "mins",
   "=",
   "findmins",
   "(",
   "kde_x",
   ",",
   "yd",
   ")",
   "# find minima in kde",
   "if",
   "len",
   "(",
   "mins",
   ")",
   ">",
   "0",
   ":",
   "bkg",
   "=",
   "tsigs",
   "<",
   "(",
   "mins",
   "[",
   "0",
   "]",
   ")",
   "# set background as lowest distribution",
   "thresh",
   "=",
   "mins",
   "[",
   "0",
   "]",
   "else",
   ":",
   "bkg",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "tsigs",
   ".",
   "size",
   ",",
   "dtype",
   "=",
   "bool",
   ")",
   "else",
   ":",
   "bkg",
   "=",
   "tsigs",
   "<",
   "thresh",
   "# assign rough background and signal regions based on kde minima",
   "fbkg",
   "=",
   "bkg",
   "fsig",
   "=",
   "~",
   "bkg",
   "# remove transitions by fitting a gaussian to the gradients of",
   "# each transition",
   "# 1. determine the approximate index of each transition",
   "zeros",
   "=",
   "bool_2_indices",
   "(",
   "fsig",
   ")",
   "# 2. calculate the absolute gradient of the target trace.",
   "g",
   "=",
   "abs",
   "(",
   "fastgrad",
   "(",
   "sigs",
   ",",
   "gwin",
   ")",
   ")",
   "# gradient of untransformed data.",
   "if",
   "zeros",
   "is",
   "not",
   "None",
   ":",
   "zeros",
   "=",
   "zeros",
   ".",
   "flatten",
   "(",
   ")",
   "trans",
   "=",
   "dict",
   "(",
   "zeros",
   "=",
   "zeros",
   ".",
   "flatten",
   "(",
   ")",
   ",",
   "lohi",
   "=",
   "[",
   "]",
   ",",
   "pgs",
   "=",
   "[",
   "]",
   ",",
   "excl",
   "=",
   "[",
   "]",
   ",",
   "tps",
   "=",
   "[",
   "]",
   ",",
   "failed",
   "=",
   "[",
   "]",
   ",",
   "xs",
   "=",
   "[",
   "]",
   ",",
   "ys",
   "=",
   "[",
   "]",
   ")",
   "for",
   "z",
   "in",
   "zeros",
   ":",
   "# for each approximate transition",
   "# isolate the data around the transition",
   "if",
   "z",
   "-",
   "win",
   "<",
   "0",
   ":",
   "lo",
   "=",
   "gwin",
   "//",
   "2",
   "hi",
   "=",
   "int",
   "(",
   "z",
   "+",
   "win",
   ")",
   "elif",
   "z",
   "+",
   "win",
   ">",
   "(",
   "len",
   "(",
   "sig",
   ")",
   "-",
   "gwin",
   "//",
   "2",
   ")",
   ":",
   "lo",
   "=",
   "int",
   "(",
   "z",
   "-",
   "win",
   ")",
   "hi",
   "=",
   "len",
   "(",
   "sig",
   ")",
   "-",
   "gwin",
   "//",
   "2",
   "else",
   ":",
   "lo",
   "=",
   "int",
   "(",
   "z",
   "-",
   "win",
   ")",
   "hi",
   "=",
   "int",
   "(",
   "z",
   "+",
   "win",
   ")",
   "xs",
   "=",
   "t",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "ys",
   "=",
   "g",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "trans",
   "[",
   "'xs'",
   "]",
   ".",
   "append",
   "(",
   "xs",
   ")",
   "trans",
   "[",
   "'ys'",
   "]",
   ".",
   "append",
   "(",
   "ys",
   ")",
   "trans",
   "[",
   "'lohi'",
   "]",
   ".",
   "append",
   "(",
   "[",
   "lo",
   ",",
   "hi",
   "]",
   ")",
   "# determine type of transition (on/off)",
   "mid",
   "=",
   "(",
   "hi",
   "+",
   "lo",
   ")",
   "//",
   "2",
   "tp",
   "=",
   "sigs",
   "[",
   "mid",
   "+",
   "3",
   "]",
   ">",
   "sigs",
   "[",
   "mid",
   "-",
   "3",
   "]",
   "# True if 'on' transition.",
   "trans",
   "[",
   "'tps'",
   "]",
   ".",
   "append",
   "(",
   "tp",
   ")",
   "c",
   "=",
   "t",
   "[",
   "z",
   "]",
   "# center of transition",
   "width",
   "=",
   "(",
   "t",
   "[",
   "1",
   "]",
   "-",
   "t",
   "[",
   "0",
   "]",
   ")",
   "*",
   "2",
   "# initial width guess",
   "try",
   ":",
   "pg",
   ",",
   "_",
   "=",
   "curve_fit",
   "(",
   "gauss",
   ",",
   "xs",
   ",",
   "ys",
   ",",
   "p0",
   "=",
   "(",
   "np",
   ".",
   "nanmax",
   "(",
   "ys",
   ")",
   ",",
   "c",
   ",",
   "width",
   ")",
   ",",
   "sigma",
   "=",
   "(",
   "xs",
   "-",
   "c",
   ")",
   "**",
   "2",
   "+",
   ".01",
   ")",
   "trans",
   "[",
   "'pgs'",
   "]",
   ".",
   "append",
   "(",
   "pg",
   ")",
   "fwhm",
   "=",
   "abs",
   "(",
   "2",
   "*",
   "pg",
   "[",
   "-",
   "1",
   "]",
   "*",
   "np",
   ".",
   "sqrt",
   "(",
   "2",
   "*",
   "np",
   ".",
   "log",
   "(",
   "2",
   ")",
   ")",
   ")",
   "# apply on_mult or off_mult, as appropriate.",
   "if",
   "tp",
   ":",
   "lim",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "-",
   "fwhm",
   ",",
   "fwhm",
   "]",
   ")",
   "*",
   "on_mult",
   "+",
   "pg",
   "[",
   "1",
   "]",
   "else",
   ":",
   "lim",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "-",
   "fwhm",
   ",",
   "fwhm",
   "]",
   ")",
   "*",
   "off_mult",
   "+",
   "pg",
   "[",
   "1",
   "]",
   "trans",
   "[",
   "'excl'",
   "]",
   ".",
   "append",
   "(",
   "lim",
   ")",
   "fbkg",
   "[",
   "(",
   "t",
   ">",
   "lim",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<",
   "lim",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "False",
   "fsig",
   "[",
   "(",
   "t",
   ">",
   "lim",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<",
   "lim",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "False",
   "failed",
   ".",
   "append",
   "(",
   "False",
   ")",
   "except",
   "RuntimeError",
   ":",
   "failed",
   ".",
   "append",
   "(",
   "True",
   ")",
   "trans",
   "[",
   "'lohi'",
   "]",
   ".",
   "append",
   "(",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   ")",
   "trans",
   "[",
   "'pgs'",
   "]",
   ".",
   "append",
   "(",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   ")",
   "trans",
   "[",
   "'excl'",
   "]",
   ".",
   "append",
   "(",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   ")",
   "trans",
   "[",
   "'tps'",
   "]",
   ".",
   "append",
   "(",
   "tp",
   ")",
   "pass",
   "else",
   ":",
   "zeros",
   "=",
   "[",
   "]",
   "return",
   "t",
   ",",
   "sig",
   ",",
   "sigs",
   ",",
   "tsig",
   ",",
   "tsigs",
   ",",
   "kde_x",
   ",",
   "yd",
   ",",
   "g",
   ",",
   "trans",
   ",",
   "thresh"
  ]
 },
 {
  "idx": "maxmin-1000",
  "nl_tokens": [
   "Clears",
   "out",
   "the",
   "previous",
   "line",
   "and",
   "prints",
   "a",
   "new",
   "one",
   "."
  ],
  "pl_tokens": [
   "def",
   "print_inplace",
   "(",
   "msg",
   ")",
   ":",
   "term_width",
   "=",
   "get_terminal_size",
   "(",
   ")",
   ".",
   "columns",
   "spacing",
   "=",
   "term_width",
   "-",
   "terminal_width",
   "(",
   "msg",
   ")",
   "# On windows we need one less space or we overflow the line for some reason.",
   "if",
   "is_win32",
   ":",
   "spacing",
   "-=",
   "1",
   "sys",
   ".",
   "stderr",
   ".",
   "write",
   "(",
   "\"\\r{0}\"",
   ".",
   "format",
   "(",
   "msg",
   ")",
   ")",
   "sys",
   ".",
   "stderr",
   ".",
   "write",
   "(",
   "\" \"",
   "*",
   "<mask>",
   "(",
   "0",
   ",",
   "spacing",
   ")",
   ")",
   "sys",
   ".",
   "stderr",
   ".",
   "flush",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1001",
  "nl_tokens": [
   "Calculate",
   "the",
   "margin",
   "in",
   "pixels",
   "to",
   "the",
   "right",
   "of",
   "the",
   "plot",
   "area",
   "setting",
   "border_right",
   "."
  ],
  "pl_tokens": [
   "def",
   "calculate_right_margin",
   "(",
   "self",
   ")",
   ":",
   "br",
   "=",
   "7",
   "if",
   "self",
   ".",
   "key",
   "and",
   "self",
   ".",
   "key_position",
   "==",
   "'right'",
   ":",
   "max_key_len",
   "=",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "self",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ")",
   "br",
   "+=",
   "max_key_len",
   "*",
   "self",
   ".",
   "key_font_size",
   "*",
   "0.6",
   "br",
   "+=",
   "self",
   ".",
   "KEY_BOX_SIZE",
   "br",
   "+=",
   "10",
   "# Some padding around the box",
   "self",
   ".",
   "border_right",
   "=",
   "br"
  ]
 },
 {
  "idx": "maxmin-1002",
  "nl_tokens": [
   "Split",
   "an",
   "audio",
   "signal",
   "into",
   "non",
   "-",
   "silent",
   "intervals",
   "."
  ],
  "pl_tokens": [
   "def",
   "split",
   "(",
   "y",
   ",",
   "top_db",
   "=",
   "60",
   ",",
   "ref",
   "=",
   "np",
   ".",
   "<mask>",
   ",",
   "frame_length",
   "=",
   "2048",
   ",",
   "hop_length",
   "=",
   "512",
   ")",
   ":",
   "non_silent",
   "=",
   "_signal_to_frame_nonsilent",
   "(",
   "y",
   ",",
   "frame_length",
   "=",
   "frame_length",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ",",
   "ref",
   "=",
   "ref",
   ",",
   "top_db",
   "=",
   "top_db",
   ")",
   "# Interval slicing, adapted from",
   "# https://stackoverflow.com/questions/2619413/efficiently-finding-the-interval-with-non-zeros-in-scipy-numpy-in-python",
   "# Find points where the sign flips",
   "edges",
   "=",
   "np",
   ".",
   "flatnonzero",
   "(",
   "np",
   ".",
   "diff",
   "(",
   "non_silent",
   ".",
   "astype",
   "(",
   "int",
   ")",
   ")",
   ")",
   "# Pad back the sample lost in the diff",
   "edges",
   "=",
   "[",
   "edges",
   "+",
   "1",
   "]",
   "# If the first frame had high energy, count it",
   "if",
   "non_silent",
   "[",
   "0",
   "]",
   ":",
   "edges",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "[",
   "0",
   "]",
   ")",
   "# Likewise for the last frame",
   "if",
   "non_silent",
   "[",
   "-",
   "1",
   "]",
   ":",
   "edges",
   ".",
   "append",
   "(",
   "[",
   "len",
   "(",
   "non_silent",
   ")",
   "]",
   ")",
   "# Convert from frames to samples",
   "edges",
   "=",
   "core",
   ".",
   "frames_to_samples",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "edges",
   ")",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "# Clip to the signal duration",
   "edges",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "edges",
   ",",
   "y",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ")",
   "# Stack the results back as an ndarray",
   "return",
   "edges",
   ".",
   "reshape",
   "(",
   "(",
   "-",
   "1",
   ",",
   "2",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1003",
  "nl_tokens": [
   "Find",
   "lines",
   "in",
   "home",
   "that",
   "are",
   "inspectable",
   ".",
   "Walk",
   "back",
   "from",
   "the",
   "err",
   "line",
   "up",
   "to",
   "3",
   "lines",
   "but",
   "don",
   "t",
   "walk",
   "back",
   "over",
   "changes",
   "in",
   "indent",
   "level",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_inspectable_lines",
   "(",
   "lines",
   ",",
   "pos",
   ")",
   ":",
   "cnt",
   "=",
   "re",
   ".",
   "compile",
   "(",
   "r'\\\\[\\s\\n]*$'",
   ")",
   "df",
   "=",
   "re",
   ".",
   "compile",
   "(",
   "r':[\\s\\n]*$'",
   ")",
   "ind",
   "=",
   "re",
   ".",
   "compile",
   "(",
   "r'^(\\s*)'",
   ")",
   "toinspect",
   "=",
   "[",
   "]",
   "home",
   "=",
   "lines",
   "[",
   "pos",
   "]",
   "home_indent",
   "=",
   "ind",
   ".",
   "match",
   "(",
   "home",
   ")",
   ".",
   "groups",
   "(",
   ")",
   "[",
   "0",
   "]",
   "before",
   "=",
   "lines",
   "[",
   "<mask>",
   "(",
   "pos",
   "-",
   "3",
   ",",
   "0",
   ")",
   ":",
   "pos",
   "]",
   "before",
   ".",
   "reverse",
   "(",
   ")",
   "after",
   "=",
   "lines",
   "[",
   "pos",
   "+",
   "1",
   ":",
   "min",
   "(",
   "pos",
   "+",
   "4",
   ",",
   "len",
   "(",
   "lines",
   ")",
   ")",
   "]",
   "for",
   "line",
   "in",
   "before",
   ":",
   "if",
   "ind",
   ".",
   "match",
   "(",
   "line",
   ")",
   ".",
   "groups",
   "(",
   ")",
   "[",
   "0",
   "]",
   "==",
   "home_indent",
   ":",
   "toinspect",
   ".",
   "append",
   "(",
   "line",
   ")",
   "else",
   ":",
   "break",
   "toinspect",
   ".",
   "reverse",
   "(",
   ")",
   "toinspect",
   ".",
   "append",
   "(",
   "home",
   ")",
   "home_pos",
   "=",
   "len",
   "(",
   "toinspect",
   ")",
   "-",
   "1",
   "continued",
   "=",
   "cnt",
   ".",
   "search",
   "(",
   "home",
   ")",
   "for",
   "line",
   "in",
   "after",
   ":",
   "if",
   "(",
   "(",
   "continued",
   "or",
   "ind",
   ".",
   "match",
   "(",
   "line",
   ")",
   ".",
   "groups",
   "(",
   ")",
   "[",
   "0",
   "]",
   "==",
   "home_indent",
   ")",
   "and",
   "not",
   "df",
   ".",
   "search",
   "(",
   "line",
   ")",
   ")",
   ":",
   "toinspect",
   ".",
   "append",
   "(",
   "line",
   ")",
   "continued",
   "=",
   "cnt",
   ".",
   "search",
   "(",
   "line",
   ")",
   "else",
   ":",
   "break",
   "log",
   ".",
   "debug",
   "(",
   "\"Inspecting lines '''%s''' around %s\"",
   ",",
   "toinspect",
   ",",
   "home_pos",
   ")",
   "return",
   "toinspect",
   ",",
   "home_pos"
  ]
 },
 {
  "idx": "maxmin-1004",
  "nl_tokens": [
   "Fetch",
   "the",
   "messages"
  ],
  "pl_tokens": [
   "def",
   "fetch_items",
   "(",
   "self",
   ",",
   "category",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "offset",
   "=",
   "kwargs",
   "[",
   "'offset'",
   "]",
   "chats",
   "=",
   "kwargs",
   "[",
   "'chats'",
   "]",
   "logger",
   ".",
   "info",
   "(",
   "\"Looking for messages of '%s' bot from offset '%s'\"",
   ",",
   "self",
   ".",
   "bot",
   ",",
   "offset",
   ")",
   "if",
   "chats",
   "is",
   "not",
   "None",
   ":",
   "if",
   "len",
   "(",
   "chats",
   ")",
   "==",
   "0",
   ":",
   "logger",
   ".",
   "warning",
   "(",
   "\"Chat list filter is empty. No messages will be returned\"",
   ")",
   "else",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"Messages which belong to chats %s will be fetched\"",
   ",",
   "'['",
   "+",
   "','",
   ".",
   "join",
   "(",
   "str",
   "(",
   "ch_id",
   ")",
   "for",
   "ch_id",
   "in",
   "chats",
   ")",
   "+",
   "']'",
   ")",
   "nmsgs",
   "=",
   "0",
   "while",
   "True",
   ":",
   "raw_json",
   "=",
   "self",
   ".",
   "client",
   ".",
   "updates",
   "(",
   "offset",
   "=",
   "offset",
   ")",
   "messages",
   "=",
   "[",
   "msg",
   "for",
   "msg",
   "in",
   "self",
   ".",
   "parse_messages",
   "(",
   "raw_json",
   ")",
   "]",
   "if",
   "len",
   "(",
   "messages",
   ")",
   "==",
   "0",
   ":",
   "break",
   "for",
   "msg",
   "in",
   "messages",
   ":",
   "offset",
   "=",
   "<mask>",
   "(",
   "msg",
   "[",
   "'update_id'",
   "]",
   ",",
   "offset",
   ")",
   "if",
   "not",
   "self",
   ".",
   "_filter_message_by_chats",
   "(",
   "msg",
   ",",
   "chats",
   ")",
   ":",
   "logger",
   ".",
   "debug",
   "(",
   "\"Message %s does not belong to any chat; filtered\"",
   ",",
   "msg",
   "[",
   "'message'",
   "]",
   "[",
   "'message_id'",
   "]",
   ")",
   "continue",
   "yield",
   "msg",
   "nmsgs",
   "+=",
   "1",
   "offset",
   "+=",
   "1",
   "logger",
   ".",
   "info",
   "(",
   "\"Fetch process completed: %s messages fetched\"",
   ",",
   "nmsgs",
   ")"
  ]
 },
 {
  "idx": "maxmin-1005",
  "nl_tokens": [
   "add",
   "a",
   "dummy",
   "option",
   "section",
   "for",
   "help",
   "purpose"
  ],
  "pl_tokens": [
   "def",
   "add_help_section",
   "(",
   "self",
   ",",
   "title",
   ",",
   "description",
   ",",
   "level",
   "=",
   "0",
   ")",
   ":",
   "group",
   "=",
   "optparse",
   ".",
   "OptionGroup",
   "(",
   "self",
   ".",
   "cmdline_parser",
   ",",
   "title",
   "=",
   "title",
   ".",
   "capitalize",
   "(",
   ")",
   ",",
   "description",
   "=",
   "description",
   ")",
   "group",
   ".",
   "level",
   "=",
   "level",
   "self",
   ".",
   "_maxlevel",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_maxlevel",
   ",",
   "level",
   ")",
   "self",
   ".",
   "cmdline_parser",
   ".",
   "add_option_group",
   "(",
   "group",
   ")"
  ]
 },
 {
  "idx": "maxmin-1006",
  "nl_tokens": [
   "Find",
   "the",
   "strongly",
   "connected",
   "components",
   "in",
   "a",
   "graph",
   "using",
   "Tarjan",
   "s",
   "algorithm",
   ".",
   "The",
   "graph",
   "argument",
   "should",
   "be",
   "a",
   "dictionary",
   "mapping",
   "node",
   "names",
   "to",
   "sequences",
   "of",
   "successor",
   "nodes",
   "."
  ],
  "pl_tokens": [
   "def",
   "strongly_connected_components",
   "(",
   "graph",
   ":",
   "Graph",
   ")",
   "->",
   "List",
   ":",
   "assert",
   "check_argument_types",
   "(",
   ")",
   "result",
   "=",
   "[",
   "]",
   "stack",
   "=",
   "[",
   "]",
   "low",
   "=",
   "{",
   "}",
   "def",
   "visit",
   "(",
   "node",
   ":",
   "str",
   ")",
   ":",
   "if",
   "node",
   "in",
   "low",
   ":",
   "return",
   "num",
   "=",
   "len",
   "(",
   "low",
   ")",
   "low",
   "[",
   "node",
   "]",
   "=",
   "num",
   "stack_pos",
   "=",
   "len",
   "(",
   "stack",
   ")",
   "stack",
   ".",
   "append",
   "(",
   "node",
   ")",
   "for",
   "successor",
   "in",
   "graph",
   "[",
   "node",
   "]",
   ":",
   "visit",
   "(",
   "successor",
   ")",
   "low",
   "[",
   "node",
   "]",
   "=",
   "<mask>",
   "(",
   "low",
   "[",
   "node",
   "]",
   ",",
   "low",
   "[",
   "successor",
   "]",
   ")",
   "if",
   "num",
   "==",
   "low",
   "[",
   "node",
   "]",
   ":",
   "component",
   "=",
   "tuple",
   "(",
   "stack",
   "[",
   "stack_pos",
   ":",
   "]",
   ")",
   "del",
   "stack",
   "[",
   "stack_pos",
   ":",
   "]",
   "result",
   ".",
   "append",
   "(",
   "component",
   ")",
   "for",
   "item",
   "in",
   "component",
   ":",
   "low",
   "[",
   "item",
   "]",
   "=",
   "len",
   "(",
   "graph",
   ")",
   "for",
   "node",
   "in",
   "graph",
   ":",
   "visit",
   "(",
   "node",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-1007",
  "nl_tokens": [
   "Parses",
   "arguments",
   "for",
   "the",
   "list",
   "command",
   "and",
   "returns",
   "the",
   "tuple",
   ":",
   "(",
   "filename",
   "first",
   "line",
   "number",
   "last",
   "line",
   "number",
   ")",
   "or",
   "sets",
   "these",
   "to",
   "None",
   "if",
   "there",
   "was",
   "some",
   "problem",
   "."
  ],
  "pl_tokens": [
   "def",
   "parse_list_cmd",
   "(",
   "proc",
   ",",
   "args",
   ",",
   "listsize",
   "=",
   "10",
   ")",
   ":",
   "text",
   "=",
   "proc",
   ".",
   "current_command",
   "[",
   "len",
   "(",
   "args",
   "[",
   "0",
   "]",
   ")",
   "+",
   "1",
   ":",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "if",
   "text",
   "in",
   "frozenset",
   "(",
   "(",
   "''",
   ",",
   "'.'",
   ",",
   "'+'",
   ",",
   "'-'",
   ")",
   ")",
   ":",
   "if",
   "text",
   "==",
   "'.'",
   ":",
   "location",
   "=",
   "resolve_location",
   "(",
   "proc",
   ",",
   "'.'",
   ")",
   "return",
   "location",
   ".",
   "path",
   ",",
   "location",
   ".",
   "line_number",
   ",",
   "listsize",
   "else",
   ":",
   "if",
   "proc",
   ".",
   "list_lineno",
   "is",
   "None",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Don't have previous list location\"",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "filename",
   "=",
   "proc",
   ".",
   "list_filename",
   "if",
   "text",
   "==",
   "'+'",
   ":",
   "first",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "proc",
   ".",
   "list_lineno",
   "+",
   "listsize",
   ")",
   "elif",
   "text",
   "==",
   "'-'",
   ":",
   "if",
   "proc",
   ".",
   "list_lineno",
   "==",
   "1",
   "+",
   "listsize",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Already at start of %s.\"",
   "%",
   "proc",
   ".",
   "list_filename",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "first",
   "=",
   "max",
   "(",
   "1",
   ",",
   "proc",
   ".",
   "list_lineno",
   "-",
   "(",
   "2",
   "*",
   "listsize",
   ")",
   "-",
   "1",
   ")",
   "elif",
   "text",
   "==",
   "''",
   ":",
   "# Continue from where we last left off",
   "first",
   "=",
   "proc",
   ".",
   "list_lineno",
   "+",
   "1",
   "last",
   "=",
   "first",
   "+",
   "listsize",
   "-",
   "1",
   "return",
   "filename",
   ",",
   "first",
   ",",
   "last",
   "else",
   ":",
   "try",
   ":",
   "list_range",
   "=",
   "build_range",
   "(",
   "text",
   ")",
   "except",
   "LocationError",
   "as",
   "e",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Error in parsing list range at or around:\"",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text_cursor",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "except",
   "ScannerError",
   "as",
   "e",
   ":",
   "proc",
   ".",
   "errmsg",
   "(",
   "\"Lexical error in parsing list range at or around:\"",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text",
   ")",
   "proc",
   ".",
   "errmsg",
   "(",
   "e",
   ".",
   "text_cursor",
   ")",
   "return",
   "INVALID_PARSE_LIST",
   "if",
   "list_range",
   ".",
   "first",
   "is",
   "None",
   ":",
   "# Last must have been given",
   "assert",
   "isinstance",
   "(",
   "list_range",
   ".",
   "last",
   ",",
   "Location",
   ")",
   "location",
   "=",
   "resolve_location",
   "(",
   "proc",
   ",",
   "list_range",
   ".",
   "last",
   ")",
   "if",
   "not",
   "location",
   ":",
   "return",
   "INVALID_PARSE_LIST",
   "last",
   "=",
   "location",
   ".",
   "line_number",
   "first",
   "=",
   "max",
   "(",
   "1",
   ",",
   "last",
   "-",
   "listsize",
   ")",
   "return",
   "location",
   ".",
   "path",
   ",",
   "first",
   ",",
   "last",
   "elif",
   "isinstance",
   "(",
   "list_range",
   ".",
   "first",
   ",",
   "int",
   ")",
   ":",
   "first",
   "=",
   "list_range",
   ".",
   "first",
   "location",
   "=",
   "resolve_location",
   "(",
   "proc",
   ",",
   "list_range",
   ".",
   "last",
   ")",
   "if",
   "not",
   "location",
   ":",
   "return",
   "INVALID_PARSE_LIST",
   "filename",
   "=",
   "location",
   ".",
   "path",
   "last",
   "=",
   "location",
   ".",
   "line_number",
   "if",
   "last",
   "<",
   "first",
   ":",
   "# Treat as a count rather than an absolute location",
   "last",
   "=",
   "first",
   "+",
   "last",
   "return",
   "location",
   ".",
   "path",
   ",",
   "first",
   ",",
   "last",
   "else",
   ":",
   "# First is location. Last may be empty or a number",
   "assert",
   "isinstance",
   "(",
   "list_range",
   ".",
   "first",
   ",",
   "Location",
   ")",
   "location",
   "=",
   "resolve_location",
   "(",
   "proc",
   ",",
   "list_range",
   ".",
   "first",
   ")",
   "if",
   "not",
   "location",
   ":",
   "return",
   "INVALID_PARSE_LIST",
   "first",
   "=",
   "location",
   ".",
   "line_number",
   "last",
   "=",
   "list_range",
   ".",
   "last",
   "if",
   "location",
   ".",
   "method",
   ":",
   "first",
   "-=",
   "listsize",
   "//",
   "2",
   "if",
   "isinstance",
   "(",
   "last",
   ",",
   "str",
   ")",
   ":",
   "# Is an offset +number",
   "assert",
   "last",
   "[",
   "0",
   "]",
   "==",
   "'+'",
   "last",
   "=",
   "first",
   "+",
   "int",
   "(",
   "last",
   "[",
   "1",
   ":",
   "]",
   ")",
   "elif",
   "not",
   "last",
   ":",
   "last",
   "=",
   "first",
   "+",
   "listsize",
   "elif",
   "last",
   "<",
   "first",
   ":",
   "# Treat as a count rather than an absolute location",
   "last",
   "=",
   "first",
   "+",
   "last",
   "return",
   "location",
   ".",
   "path",
   ",",
   "first",
   ",",
   "last",
   "pass",
   "return"
  ]
 },
 {
  "idx": "maxmin-1008",
  "nl_tokens": [
   "Determine",
   "whether",
   "the",
   "desired",
   "version",
   "is",
   "a",
   "reasonable",
   "next",
   "version",
   "."
  ],
  "pl_tokens": [
   "def",
   "reasonable_desired_version",
   "(",
   "self",
   ",",
   "desired_version",
   ",",
   "allow_equal",
   "=",
   "False",
   ",",
   "allow_patch_skip",
   "=",
   "False",
   ")",
   ":",
   "try",
   ":",
   "desired_version",
   "=",
   "desired_version",
   ".",
   "base_version",
   "except",
   ":",
   "pass",
   "(",
   "new_major",
   ",",
   "new_minor",
   ",",
   "new_patch",
   ")",
   "=",
   "map",
   "(",
   "int",
   ",",
   "desired_version",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   ")",
   "tag_versions",
   "=",
   "self",
   ".",
   "_versions_from_tags",
   "(",
   ")",
   "if",
   "not",
   "tag_versions",
   ":",
   "# no tags yet, and legal version is legal!",
   "return",
   "\"\"",
   "max_version",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_versions_from_tags",
   "(",
   ")",
   ")",
   ".",
   "base_version",
   "(",
   "old_major",
   ",",
   "old_minor",
   ",",
   "old_patch",
   ")",
   "=",
   "map",
   "(",
   "int",
   ",",
   "str",
   "(",
   "max_version",
   ")",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   ")",
   "update_str",
   "=",
   "str",
   "(",
   "max_version",
   ")",
   "+",
   "\" -> \"",
   "+",
   "str",
   "(",
   "desired_version",
   ")",
   "v_desired",
   "=",
   "vers",
   ".",
   "Version",
   "(",
   "desired_version",
   ")",
   "v_max",
   "=",
   "vers",
   ".",
   "Version",
   "(",
   "max_version",
   ")",
   "if",
   "allow_equal",
   "and",
   "v_desired",
   "==",
   "v_max",
   ":",
   "return",
   "\"\"",
   "if",
   "v_desired",
   "<",
   "v_max",
   ":",
   "return",
   "(",
   "\"Bad update: New version doesn't increase on last tag: \"",
   "+",
   "update_str",
   "+",
   "\"\\n\"",
   ")",
   "bad_update",
   "=",
   "skipped_version",
   "(",
   "(",
   "old_major",
   ",",
   "old_minor",
   ",",
   "old_patch",
   ")",
   ",",
   "(",
   "new_major",
   ",",
   "new_minor",
   ",",
   "new_patch",
   ")",
   ",",
   "allow_patch_skip",
   ")",
   "msg",
   "=",
   "\"\"",
   "if",
   "bad_update",
   ":",
   "msg",
   "=",
   "(",
   "\"Bad update: Did you skip a version from \"",
   "+",
   "update_str",
   "+",
   "\"?\\n\"",
   ")",
   "return",
   "msg"
  ]
 },
 {
  "idx": "maxmin-1009",
  "nl_tokens": [
   "Calculate",
   "the",
   "concurrence",
   "."
  ],
  "pl_tokens": [
   "def",
   "concurrence",
   "(",
   "state",
   ")",
   ":",
   "rho",
   "=",
   "np",
   ".",
   "array",
   "(",
   "state",
   ")",
   "if",
   "rho",
   ".",
   "ndim",
   "==",
   "1",
   ":",
   "rho",
   "=",
   "outer",
   "(",
   "state",
   ")",
   "if",
   "len",
   "(",
   "state",
   ")",
   "!=",
   "4",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Concurrence is only defined for more than two qubits\"",
   ")",
   "YY",
   "=",
   "np",
   ".",
   "fliplr",
   "(",
   "np",
   ".",
   "diag",
   "(",
   "[",
   "-",
   "1",
   ",",
   "1",
   ",",
   "1",
   ",",
   "-",
   "1",
   "]",
   ")",
   ")",
   "A",
   "=",
   "rho",
   ".",
   "dot",
   "(",
   "YY",
   ")",
   ".",
   "dot",
   "(",
   "rho",
   ".",
   "conj",
   "(",
   ")",
   ")",
   ".",
   "dot",
   "(",
   "YY",
   ")",
   "w",
   "=",
   "la",
   ".",
   "eigh",
   "(",
   "A",
   ",",
   "eigvals_only",
   "=",
   "True",
   ")",
   "w",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "maximum",
   "(",
   "w",
   ",",
   "0",
   ")",
   ")",
   "return",
   "<mask>",
   "(",
   "0.0",
   ",",
   "w",
   "[",
   "-",
   "1",
   "]",
   "-",
   "np",
   ".",
   "sum",
   "(",
   "w",
   "[",
   "0",
   ":",
   "-",
   "1",
   "]",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1010",
  "nl_tokens": [
   "Bounded",
   "auto",
   "-",
   "correlation"
  ],
  "pl_tokens": [
   "def",
   "autocorrelate",
   "(",
   "y",
   ",",
   "max_size",
   "=",
   "None",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   ":",
   "if",
   "max_size",
   "is",
   "None",
   ":",
   "max_size",
   "=",
   "y",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   "max_size",
   "=",
   "int",
   "(",
   "<mask>",
   "(",
   "max_size",
   ",",
   "y",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   ")",
   ")",
   "# Compute the power spectrum along the chosen axis",
   "# Pad out the signal to support full-length auto-correlation.",
   "fft",
   "=",
   "get_fftlib",
   "(",
   ")",
   "powspec",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "fft",
   ".",
   "fft",
   "(",
   "y",
   ",",
   "n",
   "=",
   "2",
   "*",
   "y",
   ".",
   "shape",
   "[",
   "axis",
   "]",
   "+",
   "1",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   ")",
   "**",
   "2",
   "# Convert back to time domain",
   "autocorr",
   "=",
   "fft",
   ".",
   "ifft",
   "(",
   "powspec",
   ",",
   "axis",
   "=",
   "axis",
   ")",
   "# Slice down to max_size",
   "subslice",
   "=",
   "[",
   "slice",
   "(",
   "None",
   ")",
   "]",
   "*",
   "autocorr",
   ".",
   "ndim",
   "subslice",
   "[",
   "axis",
   "]",
   "=",
   "slice",
   "(",
   "max_size",
   ")",
   "autocorr",
   "=",
   "autocorr",
   "[",
   "tuple",
   "(",
   "subslice",
   ")",
   "]",
   "if",
   "not",
   "np",
   ".",
   "iscomplexobj",
   "(",
   "y",
   ")",
   ":",
   "autocorr",
   "=",
   "autocorr",
   ".",
   "real",
   "return",
   "autocorr"
  ]
 },
 {
  "idx": "maxmin-1011",
  "nl_tokens": [
   "Given",
   "the",
   "bit",
   "pattern",
   "lengths",
   "for",
   "symbols",
   "given",
   "in",
   "lengthTable",
   "set",
   "decodeTable",
   "minLength",
   "maxLength"
  ],
  "pl_tokens": [
   "def",
   "setLength",
   "(",
   "self",
   ",",
   "lengthTable",
   ")",
   ":",
   "self",
   ".",
   "lengthTable",
   "=",
   "lengthTable",
   "self",
   ".",
   "minLength",
   "=",
   "<mask>",
   "(",
   "lengthTable",
   ".",
   "values",
   "(",
   ")",
   ")",
   "self",
   ".",
   "maxLength",
   "=",
   "max",
   "(",
   "lengthTable",
   ".",
   "values",
   "(",
   ")",
   ")",
   "#compute the backwards codes first; then reverse them",
   "#compute (backwards) first code for every separate lengths",
   "nextCodes",
   "=",
   "[",
   "]",
   "#build codes for each length, from right to left",
   "code",
   "=",
   "0",
   "for",
   "bits",
   "in",
   "range",
   "(",
   "self",
   ".",
   "maxLength",
   "+",
   "1",
   ")",
   ":",
   "code",
   "<<=",
   "1",
   "nextCodes",
   ".",
   "append",
   "(",
   "code",
   ")",
   "code",
   "+=",
   "sum",
   "(",
   "x",
   "==",
   "bits",
   "for",
   "x",
   "in",
   "lengthTable",
   ".",
   "values",
   "(",
   ")",
   ")",
   "self",
   ".",
   "decodeTable",
   "=",
   "{",
   "}",
   "#count codes for each length, and store reversed in the table",
   "for",
   "symbol",
   "in",
   "sorted",
   "(",
   "lengthTable",
   ")",
   ":",
   "bits",
   "=",
   "lengthTable",
   "[",
   "symbol",
   "]",
   "bitpattern",
   "=",
   "'{:0{}b}'",
   ".",
   "format",
   "(",
   "nextCodes",
   "[",
   "bits",
   "]",
   ",",
   "bits",
   ")",
   "self",
   ".",
   "decodeTable",
   "[",
   "int",
   "(",
   "bitpattern",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "2",
   ")",
   "]",
   "=",
   "symbol",
   "nextCodes",
   "[",
   "bits",
   "]",
   "+=",
   "1",
   "self",
   ".",
   "switchToPrefix",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1012",
  "nl_tokens": [
   "A",
   "Python",
   "implementation",
   "of",
   "the",
   "Matlab",
   "code",
   "http",
   ":",
   "//",
   "www",
   ".",
   "santafe",
   ".",
   "edu",
   "/",
   "~aaronc",
   "/",
   "powerlaws",
   "/",
   "plfit",
   ".",
   "m",
   "from",
   "http",
   ":",
   "//",
   "www",
   ".",
   "santafe",
   ".",
   "edu",
   "/",
   "~aaronc",
   "/",
   "powerlaws",
   "/"
  ],
  "pl_tokens": [
   "def",
   "plfit",
   "(",
   "x",
   ",",
   "nosmall",
   "=",
   "False",
   ",",
   "finite",
   "=",
   "False",
   ")",
   ":",
   "xmins",
   "=",
   "unique",
   "(",
   "x",
   ")",
   "xmins",
   "=",
   "xmins",
   "[",
   "1",
   ":",
   "-",
   "1",
   "]",
   "dat",
   "=",
   "xmins",
   "*",
   "0",
   "z",
   "=",
   "sort",
   "(",
   "x",
   ")",
   "for",
   "xm",
   "in",
   "arange",
   "(",
   "len",
   "(",
   "xmins",
   ")",
   ")",
   ":",
   "xmin",
   "=",
   "xmins",
   "[",
   "xm",
   "]",
   "z",
   "=",
   "z",
   "[",
   "z",
   ">=",
   "xmin",
   "]",
   "n",
   "=",
   "float",
   "(",
   "len",
   "(",
   "z",
   ")",
   ")",
   "# estimate alpha using direct MLE",
   "a",
   "=",
   "n",
   "/",
   "sum",
   "(",
   "log",
   "(",
   "z",
   "/",
   "xmin",
   ")",
   ")",
   "if",
   "nosmall",
   ":",
   "# 4. For continuous data, PLFIT can return erroneously large estimates of ",
   "#    alpha when xmin is so large that the number of obs x >= xmin is very ",
   "#    small. To prevent this, we can truncate the search over xmin values ",
   "#    before the finite-size bias becomes significant by calling PLFIT as",
   "if",
   "(",
   "a",
   "-",
   "1",
   ")",
   "/",
   "sqrt",
   "(",
   "n",
   ")",
   ">",
   "0.1",
   ":",
   "#dat(xm:end) = [];",
   "dat",
   "=",
   "dat",
   "[",
   ":",
   "xm",
   "]",
   "xm",
   "=",
   "len",
   "(",
   "xmins",
   ")",
   "+",
   "1",
   "break",
   "# compute KS statistic",
   "cx",
   "=",
   "arange",
   "(",
   "n",
   ")",
   "/",
   "float",
   "(",
   "n",
   ")",
   "#data",
   "cf",
   "=",
   "1",
   "-",
   "(",
   "xmin",
   "/",
   "z",
   ")",
   "**",
   "a",
   "# fitted",
   "dat",
   "[",
   "xm",
   "]",
   "=",
   "<mask>",
   "(",
   "abs",
   "(",
   "cf",
   "-",
   "cx",
   ")",
   ")",
   "D",
   "=",
   "min",
   "(",
   "dat",
   ")",
   "#xmin  = xmins(find(dat<=D,1,'first'));",
   "xmin",
   "=",
   "xmins",
   "[",
   "argmin",
   "(",
   "dat",
   ")",
   "]",
   "z",
   "=",
   "x",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "n",
   "=",
   "len",
   "(",
   "z",
   ")",
   "alpha",
   "=",
   "1",
   "+",
   "n",
   "/",
   "sum",
   "(",
   "log",
   "(",
   "z",
   "/",
   "xmin",
   ")",
   ")",
   "if",
   "finite",
   ":",
   "alpha",
   "=",
   "alpha",
   "*",
   "(",
   "n",
   "-",
   "1",
   ")",
   "/",
   "n",
   "+",
   "1",
   "/",
   "n",
   "if",
   "n",
   "<",
   "50",
   "and",
   "~",
   "finite",
   ":",
   "print",
   "'(PLFIT) Warning: finite-size bias may be present.'",
   "L",
   "=",
   "n",
   "*",
   "log",
   "(",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   ")",
   "-",
   "alpha",
   "*",
   "sum",
   "(",
   "log",
   "(",
   "z",
   "/",
   "xmin",
   ")",
   ")",
   "return",
   "xmin",
   ",",
   "alpha",
   ",",
   "L",
   ",",
   "dat"
  ]
 },
 {
  "idx": "maxmin-1013",
  "nl_tokens": [
   "Render",
   "the",
   "widget",
   "."
  ],
  "pl_tokens": [
   "def",
   "render",
   "(",
   "self",
   ",",
   "progress",
   ",",
   "width",
   "=",
   "None",
   ",",
   "status",
   "=",
   "None",
   ")",
   ":",
   "if",
   "width",
   "<=",
   "3",
   ":",
   "return",
   "RenderResult",
   "(",
   ")",
   "bar_width",
   "=",
   "width",
   "-",
   "2",
   "# Total width minus the bar ends",
   "n_chars",
   "=",
   "int",
   "(",
   "progress",
   "*",
   "bar_width",
   "+",
   "0.001",
   ")",
   "endf",
   ",",
   "endl",
   "=",
   "self",
   ".",
   "_bar_ends",
   "if",
   "self",
   ".",
   "_file_mode",
   ":",
   "out",
   "=",
   "endf",
   "out",
   "+=",
   "self",
   ".",
   "_bar_symbols",
   "[",
   "-",
   "1",
   "]",
   "*",
   "n_chars",
   "out",
   "+=",
   "endl",
   "if",
   "progress",
   "==",
   "1",
   "else",
   "\"\"",
   "if",
   "status",
   ":",
   "out",
   "+=",
   "\" (%s)\"",
   "%",
   "status",
   "next_progress",
   "=",
   "(",
   "n_chars",
   "+",
   "1",
   ")",
   "/",
   "bar_width",
   "rendered_len",
   "=",
   "len",
   "(",
   "out",
   ")",
   "else",
   ":",
   "frac_chars",
   "=",
   "int",
   "(",
   "(",
   "progress",
   "*",
   "bar_width",
   "-",
   "n_chars",
   ")",
   "*",
   "len",
   "(",
   "self",
   ".",
   "_bar_symbols",
   ")",
   ")",
   "out",
   "=",
   "endf",
   "out",
   "+=",
   "self",
   ".",
   "_bar_symbols",
   "[",
   "-",
   "1",
   "]",
   "*",
   "n_chars",
   "out",
   "+=",
   "self",
   ".",
   "_bar_symbols",
   "[",
   "frac_chars",
   "-",
   "1",
   "]",
   "if",
   "frac_chars",
   ">",
   "0",
   "else",
   "\"\"",
   "rendered_len",
   "=",
   "len",
   "(",
   "out",
   ")",
   "if",
   "status",
   ":",
   "out",
   "+=",
   "colorama",
   ".",
   "Fore",
   ".",
   "RED",
   "+",
   "\" (\"",
   "+",
   "status",
   "+",
   "\")\"",
   "+",
   "colorama",
   ".",
   "Style",
   ".",
   "RESET_ALL",
   "rendered_len",
   "+=",
   "3",
   "+",
   "len",
   "(",
   "status",
   ")",
   "out",
   "+=",
   "\" \"",
   "*",
   "(",
   "width",
   "-",
   "1",
   "-",
   "rendered_len",
   ")",
   "out",
   "+=",
   "endl",
   "next_progress",
   "=",
   "(",
   "n_chars",
   "+",
   "(",
   "frac_chars",
   "+",
   "1",
   ")",
   "/",
   "len",
   "(",
   "self",
   ".",
   "_bar_symbols",
   ")",
   ")",
   "/",
   "bar_width",
   "rendered_len",
   "+=",
   "<mask>",
   "(",
   "0",
   ",",
   "width",
   "-",
   "1",
   "-",
   "rendered_len",
   ")",
   "+",
   "1",
   "return",
   "RenderResult",
   "(",
   "rendered",
   "=",
   "out",
   ",",
   "length",
   "=",
   "rendered_len",
   ",",
   "next_progress",
   "=",
   "next_progress",
   ")"
  ]
 },
 {
  "idx": "maxmin-1014",
  "nl_tokens": [
   "Normalizes",
   "features",
   "such",
   "that",
   "each",
   "vector",
   "is",
   "between",
   "floor",
   "to",
   "1",
   "."
  ],
  "pl_tokens": [
   "def",
   "min_max_normalize",
   "(",
   "F",
   ",",
   "floor",
   "=",
   "0.001",
   ")",
   ":",
   "F",
   "+=",
   "-",
   "F",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "floor",
   "F",
   "=",
   "F",
   "/",
   "F",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "return",
   "F"
  ]
 },
 {
  "idx": "maxmin-1015",
  "nl_tokens": [
   "Plots",
   "the",
   "power",
   "-",
   "law",
   "-",
   "predicted",
   "value",
   "on",
   "the",
   "Y",
   "-",
   "axis",
   "against",
   "the",
   "real",
   "values",
   "along",
   "the",
   "X",
   "-",
   "axis",
   ".",
   "Can",
   "be",
   "used",
   "as",
   "a",
   "diagnostic",
   "of",
   "the",
   "fit",
   "quality",
   "."
  ],
  "pl_tokens": [
   "def",
   "plotppf",
   "(",
   "self",
   ",",
   "x",
   "=",
   "None",
   ",",
   "xmin",
   "=",
   "None",
   ",",
   "alpha",
   "=",
   "None",
   ",",
   "dolog",
   "=",
   "True",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "not",
   "(",
   "xmin",
   ")",
   ":",
   "xmin",
   "=",
   "self",
   ".",
   "_xmin",
   "if",
   "not",
   "(",
   "alpha",
   ")",
   ":",
   "alpha",
   "=",
   "self",
   ".",
   "_alpha",
   "if",
   "not",
   "(",
   "x",
   ")",
   ":",
   "x",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "self",
   ".",
   "data",
   "[",
   "self",
   ".",
   "data",
   ">",
   "xmin",
   "]",
   ")",
   "else",
   ":",
   "x",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "x",
   "[",
   "x",
   ">",
   "xmin",
   "]",
   ")",
   "# N = M^(-alpha+1)",
   "# M = N^(1/(-alpha+1))",
   "m0",
   "=",
   "<mask>",
   "(",
   "x",
   ")",
   "N",
   "=",
   "(",
   "1.0",
   "+",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "x",
   ")",
   ")",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "xmodel",
   "=",
   "m0",
   "*",
   "N",
   "**",
   "(",
   "1",
   "/",
   "(",
   "1",
   "-",
   "alpha",
   ")",
   ")",
   "/",
   "max",
   "(",
   "N",
   ")",
   "**",
   "(",
   "1",
   "/",
   "(",
   "1",
   "-",
   "alpha",
   ")",
   ")",
   "if",
   "dolog",
   ":",
   "pylab",
   ".",
   "loglog",
   "(",
   "x",
   ",",
   "xmodel",
   ",",
   "'.'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "set_xlim",
   "(",
   "min",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   ")",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "set_ylim",
   "(",
   "min",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   ")",
   "else",
   ":",
   "pylab",
   ".",
   "plot",
   "(",
   "x",
   ",",
   "xmodel",
   ",",
   "'.'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "pylab",
   ".",
   "plot",
   "(",
   "[",
   "min",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   "]",
   ",",
   "[",
   "min",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   "]",
   ",",
   "'k--'",
   ")",
   "pylab",
   ".",
   "xlabel",
   "(",
   "\"Real Value\"",
   ")",
   "pylab",
   ".",
   "ylabel",
   "(",
   "\"Power-Law Model Value\"",
   ")"
  ]
 },
 {
  "idx": "maxmin-1016",
  "nl_tokens": [
   "Helper",
   "returning",
   "the",
   "largest",
   "integer",
   "exactly",
   "representable",
   "by",
   "dtype",
   "."
  ],
  "pl_tokens": [
   "def",
   "_largest_integer_by_dtype",
   "(",
   "dt",
   ")",
   ":",
   "if",
   "not",
   "_is_known_dtype",
   "(",
   "dt",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Unrecognized dtype: {}\"",
   ".",
   "format",
   "(",
   "dt",
   ".",
   "name",
   ")",
   ")",
   "if",
   "dt",
   ".",
   "is_floating",
   ":",
   "return",
   "int",
   "(",
   "2",
   "**",
   "(",
   "np",
   ".",
   "finfo",
   "(",
   "dt",
   ".",
   "as_numpy_dtype",
   ")",
   ".",
   "nmant",
   "+",
   "1",
   ")",
   ")",
   "if",
   "dt",
   ".",
   "is_integer",
   ":",
   "return",
   "np",
   ".",
   "iinfo",
   "(",
   "dt",
   ".",
   "as_numpy_dtype",
   ")",
   ".",
   "<mask>",
   "if",
   "dt",
   ".",
   "base_dtype",
   "==",
   "tf",
   ".",
   "bool",
   ":",
   "return",
   "int",
   "(",
   "1",
   ")",
   "# We actually can't land here but keep the case for completeness.",
   "raise",
   "TypeError",
   "(",
   "\"Unrecognized dtype: {}\"",
   ".",
   "format",
   "(",
   "dt",
   ".",
   "name",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1017",
  "nl_tokens": [
   "Final",
   "post",
   "-",
   "processing",
   ":",
   "throw",
   "out",
   "spurious",
   "leading",
   "/",
   "trailing",
   "beats"
  ],
  "pl_tokens": [
   "def",
   "__trim_beats",
   "(",
   "localscore",
   ",",
   "beats",
   ",",
   "trim",
   ")",
   ":",
   "smooth_boe",
   "=",
   "scipy",
   ".",
   "signal",
   ".",
   "convolve",
   "(",
   "localscore",
   "[",
   "beats",
   "]",
   ",",
   "scipy",
   ".",
   "signal",
   ".",
   "hann",
   "(",
   "5",
   ")",
   ",",
   "'same'",
   ")",
   "if",
   "trim",
   ":",
   "threshold",
   "=",
   "0.5",
   "*",
   "(",
   "(",
   "smooth_boe",
   "**",
   "2",
   ")",
   ".",
   "mean",
   "(",
   ")",
   "**",
   "0.5",
   ")",
   "else",
   ":",
   "threshold",
   "=",
   "0.0",
   "valid",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "smooth_boe",
   ">",
   "threshold",
   ")",
   "return",
   "beats",
   "[",
   "valid",
   ".",
   "<mask>",
   "(",
   ")",
   ":",
   "valid",
   ".",
   "max",
   "(",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-1018",
  "nl_tokens": [
   "Function",
   "for",
   "visualising",
   "the",
   "autorange",
   "mechanism",
   "."
  ],
  "pl_tokens": [
   "def",
   "autorange_plot",
   "(",
   "t",
   ",",
   "sig",
   ",",
   "gwin",
   "=",
   "7",
   ",",
   "swin",
   "=",
   "None",
   ",",
   "win",
   "=",
   "30",
   ",",
   "on_mult",
   "=",
   "(",
   "1.5",
   ",",
   "1.",
   ")",
   ",",
   "off_mult",
   "=",
   "(",
   "1.",
   ",",
   "1.5",
   ")",
   ",",
   "nbin",
   "=",
   "10",
   ",",
   "thresh",
   "=",
   "None",
   ")",
   ":",
   "if",
   "swin",
   "is",
   "None",
   ":",
   "swin",
   "=",
   "gwin",
   "//",
   "2",
   "sigs",
   "=",
   "fastsmooth",
   "(",
   "sig",
   ",",
   "swin",
   ")",
   "# perform autorange calculations",
   "# bins = 50",
   "bins",
   "=",
   "sig",
   ".",
   "size",
   "//",
   "nbin",
   "kde_x",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "sig",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "sig",
   ".",
   "max",
   "(",
   ")",
   ",",
   "bins",
   ")",
   "kde",
   "=",
   "gaussian_kde",
   "(",
   "sigs",
   ")",
   "yd",
   "=",
   "kde",
   ".",
   "pdf",
   "(",
   "kde_x",
   ")",
   "mins",
   "=",
   "findmins",
   "(",
   "kde_x",
   ",",
   "yd",
   ")",
   "# find minima in kde",
   "if",
   "thresh",
   "is",
   "not",
   "None",
   ":",
   "mins",
   "=",
   "[",
   "thresh",
   "]",
   "if",
   "len",
   "(",
   "mins",
   ")",
   ">",
   "0",
   ":",
   "bkg",
   "=",
   "sigs",
   "<",
   "(",
   "mins",
   "[",
   "0",
   "]",
   ")",
   "# set background as lowest distribution",
   "else",
   ":",
   "bkg",
   "=",
   "np",
   ".",
   "ones",
   "(",
   "sig",
   ".",
   "size",
   ",",
   "dtype",
   "=",
   "bool",
   ")",
   "# bkg[0] = True  # the first value must always be background",
   "# assign rough background and signal regions based on kde minima",
   "fbkg",
   "=",
   "bkg",
   "fsig",
   "=",
   "~",
   "bkg",
   "g",
   "=",
   "abs",
   "(",
   "fastgrad",
   "(",
   "sigs",
   ",",
   "gwin",
   ")",
   ")",
   "# calculate gradient of signal",
   "# 2. determine the approximate index of each transition",
   "zeros",
   "=",
   "bool_2_indices",
   "(",
   "fsig",
   ")",
   "if",
   "zeros",
   "is",
   "not",
   "None",
   ":",
   "zeros",
   "=",
   "zeros",
   ".",
   "flatten",
   "(",
   ")",
   "lohi",
   "=",
   "[",
   "]",
   "pgs",
   "=",
   "[",
   "]",
   "excl",
   "=",
   "[",
   "]",
   "tps",
   "=",
   "[",
   "]",
   "failed",
   "=",
   "[",
   "]",
   "for",
   "z",
   "in",
   "zeros",
   ":",
   "# for each approximate transition",
   "# isolate the data around the transition",
   "if",
   "z",
   "-",
   "win",
   "<",
   "0",
   ":",
   "lo",
   "=",
   "gwin",
   "//",
   "2",
   "hi",
   "=",
   "int",
   "(",
   "z",
   "+",
   "win",
   ")",
   "elif",
   "z",
   "+",
   "win",
   ">",
   "(",
   "len",
   "(",
   "sig",
   ")",
   "-",
   "gwin",
   "//",
   "2",
   ")",
   ":",
   "lo",
   "=",
   "int",
   "(",
   "z",
   "-",
   "win",
   ")",
   "hi",
   "=",
   "len",
   "(",
   "sig",
   ")",
   "-",
   "gwin",
   "//",
   "2",
   "else",
   ":",
   "lo",
   "=",
   "int",
   "(",
   "z",
   "-",
   "win",
   ")",
   "hi",
   "=",
   "int",
   "(",
   "z",
   "+",
   "win",
   ")",
   "xs",
   "=",
   "t",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "ys",
   "=",
   "g",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "lohi",
   ".",
   "append",
   "(",
   "[",
   "lo",
   ",",
   "hi",
   "]",
   ")",
   "# determine type of transition (on/off)",
   "mid",
   "=",
   "(",
   "hi",
   "+",
   "lo",
   ")",
   "//",
   "2",
   "tp",
   "=",
   "sigs",
   "[",
   "mid",
   "+",
   "3",
   "]",
   ">",
   "sigs",
   "[",
   "mid",
   "-",
   "3",
   "]",
   "# True if 'on' transition.",
   "tps",
   ".",
   "append",
   "(",
   "tp",
   ")",
   "c",
   "=",
   "t",
   "[",
   "z",
   "]",
   "# center of transition",
   "width",
   "=",
   "(",
   "t",
   "[",
   "1",
   "]",
   "-",
   "t",
   "[",
   "0",
   "]",
   ")",
   "*",
   "2",
   "# initial width guess",
   "try",
   ":",
   "pg",
   ",",
   "_",
   "=",
   "curve_fit",
   "(",
   "gauss",
   ",",
   "xs",
   ",",
   "ys",
   ",",
   "p0",
   "=",
   "(",
   "np",
   ".",
   "nanmax",
   "(",
   "ys",
   ")",
   ",",
   "c",
   ",",
   "width",
   ")",
   ",",
   "sigma",
   "=",
   "(",
   "xs",
   "-",
   "c",
   ")",
   "**",
   "2",
   "+",
   ".01",
   ")",
   "pgs",
   ".",
   "append",
   "(",
   "pg",
   ")",
   "fwhm",
   "=",
   "abs",
   "(",
   "2",
   "*",
   "pg",
   "[",
   "-",
   "1",
   "]",
   "*",
   "np",
   ".",
   "sqrt",
   "(",
   "2",
   "*",
   "np",
   ".",
   "log",
   "(",
   "2",
   ")",
   ")",
   ")",
   "# apply on_mult or off_mult, as appropriate.",
   "if",
   "tp",
   ":",
   "lim",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "-",
   "fwhm",
   ",",
   "fwhm",
   "]",
   ")",
   "*",
   "on_mult",
   "+",
   "pg",
   "[",
   "1",
   "]",
   "else",
   ":",
   "lim",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "-",
   "fwhm",
   ",",
   "fwhm",
   "]",
   ")",
   "*",
   "off_mult",
   "+",
   "pg",
   "[",
   "1",
   "]",
   "excl",
   ".",
   "append",
   "(",
   "lim",
   ")",
   "fbkg",
   "[",
   "(",
   "t",
   ">",
   "lim",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<",
   "lim",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "False",
   "fsig",
   "[",
   "(",
   "t",
   ">",
   "lim",
   "[",
   "0",
   "]",
   ")",
   "&",
   "(",
   "t",
   "<",
   "lim",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "False",
   "failed",
   ".",
   "append",
   "(",
   "False",
   ")",
   "except",
   "RuntimeError",
   ":",
   "failed",
   ".",
   "append",
   "(",
   "True",
   ")",
   "lohi",
   ".",
   "append",
   "(",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   ")",
   "pgs",
   ".",
   "append",
   "(",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   ")",
   "excl",
   ".",
   "append",
   "(",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   ")",
   "tps",
   ".",
   "append",
   "(",
   "tp",
   ")",
   "pass",
   "else",
   ":",
   "zeros",
   "=",
   "[",
   "]",
   "# make plot",
   "nrows",
   "=",
   "2",
   "+",
   "len",
   "(",
   "zeros",
   ")",
   "//",
   "2",
   "+",
   "len",
   "(",
   "zeros",
   ")",
   "%",
   "2",
   "fig",
   ",",
   "axs",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "nrows",
   ",",
   "2",
   ",",
   "figsize",
   "=",
   "(",
   "6",
   ",",
   "4",
   "+",
   "1.5",
   "*",
   "nrows",
   ")",
   ")",
   "# Trace",
   "ax1",
   ",",
   "ax2",
   ",",
   "ax3",
   ",",
   "ax4",
   "=",
   "axs",
   ".",
   "flat",
   "[",
   ":",
   "4",
   "]",
   "ax4",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "# widen ax1 & 3",
   "for",
   "ax",
   "in",
   "[",
   "ax1",
   ",",
   "ax3",
   "]",
   ":",
   "p",
   "=",
   "ax",
   ".",
   "axes",
   ".",
   "get_position",
   "(",
   ")",
   "p2",
   "=",
   "[",
   "p",
   ".",
   "x0",
   ",",
   "p",
   ".",
   "y0",
   ",",
   "p",
   ".",
   "width",
   "*",
   "1.75",
   ",",
   "p",
   ".",
   "height",
   "]",
   "ax",
   ".",
   "axes",
   ".",
   "set_position",
   "(",
   "p2",
   ")",
   "# move ax3 up",
   "p",
   "=",
   "ax3",
   ".",
   "axes",
   ".",
   "get_position",
   "(",
   ")",
   "p2",
   "=",
   "[",
   "p",
   ".",
   "x0",
   ",",
   "p",
   ".",
   "y0",
   "+",
   "0.15",
   "*",
   "p",
   ".",
   "height",
   ",",
   "p",
   ".",
   "width",
   ",",
   "p",
   ".",
   "height",
   "]",
   "ax3",
   ".",
   "axes",
   ".",
   "set_position",
   "(",
   "p2",
   ")",
   "# truncate ax2",
   "p",
   "=",
   "ax2",
   ".",
   "axes",
   ".",
   "get_position",
   "(",
   ")",
   "p2",
   "=",
   "[",
   "p",
   ".",
   "x0",
   "+",
   "p",
   ".",
   "width",
   "*",
   "0.6",
   ",",
   "p",
   ".",
   "y0",
   ",",
   "p",
   ".",
   "width",
   "*",
   "0.4",
   ",",
   "p",
   ".",
   "height",
   "]",
   "ax2",
   ".",
   "axes",
   ".",
   "set_position",
   "(",
   "p2",
   ")",
   "# plot traces and gradient",
   "ax1",
   ".",
   "plot",
   "(",
   "t",
   ",",
   "sig",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "lw",
   "=",
   "1",
   ")",
   "ax1",
   ".",
   "set_xticklabels",
   "(",
   "[",
   "]",
   ")",
   "ax1",
   ".",
   "set_ylabel",
   "(",
   "'Signal'",
   ")",
   "ax3",
   ".",
   "plot",
   "(",
   "t",
   ",",
   "g",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "lw",
   "=",
   "1",
   ")",
   "ax3",
   ".",
   "set_xlabel",
   "(",
   "'Time (s)'",
   ")",
   "ax3",
   ".",
   "set_ylabel",
   "(",
   "'Gradient'",
   ")",
   "# plot kde",
   "ax2",
   ".",
   "fill_betweenx",
   "(",
   "kde_x",
   ",",
   "yd",
   ",",
   "color",
   "=",
   "(",
   "0",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0.2",
   ")",
   ")",
   "ax2",
   ".",
   "plot",
   "(",
   "yd",
   ",",
   "kde_x",
   ",",
   "color",
   "=",
   "'k'",
   ")",
   "ax2",
   ".",
   "set_ylim",
   "(",
   "ax1",
   ".",
   "get_ylim",
   "(",
   ")",
   ")",
   "ax2",
   ".",
   "set_yticklabels",
   "(",
   "[",
   "]",
   ")",
   "ax2",
   ".",
   "set_xlabel",
   "(",
   "'Data\\nDensity'",
   ")",
   "# limit",
   "for",
   "ax",
   "in",
   "[",
   "ax1",
   ",",
   "ax2",
   "]",
   ":",
   "ax",
   ".",
   "axhline",
   "(",
   "mins",
   "[",
   "0",
   "]",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "ls",
   "=",
   "'dashed'",
   ",",
   "alpha",
   "=",
   "0.4",
   ")",
   "if",
   "len",
   "(",
   "zeros",
   ")",
   ">",
   "0",
   ":",
   "# zeros",
   "for",
   "z",
   "in",
   "zeros",
   ":",
   "ax1",
   ".",
   "axvline",
   "(",
   "t",
   "[",
   "z",
   "]",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "ax3",
   ".",
   "axvline",
   "(",
   "t",
   "[",
   "z",
   "]",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "# plot individual transitions",
   "n",
   "=",
   "1",
   "for",
   "(",
   "lo",
   ",",
   "hi",
   ")",
   ",",
   "lim",
   ",",
   "tp",
   ",",
   "pg",
   ",",
   "fail",
   ",",
   "ax",
   "in",
   "zip",
   "(",
   "lohi",
   ",",
   "excl",
   ",",
   "tps",
   ",",
   "pgs",
   ",",
   "failed",
   ",",
   "axs",
   ".",
   "flat",
   "[",
   "4",
   ":",
   "]",
   ")",
   ":",
   "# plot region on gradient axis",
   "ax3",
   ".",
   "axvspan",
   "(",
   "t",
   "[",
   "lo",
   "]",
   ",",
   "t",
   "[",
   "hi",
   "]",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "alpha",
   "=",
   "0.1",
   ",",
   "zorder",
   "=",
   "-",
   "2",
   ")",
   "# plot individual transitions",
   "x",
   "=",
   "t",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "y",
   "=",
   "g",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "ys",
   "=",
   "sig",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "ax",
   ".",
   "scatter",
   "(",
   "x",
   ",",
   "y",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "marker",
   "=",
   "'x'",
   ",",
   "zorder",
   "=",
   "-",
   "1",
   ",",
   "s",
   "=",
   "10",
   ")",
   "ax",
   ".",
   "set_yticklabels",
   "(",
   "[",
   "]",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "rangecalc",
   "(",
   "y",
   ")",
   ")",
   "tax",
   "=",
   "ax",
   ".",
   "twinx",
   "(",
   ")",
   "tax",
   ".",
   "plot",
   "(",
   "x",
   ",",
   "ys",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "alpha",
   "=",
   "0.3",
   ",",
   "zorder",
   "=",
   "-",
   "5",
   ")",
   "tax",
   ".",
   "set_yticklabels",
   "(",
   "[",
   "]",
   ")",
   "tax",
   ".",
   "set_ylim",
   "(",
   "rangecalc",
   "(",
   "ys",
   ")",
   ")",
   "# plot fitted gaussian",
   "xn",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "x",
   ".",
   "min",
   "(",
   ")",
   ",",
   "x",
   ".",
   "max",
   "(",
   ")",
   ",",
   "100",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "xn",
   ",",
   "gauss",
   "(",
   "xn",
   ",",
   "*",
   "pg",
   ")",
   ",",
   "color",
   "=",
   "'r'",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "# plot center and excluded region",
   "ax",
   ".",
   "axvline",
   "(",
   "pg",
   "[",
   "1",
   "]",
   ",",
   "color",
   "=",
   "'b'",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "ax",
   ".",
   "axvspan",
   "(",
   "*",
   "lim",
   ",",
   "color",
   "=",
   "'b'",
   ",",
   "alpha",
   "=",
   "0.1",
   ",",
   "zorder",
   "=",
   "-",
   "2",
   ")",
   "ax1",
   ".",
   "axvspan",
   "(",
   "*",
   "lim",
   ",",
   "color",
   "=",
   "'b'",
   ",",
   "alpha",
   "=",
   "0.1",
   ",",
   "zorder",
   "=",
   "-",
   "2",
   ")",
   "if",
   "tp",
   ":",
   "ax",
   ".",
   "text",
   "(",
   ".05",
   ",",
   ".95",
   ",",
   "'{} (on)'",
   ".",
   "format",
   "(",
   "n",
   ")",
   ",",
   "ha",
   "=",
   "'left'",
   ",",
   "va",
   "=",
   "'top'",
   ",",
   "transform",
   "=",
   "ax",
   ".",
   "transAxes",
   ")",
   "else",
   ":",
   "ax",
   ".",
   "text",
   "(",
   ".95",
   ",",
   ".95",
   ",",
   "'{} (off)'",
   ".",
   "format",
   "(",
   "n",
   ")",
   ",",
   "ha",
   "=",
   "'right'",
   ",",
   "va",
   "=",
   "'top'",
   ",",
   "transform",
   "=",
   "ax",
   ".",
   "transAxes",
   ")",
   "if",
   "ax",
   ".",
   "is_last_row",
   "(",
   ")",
   ":",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "'Time (s)'",
   ")",
   "if",
   "ax",
   ".",
   "is_first_col",
   "(",
   ")",
   ":",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "'Gradient (x)'",
   ")",
   "if",
   "ax",
   ".",
   "is_last_col",
   "(",
   ")",
   ":",
   "tax",
   ".",
   "set_ylabel",
   "(",
   "'Signal (line)'",
   ")",
   "if",
   "fail",
   ":",
   "ax",
   ".",
   "axes",
   ".",
   "set_facecolor",
   "(",
   "(",
   "1",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0.2",
   ")",
   ")",
   "ax",
   ".",
   "text",
   "(",
   ".5",
   ",",
   ".5",
   ",",
   "'FAIL'",
   ",",
   "ha",
   "=",
   "'center'",
   ",",
   "va",
   "=",
   "'center'",
   ",",
   "fontsize",
   "=",
   "16",
   ",",
   "color",
   "=",
   "(",
   "1",
   ",",
   "0",
   ",",
   "0",
   ",",
   "0.5",
   ")",
   ",",
   "transform",
   "=",
   "ax",
   ".",
   "transAxes",
   ")",
   "n",
   "+=",
   "1",
   "# should never be, but just in case...",
   "if",
   "len",
   "(",
   "zeros",
   ")",
   "%",
   "2",
   "==",
   "1",
   ":",
   "axs",
   ".",
   "flat",
   "[",
   "-",
   "1",
   "]",
   ".",
   "set_visible",
   "=",
   "False",
   "return",
   "fig",
   ",",
   "axs"
  ]
 },
 {
  "idx": "maxmin-1019",
  "nl_tokens": [
   "Draw",
   "a",
   "sequential",
   "sample",
   "of",
   "class",
   "labels",
   "from",
   "this",
   "network",
   "."
  ],
  "pl_tokens": [
   "def",
   "predict_sequence",
   "(",
   "self",
   ",",
   "labels",
   ",",
   "steps",
   ",",
   "streams",
   "=",
   "1",
   ",",
   "rng",
   "=",
   "None",
   ")",
   ":",
   "if",
   "rng",
   "is",
   "None",
   "or",
   "isinstance",
   "(",
   "rng",
   ",",
   "int",
   ")",
   ":",
   "rng",
   "=",
   "np",
   ".",
   "random",
   ".",
   "RandomState",
   "(",
   "rng",
   ")",
   "offset",
   "=",
   "len",
   "(",
   "labels",
   ")",
   "batch",
   "=",
   "<mask>",
   "(",
   "2",
   ",",
   "streams",
   ")",
   "inputs",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "batch",
   ",",
   "offset",
   "+",
   "steps",
   ",",
   "self",
   ".",
   "layers",
   "[",
   "0",
   "]",
   ".",
   "output_size",
   ")",
   ",",
   "'f'",
   ")",
   "inputs",
   "[",
   ":",
   ",",
   "np",
   ".",
   "arange",
   "(",
   "offset",
   ")",
   ",",
   "labels",
   "]",
   "=",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "offset",
   ",",
   "offset",
   "+",
   "steps",
   ")",
   ":",
   "chars",
   "=",
   "[",
   "]",
   "for",
   "pdf",
   "in",
   "self",
   ".",
   "predict_proba",
   "(",
   "inputs",
   "[",
   ":",
   "i",
   "]",
   ")",
   "[",
   ":",
   ",",
   "-",
   "1",
   "]",
   ":",
   "try",
   ":",
   "c",
   "=",
   "rng",
   ".",
   "multinomial",
   "(",
   "1",
   ",",
   "pdf",
   ")",
   ".",
   "argmax",
   "(",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "except",
   "ValueError",
   ":",
   "# sometimes the pdf triggers a normalization error. just",
   "# choose greedily in this case.",
   "c",
   "=",
   "pdf",
   ".",
   "argmax",
   "(",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "chars",
   ".",
   "append",
   "(",
   "int",
   "(",
   "c",
   ")",
   ")",
   "inputs",
   "[",
   "np",
   ".",
   "arange",
   "(",
   "batch",
   ")",
   ",",
   "i",
   ",",
   "chars",
   "]",
   "=",
   "1",
   "yield",
   "chars",
   "[",
   "0",
   "]",
   "if",
   "streams",
   "==",
   "1",
   "else",
   "chars"
  ]
 },
 {
  "idx": "maxmin-1020",
  "nl_tokens": [
   "Calculates",
   "the",
   "margin",
   "to",
   "the",
   "left",
   "of",
   "the",
   "plot",
   "area",
   "setting",
   "border_left",
   "."
  ],
  "pl_tokens": [
   "def",
   "calculate_left_margin",
   "(",
   "self",
   ")",
   ":",
   "bl",
   "=",
   "7",
   "# Check for Y labels",
   "if",
   "self",
   ".",
   "rotate_y_labels",
   ":",
   "max_y_label_height_px",
   "=",
   "self",
   ".",
   "y_label_font_size",
   "else",
   ":",
   "label_lengths",
   "=",
   "map",
   "(",
   "len",
   ",",
   "self",
   ".",
   "get_y_labels",
   "(",
   ")",
   ")",
   "max_y_label_len",
   "=",
   "<mask>",
   "(",
   "label_lengths",
   ")",
   "max_y_label_height_px",
   "=",
   "0.6",
   "*",
   "max_y_label_len",
   "*",
   "self",
   ".",
   "y_label_font_size",
   "if",
   "self",
   ".",
   "show_y_labels",
   ":",
   "bl",
   "+=",
   "max_y_label_height_px",
   "if",
   "self",
   ".",
   "stagger_y_labels",
   ":",
   "bl",
   "+=",
   "max_y_label_height_px",
   "+",
   "10",
   "if",
   "self",
   ".",
   "show_y_title",
   ":",
   "bl",
   "+=",
   "self",
   ".",
   "y_title_font_size",
   "+",
   "5",
   "self",
   ".",
   "border_left",
   "=",
   "bl"
  ]
 },
 {
  "idx": "maxmin-1021",
  "nl_tokens": [
   "generate",
   "strings",
   "identified",
   "as",
   "sentences"
  ],
  "pl_tokens": [
   "def",
   "_sentences",
   "(",
   "self",
   ",",
   "clean_visible",
   ")",
   ":",
   "previous_end",
   "=",
   "0",
   "clean_visible",
   "=",
   "clean_visible",
   ".",
   "decode",
   "(",
   "'utf8'",
   ")",
   "for",
   "start",
   ",",
   "end",
   "in",
   "self",
   ".",
   "sentence_tokenizer",
   ".",
   "span_tokenize",
   "(",
   "clean_visible",
   ")",
   ":",
   "# no need to check start, because the first byte of text",
   "# is always first byte of first sentence, and we will",
   "# have already made the previous sentence longer on the",
   "# end if there was an overlap.",
   "if",
   "start",
   "<",
   "previous_end",
   ":",
   "start",
   "=",
   "previous_end",
   "if",
   "start",
   ">",
   "end",
   ":",
   "# skip this sentence... because it was eaten by",
   "# an earlier sentence with a label",
   "continue",
   "try",
   ":",
   "label",
   "=",
   "self",
   ".",
   "label_index",
   ".",
   "find_le",
   "(",
   "end",
   ")",
   "except",
   "ValueError",
   ":",
   "label",
   "=",
   "None",
   "if",
   "label",
   ":",
   "## avoid splitting a label",
   "off",
   "=",
   "label",
   ".",
   "offsets",
   "[",
   "OffsetType",
   ".",
   "CHARS",
   "]",
   "end",
   "=",
   "<mask>",
   "(",
   "off",
   ".",
   "first",
   "+",
   "off",
   ".",
   "length",
   ",",
   "end",
   ")",
   "previous_end",
   "=",
   "end",
   "sent_str",
   "=",
   "clean_visible",
   "[",
   "start",
   ":",
   "end",
   "]",
   "yield",
   "start",
   ",",
   "end",
   ",",
   "sent_str"
  ]
 },
 {
  "idx": "maxmin-1022",
  "nl_tokens": [
   "Keep",
   "the",
   "row",
   "of",
   "the",
   "data",
   "corresponding",
   "to",
   "the",
   "maximal",
   "value",
   "in",
   "a",
   "column"
  ],
  "pl_tokens": [
   "def",
   "argmax",
   "(",
   "df",
   ",",
   "column",
   ":",
   "str",
   ",",
   "groups",
   ":",
   "Union",
   "[",
   "str",
   ",",
   "List",
   "[",
   "str",
   "]",
   "]",
   "=",
   "None",
   ")",
   ":",
   "if",
   "groups",
   "is",
   "None",
   ":",
   "df",
   "=",
   "df",
   "[",
   "df",
   "[",
   "column",
   "]",
   "==",
   "df",
   "[",
   "column",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "]",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ")",
   "else",
   ":",
   "group_max",
   "=",
   "df",
   ".",
   "groupby",
   "(",
   "groups",
   ")",
   "[",
   "column",
   "]",
   ".",
   "transform",
   "(",
   "'max'",
   ")",
   "df",
   "=",
   "(",
   "df",
   ".",
   "loc",
   "[",
   "df",
   "[",
   "column",
   "]",
   "==",
   "group_max",
   ",",
   ":",
   "]",
   ".",
   "drop_duplicates",
   "(",
   ")",
   ".",
   "reset_index",
   "(",
   "drop",
   "=",
   "True",
   ")",
   ")",
   "return",
   "df"
  ]
 },
 {
  "idx": "maxmin-1023",
  "nl_tokens": [
   "Finding",
   "all",
   "tasks",
   "that",
   "have",
   "SLAs",
   "defined",
   "and",
   "sending",
   "alert",
   "emails",
   "where",
   "needed",
   ".",
   "New",
   "SLA",
   "misses",
   "are",
   "also",
   "recorded",
   "in",
   "the",
   "database",
   "."
  ],
  "pl_tokens": [
   "def",
   "manage_slas",
   "(",
   "self",
   ",",
   "dag",
   ",",
   "session",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "any",
   "(",
   "[",
   "isinstance",
   "(",
   "ti",
   ".",
   "sla",
   ",",
   "timedelta",
   ")",
   "for",
   "ti",
   "in",
   "dag",
   ".",
   "tasks",
   "]",
   ")",
   ":",
   "self",
   ".",
   "log",
   ".",
   "info",
   "(",
   "\"Skipping SLA check for %s because no tasks in DAG have SLAs\"",
   ",",
   "dag",
   ")",
   "return",
   "TI",
   "=",
   "models",
   ".",
   "TaskInstance",
   "sq",
   "=",
   "(",
   "session",
   ".",
   "query",
   "(",
   "TI",
   ".",
   "task_id",
   ",",
   "func",
   ".",
   "<mask>",
   "(",
   "TI",
   ".",
   "execution_date",
   ")",
   ".",
   "label",
   "(",
   "'max_ti'",
   ")",
   ")",
   ".",
   "with_hint",
   "(",
   "TI",
   ",",
   "'USE INDEX (PRIMARY)'",
   ",",
   "dialect_name",
   "=",
   "'mysql'",
   ")",
   ".",
   "filter",
   "(",
   "TI",
   ".",
   "dag_id",
   "==",
   "dag",
   ".",
   "dag_id",
   ")",
   ".",
   "filter",
   "(",
   "or_",
   "(",
   "TI",
   ".",
   "state",
   "==",
   "State",
   ".",
   "SUCCESS",
   ",",
   "TI",
   ".",
   "state",
   "==",
   "State",
   ".",
   "SKIPPED",
   ")",
   ")",
   ".",
   "filter",
   "(",
   "TI",
   ".",
   "task_id",
   ".",
   "in_",
   "(",
   "dag",
   ".",
   "task_ids",
   ")",
   ")",
   ".",
   "group_by",
   "(",
   "TI",
   ".",
   "task_id",
   ")",
   ".",
   "subquery",
   "(",
   "'sq'",
   ")",
   ")",
   "max_tis",
   "=",
   "session",
   ".",
   "query",
   "(",
   "TI",
   ")",
   ".",
   "filter",
   "(",
   "TI",
   ".",
   "dag_id",
   "==",
   "dag",
   ".",
   "dag_id",
   ",",
   "TI",
   ".",
   "task_id",
   "==",
   "sq",
   ".",
   "c",
   ".",
   "task_id",
   ",",
   "TI",
   ".",
   "execution_date",
   "==",
   "sq",
   ".",
   "c",
   ".",
   "max_ti",
   ",",
   ")",
   ".",
   "all",
   "(",
   ")",
   "ts",
   "=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "for",
   "ti",
   "in",
   "max_tis",
   ":",
   "task",
   "=",
   "dag",
   ".",
   "get_task",
   "(",
   "ti",
   ".",
   "task_id",
   ")",
   "dttm",
   "=",
   "ti",
   ".",
   "execution_date",
   "if",
   "isinstance",
   "(",
   "task",
   ".",
   "sla",
   ",",
   "timedelta",
   ")",
   ":",
   "dttm",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "dttm",
   ")",
   "while",
   "dttm",
   "<",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   ":",
   "following_schedule",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "dttm",
   ")",
   "if",
   "following_schedule",
   "+",
   "task",
   ".",
   "sla",
   "<",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   ":",
   "session",
   ".",
   "merge",
   "(",
   "SlaMiss",
   "(",
   "task_id",
   "=",
   "ti",
   ".",
   "task_id",
   ",",
   "dag_id",
   "=",
   "ti",
   ".",
   "dag_id",
   ",",
   "execution_date",
   "=",
   "dttm",
   ",",
   "timestamp",
   "=",
   "ts",
   ")",
   ")",
   "dttm",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "dttm",
   ")",
   "session",
   ".",
   "commit",
   "(",
   ")",
   "slas",
   "=",
   "(",
   "session",
   ".",
   "query",
   "(",
   "SlaMiss",
   ")",
   ".",
   "filter",
   "(",
   "SlaMiss",
   ".",
   "notification_sent",
   "==",
   "False",
   ",",
   "SlaMiss",
   ".",
   "dag_id",
   "==",
   "dag",
   ".",
   "dag_id",
   ")",
   "# noqa: E712",
   ".",
   "all",
   "(",
   ")",
   ")",
   "if",
   "slas",
   ":",
   "sla_dates",
   "=",
   "[",
   "sla",
   ".",
   "execution_date",
   "for",
   "sla",
   "in",
   "slas",
   "]",
   "qry",
   "=",
   "(",
   "session",
   ".",
   "query",
   "(",
   "TI",
   ")",
   ".",
   "filter",
   "(",
   "TI",
   ".",
   "state",
   "!=",
   "State",
   ".",
   "SUCCESS",
   ",",
   "TI",
   ".",
   "execution_date",
   ".",
   "in_",
   "(",
   "sla_dates",
   ")",
   ",",
   "TI",
   ".",
   "dag_id",
   "==",
   "dag",
   ".",
   "dag_id",
   ")",
   ".",
   "all",
   "(",
   ")",
   ")",
   "blocking_tis",
   "=",
   "[",
   "]",
   "for",
   "ti",
   "in",
   "qry",
   ":",
   "if",
   "ti",
   ".",
   "task_id",
   "in",
   "dag",
   ".",
   "task_ids",
   ":",
   "ti",
   ".",
   "task",
   "=",
   "dag",
   ".",
   "get_task",
   "(",
   "ti",
   ".",
   "task_id",
   ")",
   "blocking_tis",
   ".",
   "append",
   "(",
   "ti",
   ")",
   "else",
   ":",
   "session",
   ".",
   "delete",
   "(",
   "ti",
   ")",
   "session",
   ".",
   "commit",
   "(",
   ")",
   "task_list",
   "=",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "[",
   "sla",
   ".",
   "task_id",
   "+",
   "' on '",
   "+",
   "sla",
   ".",
   "execution_date",
   ".",
   "isoformat",
   "(",
   ")",
   "for",
   "sla",
   "in",
   "slas",
   "]",
   ")",
   "blocking_task_list",
   "=",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "[",
   "ti",
   ".",
   "task_id",
   "+",
   "' on '",
   "+",
   "ti",
   ".",
   "execution_date",
   ".",
   "isoformat",
   "(",
   ")",
   "for",
   "ti",
   "in",
   "blocking_tis",
   "]",
   ")",
   "# Track whether email or any alert notification sent",
   "# We consider email or the alert callback as notifications",
   "email_sent",
   "=",
   "False",
   "notification_sent",
   "=",
   "False",
   "if",
   "dag",
   ".",
   "sla_miss_callback",
   ":",
   "# Execute the alert callback",
   "self",
   ".",
   "log",
   ".",
   "info",
   "(",
   "' --------------> ABOUT TO CALL SLA MISS CALL BACK '",
   ")",
   "try",
   ":",
   "dag",
   ".",
   "sla_miss_callback",
   "(",
   "dag",
   ",",
   "task_list",
   ",",
   "blocking_task_list",
   ",",
   "slas",
   ",",
   "blocking_tis",
   ")",
   "notification_sent",
   "=",
   "True",
   "except",
   "Exception",
   ":",
   "self",
   ".",
   "log",
   ".",
   "exception",
   "(",
   "\"Could not call sla_miss_callback for DAG %s\"",
   ",",
   "dag",
   ".",
   "dag_id",
   ")",
   "email_content",
   "=",
   "\"\"\"\\\n            Here's a list of tasks that missed their SLAs:\n            <pre><code>{task_list}\\n<code></pre>\n            Blocking tasks:\n            <pre><code>{blocking_task_list}\\n{bug}<code></pre>\n            \"\"\"",
   ".",
   "format",
   "(",
   "task_list",
   "=",
   "task_list",
   ",",
   "blocking_task_list",
   "=",
   "blocking_task_list",
   ",",
   "bug",
   "=",
   "asciiart",
   ".",
   "bug",
   ")",
   "emails",
   "=",
   "set",
   "(",
   ")",
   "for",
   "task",
   "in",
   "dag",
   ".",
   "tasks",
   ":",
   "if",
   "task",
   ".",
   "email",
   ":",
   "if",
   "isinstance",
   "(",
   "task",
   ".",
   "email",
   ",",
   "basestring",
   ")",
   ":",
   "emails",
   "|=",
   "set",
   "(",
   "get_email_address_list",
   "(",
   "task",
   ".",
   "email",
   ")",
   ")",
   "elif",
   "isinstance",
   "(",
   "task",
   ".",
   "email",
   ",",
   "(",
   "list",
   ",",
   "tuple",
   ")",
   ")",
   ":",
   "emails",
   "|=",
   "set",
   "(",
   "task",
   ".",
   "email",
   ")",
   "if",
   "emails",
   ":",
   "try",
   ":",
   "send_email",
   "(",
   "emails",
   ",",
   "\"[airflow] SLA miss on DAG=\"",
   "+",
   "dag",
   ".",
   "dag_id",
   ",",
   "email_content",
   ")",
   "email_sent",
   "=",
   "True",
   "notification_sent",
   "=",
   "True",
   "except",
   "Exception",
   ":",
   "self",
   ".",
   "log",
   ".",
   "exception",
   "(",
   "\"Could not send SLA Miss email notification for\"",
   "\" DAG %s\"",
   ",",
   "dag",
   ".",
   "dag_id",
   ")",
   "# If we sent any notification, update the sla_miss table",
   "if",
   "notification_sent",
   ":",
   "for",
   "sla",
   "in",
   "slas",
   ":",
   "if",
   "email_sent",
   ":",
   "sla",
   ".",
   "email_sent",
   "=",
   "True",
   "sla",
   ".",
   "notification_sent",
   "=",
   "True",
   "session",
   ".",
   "merge",
   "(",
   "sla",
   ")",
   "session",
   ".",
   "commit",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1024",
  "nl_tokens": [
   "Components",
   "are",
   "positioned",
   "relative",
   "to",
   "their",
   "container",
   ".",
   "Use",
   "this",
   "method",
   "to",
   "position",
   "the",
   "bottom",
   "-",
   "left",
   "corner",
   "of",
   "the",
   "components",
   "at",
   "the",
   "origin",
   "."
  ],
  "pl_tokens": [
   "def",
   "move_to_origin",
   "(",
   "components",
   ")",
   ":",
   "for",
   "component",
   "in",
   "components",
   ":",
   "if",
   "isinstance",
   "(",
   "component",
   ",",
   "Ellipse",
   ")",
   ":",
   "component",
   ".",
   "x_origin",
   "=",
   "component",
   ".",
   "e_width",
   "component",
   ".",
   "y_origin",
   "=",
   "component",
   ".",
   "e_height",
   "elif",
   "isinstance",
   "(",
   "component",
   ",",
   "(",
   "Polygon",
   ",",
   "BSpline",
   ")",
   ")",
   ":",
   "min_x",
   "=",
   "<mask>",
   "(",
   "[",
   "t",
   "[",
   "0",
   "]",
   "for",
   "t",
   "in",
   "component",
   ".",
   "points",
   "]",
   ")",
   "min_y",
   "=",
   "min",
   "(",
   "[",
   "t",
   "[",
   "1",
   "]",
   "for",
   "t",
   "in",
   "component",
   ".",
   "points",
   "]",
   ")",
   "component",
   ".",
   "points",
   "=",
   "[",
   "(",
   "p",
   "[",
   "0",
   "]",
   "-",
   "min_x",
   ",",
   "p",
   "[",
   "1",
   "]",
   "-",
   "min_y",
   ")",
   "for",
   "p",
   "in",
   "component",
   ".",
   "points",
   "]",
   "elif",
   "isinstance",
   "(",
   "component",
   ",",
   "Text",
   ")",
   ":",
   "font",
   "=",
   "str_to_font",
   "(",
   "str",
   "(",
   "component",
   ".",
   "pen",
   ".",
   "font",
   ")",
   ")",
   "component",
   ".",
   "text_x",
   "=",
   "0",
   "#-( component.text_w / 2 )",
   "component",
   ".",
   "text_y",
   "=",
   "0"
  ]
 },
 {
  "idx": "maxmin-1025",
  "nl_tokens": [
   "save",
   "es",
   "and",
   "stats"
  ],
  "pl_tokens": [
   "def",
   "_save",
   "(",
   "self",
   ",",
   "outdir",
   ")",
   ":",
   "# save raw ES to one csv file",
   "samplesRawES",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "self",
   ".",
   "resultsOnSamples",
   ")",
   "samplesRawES",
   ".",
   "index",
   ".",
   "name",
   "=",
   "'Term|ES'",
   "# normalize enrichment scores by using the entire data set, as indicated",
   "# by Barbie et al., 2009, online methods, pg. 2",
   "samplesNES",
   "=",
   "samplesRawES",
   "/",
   "(",
   "samplesRawES",
   ".",
   "values",
   ".",
   "<mask>",
   "(",
   ")",
   "-",
   "samplesRawES",
   ".",
   "values",
   ".",
   "min",
   "(",
   ")",
   ")",
   "samplesNES",
   "=",
   "samplesNES",
   ".",
   "copy",
   "(",
   ")",
   "samplesNES",
   ".",
   "index",
   ".",
   "rename",
   "(",
   "'Term|NES'",
   ",",
   "inplace",
   "=",
   "True",
   ")",
   "self",
   ".",
   "res2d",
   "=",
   "samplesNES",
   "self",
   ".",
   "_logger",
   ".",
   "info",
   "(",
   "\"Congratulations. GSEApy runs successfully................\\n\"",
   ")",
   "if",
   "self",
   ".",
   "_outdir",
   "is",
   "None",
   ":",
   "return",
   "# write es",
   "outESfile",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "outdir",
   ",",
   "\"gseapy.samples.raw.es.txt\"",
   ")",
   "with",
   "open",
   "(",
   "outESfile",
   ",",
   "'a'",
   ")",
   "as",
   "f",
   ":",
   "if",
   "self",
   ".",
   "scale",
   ":",
   "f",
   ".",
   "write",
   "(",
   "'# scale the enrichment scores by number of genes in the gene sets\\n'",
   ")",
   "f",
   ".",
   "write",
   "(",
   "'# this normalization has not effects on the final NES, '",
   "+",
   "'as indicated by Barbie et al., 2009, online methods, pg. 2\\n'",
   ")",
   "else",
   ":",
   "f",
   ".",
   "write",
   "(",
   "'# raw enrichment scores of all data\\n'",
   ")",
   "f",
   ".",
   "write",
   "(",
   "'# no scale es by numbers of genes in the gene sets\\n'",
   ")",
   "samplesRawES",
   ".",
   "to_csv",
   "(",
   "f",
   ",",
   "sep",
   "=",
   "'\\t'",
   ")",
   "outNESfile",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "outdir",
   ",",
   "\"gseapy.samples.normalized.es.txt\"",
   ")",
   "with",
   "open",
   "(",
   "outNESfile",
   ",",
   "'a'",
   ")",
   "as",
   "f",
   ":",
   "f",
   ".",
   "write",
   "(",
   "'# normalize enrichment scores by using the entire data set\\n'",
   ")",
   "f",
   ".",
   "write",
   "(",
   "'# as indicated by Barbie et al., 2009, online methods, pg. 2\\n'",
   ")",
   "samplesNES",
   ".",
   "to_csv",
   "(",
   "f",
   ",",
   "sep",
   "=",
   "'\\t'",
   ")",
   "return"
  ]
 },
 {
  "idx": "maxmin-1026",
  "nl_tokens": [
   "Drop",
   "a",
   "single",
   "column",
   "or",
   "row",
   "or",
   "a",
   "set",
   "of",
   "columns",
   "or",
   "rows",
   "from",
   "a",
   "H2OFrame",
   "."
  ],
  "pl_tokens": [
   "def",
   "drop",
   "(",
   "self",
   ",",
   "index",
   ",",
   "axis",
   "=",
   "1",
   ")",
   ":",
   "if",
   "axis",
   "==",
   "1",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "index",
   ",",
   "list",
   ")",
   ":",
   "#If input is a string, i.e., \"C1\":",
   "if",
   "is_type",
   "(",
   "index",
   ",",
   "str",
   ")",
   ":",
   "#Check if index is an actual column(s) in the frame",
   "if",
   "index",
   "not",
   "in",
   "self",
   ".",
   "names",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Column(s) selected to drop are not in original frame: %r\"",
   "%",
   "index",
   ")",
   "index",
   "=",
   "self",
   ".",
   "names",
   ".",
   "index",
   "(",
   "index",
   ")",
   "#If input is an int indicating a column index, i.e., 3:",
   "elif",
   "is_type",
   "(",
   "index",
   ",",
   "int",
   ")",
   ":",
   "#Check if index is an actual column index in the frame",
   "if",
   "index",
   ">",
   "self",
   ".",
   "ncol",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Column index selected to drop is not part of the frame: %r\"",
   "%",
   "index",
   ")",
   "if",
   "index",
   "<",
   "0",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Column index selected to drop is not positive: %r\"",
   "%",
   "index",
   ")",
   "fr",
   "=",
   "H2OFrame",
   ".",
   "_expr",
   "(",
   "expr",
   "=",
   "ExprNode",
   "(",
   "\"cols\"",
   ",",
   "self",
   ",",
   "-",
   "(",
   "index",
   "+",
   "1",
   ")",
   ")",
   ",",
   "cache",
   "=",
   "self",
   ".",
   "_ex",
   ".",
   "_cache",
   ")",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "ncols",
   "-=",
   "1",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "names",
   "=",
   "self",
   ".",
   "names",
   "[",
   ":",
   "index",
   "]",
   "+",
   "self",
   ".",
   "names",
   "[",
   "index",
   "+",
   "1",
   ":",
   "]",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "types",
   "=",
   "{",
   "name",
   ":",
   "self",
   ".",
   "types",
   "[",
   "name",
   "]",
   "for",
   "name",
   "in",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "names",
   "}",
   "return",
   "fr",
   "elif",
   "isinstance",
   "(",
   "index",
   ",",
   "list",
   ")",
   ":",
   "#If input is an int array indicating a column index, i.e., [3] or [1,2,3]:",
   "if",
   "is_type",
   "(",
   "index",
   ",",
   "[",
   "int",
   "]",
   ")",
   ":",
   "if",
   "<mask>",
   "(",
   "index",
   ")",
   ">",
   "self",
   ".",
   "ncol",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Column index selected to drop is not part of the frame: %r\"",
   "%",
   "index",
   ")",
   "if",
   "min",
   "(",
   "index",
   ")",
   "<",
   "0",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Column index selected to drop is not positive: %r\"",
   "%",
   "index",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "index",
   ")",
   ")",
   ":",
   "index",
   "[",
   "i",
   "]",
   "=",
   "-",
   "(",
   "index",
   "[",
   "i",
   "]",
   "+",
   "1",
   ")",
   "#If index is a string array, i.e., [\"C1\", \"C2\"]",
   "elif",
   "is_type",
   "(",
   "index",
   ",",
   "[",
   "str",
   "]",
   ")",
   ":",
   "#Check if index is an actual column(s) in the frame",
   "if",
   "not",
   "set",
   "(",
   "index",
   ")",
   ".",
   "issubset",
   "(",
   "self",
   ".",
   "names",
   ")",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Column(s) selected to drop are not in original frame: %r\"",
   "%",
   "index",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "index",
   ")",
   ")",
   ":",
   "index",
   "[",
   "i",
   "]",
   "=",
   "-",
   "(",
   "self",
   ".",
   "names",
   ".",
   "index",
   "(",
   "index",
   "[",
   "i",
   "]",
   ")",
   "+",
   "1",
   ")",
   "fr",
   "=",
   "H2OFrame",
   ".",
   "_expr",
   "(",
   "expr",
   "=",
   "ExprNode",
   "(",
   "\"cols\"",
   ",",
   "self",
   ",",
   "index",
   ")",
   ",",
   "cache",
   "=",
   "self",
   ".",
   "_ex",
   ".",
   "_cache",
   ")",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "ncols",
   "-=",
   "len",
   "(",
   "index",
   ")",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "names",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "self",
   ".",
   "names",
   "if",
   "self",
   ".",
   "names",
   ".",
   "index",
   "(",
   "i",
   ")",
   "not",
   "in",
   "list",
   "(",
   "map",
   "(",
   "lambda",
   "x",
   ":",
   "abs",
   "(",
   "x",
   ")",
   "-",
   "1",
   ",",
   "index",
   ")",
   ")",
   "]",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "types",
   "=",
   "{",
   "name",
   ":",
   "fr",
   ".",
   "types",
   "[",
   "name",
   "]",
   "for",
   "name",
   "in",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "names",
   "}",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Invalid column index types. Must either be a list of all int indexes, \"",
   "\"a string list of all column names, a single int index, or\"",
   "\"a single string for dropping columns.\"",
   ")",
   "return",
   "fr",
   "elif",
   "axis",
   "==",
   "0",
   ":",
   "if",
   "is_type",
   "(",
   "index",
   ",",
   "[",
   "int",
   "]",
   ")",
   ":",
   "#Check if index is an actual column index in the frame",
   "if",
   "max",
   "(",
   "index",
   ")",
   ">",
   "self",
   ".",
   "nrow",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Row index selected to drop is not part of the frame: %r\"",
   "%",
   "index",
   ")",
   "if",
   "min",
   "(",
   "index",
   ")",
   "<",
   "0",
   ":",
   "raise",
   "H2OValueError",
   "(",
   "\"Row index selected to drop is not positive: %r\"",
   "%",
   "index",
   ")",
   "index",
   "=",
   "[",
   "-",
   "(",
   "x",
   "+",
   "1",
   ")",
   "for",
   "x",
   "in",
   "index",
   "]",
   "fr",
   "=",
   "H2OFrame",
   ".",
   "_expr",
   "(",
   "expr",
   "=",
   "ExprNode",
   "(",
   "\"rows\"",
   ",",
   "self",
   ",",
   "index",
   ")",
   ",",
   "cache",
   "=",
   "self",
   ".",
   "_ex",
   ".",
   "_cache",
   ")",
   "fr",
   ".",
   "_ex",
   ".",
   "_cache",
   ".",
   "nrows",
   "-=",
   "len",
   "(",
   "index",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Invalid row indexes. Must be a list of int row indexes to drop from the H2OFrame.\"",
   ")",
   "return",
   "fr"
  ]
 },
 {
  "idx": "maxmin-1027",
  "nl_tokens": [
   "Sonifies",
   "the",
   "estimated",
   "times",
   "into",
   "the",
   "output",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "sonify_clicks",
   "(",
   "audio",
   ",",
   "clicks",
   ",",
   "out_file",
   ",",
   "fs",
   ",",
   "offset",
   "=",
   "0",
   ")",
   ":",
   "# Generate clicks (this should be done by mir_eval, but its",
   "# latest release is not compatible with latest numpy)",
   "times",
   "=",
   "clicks",
   "+",
   "offset",
   "# 1 kHz tone, 100ms",
   "click",
   "=",
   "np",
   ".",
   "sin",
   "(",
   "2",
   "*",
   "np",
   ".",
   "pi",
   "*",
   "np",
   ".",
   "arange",
   "(",
   "fs",
   "*",
   ".1",
   ")",
   "*",
   "1000",
   "/",
   "(",
   "1.",
   "*",
   "fs",
   ")",
   ")",
   "# Exponential decay",
   "click",
   "*=",
   "np",
   ".",
   "exp",
   "(",
   "-",
   "np",
   ".",
   "arange",
   "(",
   "fs",
   "*",
   ".1",
   ")",
   "/",
   "(",
   "fs",
   "*",
   ".01",
   ")",
   ")",
   "length",
   "=",
   "int",
   "(",
   "times",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "fs",
   "+",
   "click",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "+",
   "1",
   ")",
   "audio_clicks",
   "=",
   "mir_eval",
   ".",
   "sonify",
   ".",
   "clicks",
   "(",
   "times",
   ",",
   "fs",
   ",",
   "length",
   "=",
   "length",
   ")",
   "# Create array to store the audio plus the clicks",
   "out_audio",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "max",
   "(",
   "len",
   "(",
   "audio",
   ")",
   ",",
   "len",
   "(",
   "audio_clicks",
   ")",
   ")",
   ")",
   "# Assign the audio and the clicks",
   "out_audio",
   "[",
   ":",
   "len",
   "(",
   "audio",
   ")",
   "]",
   "=",
   "audio",
   "out_audio",
   "[",
   ":",
   "len",
   "(",
   "audio_clicks",
   ")",
   "]",
   "+=",
   "audio_clicks",
   "# Write to file",
   "scipy",
   ".",
   "io",
   ".",
   "wavfile",
   ".",
   "write",
   "(",
   "out_file",
   ",",
   "fs",
   ",",
   "out_audio",
   ")"
  ]
 },
 {
  "idx": "maxmin-1028",
  "nl_tokens": [
   "Each",
   "layer",
   "has",
   "it",
   "s",
   "own",
   "ranges_grid",
   "computed",
   "now",
   "unless",
   "something",
   "went",
   "wrong",
   "But",
   "all",
   "layers",
   "are",
   "shown",
   "with",
   "the",
   "same",
   "ranges",
   "(",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   ")",
   "If",
   "any",
   "of",
   "the",
   "ranges",
   "is",
   "None",
   "take",
   "the",
   "min",
   "/",
   "max",
   "of",
   "each",
   "layer"
  ],
  "pl_tokens": [
   "def",
   "_update_step2",
   "(",
   "self",
   ",",
   "layers",
   ")",
   ":",
   "logger",
   ".",
   "info",
   "(",
   "\"done with ranges, now update step2 for layers: %r\"",
   ",",
   "layers",
   ")",
   "for",
   "dimension",
   "in",
   "range",
   "(",
   "self",
   ".",
   "dimensions",
   ")",
   ":",
   "if",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   "[",
   "dimension",
   "]",
   "is",
   "None",
   ":",
   "vmin",
   "=",
   "<mask>",
   "(",
   "[",
   "layer",
   ".",
   "state",
   ".",
   "ranges_grid",
   "[",
   "dimension",
   "]",
   "[",
   "0",
   "]",
   "for",
   "layer",
   "in",
   "layers",
   "]",
   ")",
   "vmax",
   "=",
   "max",
   "(",
   "[",
   "layer",
   ".",
   "state",
   ".",
   "ranges_grid",
   "[",
   "dimension",
   "]",
   "[",
   "1",
   "]",
   "for",
   "layer",
   "in",
   "layers",
   "]",
   ")",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   "[",
   "dimension",
   "]",
   "=",
   "[",
   "vmin",
   ",",
   "vmax",
   "]",
   "logger",
   ".",
   "debug",
   "(",
   "\"ranges before aspect check: %r\"",
   ",",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   ")",
   "self",
   ".",
   "check_aspect",
   "(",
   "0",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"ranges after aspect check: %r\"",
   ",",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   ")",
   "# now make sure the layers all have the same ranges_grid",
   "for",
   "layer",
   "in",
   "layers",
   ":",
   "# layer.state.ranges_grid = copy.deepcopy(self.state.ranges_viewport)",
   "for",
   "d",
   "in",
   "range",
   "(",
   "layer",
   ".",
   "dimensions",
   ")",
   ":",
   "layer",
   ".",
   "set_range",
   "(",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   "[",
   "d",
   "]",
   "[",
   "0",
   "]",
   ",",
   "self",
   ".",
   "state",
   ".",
   "ranges_viewport",
   "[",
   "d",
   "]",
   "[",
   "1",
   "]",
   ",",
   "d",
   ")",
   "# now we are ready to calculate histograms",
   "promises",
   "=",
   "[",
   "layer",
   ".",
   "add_tasks_histograms",
   "(",
   ")",
   "for",
   "layer",
   "in",
   "layers",
   "]",
   "executors",
   "=",
   "list",
   "(",
   "set",
   "(",
   "[",
   "layer",
   ".",
   "dataset",
   ".",
   "executor",
   "for",
   "layer",
   "in",
   "layers",
   "]",
   ")",
   ")",
   "for",
   "executor",
   "in",
   "executors",
   ":",
   "executor",
   ".",
   "execute",
   "(",
   ")",
   "promises_histograms_done",
   "=",
   "vaex",
   ".",
   "promise",
   ".",
   "listPromise",
   "(",
   "promises",
   ")",
   "promises_histograms_done",
   ".",
   "then",
   "(",
   "self",
   ".",
   "_update_step3",
   ",",
   "self",
   ".",
   "on_error_or_cancel",
   ")",
   ".",
   "end",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1029",
  "nl_tokens": [
   "Populate",
   "Filterbank",
   "instance",
   "with",
   "data",
   "from",
   "Filterbank",
   "file"
  ],
  "pl_tokens": [
   "def",
   "read_filterbank",
   "(",
   "self",
   ",",
   "filename",
   "=",
   "None",
   ",",
   "f_start",
   "=",
   "None",
   ",",
   "f_stop",
   "=",
   "None",
   ",",
   "t_start",
   "=",
   "None",
   ",",
   "t_stop",
   "=",
   "None",
   ",",
   "load_data",
   "=",
   "True",
   ")",
   ":",
   "if",
   "filename",
   "is",
   "None",
   ":",
   "filename",
   "=",
   "self",
   ".",
   "filename",
   "else",
   ":",
   "self",
   ".",
   "filename",
   "=",
   "filename",
   "self",
   ".",
   "header",
   "=",
   "read_header",
   "(",
   "filename",
   ")",
   "#convert input frequencies into what their corresponding index would be",
   "i_start",
   ",",
   "i_stop",
   ",",
   "chan_start_idx",
   ",",
   "chan_stop_idx",
   "=",
   "self",
   ".",
   "_setup_freqs",
   "(",
   "f_start",
   "=",
   "f_start",
   ",",
   "f_stop",
   "=",
   "f_stop",
   ")",
   "n_bits",
   "=",
   "self",
   ".",
   "header",
   "[",
   "b'nbits'",
   "]",
   "n_bytes",
   "=",
   "int",
   "(",
   "self",
   ".",
   "header",
   "[",
   "b'nbits'",
   "]",
   "/",
   "8",
   ")",
   "n_chans",
   "=",
   "self",
   ".",
   "header",
   "[",
   "b'nchans'",
   "]",
   "n_chans_selected",
   "=",
   "self",
   ".",
   "freqs",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "n_ifs",
   "=",
   "self",
   ".",
   "header",
   "[",
   "b'nifs'",
   "]",
   "# Load binary data",
   "self",
   ".",
   "idx_data",
   "=",
   "len_header",
   "(",
   "filename",
   ")",
   "f",
   "=",
   "open",
   "(",
   "filename",
   ",",
   "'rb'",
   ")",
   "f",
   ".",
   "seek",
   "(",
   "self",
   ".",
   "idx_data",
   ")",
   "filesize",
   "=",
   "os",
   ".",
   "path",
   ".",
   "getsize",
   "(",
   "self",
   ".",
   "filename",
   ")",
   "n_bytes_data",
   "=",
   "filesize",
   "-",
   "self",
   ".",
   "idx_data",
   "# Finally add some other info to the class as objects",
   "self",
   ".",
   "n_ints_in_file",
   "=",
   "calc_n_ints_in_file",
   "(",
   "self",
   ".",
   "filename",
   ")",
   "self",
   ".",
   "file_size_bytes",
   "=",
   "filesize",
   "## Setup time axis",
   "ii_start",
   ",",
   "ii_stop",
   ",",
   "n_ints",
   "=",
   "self",
   ".",
   "_setup_time_axis",
   "(",
   "t_start",
   "=",
   "t_start",
   ",",
   "t_stop",
   "=",
   "t_stop",
   ")",
   "# Seek to first integration",
   "f",
   ".",
   "seek",
   "(",
   "int",
   "(",
   "ii_start",
   "*",
   "n_bits",
   "*",
   "n_ifs",
   "*",
   "n_chans",
   "/",
   "8",
   ")",
   ",",
   "1",
   ")",
   "# Set up indexes used in file read (taken out of loop for speed)",
   "i0",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "(",
   "chan_start_idx",
   ",",
   "chan_stop_idx",
   ")",
   ")",
   "i1",
   "=",
   "np",
   ".",
   "max",
   "(",
   "(",
   "chan_start_idx",
   ",",
   "chan_stop_idx",
   ")",
   ")",
   "#Set up the data type (taken out of loop for speed)",
   "if",
   "n_bits",
   "==",
   "2",
   ":",
   "dd_type",
   "=",
   "b'uint8'",
   "n_chans_selected",
   "=",
   "int",
   "(",
   "n_chans_selected",
   "/",
   "4",
   ")",
   "elif",
   "n_bytes",
   "==",
   "4",
   ":",
   "dd_type",
   "=",
   "b'float32'",
   "elif",
   "n_bytes",
   "==",
   "2",
   ":",
   "dd_type",
   "=",
   "b'uint16'",
   "elif",
   "n_bytes",
   "==",
   "1",
   ":",
   "dd_type",
   "=",
   "b'uint8'",
   "if",
   "load_data",
   ":",
   "if",
   "n_ints",
   "*",
   "n_ifs",
   "*",
   "n_chans_selected",
   ">",
   "MAX_DATA_ARRAY_SIZE",
   ":",
   "print",
   "(",
   "\"[Filterbank]  Error: data array is too large to load. Either select fewer points or manually increase MAX_DATA_ARRAY_SIZE. Large files are now handle with Waterfall .\"",
   ")",
   "sys",
   ".",
   "exit",
   "(",
   ")",
   "if",
   "n_bits",
   "==",
   "2",
   ":",
   "self",
   ".",
   "data",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "n_ints",
   ",",
   "n_ifs",
   ",",
   "n_chans_selected",
   "*",
   "4",
   ")",
   ",",
   "dtype",
   "=",
   "dd_type",
   ")",
   "else",
   ":",
   "self",
   ".",
   "data",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "n_ints",
   ",",
   "n_ifs",
   ",",
   "n_chans_selected",
   ")",
   ",",
   "dtype",
   "=",
   "dd_type",
   ")",
   "for",
   "ii",
   "in",
   "range",
   "(",
   "n_ints",
   ")",
   ":",
   "\"\"\"d = f.read(n_bytes * n_chans * n_ifs)\n                \"\"\"",
   "for",
   "jj",
   "in",
   "range",
   "(",
   "n_ifs",
   ")",
   ":",
   "f",
   ".",
   "seek",
   "(",
   "n_bytes",
   "*",
   "i0",
   ",",
   "1",
   ")",
   "# 1 = from current location",
   "#d = f.read(n_bytes * n_chans_selected)",
   "#bytes_to_read = n_bytes * n_chans_selected",
   "dd",
   "=",
   "np",
   ".",
   "fromfile",
   "(",
   "f",
   ",",
   "count",
   "=",
   "n_chans_selected",
   ",",
   "dtype",
   "=",
   "dd_type",
   ")",
   "# Reverse array if frequency axis is flipped",
   "#                     if f_delt < 0:",
   "#                         dd = dd[::-1]",
   "if",
   "n_bits",
   "==",
   "2",
   ":",
   "dd",
   "=",
   "unpack_2to8",
   "(",
   "dd",
   ")",
   "self",
   ".",
   "data",
   "[",
   "ii",
   ",",
   "jj",
   "]",
   "=",
   "dd",
   "f",
   ".",
   "seek",
   "(",
   "n_bytes",
   "*",
   "(",
   "n_chans",
   "-",
   "i1",
   ")",
   ",",
   "1",
   ")",
   "# Seek to start of next block",
   "else",
   ":",
   "print",
   "(",
   "\"Skipping data load...\"",
   ")",
   "self",
   ".",
   "data",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "0",
   "]",
   ",",
   "dtype",
   "=",
   "dd_type",
   ")"
  ]
 },
 {
  "idx": "maxmin-1030",
  "nl_tokens": [
   "Print",
   "a",
   "string",
   "piping",
   "through",
   "a",
   "pager",
   "."
  ],
  "pl_tokens": [
   "def",
   "page",
   "(",
   "strng",
   ",",
   "start",
   "=",
   "0",
   ",",
   "screen_lines",
   "=",
   "0",
   ",",
   "pager_cmd",
   "=",
   "None",
   ",",
   "html",
   "=",
   "None",
   ",",
   "auto_html",
   "=",
   "False",
   ")",
   ":",
   "# Some routines may auto-compute start offsets incorrectly and pass a",
   "# negative value.  Offset to 0 for robustness.",
   "start",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "start",
   ")",
   "shell",
   "=",
   "InteractiveShell",
   ".",
   "instance",
   "(",
   ")",
   "if",
   "auto_html",
   ":",
   "try",
   ":",
   "# These defaults ensure user configuration variables for docutils",
   "# are not loaded, only our config is used here.",
   "defaults",
   "=",
   "{",
   "'file_insertion_enabled'",
   ":",
   "0",
   ",",
   "'raw_enabled'",
   ":",
   "0",
   ",",
   "'_disable_config'",
   ":",
   "1",
   "}",
   "html",
   "=",
   "publish_string",
   "(",
   "strng",
   ",",
   "writer_name",
   "=",
   "'html'",
   ",",
   "settings_overrides",
   "=",
   "defaults",
   ")",
   "except",
   ":",
   "pass",
   "payload",
   "=",
   "dict",
   "(",
   "source",
   "=",
   "'IPython.zmq.page.page'",
   ",",
   "text",
   "=",
   "strng",
   ",",
   "html",
   "=",
   "html",
   ",",
   "start_line_number",
   "=",
   "start",
   ")",
   "shell",
   ".",
   "payload_manager",
   ".",
   "write_payload",
   "(",
   "payload",
   ")"
  ]
 },
 {
  "idx": "maxmin-1031",
  "nl_tokens": [
   "Sends",
   "the",
   "field",
   "definitions",
   "ot",
   "standard",
   "out"
  ],
  "pl_tokens": [
   "def",
   "outputFieldMarkdown",
   "(",
   "self",
   ")",
   ":",
   "f",
   ",",
   "d",
   "=",
   "self",
   ".",
   "getFieldsColumnLengths",
   "(",
   ")",
   "fc",
   ",",
   "dc",
   "=",
   "self",
   ".",
   "printFieldsHeader",
   "(",
   "f",
   ",",
   "d",
   ")",
   "f",
   "=",
   "<mask>",
   "(",
   "fc",
   ",",
   "f",
   ")",
   "d",
   "=",
   "max",
   "(",
   "dc",
   ",",
   "d",
   ")",
   "self",
   ".",
   "printFields",
   "(",
   "f",
   ",",
   "d",
   ")"
  ]
 },
 {
  "idx": "maxmin-1032",
  "nl_tokens": [
   "Gets",
   "the",
   "width",
   "of",
   "the",
   "table",
   "that",
   "would",
   "be",
   "printed",
   ".",
   ":",
   "rtype",
   ":",
   "int"
  ],
  "pl_tokens": [
   "def",
   "get_table_width",
   "(",
   "table",
   ")",
   ":",
   "columns",
   "=",
   "transpose_table",
   "(",
   "prepare_rows",
   "(",
   "table",
   ")",
   ")",
   "widths",
   "=",
   "[",
   "<mask>",
   "(",
   "len",
   "(",
   "cell",
   ")",
   "for",
   "cell",
   "in",
   "column",
   ")",
   "for",
   "column",
   "in",
   "columns",
   "]",
   "return",
   "len",
   "(",
   "'+'",
   "+",
   "'|'",
   ".",
   "join",
   "(",
   "'-'",
   "*",
   "(",
   "w",
   "+",
   "2",
   ")",
   "for",
   "w",
   "in",
   "widths",
   ")",
   "+",
   "'+'",
   ")"
  ]
 },
 {
  "idx": "maxmin-1033",
  "nl_tokens": [
   "return",
   "dateobj",
   "+",
   "nb_years"
  ],
  "pl_tokens": [
   "def",
   "add_years",
   "(",
   "dateobj",
   ",",
   "nb_years",
   ")",
   ":",
   "year",
   "=",
   "dateobj",
   ".",
   "year",
   "+",
   "nb_years",
   "lastday",
   "=",
   "monthrange",
   "(",
   "year",
   ",",
   "dateobj",
   ".",
   "month",
   ")",
   "[",
   "1",
   "]",
   "return",
   "dateobj",
   ".",
   "replace",
   "(",
   "year",
   "=",
   "year",
   ",",
   "day",
   "=",
   "<mask>",
   "(",
   "lastday",
   ",",
   "dateobj",
   ".",
   "day",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1034",
  "nl_tokens": [
   "Print",
   "count",
   "entries",
   "of",
   "the",
   "stack",
   "trace"
  ],
  "pl_tokens": [
   "def",
   "print_stack_trace",
   "(",
   "proc_obj",
   ",",
   "count",
   "=",
   "None",
   ",",
   "color",
   "=",
   "'plain'",
   ",",
   "opts",
   "=",
   "{",
   "}",
   ")",
   ":",
   "if",
   "count",
   "is",
   "None",
   ":",
   "n",
   "=",
   "len",
   "(",
   "proc_obj",
   ".",
   "stack",
   ")",
   "else",
   ":",
   "n",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "proc_obj",
   ".",
   "stack",
   ")",
   ",",
   "count",
   ")",
   "try",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n",
   ")",
   ":",
   "print_stack_entry",
   "(",
   "proc_obj",
   ",",
   "i",
   ",",
   "color",
   "=",
   "color",
   ",",
   "opts",
   "=",
   "opts",
   ")",
   "except",
   "KeyboardInterrupt",
   ":",
   "pass",
   "return"
  ]
 },
 {
  "idx": "maxmin-1035",
  "nl_tokens": [
   "Save",
   "a",
   "vectorized",
   "image",
   "to",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "save_img",
   "(",
   "data",
   ",",
   "filename",
   ",",
   "masker",
   ",",
   "header",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "header",
   ":",
   "header",
   "=",
   "masker",
   ".",
   "get_header",
   "(",
   ")",
   "header",
   ".",
   "set_data_dtype",
   "(",
   "data",
   ".",
   "dtype",
   ")",
   "# Avoids loss of precision",
   "# Update min/max -- this should happen on save, but doesn't seem to",
   "header",
   "[",
   "'cal_max'",
   "]",
   "=",
   "data",
   ".",
   "<mask>",
   "(",
   ")",
   "header",
   "[",
   "'cal_min'",
   "]",
   "=",
   "data",
   ".",
   "min",
   "(",
   ")",
   "img",
   "=",
   "nifti1",
   ".",
   "Nifti1Image",
   "(",
   "masker",
   ".",
   "unmask",
   "(",
   "data",
   ")",
   ",",
   "None",
   ",",
   "header",
   ")",
   "img",
   ".",
   "to_filename",
   "(",
   "filename",
   ")"
  ]
 },
 {
  "idx": "maxmin-1036",
  "nl_tokens": [
   "Report",
   "how",
   "many",
   "data",
   "are",
   "removed",
   "by",
   "the",
   "active",
   "filters",
   "."
  ],
  "pl_tokens": [
   "def",
   "filter_nremoved",
   "(",
   "self",
   ",",
   "filt",
   "=",
   "True",
   ",",
   "quiet",
   "=",
   "False",
   ")",
   ":",
   "rminfo",
   "=",
   "{",
   "}",
   "for",
   "n",
   "in",
   "self",
   ".",
   "subsets",
   "[",
   "'All_Samples'",
   "]",
   ":",
   "s",
   "=",
   "self",
   ".",
   "data",
   "[",
   "n",
   "]",
   "rminfo",
   "[",
   "n",
   "]",
   "=",
   "s",
   ".",
   "filt_nremoved",
   "(",
   "filt",
   ")",
   "if",
   "not",
   "quiet",
   ":",
   "maxL",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "s",
   ")",
   "for",
   "s",
   "in",
   "rminfo",
   ".",
   "keys",
   "(",
   ")",
   "]",
   ")",
   "print",
   "(",
   "'{string:{number}s}'",
   ".",
   "format",
   "(",
   "string",
   "=",
   "'Sample '",
   ",",
   "number",
   "=",
   "maxL",
   "+",
   "3",
   ")",
   "+",
   "'{total:4s}'",
   ".",
   "format",
   "(",
   "total",
   "=",
   "'tot'",
   ")",
   "+",
   "'{removed:4s}'",
   ".",
   "format",
   "(",
   "removed",
   "=",
   "'flt'",
   ")",
   "+",
   "'{percent:4s}'",
   ".",
   "format",
   "(",
   "percent",
   "=",
   "'%rm'",
   ")",
   ")",
   "for",
   "k",
   ",",
   "(",
   "ntot",
   ",",
   "nfilt",
   ",",
   "pcrm",
   ")",
   "in",
   "rminfo",
   ".",
   "items",
   "(",
   ")",
   ":",
   "print",
   "(",
   "'{string:{number}s}'",
   ".",
   "format",
   "(",
   "string",
   "=",
   "k",
   ",",
   "number",
   "=",
   "maxL",
   "+",
   "3",
   ")",
   "+",
   "'{total:4.0f}'",
   ".",
   "format",
   "(",
   "total",
   "=",
   "ntot",
   ")",
   "+",
   "'{removed:4.0f}'",
   ".",
   "format",
   "(",
   "removed",
   "=",
   "nfilt",
   ")",
   "+",
   "'{percent:4.0f}'",
   ".",
   "format",
   "(",
   "percent",
   "=",
   "pcrm",
   ")",
   ")",
   "return",
   "rminfo"
  ]
 },
 {
  "idx": "maxmin-1037",
  "nl_tokens": [
   "Calculate",
   "the",
   "minimum",
   "for",
   "given",
   "expressions",
   "possibly",
   "on",
   "a",
   "grid",
   "defined",
   "by",
   "binby",
   "."
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "expression",
   ",",
   "binby",
   "=",
   "[",
   "]",
   ",",
   "limits",
   "=",
   "None",
   ",",
   "shape",
   "=",
   "default_shape",
   ",",
   "selection",
   "=",
   "False",
   ",",
   "delay",
   "=",
   "False",
   ",",
   "progress",
   "=",
   "None",
   ",",
   "edges",
   "=",
   "False",
   ")",
   ":",
   "return",
   "self",
   ".",
   "_compute_agg",
   "(",
   "'min'",
   ",",
   "expression",
   ",",
   "binby",
   ",",
   "limits",
   ",",
   "shape",
   ",",
   "selection",
   ",",
   "delay",
   ",",
   "edges",
   ",",
   "progress",
   ")",
   "@",
   "delayed",
   "def",
   "finish",
   "(",
   "result",
   ")",
   ":",
   "return",
   "result",
   "[",
   "...",
   ",",
   "0",
   "]",
   "return",
   "self",
   ".",
   "_delay",
   "(",
   "delay",
   ",",
   "finish",
   "(",
   "self",
   ".",
   "minmax",
   "(",
   "expression",
   ",",
   "binby",
   "=",
   "binby",
   ",",
   "limits",
   "=",
   "limits",
   ",",
   "shape",
   "=",
   "shape",
   ",",
   "selection",
   "=",
   "selection",
   ",",
   "delay",
   "=",
   "delay",
   ",",
   "progress",
   "=",
   "progress",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1038",
  "nl_tokens": [
   "Initial",
   "rendering",
   "stage",
   "done",
   "in",
   "order",
   "to",
   "compute",
   "widths",
   "of",
   "all",
   "widgets",
   "."
  ],
  "pl_tokens": [
   "def",
   "_compute_widget_sizes",
   "(",
   "self",
   ")",
   ":",
   "wl",
   "=",
   "[",
   "0",
   "]",
   "*",
   "len",
   "(",
   "self",
   ".",
   "_widgets",
   ")",
   "flex_count",
   "=",
   "0",
   "# First render all non-flexible widgets",
   "for",
   "i",
   ",",
   "widget",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "_widgets",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "widget",
   ",",
   "ProgressBarFlexibleWidget",
   ")",
   ":",
   "flex_count",
   "+=",
   "1",
   "else",
   ":",
   "wl",
   "[",
   "i",
   "]",
   "=",
   "widget",
   ".",
   "render",
   "(",
   "1",
   ")",
   ".",
   "length",
   "remaining_width",
   "=",
   "self",
   ".",
   "_width",
   "-",
   "sum",
   "(",
   "wl",
   ")",
   "remaining_width",
   "-=",
   "len",
   "(",
   "self",
   ".",
   "_widgets",
   ")",
   "-",
   "1",
   "# account for 1-space interval between widgets",
   "if",
   "remaining_width",
   "<",
   "10",
   "*",
   "flex_count",
   ":",
   "if",
   "self",
   ".",
   "_file_mode",
   ":",
   "remaining_width",
   "=",
   "10",
   "*",
   "flex_count",
   "else",
   ":",
   "# The window is too small to accomodate the widget: try to split it into several lines, otherwise",
   "# switch to \"file mode\". If we don't do this, then rendering the widget will cause it to wrap, and",
   "# then when we use \\r to go to the beginning of the line, only part of the widget will be overwritten,",
   "# which means we'll have many (possibly hundreds) of progress bar lines in the end.",
   "widget0",
   "=",
   "self",
   ".",
   "_widgets",
   "[",
   "0",
   "]",
   "if",
   "isinstance",
   "(",
   "widget0",
   ",",
   "PBWString",
   ")",
   "and",
   "remaining_width",
   "+",
   "widget0",
   ".",
   "render",
   "(",
   "0",
   ")",
   ".",
   "length",
   ">=",
   "10",
   "*",
   "flex_count",
   ":",
   "remaining_width",
   "+=",
   "widget0",
   ".",
   "render",
   "(",
   "0",
   ")",
   ".",
   "length",
   "+",
   "1",
   "self",
   ".",
   "_to_render",
   "=",
   "widget0",
   ".",
   "render",
   "(",
   "0",
   ")",
   ".",
   "rendered",
   "+",
   "\"\\n\"",
   "self",
   ".",
   "_widgets",
   "=",
   "self",
   ".",
   "_widgets",
   "[",
   "1",
   ":",
   "]",
   "if",
   "remaining_width",
   "<",
   "10",
   "*",
   "flex_count",
   ":",
   "self",
   ".",
   "_file_mode",
   "=",
   "True",
   "remaining_width",
   "=",
   "10",
   "*",
   "flex_count",
   "remaining_width",
   "=",
   "<mask>",
   "(",
   "remaining_width",
   ",",
   "10",
   "*",
   "flex_count",
   ")",
   "# Ensure at least 10 chars per flexible widget",
   "for",
   "i",
   ",",
   "widget",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "_widgets",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "widget",
   ",",
   "ProgressBarFlexibleWidget",
   ")",
   ":",
   "target_length",
   "=",
   "int",
   "(",
   "remaining_width",
   "/",
   "flex_count",
   ")",
   "result",
   "=",
   "widget",
   ".",
   "render",
   "(",
   "1",
   ",",
   "target_length",
   ")",
   "wl",
   "[",
   "i",
   "]",
   "=",
   "result",
   ".",
   "length",
   "remaining_width",
   "-=",
   "result",
   ".",
   "length",
   "flex_count",
   "-=",
   "1",
   "return",
   "wl"
  ]
 },
 {
  "idx": "maxmin-1039",
  "nl_tokens": [
   "Draw",
   "bboxes",
   "on",
   "an",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "imshow_bboxes",
   "(",
   "img",
   ",",
   "bboxes",
   ",",
   "colors",
   "=",
   "'green'",
   ",",
   "top_k",
   "=",
   "-",
   "1",
   ",",
   "thickness",
   "=",
   "1",
   ",",
   "show",
   "=",
   "True",
   ",",
   "win_name",
   "=",
   "''",
   ",",
   "wait_time",
   "=",
   "0",
   ",",
   "out_file",
   "=",
   "None",
   ")",
   ":",
   "img",
   "=",
   "imread",
   "(",
   "img",
   ")",
   "if",
   "isinstance",
   "(",
   "bboxes",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "bboxes",
   "=",
   "[",
   "bboxes",
   "]",
   "if",
   "not",
   "isinstance",
   "(",
   "colors",
   ",",
   "list",
   ")",
   ":",
   "colors",
   "=",
   "[",
   "colors",
   "for",
   "_",
   "in",
   "range",
   "(",
   "len",
   "(",
   "bboxes",
   ")",
   ")",
   "]",
   "colors",
   "=",
   "[",
   "color_val",
   "(",
   "c",
   ")",
   "for",
   "c",
   "in",
   "colors",
   "]",
   "assert",
   "len",
   "(",
   "bboxes",
   ")",
   "==",
   "len",
   "(",
   "colors",
   ")",
   "for",
   "i",
   ",",
   "_bboxes",
   "in",
   "enumerate",
   "(",
   "bboxes",
   ")",
   ":",
   "_bboxes",
   "=",
   "_bboxes",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "int32",
   ")",
   "if",
   "top_k",
   "<=",
   "0",
   ":",
   "_top_k",
   "=",
   "_bboxes",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "else",
   ":",
   "_top_k",
   "=",
   "<mask>",
   "(",
   "top_k",
   ",",
   "_bboxes",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "for",
   "j",
   "in",
   "range",
   "(",
   "_top_k",
   ")",
   ":",
   "left_top",
   "=",
   "(",
   "_bboxes",
   "[",
   "j",
   ",",
   "0",
   "]",
   ",",
   "_bboxes",
   "[",
   "j",
   ",",
   "1",
   "]",
   ")",
   "right_bottom",
   "=",
   "(",
   "_bboxes",
   "[",
   "j",
   ",",
   "2",
   "]",
   ",",
   "_bboxes",
   "[",
   "j",
   ",",
   "3",
   "]",
   ")",
   "cv2",
   ".",
   "rectangle",
   "(",
   "img",
   ",",
   "left_top",
   ",",
   "right_bottom",
   ",",
   "colors",
   "[",
   "i",
   "]",
   ",",
   "thickness",
   "=",
   "thickness",
   ")",
   "if",
   "show",
   ":",
   "imshow",
   "(",
   "img",
   ",",
   "win_name",
   ",",
   "wait_time",
   ")",
   "if",
   "out_file",
   "is",
   "not",
   "None",
   ":",
   "imwrite",
   "(",
   "img",
   ",",
   "out_file",
   ")"
  ]
 },
 {
  "idx": "maxmin-1040",
  "nl_tokens": [
   "This",
   "method",
   "checks",
   "whether",
   "a",
   "new",
   "DagRun",
   "needs",
   "to",
   "be",
   "created",
   "for",
   "a",
   "DAG",
   "based",
   "on",
   "scheduling",
   "interval",
   ".",
   "Returns",
   "DagRun",
   "if",
   "one",
   "is",
   "scheduled",
   ".",
   "Otherwise",
   "returns",
   "None",
   "."
  ],
  "pl_tokens": [
   "def",
   "create_dag_run",
   "(",
   "self",
   ",",
   "dag",
   ",",
   "session",
   "=",
   "None",
   ")",
   ":",
   "if",
   "dag",
   ".",
   "schedule_interval",
   "and",
   "conf",
   ".",
   "getboolean",
   "(",
   "'scheduler'",
   ",",
   "'USE_JOB_SCHEDULE'",
   ")",
   ":",
   "active_runs",
   "=",
   "DagRun",
   ".",
   "find",
   "(",
   "dag_id",
   "=",
   "dag",
   ".",
   "dag_id",
   ",",
   "state",
   "=",
   "State",
   ".",
   "RUNNING",
   ",",
   "external_trigger",
   "=",
   "False",
   ",",
   "session",
   "=",
   "session",
   ")",
   "# return if already reached maximum active runs and no timeout setting",
   "if",
   "len",
   "(",
   "active_runs",
   ")",
   ">=",
   "dag",
   ".",
   "max_active_runs",
   "and",
   "not",
   "dag",
   ".",
   "dagrun_timeout",
   ":",
   "return",
   "timedout_runs",
   "=",
   "0",
   "for",
   "dr",
   "in",
   "active_runs",
   ":",
   "if",
   "(",
   "dr",
   ".",
   "start_date",
   "and",
   "dag",
   ".",
   "dagrun_timeout",
   "and",
   "dr",
   ".",
   "start_date",
   "<",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "-",
   "dag",
   ".",
   "dagrun_timeout",
   ")",
   ":",
   "dr",
   ".",
   "state",
   "=",
   "State",
   ".",
   "FAILED",
   "dr",
   ".",
   "end_date",
   "=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "dag",
   ".",
   "handle_callback",
   "(",
   "dr",
   ",",
   "success",
   "=",
   "False",
   ",",
   "reason",
   "=",
   "'dagrun_timeout'",
   ",",
   "session",
   "=",
   "session",
   ")",
   "timedout_runs",
   "+=",
   "1",
   "session",
   ".",
   "commit",
   "(",
   ")",
   "if",
   "len",
   "(",
   "active_runs",
   ")",
   "-",
   "timedout_runs",
   ">=",
   "dag",
   ".",
   "max_active_runs",
   ":",
   "return",
   "# this query should be replaced by find dagrun",
   "qry",
   "=",
   "(",
   "session",
   ".",
   "query",
   "(",
   "func",
   ".",
   "<mask>",
   "(",
   "DagRun",
   ".",
   "execution_date",
   ")",
   ")",
   ".",
   "filter_by",
   "(",
   "dag_id",
   "=",
   "dag",
   ".",
   "dag_id",
   ")",
   ".",
   "filter",
   "(",
   "or_",
   "(",
   "DagRun",
   ".",
   "external_trigger",
   "==",
   "False",
   ",",
   "# noqa: E712",
   "# add % as a wildcard for the like query",
   "DagRun",
   ".",
   "run_id",
   ".",
   "like",
   "(",
   "DagRun",
   ".",
   "ID_PREFIX",
   "+",
   "'%'",
   ")",
   ")",
   ")",
   ")",
   "last_scheduled_run",
   "=",
   "qry",
   ".",
   "scalar",
   "(",
   ")",
   "# don't schedule @once again",
   "if",
   "dag",
   ".",
   "schedule_interval",
   "==",
   "'@once'",
   "and",
   "last_scheduled_run",
   ":",
   "return",
   "None",
   "# don't do scheduler catchup for dag's that don't have dag.catchup = True",
   "if",
   "not",
   "(",
   "dag",
   ".",
   "catchup",
   "or",
   "dag",
   ".",
   "schedule_interval",
   "==",
   "'@once'",
   ")",
   ":",
   "# The logic is that we move start_date up until",
   "# one period before, so that timezone.utcnow() is AFTER",
   "# the period end, and the job can be created...",
   "now",
   "=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   "next_start",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "now",
   ")",
   "last_start",
   "=",
   "dag",
   ".",
   "previous_schedule",
   "(",
   "now",
   ")",
   "if",
   "next_start",
   "<=",
   "now",
   ":",
   "new_start",
   "=",
   "last_start",
   "else",
   ":",
   "new_start",
   "=",
   "dag",
   ".",
   "previous_schedule",
   "(",
   "last_start",
   ")",
   "if",
   "dag",
   ".",
   "start_date",
   ":",
   "if",
   "new_start",
   ">=",
   "dag",
   ".",
   "start_date",
   ":",
   "dag",
   ".",
   "start_date",
   "=",
   "new_start",
   "else",
   ":",
   "dag",
   ".",
   "start_date",
   "=",
   "new_start",
   "next_run_date",
   "=",
   "None",
   "if",
   "not",
   "last_scheduled_run",
   ":",
   "# First run",
   "task_start_dates",
   "=",
   "[",
   "t",
   ".",
   "start_date",
   "for",
   "t",
   "in",
   "dag",
   ".",
   "tasks",
   "]",
   "if",
   "task_start_dates",
   ":",
   "next_run_date",
   "=",
   "dag",
   ".",
   "normalize_schedule",
   "(",
   "min",
   "(",
   "task_start_dates",
   ")",
   ")",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"Next run date based on tasks %s\"",
   ",",
   "next_run_date",
   ")",
   "else",
   ":",
   "next_run_date",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "last_scheduled_run",
   ")",
   "# make sure backfills are also considered",
   "last_run",
   "=",
   "dag",
   ".",
   "get_last_dagrun",
   "(",
   "session",
   "=",
   "session",
   ")",
   "if",
   "last_run",
   "and",
   "next_run_date",
   ":",
   "while",
   "next_run_date",
   "<=",
   "last_run",
   ".",
   "execution_date",
   ":",
   "next_run_date",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "next_run_date",
   ")",
   "# don't ever schedule prior to the dag's start_date",
   "if",
   "dag",
   ".",
   "start_date",
   ":",
   "next_run_date",
   "=",
   "(",
   "dag",
   ".",
   "start_date",
   "if",
   "not",
   "next_run_date",
   "else",
   "max",
   "(",
   "next_run_date",
   ",",
   "dag",
   ".",
   "start_date",
   ")",
   ")",
   "if",
   "next_run_date",
   "==",
   "dag",
   ".",
   "start_date",
   ":",
   "next_run_date",
   "=",
   "dag",
   ".",
   "normalize_schedule",
   "(",
   "dag",
   ".",
   "start_date",
   ")",
   "self",
   ".",
   "log",
   ".",
   "debug",
   "(",
   "\"Dag start date: %s. Next run date: %s\"",
   ",",
   "dag",
   ".",
   "start_date",
   ",",
   "next_run_date",
   ")",
   "# don't ever schedule in the future or if next_run_date is None",
   "if",
   "not",
   "next_run_date",
   "or",
   "next_run_date",
   ">",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   ":",
   "return",
   "# this structure is necessary to avoid a TypeError from concatenating",
   "# NoneType",
   "if",
   "dag",
   ".",
   "schedule_interval",
   "==",
   "'@once'",
   ":",
   "period_end",
   "=",
   "next_run_date",
   "elif",
   "next_run_date",
   ":",
   "period_end",
   "=",
   "dag",
   ".",
   "following_schedule",
   "(",
   "next_run_date",
   ")",
   "# Don't schedule a dag beyond its end_date (as specified by the dag param)",
   "if",
   "next_run_date",
   "and",
   "dag",
   ".",
   "end_date",
   "and",
   "next_run_date",
   ">",
   "dag",
   ".",
   "end_date",
   ":",
   "return",
   "# Don't schedule a dag beyond its end_date (as specified by the task params)",
   "# Get the min task end date, which may come from the dag.default_args",
   "min_task_end_date",
   "=",
   "[",
   "]",
   "task_end_dates",
   "=",
   "[",
   "t",
   ".",
   "end_date",
   "for",
   "t",
   "in",
   "dag",
   ".",
   "tasks",
   "if",
   "t",
   ".",
   "end_date",
   "]",
   "if",
   "task_end_dates",
   ":",
   "min_task_end_date",
   "=",
   "min",
   "(",
   "task_end_dates",
   ")",
   "if",
   "next_run_date",
   "and",
   "min_task_end_date",
   "and",
   "next_run_date",
   ">",
   "min_task_end_date",
   ":",
   "return",
   "if",
   "next_run_date",
   "and",
   "period_end",
   "and",
   "period_end",
   "<=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   ":",
   "next_run",
   "=",
   "dag",
   ".",
   "create_dagrun",
   "(",
   "run_id",
   "=",
   "DagRun",
   ".",
   "ID_PREFIX",
   "+",
   "next_run_date",
   ".",
   "isoformat",
   "(",
   ")",
   ",",
   "execution_date",
   "=",
   "next_run_date",
   ",",
   "start_date",
   "=",
   "timezone",
   ".",
   "utcnow",
   "(",
   ")",
   ",",
   "state",
   "=",
   "State",
   ".",
   "RUNNING",
   ",",
   "external_trigger",
   "=",
   "False",
   ")",
   "return",
   "next_run"
  ]
 },
 {
  "idx": "maxmin-1041",
  "nl_tokens": [
   "parse",
   "an",
   "abiguous",
   "date",
   "such",
   "as",
   "2017",
   "-",
   "XX",
   "-",
   "XX",
   "to",
   "[",
   "2017",
   "2017",
   ".",
   "999",
   "]"
  ],
  "pl_tokens": [
   "def",
   "ambiguous_date_to_date_range",
   "(",
   "mydate",
   ",",
   "fmt",
   "=",
   "\"%Y-%m-%d\"",
   ",",
   "min_max_year",
   "=",
   "None",
   ")",
   ":",
   "from",
   "datetime",
   "import",
   "datetime",
   "sep",
   "=",
   "fmt",
   ".",
   "split",
   "(",
   "'%'",
   ")",
   "[",
   "1",
   "]",
   "[",
   "-",
   "1",
   "]",
   "min_date",
   ",",
   "max_date",
   "=",
   "{",
   "}",
   ",",
   "{",
   "}",
   "today",
   "=",
   "datetime",
   ".",
   "today",
   "(",
   ")",
   ".",
   "date",
   "(",
   ")",
   "for",
   "val",
   ",",
   "field",
   "in",
   "zip",
   "(",
   "mydate",
   ".",
   "split",
   "(",
   "sep",
   ")",
   ",",
   "fmt",
   ".",
   "split",
   "(",
   "sep",
   "+",
   "'%'",
   ")",
   ")",
   ":",
   "f",
   "=",
   "'year'",
   "if",
   "'y'",
   "in",
   "field",
   ".",
   "lower",
   "(",
   ")",
   "else",
   "(",
   "'day'",
   "if",
   "'d'",
   "in",
   "field",
   ".",
   "lower",
   "(",
   ")",
   "else",
   "'month'",
   ")",
   "if",
   "'XX'",
   "in",
   "val",
   ":",
   "if",
   "f",
   "==",
   "'year'",
   ":",
   "if",
   "min_max_year",
   ":",
   "min_date",
   "[",
   "f",
   "]",
   "=",
   "min_max_year",
   "[",
   "0",
   "]",
   "if",
   "len",
   "(",
   "min_max_year",
   ")",
   ">",
   "1",
   ":",
   "max_date",
   "[",
   "f",
   "]",
   "=",
   "min_max_year",
   "[",
   "1",
   "]",
   "elif",
   "len",
   "(",
   "min_max_year",
   ")",
   "==",
   "1",
   ":",
   "max_date",
   "[",
   "f",
   "]",
   "=",
   "4000",
   "#will be replaced by 'today' below.",
   "else",
   ":",
   "return",
   "None",
   ",",
   "None",
   "elif",
   "f",
   "==",
   "'month'",
   ":",
   "min_date",
   "[",
   "f",
   "]",
   "=",
   "1",
   "max_date",
   "[",
   "f",
   "]",
   "=",
   "12",
   "elif",
   "f",
   "==",
   "'day'",
   ":",
   "min_date",
   "[",
   "f",
   "]",
   "=",
   "1",
   "max_date",
   "[",
   "f",
   "]",
   "=",
   "31",
   "else",
   ":",
   "try",
   ":",
   "min_date",
   "[",
   "f",
   "]",
   "=",
   "int",
   "(",
   "val",
   ")",
   "max_date",
   "[",
   "f",
   "]",
   "=",
   "int",
   "(",
   "val",
   ")",
   "except",
   "ValueError",
   ":",
   "print",
   "(",
   "\"Can't parse date string: \"",
   "+",
   "mydate",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ")",
   "return",
   "None",
   ",",
   "None",
   "max_date",
   "[",
   "'day'",
   "]",
   "=",
   "<mask>",
   "(",
   "max_date",
   "[",
   "'day'",
   "]",
   ",",
   "31",
   "if",
   "max_date",
   "[",
   "'month'",
   "]",
   "in",
   "[",
   "1",
   ",",
   "3",
   ",",
   "5",
   ",",
   "7",
   ",",
   "8",
   ",",
   "10",
   ",",
   "12",
   "]",
   "else",
   "28",
   "if",
   "max_date",
   "[",
   "'month'",
   "]",
   "==",
   "2",
   "else",
   "30",
   ")",
   "lower_bound",
   "=",
   "datetime",
   "(",
   "year",
   "=",
   "min_date",
   "[",
   "'year'",
   "]",
   ",",
   "month",
   "=",
   "min_date",
   "[",
   "'month'",
   "]",
   ",",
   "day",
   "=",
   "min_date",
   "[",
   "'day'",
   "]",
   ")",
   ".",
   "date",
   "(",
   ")",
   "upper_bound",
   "=",
   "datetime",
   "(",
   "year",
   "=",
   "max_date",
   "[",
   "'year'",
   "]",
   ",",
   "month",
   "=",
   "max_date",
   "[",
   "'month'",
   "]",
   ",",
   "day",
   "=",
   "max_date",
   "[",
   "'day'",
   "]",
   ")",
   ".",
   "date",
   "(",
   ")",
   "return",
   "(",
   "lower_bound",
   ",",
   "upper_bound",
   "if",
   "upper_bound",
   "<",
   "today",
   "else",
   "today",
   ")"
  ]
 },
 {
  "idx": "maxmin-1042",
  "nl_tokens": [
   "Make",
   "a",
   "simple",
   "plot",
   "of",
   "the",
   "Decor",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot",
   "(",
   "self",
   ",",
   "fmt",
   "=",
   "None",
   ",",
   "fig",
   "=",
   "None",
   ",",
   "ax",
   "=",
   "None",
   ")",
   ":",
   "u",
   "=",
   "4",
   "# aspect ratio of decor plot",
   "v",
   "=",
   "0.25",
   "# ratio of decor tile width",
   "r",
   "=",
   "None",
   "if",
   "(",
   "fig",
   "is",
   "None",
   ")",
   "and",
   "(",
   "ax",
   "is",
   "None",
   ")",
   ":",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "u",
   ",",
   "1",
   ")",
   ")",
   "else",
   ":",
   "r",
   "=",
   "fig",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.1",
   "*",
   "v",
   ",",
   "0.1",
   ",",
   "0.8",
   "*",
   "v",
   ",",
   "0.8",
   "]",
   ")",
   "else",
   ":",
   "r",
   "=",
   "ax",
   "rect1",
   "=",
   "patches",
   ".",
   "Rectangle",
   "(",
   "(",
   "0",
   ",",
   "0",
   ")",
   ",",
   "u",
   "*",
   "v",
   ",",
   "u",
   "*",
   "v",
   ",",
   "color",
   "=",
   "self",
   ".",
   "colour",
   ",",
   "lw",
   "=",
   "1",
   ",",
   "hatch",
   "=",
   "self",
   ".",
   "hatch",
   ",",
   "ec",
   "=",
   "'k'",
   ")",
   "ax",
   ".",
   "add_patch",
   "(",
   "rect1",
   ")",
   "ax",
   ".",
   "text",
   "(",
   "1.0",
   "+",
   "0.1",
   "*",
   "v",
   "*",
   "u",
   ",",
   "u",
   "*",
   "v",
   "*",
   "0.5",
   ",",
   "self",
   ".",
   "component",
   ".",
   "summary",
   "(",
   "fmt",
   "=",
   "fmt",
   ")",
   ",",
   "fontsize",
   "=",
   "<mask>",
   "(",
   "u",
   ",",
   "15",
   ")",
   ",",
   "verticalalignment",
   "=",
   "'center'",
   ",",
   "horizontalalignment",
   "=",
   "'left'",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "[",
   "0",
   ",",
   "u",
   "*",
   "v",
   "]",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "[",
   "0",
   ",",
   "u",
   "*",
   "v",
   "]",
   ")",
   "ax",
   ".",
   "get_xaxis",
   "(",
   ")",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "get_yaxis",
   "(",
   ")",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "invert_yaxis",
   "(",
   ")",
   "return",
   "r"
  ]
 },
 {
  "idx": "maxmin-1043",
  "nl_tokens": [
   "Trim",
   "leading",
   "and",
   "trailing",
   "silence",
   "from",
   "an",
   "audio",
   "signal",
   "."
  ],
  "pl_tokens": [
   "def",
   "trim",
   "(",
   "y",
   ",",
   "top_db",
   "=",
   "60",
   ",",
   "ref",
   "=",
   "np",
   ".",
   "<mask>",
   ",",
   "frame_length",
   "=",
   "2048",
   ",",
   "hop_length",
   "=",
   "512",
   ")",
   ":",
   "non_silent",
   "=",
   "_signal_to_frame_nonsilent",
   "(",
   "y",
   ",",
   "frame_length",
   "=",
   "frame_length",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ",",
   "ref",
   "=",
   "ref",
   ",",
   "top_db",
   "=",
   "top_db",
   ")",
   "nonzero",
   "=",
   "np",
   ".",
   "flatnonzero",
   "(",
   "non_silent",
   ")",
   "if",
   "nonzero",
   ".",
   "size",
   ">",
   "0",
   ":",
   "# Compute the start and end positions",
   "# End position goes one frame past the last non-zero",
   "start",
   "=",
   "int",
   "(",
   "core",
   ".",
   "frames_to_samples",
   "(",
   "nonzero",
   "[",
   "0",
   "]",
   ",",
   "hop_length",
   ")",
   ")",
   "end",
   "=",
   "min",
   "(",
   "y",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ",",
   "int",
   "(",
   "core",
   ".",
   "frames_to_samples",
   "(",
   "nonzero",
   "[",
   "-",
   "1",
   "]",
   "+",
   "1",
   ",",
   "hop_length",
   ")",
   ")",
   ")",
   "else",
   ":",
   "# The signal only contains zeros",
   "start",
   ",",
   "end",
   "=",
   "0",
   ",",
   "0",
   "# Build the mono/stereo index",
   "full_index",
   "=",
   "[",
   "slice",
   "(",
   "None",
   ")",
   "]",
   "*",
   "y",
   ".",
   "ndim",
   "full_index",
   "[",
   "-",
   "1",
   "]",
   "=",
   "slice",
   "(",
   "start",
   ",",
   "end",
   ")",
   "return",
   "y",
   "[",
   "tuple",
   "(",
   "full_index",
   ")",
   "]",
   ",",
   "np",
   ".",
   "asarray",
   "(",
   "[",
   "start",
   ",",
   "end",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-1044",
  "nl_tokens": [
   "Print",
   "generated",
   "model",
   "data",
   "in",
   "human",
   "readable",
   "format",
   "."
  ],
  "pl_tokens": [
   "def",
   "report",
   "(",
   "self",
   ",",
   "output_file",
   "=",
   "sys",
   ".",
   "stdout",
   ")",
   ":",
   "report",
   "=",
   "''",
   "if",
   "self",
   ".",
   "verbose",
   ">",
   "1",
   ":",
   "self",
   ".",
   "_CPU",
   ".",
   "report",
   "(",
   ")",
   "self",
   ".",
   "_data",
   ".",
   "report",
   "(",
   ")",
   "report",
   "+=",
   "'{{ {:.1f} || {:.1f} | {} }} cy/CL'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'T_OL'",
   "]",
   ",",
   "self",
   ".",
   "results",
   "[",
   "'T_nOL'",
   "]",
   ",",
   "' | '",
   ".",
   "join",
   "(",
   "[",
   "'{:.1f}'",
   ".",
   "format",
   "(",
   "i",
   "[",
   "1",
   "]",
   ")",
   "for",
   "i",
   "in",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "]",
   ")",
   ")",
   "if",
   "self",
   ".",
   "_args",
   ".",
   "cores",
   ">",
   "1",
   ":",
   "report",
   "+=",
   "\" (single core)\"",
   "report",
   "+=",
   "' = {}'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'total cycles'",
   "]",
   "[",
   "self",
   ".",
   "_args",
   ".",
   "unit",
   "]",
   ")",
   "report",
   "+=",
   "'\\n{{ {:.1f} \\ {} }} cy/CL'",
   ".",
   "format",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'T_OL'",
   "]",
   ",",
   "self",
   ".",
   "results",
   "[",
   "'T_nOL'",
   "]",
   ")",
   ",",
   "' \\ '",
   ".",
   "join",
   "(",
   "[",
   "'{:.1f}'",
   ".",
   "format",
   "(",
   "max",
   "(",
   "sum",
   "(",
   "[",
   "x",
   "[",
   "1",
   "]",
   "for",
   "x",
   "in",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "[",
   ":",
   "i",
   "+",
   "1",
   "]",
   "]",
   ")",
   "+",
   "self",
   ".",
   "results",
   "[",
   "'T_nOL'",
   "]",
   ",",
   "self",
   ".",
   "results",
   "[",
   "'T_OL'",
   "]",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   ")",
   ")",
   "]",
   ")",
   ")",
   "if",
   "self",
   ".",
   "_args",
   ".",
   "cores",
   ">",
   "1",
   ":",
   "report",
   "+=",
   "\" (single core)\"",
   "report",
   "+=",
   "'\\nsaturating at {:.0f} cores'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'scaling cores'",
   "]",
   ")",
   "if",
   "self",
   ".",
   "results",
   "[",
   "'multi-core'",
   "]",
   ":",
   "report",
   "+=",
   "\"\\nprediction for {} cores,\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'multi-core'",
   "]",
   "[",
   "'cores'",
   "]",
   ")",
   "+",
   "\" assuming static scheduling: \"",
   "report",
   "+=",
   "\"{} ({})\\n\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'multi-core'",
   "]",
   "[",
   "'performance'",
   "]",
   "[",
   "self",
   ".",
   "_args",
   ".",
   "unit",
   "]",
   ",",
   "', '",
   ".",
   "join",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'multi-core'",
   "]",
   "[",
   "'notes'",
   "]",
   ")",
   ")",
   "if",
   "self",
   ".",
   "results",
   "[",
   "'scaling prediction'",
   "]",
   ":",
   "report",
   "+=",
   "\"\\nScaling prediction, considering memory bus utilization penalty and \"",
   "\"assuming all scalable caches:\\n\"",
   "if",
   "self",
   ".",
   "machine",
   "[",
   "'cores per socket'",
   "]",
   ">",
   "self",
   ".",
   "machine",
   "[",
   "'cores per NUMA domain'",
   "]",
   ":",
   "report",
   "+=",
   "\"1st NUMA dom.\"",
   "+",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_args",
   ".",
   "unit",
   ")",
   "-",
   "4",
   ")",
   "*",
   "' '",
   "+",
   "'||'",
   "+",
   "'--------'",
   "*",
   "(",
   "self",
   ".",
   "machine",
   "[",
   "'cores per NUMA domain'",
   "]",
   "-",
   "1",
   ")",
   "+",
   "'-------|\\n'",
   "report",
   "+=",
   "\"cores \"",
   "+",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_args",
   ".",
   "unit",
   ")",
   "+",
   "2",
   ")",
   "*",
   "' '",
   "+",
   "\" || \"",
   "+",
   "' | '",
   ".",
   "join",
   "(",
   "[",
   "'{:<5}'",
   ".",
   "format",
   "(",
   "s",
   "[",
   "'cores'",
   "]",
   ")",
   "for",
   "s",
   "in",
   "self",
   ".",
   "results",
   "[",
   "'scaling prediction'",
   "]",
   "]",
   ")",
   "+",
   "'\\n'",
   "report",
   "+=",
   "\"perf. ({}) || \"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "_args",
   ".",
   "unit",
   ")",
   "+",
   "' | '",
   ".",
   "join",
   "(",
   "[",
   "'{:<5.1f}'",
   ".",
   "format",
   "(",
   "float",
   "(",
   "s",
   "[",
   "'performance'",
   "]",
   "[",
   "self",
   ".",
   "_args",
   ".",
   "unit",
   "]",
   ")",
   ")",
   "for",
   "s",
   "in",
   "self",
   ".",
   "results",
   "[",
   "'scaling prediction'",
   "]",
   "]",
   ")",
   "+",
   "'\\n'",
   "print",
   "(",
   "report",
   ",",
   "file",
   "=",
   "output_file",
   ")",
   "if",
   "self",
   ".",
   "_args",
   "and",
   "self",
   ".",
   "_args",
   ".",
   "ecm_plot",
   ":",
   "assert",
   "plot_support",
   ",",
   "\"matplotlib couldn't be imported. Plotting is not supported.\"",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "frameon",
   "=",
   "False",
   ")",
   "self",
   ".",
   "plot",
   "(",
   "fig",
   ")"
  ]
 },
 {
  "idx": "maxmin-1045",
  "nl_tokens": [
   "\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442",
   "\u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e",
   "\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c",
   "\u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f",
   "\u043d\u043e\u0432\u043e\u0433\u043e",
   "\u0441\u0438\u043c\u0432\u043e\u043b\u0430",
   "\u0432",
   "\u0443\u0437\u043b\u0430\u0445",
   "\u0441\u043b\u043e\u0432\u0430\u0440\u044f",
   "\u0432",
   "\u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438",
   "\u0441\u043e",
   "\u0448\u0442\u0440\u0430\u0444\u0430\u043c\u0438",
   "\u0438\u0437",
   "costs"
  ],
  "pl_tokens": [
   "def",
   "_precompute_absense_costs",
   "(",
   "dictionary",
   ",",
   "removal_costs",
   ",",
   "insertion_costs",
   ",",
   "n",
   ",",
   "allow_spaces",
   "=",
   "False",
   ")",
   ":",
   "answer",
   "=",
   "[",
   "dict",
   "(",
   ")",
   "for",
   "node",
   "in",
   "dictionary",
   ".",
   "data",
   "]",
   "if",
   "n",
   "==",
   "0",
   ":",
   "return",
   "answer",
   "curr_alphabet",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "dictionary",
   ".",
   "alphabet",
   ")",
   "if",
   "allow_spaces",
   ":",
   "curr_alphabet",
   "+=",
   "[",
   "' '",
   "]",
   "for",
   "l",
   ",",
   "(",
   "costs_in_node",
   ",",
   "node",
   ")",
   "in",
   "enumerate",
   "(",
   "zip",
   "(",
   "answer",
   ",",
   "dictionary",
   ".",
   "data",
   ")",
   ")",
   ":",
   "# \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432",
   "curr_node_removal_costs",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ",",
   "shape",
   "=",
   "(",
   "n",
   ",",
   ")",
   ")",
   "if",
   "len",
   "(",
   "node",
   "[",
   "0",
   "]",
   ")",
   ">",
   "0",
   ":",
   "curr_node_removal_costs",
   "[",
   "0",
   "]",
   "=",
   "<mask>",
   "(",
   "removal_costs",
   "[",
   "symbol",
   "]",
   "for",
   "symbol",
   "in",
   "node",
   "[",
   "0",
   "]",
   ")",
   "for",
   "j",
   ",",
   "symbols",
   "in",
   "enumerate",
   "(",
   "node",
   "[",
   "1",
   ":",
   "]",
   ",",
   "1",
   ")",
   ":",
   "if",
   "len",
   "(",
   "symbols",
   ")",
   "==",
   "0",
   ":",
   "curr_node_removal_costs",
   "[",
   "j",
   ":",
   "]",
   "=",
   "curr_node_removal_costs",
   "[",
   "j",
   "-",
   "1",
   "]",
   "break",
   "curr_cost",
   "=",
   "min",
   "(",
   "removal_costs",
   "[",
   "symbol",
   "]",
   "for",
   "symbol",
   "in",
   "symbols",
   ")",
   "curr_node_removal_costs",
   "[",
   "j",
   "]",
   "=",
   "min",
   "(",
   "curr_node_removal_costs",
   "[",
   "j",
   "-",
   "1",
   "]",
   ",",
   "curr_cost",
   ")",
   "else",
   ":",
   "curr_node_removal_costs",
   "[",
   ":",
   "]",
   "=",
   "np",
   ".",
   "inf",
   "# \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0438 \u0432\u0441\u0442\u0430\u0432\u043a\u0438",
   "for",
   "a",
   "in",
   "curr_alphabet",
   ":",
   "curr_symbol_costs",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   ",",
   "shape",
   "=",
   "(",
   "n",
   ",",
   ")",
   ")",
   "curr_symbol_costs",
   ".",
   "fill",
   "(",
   "insertion_costs",
   "[",
   "a",
   "]",
   ")",
   "for",
   "j",
   ",",
   "symbols",
   "in",
   "enumerate",
   "(",
   "node",
   ")",
   ":",
   "if",
   "a",
   "in",
   "symbols",
   ":",
   "curr_symbol_costs",
   "[",
   "j",
   ":",
   "]",
   "=",
   "0.0",
   "break",
   "curr_symbol_costs",
   "[",
   "j",
   "]",
   "=",
   "min",
   "(",
   "curr_symbol_costs",
   "[",
   "j",
   "]",
   ",",
   "curr_node_removal_costs",
   "[",
   "j",
   "]",
   ")",
   "costs_in_node",
   "[",
   "a",
   "]",
   "=",
   "curr_symbol_costs",
   "return",
   "answer"
  ]
 },
 {
  "idx": "maxmin-1046",
  "nl_tokens": [
   "Returns",
   "an",
   "updated",
   "segmentation",
   "mask",
   "such",
   "that",
   "the",
   "input",
   "segmentation_mask",
   "has",
   "been",
   "updated",
   "by",
   "segmenting",
   "between",
   "onset_front_id",
   "and",
   "offset_front_id",
   "as",
   "found",
   "in",
   "onset_fronts",
   "and",
   "offset_fronts",
   "respectively",
   "."
  ],
  "pl_tokens": [
   "def",
   "_update_segmentation_mask",
   "(",
   "segmentation_mask",
   ",",
   "onset_fronts",
   ",",
   "offset_fronts",
   ",",
   "onset_front_id",
   ",",
   "offset_front_id_most_overlap",
   ")",
   ":",
   "# Get the portions of the onset and offset fronts that overlap and are consecutive",
   "onset_front_overlap",
   ",",
   "offset_front_overlap",
   "=",
   "_get_consecutive_and_overlapping_fronts",
   "(",
   "onset_fronts",
   ",",
   "offset_fronts",
   ",",
   "onset_front_id",
   ",",
   "offset_front_id_most_overlap",
   ")",
   "onset_front",
   "=",
   "_get_front_idxs_from_id",
   "(",
   "onset_fronts",
   ",",
   "onset_front_id",
   ")",
   "offset_front",
   "=",
   "_get_front_idxs_from_id",
   "(",
   "offset_fronts",
   ",",
   "offset_front_id_most_overlap",
   ")",
   "msg",
   "=",
   "\"Onset front {} and offset front {} result in consecutive overlapping portions of (on) {} and (off) {}, one of which is empty\"",
   ".",
   "format",
   "(",
   "onset_front",
   ",",
   "offset_front",
   ",",
   "onset_front_overlap",
   ",",
   "offset_front_overlap",
   ")",
   "assert",
   "onset_front_overlap",
   ",",
   "msg",
   "assert",
   "offset_front_overlap",
   ",",
   "msg",
   "onset_front",
   "=",
   "onset_front_overlap",
   "offset_front",
   "=",
   "offset_front_overlap",
   "# Figure out which frequencies will go in the segment",
   "flow_on",
   ",",
   "_slow_on",
   "=",
   "onset_front",
   "[",
   "0",
   "]",
   "fhigh_on",
   ",",
   "_shigh_on",
   "=",
   "onset_front",
   "[",
   "-",
   "1",
   "]",
   "flow_off",
   ",",
   "_slow_off",
   "=",
   "offset_front",
   "[",
   "0",
   "]",
   "fhigh_off",
   ",",
   "_shigh_off",
   "=",
   "offset_front",
   "[",
   "-",
   "1",
   "]",
   "flow",
   "=",
   "<mask>",
   "(",
   "flow_on",
   ",",
   "flow_off",
   ")",
   "fhigh",
   "=",
   "min",
   "(",
   "fhigh_on",
   ",",
   "fhigh_off",
   ")",
   "# Update all the masks with the segment",
   "for",
   "fidx",
   ",",
   "_freqchan",
   "in",
   "enumerate",
   "(",
   "segmentation_mask",
   "[",
   "flow",
   ":",
   "fhigh",
   "+",
   "1",
   ",",
   ":",
   "]",
   ",",
   "start",
   "=",
   "flow",
   ")",
   ":",
   "assert",
   "fidx",
   ">=",
   "flow",
   ",",
   "\"Frequency index is {}, but we should have started at {}\"",
   ".",
   "format",
   "(",
   "fidx",
   ",",
   "flow",
   ")",
   "assert",
   "(",
   "fidx",
   "-",
   "flow",
   ")",
   "<",
   "len",
   "(",
   "onset_front",
   ")",
   ",",
   "\"Frequency index {} minus starting frequency {} is too large for nfrequencies {} in onset front {}\"",
   ".",
   "format",
   "(",
   "fidx",
   ",",
   "flow",
   ",",
   "len",
   "(",
   "onset_front",
   ")",
   ",",
   "onset_front",
   ")",
   "assert",
   "(",
   "fidx",
   "-",
   "flow",
   ")",
   "<",
   "len",
   "(",
   "offset_front",
   ")",
   ",",
   "\"Frequency index {} minus starting frequency {} is too large for nfrequencies {} in offset front {}\"",
   ".",
   "format",
   "(",
   "fidx",
   ",",
   "flow",
   ",",
   "len",
   "(",
   "offset_front",
   ")",
   ",",
   "offset_front",
   ")",
   "_",
   ",",
   "beg",
   "=",
   "onset_front",
   "[",
   "fidx",
   "-",
   "flow",
   "]",
   "_",
   ",",
   "end",
   "=",
   "offset_front",
   "[",
   "fidx",
   "-",
   "flow",
   "]",
   "if",
   "beg",
   ">",
   "end",
   ":",
   "end",
   ",",
   "beg",
   "=",
   "beg",
   ",",
   "end",
   "assert",
   "end",
   ">=",
   "beg",
   "segmentation_mask",
   "[",
   "fidx",
   ",",
   "beg",
   ":",
   "end",
   "+",
   "1",
   "]",
   "=",
   "onset_front_id",
   "onset_fronts",
   "[",
   "fidx",
   ",",
   "(",
   "beg",
   "+",
   "1",
   ")",
   ":",
   "(",
   "end",
   "+",
   "1",
   ")",
   "]",
   "=",
   "0",
   "offset_fronts",
   "[",
   "fidx",
   ",",
   "(",
   "beg",
   "+",
   "1",
   ")",
   ":",
   "(",
   "end",
   "+",
   "1",
   ")",
   "]",
   "=",
   "0",
   "nfreqs_used_in_onset_front",
   "=",
   "(",
   "fidx",
   "-",
   "flow",
   ")",
   "+",
   "1",
   "# Update the other masks to delete fronts that have been used",
   "indexes",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "flow",
   ",",
   "fhigh",
   "+",
   "1",
   ",",
   "1",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int64",
   ")",
   "onset_front_sample_idxs_across_freqs",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "s",
   "for",
   "_",
   ",",
   "s",
   "in",
   "onset_front",
   "]",
   ")",
   "onset_front_sample_idxs_across_freqs_up_to_break",
   "=",
   "onset_front_sample_idxs_across_freqs",
   "[",
   ":",
   "nfreqs_used_in_onset_front",
   "]",
   "offset_front_sample_idxs_across_freqs",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "s",
   "for",
   "_",
   ",",
   "s",
   "in",
   "offset_front",
   "]",
   ")",
   "offset_front_sample_idxs_across_freqs_up_to_break",
   "=",
   "offset_front_sample_idxs_across_freqs",
   "[",
   ":",
   "nfreqs_used_in_onset_front",
   "]",
   "## Remove the offset front from where we started to where we ended",
   "offset_fronts",
   "[",
   "indexes",
   "[",
   ":",
   "nfreqs_used_in_onset_front",
   "]",
   ",",
   "offset_front_sample_idxs_across_freqs_up_to_break",
   "]",
   "=",
   "0",
   "## Remove the onset front from where we started to where we ended",
   "onset_fronts",
   "[",
   "indexes",
   "[",
   ":",
   "nfreqs_used_in_onset_front",
   "]",
   ",",
   "onset_front_sample_idxs_across_freqs_up_to_break",
   "]",
   "=",
   "0",
   "# Determine if we matched the entire onset front by checking if there is any more of this onset front in onset_fronts",
   "whole_onset_front_matched",
   "=",
   "onset_front_id",
   "not",
   "in",
   "np",
   ".",
   "unique",
   "(",
   "onset_fronts",
   ")",
   "return",
   "whole_onset_front_matched"
  ]
 },
 {
  "idx": "maxmin-1047",
  "nl_tokens": [
   "Convert",
   "flow",
   "map",
   "to",
   "RGB",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "flow2rgb",
   "(",
   "flow",
   ",",
   "color_wheel",
   "=",
   "None",
   ",",
   "unknown_thr",
   "=",
   "1e6",
   ")",
   ":",
   "assert",
   "flow",
   ".",
   "ndim",
   "==",
   "3",
   "and",
   "flow",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   "==",
   "2",
   "if",
   "color_wheel",
   "is",
   "None",
   ":",
   "color_wheel",
   "=",
   "make_color_wheel",
   "(",
   ")",
   "assert",
   "color_wheel",
   ".",
   "ndim",
   "==",
   "2",
   "and",
   "color_wheel",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "==",
   "3",
   "num_bins",
   "=",
   "color_wheel",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "dx",
   "=",
   "flow",
   "[",
   ":",
   ",",
   ":",
   ",",
   "0",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "dy",
   "=",
   "flow",
   "[",
   ":",
   ",",
   ":",
   ",",
   "1",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "ignore_inds",
   "=",
   "(",
   "np",
   ".",
   "isnan",
   "(",
   "dx",
   ")",
   "|",
   "np",
   ".",
   "isnan",
   "(",
   "dy",
   ")",
   "|",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "dx",
   ")",
   ">",
   "unknown_thr",
   ")",
   "|",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "dy",
   ")",
   ">",
   "unknown_thr",
   ")",
   ")",
   "dx",
   "[",
   "ignore_inds",
   "]",
   "=",
   "0",
   "dy",
   "[",
   "ignore_inds",
   "]",
   "=",
   "0",
   "rad",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "dx",
   "**",
   "2",
   "+",
   "dy",
   "**",
   "2",
   ")",
   "if",
   "np",
   ".",
   "any",
   "(",
   "rad",
   ">",
   "np",
   ".",
   "finfo",
   "(",
   "float",
   ")",
   ".",
   "eps",
   ")",
   ":",
   "max_rad",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "rad",
   ")",
   "dx",
   "/=",
   "max_rad",
   "dy",
   "/=",
   "max_rad",
   "[",
   "h",
   ",",
   "w",
   "]",
   "=",
   "dx",
   ".",
   "shape",
   "rad",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "dx",
   "**",
   "2",
   "+",
   "dy",
   "**",
   "2",
   ")",
   "angle",
   "=",
   "np",
   ".",
   "arctan2",
   "(",
   "-",
   "dy",
   ",",
   "-",
   "dx",
   ")",
   "/",
   "np",
   ".",
   "pi",
   "bin_real",
   "=",
   "(",
   "angle",
   "+",
   "1",
   ")",
   "/",
   "2",
   "*",
   "(",
   "num_bins",
   "-",
   "1",
   ")",
   "bin_left",
   "=",
   "np",
   ".",
   "floor",
   "(",
   "bin_real",
   ")",
   ".",
   "astype",
   "(",
   "int",
   ")",
   "bin_right",
   "=",
   "(",
   "bin_left",
   "+",
   "1",
   ")",
   "%",
   "num_bins",
   "w",
   "=",
   "(",
   "bin_real",
   "-",
   "bin_left",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "float32",
   ")",
   ")",
   "[",
   "...",
   ",",
   "None",
   "]",
   "flow_img",
   "=",
   "(",
   "1",
   "-",
   "w",
   ")",
   "*",
   "color_wheel",
   "[",
   "bin_left",
   ",",
   ":",
   "]",
   "+",
   "w",
   "*",
   "color_wheel",
   "[",
   "bin_right",
   ",",
   ":",
   "]",
   "small_ind",
   "=",
   "rad",
   "<=",
   "1",
   "flow_img",
   "[",
   "small_ind",
   "]",
   "=",
   "1",
   "-",
   "rad",
   "[",
   "small_ind",
   ",",
   "None",
   "]",
   "*",
   "(",
   "1",
   "-",
   "flow_img",
   "[",
   "small_ind",
   "]",
   ")",
   "flow_img",
   "[",
   "np",
   ".",
   "logical_not",
   "(",
   "small_ind",
   ")",
   "]",
   "*=",
   "0.75",
   "flow_img",
   "[",
   "ignore_inds",
   ",",
   ":",
   "]",
   "=",
   "0",
   "return",
   "flow_img"
  ]
 },
 {
  "idx": "maxmin-1048",
  "nl_tokens": [
   "Select",
   "a",
   "n",
   "-",
   "dimensional",
   "rectangular",
   "box",
   "bounded",
   "by",
   "limits",
   "."
  ],
  "pl_tokens": [
   "def",
   "select_box",
   "(",
   "self",
   ",",
   "spaces",
   ",",
   "limits",
   ",",
   "mode",
   "=",
   "\"replace\"",
   ",",
   "name",
   "=",
   "\"default\"",
   ")",
   ":",
   "sorted_limits",
   "=",
   "[",
   "(",
   "<mask>",
   "(",
   "l",
   ")",
   ",",
   "max",
   "(",
   "l",
   ")",
   ")",
   "for",
   "l",
   "in",
   "limits",
   "]",
   "expressions",
   "=",
   "[",
   "\"((%s) >= %f) & ((%s) <= %f)\"",
   "%",
   "(",
   "expression",
   ",",
   "lmin",
   ",",
   "expression",
   ",",
   "lmax",
   ")",
   "for",
   "(",
   "expression",
   ",",
   "(",
   "lmin",
   ",",
   "lmax",
   ")",
   ")",
   "in",
   "zip",
   "(",
   "spaces",
   ",",
   "sorted_limits",
   ")",
   "]",
   "self",
   ".",
   "select",
   "(",
   "\"&\"",
   ".",
   "join",
   "(",
   "expressions",
   ")",
   ",",
   "mode",
   "=",
   "mode",
   ",",
   "name",
   "=",
   "name",
   ")"
  ]
 },
 {
  "idx": "maxmin-1049",
  "nl_tokens": [
   "Send",
   "information",
   "about",
   "a",
   "single",
   "metric",
   "data",
   "point",
   "that",
   "was",
   "captured",
   "for",
   "the",
   "application",
   ".",
   ":",
   "param",
   "name",
   ":",
   "The",
   "name",
   "of",
   "the",
   "metric",
   "that",
   "was",
   "captured",
   ".",
   ":",
   "param",
   "value",
   ":",
   "The",
   "value",
   "of",
   "the",
   "metric",
   "that",
   "was",
   "captured",
   ".",
   ":",
   "param",
   "type",
   ":",
   "The",
   "type",
   "of",
   "the",
   "metric",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "TelemetryDataPointType",
   ".",
   "aggregation",
   ")",
   ":",
   "param",
   "count",
   ":",
   "the",
   "number",
   "of",
   "metrics",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "min",
   ":",
   "the",
   "minimum",
   "of",
   "all",
   "metrics",
   "collected",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "max",
   ":",
   "the",
   "maximum",
   "of",
   "all",
   "metrics",
   "collected",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "std_dev",
   ":",
   "the",
   "standard",
   "deviation",
   "of",
   "all",
   "metrics",
   "collected",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "properties",
   ":",
   "the",
   "set",
   "of",
   "custom",
   "properties",
   "the",
   "client",
   "wants",
   "attached",
   "to",
   "this",
   "data",
   "item",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")"
  ],
  "pl_tokens": [
   "def",
   "track_metric",
   "(",
   "self",
   ",",
   "name",
   ":",
   "str",
   ",",
   "value",
   ":",
   "float",
   ",",
   "type",
   ":",
   "TelemetryDataPointType",
   "=",
   "None",
   ",",
   "count",
   ":",
   "int",
   "=",
   "None",
   ",",
   "<mask>",
   ":",
   "float",
   "=",
   "None",
   ",",
   "max",
   ":",
   "float",
   "=",
   "None",
   ",",
   "std_dev",
   ":",
   "float",
   "=",
   "None",
   ",",
   "properties",
   ":",
   "Dict",
   "[",
   "str",
   ",",
   "object",
   "]",
   "=",
   "None",
   ")",
   "->",
   "NotImplemented",
   ":",
   "raise",
   "NotImplementedError",
   "(",
   "'BotTelemetryClient.track_metric(): is not implemented.'",
   ")"
  ]
 },
 {
  "idx": "maxmin-1050",
  "nl_tokens": [
   "Extract",
   "a",
   "single",
   "batch",
   "of",
   "data",
   "to",
   "pass",
   "to",
   "the",
   "model",
   "being",
   "trained",
   "."
  ],
  "pl_tokens": [
   "def",
   "batch_at",
   "(",
   "features",
   ",",
   "labels",
   ",",
   "seq_begins",
   ",",
   "seq_lengths",
   ")",
   ":",
   "length",
   "=",
   "seq_lengths",
   ".",
   "<mask>",
   "(",
   ")",
   "feat",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "BATCH_SIZE",
   ",",
   "length",
   ",",
   "features",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ")",
   ",",
   "'f'",
   ")",
   "labl",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "BATCH_SIZE",
   ",",
   "length",
   ")",
   ",",
   "'i'",
   ")",
   "mask",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "BATCH_SIZE",
   ",",
   "length",
   ")",
   ",",
   "'f'",
   ")",
   "for",
   "b",
   ",",
   "(",
   "begin",
   ",",
   "length",
   ")",
   "in",
   "enumerate",
   "(",
   "zip",
   "(",
   "seq_begins",
   ",",
   "seq_lengths",
   ")",
   ")",
   ":",
   "feat",
   "[",
   "b",
   ",",
   ":",
   "length",
   "]",
   "=",
   "features",
   "[",
   "begin",
   ":",
   "begin",
   "+",
   "length",
   "]",
   "labl",
   "[",
   "b",
   ",",
   ":",
   "length",
   "]",
   "=",
   "labels",
   "[",
   "begin",
   ":",
   "begin",
   "+",
   "length",
   "]",
   "mask",
   "[",
   "b",
   ",",
   ":",
   "length",
   "]",
   "=",
   "1",
   "return",
   "[",
   "feat",
   ",",
   "labl",
   ",",
   "mask",
   "]"
  ]
 },
 {
  "idx": "maxmin-1051",
  "nl_tokens": [
   "A",
   "text",
   "-",
   "based",
   "job",
   "status",
   "checker"
  ],
  "pl_tokens": [
   "def",
   "_text_checker",
   "(",
   "job",
   ",",
   "interval",
   ",",
   "_interval_set",
   "=",
   "False",
   ",",
   "quiet",
   "=",
   "False",
   ",",
   "output",
   "=",
   "sys",
   ".",
   "stdout",
   ")",
   ":",
   "status",
   "=",
   "job",
   ".",
   "status",
   "(",
   ")",
   "msg",
   "=",
   "status",
   ".",
   "value",
   "prev_msg",
   "=",
   "msg",
   "msg_len",
   "=",
   "len",
   "(",
   "msg",
   ")",
   "if",
   "not",
   "quiet",
   ":",
   "print",
   "(",
   "'\\r%s: %s'",
   "%",
   "(",
   "'Job Status'",
   ",",
   "msg",
   ")",
   ",",
   "end",
   "=",
   "''",
   ",",
   "file",
   "=",
   "output",
   ")",
   "while",
   "status",
   ".",
   "name",
   "not",
   "in",
   "[",
   "'DONE'",
   ",",
   "'CANCELLED'",
   ",",
   "'ERROR'",
   "]",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "interval",
   ")",
   "status",
   "=",
   "job",
   ".",
   "status",
   "(",
   ")",
   "msg",
   "=",
   "status",
   ".",
   "value",
   "if",
   "status",
   ".",
   "name",
   "==",
   "'QUEUED'",
   ":",
   "msg",
   "+=",
   "' (%s)'",
   "%",
   "job",
   ".",
   "queue_position",
   "(",
   ")",
   "if",
   "not",
   "_interval_set",
   ":",
   "interval",
   "=",
   "<mask>",
   "(",
   "job",
   ".",
   "queue_position",
   "(",
   ")",
   ",",
   "2",
   ")",
   "else",
   ":",
   "if",
   "not",
   "_interval_set",
   ":",
   "interval",
   "=",
   "2",
   "# Adjust length of message so there are no artifacts",
   "if",
   "len",
   "(",
   "msg",
   ")",
   "<",
   "msg_len",
   ":",
   "msg",
   "+=",
   "' '",
   "*",
   "(",
   "msg_len",
   "-",
   "len",
   "(",
   "msg",
   ")",
   ")",
   "elif",
   "len",
   "(",
   "msg",
   ")",
   ">",
   "msg_len",
   ":",
   "msg_len",
   "=",
   "len",
   "(",
   "msg",
   ")",
   "if",
   "msg",
   "!=",
   "prev_msg",
   "and",
   "not",
   "quiet",
   ":",
   "print",
   "(",
   "'\\r%s: %s'",
   "%",
   "(",
   "'Job Status'",
   ",",
   "msg",
   ")",
   ",",
   "end",
   "=",
   "''",
   ",",
   "file",
   "=",
   "output",
   ")",
   "prev_msg",
   "=",
   "msg",
   "if",
   "not",
   "quiet",
   ":",
   "print",
   "(",
   "''",
   ",",
   "file",
   "=",
   "output",
   ")"
  ]
 },
 {
  "idx": "maxmin-1052",
  "nl_tokens": [
   "Returns",
   "the",
   "length",
   "of",
   "the",
   "element",
   "including",
   "the",
   "box",
   "around",
   "."
  ],
  "pl_tokens": [
   "def",
   "length",
   "(",
   "self",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "len",
   "(",
   "self",
   ".",
   "top",
   ")",
   ",",
   "len",
   "(",
   "self",
   ".",
   "mid",
   ")",
   ",",
   "len",
   "(",
   "self",
   ".",
   "bot",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1053",
  "nl_tokens": [
   "Calculates",
   "Exact",
   "Match",
   "score",
   "between",
   "y_true",
   "and",
   "y_predicted",
   "EM",
   "score",
   "uses",
   "the",
   "best",
   "matching",
   "y_true",
   "answer",
   ":",
   "if",
   "y_pred",
   "equal",
   "at",
   "least",
   "to",
   "one",
   "answer",
   "in",
   "y_true",
   "then",
   "EM",
   "=",
   "1",
   "else",
   "EM",
   "=",
   "0",
   "Skips",
   "examples",
   "without",
   "an",
   "answer",
   ".",
   "Args",
   ":",
   "y_true",
   ":",
   "list",
   "of",
   "correct",
   "answers",
   "(",
   "correct",
   "answers",
   "are",
   "represented",
   "by",
   "list",
   "of",
   "strings",
   ")",
   "y_predicted",
   ":",
   "list",
   "of",
   "predicted",
   "answers",
   "Returns",
   ":",
   "exact",
   "match",
   "score",
   ":",
   "float"
  ],
  "pl_tokens": [
   "def",
   "squad_v1_exact_match",
   "(",
   "y_true",
   ":",
   "List",
   "[",
   "List",
   "[",
   "str",
   "]",
   "]",
   ",",
   "y_predicted",
   ":",
   "List",
   "[",
   "str",
   "]",
   ")",
   "->",
   "float",
   ":",
   "EM_total",
   "=",
   "0",
   "count",
   "=",
   "0",
   "for",
   "ground_truth",
   ",",
   "prediction",
   "in",
   "zip",
   "(",
   "y_true",
   ",",
   "y_predicted",
   ")",
   ":",
   "if",
   "len",
   "(",
   "ground_truth",
   "[",
   "0",
   "]",
   ")",
   "==",
   "0",
   ":",
   "# skip empty answers",
   "continue",
   "count",
   "+=",
   "1",
   "EMs",
   "=",
   "[",
   "int",
   "(",
   "normalize_answer",
   "(",
   "gt",
   ")",
   "==",
   "normalize_answer",
   "(",
   "prediction",
   ")",
   ")",
   "for",
   "gt",
   "in",
   "ground_truth",
   "]",
   "EM_total",
   "+=",
   "<mask>",
   "(",
   "EMs",
   ")",
   "return",
   "100",
   "*",
   "EM_total",
   "/",
   "count",
   "if",
   "count",
   ">",
   "0",
   "else",
   "0"
  ]
 },
 {
  "idx": "maxmin-1054",
  "nl_tokens": [
   "Give",
   "the",
   "annotation",
   "before",
   "a",
   "given",
   "time",
   ".",
   "When",
   "the",
   "tier",
   "contains",
   "reference",
   "annotations",
   "this",
   "will",
   "be",
   "returned",
   "check",
   ":",
   "func",
   ":",
   "get_ref_annotation_data_before_time",
   "for",
   "the",
   "format",
   ".",
   "If",
   "an",
   "annotation",
   "overlaps",
   "with",
   "time",
   "that",
   "annotation",
   "will",
   "be",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_annotation_data_before_time",
   "(",
   "self",
   ",",
   "id_tier",
   ",",
   "time",
   ")",
   ":",
   "if",
   "self",
   ".",
   "tiers",
   "[",
   "id_tier",
   "]",
   "[",
   "1",
   "]",
   ":",
   "return",
   "self",
   ".",
   "get_ref_annotation_before_time",
   "(",
   "id_tier",
   ",",
   "time",
   ")",
   "befores",
   "=",
   "self",
   ".",
   "get_annotation_data_between_times",
   "(",
   "id_tier",
   ",",
   "0",
   ",",
   "time",
   ")",
   "if",
   "befores",
   ":",
   "return",
   "[",
   "<mask>",
   "(",
   "befores",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   "]",
   "else",
   ":",
   "return",
   "[",
   "]"
  ]
 },
 {
  "idx": "maxmin-1055",
  "nl_tokens": [
   "Initialization",
   "done",
   "before",
   "entering",
   "the",
   "debugger",
   "-",
   "command",
   "loop",
   ".",
   "In",
   "particular",
   "we",
   "set",
   "up",
   "the",
   "call",
   "stack",
   "used",
   "for",
   "local",
   "variable",
   "lookup",
   "and",
   "frame",
   "/",
   "up",
   "/",
   "down",
   "commands",
   "."
  ],
  "pl_tokens": [
   "def",
   "setup",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "forget",
   "(",
   ")",
   "if",
   "self",
   ".",
   "settings",
   "(",
   "'dbg_trepan'",
   ")",
   ":",
   "self",
   ".",
   "frame",
   "=",
   "inspect",
   ".",
   "currentframe",
   "(",
   ")",
   "pass",
   "if",
   "self",
   ".",
   "event",
   "in",
   "[",
   "'exception'",
   ",",
   "'c_exception'",
   "]",
   ":",
   "exc_type",
   ",",
   "exc_value",
   ",",
   "exc_traceback",
   "=",
   "self",
   ".",
   "event_arg",
   "else",
   ":",
   "_",
   ",",
   "_",
   ",",
   "exc_traceback",
   "=",
   "(",
   "None",
   ",",
   "None",
   ",",
   "None",
   ",",
   ")",
   "# NOQA",
   "pass",
   "if",
   "self",
   ".",
   "frame",
   "or",
   "exc_traceback",
   ":",
   "self",
   ".",
   "stack",
   ",",
   "self",
   ".",
   "curindex",
   "=",
   "get_stack",
   "(",
   "self",
   ".",
   "frame",
   ",",
   "exc_traceback",
   ",",
   "None",
   ",",
   "self",
   ")",
   "self",
   ".",
   "curframe",
   "=",
   "self",
   ".",
   "stack",
   "[",
   "self",
   ".",
   "curindex",
   "]",
   "[",
   "0",
   "]",
   "self",
   ".",
   "thread_name",
   "=",
   "Mthread",
   ".",
   "current_thread_name",
   "(",
   ")",
   "if",
   "exc_traceback",
   ":",
   "self",
   ".",
   "list_lineno",
   "=",
   "traceback",
   ".",
   "extract_tb",
   "(",
   "exc_traceback",
   ",",
   "1",
   ")",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "self",
   ".",
   "list_offset",
   "=",
   "self",
   ".",
   "curframe",
   ".",
   "f_lasti",
   "self",
   ".",
   "list_object",
   "=",
   "self",
   ".",
   "curframe",
   "else",
   ":",
   "self",
   ".",
   "stack",
   "=",
   "self",
   ".",
   "curframe",
   "=",
   "self",
   ".",
   "botframe",
   "=",
   "None",
   "pass",
   "if",
   "self",
   ".",
   "curframe",
   ":",
   "self",
   ".",
   "list_lineno",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "inspect",
   ".",
   "getlineno",
   "(",
   "self",
   ".",
   "curframe",
   ")",
   "-",
   "int",
   "(",
   "self",
   ".",
   "settings",
   "(",
   "'listsize'",
   ")",
   "/",
   "2",
   ")",
   ")",
   "-",
   "1",
   "self",
   ".",
   "list_offset",
   "=",
   "self",
   ".",
   "curframe",
   ".",
   "f_lasti",
   "self",
   ".",
   "list_filename",
   "=",
   "self",
   ".",
   "curframe",
   ".",
   "f_code",
   ".",
   "co_filename",
   "self",
   ".",
   "list_object",
   "=",
   "self",
   ".",
   "curframe",
   "else",
   ":",
   "if",
   "not",
   "exc_traceback",
   ":",
   "self",
   ".",
   "list_lineno",
   "=",
   "None",
   "pass",
   "# if self.execRcLines()==1: return True",
   "# FIXME:  do we want to save self.list_lineno a second place",
   "# so that we can do 'list .' and go back to the first place we listed?",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-1056",
  "nl_tokens": [
   "Gets",
   "value",
   "of",
   "bits",
   "between",
   "selected",
   "range",
   "from",
   "memory"
  ],
  "pl_tokens": [
   "def",
   "getBits_from_array",
   "(",
   "array",
   ",",
   "wordWidth",
   ",",
   "start",
   ",",
   "end",
   ",",
   "reinterpretElmToType",
   "=",
   "None",
   ")",
   ":",
   "inPartOffset",
   "=",
   "0",
   "value",
   "=",
   "Bits",
   "(",
   "end",
   "-",
   "start",
   ",",
   "None",
   ")",
   ".",
   "fromPy",
   "(",
   "None",
   ")",
   "while",
   "start",
   "!=",
   "end",
   ":",
   "assert",
   "start",
   "<",
   "end",
   ",",
   "(",
   "start",
   ",",
   "end",
   ")",
   "dataWordIndex",
   "=",
   "start",
   "//",
   "wordWidth",
   "v",
   "=",
   "array",
   "[",
   "dataWordIndex",
   "]",
   "if",
   "reinterpretElmToType",
   "is",
   "not",
   "None",
   ":",
   "v",
   "=",
   "v",
   ".",
   "_reinterpret_cast",
   "(",
   "reinterpretElmToType",
   ")",
   "endOfWord",
   "=",
   "(",
   "dataWordIndex",
   "+",
   "1",
   ")",
   "*",
   "wordWidth",
   "width",
   "=",
   "<mask>",
   "(",
   "end",
   ",",
   "endOfWord",
   ")",
   "-",
   "start",
   "offset",
   "=",
   "start",
   "%",
   "wordWidth",
   "val",
   "=",
   "selectBitRange",
   "(",
   "v",
   ".",
   "val",
   ",",
   "offset",
   ",",
   "width",
   ")",
   "vldMask",
   "=",
   "selectBitRange",
   "(",
   "v",
   ".",
   "vldMask",
   ",",
   "offset",
   ",",
   "width",
   ")",
   "updateTime",
   "=",
   "v",
   ".",
   "updateTime",
   "m",
   "=",
   "mask",
   "(",
   "width",
   ")",
   "value",
   ".",
   "val",
   "|=",
   "(",
   "val",
   "&",
   "m",
   ")",
   "<<",
   "inPartOffset",
   "value",
   ".",
   "vldMask",
   "|=",
   "(",
   "vldMask",
   "&",
   "m",
   ")",
   "<<",
   "inPartOffset",
   "value",
   ".",
   "updateMask",
   "=",
   "max",
   "(",
   "value",
   ".",
   "updateTime",
   ",",
   "updateTime",
   ")",
   "inPartOffset",
   "+=",
   "width",
   "start",
   "+=",
   "width",
   "return",
   "value"
  ]
 },
 {
  "idx": "maxmin-1057",
  "nl_tokens": [
   "Resize",
   "image",
   "according",
   "to",
   "size",
   ".",
   "image",
   ":",
   "a",
   "Pillow",
   "image",
   "instance",
   "size",
   ":",
   "a",
   "list",
   "of",
   "two",
   "integers",
   "[",
   "width",
   "height",
   "]"
  ],
  "pl_tokens": [
   "def",
   "resize_cover",
   "(",
   "image",
   ",",
   "size",
   ",",
   "resample",
   "=",
   "Image",
   ".",
   "LANCZOS",
   ")",
   ":",
   "img_format",
   "=",
   "image",
   ".",
   "format",
   "img",
   "=",
   "image",
   ".",
   "copy",
   "(",
   ")",
   "img_size",
   "=",
   "img",
   ".",
   "size",
   "ratio",
   "=",
   "<mask>",
   "(",
   "size",
   "[",
   "0",
   "]",
   "/",
   "img_size",
   "[",
   "0",
   "]",
   ",",
   "size",
   "[",
   "1",
   "]",
   "/",
   "img_size",
   "[",
   "1",
   "]",
   ")",
   "new_size",
   "=",
   "[",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "img_size",
   "[",
   "0",
   "]",
   "*",
   "ratio",
   ")",
   ")",
   ",",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "img_size",
   "[",
   "1",
   "]",
   "*",
   "ratio",
   ")",
   ")",
   "]",
   "img",
   "=",
   "img",
   ".",
   "resize",
   "(",
   "(",
   "new_size",
   "[",
   "0",
   "]",
   ",",
   "new_size",
   "[",
   "1",
   "]",
   ")",
   ",",
   "resample",
   ")",
   "img",
   "=",
   "resize_crop",
   "(",
   "img",
   ",",
   "size",
   ")",
   "img",
   ".",
   "format",
   "=",
   "img_format",
   "return",
   "img"
  ]
 },
 {
  "idx": "maxmin-1058",
  "nl_tokens": [
   "Give",
   "the",
   "annotation",
   "before",
   "a",
   "given",
   "time",
   ".",
   "When",
   "the",
   "tier",
   "contains",
   "reference",
   "annotations",
   "this",
   "will",
   "be",
   "returned",
   "check",
   ":",
   "func",
   ":",
   "get_ref_annotation_data_before_time",
   "for",
   "the",
   "format",
   ".",
   "If",
   "an",
   "annotation",
   "overlaps",
   "with",
   "time",
   "that",
   "annotation",
   "will",
   "be",
   "returned",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_annotation_data_after_time",
   "(",
   "self",
   ",",
   "id_tier",
   ",",
   "time",
   ")",
   ":",
   "if",
   "self",
   ".",
   "tiers",
   "[",
   "id_tier",
   "]",
   "[",
   "1",
   "]",
   ":",
   "return",
   "self",
   ".",
   "get_ref_annotation_after_time",
   "(",
   "id_tier",
   ",",
   "time",
   ")",
   "befores",
   "=",
   "self",
   ".",
   "get_annotation_data_between_times",
   "(",
   "id_tier",
   ",",
   "time",
   ",",
   "self",
   ".",
   "get_full_time_interval",
   "(",
   ")",
   "[",
   "1",
   "]",
   ")",
   "if",
   "befores",
   ":",
   "return",
   "[",
   "<mask>",
   "(",
   "befores",
   ",",
   "key",
   "=",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   "]",
   "else",
   ":",
   "return",
   "[",
   "]"
  ]
 },
 {
  "idx": "maxmin-1059",
  "nl_tokens": [
   "Return",
   "the",
   "first",
   "rows",
   "and",
   "cols",
   "of",
   "the",
   "frame",
   "as",
   "a",
   "new",
   "H2OFrame",
   "."
  ],
  "pl_tokens": [
   "def",
   "head",
   "(",
   "self",
   ",",
   "rows",
   "=",
   "10",
   ",",
   "cols",
   "=",
   "200",
   ")",
   ":",
   "assert_is_type",
   "(",
   "rows",
   ",",
   "int",
   ")",
   "assert_is_type",
   "(",
   "cols",
   ",",
   "int",
   ")",
   "nrows",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "nrows",
   ",",
   "rows",
   ")",
   "ncols",
   "=",
   "min",
   "(",
   "self",
   ".",
   "ncols",
   ",",
   "cols",
   ")",
   "newdt",
   "=",
   "self",
   "[",
   ":",
   "nrows",
   ",",
   ":",
   "ncols",
   "]",
   "return",
   "newdt",
   ".",
   "_frame",
   "(",
   "rows",
   "=",
   "nrows",
   ",",
   "cols",
   "=",
   "cols",
   ",",
   "fill_cache",
   "=",
   "True",
   ")"
  ]
 },
 {
  "idx": "maxmin-1060",
  "nl_tokens": [
   "Parses",
   "the",
   "label",
   "drawing",
   "directive",
   "updating",
   "the",
   "label",
   "components",
   "."
  ],
  "pl_tokens": [
   "def",
   "parse_xdot_label_directive",
   "(",
   "self",
   ",",
   "new",
   ")",
   ":",
   "components",
   "=",
   "XdotAttrParser",
   "(",
   ")",
   ".",
   "parse_xdot_data",
   "(",
   "new",
   ")",
   "pos_x",
   "=",
   "<mask>",
   "(",
   "[",
   "c",
   ".",
   "x",
   "for",
   "c",
   "in",
   "components",
   "]",
   ")",
   "pos_y",
   "=",
   "min",
   "(",
   "[",
   "c",
   ".",
   "y",
   "for",
   "c",
   "in",
   "components",
   "]",
   ")",
   "move_to_origin",
   "(",
   "components",
   ")",
   "container",
   "=",
   "Container",
   "(",
   "auto_size",
   "=",
   "True",
   ",",
   "position",
   "=",
   "[",
   "pos_x",
   "-",
   "self",
   ".",
   "pos",
   "[",
   "0",
   "]",
   ",",
   "pos_y",
   "-",
   "self",
   ".",
   "pos",
   "[",
   "1",
   "]",
   "]",
   ",",
   "bgcolor",
   "=",
   "\"red\"",
   ")",
   "container",
   ".",
   "add",
   "(",
   "*",
   "components",
   ")",
   "self",
   ".",
   "label_drawing",
   "=",
   "container"
  ]
 },
 {
  "idx": "maxmin-1061",
  "nl_tokens": [
   "Calculate",
   "the",
   "maximum",
   "parallax",
   "error",
   "from",
   "G",
   "and",
   "(",
   "V",
   "-",
   "I",
   ")",
   ".",
   "This",
   "correspond",
   "to",
   "the",
   "sky",
   "regions",
   "with",
   "the",
   "largest",
   "astrometric",
   "errors",
   ".",
   "At",
   "the",
   "bright",
   "end",
   "the",
   "parallax",
   "error",
   "is",
   "at",
   "least",
   "14",
   "muas",
   "due",
   "to",
   "the",
   "gating",
   "scheme",
   "."
  ],
  "pl_tokens": [
   "def",
   "parallaxMaxError",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "0.0",
   ")",
   ":",
   "errors",
   "=",
   "_astrometricErrorFactors",
   "[",
   "\"parallax\"",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "parallaxErrorSkyAvg",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "extension",
   ")",
   "indices",
   "=",
   "(",
   "errors",
   "<",
   "_parallaxErrorMaxBright",
   ")",
   "errors",
   "[",
   "indices",
   "]",
   "=",
   "_parallaxErrorMaxBright",
   "return",
   "errors"
  ]
 },
 {
  "idx": "maxmin-1062",
  "nl_tokens": [
   "Return",
   "the",
   "maximum",
   "of",
   "the",
   "array",
   "over",
   "the",
   "given",
   "axis",
   "."
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "axis",
   "=",
   "None",
   ",",
   "keepdims",
   "=",
   "False",
   ")",
   ":",
   "from",
   "numpy",
   "import",
   "maximum",
   "return",
   "self",
   ".",
   "_stat",
   "(",
   "axis",
   ",",
   "func",
   "=",
   "maximum",
   ",",
   "keepdims",
   "=",
   "keepdims",
   ")"
  ]
 },
 {
  "idx": "maxmin-1063",
  "nl_tokens": [
   "Decorator",
   "for",
   "expanding",
   "an",
   "operation",
   "across",
   "a",
   "whole",
   "register",
   "or",
   "register",
   "subset",
   ".",
   "Args",
   ":",
   "n_bits",
   "(",
   "int",
   ")",
   ":",
   "the",
   "number",
   "of",
   "register",
   "bit",
   "arguments",
   "the",
   "decorated",
   "function",
   "takes",
   "func",
   "(",
   "function",
   ")",
   ":",
   "used",
   "for",
   "decorators",
   "with",
   "keyword",
   "args",
   "broadcastable",
   "(",
   "list",
   "(",
   "bool",
   "))",
   ":",
   "list",
   "of",
   "bool",
   "for",
   "which",
   "register",
   "args",
   "can",
   "be",
   "broadcast",
   "from",
   "1",
   "bit",
   "to",
   "the",
   "max",
   "size",
   "of",
   "the",
   "rest",
   "of",
   "the",
   "args",
   ".",
   "Defaults",
   "to",
   "all",
   "True",
   "if",
   "not",
   "specified",
   "."
  ],
  "pl_tokens": [
   "def",
   "_op_expand",
   "(",
   "n_bits",
   ",",
   "func",
   "=",
   "None",
   ",",
   "broadcastable",
   "=",
   "None",
   ")",
   ":",
   "if",
   "func",
   "is",
   "None",
   ":",
   "return",
   "functools",
   ".",
   "partial",
   "(",
   "_op_expand",
   ",",
   "n_bits",
   ",",
   "broadcastable",
   "=",
   "broadcastable",
   ")",
   "@",
   "functools",
   ".",
   "wraps",
   "(",
   "func",
   ")",
   "def",
   "wrapper",
   "(",
   "self",
   ",",
   "*",
   "args",
   ")",
   ":",
   "params",
   "=",
   "args",
   "[",
   "0",
   ":",
   "-",
   "n_bits",
   "]",
   "if",
   "len",
   "(",
   "args",
   ")",
   ">",
   "n_bits",
   "else",
   "tuple",
   "(",
   ")",
   "rargs",
   "=",
   "args",
   "[",
   "-",
   "n_bits",
   ":",
   "]",
   "if",
   "broadcastable",
   "is",
   "None",
   ":",
   "blist",
   "=",
   "[",
   "True",
   "]",
   "*",
   "len",
   "(",
   "rargs",
   ")",
   "else",
   ":",
   "blist",
   "=",
   "broadcastable",
   "if",
   "not",
   "all",
   "(",
   "[",
   "_is_bit",
   "(",
   "arg",
   ")",
   "for",
   "arg",
   "in",
   "rargs",
   "]",
   ")",
   ":",
   "rarg_size",
   "=",
   "[",
   "1",
   "]",
   "*",
   "n_bits",
   "for",
   "iarg",
   ",",
   "arg",
   "in",
   "enumerate",
   "(",
   "rargs",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "arg",
   ",",
   "Register",
   ")",
   ":",
   "rarg_size",
   "[",
   "iarg",
   "]",
   "=",
   "len",
   "(",
   "arg",
   ")",
   "elif",
   "isinstance",
   "(",
   "arg",
   ",",
   "list",
   ")",
   "and",
   "all",
   "(",
   "[",
   "_is_bit",
   "(",
   "bit",
   ")",
   "for",
   "bit",
   "in",
   "arg",
   "]",
   ")",
   ":",
   "rarg_size",
   "[",
   "iarg",
   "]",
   "=",
   "len",
   "(",
   "arg",
   ")",
   "elif",
   "_is_bit",
   "(",
   "arg",
   ")",
   ":",
   "rarg_size",
   "[",
   "iarg",
   "]",
   "=",
   "1",
   "else",
   ":",
   "raise",
   "QiskitError",
   "(",
   "'operation arguments must be qubits/cbits'",
   ")",
   "broadcast_size",
   "=",
   "<mask>",
   "(",
   "rarg_size",
   ")",
   "expanded_rargs",
   "=",
   "[",
   "]",
   "for",
   "arg",
   ",",
   "broadcast",
   "in",
   "zip",
   "(",
   "rargs",
   ",",
   "blist",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "arg",
   ",",
   "Register",
   ")",
   ":",
   "arg",
   "=",
   "[",
   "(",
   "arg",
   ",",
   "i",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "arg",
   ")",
   ")",
   "]",
   "elif",
   "isinstance",
   "(",
   "arg",
   ",",
   "tuple",
   ")",
   ":",
   "arg",
   "=",
   "[",
   "arg",
   "]",
   "# now we should have a list of qubits",
   "if",
   "isinstance",
   "(",
   "arg",
   ",",
   "list",
   ")",
   "and",
   "len",
   "(",
   "arg",
   ")",
   "==",
   "1",
   "and",
   "broadcast",
   ":",
   "arg",
   "=",
   "arg",
   "*",
   "broadcast_size",
   "if",
   "len",
   "(",
   "arg",
   ")",
   "!=",
   "broadcast_size",
   ":",
   "raise",
   "QiskitError",
   "(",
   "'register size error'",
   ")",
   "expanded_rargs",
   ".",
   "append",
   "(",
   "arg",
   ")",
   "rargs",
   "=",
   "expanded_rargs",
   "if",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "arg",
   ",",
   "list",
   ")",
   "for",
   "arg",
   "in",
   "rargs",
   "]",
   ")",
   ":",
   "if",
   "all",
   "(",
   "rargs",
   ")",
   ":",
   "instructions",
   "=",
   "InstructionSet",
   "(",
   ")",
   "for",
   "irargs",
   "in",
   "zip",
   "(",
   "*",
   "rargs",
   ")",
   ":",
   "instructions",
   ".",
   "add",
   "(",
   "func",
   "(",
   "self",
   ",",
   "*",
   "params",
   ",",
   "*",
   "irargs",
   ")",
   ",",
   "[",
   "i",
   "for",
   "i",
   "in",
   "irargs",
   "if",
   "isinstance",
   "(",
   "i",
   "[",
   "0",
   "]",
   ",",
   "QuantumRegister",
   ")",
   "]",
   ",",
   "[",
   "i",
   "for",
   "i",
   "in",
   "irargs",
   "if",
   "isinstance",
   "(",
   "i",
   "[",
   "0",
   "]",
   ",",
   "ClassicalRegister",
   ")",
   "]",
   ")",
   "return",
   "instructions",
   "else",
   ":",
   "raise",
   "QiskitError",
   "(",
   "'empty control or target argument'",
   ")",
   "return",
   "func",
   "(",
   "self",
   ",",
   "*",
   "params",
   ",",
   "*",
   "rargs",
   ")",
   "return",
   "wrapper"
  ]
 },
 {
  "idx": "maxmin-1064",
  "nl_tokens": [
   "Generate",
   "a",
   "list",
   "of",
   "n",
   "random",
   "ports",
   "near",
   "the",
   "given",
   "port",
   "."
  ],
  "pl_tokens": [
   "def",
   "random_ports",
   "(",
   "port",
   ",",
   "n",
   ")",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "5",
   ",",
   "n",
   ")",
   ")",
   ":",
   "yield",
   "port",
   "+",
   "i",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n",
   "-",
   "5",
   ")",
   ":",
   "yield",
   "port",
   "+",
   "random",
   ".",
   "randint",
   "(",
   "-",
   "2",
   "*",
   "n",
   ",",
   "2",
   "*",
   "n",
   ")"
  ]
 },
 {
  "idx": "maxmin-1065",
  "nl_tokens": [
   "Compute",
   "some",
   "basic",
   "stats",
   "on",
   "the",
   "next",
   "block",
   "of",
   "data"
  ],
  "pl_tokens": [
   "def",
   "print_stats",
   "(",
   "self",
   ")",
   ":",
   "header",
   ",",
   "data",
   "=",
   "self",
   ".",
   "read_next_data_block",
   "(",
   ")",
   "data",
   "=",
   "data",
   ".",
   "view",
   "(",
   "'float32'",
   ")",
   "print",
   "(",
   "\"AVG: %2.3f\"",
   "%",
   "data",
   ".",
   "mean",
   "(",
   ")",
   ")",
   "print",
   "(",
   "\"STD: %2.3f\"",
   "%",
   "data",
   ".",
   "std",
   "(",
   ")",
   ")",
   "print",
   "(",
   "\"MAX: %2.3f\"",
   "%",
   "data",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "print",
   "(",
   "\"MIN: %2.3f\"",
   "%",
   "data",
   ".",
   "min",
   "(",
   ")",
   ")",
   "import",
   "pylab",
   "as",
   "plt"
  ]
 },
 {
  "idx": "maxmin-1066",
  "nl_tokens": [
   "Format",
   "target",
   "axes",
   "given",
   "an",
   "array",
   "shape"
  ],
  "pl_tokens": [
   "def",
   "_format_axes",
   "(",
   "axes",
   ",",
   "shape",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "axes",
   ",",
   "int",
   ")",
   ":",
   "axes",
   "=",
   "(",
   "axes",
   ",",
   ")",
   "elif",
   "isinstance",
   "(",
   "axes",
   ",",
   "list",
   ")",
   "or",
   "hasattr",
   "(",
   "axes",
   ",",
   "'__iter__'",
   ")",
   ":",
   "axes",
   "=",
   "tuple",
   "(",
   "axes",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "axes",
   ",",
   "tuple",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"axes argument %s in the constructor not specified correctly\"",
   "%",
   "str",
   "(",
   "axes",
   ")",
   ")",
   "if",
   "<mask>",
   "(",
   "axes",
   ")",
   "<",
   "0",
   "or",
   "max",
   "(",
   "axes",
   ")",
   ">",
   "len",
   "(",
   "shape",
   ")",
   "-",
   "1",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"invalid key axes %s given shape %s\"",
   "%",
   "(",
   "str",
   "(",
   "axes",
   ")",
   ",",
   "str",
   "(",
   "shape",
   ")",
   ")",
   ")",
   "return",
   "axes"
  ]
 },
 {
  "idx": "maxmin-1067",
  "nl_tokens": [
   "Updates",
   "the",
   "monitor",
   "info",
   "Called",
   "from",
   "another",
   "thread",
   "."
  ],
  "pl_tokens": [
   "def",
   "update_backend_info",
   "(",
   "self",
   ",",
   "interval",
   "=",
   "60",
   ")",
   ":",
   "my_thread",
   "=",
   "threading",
   ".",
   "currentThread",
   "(",
   ")",
   "current_interval",
   "=",
   "0",
   "started",
   "=",
   "False",
   "all_dead",
   "=",
   "False",
   "stati",
   "=",
   "[",
   "None",
   "]",
   "*",
   "len",
   "(",
   "self",
   ".",
   "_backends",
   ")",
   "while",
   "getattr",
   "(",
   "my_thread",
   ",",
   "\"do_run\"",
   ",",
   "True",
   ")",
   "and",
   "not",
   "all_dead",
   ":",
   "if",
   "current_interval",
   "==",
   "interval",
   "or",
   "started",
   "is",
   "False",
   ":",
   "for",
   "ind",
   ",",
   "back",
   "in",
   "enumerate",
   "(",
   "self",
   ".",
   "_backends",
   ")",
   ":",
   "_value",
   "=",
   "self",
   ".",
   "children",
   "[",
   "ind",
   "]",
   ".",
   "children",
   "[",
   "2",
   "]",
   ".",
   "value",
   "_head",
   "=",
   "_value",
   ".",
   "split",
   "(",
   "'<b>'",
   ")",
   "[",
   "0",
   "]",
   "try",
   ":",
   "_status",
   "=",
   "back",
   ".",
   "status",
   "(",
   ")",
   "stati",
   "[",
   "ind",
   "]",
   "=",
   "_status",
   "except",
   "Exception",
   ":",
   "# pylint: disable=W0703",
   "self",
   ".",
   "children",
   "[",
   "ind",
   "]",
   ".",
   "children",
   "[",
   "2",
   "]",
   ".",
   "value",
   "=",
   "_value",
   ".",
   "replace",
   "(",
   "_head",
   ",",
   "\"<h5 style='color:#ff5c49'>\"",
   ")",
   "self",
   ".",
   "children",
   "[",
   "ind",
   "]",
   ".",
   "_is_alive",
   "=",
   "False",
   "else",
   ":",
   "self",
   ".",
   "children",
   "[",
   "ind",
   "]",
   ".",
   "_is_alive",
   "=",
   "True",
   "self",
   ".",
   "children",
   "[",
   "ind",
   "]",
   ".",
   "children",
   "[",
   "2",
   "]",
   ".",
   "value",
   "=",
   "_value",
   ".",
   "replace",
   "(",
   "_head",
   ",",
   "\"<h5>\"",
   ")",
   "idx",
   "=",
   "list",
   "(",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "_backends",
   ")",
   ")",
   ")",
   "pending",
   "=",
   "[",
   "s",
   ".",
   "pending_jobs",
   "for",
   "s",
   "in",
   "stati",
   "]",
   "_",
   ",",
   "least_idx",
   "=",
   "zip",
   "(",
   "*",
   "sorted",
   "(",
   "zip",
   "(",
   "pending",
   ",",
   "idx",
   ")",
   ")",
   ")",
   "# Make sure least pending is operational",
   "for",
   "ind",
   "in",
   "least_idx",
   ":",
   "if",
   "stati",
   "[",
   "ind",
   "]",
   ".",
   "operational",
   ":",
   "least_pending_idx",
   "=",
   "ind",
   "break",
   "for",
   "var",
   "in",
   "idx",
   ":",
   "if",
   "var",
   "==",
   "least_pending_idx",
   ":",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "4",
   "]",
   ".",
   "value",
   "=",
   "\"<h5 style='color:#34bc6e'>True</h5>\"",
   "else",
   ":",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "4",
   "]",
   ".",
   "value",
   "=",
   "\"<h5 style='color:#dc267f'>False</h5>\"",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "3",
   "]",
   ".",
   "children",
   "[",
   "1",
   "]",
   ".",
   "value",
   "=",
   "pending",
   "[",
   "var",
   "]",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "3",
   "]",
   ".",
   "children",
   "[",
   "1",
   "]",
   ".",
   "<mask>",
   "=",
   "max",
   "(",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "3",
   "]",
   ".",
   "children",
   "[",
   "1",
   "]",
   ".",
   "max",
   ",",
   "pending",
   "[",
   "var",
   "]",
   "+",
   "10",
   ")",
   "if",
   "stati",
   "[",
   "var",
   "]",
   ".",
   "operational",
   ":",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "5",
   "]",
   ".",
   "value",
   "=",
   "\"<h5 style='color:#34bc6e'>True</h5>\"",
   "else",
   ":",
   "self",
   ".",
   "children",
   "[",
   "var",
   "]",
   ".",
   "children",
   "[",
   "5",
   "]",
   ".",
   "value",
   "=",
   "\"<h5 style='color:#dc267f'>False</h5>\"",
   "started",
   "=",
   "True",
   "current_interval",
   "=",
   "0",
   "time",
   ".",
   "sleep",
   "(",
   "1",
   ")",
   "all_dead",
   "=",
   "not",
   "any",
   "(",
   "[",
   "wid",
   ".",
   "_is_alive",
   "for",
   "wid",
   "in",
   "self",
   ".",
   "children",
   "]",
   ")",
   "current_interval",
   "+=",
   "1"
  ]
 },
 {
  "idx": "maxmin-1068",
  "nl_tokens": [
   "Process",
   "a",
   "custom",
   "unitary",
   "node",
   "."
  ],
  "pl_tokens": [
   "def",
   "_process_custom_unitary",
   "(",
   "self",
   ",",
   "node",
   ")",
   ":",
   "name",
   "=",
   "node",
   ".",
   "name",
   "if",
   "node",
   ".",
   "arguments",
   "is",
   "not",
   "None",
   ":",
   "args",
   "=",
   "self",
   ".",
   "_process_node",
   "(",
   "node",
   ".",
   "arguments",
   ")",
   "else",
   ":",
   "args",
   "=",
   "[",
   "]",
   "bits",
   "=",
   "[",
   "self",
   ".",
   "_process_bit_id",
   "(",
   "node_element",
   ")",
   "for",
   "node_element",
   "in",
   "node",
   ".",
   "bitlist",
   ".",
   "children",
   "]",
   "if",
   "name",
   "in",
   "self",
   ".",
   "gates",
   ":",
   "gargs",
   "=",
   "self",
   ".",
   "gates",
   "[",
   "name",
   "]",
   "[",
   "\"args\"",
   "]",
   "gbits",
   "=",
   "self",
   ".",
   "gates",
   "[",
   "name",
   "]",
   "[",
   "\"bits\"",
   "]",
   "# Loop over register arguments, if any.",
   "maxidx",
   "=",
   "<mask>",
   "(",
   "map",
   "(",
   "len",
   ",",
   "bits",
   ")",
   ")",
   "for",
   "idx",
   "in",
   "range",
   "(",
   "maxidx",
   ")",
   ":",
   "self",
   ".",
   "arg_stack",
   ".",
   "append",
   "(",
   "{",
   "gargs",
   "[",
   "j",
   "]",
   ":",
   "args",
   "[",
   "j",
   "]",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "gargs",
   ")",
   ")",
   "}",
   ")",
   "# Only index into register arguments.",
   "element",
   "=",
   "[",
   "idx",
   "*",
   "x",
   "for",
   "x",
   "in",
   "[",
   "len",
   "(",
   "bits",
   "[",
   "j",
   "]",
   ")",
   ">",
   "1",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "bits",
   ")",
   ")",
   "]",
   "]",
   "self",
   ".",
   "bit_stack",
   ".",
   "append",
   "(",
   "{",
   "gbits",
   "[",
   "j",
   "]",
   ":",
   "bits",
   "[",
   "j",
   "]",
   "[",
   "element",
   "[",
   "j",
   "]",
   "]",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "gbits",
   ")",
   ")",
   "}",
   ")",
   "self",
   ".",
   "_create_dag_op",
   "(",
   "name",
   ",",
   "[",
   "self",
   ".",
   "arg_stack",
   "[",
   "-",
   "1",
   "]",
   "[",
   "s",
   "]",
   ".",
   "sym",
   "(",
   ")",
   "for",
   "s",
   "in",
   "gargs",
   "]",
   ",",
   "[",
   "self",
   ".",
   "bit_stack",
   "[",
   "-",
   "1",
   "]",
   "[",
   "s",
   "]",
   "for",
   "s",
   "in",
   "gbits",
   "]",
   ")",
   "self",
   ".",
   "arg_stack",
   ".",
   "pop",
   "(",
   ")",
   "self",
   ".",
   "bit_stack",
   ".",
   "pop",
   "(",
   ")",
   "else",
   ":",
   "raise",
   "QiskitError",
   "(",
   "\"internal error undefined gate:\"",
   ",",
   "\"line=%s\"",
   "%",
   "node",
   ".",
   "line",
   ",",
   "\"file=%s\"",
   "%",
   "node",
   ".",
   "file",
   ")"
  ]
 },
 {
  "idx": "maxmin-1069",
  "nl_tokens": [
   "Return",
   "load",
   "and",
   "store",
   "offsets",
   "on",
   "a",
   "virtual",
   "address",
   "space",
   "."
  ],
  "pl_tokens": [
   "def",
   "compile_global_offsets",
   "(",
   "self",
   ",",
   "iteration",
   "=",
   "0",
   ",",
   "spacing",
   "=",
   "0",
   ")",
   ":",
   "global_load_offsets",
   "=",
   "[",
   "]",
   "global_store_offsets",
   "=",
   "[",
   "]",
   "if",
   "isinstance",
   "(",
   "iteration",
   ",",
   "range",
   ")",
   ":",
   "iteration",
   "=",
   "numpy",
   ".",
   "arange",
   "(",
   "iteration",
   ".",
   "start",
   ",",
   "iteration",
   ".",
   "stop",
   ",",
   "iteration",
   ".",
   "step",
   ",",
   "dtype",
   "=",
   "'O'",
   ")",
   "else",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "iteration",
   ",",
   "collections",
   ".",
   "Sequence",
   ")",
   ":",
   "iteration",
   "=",
   "[",
   "iteration",
   "]",
   "iteration",
   "=",
   "numpy",
   ".",
   "array",
   "(",
   "iteration",
   ",",
   "dtype",
   "=",
   "'O'",
   ")",
   "# loop indices based on iteration",
   "# unwind global iteration count into loop counters:",
   "base_loop_counters",
   "=",
   "self",
   ".",
   "global_iterator_to_indices",
   "(",
   ")",
   "total_length",
   "=",
   "self",
   ".",
   "iteration_length",
   "(",
   ")",
   "assert",
   "iteration",
   ".",
   "<mask>",
   "(",
   ")",
   "<",
   "self",
   ".",
   "subs_consts",
   "(",
   "total_length",
   ")",
   ",",
   "\"Iterations go beyond what is possible in the original code ({} vs {}). \"",
   "\"One common reason, is that the iteration length are unrealistically small.\"",
   ".",
   "format",
   "(",
   "iteration",
   ".",
   "max",
   "(",
   ")",
   ",",
   "self",
   ".",
   "subs_consts",
   "(",
   "total_length",
   ")",
   ")",
   "# Get sizes of arrays and base offsets for each array",
   "var_sizes",
   "=",
   "self",
   ".",
   "array_sizes",
   "(",
   "in_bytes",
   "=",
   "True",
   ",",
   "subs_consts",
   "=",
   "True",
   ")",
   "base_offsets",
   "=",
   "{",
   "}",
   "base",
   "=",
   "0",
   "# Always arrange arrays in alphabetical order in memory, for reproducibility",
   "for",
   "var_name",
   ",",
   "var_size",
   "in",
   "sorted",
   "(",
   "var_sizes",
   ".",
   "items",
   "(",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "v",
   ":",
   "v",
   "[",
   "0",
   "]",
   ")",
   ":",
   "base_offsets",
   "[",
   "var_name",
   "]",
   "=",
   "base",
   "array_total_size",
   "=",
   "self",
   ".",
   "subs_consts",
   "(",
   "var_size",
   "+",
   "spacing",
   ")",
   "# Add bytes to align by 64 byte (typical cacheline size):",
   "array_total_size",
   "=",
   "(",
   "(",
   "int",
   "(",
   "array_total_size",
   ")",
   "+",
   "63",
   ")",
   "&",
   "~",
   "63",
   ")",
   "base",
   "+=",
   "array_total_size",
   "# Gather all read and write accesses to the array:",
   "for",
   "var_name",
   ",",
   "var_size",
   "in",
   "var_sizes",
   ".",
   "items",
   "(",
   ")",
   ":",
   "element_size",
   "=",
   "self",
   ".",
   "datatypes_size",
   "[",
   "self",
   ".",
   "variables",
   "[",
   "var_name",
   "]",
   "[",
   "0",
   "]",
   "]",
   "for",
   "r",
   "in",
   "self",
   ".",
   "sources",
   ".",
   "get",
   "(",
   "var_name",
   ",",
   "[",
   "]",
   ")",
   ":",
   "offset_expr",
   "=",
   "self",
   ".",
   "access_to_sympy",
   "(",
   "var_name",
   ",",
   "r",
   ")",
   "# Ignore accesses that always go to the same location (constant offsets)",
   "if",
   "not",
   "any",
   "(",
   "[",
   "s",
   "in",
   "base_loop_counters",
   ".",
   "keys",
   "(",
   ")",
   "for",
   "s",
   "in",
   "offset_expr",
   ".",
   "free_symbols",
   "]",
   ")",
   ":",
   "continue",
   "offset",
   "=",
   "force_iterable",
   "(",
   "sympy",
   ".",
   "lambdify",
   "(",
   "base_loop_counters",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "self",
   ".",
   "subs_consts",
   "(",
   "offset_expr",
   "*",
   "element_size",
   "+",
   "base_offsets",
   "[",
   "var_name",
   "]",
   ")",
   ",",
   "numpy",
   ")",
   ")",
   "# TODO possibly differentiate between index order",
   "global_load_offsets",
   ".",
   "append",
   "(",
   "offset",
   ")",
   "for",
   "w",
   "in",
   "self",
   ".",
   "destinations",
   ".",
   "get",
   "(",
   "var_name",
   ",",
   "[",
   "]",
   ")",
   ":",
   "offset_expr",
   "=",
   "self",
   ".",
   "access_to_sympy",
   "(",
   "var_name",
   ",",
   "w",
   ")",
   "# Ignore accesses that always go to the same location (constant offsets)",
   "if",
   "not",
   "any",
   "(",
   "[",
   "s",
   "in",
   "base_loop_counters",
   ".",
   "keys",
   "(",
   ")",
   "for",
   "s",
   "in",
   "offset_expr",
   ".",
   "free_symbols",
   "]",
   ")",
   ":",
   "continue",
   "offset",
   "=",
   "force_iterable",
   "(",
   "sympy",
   ".",
   "lambdify",
   "(",
   "base_loop_counters",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "self",
   ".",
   "subs_consts",
   "(",
   "offset_expr",
   "*",
   "element_size",
   "+",
   "base_offsets",
   "[",
   "var_name",
   "]",
   ")",
   ",",
   "numpy",
   ")",
   ")",
   "# TODO possibly differentiate between index order",
   "global_store_offsets",
   ".",
   "append",
   "(",
   "offset",
   ")",
   "# TODO take element sizes into account, return in bytes",
   "# Generate numpy.array for each counter",
   "counter_per_it",
   "=",
   "[",
   "v",
   "(",
   "iteration",
   ")",
   "for",
   "v",
   "in",
   "base_loop_counters",
   ".",
   "values",
   "(",
   ")",
   "]",
   "# Old and slow - left for reference",
   "## Data access as they appear with iteration order",
   "#return zip_longest(zip(*[o(*counter_per_it) for o in global_load_offsets]),",
   "#                   zip(*[o(*counter_per_it) for o in global_store_offsets]),",
   "#                   fillvalue=None)",
   "# Data access as they appear with iteration order",
   "load_offsets",
   "=",
   "[",
   "]",
   "for",
   "o",
   "in",
   "global_load_offsets",
   ":",
   "load_offsets",
   ".",
   "append",
   "(",
   "o",
   "(",
   "*",
   "counter_per_it",
   ")",
   ")",
   "# Convert to numpy ndarray and transpose to get offsets per iterations",
   "load_offsets",
   "=",
   "numpy",
   ".",
   "asarray",
   "(",
   "load_offsets",
   ")",
   ".",
   "T",
   "store_offsets",
   "=",
   "[",
   "]",
   "for",
   "o",
   "in",
   "global_store_offsets",
   ":",
   "store_offsets",
   ".",
   "append",
   "(",
   "o",
   "(",
   "*",
   "counter_per_it",
   ")",
   ")",
   "store_offsets",
   "=",
   "numpy",
   ".",
   "asarray",
   "(",
   "store_offsets",
   ")",
   ".",
   "T",
   "# Combine loads and stores",
   "store_width",
   "=",
   "store_offsets",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "if",
   "len",
   "(",
   "store_offsets",
   ".",
   "shape",
   ")",
   ">",
   "1",
   "else",
   "0",
   "dtype",
   "=",
   "[",
   "(",
   "'load'",
   ",",
   "load_offsets",
   ".",
   "dtype",
   ",",
   "(",
   "load_offsets",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   ")",
   ")",
   ",",
   "(",
   "'store'",
   ",",
   "store_offsets",
   ".",
   "dtype",
   ",",
   "(",
   "store_width",
   ",",
   ")",
   ")",
   "]",
   "offsets",
   "=",
   "numpy",
   ".",
   "empty",
   "(",
   "max",
   "(",
   "load_offsets",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "store_offsets",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "offsets",
   "[",
   "'load'",
   "]",
   "=",
   "load_offsets",
   "offsets",
   "[",
   "'store'",
   "]",
   "=",
   "store_offsets",
   "return",
   "offsets"
  ]
 },
 {
  "idx": "maxmin-1070",
  "nl_tokens": [
   "Naive",
   "neighborhoods",
   "algo",
   "."
  ],
  "pl_tokens": [
   "def",
   "make_fuzzy",
   "(",
   "word",
   ",",
   "<mask>",
   "=",
   "1",
   ")",
   ":",
   "# inversions",
   "neighbors",
   "=",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "word",
   ")",
   "-",
   "1",
   ")",
   ":",
   "neighbor",
   "=",
   "list",
   "(",
   "word",
   ")",
   "neighbor",
   "[",
   "i",
   "]",
   ",",
   "neighbor",
   "[",
   "i",
   "+",
   "1",
   "]",
   "=",
   "neighbor",
   "[",
   "i",
   "+",
   "1",
   "]",
   ",",
   "neighbor",
   "[",
   "i",
   "]",
   "neighbors",
   ".",
   "append",
   "(",
   "''",
   ".",
   "join",
   "(",
   "neighbor",
   ")",
   ")",
   "# substitutions",
   "for",
   "letter",
   "in",
   "string",
   ".",
   "ascii_lowercase",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "neighbor",
   "=",
   "list",
   "(",
   "word",
   ")",
   "if",
   "letter",
   "!=",
   "neighbor",
   "[",
   "i",
   "]",
   ":",
   "neighbor",
   "[",
   "i",
   "]",
   "=",
   "letter",
   "neighbors",
   ".",
   "append",
   "(",
   "''",
   ".",
   "join",
   "(",
   "neighbor",
   ")",
   ")",
   "# insertions",
   "for",
   "letter",
   "in",
   "string",
   ".",
   "ascii_lowercase",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "word",
   ")",
   "+",
   "1",
   ")",
   ":",
   "neighbor",
   "=",
   "list",
   "(",
   "word",
   ")",
   "neighbor",
   ".",
   "insert",
   "(",
   "i",
   ",",
   "letter",
   ")",
   "neighbors",
   ".",
   "append",
   "(",
   "''",
   ".",
   "join",
   "(",
   "neighbor",
   ")",
   ")",
   "if",
   "len",
   "(",
   "word",
   ")",
   ">",
   "3",
   ":",
   "# removal",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "word",
   ")",
   ")",
   ":",
   "neighbor",
   "=",
   "list",
   "(",
   "word",
   ")",
   "del",
   "neighbor",
   "[",
   "i",
   "]",
   "neighbors",
   ".",
   "append",
   "(",
   "''",
   ".",
   "join",
   "(",
   "neighbor",
   ")",
   ")",
   "return",
   "neighbors"
  ]
 },
 {
  "idx": "maxmin-1071",
  "nl_tokens": [
   "[",
   "string",
   "]",
   "-",
   ">",
   "[",
   "padded_string",
   "]"
  ],
  "pl_tokens": [
   "def",
   "_align_column",
   "(",
   "strings",
   ",",
   "alignment",
   ",",
   "minwidth",
   "=",
   "0",
   ",",
   "has_invisible",
   "=",
   "True",
   ")",
   ":",
   "if",
   "alignment",
   "==",
   "\"right\"",
   ":",
   "strings",
   "=",
   "[",
   "s",
   ".",
   "strip",
   "(",
   ")",
   "for",
   "s",
   "in",
   "strings",
   "]",
   "padfn",
   "=",
   "_padleft",
   "elif",
   "alignment",
   "in",
   "\"center\"",
   ":",
   "strings",
   "=",
   "[",
   "s",
   ".",
   "strip",
   "(",
   ")",
   "for",
   "s",
   "in",
   "strings",
   "]",
   "padfn",
   "=",
   "_padboth",
   "elif",
   "alignment",
   "in",
   "\"decimal\"",
   ":",
   "decimals",
   "=",
   "[",
   "_afterpoint",
   "(",
   "s",
   ")",
   "for",
   "s",
   "in",
   "strings",
   "]",
   "maxdecimals",
   "=",
   "<mask>",
   "(",
   "decimals",
   ")",
   "strings",
   "=",
   "[",
   "s",
   "+",
   "(",
   "maxdecimals",
   "-",
   "decs",
   ")",
   "*",
   "\" \"",
   "for",
   "s",
   ",",
   "decs",
   "in",
   "zip",
   "(",
   "strings",
   ",",
   "decimals",
   ")",
   "]",
   "padfn",
   "=",
   "_padleft",
   "else",
   ":",
   "strings",
   "=",
   "[",
   "s",
   ".",
   "strip",
   "(",
   ")",
   "for",
   "s",
   "in",
   "strings",
   "]",
   "padfn",
   "=",
   "_padright",
   "if",
   "has_invisible",
   ":",
   "width_fn",
   "=",
   "_visible_width",
   "else",
   ":",
   "width_fn",
   "=",
   "len",
   "maxwidth",
   "=",
   "max",
   "(",
   "max",
   "(",
   "list",
   "(",
   "map",
   "(",
   "width_fn",
   ",",
   "strings",
   ")",
   ")",
   ")",
   ",",
   "minwidth",
   ")",
   "padded_strings",
   "=",
   "[",
   "padfn",
   "(",
   "maxwidth",
   ",",
   "s",
   ",",
   "has_invisible",
   ")",
   "for",
   "s",
   "in",
   "strings",
   "]",
   "return",
   "padded_strings"
  ]
 },
 {
  "idx": "maxmin-1072",
  "nl_tokens": [
   "Visualizes",
   "the",
   "MDR",
   "grid",
   "of",
   "a",
   "given",
   "fitted",
   "MDR",
   "instance",
   ".",
   "Only",
   "works",
   "for",
   "2",
   "-",
   "way",
   "MDR",
   "models",
   ".",
   "This",
   "function",
   "is",
   "currently",
   "incomplete",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_mdr_grid",
   "(",
   "mdr_instance",
   ")",
   ":",
   "var1_levels",
   "=",
   "list",
   "(",
   "set",
   "(",
   "[",
   "variables",
   "[",
   "0",
   "]",
   "for",
   "variables",
   "in",
   "mdr_instance",
   ".",
   "feature_map",
   "]",
   ")",
   ")",
   "var2_levels",
   "=",
   "list",
   "(",
   "set",
   "(",
   "[",
   "variables",
   "[",
   "1",
   "]",
   "for",
   "variables",
   "in",
   "mdr_instance",
   ".",
   "feature_map",
   "]",
   ")",
   ")",
   "max_count",
   "=",
   "np",
   ".",
   "array",
   "(",
   "list",
   "(",
   "mdr_instance",
   ".",
   "class_count_matrix",
   ".",
   "values",
   "(",
   ")",
   ")",
   ")",
   ".",
   "flatten",
   "(",
   ")",
   ".",
   "<mask>",
   "(",
   ")",
   "\"\"\"\n    TODO:\n        - Add common axis labels\n        - Make sure this scales for smaller and larger record sizes\n        - Extend to 3-way+ models, e.g., http://4.bp.blogspot.com/-vgKCjEkWFUc/UPwPuHo6XvI/AAAAAAAAAE0/fORHqDcoikE/s1600/model.jpg\n    \"\"\"",
   "fig",
   ",",
   "splots",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "ncols",
   "=",
   "len",
   "(",
   "var1_levels",
   ")",
   ",",
   "nrows",
   "=",
   "len",
   "(",
   "var2_levels",
   ")",
   ",",
   "sharey",
   "=",
   "True",
   ",",
   "sharex",
   "=",
   "True",
   ")",
   "fig",
   ".",
   "set_figwidth",
   "(",
   "6",
   ")",
   "fig",
   ".",
   "set_figheight",
   "(",
   "6",
   ")",
   "for",
   "(",
   "var1",
   ",",
   "var2",
   ")",
   "in",
   "itertools",
   ".",
   "product",
   "(",
   "var1_levels",
   ",",
   "var2_levels",
   ")",
   ":",
   "class_counts",
   "=",
   "mdr_instance",
   ".",
   "class_count_matrix",
   "[",
   "(",
   "var1",
   ",",
   "var2",
   ")",
   "]",
   "splot",
   "=",
   "splots",
   "[",
   "var2_levels",
   ".",
   "index",
   "(",
   "var2",
   ")",
   "]",
   "[",
   "var1_levels",
   ".",
   "index",
   "(",
   "var1",
   ")",
   "]",
   "splot",
   ".",
   "set_yticks",
   "(",
   "[",
   "]",
   ")",
   "splot",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "splot",
   ".",
   "set_ylim",
   "(",
   "0",
   ",",
   "max_count",
   "*",
   "1.5",
   ")",
   "splot",
   ".",
   "set_xlim",
   "(",
   "-",
   "0.5",
   ",",
   "1.5",
   ")",
   "if",
   "var2_levels",
   ".",
   "index",
   "(",
   "var2",
   ")",
   "==",
   "0",
   ":",
   "splot",
   ".",
   "set_title",
   "(",
   "'X1 = {}'",
   ".",
   "format",
   "(",
   "var1",
   ")",
   ",",
   "fontsize",
   "=",
   "12",
   ")",
   "if",
   "var1_levels",
   ".",
   "index",
   "(",
   "var1",
   ")",
   "==",
   "0",
   ":",
   "splot",
   ".",
   "set_ylabel",
   "(",
   "'X2 = {}'",
   ".",
   "format",
   "(",
   "var2",
   ")",
   ",",
   "fontsize",
   "=",
   "12",
   ")",
   "bars",
   "=",
   "splot",
   ".",
   "bar",
   "(",
   "left",
   "=",
   "range",
   "(",
   "class_counts",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   ",",
   "height",
   "=",
   "class_counts",
   ",",
   "width",
   "=",
   "0.5",
   ",",
   "color",
   "=",
   "'black'",
   ",",
   "align",
   "=",
   "'center'",
   ")",
   "bgcolor",
   "=",
   "'lightgrey'",
   "if",
   "mdr_instance",
   ".",
   "feature_map",
   "[",
   "(",
   "var1",
   ",",
   "var2",
   ")",
   "]",
   "==",
   "0",
   "else",
   "'darkgrey'",
   "splot",
   ".",
   "set_axis_bgcolor",
   "(",
   "bgcolor",
   ")",
   "for",
   "index",
   ",",
   "bar",
   "in",
   "enumerate",
   "(",
   "bars",
   ")",
   ":",
   "splot",
   ".",
   "text",
   "(",
   "index",
   ",",
   "class_counts",
   "[",
   "index",
   "]",
   "+",
   "(",
   "max_count",
   "*",
   "0.1",
   ")",
   ",",
   "class_counts",
   "[",
   "index",
   "]",
   ",",
   "ha",
   "=",
   "'center'",
   ")",
   "fig",
   ".",
   "tight_layout",
   "(",
   ")",
   "return",
   "fig"
  ]
 },
 {
  "idx": "maxmin-1073",
  "nl_tokens": [
   "Calculate",
   "end",
   "position",
   "for",
   "a",
   "variant",
   "."
  ],
  "pl_tokens": [
   "def",
   "end_position",
   "(",
   "variant_obj",
   ")",
   ":",
   "alt_bases",
   "=",
   "len",
   "(",
   "variant_obj",
   "[",
   "'alternative'",
   "]",
   ")",
   "num_bases",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "variant_obj",
   "[",
   "'reference'",
   "]",
   ")",
   ",",
   "alt_bases",
   ")",
   "return",
   "variant_obj",
   "[",
   "'position'",
   "]",
   "+",
   "(",
   "num_bases",
   "-",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-1074",
  "nl_tokens": [
   "Computes",
   "the",
   "novelty",
   "curve",
   "from",
   "the",
   "structural",
   "features",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_nc",
   "(",
   "X",
   ")",
   ":",
   "N",
   "=",
   "X",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "# nc = np.sum(np.diff(X, axis=0), axis=1) # Difference between SF's",
   "nc",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "N",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "N",
   "-",
   "1",
   ")",
   ":",
   "nc",
   "[",
   "i",
   "]",
   "=",
   "distance",
   ".",
   "euclidean",
   "(",
   "X",
   "[",
   "i",
   ",",
   ":",
   "]",
   ",",
   "X",
   "[",
   "i",
   "+",
   "1",
   ",",
   ":",
   "]",
   ")",
   "# Normalize",
   "nc",
   "+=",
   "np",
   ".",
   "abs",
   "(",
   "nc",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "nc",
   "/=",
   "float",
   "(",
   "nc",
   ".",
   "max",
   "(",
   ")",
   ")",
   "return",
   "nc"
  ]
 },
 {
  "idx": "maxmin-1075",
  "nl_tokens": [
   "List",
   "room",
   "memberships",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "roomId",
   "=",
   "None",
   ",",
   "personId",
   "=",
   "None",
   ",",
   "personEmail",
   "=",
   "None",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "roomId",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "personId",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "personEmail",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "roomId",
   "=",
   "roomId",
   ",",
   "personId",
   "=",
   "personId",
   ",",
   "personEmail",
   "=",
   "personEmail",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield membership objects created from the returned items JSON objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-1076",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "hyperbolic",
   "arc",
   "cosine",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "acosh",
   "(",
   "wave",
   ")",
   ":",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "ValueError",
   ",",
   "\"Math domain error\"",
   ",",
   "bool",
   "(",
   "<mask>",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   "<",
   "1",
   ")",
   ")",
   "return",
   "_operation",
   "(",
   "wave",
   ",",
   "\"acosh\"",
   ",",
   "\"\"",
   ",",
   "np",
   ".",
   "arccosh",
   ")"
  ]
 },
 {
  "idx": "maxmin-1077",
  "nl_tokens": [
   "TODO",
   ":",
   "Check",
   "for",
   "existing",
   "files",
   "in",
   "savedir",
   "don",
   "t",
   "overwrite?"
  ],
  "pl_tokens": [
   "def",
   "long_file",
   "(",
   "data_file",
   ",",
   "dataformat",
   ",",
   "sample_list",
   ",",
   "savedir",
   "=",
   "None",
   ",",
   "srm_id",
   "=",
   "None",
   ",",
   "*",
   "*",
   "autorange_args",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "sample_list",
   ",",
   "str",
   ")",
   ":",
   "if",
   "os",
   ".",
   "path",
   ".",
   "exists",
   "(",
   "sample_list",
   ")",
   ":",
   "sample_list",
   "=",
   "np",
   ".",
   "genfromtxt",
   "(",
   "sample_list",
   ",",
   "dtype",
   "=",
   "str",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "'File {} not found.'",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "sample_list",
   ",",
   "(",
   "list",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'sample_list should be an array_like or a file.'",
   ")",
   "if",
   "srm_id",
   "is",
   "not",
   "None",
   ":",
   "srm_replace",
   "=",
   "[",
   "]",
   "for",
   "s",
   "in",
   "sample_list",
   ":",
   "if",
   "srm_id",
   "in",
   "s",
   ":",
   "s",
   "=",
   "srm_id",
   "srm_replace",
   ".",
   "append",
   "(",
   "s",
   ")",
   "sample_list",
   "=",
   "srm_replace",
   "_",
   ",",
   "_",
   ",",
   "dat",
   ",",
   "meta",
   "=",
   "read_data",
   "(",
   "data_file",
   ",",
   "dataformat",
   "=",
   "dataformat",
   ",",
   "name_mode",
   "=",
   "'file'",
   ")",
   "if",
   "'date'",
   "in",
   "meta",
   ":",
   "d",
   "=",
   "dateutil",
   ".",
   "parser",
   ".",
   "parse",
   "(",
   "meta",
   "[",
   "'date'",
   "]",
   ")",
   "else",
   ":",
   "d",
   "=",
   "datetime",
   ".",
   "datetime",
   ".",
   "now",
   "(",
   ")",
   "# autorange",
   "bkg",
   ",",
   "sig",
   ",",
   "trn",
   ",",
   "_",
   "=",
   "autorange",
   "(",
   "dat",
   "[",
   "'Time'",
   "]",
   ",",
   "dat",
   "[",
   "'total_counts'",
   "]",
   ",",
   "*",
   "*",
   "autorange_args",
   ")",
   "ns",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "sig",
   ".",
   "size",
   ")",
   "ns",
   "[",
   "sig",
   "]",
   "=",
   "np",
   ".",
   "cumsum",
   "(",
   "(",
   "sig",
   "^",
   "np",
   ".",
   "roll",
   "(",
   "sig",
   ",",
   "1",
   ")",
   ")",
   "&",
   "sig",
   ")",
   "[",
   "sig",
   "]",
   "n",
   "=",
   "int",
   "(",
   "<mask>",
   "(",
   "ns",
   ")",
   ")",
   "if",
   "len",
   "(",
   "sample_list",
   ")",
   "!=",
   "n",
   ":",
   "warn",
   "(",
   "'Length of sample list does not match number of ablations in file.\\n'",
   "+",
   "'We will continue, but please make sure the assignments are correct.'",
   ")",
   "# calculate split boundaries",
   "bounds",
   "=",
   "[",
   "]",
   "lower",
   "=",
   "0",
   "sn",
   "=",
   "0",
   "next_sample",
   "=",
   "''",
   "for",
   "ni",
   "in",
   "range",
   "(",
   "n",
   "-",
   "1",
   ")",
   ":",
   "sample",
   "=",
   "sample_list",
   "[",
   "sn",
   "]",
   "next_sample",
   "=",
   "sample_list",
   "[",
   "sn",
   "+",
   "1",
   "]",
   "if",
   "sample",
   "!=",
   "next_sample",
   ":",
   "current_end",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "dat",
   "[",
   "'Time'",
   "]",
   "==",
   "dat",
   "[",
   "'Time'",
   "]",
   "[",
   "ns",
   "==",
   "ni",
   "+",
   "1",
   "]",
   ".",
   "max",
   "(",
   ")",
   ")",
   "[",
   "0",
   "]",
   "next_start",
   "=",
   "np",
   ".",
   "argwhere",
   "(",
   "dat",
   "[",
   "'Time'",
   "]",
   "==",
   "dat",
   "[",
   "'Time'",
   "]",
   "[",
   "ns",
   "==",
   "ni",
   "+",
   "2",
   "]",
   ".",
   "min",
   "(",
   ")",
   ")",
   "[",
   "0",
   "]",
   "upper",
   "=",
   "(",
   "current_end",
   "+",
   "next_start",
   ")",
   "//",
   "2",
   "bounds",
   ".",
   "append",
   "(",
   "(",
   "sample",
   ",",
   "(",
   "int",
   "(",
   "lower",
   ")",
   ",",
   "int",
   "(",
   "upper",
   ")",
   ")",
   ")",
   ")",
   "lower",
   "=",
   "upper",
   "+",
   "1",
   "sn",
   "+=",
   "1",
   "bounds",
   ".",
   "append",
   "(",
   "(",
   "sample_list",
   "[",
   "-",
   "1",
   "]",
   ",",
   "(",
   "int",
   "(",
   "upper",
   ")",
   "+",
   "1",
   ",",
   "len",
   "(",
   "ns",
   ")",
   ")",
   ")",
   ")",
   "# split up data",
   "sections",
   "=",
   "{",
   "}",
   "seen",
   "=",
   "{",
   "}",
   "for",
   "s",
   ",",
   "(",
   "lo",
   ",",
   "hi",
   ")",
   "in",
   "bounds",
   ":",
   "if",
   "s",
   "not",
   "in",
   "seen",
   ":",
   "seen",
   "[",
   "s",
   "]",
   "=",
   "0",
   "else",
   ":",
   "seen",
   "[",
   "s",
   "]",
   "+=",
   "1",
   "s",
   "+=",
   "'_{}'",
   ".",
   "format",
   "(",
   "seen",
   "[",
   "s",
   "]",
   ")",
   "sections",
   "[",
   "s",
   "]",
   "=",
   "{",
   "'oTime'",
   ":",
   "dat",
   "[",
   "'Time'",
   "]",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "}",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'Time'",
   "]",
   "=",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'oTime'",
   "]",
   "-",
   "np",
   ".",
   "nanmin",
   "(",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'oTime'",
   "]",
   ")",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'rawdata'",
   "]",
   "=",
   "{",
   "}",
   "for",
   "k",
   ",",
   "v",
   "in",
   "dat",
   "[",
   "'rawdata'",
   "]",
   ".",
   "items",
   "(",
   ")",
   ":",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'rawdata'",
   "]",
   "[",
   "k",
   "]",
   "=",
   "v",
   "[",
   "lo",
   ":",
   "hi",
   "]",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'starttime'",
   "]",
   "=",
   "d",
   "+",
   "datetime",
   ".",
   "timedelta",
   "(",
   "seconds",
   "=",
   "np",
   ".",
   "nanmin",
   "(",
   "sections",
   "[",
   "s",
   "]",
   "[",
   "'oTime'",
   "]",
   ")",
   ")",
   "# save output",
   "if",
   "savedir",
   "is",
   "None",
   ":",
   "savedir",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "os",
   ".",
   "path",
   ".",
   "dirname",
   "(",
   "os",
   ".",
   "path",
   ".",
   "abspath",
   "(",
   "data_file",
   ")",
   ")",
   ",",
   "os",
   ".",
   "path",
   ".",
   "splitext",
   "(",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "data_file",
   ")",
   ")",
   "[",
   "0",
   "]",
   "+",
   "'_split'",
   ")",
   "if",
   "not",
   "os",
   ".",
   "path",
   ".",
   "isdir",
   "(",
   "savedir",
   ")",
   ":",
   "os",
   ".",
   "makedirs",
   "(",
   "savedir",
   ")",
   "header",
   "=",
   "[",
   "'# Long data file split by latools on {}'",
   ".",
   "format",
   "(",
   "datetime",
   ".",
   "datetime",
   ".",
   "now",
   "(",
   ")",
   ".",
   "strftime",
   "(",
   "'%Y:%m:%d %H:%M:%S'",
   ")",
   ")",
   "]",
   "if",
   "'date'",
   "not",
   "in",
   "meta",
   ":",
   "header",
   ".",
   "append",
   "(",
   "'# Warning: No date specified in file - Analysis Times are date file was split. '",
   ")",
   "else",
   ":",
   "header",
   ".",
   "append",
   "(",
   "'# '",
   ")",
   "header",
   ".",
   "append",
   "(",
   "'# '",
   ")",
   "header",
   ".",
   "append",
   "(",
   "'# '",
   ")",
   "flist",
   "=",
   "[",
   "savedir",
   "]",
   "for",
   "s",
   ",",
   "dat",
   "in",
   "sections",
   ".",
   "items",
   "(",
   ")",
   ":",
   "iheader",
   "=",
   "header",
   ".",
   "copy",
   "(",
   ")",
   "iheader",
   ".",
   "append",
   "(",
   "'# Sample: {}'",
   ".",
   "format",
   "(",
   "s",
   ")",
   ")",
   "iheader",
   ".",
   "append",
   "(",
   "'# Analysis Time: {}'",
   ".",
   "format",
   "(",
   "dat",
   "[",
   "'starttime'",
   "]",
   ".",
   "strftime",
   "(",
   "'%Y-%m-%d %H:%M:%S'",
   ")",
   ")",
   ")",
   "iheader",
   "=",
   "'\\n'",
   ".",
   "join",
   "(",
   "iheader",
   ")",
   "+",
   "'\\n'",
   "out",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "{",
   "analyte_2_namemass",
   "(",
   "k",
   ")",
   ":",
   "v",
   "for",
   "k",
   ",",
   "v",
   "in",
   "dat",
   "[",
   "'rawdata'",
   "]",
   ".",
   "items",
   "(",
   ")",
   "}",
   ",",
   "index",
   "=",
   "dat",
   "[",
   "'Time'",
   "]",
   ")",
   "out",
   ".",
   "index",
   ".",
   "name",
   "=",
   "'Time'",
   "csv",
   "=",
   "out",
   ".",
   "to_csv",
   "(",
   ")",
   "with",
   "open",
   "(",
   "'{}/{}.csv'",
   ".",
   "format",
   "(",
   "savedir",
   ",",
   "s",
   ")",
   ",",
   "'w'",
   ")",
   "as",
   "f",
   ":",
   "f",
   ".",
   "write",
   "(",
   "iheader",
   ")",
   "f",
   ".",
   "write",
   "(",
   "csv",
   ")",
   "flist",
   ".",
   "append",
   "(",
   "'   {}.csv'",
   ".",
   "format",
   "(",
   "s",
   ")",
   ")",
   "print",
   "(",
   "\"File split into {} sections.\\n Saved to: {}\\n\\n Import using the 'REPRODUCE' configuration.\"",
   ".",
   "format",
   "(",
   "n",
   ",",
   "'\\n'",
   ".",
   "join",
   "(",
   "flist",
   ")",
   ")",
   ")",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-1078",
  "nl_tokens": [
   "Adds",
   "two",
   "sequences",
   "of",
   "trits",
   "together",
   "."
  ],
  "pl_tokens": [
   "def",
   "add_trits",
   "(",
   "left",
   ",",
   "right",
   ")",
   ":",
   "# type: (Sequence[int], Sequence[int]) -> List[int]",
   "target_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "left",
   ")",
   ",",
   "len",
   "(",
   "right",
   ")",
   ")",
   "res",
   "=",
   "[",
   "0",
   "]",
   "*",
   "target_len",
   "left",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "(",
   "target_len",
   "-",
   "len",
   "(",
   "left",
   ")",
   ")",
   "right",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "(",
   "target_len",
   "-",
   "len",
   "(",
   "right",
   ")",
   ")",
   "carry",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "res",
   ")",
   ")",
   ":",
   "res",
   "[",
   "i",
   "]",
   ",",
   "carry",
   "=",
   "_full_add_trits",
   "(",
   "left",
   "[",
   "i",
   "]",
   ",",
   "right",
   "[",
   "i",
   "]",
   ",",
   "carry",
   ")",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-1079",
  "nl_tokens": [
   "Clip",
   "values",
   "above",
   "and",
   "below",
   "."
  ],
  "pl_tokens": [
   "def",
   "clip",
   "(",
   "self",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "max",
   "=",
   "None",
   ")",
   ":",
   "rdd",
   "=",
   "self",
   ".",
   "_rdd",
   ".",
   "mapValues",
   "(",
   "lambda",
   "v",
   ":",
   "v",
   ".",
   "clip",
   "(",
   "min",
   "=",
   "min",
   ",",
   "max",
   "=",
   "max",
   ")",
   ")",
   "return",
   "self",
   ".",
   "_constructor",
   "(",
   "rdd",
   ")",
   ".",
   "__finalize__",
   "(",
   "self",
   ")"
  ]
 },
 {
  "idx": "maxmin-1080",
  "nl_tokens": [
   "Determine",
   "FDR",
   "threshold",
   "given",
   "a",
   "p",
   "value",
   "array",
   "and",
   "desired",
   "false",
   "discovery",
   "rate",
   "q",
   "."
  ],
  "pl_tokens": [
   "def",
   "fdr",
   "(",
   "p",
   ",",
   "q",
   "=",
   ".05",
   ")",
   ":",
   "s",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "p",
   ")",
   "nvox",
   "=",
   "p",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "null",
   "=",
   "np",
   ".",
   "array",
   "(",
   "range",
   "(",
   "1",
   ",",
   "nvox",
   "+",
   "1",
   ")",
   ",",
   "dtype",
   "=",
   "'float'",
   ")",
   "*",
   "q",
   "/",
   "nvox",
   "below",
   "=",
   "np",
   ".",
   "where",
   "(",
   "s",
   "<=",
   "null",
   ")",
   "[",
   "0",
   "]",
   "return",
   "s",
   "[",
   "<mask>",
   "(",
   "below",
   ")",
   "]",
   "if",
   "len",
   "(",
   "below",
   ")",
   "else",
   "-",
   "1"
  ]
 },
 {
  "idx": "maxmin-1081",
  "nl_tokens": [
   "Try",
   "to",
   "import",
   "the",
   "given",
   "names",
   "and",
   "return",
   "a",
   "list",
   "of",
   "[",
   "(",
   "name",
   "signature",
   "summary_string",
   "real_name",
   ")",
   "...",
   "]",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_items",
   "(",
   "self",
   ",",
   "names",
   ")",
   ":",
   "env",
   "=",
   "self",
   ".",
   "state",
   ".",
   "document",
   ".",
   "settings",
   ".",
   "env",
   "prefixes",
   "=",
   "get_import_prefixes_from_env",
   "(",
   "env",
   ")",
   "items",
   "=",
   "[",
   "]",
   "max_item_chars",
   "=",
   "50",
   "for",
   "name",
   "in",
   "names",
   ":",
   "display_name",
   "=",
   "name",
   "if",
   "name",
   ".",
   "startswith",
   "(",
   "'~'",
   ")",
   ":",
   "name",
   "=",
   "name",
   "[",
   "1",
   ":",
   "]",
   "display_name",
   "=",
   "name",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   "[",
   "-",
   "1",
   "]",
   "try",
   ":",
   "real_name",
   ",",
   "obj",
   ",",
   "parent",
   "=",
   "import_by_name",
   "(",
   "name",
   ",",
   "prefixes",
   "=",
   "prefixes",
   ")",
   "except",
   "ImportError",
   ":",
   "self",
   ".",
   "warn",
   "(",
   "'failed to import %s'",
   "%",
   "name",
   ")",
   "items",
   ".",
   "append",
   "(",
   "(",
   "name",
   ",",
   "''",
   ",",
   "''",
   ",",
   "name",
   ")",
   ")",
   "continue",
   "# NB. using real_name here is important, since Documenters",
   "#     handle module prefixes slightly differently",
   "documenter",
   "=",
   "get_documenter",
   "(",
   "obj",
   ",",
   "parent",
   ")",
   "(",
   "self",
   ",",
   "real_name",
   ")",
   "if",
   "not",
   "documenter",
   ".",
   "parse_name",
   "(",
   ")",
   ":",
   "self",
   ".",
   "warn",
   "(",
   "'failed to parse name %s'",
   "%",
   "real_name",
   ")",
   "items",
   ".",
   "append",
   "(",
   "(",
   "display_name",
   ",",
   "''",
   ",",
   "''",
   ",",
   "real_name",
   ")",
   ")",
   "continue",
   "if",
   "not",
   "documenter",
   ".",
   "import_object",
   "(",
   ")",
   ":",
   "self",
   ".",
   "warn",
   "(",
   "'failed to import object %s'",
   "%",
   "real_name",
   ")",
   "items",
   ".",
   "append",
   "(",
   "(",
   "display_name",
   ",",
   "''",
   ",",
   "''",
   ",",
   "real_name",
   ")",
   ")",
   "continue",
   "# -- Grab the signature",
   "sig",
   "=",
   "documenter",
   ".",
   "format_signature",
   "(",
   ")",
   "if",
   "not",
   "sig",
   ":",
   "sig",
   "=",
   "''",
   "else",
   ":",
   "max_chars",
   "=",
   "<mask>",
   "(",
   "10",
   ",",
   "max_item_chars",
   "-",
   "len",
   "(",
   "display_name",
   ")",
   ")",
   "sig",
   "=",
   "mangle_signature",
   "(",
   "sig",
   ",",
   "max_chars",
   "=",
   "max_chars",
   ")",
   "sig",
   "=",
   "sig",
   ".",
   "replace",
   "(",
   "'*'",
   ",",
   "r'\\*'",
   ")",
   "# -- Grab the summary",
   "doc",
   "=",
   "list",
   "(",
   "documenter",
   ".",
   "process_doc",
   "(",
   "documenter",
   ".",
   "get_doc",
   "(",
   ")",
   ")",
   ")",
   "while",
   "doc",
   "and",
   "not",
   "doc",
   "[",
   "0",
   "]",
   ".",
   "strip",
   "(",
   ")",
   ":",
   "doc",
   ".",
   "pop",
   "(",
   "0",
   ")",
   "m",
   "=",
   "re",
   ".",
   "search",
   "(",
   "r\"^([A-Z][^A-Z]*?\\.\\s)\"",
   ",",
   "\" \"",
   ".",
   "join",
   "(",
   "doc",
   ")",
   ".",
   "strip",
   "(",
   ")",
   ")",
   "if",
   "m",
   ":",
   "summary",
   "=",
   "m",
   ".",
   "group",
   "(",
   "1",
   ")",
   ".",
   "strip",
   "(",
   ")",
   "elif",
   "doc",
   ":",
   "summary",
   "=",
   "doc",
   "[",
   "0",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "else",
   ":",
   "summary",
   "=",
   "''",
   "items",
   ".",
   "append",
   "(",
   "(",
   "display_name",
   ",",
   "sig",
   ",",
   "summary",
   ",",
   "real_name",
   ")",
   ")",
   "return",
   "items"
  ]
 },
 {
  "idx": "maxmin-1082",
  "nl_tokens": [
   "Return",
   "the",
   "minimum",
   "of",
   "the",
   "array",
   "over",
   "the",
   "given",
   "axis",
   "."
  ],
  "pl_tokens": [
   "def",
   "<mask>",
   "(",
   "self",
   ",",
   "axis",
   "=",
   "None",
   ",",
   "keepdims",
   "=",
   "False",
   ")",
   ":",
   "from",
   "numpy",
   "import",
   "minimum",
   "return",
   "self",
   ".",
   "_stat",
   "(",
   "axis",
   ",",
   "func",
   "=",
   "minimum",
   ",",
   "keepdims",
   "=",
   "keepdims",
   ")"
  ]
 },
 {
  "idx": "maxmin-1083",
  "nl_tokens": [
   "Parse",
   "lines",
   "with",
   "ensembl",
   "formated",
   "exons"
  ],
  "pl_tokens": [
   "def",
   "parse_ensembl_exons",
   "(",
   "lines",
   ")",
   ":",
   "header",
   "=",
   "[",
   "]",
   "LOG",
   ".",
   "debug",
   "(",
   "\"Parsing ensembl exons...\"",
   ")",
   "for",
   "index",
   ",",
   "line",
   "in",
   "enumerate",
   "(",
   "lines",
   ")",
   ":",
   "# File allways start with a header line",
   "if",
   "index",
   "==",
   "0",
   ":",
   "header",
   "=",
   "line",
   ".",
   "rstrip",
   "(",
   ")",
   ".",
   "split",
   "(",
   "'\\t'",
   ")",
   "continue",
   "exon_info",
   "=",
   "parse_ensembl_line",
   "(",
   "line",
   ",",
   "header",
   ")",
   "chrom",
   "=",
   "exon_info",
   "[",
   "'chrom'",
   "]",
   "start",
   "=",
   "exon_info",
   "[",
   "'exon_start'",
   "]",
   "end",
   "=",
   "exon_info",
   "[",
   "'exon_end'",
   "]",
   "transcript",
   "=",
   "exon_info",
   "[",
   "'ensembl_transcript_id'",
   "]",
   "gene",
   "=",
   "exon_info",
   "[",
   "'ensembl_gene_id'",
   "]",
   "rank",
   "=",
   "exon_info",
   "[",
   "'exon_rank'",
   "]",
   "strand",
   "=",
   "exon_info",
   "[",
   "'strand'",
   "]",
   "# Recalculate start and stop (taking UTR regions into account for end exons)",
   "if",
   "strand",
   "==",
   "1",
   ":",
   "# highest position: start of exon or end of 5' UTR",
   "# If no 5' UTR make sure exon_start is allways choosen",
   "start",
   "=",
   "<mask>",
   "(",
   "start",
   ",",
   "exon_info",
   ".",
   "get",
   "(",
   "'utr_5_end'",
   ")",
   "or",
   "-",
   "1",
   ")",
   "# lowest position: end of exon or start of 3' UTR",
   "end",
   "=",
   "min",
   "(",
   "end",
   ",",
   "exon_info",
   ".",
   "get",
   "(",
   "'utr_3_start'",
   ")",
   "or",
   "float",
   "(",
   "'inf'",
   ")",
   ")",
   "elif",
   "strand",
   "==",
   "-",
   "1",
   ":",
   "# highest position: start of exon or end of 3' UTR",
   "start",
   "=",
   "max",
   "(",
   "start",
   ",",
   "exon_info",
   ".",
   "get",
   "(",
   "'utr_3_end'",
   ")",
   "or",
   "-",
   "1",
   ")",
   "# lowest position: end of exon or start of 5' UTR",
   "end",
   "=",
   "min",
   "(",
   "end",
   ",",
   "exon_info",
   ".",
   "get",
   "(",
   "'utr_5_start'",
   ")",
   "or",
   "float",
   "(",
   "'inf'",
   ")",
   ")",
   "exon_id",
   "=",
   "\"-\"",
   ".",
   "join",
   "(",
   "[",
   "chrom",
   ",",
   "str",
   "(",
   "start",
   ")",
   ",",
   "str",
   "(",
   "end",
   ")",
   "]",
   ")",
   "if",
   "start",
   ">",
   "end",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"ERROR: %s\"",
   "%",
   "exon_id",
   ")",
   "data",
   "=",
   "{",
   "\"exon_id\"",
   ":",
   "exon_id",
   ",",
   "\"chrom\"",
   ":",
   "chrom",
   ",",
   "\"start\"",
   ":",
   "start",
   ",",
   "\"end\"",
   ":",
   "end",
   ",",
   "\"transcript\"",
   ":",
   "transcript",
   ",",
   "\"gene\"",
   ":",
   "gene",
   ",",
   "\"rank\"",
   ":",
   "rank",
   ",",
   "}",
   "yield",
   "data"
  ]
 },
 {
  "idx": "maxmin-1084",
  "nl_tokens": [
   "Dumps",
   "the",
   "mesh",
   "to",
   "XDMF",
   "format",
   "."
  ],
  "pl_tokens": [
   "def",
   "write_xdmf",
   "(",
   "mesh",
   ",",
   "path",
   ",",
   "dataformat",
   "=",
   "\"XML\"",
   ")",
   ":",
   "pattern",
   "=",
   "Template",
   "(",
   "open",
   "(",
   "MODPATH",
   "+",
   "\"/templates/mesh/xdmf.xdmf\"",
   ")",
   ".",
   "read",
   "(",
   ")",
   ")",
   "attribute_pattern",
   "=",
   "Template",
   "(",
   "open",
   "(",
   "MODPATH",
   "+",
   "\"/templates/mesh/xdmf_attribute.xdmf\"",
   ")",
   ".",
   "read",
   "(",
   ")",
   ")",
   "# MAPPINGS",
   "cell_map",
   "=",
   "{",
   "\"tri3\"",
   ":",
   "4",
   ",",
   "\"quad4\"",
   ":",
   "5",
   ",",
   "\"tetra4\"",
   ":",
   "6",
   ",",
   "\"pyra5\"",
   ":",
   "7",
   ",",
   "\"prism6\"",
   ":",
   "8",
   ",",
   "\"hexa8\"",
   ":",
   "9",
   "}",
   "# REFERENCES",
   "nodes",
   ",",
   "elements",
   "=",
   "mesh",
   ".",
   "nodes",
   ".",
   "data",
   ",",
   "mesh",
   ".",
   "elements",
   ".",
   "data",
   "fields",
   "=",
   "mesh",
   ".",
   "fields",
   "# NUMBERS",
   "Ne",
   ",",
   "Nn",
   "=",
   "len",
   "(",
   "elements",
   ")",
   ",",
   "len",
   "(",
   "nodes",
   ")",
   "# NODES",
   "nodes_map",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "nodes",
   ".",
   "index",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "1",
   ")",
   "nodes_map",
   "[",
   "nodes",
   ".",
   "index",
   "]",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "nodes",
   ".",
   "index",
   ")",
   ")",
   "nodes_map",
   "[",
   "0",
   "]",
   "=",
   "-",
   "1",
   "# ELEMENTS",
   "cols",
   "=",
   "[",
   "\"n{0}\"",
   ".",
   "format",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "elements",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "-",
   "1",
   ")",
   "]",
   "connectivities",
   "=",
   "mesh",
   ".",
   "elements",
   ".",
   "data",
   "[",
   "cols",
   "]",
   ".",
   "as_matrix",
   "(",
   ")",
   "connectivities",
   "[",
   "np",
   ".",
   "isnan",
   "(",
   "connectivities",
   ")",
   "]",
   "=",
   "0",
   "connectivities",
   "=",
   "connectivities",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "int32",
   ")",
   "connectivities",
   "=",
   "nodes_map",
   "[",
   "connectivities",
   "]",
   "labels",
   "=",
   "np",
   ".",
   "array",
   "(",
   "elements",
   ".",
   "index",
   ")",
   "etypes",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "cell_map",
   "[",
   "t",
   "]",
   "for",
   "t",
   "in",
   "elements",
   ".",
   "etype",
   "]",
   ")",
   "lconn",
   "=",
   "Ne",
   "+",
   "(",
   "connectivities",
   "!=",
   "-",
   "1",
   ")",
   ".",
   "sum",
   "(",
   ")",
   "# FIELDS",
   "fields_string",
   "=",
   "\"\"",
   "field_data",
   "=",
   "{",
   "}",
   "for",
   "tag",
   ",",
   "field",
   "in",
   "fields",
   ".",
   "items",
   "(",
   ")",
   ":",
   "field_data",
   "[",
   "tag",
   "]",
   "=",
   "{",
   "}",
   "field",
   ".",
   "data",
   ".",
   "sort_index",
   "(",
   "inplace",
   "=",
   "True",
   ")",
   "fshape",
   "=",
   "field",
   ".",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "if",
   "fshape",
   "==",
   "1",
   ":",
   "ftype",
   "=",
   "\"Scalar\"",
   "elif",
   "fshape",
   "==",
   "3",
   ":",
   "ftype",
   "=",
   "\"Vector\"",
   "elif",
   "fshape",
   "==",
   "2",
   ":",
   "ftype",
   "=",
   "\"Vector\"",
   "# UGLY HACK...",
   "field",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "field",
   ")",
   "field",
   ".",
   "data",
   "[",
   "\"v3\"",
   "]",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "field",
   ".",
   "data",
   ".",
   "index",
   ")",
   "fields",
   "[",
   "tag",
   "]",
   "=",
   "field",
   "# BACK TO NORMAL  ",
   "elif",
   "fshape",
   "==",
   "6",
   ":",
   "ftype",
   "=",
   "\"Tensor6\"",
   "elif",
   "fshape",
   "==",
   "4",
   ":",
   "ftype",
   "=",
   "\"Tensor6\"",
   "# UGLY HACK...",
   "field",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "field",
   ")",
   "field",
   ".",
   "data",
   "[",
   "\"v13\"",
   "]",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "field",
   ".",
   "data",
   ".",
   "index",
   ")",
   "field",
   ".",
   "data",
   "[",
   "\"v23\"",
   "]",
   "=",
   "np",
   ".",
   "zeros_like",
   "(",
   "field",
   ".",
   "data",
   ".",
   "index",
   ")",
   "fields",
   "[",
   "tag",
   "]",
   "=",
   "field",
   "# BACK TO NORMAL  ",
   "if",
   "field",
   ".",
   "metadata",
   ".",
   "position",
   "==",
   "\"Nodal\"",
   ":",
   "position",
   "=",
   "\"Node\"",
   "if",
   "field",
   ".",
   "metadata",
   ".",
   "position",
   "==",
   "\"Element\"",
   ":",
   "position",
   "=",
   "\"Cell\"",
   "field_data",
   "[",
   "tag",
   "]",
   "[",
   "\"TAG\"",
   "]",
   "=",
   "tag",
   "field_data",
   "[",
   "tag",
   "]",
   "[",
   "\"ATTRIBUTETYPE\"",
   "]",
   "=",
   "ftype",
   "field_data",
   "[",
   "tag",
   "]",
   "[",
   "\"FORMAT\"",
   "]",
   "=",
   "dataformat",
   "field_data",
   "[",
   "tag",
   "]",
   "[",
   "\"FIELD_DIMENSION\"",
   "]",
   "=",
   "\" \"",
   ".",
   "join",
   "(",
   "[",
   "str",
   "(",
   "l",
   ")",
   "for",
   "l",
   "in",
   "field",
   ".",
   "data",
   ".",
   "shape",
   "]",
   ")",
   "field_data",
   "[",
   "tag",
   "]",
   "[",
   "\"POSITION\"",
   "]",
   "=",
   "position",
   "if",
   "dataformat",
   "==",
   "\"XML\"",
   ":",
   "#NODES",
   "nodes_string",
   "=",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "[",
   "11",
   "*",
   "\" \"",
   "+",
   "\"{0} {1} {2}\"",
   ".",
   "format",
   "(",
   "n",
   ".",
   "x",
   ",",
   "n",
   ".",
   "y",
   ",",
   "n",
   ".",
   "z",
   ")",
   "for",
   "i",
   ",",
   "n",
   "in",
   "nodes",
   ".",
   "iterrows",
   "(",
   ")",
   "]",
   ")",
   "# ELEMENTS",
   "elements_string",
   "=",
   "\"\"",
   "for",
   "i",
   "in",
   "range",
   "(",
   "Ne",
   ")",
   ":",
   "elements_string",
   "+=",
   "11",
   "*",
   "\" \"",
   "+",
   "str",
   "(",
   "etypes",
   "[",
   "i",
   "]",
   ")",
   "+",
   "\" \"",
   "c",
   "=",
   "connectivities",
   "[",
   "i",
   "]",
   "c",
   "=",
   "c",
   "[",
   "np",
   ".",
   "where",
   "(",
   "c",
   "!=",
   "-",
   "1",
   ")",
   "]",
   "elements_string",
   "+=",
   "\" \"",
   ".",
   "join",
   "(",
   "[",
   "str",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "c",
   "]",
   ")",
   "+",
   "\"\\n\"",
   "elements_strings",
   "=",
   "elements_string",
   "[",
   ":",
   "-",
   "1",
   "]",
   "# FIELDS",
   "for",
   "tag",
   ",",
   "field",
   "in",
   "fields",
   ".",
   "items",
   "(",
   ")",
   ":",
   "fdata",
   "=",
   "field",
   ".",
   "data",
   ".",
   "to_csv",
   "(",
   "sep",
   "=",
   "\" \"",
   ",",
   "index",
   "=",
   "False",
   ",",
   "header",
   "=",
   "False",
   ")",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   "fdata",
   "=",
   "[",
   "11",
   "*",
   "\" \"",
   "+",
   "l",
   "for",
   "l",
   "in",
   "fdata",
   "]",
   "fdata",
   "=",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "fdata",
   ")",
   "field_data",
   "[",
   "tag",
   "]",
   "[",
   "\"DATA\"",
   "]",
   "=",
   "fdata",
   "fields_string",
   "+=",
   "attribute_pattern",
   ".",
   "substitute",
   "(",
   "*",
   "*",
   "field_data",
   "[",
   "tag",
   "]",
   ")",
   "elif",
   "dataformat",
   "==",
   "\"HDF\"",
   ":",
   "hdf",
   "=",
   "pd",
   ".",
   "HDFStore",
   "(",
   "path",
   "+",
   "\".h5\"",
   ")",
   "hdf",
   ".",
   "put",
   "(",
   "\"COORDS\"",
   ",",
   "mesh",
   ".",
   "nodes",
   ".",
   "data",
   "[",
   "list",
   "(",
   "\"xyz\"",
   ")",
   "]",
   ")",
   "flatconn",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "lconn",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int32",
   ")",
   "pos",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "Ne",
   ")",
   ":",
   "c",
   "=",
   "connectivities",
   "[",
   "i",
   "]",
   "c",
   "=",
   "c",
   "[",
   "np",
   ".",
   "where",
   "(",
   "c",
   "!=",
   "-",
   "1",
   ")",
   "]",
   "lc",
   "=",
   "len",
   "(",
   "c",
   ")",
   "flatconn",
   "[",
   "pos",
   "]",
   "=",
   "etypes",
   "[",
   "i",
   "]",
   "flatconn",
   "[",
   "pos",
   "+",
   "1",
   "+",
   "np",
   ".",
   "arange",
   "(",
   "lc",
   ")",
   "]",
   "=",
   "c",
   "pos",
   "+=",
   "1",
   "+",
   "lc",
   "hdf",
   ".",
   "put",
   "(",
   "\"CONNECTIVITY\"",
   ",",
   "pd",
   ".",
   "DataFrame",
   "(",
   "flatconn",
   ")",
   ")",
   "nodes_string",
   "=",
   "11",
   "*",
   "\" \"",
   "+",
   "\"{0}.h5:/COORDS/block0_values\"",
   ".",
   "format",
   "(",
   "path",
   ")",
   "elements_string",
   "=",
   "11",
   "*",
   "\" \"",
   "+",
   "\"{0}.h5:/CONNECTIVITY/block0_values\"",
   ".",
   "format",
   "(",
   "path",
   ")",
   "for",
   "tag",
   ",",
   "field",
   "in",
   "fields",
   ".",
   "items",
   "(",
   ")",
   ":",
   "fstrings",
   "[",
   "tag",
   "]",
   "=",
   "fstrings",
   "[",
   "tag",
   "]",
   ".",
   "replace",
   "(",
   "\"#DATA\"",
   ",",
   "11",
   "*",
   "\" \"",
   "+",
   "\"{0}.h5:/FIELDS/{1}/block0_values\"",
   ".",
   "format",
   "(",
   "path",
   ",",
   "tag",
   ")",
   ")",
   "fields_string",
   "+=",
   "fstrings",
   "[",
   "tag",
   "]",
   "hdf",
   ".",
   "put",
   "(",
   "\"FIELDS/{0}\"",
   ".",
   "format",
   "(",
   "tag",
   ")",
   ",",
   "fields",
   ".",
   "data",
   ")",
   "hdf",
   ".",
   "close",
   "(",
   ")",
   "\"\"\"\n  pattern = pattern.replace(\"#ELEMENT_NUMBER\", str(Ne))\n  pattern = pattern.replace(\"#CONN_DIMENSION\", str(lconn))\n  pattern = pattern.replace(\"#CONN_PATH\", elements_string)\n  pattern = pattern.replace(\"#NODE_NUMBER\", str(Nn))\n  pattern = pattern.replace(\"#NODE_PATH\", nodes_string)\n  pattern = pattern.replace(\"#DATAFORMAT\", dataformat)\n  pattern = pattern.replace(\"#ATTRIBUTES\", fields_string) \n  \"\"\"",
   "fields_string",
   "=",
   "\"\\n\"",
   ".",
   "join",
   "(",
   "[",
   "attribute_pattern",
   ".",
   "substitute",
   "(",
   "*",
   "*",
   "value",
   ")",
   "for",
   "key",
   ",",
   "value",
   "in",
   "field_data",
   ".",
   "items",
   "(",
   ")",
   "]",
   ")",
   "pattern",
   "=",
   "pattern",
   ".",
   "substitute",
   "(",
   "ELEMENT_NUMBER",
   "=",
   "str",
   "(",
   "Ne",
   ")",
   ",",
   "CONN_DIMENSION",
   "=",
   "str",
   "(",
   "lconn",
   ")",
   ",",
   "CONN_PATH",
   "=",
   "elements_string",
   ",",
   "NODE_NUMBER",
   "=",
   "str",
   "(",
   "Nn",
   ")",
   ",",
   "NODE_PATH",
   "=",
   "nodes_string",
   ",",
   "DATAFORMAT",
   "=",
   "dataformat",
   ",",
   "ATTRIBUTES",
   "=",
   "fields_string",
   ")",
   "open",
   "(",
   "path",
   "+",
   "\".xdmf\"",
   ",",
   "\"wb\"",
   ")",
   ".",
   "write",
   "(",
   "pattern",
   ")"
  ]
 },
 {
  "idx": "maxmin-1085",
  "nl_tokens": [
   "Short",
   "-",
   "time",
   "Fourier",
   "transform",
   "(",
   "STFT",
   ")"
  ],
  "pl_tokens": [
   "def",
   "stft",
   "(",
   "y",
   ",",
   "n_fft",
   "=",
   "2048",
   ",",
   "hop_length",
   "=",
   "None",
   ",",
   "win_length",
   "=",
   "None",
   ",",
   "window",
   "=",
   "'hann'",
   ",",
   "center",
   "=",
   "True",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "complex64",
   ",",
   "pad_mode",
   "=",
   "'reflect'",
   ")",
   ":",
   "# By default, use the entire frame",
   "if",
   "win_length",
   "is",
   "None",
   ":",
   "win_length",
   "=",
   "n_fft",
   "# Set the default hop, if it's not already specified",
   "if",
   "hop_length",
   "is",
   "None",
   ":",
   "hop_length",
   "=",
   "int",
   "(",
   "win_length",
   "//",
   "4",
   ")",
   "fft_window",
   "=",
   "get_window",
   "(",
   "window",
   ",",
   "win_length",
   ",",
   "fftbins",
   "=",
   "True",
   ")",
   "# Pad the window out to n_fft size",
   "fft_window",
   "=",
   "util",
   ".",
   "pad_center",
   "(",
   "fft_window",
   ",",
   "n_fft",
   ")",
   "# Reshape so that the window can be broadcast",
   "fft_window",
   "=",
   "fft_window",
   ".",
   "reshape",
   "(",
   "(",
   "-",
   "1",
   ",",
   "1",
   ")",
   ")",
   "# Check audio is valid",
   "util",
   ".",
   "valid_audio",
   "(",
   "y",
   ")",
   "# Pad the time series so that frames are centered",
   "if",
   "center",
   ":",
   "y",
   "=",
   "np",
   ".",
   "pad",
   "(",
   "y",
   ",",
   "int",
   "(",
   "n_fft",
   "//",
   "2",
   ")",
   ",",
   "mode",
   "=",
   "pad_mode",
   ")",
   "# Window the time series.",
   "y_frames",
   "=",
   "util",
   ".",
   "frame",
   "(",
   "y",
   ",",
   "frame_length",
   "=",
   "n_fft",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "# Pre-allocate the STFT matrix",
   "stft_matrix",
   "=",
   "np",
   ".",
   "empty",
   "(",
   "(",
   "int",
   "(",
   "1",
   "+",
   "n_fft",
   "//",
   "2",
   ")",
   ",",
   "y_frames",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ",",
   "dtype",
   "=",
   "dtype",
   ",",
   "order",
   "=",
   "'F'",
   ")",
   "fft",
   "=",
   "get_fftlib",
   "(",
   ")",
   "# how many columns can we fit within MAX_MEM_BLOCK?",
   "n_columns",
   "=",
   "int",
   "(",
   "util",
   ".",
   "MAX_MEM_BLOCK",
   "/",
   "(",
   "stft_matrix",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "*",
   "stft_matrix",
   ".",
   "itemsize",
   ")",
   ")",
   "for",
   "bl_s",
   "in",
   "range",
   "(",
   "0",
   ",",
   "stft_matrix",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "n_columns",
   ")",
   ":",
   "bl_t",
   "=",
   "<mask>",
   "(",
   "bl_s",
   "+",
   "n_columns",
   ",",
   "stft_matrix",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "stft_matrix",
   "[",
   ":",
   ",",
   "bl_s",
   ":",
   "bl_t",
   "]",
   "=",
   "fft",
   ".",
   "rfft",
   "(",
   "fft_window",
   "*",
   "y_frames",
   "[",
   ":",
   ",",
   "bl_s",
   ":",
   "bl_t",
   "]",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "return",
   "stft_matrix"
  ]
 },
 {
  "idx": "maxmin-1086",
  "nl_tokens": [
   "Retrieve",
   "the",
   "index",
   "in",
   "this",
   "metric",
   "s",
   "threshold",
   "list",
   "at",
   "which",
   "the",
   "given",
   "threshold",
   "is",
   "located",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_idx_by_threshold",
   "(",
   "self",
   ",",
   "threshold",
   ")",
   ":",
   "assert_is_type",
   "(",
   "threshold",
   ",",
   "numeric",
   ")",
   "thresh2d",
   "=",
   "self",
   ".",
   "_metric_json",
   "[",
   "'thresholds_and_metric_scores'",
   "]",
   "for",
   "i",
   ",",
   "e",
   "in",
   "enumerate",
   "(",
   "thresh2d",
   ".",
   "cell_values",
   ")",
   ":",
   "t",
   "=",
   "float",
   "(",
   "e",
   "[",
   "0",
   "]",
   ")",
   "if",
   "abs",
   "(",
   "t",
   "-",
   "threshold",
   ")",
   "<",
   "1e-8",
   "*",
   "<mask>",
   "(",
   "t",
   ",",
   "threshold",
   ")",
   ":",
   "return",
   "i",
   "if",
   "0",
   "<=",
   "threshold",
   "<=",
   "1",
   ":",
   "thresholds",
   "=",
   "[",
   "float",
   "(",
   "e",
   "[",
   "0",
   "]",
   ")",
   "for",
   "i",
   ",",
   "e",
   "in",
   "enumerate",
   "(",
   "thresh2d",
   ".",
   "cell_values",
   ")",
   "]",
   "threshold_diffs",
   "=",
   "[",
   "abs",
   "(",
   "t",
   "-",
   "threshold",
   ")",
   "for",
   "t",
   "in",
   "thresholds",
   "]",
   "closest_idx",
   "=",
   "threshold_diffs",
   ".",
   "index",
   "(",
   "min",
   "(",
   "threshold_diffs",
   ")",
   ")",
   "closest_threshold",
   "=",
   "thresholds",
   "[",
   "closest_idx",
   "]",
   "print",
   "(",
   "\"Could not find exact threshold {0}; using closest threshold found {1}.\"",
   ".",
   "format",
   "(",
   "threshold",
   ",",
   "closest_threshold",
   ")",
   ")",
   "return",
   "closest_idx",
   "raise",
   "ValueError",
   "(",
   "\"Threshold must be between 0 and 1, but got {0} \"",
   ".",
   "format",
   "(",
   "threshold",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1087",
  "nl_tokens": [
   "Compute",
   "the",
   "inverse",
   "constant",
   "-",
   "Q",
   "transform",
   "."
  ],
  "pl_tokens": [
   "def",
   "icqt",
   "(",
   "C",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "fmin",
   "=",
   "None",
   ",",
   "bins_per_octave",
   "=",
   "12",
   ",",
   "tuning",
   "=",
   "0.0",
   ",",
   "filter_scale",
   "=",
   "1",
   ",",
   "norm",
   "=",
   "1",
   ",",
   "sparsity",
   "=",
   "0.01",
   ",",
   "window",
   "=",
   "'hann'",
   ",",
   "scale",
   "=",
   "True",
   ",",
   "length",
   "=",
   "None",
   ",",
   "amin",
   "=",
   "util",
   ".",
   "Deprecated",
   "(",
   ")",
   ",",
   "res_type",
   "=",
   "'fft'",
   ")",
   ":",
   "if",
   "fmin",
   "is",
   "None",
   ":",
   "fmin",
   "=",
   "note_to_hz",
   "(",
   "'C1'",
   ")",
   "# Get the top octave of frequencies",
   "n_bins",
   "=",
   "len",
   "(",
   "C",
   ")",
   "freqs",
   "=",
   "cqt_frequencies",
   "(",
   "n_bins",
   ",",
   "fmin",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ")",
   "[",
   "-",
   "bins_per_octave",
   ":",
   "]",
   "n_filters",
   "=",
   "<mask>",
   "(",
   "n_bins",
   ",",
   "bins_per_octave",
   ")",
   "fft_basis",
   ",",
   "n_fft",
   ",",
   "lengths",
   "=",
   "__cqt_filter_fft",
   "(",
   "sr",
   ",",
   "np",
   ".",
   "min",
   "(",
   "freqs",
   ")",
   ",",
   "n_filters",
   ",",
   "bins_per_octave",
   ",",
   "tuning",
   ",",
   "filter_scale",
   ",",
   "norm",
   ",",
   "sparsity",
   "=",
   "sparsity",
   ",",
   "window",
   "=",
   "window",
   ")",
   "if",
   "hop_length",
   ">",
   "min",
   "(",
   "lengths",
   ")",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "'hop_length={} exceeds minimum CQT filter length={:.3f}.\\n'",
   "'This will probably cause unpleasant acoustic artifacts. '",
   "'Consider decreasing your hop length or increasing the frequency resolution of your CQT.'",
   ".",
   "format",
   "(",
   "hop_length",
   ",",
   "min",
   "(",
   "lengths",
   ")",
   ")",
   ")",
   "# The basis gets renormalized by the effective window length above;",
   "# This step undoes that",
   "fft_basis",
   "=",
   "fft_basis",
   ".",
   "todense",
   "(",
   ")",
   "*",
   "n_fft",
   "/",
   "lengths",
   "[",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "# This step conjugate-transposes the filter",
   "inv_basis",
   "=",
   "fft_basis",
   ".",
   "H",
   "# How many octaves do we have?",
   "n_octaves",
   "=",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "float",
   "(",
   "n_bins",
   ")",
   "/",
   "bins_per_octave",
   ")",
   ")",
   "y",
   "=",
   "None",
   "for",
   "octave",
   "in",
   "range",
   "(",
   "n_octaves",
   "-",
   "1",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   ":",
   "slice_",
   "=",
   "slice",
   "(",
   "-",
   "(",
   "octave",
   "+",
   "1",
   ")",
   "*",
   "bins_per_octave",
   "-",
   "1",
   ",",
   "-",
   "(",
   "octave",
   ")",
   "*",
   "bins_per_octave",
   "-",
   "1",
   ")",
   "# Slice this octave",
   "C_oct",
   "=",
   "C",
   "[",
   "slice_",
   "]",
   "inv_oct",
   "=",
   "inv_basis",
   "[",
   ":",
   ",",
   "-",
   "C_oct",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   "]",
   "oct_hop",
   "=",
   "hop_length",
   "//",
   "2",
   "**",
   "octave",
   "# Apply energy corrections",
   "if",
   "scale",
   ":",
   "C_scale",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "lengths",
   "[",
   "-",
   "C_oct",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   ")",
   "/",
   "n_fft",
   "else",
   ":",
   "C_scale",
   "=",
   "lengths",
   "[",
   "-",
   "C_oct",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "*",
   "np",
   ".",
   "sqrt",
   "(",
   "2",
   "**",
   "octave",
   ")",
   "/",
   "n_fft",
   "# Inverse-project the basis for each octave",
   "D_oct",
   "=",
   "inv_oct",
   ".",
   "dot",
   "(",
   "C_oct",
   "/",
   "C_scale",
   ")",
   "# Inverse-STFT that response",
   "y_oct",
   "=",
   "istft",
   "(",
   "D_oct",
   ",",
   "window",
   "=",
   "'ones'",
   ",",
   "hop_length",
   "=",
   "oct_hop",
   ")",
   "# Up-sample that octave",
   "if",
   "y",
   "is",
   "None",
   ":",
   "y",
   "=",
   "y_oct",
   "else",
   ":",
   "# Up-sample the previous buffer and add in the new one",
   "# Scipy-resampling is fast here, since it's a power-of-two relation",
   "y",
   "=",
   "audio",
   ".",
   "resample",
   "(",
   "y",
   ",",
   "1",
   ",",
   "2",
   ",",
   "scale",
   "=",
   "True",
   ",",
   "res_type",
   "=",
   "res_type",
   ",",
   "fix",
   "=",
   "False",
   ")",
   "y",
   "[",
   ":",
   "len",
   "(",
   "y_oct",
   ")",
   "]",
   "+=",
   "y_oct",
   "if",
   "length",
   ":",
   "y",
   "=",
   "util",
   ".",
   "fix_length",
   "(",
   "y",
   ",",
   "length",
   ")",
   "return",
   "y"
  ]
 },
 {
  "idx": "maxmin-1088",
  "nl_tokens": [
   "Resolve",
   "name",
   "for",
   "process",
   "and",
   "mark",
   "outputs",
   "of",
   "statemens",
   "as",
   "not",
   "hidden"
  ],
  "pl_tokens": [
   "def",
   "name_for_process_and_mark_outputs",
   "(",
   "statements",
   ":",
   "List",
   "[",
   "HdlStatement",
   "]",
   ")",
   "->",
   "str",
   ":",
   "out_names",
   "=",
   "[",
   "]",
   "for",
   "stm",
   "in",
   "statements",
   ":",
   "for",
   "sig",
   "in",
   "stm",
   ".",
   "_outputs",
   ":",
   "if",
   "not",
   "sig",
   ".",
   "hasGenericName",
   ":",
   "out_names",
   ".",
   "append",
   "(",
   "sig",
   ".",
   "name",
   ")",
   "if",
   "out_names",
   ":",
   "return",
   "<mask>",
   "(",
   "out_names",
   ")",
   "else",
   ":",
   "return",
   "\"\""
  ]
 },
 {
  "idx": "maxmin-1089",
  "nl_tokens": [
   "Estimate",
   "local",
   "FDR",
   "/",
   "posterior",
   "error",
   "probability",
   "from",
   "p",
   "-",
   "values",
   "according",
   "to",
   "bioconductor",
   "/",
   "qvalue"
  ],
  "pl_tokens": [
   "def",
   "lfdr",
   "(",
   "p_values",
   ",",
   "pi0",
   ",",
   "trunc",
   "=",
   "True",
   ",",
   "monotone",
   "=",
   "True",
   ",",
   "transf",
   "=",
   "\"probit\"",
   ",",
   "adj",
   "=",
   "1.5",
   ",",
   "eps",
   "=",
   "np",
   ".",
   "power",
   "(",
   "10.0",
   ",",
   "-",
   "8",
   ")",
   ")",
   ":",
   "p",
   "=",
   "np",
   ".",
   "array",
   "(",
   "p_values",
   ")",
   "# Compare to bioconductor/qvalue reference implementation",
   "# import rpy2",
   "# import rpy2.robjects as robjects",
   "# from rpy2.robjects import pandas2ri",
   "# pandas2ri.activate()",
   "# density=robjects.r('density')",
   "# smoothspline=robjects.r('smooth.spline')",
   "# predict=robjects.r('predict')",
   "# Check inputs",
   "lfdr_out",
   "=",
   "p",
   "rm_na",
   "=",
   "np",
   ".",
   "isfinite",
   "(",
   "p",
   ")",
   "p",
   "=",
   "p",
   "[",
   "rm_na",
   "]",
   "if",
   "(",
   "<mask>",
   "(",
   "p",
   ")",
   "<",
   "0",
   "or",
   "max",
   "(",
   "p",
   ")",
   ">",
   "1",
   ")",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"p-values not in valid range [0,1].\"",
   ")",
   "elif",
   "(",
   "pi0",
   "<",
   "0",
   "or",
   "pi0",
   ">",
   "1",
   ")",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"pi0 not in valid range [0,1].\"",
   ")",
   "# Local FDR method for both probit and logit transformations",
   "if",
   "(",
   "transf",
   "==",
   "\"probit\"",
   ")",
   ":",
   "p",
   "=",
   "np",
   ".",
   "maximum",
   "(",
   "p",
   ",",
   "eps",
   ")",
   "p",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "p",
   ",",
   "1",
   "-",
   "eps",
   ")",
   "x",
   "=",
   "scipy",
   ".",
   "stats",
   ".",
   "norm",
   ".",
   "ppf",
   "(",
   "p",
   ",",
   "loc",
   "=",
   "0",
   ",",
   "scale",
   "=",
   "1",
   ")",
   "# R-like implementation",
   "bw",
   "=",
   "bw_nrd0",
   "(",
   "x",
   ")",
   "myd",
   "=",
   "KDEUnivariate",
   "(",
   "x",
   ")",
   "myd",
   ".",
   "fit",
   "(",
   "bw",
   "=",
   "adj",
   "*",
   "bw",
   ",",
   "gridsize",
   "=",
   "512",
   ")",
   "splinefit",
   "=",
   "sp",
   ".",
   "interpolate",
   ".",
   "splrep",
   "(",
   "myd",
   ".",
   "support",
   ",",
   "myd",
   ".",
   "density",
   ")",
   "y",
   "=",
   "sp",
   ".",
   "interpolate",
   ".",
   "splev",
   "(",
   "x",
   ",",
   "splinefit",
   ")",
   "# myd = density(x, adjust = 1.5) # R reference function",
   "# mys = smoothspline(x = myd.rx2('x'), y = myd.rx2('y')) # R reference function",
   "# y = predict(mys, x).rx2('y') # R reference function",
   "lfdr",
   "=",
   "pi0",
   "*",
   "scipy",
   ".",
   "stats",
   ".",
   "norm",
   ".",
   "pdf",
   "(",
   "x",
   ")",
   "/",
   "y",
   "elif",
   "(",
   "transf",
   "==",
   "\"logit\"",
   ")",
   ":",
   "x",
   "=",
   "np",
   ".",
   "log",
   "(",
   "(",
   "p",
   "+",
   "eps",
   ")",
   "/",
   "(",
   "1",
   "-",
   "p",
   "+",
   "eps",
   ")",
   ")",
   "# R-like implementation",
   "bw",
   "=",
   "bw_nrd0",
   "(",
   "x",
   ")",
   "myd",
   "=",
   "KDEUnivariate",
   "(",
   "x",
   ")",
   "myd",
   ".",
   "fit",
   "(",
   "bw",
   "=",
   "adj",
   "*",
   "bw",
   ",",
   "gridsize",
   "=",
   "512",
   ")",
   "splinefit",
   "=",
   "sp",
   ".",
   "interpolate",
   ".",
   "splrep",
   "(",
   "myd",
   ".",
   "support",
   ",",
   "myd",
   ".",
   "density",
   ")",
   "y",
   "=",
   "sp",
   ".",
   "interpolate",
   ".",
   "splev",
   "(",
   "x",
   ",",
   "splinefit",
   ")",
   "# myd = density(x, adjust = 1.5) # R reference function",
   "# mys = smoothspline(x = myd.rx2('x'), y = myd.rx2('y')) # R reference function",
   "# y = predict(mys, x).rx2('y') # R reference function",
   "dx",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "x",
   ")",
   "/",
   "np",
   ".",
   "power",
   "(",
   "(",
   "1",
   "+",
   "np",
   ".",
   "exp",
   "(",
   "x",
   ")",
   ")",
   ",",
   "2",
   ")",
   "lfdr",
   "=",
   "(",
   "pi0",
   "*",
   "dx",
   ")",
   "/",
   "y",
   "else",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"Invalid local FDR method.\"",
   ")",
   "if",
   "(",
   "trunc",
   ")",
   ":",
   "lfdr",
   "[",
   "lfdr",
   ">",
   "1",
   "]",
   "=",
   "1",
   "if",
   "(",
   "monotone",
   ")",
   ":",
   "lfdr",
   "=",
   "lfdr",
   "[",
   "p",
   ".",
   "ravel",
   "(",
   ")",
   ".",
   "argsort",
   "(",
   ")",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "x",
   ")",
   ")",
   ":",
   "if",
   "(",
   "lfdr",
   "[",
   "i",
   "]",
   "<",
   "lfdr",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   ":",
   "lfdr",
   "[",
   "i",
   "]",
   "=",
   "lfdr",
   "[",
   "i",
   "-",
   "1",
   "]",
   "lfdr",
   "=",
   "lfdr",
   "[",
   "scipy",
   ".",
   "stats",
   ".",
   "rankdata",
   "(",
   "p",
   ",",
   "\"min\"",
   ")",
   "-",
   "1",
   "]",
   "lfdr_out",
   "[",
   "rm_na",
   "]",
   "=",
   "lfdr",
   "return",
   "lfdr_out"
  ]
 },
 {
  "idx": "maxmin-1090",
  "nl_tokens": [
   "Create",
   "a",
   "new",
   "secret",
   "link",
   "."
  ],
  "pl_tokens": [
   "def",
   "create",
   "(",
   "cls",
   ",",
   "title",
   ",",
   "owner",
   ",",
   "extra_data",
   ",",
   "description",
   "=",
   "\"\"",
   ",",
   "expires_at",
   "=",
   "None",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "expires_at",
   ",",
   "date",
   ")",
   ":",
   "expires_at",
   "=",
   "datetime",
   ".",
   "combine",
   "(",
   "expires_at",
   ",",
   "datetime",
   ".",
   "<mask>",
   ".",
   "time",
   "(",
   ")",
   ")",
   "with",
   "db",
   ".",
   "session",
   ".",
   "begin_nested",
   "(",
   ")",
   ":",
   "obj",
   "=",
   "cls",
   "(",
   "owner",
   "=",
   "owner",
   ",",
   "title",
   "=",
   "title",
   ",",
   "description",
   "=",
   "description",
   ",",
   "expires_at",
   "=",
   "expires_at",
   ",",
   "token",
   "=",
   "''",
   ",",
   ")",
   "db",
   ".",
   "session",
   ".",
   "add",
   "(",
   "obj",
   ")",
   "with",
   "db",
   ".",
   "session",
   ".",
   "begin_nested",
   "(",
   ")",
   ":",
   "# Create token (dependent on obj.id and recid)",
   "obj",
   ".",
   "token",
   "=",
   "SecretLinkFactory",
   ".",
   "create_token",
   "(",
   "obj",
   ".",
   "id",
   ",",
   "extra_data",
   ",",
   "expires_at",
   "=",
   "expires_at",
   ")",
   ".",
   "decode",
   "(",
   "'utf8'",
   ")",
   "link_created",
   ".",
   "send",
   "(",
   "obj",
   ")",
   "return",
   "obj"
  ]
 },
 {
  "idx": "maxmin-1091",
  "nl_tokens": [
   "A",
   "pure",
   "-",
   "Python",
   "implementation",
   "of",
   "the",
   "Matlab",
   "code",
   "http",
   ":",
   "//",
   "www",
   ".",
   "santafe",
   ".",
   "edu",
   "/",
   "~aaronc",
   "/",
   "powerlaws",
   "/",
   "plfit",
   ".",
   "m",
   "from",
   "http",
   ":",
   "//",
   "www",
   ".",
   "santafe",
   ".",
   "edu",
   "/",
   "~aaronc",
   "/",
   "powerlaws",
   "/"
  ],
  "pl_tokens": [
   "def",
   "plfit",
   "(",
   "self",
   ",",
   "nosmall",
   "=",
   "True",
   ",",
   "finite",
   "=",
   "False",
   ",",
   "quiet",
   "=",
   "False",
   ",",
   "silent",
   "=",
   "False",
   ",",
   "xmin",
   "=",
   "None",
   ",",
   "verbose",
   "=",
   "False",
   ")",
   ":",
   "x",
   "=",
   "self",
   ".",
   "data",
   "z",
   "=",
   "sorted",
   "(",
   "x",
   ")",
   "t",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "possible_xmins",
   "=",
   "sorted",
   "(",
   "set",
   "(",
   "z",
   ")",
   ")",
   "argxmins",
   "=",
   "[",
   "z",
   ".",
   "index",
   "(",
   "i",
   ")",
   "for",
   "i",
   "in",
   "possible_xmins",
   "]",
   "self",
   ".",
   "_nunique",
   "=",
   "len",
   "(",
   "possible_xmins",
   ")",
   "if",
   "xmin",
   "is",
   "None",
   ":",
   "av",
   "=",
   "map",
   "(",
   "self",
   ".",
   "alpha_",
   "(",
   "z",
   ")",
   ",",
   "possible_xmins",
   ")",
   "dat",
   "=",
   "map",
   "(",
   "self",
   ".",
   "kstest_",
   "(",
   "z",
   ")",
   ",",
   "possible_xmins",
   ")",
   "sigma",
   "=",
   "[",
   "(",
   "a",
   "-",
   "1",
   ")",
   "/",
   "math",
   ".",
   "sqrt",
   "(",
   "len",
   "(",
   "z",
   ")",
   "-",
   "i",
   "+",
   "1",
   ")",
   "for",
   "a",
   ",",
   "i",
   "in",
   "zip",
   "(",
   "av",
   ",",
   "argxmins",
   ")",
   "]",
   "if",
   "nosmall",
   ":",
   "# test to make sure the number of data points is high enough",
   "# to provide a reasonable s/n on the computed alpha",
   "goodvals",
   "=",
   "[",
   "s",
   "<",
   "0.1",
   "for",
   "s",
   "in",
   "sigma",
   "]",
   "if",
   "False",
   "in",
   "goodvals",
   ":",
   "nmax",
   "=",
   "goodvals",
   ".",
   "index",
   "(",
   "False",
   ")",
   "dat",
   "=",
   "dat",
   "[",
   ":",
   "nmax",
   "]",
   "possible_xmins",
   "=",
   "possible_xmins",
   "[",
   ":",
   "nmax",
   "]",
   "av",
   "=",
   "av",
   "[",
   ":",
   "nmax",
   "]",
   "else",
   ":",
   "print",
   "(",
   "\"Not enough data left after flagging - using all positive data.\"",
   ")",
   "if",
   "not",
   "quiet",
   ":",
   "print",
   "(",
   "\"PYTHON plfit executed in %f seconds\"",
   "%",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "t",
   ")",
   ")",
   "self",
   ".",
   "_av",
   "=",
   "av",
   "self",
   ".",
   "_xmin_kstest",
   "=",
   "dat",
   "self",
   ".",
   "_sigma",
   "=",
   "sigma",
   "# [:-1] to weed out the very last data point; it cannot be correct",
   "# (can't have a power law with 1 data point).",
   "# However, this should only be done if the ends have not previously",
   "# been excluded with nosmall",
   "if",
   "nosmall",
   ":",
   "xmin",
   "=",
   "possible_xmins",
   "[",
   "dat",
   ".",
   "index",
   "(",
   "<mask>",
   "(",
   "dat",
   ")",
   ")",
   "]",
   "else",
   ":",
   "xmin",
   "=",
   "possible_xmins",
   "[",
   "dat",
   ".",
   "index",
   "(",
   "min",
   "(",
   "dat",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   ")",
   "]",
   "z",
   "=",
   "[",
   "i",
   "for",
   "i",
   "in",
   "z",
   "if",
   "i",
   ">=",
   "xmin",
   "]",
   "n",
   "=",
   "len",
   "(",
   "z",
   ")",
   "alpha",
   "=",
   "1",
   "+",
   "n",
   "/",
   "sum",
   "(",
   "[",
   "math",
   ".",
   "log",
   "(",
   "a",
   "/",
   "xmin",
   ")",
   "for",
   "a",
   "in",
   "z",
   "]",
   ")",
   "if",
   "finite",
   ":",
   "alpha",
   "=",
   "alpha",
   "*",
   "(",
   "n",
   "-",
   "1.",
   ")",
   "/",
   "n",
   "+",
   "1.",
   "/",
   "n",
   "if",
   "n",
   "==",
   "1",
   "and",
   "not",
   "silent",
   ":",
   "print",
   "(",
   "\"Failure: only 1 point kept.  Probably not a power-law distribution.\"",
   ")",
   "self",
   ".",
   "_alpha",
   "=",
   "0",
   "self",
   ".",
   "_alphaerr",
   "=",
   "0",
   "self",
   ".",
   "_likelihood",
   "=",
   "0",
   "self",
   ".",
   "_ks",
   "=",
   "0",
   "self",
   ".",
   "_ks_prob",
   "=",
   "0",
   "self",
   ".",
   "_xmin",
   "=",
   "xmin",
   "return",
   "xmin",
   ",",
   "0",
   "if",
   "n",
   "<",
   "50",
   "and",
   "not",
   "finite",
   "and",
   "not",
   "silent",
   ":",
   "print",
   "(",
   "'(PLFIT) Warning: finite-size bias may be present. n=%i'",
   "%",
   "n",
   ")",
   "# ks = max(abs( numpy.arange(n)/float(n) - (1-(xmin/z)**(alpha-1)) ))",
   "ks",
   "=",
   "max",
   "(",
   "[",
   "abs",
   "(",
   "i",
   "/",
   "float",
   "(",
   "n",
   ")",
   "-",
   "(",
   "1",
   "-",
   "(",
   "xmin",
   "/",
   "b",
   ")",
   "**",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   ")",
   ")",
   "for",
   "i",
   ",",
   "b",
   "in",
   "zip",
   "(",
   "range",
   "(",
   "n",
   ")",
   ",",
   "z",
   ")",
   "]",
   ")",
   "# Parallels Eqn 3.5 in Clauset et al 2009, but zeta(alpha, xmin) = (alpha-1)/xmin.  Really is Eqn B3 in paper.",
   "#L = n*log((alpha-1)/xmin) - alpha*sum(log(z/xmin))",
   "sl",
   "=",
   "sum",
   "(",
   "[",
   "math",
   ".",
   "log",
   "(",
   "a",
   "/",
   "xmin",
   ")",
   "for",
   "a",
   "in",
   "z",
   "]",
   ")",
   "L",
   "=",
   "(",
   "n",
   "*",
   "math",
   ".",
   "log",
   "(",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   ")",
   "-",
   "alpha",
   "*",
   "sl",
   ")",
   "#requires another map... Larr = arange(len(unique(x))) * log((av-1)/unique(x)) - av*sum",
   "self",
   ".",
   "_likelihood",
   "=",
   "L",
   "self",
   ".",
   "_xmin",
   "=",
   "xmin",
   "self",
   ".",
   "_xmins",
   "=",
   "possible_xmins",
   "self",
   ".",
   "_alpha",
   "=",
   "alpha",
   "self",
   ".",
   "_alphaerr",
   "=",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "math",
   ".",
   "sqrt",
   "(",
   "n",
   ")",
   "self",
   ".",
   "_ks",
   "=",
   "ks",
   "# this ks statistic may not have the same value as min(dat) because of unique()",
   "#if scipyOK: self._ks_prob = scipy.stats.kstwobign.sf(ks*numpy.sqrt(n))",
   "self",
   ".",
   "_ngtx",
   "=",
   "n",
   "if",
   "math",
   ".",
   "isnan",
   "(",
   "L",
   ")",
   "or",
   "math",
   ".",
   "isnan",
   "(",
   "xmin",
   ")",
   "or",
   "math",
   ".",
   "isnan",
   "(",
   "alpha",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"plfit failed; returned a nan\"",
   ")",
   "if",
   "not",
   "quiet",
   ":",
   "if",
   "verbose",
   ":",
   "print",
   "(",
   "\"The lowest value included in the power-law fit, \"",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "print",
   "(",
   "\"xmin: %g\"",
   "%",
   "xmin",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "if",
   "verbose",
   ":",
   "print",
   "(",
   "\"\\nThe number of values above xmin, \"",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "print",
   "(",
   "\"n(>xmin): %i\"",
   "%",
   "n",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "if",
   "verbose",
   ":",
   "print",
   "(",
   "\"\\nThe derived power-law alpha (p(x)~x^-alpha) with MLE-derived error, \"",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "print",
   "(",
   "\"alpha: %g +/- %g  \"",
   "%",
   "(",
   "alpha",
   ",",
   "self",
   ".",
   "_alphaerr",
   ")",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "if",
   "verbose",
   ":",
   "print",
   "(",
   "\"\\nThe log of the Likelihood (the maximized parameter), \"",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "print",
   "(",
   "\"Log-Likelihood: %g  \"",
   "%",
   "L",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "if",
   "verbose",
   ":",
   "print",
   "(",
   "\"\\nThe KS-test statistic between the best-fit power-law and the data, \"",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "print",
   "(",
   "\"ks: %g\"",
   "%",
   "(",
   "ks",
   ")",
   ")",
   "return",
   "xmin",
   ",",
   "alpha"
  ]
 },
 {
  "idx": "maxmin-1092",
  "nl_tokens": [
   "Calculates",
   "the",
   "settlement",
   "of",
   "a",
   "shallow",
   "foundation",
   "(",
   "Schmertmann",
   "19XX",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "settlement_schmertmann",
   "(",
   "sp",
   ",",
   "fd",
   ",",
   "load",
   ",",
   "youngs_modulus_soil",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "length",
   "=",
   "float",
   "(",
   "fd",
   ".",
   "length",
   ")",
   "breadth",
   "=",
   "float",
   "(",
   "fd",
   ".",
   "width",
   ")",
   "depth",
   "=",
   "float",
   "(",
   "fd",
   ".",
   "depth",
   ")",
   "load",
   "=",
   "float",
   "(",
   "load",
   ")",
   "sp",
   ".",
   "gwl",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"gwl\"",
   ",",
   "sp",
   ".",
   "gwl",
   ")",
   "sp",
   ".",
   "unit_sat_weight",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"unit_sat_weight\"",
   ",",
   "sp",
   ".",
   "unit_sat_weight",
   ")",
   "verbose",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"verbose\"",
   ",",
   "0",
   ")",
   "years",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"years\"",
   ",",
   "0",
   ")",
   "q",
   "=",
   "load",
   "/",
   "(",
   "length",
   "*",
   "breadth",
   ")",
   "sigma_v0_eff",
   "=",
   "(",
   "sp",
   ".",
   "unit_dry_weight",
   "*",
   "<mask>",
   "(",
   "depth",
   ",",
   "sp",
   ".",
   "gwl",
   ")",
   "+",
   "(",
   "sp",
   ".",
   "unit_sat_weight",
   "-",
   "9.8",
   ")",
   "*",
   "max",
   "(",
   "[",
   "0",
   ",",
   "depth",
   "-",
   "sp",
   ".",
   "gwl",
   "]",
   ")",
   ")",
   "delta_q",
   "=",
   "q",
   "-",
   "sigma_v0_eff",
   "# EMBEDMENT FACTOR",
   "c_1",
   "=",
   "max",
   "(",
   "1",
   "-",
   "0.5",
   "*",
   "(",
   "sigma_v0_eff",
   "/",
   "delta_q",
   ")",
   ",",
   "0.5",
   ")",
   "# CREEP FACTOR",
   "if",
   "years",
   "==",
   "0",
   ":",
   "c_2",
   "=",
   "1.0",
   "else",
   ":",
   "c_2",
   "=",
   "1.0",
   "+",
   "0.2",
   "*",
   "np",
   ".",
   "log10",
   "(",
   "years",
   "/",
   "0.1",
   ")",
   "# SHAPE FACTOR",
   "long",
   "=",
   "max",
   "(",
   "length",
   ",",
   "breadth",
   ")",
   "short",
   "=",
   "min",
   "(",
   "length",
   ",",
   "breadth",
   ")",
   "c_3",
   "=",
   "max",
   "(",
   "1.03",
   "-",
   "0.03",
   "*",
   "(",
   "long",
   "/",
   "short",
   ")",
   ",",
   "0.73",
   ")",
   "# Peak settlement index",
   "if",
   "long",
   "/",
   "short",
   ">",
   "10",
   ":",
   "zp",
   "=",
   "short",
   "+",
   "depth",
   "z_top",
   "=",
   "0.2",
   "z_bottom",
   "=",
   "4",
   "*",
   "short",
   "+",
   "depth",
   "else",
   ":",
   "z_top",
   "=",
   "0.1",
   "zp",
   "=",
   "0.5",
   "*",
   "short",
   "+",
   "depth",
   "z_bottom",
   "=",
   "2",
   "*",
   "short",
   "+",
   "depth",
   "sigma_vp_eff",
   "=",
   "(",
   "sp",
   ".",
   "unit_dry_weight",
   "*",
   "min",
   "(",
   "zp",
   ",",
   "sp",
   ".",
   "gwl",
   ")",
   "+",
   "(",
   "sp",
   ".",
   "unit_sat_weight",
   "-",
   "9.8",
   ")",
   "*",
   "max",
   "(",
   "[",
   "0",
   ",",
   "zp",
   "-",
   "sp",
   ".",
   "gwl",
   "]",
   ")",
   ")",
   "i_zp",
   "=",
   "0.5",
   "+",
   "0.1",
   "*",
   "(",
   "delta_q",
   "/",
   "sigma_vp_eff",
   ")",
   "**",
   "0.5",
   "i_z_top",
   "=",
   "(",
   "i_zp",
   "+",
   "z_top",
   ")",
   "/",
   "2",
   "i_z_bottom",
   "=",
   "i_zp",
   "/",
   "2",
   "settlement",
   "=",
   "(",
   "c_1",
   "*",
   "c_2",
   "*",
   "c_3",
   "*",
   "delta_q",
   "*",
   "(",
   "i_z_top",
   "*",
   "(",
   "zp",
   "-",
   "depth",
   ")",
   "+",
   "i_z_bottom",
   "*",
   "(",
   "z_bottom",
   "-",
   "zp",
   ")",
   ")",
   "/",
   "youngs_modulus_soil",
   ")",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"delta_q:\"",
   ",",
   "delta_q",
   ")",
   "log",
   "(",
   "\"c_1:\"",
   ",",
   "c_1",
   ")",
   "log",
   "(",
   "\"c_2:\"",
   ",",
   "c_2",
   ")",
   "log",
   "(",
   "\"c_3:\"",
   ",",
   "c_3",
   ")",
   "log",
   "(",
   "\"zp:\"",
   ",",
   "zp",
   ")",
   "log",
   "(",
   "\"sigma_vp_eff:\"",
   ",",
   "sigma_vp_eff",
   ")",
   "log",
   "(",
   "\"i_zp:\"",
   ",",
   "i_zp",
   ")",
   "log",
   "(",
   "\"i_z_top:\"",
   ",",
   "i_z_top",
   ")",
   "log",
   "(",
   "\"i_z_bottom:\"",
   ",",
   "i_z_bottom",
   ")",
   "log",
   "(",
   "\"settlement:\"",
   ",",
   "settlement",
   ")",
   "return",
   "settlement"
  ]
 },
 {
  "idx": "maxmin-1093",
  "nl_tokens": [
   "Compute",
   "the",
   "max",
   "-",
   "envelope",
   "of",
   "x",
   "at",
   "a",
   "stride",
   "/",
   "frame",
   "length",
   "of",
   "h"
  ],
  "pl_tokens": [
   "def",
   "__envelope",
   "(",
   "x",
   ",",
   "hop",
   ")",
   ":",
   "return",
   "util",
   ".",
   "frame",
   "(",
   "x",
   ",",
   "hop_length",
   "=",
   "hop",
   ",",
   "frame_length",
   "=",
   "hop",
   ")",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "0",
   ")"
  ]
 },
 {
  "idx": "maxmin-1094",
  "nl_tokens": [
   "Hands",
   "-",
   "free",
   "plotting",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot",
   "(",
   "self",
   ",",
   "legend",
   "=",
   "None",
   ",",
   "width",
   "=",
   "1.5",
   ",",
   "ladder",
   "=",
   "True",
   ",",
   "aspect",
   "=",
   "10",
   ",",
   "ticks",
   "=",
   "(",
   "1",
   ",",
   "10",
   ")",
   ",",
   "match_only",
   "=",
   "None",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "return_fig",
   "=",
   "False",
   ",",
   "colour",
   "=",
   "None",
   ",",
   "cmap",
   "=",
   "'viridis'",
   ",",
   "default",
   "=",
   "None",
   ",",
   "style",
   "=",
   "'intervals'",
   ",",
   "field",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "legend",
   "is",
   "None",
   ":",
   "legend",
   "=",
   "Legend",
   ".",
   "random",
   "(",
   "self",
   ".",
   "components",
   ")",
   "if",
   "style",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'tops'",
   ":",
   "# Make sure width is at least 3 for 'tops' style",
   "width",
   "=",
   "<mask>",
   "(",
   "[",
   "3",
   ",",
   "width",
   "]",
   ")",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "return_ax",
   "=",
   "False",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "width",
   ",",
   "aspect",
   "*",
   "width",
   ")",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.35",
   ",",
   "0.05",
   ",",
   "0.6",
   ",",
   "0.95",
   "]",
   ")",
   "else",
   ":",
   "return_ax",
   "=",
   "True",
   "if",
   "(",
   "self",
   ".",
   "order",
   "==",
   "'none'",
   ")",
   "or",
   "(",
   "style",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'points'",
   ")",
   ":",
   "# Then this is a set of points.",
   "ax",
   "=",
   "self",
   ".",
   "plot_points",
   "(",
   "ax",
   "=",
   "ax",
   ",",
   "legend",
   "=",
   "legend",
   ",",
   "field",
   "=",
   "field",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "elif",
   "style",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'field'",
   ":",
   "if",
   "field",
   "is",
   "None",
   ":",
   "raise",
   "StriplogError",
   "(",
   "'You must provide a field to plot.'",
   ")",
   "ax",
   "=",
   "self",
   ".",
   "plot_field",
   "(",
   "ax",
   "=",
   "ax",
   ",",
   "legend",
   "=",
   "legend",
   ",",
   "field",
   "=",
   "field",
   ")",
   "elif",
   "style",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "'tops'",
   ":",
   "ax",
   "=",
   "self",
   ".",
   "plot_tops",
   "(",
   "ax",
   "=",
   "ax",
   ",",
   "legend",
   "=",
   "legend",
   ",",
   "field",
   "=",
   "field",
   ")",
   "ax",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "else",
   ":",
   "ax",
   "=",
   "self",
   ".",
   "plot_axis",
   "(",
   "ax",
   "=",
   "ax",
   ",",
   "legend",
   "=",
   "legend",
   ",",
   "ladder",
   "=",
   "ladder",
   ",",
   "default_width",
   "=",
   "width",
   ",",
   "match_only",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'match_only'",
   ",",
   "match_only",
   ")",
   ",",
   "colour",
   "=",
   "colour",
   ",",
   "cmap",
   "=",
   "cmap",
   ",",
   "default",
   "=",
   "default",
   ",",
   "width_field",
   "=",
   "field",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "ax",
   ".",
   "set_xlim",
   "(",
   "[",
   "0",
   ",",
   "width",
   "]",
   ")",
   "ax",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "# Rely on interval order.",
   "lower",
   ",",
   "upper",
   "=",
   "self",
   "[",
   "-",
   "1",
   "]",
   ".",
   "base",
   ".",
   "z",
   ",",
   "self",
   "[",
   "0",
   "]",
   ".",
   "top",
   ".",
   "z",
   "rng",
   "=",
   "abs",
   "(",
   "upper",
   "-",
   "lower",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "[",
   "lower",
   ",",
   "upper",
   "]",
   ")",
   "# Make sure ticks is a tuple.",
   "try",
   ":",
   "ticks",
   "=",
   "tuple",
   "(",
   "ticks",
   ")",
   "except",
   "TypeError",
   ":",
   "ticks",
   "=",
   "(",
   "1",
   ",",
   "ticks",
   ")",
   "# Avoid MAXTICKS error.",
   "while",
   "rng",
   "/",
   "ticks",
   "[",
   "0",
   "]",
   ">",
   "250",
   ":",
   "mi",
   ",",
   "ma",
   "=",
   "10",
   "*",
   "ticks",
   "[",
   "0",
   "]",
   ",",
   "ticks",
   "[",
   "1",
   "]",
   "if",
   "ma",
   "<=",
   "mi",
   ":",
   "ma",
   "=",
   "10",
   "*",
   "mi",
   "ticks",
   "=",
   "(",
   "mi",
   ",",
   "ma",
   ")",
   "# Carry on plotting...",
   "minorLocator",
   "=",
   "mpl",
   ".",
   "ticker",
   ".",
   "MultipleLocator",
   "(",
   "ticks",
   "[",
   "0",
   "]",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_minor_locator",
   "(",
   "minorLocator",
   ")",
   "majorLocator",
   "=",
   "mpl",
   ".",
   "ticker",
   ".",
   "MultipleLocator",
   "(",
   "ticks",
   "[",
   "1",
   "]",
   ")",
   "majorFormatter",
   "=",
   "mpl",
   ".",
   "ticker",
   ".",
   "FormatStrFormatter",
   "(",
   "'%d'",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_major_locator",
   "(",
   "majorLocator",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_major_formatter",
   "(",
   "majorFormatter",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "'top'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "'right'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "spines",
   "[",
   "'bottom'",
   "]",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax",
   ".",
   "yaxis",
   ".",
   "set_ticks_position",
   "(",
   "'left'",
   ")",
   "ax",
   ".",
   "get_yaxis",
   "(",
   ")",
   ".",
   "set_tick_params",
   "(",
   "which",
   "=",
   "'both'",
   ",",
   "direction",
   "=",
   "'out'",
   ")",
   "# Optional title.",
   "title",
   "=",
   "getattr",
   "(",
   "self",
   ",",
   "'title'",
   ",",
   "None",
   ")",
   "if",
   "title",
   "is",
   "not",
   "None",
   ":",
   "ax",
   ".",
   "set_title",
   "(",
   "title",
   ")",
   "ax",
   ".",
   "patch",
   ".",
   "set_alpha",
   "(",
   "0",
   ")",
   "if",
   "return_ax",
   ":",
   "return",
   "ax",
   "elif",
   "return_fig",
   ":",
   "return",
   "fig",
   "else",
   ":",
   "return"
  ]
 },
 {
  "idx": "maxmin-1095",
  "nl_tokens": [
   "determine",
   "the",
   "position",
   "on",
   "the",
   "tree",
   "that",
   "minimizes",
   "the",
   "bilinear",
   "product",
   "of",
   "the",
   "inverse",
   "covariance",
   "and",
   "the",
   "data",
   "vectors",
   "."
  ],
  "pl_tokens": [
   "def",
   "find_best_root",
   "(",
   "self",
   ",",
   "force_positive",
   "=",
   "True",
   ",",
   "slope",
   "=",
   "None",
   ")",
   ":",
   "self",
   ".",
   "_calculate_averages",
   "(",
   ")",
   "best_root",
   "=",
   "{",
   "\"chisq\"",
   ":",
   "np",
   ".",
   "inf",
   "}",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "if",
   "n",
   "==",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ":",
   "continue",
   "tv",
   "=",
   "self",
   ".",
   "tip_value",
   "(",
   "n",
   ")",
   "bv",
   "=",
   "self",
   ".",
   "branch_value",
   "(",
   "n",
   ")",
   "var",
   "=",
   "self",
   ".",
   "branch_variance",
   "(",
   "n",
   ")",
   "x",
   ",",
   "chisq",
   "=",
   "self",
   ".",
   "_optimal_root_along_branch",
   "(",
   "n",
   ",",
   "tv",
   ",",
   "bv",
   ",",
   "var",
   ",",
   "slope",
   "=",
   "slope",
   ")",
   "if",
   "(",
   "chisq",
   "<",
   "best_root",
   "[",
   "\"chisq\"",
   "]",
   ")",
   ":",
   "tmpQ",
   "=",
   "self",
   ".",
   "propagate_averages",
   "(",
   "n",
   ",",
   "tv",
   ",",
   "bv",
   "*",
   "x",
   ",",
   "var",
   "*",
   "x",
   ")",
   "+",
   "self",
   ".",
   "propagate_averages",
   "(",
   "n",
   ",",
   "tv",
   ",",
   "bv",
   "*",
   "(",
   "1",
   "-",
   "x",
   ")",
   ",",
   "var",
   "*",
   "(",
   "1",
   "-",
   "x",
   ")",
   ",",
   "outgroup",
   "=",
   "True",
   ")",
   "reg",
   "=",
   "base_regression",
   "(",
   "tmpQ",
   ",",
   "slope",
   "=",
   "slope",
   ")",
   "if",
   "reg",
   "[",
   "\"slope\"",
   "]",
   ">=",
   "0",
   "or",
   "(",
   "force_positive",
   "==",
   "False",
   ")",
   ":",
   "best_root",
   "=",
   "{",
   "\"node\"",
   ":",
   "n",
   ",",
   "\"split\"",
   ":",
   "x",
   "}",
   "best_root",
   ".",
   "update",
   "(",
   "reg",
   ")",
   "if",
   "'node'",
   "not",
   "in",
   "best_root",
   ":",
   "print",
   "(",
   "\"TreeRegression.find_best_root: No valid root found!\"",
   ",",
   "force_positive",
   ")",
   "return",
   "None",
   "if",
   "'hessian'",
   "in",
   "best_root",
   ":",
   "# calculate differentials with respect to x",
   "deriv",
   "=",
   "[",
   "]",
   "n",
   "=",
   "best_root",
   "[",
   "\"node\"",
   "]",
   "tv",
   "=",
   "self",
   ".",
   "tip_value",
   "(",
   "n",
   ")",
   "bv",
   "=",
   "self",
   ".",
   "branch_value",
   "(",
   "n",
   ")",
   "var",
   "=",
   "self",
   ".",
   "branch_variance",
   "(",
   "n",
   ")",
   "for",
   "dx",
   "in",
   "[",
   "-",
   "0.001",
   ",",
   "0.001",
   "]",
   ":",
   "y",
   "=",
   "<mask>",
   "(",
   "1.0",
   ",",
   "max",
   "(",
   "0.0",
   ",",
   "best_root",
   "[",
   "\"split\"",
   "]",
   "+",
   "dx",
   ")",
   ")",
   "tmpQ",
   "=",
   "self",
   ".",
   "propagate_averages",
   "(",
   "n",
   ",",
   "tv",
   ",",
   "bv",
   "*",
   "y",
   ",",
   "var",
   "*",
   "y",
   ")",
   "+",
   "self",
   ".",
   "propagate_averages",
   "(",
   "n",
   ",",
   "tv",
   ",",
   "bv",
   "*",
   "(",
   "1",
   "-",
   "y",
   ")",
   ",",
   "var",
   "*",
   "(",
   "1",
   "-",
   "y",
   ")",
   ",",
   "outgroup",
   "=",
   "True",
   ")",
   "reg",
   "=",
   "base_regression",
   "(",
   "tmpQ",
   ",",
   "slope",
   "=",
   "slope",
   ")",
   "deriv",
   ".",
   "append",
   "(",
   "[",
   "y",
   ",",
   "reg",
   "[",
   "'chisq'",
   "]",
   ",",
   "tmpQ",
   "[",
   "tavgii",
   "]",
   ",",
   "tmpQ",
   "[",
   "davgii",
   "]",
   "]",
   ")",
   "estimator_hessian",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "(",
   "3",
   ",",
   "3",
   ")",
   ")",
   "estimator_hessian",
   "[",
   ":",
   "2",
   ",",
   ":",
   "2",
   "]",
   "=",
   "best_root",
   "[",
   "'hessian'",
   "]",
   "estimator_hessian",
   "[",
   "2",
   ",",
   "2",
   "]",
   "=",
   "(",
   "deriv",
   "[",
   "0",
   "]",
   "[",
   "1",
   "]",
   "+",
   "deriv",
   "[",
   "1",
   "]",
   "[",
   "1",
   "]",
   "-",
   "2.0",
   "*",
   "best_root",
   "[",
   "'chisq'",
   "]",
   ")",
   "/",
   "(",
   "deriv",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "-",
   "deriv",
   "[",
   "1",
   "]",
   "[",
   "0",
   "]",
   ")",
   "**",
   "2",
   "# estimator_hessian[2,0] = (deriv[0][2] - deriv[1][2])/(deriv[0][0] - deriv[1][0])",
   "# estimator_hessian[2,1] = (deriv[0][3] - deriv[1][3])/(deriv[0][0] - deriv[1][0])",
   "estimator_hessian",
   "[",
   "0",
   ",",
   "2",
   "]",
   "=",
   "estimator_hessian",
   "[",
   "2",
   ",",
   "0",
   "]",
   "estimator_hessian",
   "[",
   "1",
   ",",
   "2",
   "]",
   "=",
   "estimator_hessian",
   "[",
   "2",
   ",",
   "1",
   "]",
   "best_root",
   "[",
   "'hessian'",
   "]",
   "=",
   "estimator_hessian",
   "best_root",
   "[",
   "'cov'",
   "]",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "inv",
   "(",
   "estimator_hessian",
   ")",
   "return",
   "best_root"
  ]
 },
 {
  "idx": "maxmin-1096",
  "nl_tokens": [
   "Perform",
   "optimization",
   "for",
   "the",
   "branch",
   "lengths",
   "of",
   "the",
   "entire",
   "tree",
   ".",
   "This",
   "method",
   "only",
   "does",
   "a",
   "single",
   "path",
   "and",
   "needs",
   "to",
   "be",
   "iterated",
   "."
  ],
  "pl_tokens": [
   "def",
   "optimize_branch_length",
   "(",
   "self",
   ",",
   "mode",
   "=",
   "'joint'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeAnc.optimize_branch_length: running branch length optimization in mode %s...\"",
   "%",
   "mode",
   ",",
   "1",
   ")",
   "if",
   "(",
   "self",
   ".",
   "tree",
   "is",
   "None",
   ")",
   "or",
   "(",
   "self",
   ".",
   "aln",
   "is",
   "None",
   ")",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeAnc.optimize_branch_length: ERROR, alignment or tree are missing\"",
   ",",
   "0",
   ")",
   "return",
   "ttconf",
   ".",
   "ERROR",
   "store_old_dist",
   "=",
   "False",
   "if",
   "'store_old'",
   "in",
   "kwargs",
   ":",
   "store_old_dist",
   "=",
   "kwargs",
   "[",
   "'store_old'",
   "]",
   "if",
   "mode",
   "==",
   "'marginal'",
   ":",
   "# a marginal ancestral reconstruction is required for",
   "# marginal branch length inference",
   "if",
   "not",
   "hasattr",
   "(",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ",",
   "\"marginal_profile\"",
   ")",
   ":",
   "self",
   ".",
   "infer_ancestral_sequences",
   "(",
   "marginal",
   "=",
   "True",
   ")",
   "max_bl",
   "=",
   "0",
   "for",
   "node",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   "order",
   "=",
   "'postorder'",
   ")",
   ":",
   "if",
   "node",
   ".",
   "up",
   "is",
   "None",
   ":",
   "continue",
   "# this is the root",
   "if",
   "store_old_dist",
   ":",
   "node",
   ".",
   "_old_length",
   "=",
   "node",
   ".",
   "branch_length",
   "if",
   "mode",
   "==",
   "'marginal'",
   ":",
   "new_len",
   "=",
   "self",
   ".",
   "optimal_marginal_branch_length",
   "(",
   "node",
   ")",
   "elif",
   "mode",
   "==",
   "'joint'",
   ":",
   "new_len",
   "=",
   "self",
   ".",
   "optimal_branch_length",
   "(",
   "node",
   ")",
   "else",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"treeanc.optimize_branch_length: unsupported optimization mode\"",
   ",",
   "4",
   ",",
   "warn",
   "=",
   "True",
   ")",
   "new_len",
   "=",
   "node",
   ".",
   "branch_length",
   "if",
   "new_len",
   "<",
   "0",
   ":",
   "continue",
   "self",
   ".",
   "logger",
   "(",
   "\"Optimization results: old_len=%.4e, new_len=%.4e, naive=%.4e\"",
   "\" Updating branch length...\"",
   "%",
   "(",
   "node",
   ".",
   "branch_length",
   ",",
   "new_len",
   ",",
   "len",
   "(",
   "node",
   ".",
   "mutations",
   ")",
   "*",
   "self",
   ".",
   "one_mutation",
   ")",
   ",",
   "5",
   ")",
   "node",
   ".",
   "branch_length",
   "=",
   "new_len",
   "node",
   ".",
   "mutation_length",
   "=",
   "new_len",
   "max_bl",
   "=",
   "<mask>",
   "(",
   "max_bl",
   ",",
   "new_len",
   ")",
   "# as branch lengths changed, the params must be fixed",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "up",
   "=",
   "None",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "dist2root",
   "=",
   "0.0",
   "if",
   "max_bl",
   ">",
   "0.15",
   "and",
   "mode",
   "==",
   "'joint'",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"TreeAnc.optimize_branch_length: THIS TREE HAS LONG BRANCHES.\"",
   "\" \\n\\t ****TreeTime IS NOT DESIGNED TO OPTIMIZE LONG BRANCHES.\"",
   "\" \\n\\t ****PLEASE OPTIMIZE BRANCHES WITH ANOTHER TOOL AND RERUN WITH\"",
   "\" \\n\\t ****branch_length_mode='input'\"",
   ",",
   "0",
   ",",
   "warn",
   "=",
   "True",
   ")",
   "self",
   ".",
   "_prepare_nodes",
   "(",
   ")",
   "return",
   "ttconf",
   ".",
   "SUCCESS"
  ]
 },
 {
  "idx": "maxmin-1097",
  "nl_tokens": [
   "Gets",
   "the",
   "block",
   "-",
   "size",
   "for",
   "a",
   "given",
   "token",
   "at",
   "a",
   "given",
   "resolution",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_block_size",
   "(",
   "self",
   ",",
   "token",
   ",",
   "resolution",
   "=",
   "None",
   ")",
   ":",
   "cdims",
   "=",
   "self",
   ".",
   "get_metadata",
   "(",
   "token",
   ")",
   "[",
   "'dataset'",
   "]",
   "[",
   "'cube_dimension'",
   "]",
   "if",
   "resolution",
   "is",
   "None",
   ":",
   "resolution",
   "=",
   "<mask>",
   "(",
   "cdims",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "return",
   "cdims",
   "[",
   "str",
   "(",
   "resolution",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-1098",
  "nl_tokens": [
   "calculate",
   "H",
   "(",
   "t",
   ")",
   "=",
   "\\",
   "int_tau",
   "f",
   "(",
   "t",
   "-",
   "tau",
   ")",
   "g",
   "(",
   "tau",
   ")",
   "if",
   "inverse_time",
   "=",
   "True",
   "H",
   "(",
   "t",
   ")",
   "=",
   "\\",
   "int_tau",
   "f",
   "(",
   "t",
   "+",
   "tau",
   ")",
   "g",
   "(",
   "tau",
   ")",
   "if",
   "inverse_time",
   "=",
   "False"
  ],
  "pl_tokens": [
   "def",
   "convolve",
   "(",
   "cls",
   ",",
   "node_interp",
   ",",
   "branch_interp",
   ",",
   "max_or_integral",
   "=",
   "'integral'",
   ",",
   "n_grid_points",
   "=",
   "ttconf",
   ".",
   "NODE_GRID_SIZE",
   ",",
   "n_integral",
   "=",
   "ttconf",
   ".",
   "N_INTEGRAL",
   ",",
   "inverse_time",
   "=",
   "True",
   ",",
   "rel_tol",
   "=",
   "0.05",
   ",",
   "yc",
   "=",
   "10",
   ")",
   ":",
   "if",
   "max_or_integral",
   "not",
   "in",
   "[",
   "'max'",
   ",",
   "'integral'",
   "]",
   ":",
   "raise",
   "Exception",
   "(",
   "\"Max_or_integral expected to be 'max' or 'integral', got \"",
   "+",
   "str",
   "(",
   "max_or_integral",
   ")",
   "+",
   "\" instead.\"",
   ")",
   "def",
   "conv_in_point",
   "(",
   "time_point",
   ")",
   ":",
   "if",
   "max_or_integral",
   "==",
   "'integral'",
   ":",
   "# compute integral of the convolution",
   "return",
   "_evaluate_convolution",
   "(",
   "time_point",
   ",",
   "node_interp",
   ",",
   "branch_interp",
   ",",
   "n_integral",
   "=",
   "n_integral",
   ",",
   "return_log",
   "=",
   "True",
   ",",
   "inverse_time",
   "=",
   "inverse_time",
   ")",
   "else",
   ":",
   "# compute max of the convolution",
   "return",
   "_max_of_integrand",
   "(",
   "time_point",
   ",",
   "node_interp",
   ",",
   "branch_interp",
   ",",
   "return_log",
   "=",
   "True",
   ",",
   "inverse_time",
   "=",
   "inverse_time",
   ")",
   "# estimate peak and width",
   "joint_fwhm",
   "=",
   "(",
   "node_interp",
   ".",
   "fwhm",
   "+",
   "branch_interp",
   ".",
   "fwhm",
   ")",
   "min_fwhm",
   "=",
   "<mask>",
   "(",
   "node_interp",
   ".",
   "fwhm",
   ",",
   "branch_interp",
   ".",
   "fwhm",
   ")",
   "# determine support of the resulting convolution",
   "# in order to be positive, the flipped support of f, shifted by t and g need to overlap",
   "if",
   "inverse_time",
   ":",
   "new_peak_pos",
   "=",
   "node_interp",
   ".",
   "peak_pos",
   "+",
   "branch_interp",
   ".",
   "peak_pos",
   "tmin",
   "=",
   "node_interp",
   ".",
   "xmin",
   "+",
   "branch_interp",
   ".",
   "xmin",
   "tmax",
   "=",
   "node_interp",
   ".",
   "xmax",
   "+",
   "branch_interp",
   ".",
   "xmax",
   "else",
   ":",
   "new_peak_pos",
   "=",
   "node_interp",
   ".",
   "peak_pos",
   "-",
   "branch_interp",
   ".",
   "peak_pos",
   "tmin",
   "=",
   "node_interp",
   ".",
   "xmin",
   "-",
   "branch_interp",
   ".",
   "xmax",
   "tmax",
   "=",
   "node_interp",
   ".",
   "xmax",
   "-",
   "branch_interp",
   ".",
   "xmin",
   "# make initial node grid consisting of linearly spaced points around",
   "# the center and quadratically spaced points at either end",
   "n",
   "=",
   "n_grid_points",
   "/",
   "3",
   "center_width",
   "=",
   "3",
   "*",
   "joint_fwhm",
   "grid_center",
   "=",
   "new_peak_pos",
   "+",
   "np",
   ".",
   "linspace",
   "(",
   "-",
   "1",
   ",",
   "1",
   ",",
   "n",
   ")",
   "*",
   "center_width",
   "# add the right and left grid if it is needed",
   "right_range",
   "=",
   "(",
   "tmax",
   "-",
   "grid_center",
   "[",
   "-",
   "1",
   "]",
   ")",
   "if",
   "right_range",
   ">",
   "4",
   "*",
   "center_width",
   ":",
   "grid_right",
   "=",
   "grid_center",
   "[",
   "-",
   "1",
   "]",
   "+",
   "right_range",
   "*",
   "(",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "1",
   ",",
   "n",
   ")",
   "**",
   "2.0",
   ")",
   "elif",
   "right_range",
   ">",
   "0",
   ":",
   "# use linear grid the right_range is comparable to center_width",
   "grid_right",
   "=",
   "grid_center",
   "[",
   "-",
   "1",
   "]",
   "+",
   "right_range",
   "*",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "1",
   ",",
   "int",
   "(",
   "min",
   "(",
   "n",
   ",",
   "1",
   "+",
   "0.5",
   "*",
   "n",
   "*",
   "right_range",
   "/",
   "center_width",
   ")",
   ")",
   ")",
   "else",
   ":",
   "grid_right",
   "=",
   "[",
   "]",
   "left_range",
   "=",
   "grid_center",
   "[",
   "0",
   "]",
   "-",
   "tmin",
   "if",
   "left_range",
   ">",
   "4",
   "*",
   "center_width",
   ":",
   "grid_left",
   "=",
   "tmin",
   "+",
   "left_range",
   "*",
   "(",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "1",
   ",",
   "n",
   ")",
   "**",
   "2.0",
   ")",
   "elif",
   "left_range",
   ">",
   "0",
   ":",
   "grid_left",
   "=",
   "tmin",
   "+",
   "left_range",
   "*",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "1",
   ",",
   "int",
   "(",
   "min",
   "(",
   "n",
   ",",
   "1",
   "+",
   "0.5",
   "*",
   "n",
   "*",
   "left_range",
   "/",
   "center_width",
   ")",
   ")",
   ")",
   "else",
   ":",
   "grid_left",
   "=",
   "[",
   "]",
   "if",
   "tmin",
   ">",
   "-",
   "1",
   ":",
   "grid_zero_left",
   "=",
   "tmin",
   "+",
   "(",
   "tmax",
   "-",
   "tmin",
   ")",
   "*",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "0.01",
   ",",
   "11",
   ")",
   "**",
   "2",
   "else",
   ":",
   "grid_zero_left",
   "=",
   "[",
   "tmin",
   "]",
   "if",
   "tmax",
   "<",
   "1",
   ":",
   "grid_zero_right",
   "=",
   "tmax",
   "-",
   "(",
   "tmax",
   "-",
   "tmin",
   ")",
   "*",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "0.01",
   ",",
   "11",
   ")",
   "**",
   "2",
   "else",
   ":",
   "grid_zero_right",
   "=",
   "[",
   "tmax",
   "]",
   "# make grid and calculate convolution",
   "t_grid_0",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "grid_zero_left",
   ",",
   "grid_left",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "grid_center",
   ",",
   "grid_right",
   "[",
   "1",
   ":",
   "]",
   ",",
   "grid_zero_right",
   "]",
   ")",
   ")",
   "t_grid_0",
   "=",
   "t_grid_0",
   "[",
   "(",
   "t_grid_0",
   ">",
   "tmin",
   "-",
   "ttconf",
   ".",
   "TINY_NUMBER",
   ")",
   "&",
   "(",
   "t_grid_0",
   "<",
   "tmax",
   "+",
   "ttconf",
   ".",
   "TINY_NUMBER",
   ")",
   "]",
   "# res0 - the values of the convolution (integral or max)",
   "# t_0  - the value, at which the res0 achieves maximum",
   "#        (when determining the maximum of the integrand, otherwise meaningless)",
   "res_0",
   ",",
   "t_0",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "conv_in_point",
   "(",
   "t_val",
   ")",
   "for",
   "t_val",
   "in",
   "t_grid_0",
   "]",
   ")",
   ".",
   "T",
   "# refine grid as necessary and add new points",
   "# calculate interpolation error at all internal points [2:-2] bc end points are sometime off scale",
   "interp_error",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "res_0",
   "[",
   "3",
   ":",
   "-",
   "1",
   "]",
   "+",
   "res_0",
   "[",
   "1",
   ":",
   "-",
   "3",
   "]",
   "-",
   "2",
   "*",
   "res_0",
   "[",
   "2",
   ":",
   "-",
   "2",
   "]",
   ")",
   "# determine the number of extra points needed, criterion depends on distance from peak dy",
   "dy",
   "=",
   "(",
   "res_0",
   "[",
   "2",
   ":",
   "-",
   "2",
   "]",
   "-",
   "res_0",
   ".",
   "min",
   "(",
   ")",
   ")",
   "dx",
   "=",
   "np",
   ".",
   "diff",
   "(",
   "t_grid_0",
   ")",
   "refine_factor",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "np",
   ".",
   "minimum",
   "(",
   "np",
   ".",
   "array",
   "(",
   "np",
   ".",
   "floor",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "interp_error",
   "/",
   "(",
   "rel_tol",
   "*",
   "(",
   "1",
   "+",
   "(",
   "dy",
   "/",
   "yc",
   ")",
   "**",
   "4",
   ")",
   ")",
   ")",
   ")",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   ",",
   "np",
   ".",
   "array",
   "(",
   "100",
   "*",
   "(",
   "dx",
   "[",
   "1",
   ":",
   "-",
   "2",
   "]",
   "+",
   "dx",
   "[",
   "2",
   ":",
   "-",
   "1",
   "]",
   ")",
   "/",
   "min_fwhm",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   ")",
   ",",
   "10",
   ")",
   "insert_point_idx",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "interp_error",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "+",
   "1",
   ",",
   "dtype",
   "=",
   "int",
   ")",
   "insert_point_idx",
   "[",
   "1",
   ":",
   "]",
   "=",
   "refine_factor",
   "insert_point_idx",
   "[",
   ":",
   "-",
   "1",
   "]",
   "+=",
   "refine_factor",
   "# add additional points if there are any to add",
   "if",
   "np",
   ".",
   "sum",
   "(",
   "insert_point_idx",
   ")",
   ":",
   "add_x",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "np",
   ".",
   "linspace",
   "(",
   "t1",
   ",",
   "t2",
   ",",
   "n",
   "+",
   "2",
   ")",
   "[",
   "1",
   ":",
   "-",
   "1",
   "]",
   "for",
   "t1",
   ",",
   "t2",
   ",",
   "n",
   "in",
   "zip",
   "(",
   "t_grid_0",
   "[",
   "1",
   ":",
   "-",
   "2",
   "]",
   ",",
   "t_grid_0",
   "[",
   "2",
   ":",
   "-",
   "1",
   "]",
   ",",
   "insert_point_idx",
   ")",
   "if",
   "n",
   ">",
   "0",
   "]",
   ")",
   "# calculate convolution at these points",
   "add_y",
   ",",
   "add_t",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "conv_in_point",
   "(",
   "t_val",
   ")",
   "for",
   "t_val",
   "in",
   "add_x",
   "]",
   ")",
   ".",
   "T",
   "t_grid_0",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "t_grid_0",
   ",",
   "add_x",
   ")",
   ")",
   "res_0",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "res_0",
   ",",
   "add_y",
   ")",
   ")",
   "t_0",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "t_0",
   ",",
   "add_t",
   ")",
   ")",
   "# instantiate the new interpolation object and return",
   "res_y",
   "=",
   "cls",
   "(",
   "t_grid_0",
   ",",
   "res_0",
   ",",
   "is_log",
   "=",
   "True",
   ",",
   "kind",
   "=",
   "'linear'",
   ")",
   "# the interpolation object, which is used to store the value of the",
   "# grid, which maximizes the convolution (for 'max' option),",
   "# or flat -1 distribution (for 'integral' option)",
   "# this grid is the optimal branch length",
   "res_t",
   "=",
   "Distribution",
   "(",
   "t_grid_0",
   ",",
   "t_0",
   ",",
   "is_log",
   "=",
   "True",
   ",",
   "min_width",
   "=",
   "node_interp",
   ".",
   "min_width",
   ",",
   "kind",
   "=",
   "'linear'",
   ")",
   "return",
   "res_y",
   ",",
   "res_t"
  ]
 },
 {
  "idx": "maxmin-1099",
  "nl_tokens": [
   "Update",
   "learning",
   "rate",
   "and",
   "momentum",
   "variables",
   "after",
   "event",
   "(",
   "given",
   "by",
   "event_name",
   ")"
  ],
  "pl_tokens": [
   "def",
   "process_event",
   "(",
   "self",
   ",",
   "event_name",
   ":",
   "str",
   ",",
   "data",
   ":",
   "dict",
   ")",
   "->",
   "None",
   ":",
   "if",
   "event_name",
   "==",
   "\"after_validation\"",
   ":",
   "if",
   "data",
   "[",
   "'impatience'",
   "]",
   ">",
   "self",
   ".",
   "_learning_rate_last_impatience",
   ":",
   "self",
   ".",
   "_learning_rate_cur_impatience",
   "+=",
   "1",
   "else",
   ":",
   "self",
   ".",
   "_learning_rate_cur_impatience",
   "=",
   "0",
   "self",
   ".",
   "_learning_rate_last_impatience",
   "=",
   "data",
   "[",
   "'impatience'",
   "]",
   "if",
   "(",
   "self",
   ".",
   "_learning_rate_drop_patience",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "self",
   ".",
   "_learning_rate_cur_impatience",
   ">=",
   "self",
   ".",
   "_learning_rate_drop_patience",
   ")",
   ":",
   "self",
   ".",
   "_learning_rate_cur_impatience",
   "=",
   "0",
   "self",
   ".",
   "_learning_rate_cur_div",
   "*=",
   "self",
   ".",
   "_learning_rate_drop_div",
   "self",
   ".",
   "_lr",
   "/=",
   "self",
   ".",
   "_learning_rate_drop_div",
   "self",
   ".",
   "_update_graph_variables",
   "(",
   "learning_rate",
   "=",
   "self",
   ".",
   "_lr",
   ")",
   "log",
   ".",
   "info",
   "(",
   "f\"New learning rate dividor = {self._learning_rate_cur_div}\"",
   ")",
   "if",
   "event_name",
   "==",
   "'after_batch'",
   ":",
   "if",
   "(",
   "self",
   ".",
   "_lr",
   "is",
   "not",
   "None",
   ")",
   "and",
   "self",
   ".",
   "_lr_update_on_batch",
   ":",
   "self",
   ".",
   "_lr",
   "=",
   "self",
   ".",
   "_lr_schedule",
   ".",
   "next_val",
   "(",
   ")",
   "/",
   "self",
   ".",
   "_learning_rate_cur_div",
   "self",
   ".",
   "_update_graph_variables",
   "(",
   "learning_rate",
   "=",
   "self",
   ".",
   "_lr",
   ")",
   "if",
   "(",
   "self",
   ".",
   "_mom",
   "is",
   "not",
   "None",
   ")",
   "and",
   "self",
   ".",
   "_mom_update_on_batch",
   ":",
   "self",
   ".",
   "_mom",
   "=",
   "<mask>",
   "(",
   "1.",
   ",",
   "max",
   "(",
   "0.",
   ",",
   "self",
   ".",
   "_mom_schedule",
   ".",
   "next_val",
   "(",
   ")",
   ")",
   ")",
   "self",
   ".",
   "_update_graph_variables",
   "(",
   "momentum",
   "=",
   "self",
   ".",
   "_mom",
   ")",
   "if",
   "event_name",
   "==",
   "'after_epoch'",
   ":",
   "if",
   "(",
   "self",
   ".",
   "_lr",
   "is",
   "not",
   "None",
   ")",
   "and",
   "not",
   "self",
   ".",
   "_lr_update_on_batch",
   ":",
   "self",
   ".",
   "_lr",
   "=",
   "self",
   ".",
   "_lr_schedule",
   ".",
   "next_val",
   "(",
   ")",
   "/",
   "self",
   ".",
   "_learning_rate_cur_div",
   "self",
   ".",
   "_update_graph_variables",
   "(",
   "learning_rate",
   "=",
   "self",
   ".",
   "_lr",
   ")",
   "if",
   "(",
   "self",
   ".",
   "_mom",
   "is",
   "not",
   "None",
   ")",
   "and",
   "not",
   "self",
   ".",
   "_mom_update_on_batch",
   ":",
   "self",
   ".",
   "_mom",
   "=",
   "min",
   "(",
   "1.",
   ",",
   "max",
   "(",
   "0.",
   ",",
   "self",
   ".",
   "_mom_schedule",
   ".",
   "next_val",
   "(",
   ")",
   ")",
   ")",
   "self",
   ".",
   "_update_graph_variables",
   "(",
   "momentum",
   "=",
   "self",
   ".",
   "_mom",
   ")",
   "if",
   "event_name",
   "==",
   "'after_train_log'",
   ":",
   "if",
   "(",
   "self",
   ".",
   "_lr",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "'learning_rate'",
   "not",
   "in",
   "data",
   ")",
   ":",
   "data",
   "[",
   "'learning_rate'",
   "]",
   "=",
   "self",
   ".",
   "_lr",
   "if",
   "(",
   "self",
   ".",
   "_mom",
   "is",
   "not",
   "None",
   ")",
   "and",
   "(",
   "'momentum'",
   "not",
   "in",
   "data",
   ")",
   ":",
   "data",
   "[",
   "'momentum'",
   "]",
   "=",
   "self",
   ".",
   "_mom"
  ]
 },
 {
  "idx": "maxmin-1100",
  "nl_tokens": [
   "Identify",
   "a",
   "plan",
   "for",
   "chunking",
   "values",
   "along",
   "each",
   "dimension",
   "."
  ],
  "pl_tokens": [
   "def",
   "getplan",
   "(",
   "self",
   ",",
   "size",
   "=",
   "\"150\"",
   ",",
   "axes",
   "=",
   "None",
   ",",
   "padding",
   "=",
   "None",
   ")",
   ":",
   "from",
   "numpy",
   "import",
   "dtype",
   "as",
   "gettype",
   "# initialize with all elements in one chunk",
   "plan",
   "=",
   "self",
   ".",
   "vshape",
   "# check for subset of axes",
   "if",
   "axes",
   "is",
   "None",
   ":",
   "if",
   "isinstance",
   "(",
   "size",
   ",",
   "str",
   ")",
   ":",
   "axes",
   "=",
   "arange",
   "(",
   "len",
   "(",
   "self",
   ".",
   "vshape",
   ")",
   ")",
   "else",
   ":",
   "axes",
   "=",
   "arange",
   "(",
   "len",
   "(",
   "size",
   ")",
   ")",
   "else",
   ":",
   "axes",
   "=",
   "asarray",
   "(",
   "axes",
   ",",
   "'int'",
   ")",
   "# set padding",
   "pad",
   "=",
   "array",
   "(",
   "len",
   "(",
   "self",
   ".",
   "vshape",
   ")",
   "*",
   "[",
   "0",
   ",",
   "]",
   ")",
   "if",
   "padding",
   "is",
   "not",
   "None",
   ":",
   "pad",
   "[",
   "axes",
   "]",
   "=",
   "padding",
   "# set the plan",
   "if",
   "isinstance",
   "(",
   "size",
   ",",
   "tuple",
   ")",
   ":",
   "plan",
   "[",
   "axes",
   "]",
   "=",
   "size",
   "elif",
   "isinstance",
   "(",
   "size",
   ",",
   "str",
   ")",
   ":",
   "# convert from kilobytes",
   "size",
   "=",
   "1000.0",
   "*",
   "float",
   "(",
   "size",
   ")",
   "# calculate from dtype",
   "elsize",
   "=",
   "gettype",
   "(",
   "self",
   ".",
   "dtype",
   ")",
   ".",
   "itemsize",
   "nelements",
   "=",
   "prod",
   "(",
   "self",
   ".",
   "vshape",
   ")",
   "dims",
   "=",
   "self",
   ".",
   "vshape",
   "[",
   "self",
   ".",
   "vmask",
   "(",
   "axes",
   ")",
   "]",
   "if",
   "size",
   "<=",
   "elsize",
   ":",
   "s",
   "=",
   "ones",
   "(",
   "len",
   "(",
   "axes",
   ")",
   ")",
   "else",
   ":",
   "remsize",
   "=",
   "1.0",
   "*",
   "nelements",
   "*",
   "elsize",
   "s",
   "=",
   "[",
   "]",
   "for",
   "(",
   "i",
   ",",
   "d",
   ")",
   "in",
   "enumerate",
   "(",
   "dims",
   ")",
   ":",
   "minsize",
   "=",
   "remsize",
   "/",
   "d",
   "if",
   "minsize",
   ">=",
   "size",
   ":",
   "s",
   ".",
   "append",
   "(",
   "1",
   ")",
   "remsize",
   "=",
   "minsize",
   "continue",
   "else",
   ":",
   "s",
   ".",
   "append",
   "(",
   "<mask>",
   "(",
   "d",
   ",",
   "floor",
   "(",
   "size",
   "/",
   "minsize",
   ")",
   ")",
   ")",
   "s",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "=",
   "plan",
   "[",
   "i",
   "+",
   "1",
   ":",
   "]",
   "break",
   "plan",
   "[",
   "axes",
   "]",
   "=",
   "s",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Chunk size not understood, must be tuple or int\"",
   ")",
   "return",
   "plan",
   ",",
   "pad"
  ]
 },
 {
  "idx": "maxmin-1101",
  "nl_tokens": [
   "Execute",
   "the",
   "demo",
   "echoing",
   "commands",
   "and",
   "pausing",
   "for",
   "user",
   "input",
   "."
  ],
  "pl_tokens": [
   "def",
   "_run_demo",
   "(",
   "body_fn",
   ",",
   "interactive",
   ",",
   "echo",
   ",",
   "testing",
   ")",
   ":",
   "import",
   "colorama",
   "from",
   "colorama",
   "import",
   "Style",
   ",",
   "Fore",
   "colorama",
   ".",
   "init",
   "(",
   ")",
   "class",
   "StopExecution",
   "(",
   "Exception",
   ")",
   ":",
   "\"\"\"Helper class for cancelling the demo.\"\"\"",
   "assert_is_type",
   "(",
   "body_fn",
   ",",
   "type",
   "(",
   "_run_demo",
   ")",
   ")",
   "# Reformat description by removing extra spaces; then print it.",
   "if",
   "body_fn",
   ".",
   "__doc__",
   ":",
   "desc_lines",
   "=",
   "body_fn",
   ".",
   "__doc__",
   ".",
   "split",
   "(",
   "\"\\n\"",
   ")",
   "while",
   "desc_lines",
   "[",
   "0",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "==",
   "\"\"",
   ":",
   "desc_lines",
   "=",
   "desc_lines",
   "[",
   "1",
   ":",
   "]",
   "while",
   "desc_lines",
   "[",
   "-",
   "1",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "==",
   "\"\"",
   ":",
   "desc_lines",
   "=",
   "desc_lines",
   "[",
   ":",
   "-",
   "1",
   "]",
   "strip_spaces",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "line",
   ")",
   "-",
   "len",
   "(",
   "line",
   ".",
   "lstrip",
   "(",
   "\" \"",
   ")",
   ")",
   "for",
   "line",
   "in",
   "desc_lines",
   "[",
   "1",
   ":",
   "]",
   "if",
   "line",
   ".",
   "strip",
   "(",
   ")",
   "!=",
   "\"\"",
   ")",
   "maxlen",
   "=",
   "max",
   "(",
   "len",
   "(",
   "line",
   ")",
   "for",
   "line",
   "in",
   "desc_lines",
   ")",
   "print",
   "(",
   "Fore",
   ".",
   "CYAN",
   ")",
   "print",
   "(",
   "\"-\"",
   "*",
   "maxlen",
   ")",
   "for",
   "line",
   "in",
   "desc_lines",
   ":",
   "print",
   "(",
   "line",
   "[",
   "strip_spaces",
   ":",
   "]",
   ".",
   "rstrip",
   "(",
   ")",
   ")",
   "print",
   "(",
   "\"-\"",
   "*",
   "maxlen",
   ")",
   "print",
   "(",
   "Style",
   ".",
   "RESET_ALL",
   ",",
   "end",
   "=",
   "\"\"",
   ")",
   "# Prepare the executor function",
   "def",
   "controller",
   "(",
   ")",
   ":",
   "\"\"\"Print to console the next block of commands, and wait for keypress.\"\"\"",
   "try",
   ":",
   "raise",
   "RuntimeError",
   "(",
   "\"Catch me!\"",
   ")",
   "except",
   "RuntimeError",
   ":",
   "print",
   "(",
   ")",
   "# Extract and print lines that will be executed next",
   "if",
   "echo",
   ":",
   "tb",
   "=",
   "sys",
   ".",
   "exc_info",
   "(",
   ")",
   "[",
   "2",
   "]",
   "fr",
   "=",
   "tb",
   ".",
   "tb_frame",
   ".",
   "f_back",
   "filename",
   "=",
   "fr",
   ".",
   "f_code",
   ".",
   "co_filename",
   "linecache",
   ".",
   "checkcache",
   "(",
   "filename",
   ")",
   "line",
   "=",
   "linecache",
   ".",
   "getline",
   "(",
   "filename",
   ",",
   "fr",
   ".",
   "f_lineno",
   ",",
   "fr",
   ".",
   "f_globals",
   ")",
   ".",
   "rstrip",
   "(",
   ")",
   "indent_len",
   "=",
   "len",
   "(",
   "line",
   ")",
   "-",
   "len",
   "(",
   "line",
   ".",
   "lstrip",
   "(",
   "\" \"",
   ")",
   ")",
   "assert",
   "line",
   "[",
   "indent_len",
   ":",
   "]",
   "==",
   "\"go()\"",
   "i",
   "=",
   "fr",
   ".",
   "f_lineno",
   "output_lines",
   "=",
   "[",
   "]",
   "n_blank_lines",
   "=",
   "0",
   "while",
   "True",
   ":",
   "i",
   "+=",
   "1",
   "line",
   "=",
   "linecache",
   ".",
   "getline",
   "(",
   "filename",
   ",",
   "i",
   ",",
   "fr",
   ".",
   "f_globals",
   ")",
   ".",
   "rstrip",
   "(",
   ")",
   "# Detect dedent",
   "if",
   "line",
   "[",
   ":",
   "indent_len",
   "]",
   ".",
   "strip",
   "(",
   ")",
   "!=",
   "\"\"",
   ":",
   "break",
   "line",
   "=",
   "line",
   "[",
   "indent_len",
   ":",
   "]",
   "if",
   "line",
   "==",
   "\"go()\"",
   ":",
   "break",
   "style",
   "=",
   "Fore",
   ".",
   "LIGHTBLACK_EX",
   "if",
   "line",
   ".",
   "lstrip",
   "(",
   ")",
   ".",
   "startswith",
   "(",
   "\"#\"",
   ")",
   "else",
   "Style",
   ".",
   "BRIGHT",
   "prompt",
   "=",
   "\"... \"",
   "if",
   "line",
   ".",
   "startswith",
   "(",
   "\" \"",
   ")",
   "else",
   "\">>> \"",
   "output_lines",
   ".",
   "append",
   "(",
   "Fore",
   ".",
   "CYAN",
   "+",
   "prompt",
   "+",
   "Fore",
   ".",
   "RESET",
   "+",
   "style",
   "+",
   "line",
   "+",
   "Style",
   ".",
   "RESET_ALL",
   ")",
   "del",
   "style",
   "# Otherwise exception print-outs may get messed-up...",
   "if",
   "line",
   ".",
   "strip",
   "(",
   ")",
   "==",
   "\"\"",
   ":",
   "n_blank_lines",
   "+=",
   "1",
   "if",
   "n_blank_lines",
   ">",
   "5",
   ":",
   "break",
   "# Just in case we hit file end or something",
   "else",
   ":",
   "n_blank_lines",
   "=",
   "0",
   "for",
   "line",
   "in",
   "output_lines",
   "[",
   ":",
   "-",
   "n_blank_lines",
   "]",
   ":",
   "print",
   "(",
   "line",
   ")",
   "# Prompt for user input",
   "if",
   "interactive",
   ":",
   "print",
   "(",
   "\"\\n\"",
   "+",
   "Style",
   ".",
   "DIM",
   "+",
   "\"(press any key)\"",
   "+",
   "Style",
   ".",
   "RESET_ALL",
   ",",
   "end",
   "=",
   "\"\"",
   ")",
   "key",
   "=",
   "_wait_for_keypress",
   "(",
   ")",
   "print",
   "(",
   "\"\\r                     \\r\"",
   ",",
   "end",
   "=",
   "\"\"",
   ")",
   "if",
   "key",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "\"q\"",
   ":",
   "raise",
   "StopExecution",
   "(",
   ")",
   "# Replace h2o.init() with a stub when running in \"test\" mode",
   "_h2o_init",
   "=",
   "h2o",
   ".",
   "init",
   "if",
   "testing",
   ":",
   "h2o",
   ".",
   "init",
   "=",
   "lambda",
   "*",
   "args",
   ",",
   "*",
   "*",
   "kwargs",
   ":",
   "None",
   "# Run the test",
   "try",
   ":",
   "body_fn",
   "(",
   "controller",
   ")",
   "print",
   "(",
   "\"\\n\"",
   "+",
   "Fore",
   ".",
   "CYAN",
   "+",
   "\"---- End of Demo ----\"",
   "+",
   "Style",
   ".",
   "RESET_ALL",
   ")",
   "except",
   "(",
   "StopExecution",
   ",",
   "KeyboardInterrupt",
   ")",
   ":",
   "print",
   "(",
   "\"\\n\"",
   "+",
   "Fore",
   ".",
   "RED",
   "+",
   "\"---- Demo aborted ----\"",
   "+",
   "Style",
   ".",
   "RESET_ALL",
   ")",
   "# Clean-up",
   "if",
   "testing",
   ":",
   "h2o",
   ".",
   "init",
   "=",
   "_h2o_init",
   "print",
   "(",
   ")",
   "colorama",
   ".",
   "deinit",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1102",
  "nl_tokens": [
   "Expands",
   "this",
   "envelope",
   "by",
   "the",
   "given",
   "Envelope",
   "or",
   "tuple",
   "."
  ],
  "pl_tokens": [
   "def",
   "expand",
   "(",
   "self",
   ",",
   "other",
   ")",
   ":",
   "if",
   "len",
   "(",
   "other",
   ")",
   "==",
   "2",
   ":",
   "other",
   "+=",
   "other",
   "mid",
   "=",
   "len",
   "(",
   "other",
   ")",
   "//",
   "2",
   "self",
   ".",
   "ll",
   "=",
   "map",
   "(",
   "<mask>",
   ",",
   "self",
   ".",
   "ll",
   ",",
   "other",
   "[",
   ":",
   "mid",
   "]",
   ")",
   "self",
   ".",
   "ur",
   "=",
   "map",
   "(",
   "max",
   ",",
   "self",
   ".",
   "ur",
   ",",
   "other",
   "[",
   "mid",
   ":",
   "]",
   ")"
  ]
 },
 {
  "idx": "maxmin-1103",
  "nl_tokens": [
   "This",
   "utility",
   "function",
   "will",
   "print",
   "the",
   "progress",
   "of",
   "a",
   "passed",
   "iterator",
   "job",
   "as",
   "started",
   "by",
   "refresh_indices",
   "()",
   "and",
   "clean_old_index",
   "()",
   "."
  ],
  "pl_tokens": [
   "def",
   "show_progress",
   "(",
   "job",
   ")",
   ":",
   "start",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "last_print",
   "=",
   "0",
   "last_line",
   "=",
   "0",
   "for",
   "prog",
   ",",
   "total",
   "in",
   "chain",
   "(",
   "job",
   ",",
   "[",
   "(",
   "1",
   ",",
   "1",
   ")",
   "]",
   ")",
   ":",
   "# Only print a line when we start, finish, or every .1 seconds",
   "if",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "last_print",
   ")",
   ">",
   ".1",
   "or",
   "prog",
   ">=",
   "total",
   ":",
   "delta",
   "=",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   "-",
   "start",
   ")",
   "or",
   ".0001",
   "line",
   "=",
   "\"%.1f%% complete, %.1f seconds elapsed, %.1f seconds remaining\"",
   "%",
   "(",
   "100.",
   "*",
   "prog",
   "/",
   "(",
   "total",
   "or",
   "1",
   ")",
   ",",
   "delta",
   ",",
   "total",
   "*",
   "delta",
   "/",
   "(",
   "prog",
   "or",
   "1",
   ")",
   "-",
   "delta",
   ")",
   "length",
   "=",
   "len",
   "(",
   "line",
   ")",
   "# pad the line out with spaces just in case our line got shorter",
   "line",
   "+=",
   "<mask>",
   "(",
   "last_line",
   "-",
   "length",
   ",",
   "0",
   ")",
   "*",
   "' '",
   "print",
   "(",
   "line",
   ",",
   "end",
   "=",
   "\"\\r\"",
   ")",
   "last_line",
   "=",
   "length",
   "last_print",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "print",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1104",
  "nl_tokens": [
   "Generates",
   "a",
   "list",
   "with",
   "start",
   "end",
   "stop",
   "indices",
   "of",
   "length",
   "parts",
   "[",
   "(",
   "0",
   "length",
   "/",
   "parts",
   ")",
   "...",
   "(",
   "..",
   "length",
   ")",
   "]"
  ],
  "pl_tokens": [
   "def",
   "subdivide",
   "(",
   "length",
   ",",
   "parts",
   "=",
   "None",
   ",",
   "max_length",
   "=",
   "None",
   ")",
   ":",
   "if",
   "max_length",
   ":",
   "i1",
   "=",
   "0",
   "done",
   "=",
   "False",
   "while",
   "not",
   "done",
   ":",
   "i2",
   "=",
   "<mask>",
   "(",
   "length",
   ",",
   "i1",
   "+",
   "max_length",
   ")",
   "# print i1, i2",
   "yield",
   "i1",
   ",",
   "i2",
   "i1",
   "=",
   "i2",
   "if",
   "i1",
   "==",
   "length",
   ":",
   "done",
   "=",
   "True",
   "else",
   ":",
   "part_length",
   "=",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "float",
   "(",
   "length",
   ")",
   "/",
   "parts",
   ")",
   ")",
   "# subblock_count = math.ceil(total_length/subblock_size)",
   "# args_list = []",
   "for",
   "index",
   "in",
   "range",
   "(",
   "parts",
   ")",
   ":",
   "i1",
   ",",
   "i2",
   "=",
   "index",
   "*",
   "part_length",
   ",",
   "min",
   "(",
   "length",
   ",",
   "(",
   "index",
   "+",
   "1",
   ")",
   "*",
   "part_length",
   ")",
   "yield",
   "i1",
   ",",
   "i2"
  ]
 },
 {
  "idx": "maxmin-1105",
  "nl_tokens": [
   "Updates",
   "the",
   "progressbar",
   "by",
   "re",
   "-",
   "calculating",
   "the",
   "label",
   ".",
   "It",
   "is",
   "not",
   "required",
   "to",
   "manually",
   "call",
   "this",
   "method",
   "since",
   "setting",
   "any",
   "of",
   "the",
   "properties",
   "of",
   "this",
   "class",
   "will",
   "automatically",
   "trigger",
   "a",
   "re",
   "-",
   "calculation",
   "."
  ],
  "pl_tokens": [
   "def",
   "update_progressbar",
   "(",
   "self",
   ")",
   ":",
   "n",
   ",",
   "nmin",
   ",",
   "nmax",
   "=",
   "self",
   ".",
   "wprogressbar",
   ".",
   "n",
   ",",
   "self",
   ".",
   "wprogressbar",
   ".",
   "nmin",
   ",",
   "self",
   ".",
   "wprogressbar",
   ".",
   "nmax",
   "if",
   "(",
   "nmax",
   "-",
   "nmin",
   ")",
   "==",
   "0",
   ":",
   "percent",
   "=",
   "0",
   "# prevents ZeroDivisionError",
   "else",
   ":",
   "percent",
   "=",
   "<mask>",
   "(",
   "min",
   "(",
   "(",
   "n",
   "-",
   "nmin",
   ")",
   "/",
   "(",
   "nmax",
   "-",
   "nmin",
   ")",
   ",",
   "1.",
   ")",
   ",",
   "0.",
   ")",
   "*",
   "100",
   "dat",
   "=",
   "{",
   "\"value\"",
   ":",
   "round",
   "(",
   "n",
   ",",
   "4",
   ")",
   ",",
   "\"n\"",
   ":",
   "round",
   "(",
   "n",
   ",",
   "4",
   ")",
   ",",
   "\"nmin\"",
   ":",
   "round",
   "(",
   "nmin",
   ",",
   "4",
   ")",
   ",",
   "\"nmax\"",
   ":",
   "round",
   "(",
   "nmax",
   ",",
   "4",
   ")",
   ",",
   "\"percent\"",
   ":",
   "round",
   "(",
   "percent",
   ",",
   "4",
   ")",
   ",",
   "\"p\"",
   ":",
   "round",
   "(",
   "percent",
   ",",
   "4",
   ")",
   "}",
   "txt",
   "=",
   "self",
   ".",
   "_label_progressbar",
   ".",
   "format",
   "(",
   "*",
   "*",
   "dat",
   ")",
   "self",
   ".",
   "wprogresslabel",
   ".",
   "label",
   "=",
   "txt"
  ]
 },
 {
  "idx": "maxmin-1106",
  "nl_tokens": [
   "Transform",
   "boolean",
   "arrays",
   "into",
   "list",
   "of",
   "limit",
   "pairs",
   "."
  ],
  "pl_tokens": [
   "def",
   "mkrngs",
   "(",
   "self",
   ")",
   ":",
   "bbool",
   "=",
   "bool_2_indices",
   "(",
   "self",
   ".",
   "bkg",
   ")",
   "if",
   "bbool",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "bkgrng",
   "=",
   "self",
   ".",
   "Time",
   "[",
   "bbool",
   "]",
   "else",
   ":",
   "self",
   ".",
   "bkgrng",
   "=",
   "[",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   "]",
   "sbool",
   "=",
   "bool_2_indices",
   "(",
   "self",
   ".",
   "sig",
   ")",
   "if",
   "sbool",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "sigrng",
   "=",
   "self",
   ".",
   "Time",
   "[",
   "sbool",
   "]",
   "else",
   ":",
   "self",
   ".",
   "sigrng",
   "=",
   "[",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   "]",
   "tbool",
   "=",
   "bool_2_indices",
   "(",
   "self",
   ".",
   "trn",
   ")",
   "if",
   "tbool",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "trnrng",
   "=",
   "self",
   ".",
   "Time",
   "[",
   "tbool",
   "]",
   "else",
   ":",
   "self",
   ".",
   "trnrng",
   "=",
   "[",
   "[",
   "np",
   ".",
   "nan",
   ",",
   "np",
   ".",
   "nan",
   "]",
   "]",
   "self",
   ".",
   "ns",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "self",
   ".",
   "Time",
   ".",
   "size",
   ")",
   "n",
   "=",
   "1",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "sig",
   ")",
   "-",
   "1",
   ")",
   ":",
   "if",
   "self",
   ".",
   "sig",
   "[",
   "i",
   "]",
   ":",
   "self",
   ".",
   "ns",
   "[",
   "i",
   "]",
   "=",
   "n",
   "if",
   "self",
   ".",
   "sig",
   "[",
   "i",
   "]",
   "and",
   "~",
   "self",
   ".",
   "sig",
   "[",
   "i",
   "+",
   "1",
   "]",
   ":",
   "n",
   "+=",
   "1",
   "self",
   ".",
   "n",
   "=",
   "int",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "ns",
   ")",
   ")",
   "# record number of traces",
   "return"
  ]
 },
 {
  "idx": "maxmin-1107",
  "nl_tokens": [
   "This",
   "function",
   "will",
   "print",
   "out",
   "the",
   "intermittents",
   "onto",
   "the",
   "screen",
   "for",
   "casual",
   "viewing",
   ".",
   "It",
   "will",
   "also",
   "print",
   "out",
   "where",
   "the",
   "giant",
   "summary",
   "dictionary",
   "is",
   "going",
   "to",
   "be",
   "stored",
   "."
  ],
  "pl_tokens": [
   "def",
   "extractPrintSaveIntermittens",
   "(",
   ")",
   ":",
   "# extract intermittents from collected failed tests",
   "global",
   "g_summary_dict_intermittents",
   "localtz",
   "=",
   "time",
   ".",
   "tzname",
   "[",
   "0",
   "]",
   "for",
   "ind",
   "in",
   "range",
   "(",
   "len",
   "(",
   "g_summary_dict_all",
   "[",
   "\"TestName\"",
   "]",
   ")",
   ")",
   ":",
   "if",
   "g_summary_dict_all",
   "[",
   "\"TestInfo\"",
   "]",
   "[",
   "ind",
   "]",
   "[",
   "\"FailureCount\"",
   "]",
   ">=",
   "g_threshold_failure",
   ":",
   "addFailedTests",
   "(",
   "g_summary_dict_intermittents",
   ",",
   "g_summary_dict_all",
   ",",
   "ind",
   ")",
   "# save dict in file",
   "if",
   "len",
   "(",
   "g_summary_dict_intermittents",
   "[",
   "\"TestName\"",
   "]",
   ")",
   ">",
   "0",
   ":",
   "json",
   ".",
   "dump",
   "(",
   "g_summary_dict_intermittents",
   ",",
   "open",
   "(",
   "g_summary_dict_name",
   ",",
   "'w'",
   ")",
   ")",
   "with",
   "open",
   "(",
   "g_summary_csv_filename",
   ",",
   "'w'",
   ")",
   "as",
   "summaryFile",
   ":",
   "for",
   "ind",
   "in",
   "range",
   "(",
   "len",
   "(",
   "g_summary_dict_intermittents",
   "[",
   "\"TestName\"",
   "]",
   ")",
   ")",
   ":",
   "testName",
   "=",
   "g_summary_dict_intermittents",
   "[",
   "\"TestName\"",
   "]",
   "[",
   "ind",
   "]",
   "numberFailure",
   "=",
   "g_summary_dict_intermittents",
   "[",
   "\"TestInfo\"",
   "]",
   "[",
   "ind",
   "]",
   "[",
   "\"FailureCount\"",
   "]",
   "firstFailedTS",
   "=",
   "parser",
   ".",
   "parse",
   "(",
   "time",
   ".",
   "ctime",
   "(",
   "<mask>",
   "(",
   "g_summary_dict_intermittents",
   "[",
   "\"TestInfo\"",
   "]",
   "[",
   "ind",
   "]",
   "[",
   "\"Timestamp\"",
   "]",
   ")",
   ")",
   "+",
   "' '",
   "+",
   "localtz",
   ")",
   "firstFailedStr",
   "=",
   "firstFailedTS",
   ".",
   "strftime",
   "(",
   "\"%a %b %d %H:%M:%S %Y %Z\"",
   ")",
   "recentFail",
   "=",
   "parser",
   ".",
   "parse",
   "(",
   "time",
   ".",
   "ctime",
   "(",
   "max",
   "(",
   "g_summary_dict_intermittents",
   "[",
   "\"TestInfo\"",
   "]",
   "[",
   "ind",
   "]",
   "[",
   "\"Timestamp\"",
   "]",
   ")",
   ")",
   "+",
   "' '",
   "+",
   "localtz",
   ")",
   "recentFailStr",
   "=",
   "recentFail",
   ".",
   "strftime",
   "(",
   "\"%a %b %d %H:%M:%S %Y %Z\"",
   ")",
   "eachTest",
   "=",
   "\"{0}, {1}, {2}, {3}\\n\"",
   ".",
   "format",
   "(",
   "testName",
   ",",
   "recentFailStr",
   ",",
   "numberFailure",
   ",",
   "g_summary_dict_intermittents",
   "[",
   "\"TestInfo\"",
   "]",
   "[",
   "ind",
   "]",
   "[",
   "\"TestCategory\"",
   "]",
   "[",
   "0",
   "]",
   ")",
   "summaryFile",
   ".",
   "write",
   "(",
   "eachTest",
   ")",
   "print",
   "(",
   "\"Intermittent: {0}, Last failed: {1}, Failed {2} times since \"",
   "\"{3}\"",
   ".",
   "format",
   "(",
   "testName",
   ",",
   "recentFailStr",
   ",",
   "numberFailure",
   ",",
   "firstFailedStr",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1108",
  "nl_tokens": [
   "\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442",
   "\u0442\u0440\u0430\u043d\u0441\u0434\u0443\u043a\u0446\u0438\u044e",
   "\u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439",
   "\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0438",
   "\u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0449\u0443\u044e",
   "first",
   "\u0432",
   "second"
  ],
  "pl_tokens": [
   "def",
   "distance",
   "(",
   "self",
   ",",
   "first",
   ",",
   "second",
   ",",
   "return_transduction",
   "=",
   "False",
   ")",
   ":",
   "if",
   "return_transduction",
   ":",
   "add_pred",
   "=",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "(",
   "y",
   "==",
   "np",
   ".",
   "inf",
   "or",
   "x",
   "<",
   "y",
   ")",
   ")",
   "else",
   ":",
   "add_pred",
   "=",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "(",
   "y",
   "==",
   "np",
   ".",
   "inf",
   "or",
   "x",
   "<=",
   "y",
   ")",
   ")",
   "clear_pred",
   "=",
   "(",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "(",
   "y",
   "<",
   "np",
   ".",
   "inf",
   "and",
   "x",
   "<",
   "y",
   ")",
   ")",
   "update_func",
   "=",
   "lambda",
   "x",
   ",",
   "y",
   ":",
   "<mask>",
   "(",
   "x",
   ",",
   "y",
   ")",
   "costs",
   ",",
   "backtraces",
   "=",
   "self",
   ".",
   "_fill_levenshtein_table",
   "(",
   "first",
   ",",
   "second",
   ",",
   "update_func",
   ",",
   "add_pred",
   ",",
   "clear_pred",
   ")",
   "final_cost",
   "=",
   "costs",
   "[",
   "-",
   "1",
   "]",
   "[",
   "-",
   "1",
   "]",
   "if",
   "final_cost",
   "==",
   "np",
   ".",
   "inf",
   ":",
   "transductions",
   "=",
   "[",
   "None",
   "]",
   "elif",
   "return_transduction",
   ":",
   "transductions",
   "=",
   "self",
   ".",
   "_backtraces_to_transductions",
   "(",
   "first",
   ",",
   "second",
   ",",
   "backtraces",
   ",",
   "final_cost",
   ",",
   "return_cost",
   "=",
   "False",
   ")",
   "if",
   "return_transduction",
   ":",
   "return",
   "final_cost",
   ",",
   "transductions",
   "else",
   ":",
   "return",
   "final_cost"
  ]
 },
 {
  "idx": "maxmin-1109",
  "nl_tokens": [
   "Plots",
   "PDF",
   "and",
   "powerlaw",
   "...."
  ],
  "pl_tokens": [
   "def",
   "plotpdf",
   "(",
   "x",
   ",",
   "xmin",
   ",",
   "alpha",
   ",",
   "nbins",
   "=",
   "30",
   ",",
   "dolog",
   "=",
   "False",
   ")",
   ":",
   "x",
   "=",
   "sort",
   "(",
   "x",
   ")",
   "n",
   "=",
   "len",
   "(",
   "x",
   ")",
   "if",
   "dolog",
   ":",
   "hb",
   "=",
   "hist",
   "(",
   "x",
   ",",
   "bins",
   "=",
   "logspace",
   "(",
   "log10",
   "(",
   "<mask>",
   "(",
   "x",
   ")",
   ")",
   ",",
   "log10",
   "(",
   "max",
   "(",
   "x",
   ")",
   ")",
   ",",
   "nbins",
   ")",
   ",",
   "log",
   "=",
   "True",
   ")",
   "alpha",
   "+=",
   "1",
   "else",
   ":",
   "hb",
   "=",
   "hist",
   "(",
   "x",
   ",",
   "bins",
   "=",
   "linspace",
   "(",
   "(",
   "min",
   "(",
   "x",
   ")",
   ")",
   ",",
   "(",
   "max",
   "(",
   "x",
   ")",
   ")",
   ",",
   "nbins",
   ")",
   ")",
   "h",
   ",",
   "b",
   "=",
   "hb",
   "[",
   "0",
   "]",
   ",",
   "hb",
   "[",
   "1",
   "]",
   "b",
   "=",
   "b",
   "[",
   "1",
   ":",
   "]",
   "q",
   "=",
   "x",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "px",
   "=",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   "*",
   "(",
   "q",
   "/",
   "xmin",
   ")",
   "**",
   "(",
   "-",
   "alpha",
   ")",
   "arg",
   "=",
   "argmin",
   "(",
   "abs",
   "(",
   "b",
   "-",
   "xmin",
   ")",
   ")",
   "norm",
   "=",
   "mean",
   "(",
   "h",
   "[",
   "b",
   ">",
   "xmin",
   "]",
   "/",
   "(",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   "*",
   "(",
   "b",
   "[",
   "b",
   ">",
   "xmin",
   "]",
   "/",
   "xmin",
   ")",
   "**",
   "(",
   "-",
   "alpha",
   ")",
   ")",
   ")",
   "px",
   "=",
   "px",
   "*",
   "norm",
   "loglog",
   "(",
   "q",
   ",",
   "px",
   ")",
   "gca",
   "(",
   ")",
   ".",
   "set_xlim",
   "(",
   "min",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1110",
  "nl_tokens": [
   "Create",
   "a",
   "plot",
   "of",
   "weights",
   "visualized",
   "as",
   "bottom",
   "-",
   "level",
   "pixel",
   "arrays",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_layers",
   "(",
   "weights",
   ",",
   "tied_weights",
   "=",
   "False",
   ",",
   "channels",
   "=",
   "1",
   ")",
   ":",
   "if",
   "hasattr",
   "(",
   "weights",
   "[",
   "0",
   "]",
   ",",
   "'get_value'",
   ")",
   ":",
   "weights",
   "=",
   "[",
   "w",
   ".",
   "get_value",
   "(",
   ")",
   "for",
   "w",
   "in",
   "weights",
   "]",
   "k",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "weights",
   ")",
   ",",
   "9",
   ")",
   "imgs",
   "=",
   "np",
   ".",
   "eye",
   "(",
   "weights",
   "[",
   "0",
   "]",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "for",
   "i",
   ",",
   "weight",
   "in",
   "enumerate",
   "(",
   "weights",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   ":",
   "imgs",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "weight",
   ".",
   "T",
   ",",
   "imgs",
   ")",
   "plot_images",
   "(",
   "imgs",
   ",",
   "100",
   "+",
   "10",
   "*",
   "k",
   "+",
   "i",
   "+",
   "1",
   ",",
   "channels",
   "=",
   "channels",
   ",",
   "title",
   "=",
   "'Layer {}'",
   ".",
   "format",
   "(",
   "i",
   "+",
   "1",
   ")",
   ")",
   "weight",
   "=",
   "weights",
   "[",
   "-",
   "1",
   "]",
   "n",
   "=",
   "weight",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "/",
   "channels",
   "if",
   "int",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "n",
   ")",
   ")",
   "**",
   "2",
   "!=",
   "n",
   ":",
   "return",
   "if",
   "tied_weights",
   ":",
   "imgs",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "weight",
   ".",
   "T",
   ",",
   "imgs",
   ")",
   "plot_images",
   "(",
   "imgs",
   ",",
   "100",
   "+",
   "10",
   "*",
   "k",
   "+",
   "k",
   ",",
   "channels",
   "=",
   "channels",
   ",",
   "title",
   "=",
   "'Layer {}'",
   ".",
   "format",
   "(",
   "k",
   ")",
   ")",
   "else",
   ":",
   "plot_images",
   "(",
   "weight",
   ",",
   "100",
   "+",
   "10",
   "*",
   "k",
   "+",
   "k",
   ",",
   "channels",
   "=",
   "channels",
   ",",
   "title",
   "=",
   "'Decoding weights'",
   ")"
  ]
 },
 {
  "idx": "maxmin-1111",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "arc",
   "sine",
   "of",
   "a",
   "waveform",
   "s",
   "dependent",
   "variable",
   "vector",
   "."
  ],
  "pl_tokens": [
   "def",
   "asin",
   "(",
   "wave",
   ")",
   ":",
   "pexdoc",
   ".",
   "exh",
   ".",
   "addex",
   "(",
   "ValueError",
   ",",
   "\"Math domain error\"",
   ",",
   "bool",
   "(",
   "(",
   "<mask>",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   "<",
   "-",
   "1",
   ")",
   "or",
   "(",
   "max",
   "(",
   "wave",
   ".",
   "_dep_vector",
   ")",
   ">",
   "1",
   ")",
   ")",
   ",",
   ")",
   "return",
   "_operation",
   "(",
   "wave",
   ",",
   "\"asin\"",
   ",",
   "\"rad\"",
   ",",
   "np",
   ".",
   "arcsin",
   ")"
  ]
 },
 {
  "idx": "maxmin-1112",
  "nl_tokens": [
   "Calculate",
   "the",
   "margin",
   "in",
   "pixels",
   "below",
   "the",
   "plot",
   "area",
   "setting",
   "border_bottom",
   "."
  ],
  "pl_tokens": [
   "def",
   "calculate_bottom_margin",
   "(",
   "self",
   ")",
   ":",
   "bb",
   "=",
   "7",
   "if",
   "self",
   ".",
   "key",
   "and",
   "self",
   ".",
   "key_position",
   "==",
   "'bottom'",
   ":",
   "bb",
   "+=",
   "len",
   "(",
   "self",
   ".",
   "data",
   ")",
   "*",
   "(",
   "self",
   ".",
   "font_size",
   "+",
   "5",
   ")",
   "bb",
   "+=",
   "10",
   "if",
   "self",
   ".",
   "show_x_labels",
   ":",
   "max_x_label_height_px",
   "=",
   "self",
   ".",
   "x_label_font_size",
   "if",
   "self",
   ".",
   "rotate_x_labels",
   ":",
   "label_lengths",
   "=",
   "map",
   "(",
   "len",
   ",",
   "self",
   ".",
   "get_x_labels",
   "(",
   ")",
   ")",
   "max_x_label_len",
   "=",
   "functools",
   ".",
   "reduce",
   "(",
   "<mask>",
   ",",
   "label_lengths",
   ")",
   "max_x_label_height_px",
   "*=",
   "0.6",
   "*",
   "max_x_label_len",
   "bb",
   "+=",
   "max_x_label_height_px",
   "if",
   "self",
   ".",
   "stagger_x_labels",
   ":",
   "bb",
   "+=",
   "max_x_label_height_px",
   "+",
   "10",
   "if",
   "self",
   ".",
   "show_x_title",
   ":",
   "bb",
   "+=",
   "self",
   ".",
   "x_title_font_size",
   "+",
   "5",
   "self",
   ".",
   "border_bottom",
   "=",
   "bb"
  ]
 },
 {
  "idx": "maxmin-1113",
  "nl_tokens": [
   "Returns",
   "max",
   "or",
   "mask",
   "if",
   "max",
   "is",
   "not",
   "finite",
   "."
  ],
  "pl_tokens": [
   "def",
   "_max_mask_non_finite",
   "(",
   "x",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ",",
   "keepdims",
   "=",
   "False",
   ",",
   "mask",
   "=",
   "0",
   ")",
   ":",
   "m",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ",",
   "axis",
   "=",
   "_astuple",
   "(",
   "axis",
   ")",
   ",",
   "keepdims",
   "=",
   "keepdims",
   ")",
   "needs_masking",
   "=",
   "~",
   "np",
   ".",
   "isfinite",
   "(",
   "m",
   ")",
   "if",
   "needs_masking",
   ".",
   "ndim",
   ">",
   "0",
   ":",
   "m",
   "[",
   "needs_masking",
   "]",
   "=",
   "mask",
   "elif",
   "needs_masking",
   ":",
   "m",
   "=",
   "mask",
   "return",
   "m"
  ]
 },
 {
  "idx": "maxmin-1114",
  "nl_tokens": [
   "Compare",
   "version",
   "strings",
   ".",
   ":",
   "param",
   "version1",
   ";",
   ":",
   "param",
   "version2",
   ";",
   ":",
   "return",
   ":",
   "1",
   "if",
   "version1",
   "is",
   "after",
   "version2",
   ";",
   "-",
   "1",
   "if",
   "version1",
   "is",
   "before",
   "version2",
   ";",
   "0",
   "if",
   "two",
   "versions",
   "are",
   "the",
   "same",
   "."
  ],
  "pl_tokens": [
   "def",
   "compare_version",
   "(",
   "version1",
   ",",
   "version2",
   ")",
   ":",
   "v1Arr",
   "=",
   "version1",
   ".",
   "split",
   "(",
   "\".\"",
   ")",
   "v2Arr",
   "=",
   "version2",
   ".",
   "split",
   "(",
   "\".\"",
   ")",
   "len1",
   "=",
   "len",
   "(",
   "v1Arr",
   ")",
   "len2",
   "=",
   "len",
   "(",
   "v2Arr",
   ")",
   "lenMax",
   "=",
   "<mask>",
   "(",
   "len1",
   ",",
   "len2",
   ")",
   "for",
   "x",
   "in",
   "range",
   "(",
   "lenMax",
   ")",
   ":",
   "v1Token",
   "=",
   "0",
   "if",
   "x",
   "<",
   "len1",
   ":",
   "v1Token",
   "=",
   "int",
   "(",
   "v1Arr",
   "[",
   "x",
   "]",
   ")",
   "v2Token",
   "=",
   "0",
   "if",
   "x",
   "<",
   "len2",
   ":",
   "v2Token",
   "=",
   "int",
   "(",
   "v2Arr",
   "[",
   "x",
   "]",
   ")",
   "if",
   "v1Token",
   "<",
   "v2Token",
   ":",
   "return",
   "-",
   "1",
   "if",
   "v1Token",
   ">",
   "v2Token",
   ":",
   "return",
   "1",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-1115",
  "nl_tokens": [
   "Converts",
   "a",
   "Las",
   "from",
   "one",
   "point",
   "format",
   "to",
   "another",
   "Automatically",
   "upgrades",
   "the",
   "file",
   "version",
   "if",
   "source",
   "file",
   "version",
   "is",
   "not",
   "compatible",
   "with",
   "the",
   "new",
   "point_format_id"
  ],
  "pl_tokens": [
   "def",
   "convert",
   "(",
   "source_las",
   ",",
   "*",
   ",",
   "point_format_id",
   "=",
   "None",
   ",",
   "file_version",
   "=",
   "None",
   ")",
   ":",
   "if",
   "point_format_id",
   "is",
   "None",
   ":",
   "point_format_id",
   "=",
   "source_las",
   ".",
   "points_data",
   ".",
   "point_format",
   ".",
   "id",
   "if",
   "file_version",
   "is",
   "None",
   ":",
   "file_version",
   "=",
   "<mask>",
   "(",
   "source_las",
   ".",
   "header",
   ".",
   "version",
   ",",
   "dims",
   ".",
   "min_file_version_for_point_format",
   "(",
   "point_format_id",
   ")",
   ",",
   ")",
   "else",
   ":",
   "file_version",
   "=",
   "str",
   "(",
   "file_version",
   ")",
   "dims",
   ".",
   "raise_if_version_not_compatible_with_fmt",
   "(",
   "point_format_id",
   ",",
   "file_version",
   ")",
   "header",
   "=",
   "headers",
   ".",
   "HeaderFactory",
   ".",
   "convert_header",
   "(",
   "source_las",
   ".",
   "header",
   ",",
   "file_version",
   ")",
   "header",
   ".",
   "point_format_id",
   "=",
   "point_format_id",
   "point_format",
   "=",
   "PointFormat",
   "(",
   "point_format_id",
   ",",
   "source_las",
   ".",
   "points_data",
   ".",
   "point_format",
   ".",
   "extra_dims",
   ")",
   "points",
   "=",
   "record",
   ".",
   "PackedPointRecord",
   ".",
   "from_point_record",
   "(",
   "source_las",
   ".",
   "points_data",
   ",",
   "point_format",
   ")",
   "try",
   ":",
   "evlrs",
   "=",
   "source_las",
   ".",
   "evlrs",
   "except",
   "ValueError",
   ":",
   "evlrs",
   "=",
   "[",
   "]",
   "if",
   "file_version",
   ">=",
   "\"1.4\"",
   ":",
   "las",
   "=",
   "las14",
   ".",
   "LasData",
   "(",
   "header",
   "=",
   "header",
   ",",
   "vlrs",
   "=",
   "source_las",
   ".",
   "vlrs",
   ",",
   "points",
   "=",
   "points",
   ",",
   "evlrs",
   "=",
   "evlrs",
   ")",
   "else",
   ":",
   "if",
   "evlrs",
   ":",
   "logger",
   ".",
   "warning",
   "(",
   "\"The source contained {} EVLRs,\"",
   "\" they will be lost as version {} doest not support them\"",
   ".",
   "format",
   "(",
   "len",
   "(",
   "evlrs",
   ")",
   ",",
   "file_version",
   ")",
   ")",
   "las",
   "=",
   "las12",
   ".",
   "LasData",
   "(",
   "header",
   "=",
   "header",
   ",",
   "vlrs",
   "=",
   "source_las",
   ".",
   "vlrs",
   ",",
   "points",
   "=",
   "points",
   ")",
   "return",
   "las"
  ]
 },
 {
  "idx": "maxmin-1116",
  "nl_tokens": [
   "Plot",
   "a",
   "nuclear",
   "chart",
   "with",
   "(",
   "N",
   "Z",
   ")",
   "as",
   "axis",
   "and",
   "the",
   "values",
   "of",
   "the",
   "Table",
   "as",
   "a",
   "color",
   "scale"
  ],
  "pl_tokens": [
   "def",
   "chart_plot",
   "(",
   "self",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "cmap",
   "=",
   "'RdBu'",
   ",",
   "xlabel",
   "=",
   "'N'",
   ",",
   "ylabel",
   "=",
   "'Z'",
   ",",
   "grid_on",
   "=",
   "True",
   ",",
   "colorbar",
   "=",
   "True",
   ")",
   ":",
   "from",
   "matplotlib",
   ".",
   "mlab",
   "import",
   "griddata",
   "from",
   "numpy",
   "import",
   "linspace",
   ",",
   "meshgrid",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "# extract the 1D arrays to be plotted",
   "x",
   "=",
   "self",
   ".",
   "dropna",
   "(",
   ")",
   ".",
   "N",
   "y",
   "=",
   "self",
   ".",
   "dropna",
   "(",
   ")",
   ".",
   "Z",
   "z",
   "=",
   "self",
   ".",
   "dropna",
   "(",
   ")",
   ".",
   "values",
   "#convert to matplotlibs grid format",
   "xi",
   "=",
   "linspace",
   "(",
   "<mask>",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   ",",
   "max",
   "(",
   "x",
   ")",
   "-",
   "min",
   "(",
   "x",
   ")",
   "+",
   "1",
   ")",
   "yi",
   "=",
   "linspace",
   "(",
   "min",
   "(",
   "y",
   ")",
   ",",
   "max",
   "(",
   "y",
   ")",
   ",",
   "max",
   "(",
   "y",
   ")",
   "-",
   "min",
   "(",
   "y",
   ")",
   "+",
   "1",
   ")",
   "Z",
   "=",
   "griddata",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ",",
   "xi",
   ",",
   "yi",
   ")",
   "X",
   ",",
   "Y",
   "=",
   "meshgrid",
   "(",
   "xi",
   ",",
   "yi",
   ")",
   "# create and customize plot",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "ax",
   "=",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   "chart",
   "=",
   "ax",
   ".",
   "pcolormesh",
   "(",
   "X",
   ",",
   "Y",
   ",",
   "Z",
   ",",
   "cmap",
   "=",
   "cmap",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "xlabel",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "ylabel",
   ")",
   "ax",
   ".",
   "grid",
   "(",
   "grid_on",
   ")",
   "ax",
   ".",
   "set_aspect",
   "(",
   "'equal'",
   ")",
   "if",
   "colorbar",
   ":",
   "plt",
   ".",
   "colorbar",
   "(",
   "chart",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-1117",
  "nl_tokens": [
   "Fetch",
   "the",
   "articles"
  ],
  "pl_tokens": [
   "def",
   "fetch_items",
   "(",
   "self",
   ",",
   "category",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "offset",
   "=",
   "kwargs",
   "[",
   "'offset'",
   "]",
   "logger",
   ".",
   "info",
   "(",
   "\"Fetching articles of '%s' group on '%s' offset %s\"",
   ",",
   "self",
   ".",
   "group",
   ",",
   "self",
   ".",
   "host",
   ",",
   "str",
   "(",
   "offset",
   ")",
   ")",
   "narts",
   ",",
   "iarts",
   ",",
   "tarts",
   "=",
   "(",
   "0",
   ",",
   "0",
   ",",
   "0",
   ")",
   "_",
   ",",
   "_",
   ",",
   "first",
   ",",
   "last",
   ",",
   "_",
   "=",
   "self",
   ".",
   "client",
   ".",
   "group",
   "(",
   "self",
   ".",
   "group",
   ")",
   "if",
   "offset",
   "<=",
   "last",
   ":",
   "first",
   "=",
   "<mask>",
   "(",
   "first",
   ",",
   "offset",
   ")",
   "_",
   ",",
   "overview",
   "=",
   "self",
   ".",
   "client",
   ".",
   "over",
   "(",
   "(",
   "first",
   ",",
   "last",
   ")",
   ")",
   "else",
   ":",
   "overview",
   "=",
   "[",
   "]",
   "tarts",
   "=",
   "len",
   "(",
   "overview",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Total number of articles to fetch: %s\"",
   ",",
   "tarts",
   ")",
   "for",
   "article_id",
   ",",
   "_",
   "in",
   "overview",
   ":",
   "try",
   ":",
   "article_raw",
   "=",
   "self",
   ".",
   "client",
   ".",
   "article",
   "(",
   "article_id",
   ")",
   "article",
   "=",
   "self",
   ".",
   "__parse_article",
   "(",
   "article_raw",
   ")",
   "except",
   "ParseError",
   ":",
   "logger",
   ".",
   "warning",
   "(",
   "\"Error parsing %s article; skipping\"",
   ",",
   "article_id",
   ")",
   "iarts",
   "+=",
   "1",
   "continue",
   "except",
   "nntplib",
   ".",
   "NNTPTemporaryError",
   "as",
   "e",
   ":",
   "logger",
   ".",
   "warning",
   "(",
   "\"Error '%s' fetching article %s; skipping\"",
   ",",
   "e",
   ".",
   "response",
   ",",
   "article_id",
   ")",
   "iarts",
   "+=",
   "1",
   "continue",
   "yield",
   "article",
   "narts",
   "+=",
   "1"
  ]
 },
 {
  "idx": "maxmin-1118",
  "nl_tokens": [
   "Program",
   "graph",
   "has",
   "virtual",
   "qubits",
   "as",
   "nodes",
   ".",
   "Two",
   "nodes",
   "have",
   "an",
   "edge",
   "if",
   "the",
   "corresponding",
   "virtual",
   "qubits",
   "participate",
   "in",
   "a",
   "2",
   "-",
   "qubit",
   "gate",
   ".",
   "The",
   "edge",
   "is",
   "weighted",
   "by",
   "the",
   "number",
   "of",
   "CNOTs",
   "between",
   "the",
   "pair",
   "."
  ],
  "pl_tokens": [
   "def",
   "_create_program_graph",
   "(",
   "self",
   ",",
   "dag",
   ")",
   ":",
   "idx",
   "=",
   "0",
   "for",
   "q",
   "in",
   "dag",
   ".",
   "qubits",
   "(",
   ")",
   ":",
   "self",
   ".",
   "qarg_to_id",
   "[",
   "q",
   "[",
   "0",
   "]",
   ".",
   "name",
   "+",
   "str",
   "(",
   "q",
   "[",
   "1",
   "]",
   ")",
   "]",
   "=",
   "idx",
   "idx",
   "+=",
   "1",
   "for",
   "gate",
   "in",
   "dag",
   ".",
   "twoQ_gates",
   "(",
   ")",
   ":",
   "qid1",
   "=",
   "self",
   ".",
   "_qarg_to_id",
   "(",
   "gate",
   ".",
   "qargs",
   "[",
   "0",
   "]",
   ")",
   "qid2",
   "=",
   "self",
   ".",
   "_qarg_to_id",
   "(",
   "gate",
   ".",
   "qargs",
   "[",
   "1",
   "]",
   ")",
   "min_q",
   "=",
   "<mask>",
   "(",
   "qid1",
   ",",
   "qid2",
   ")",
   "max_q",
   "=",
   "max",
   "(",
   "qid1",
   ",",
   "qid2",
   ")",
   "edge_weight",
   "=",
   "1",
   "if",
   "self",
   ".",
   "prog_graph",
   ".",
   "has_edge",
   "(",
   "min_q",
   ",",
   "max_q",
   ")",
   ":",
   "edge_weight",
   "=",
   "self",
   ".",
   "prog_graph",
   "[",
   "min_q",
   "]",
   "[",
   "max_q",
   "]",
   "[",
   "'weight'",
   "]",
   "+",
   "1",
   "self",
   ".",
   "prog_graph",
   ".",
   "add_edge",
   "(",
   "min_q",
   ",",
   "max_q",
   ",",
   "weight",
   "=",
   "edge_weight",
   ")",
   "return",
   "idx"
  ]
 },
 {
  "idx": "maxmin-1119",
  "nl_tokens": [
   "Get",
   "the",
   "last",
   "n",
   "items",
   "in",
   "readline",
   "history",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_readline_tail",
   "(",
   "self",
   ",",
   "n",
   "=",
   "10",
   ")",
   ":",
   "end",
   "=",
   "self",
   ".",
   "shell",
   ".",
   "readline",
   ".",
   "get_current_history_length",
   "(",
   ")",
   "+",
   "1",
   "start",
   "=",
   "<mask>",
   "(",
   "end",
   "-",
   "n",
   ",",
   "1",
   ")",
   "ghi",
   "=",
   "self",
   ".",
   "shell",
   ".",
   "readline",
   ".",
   "get_history_item",
   "return",
   "[",
   "ghi",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "range",
   "(",
   "start",
   ",",
   "end",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-1120",
  "nl_tokens": [
   "Parse",
   "a",
   "dataframe",
   "with",
   "ensembl",
   "exon",
   "information"
  ],
  "pl_tokens": [
   "def",
   "parse_ensembl_exon_request",
   "(",
   "result",
   ")",
   ":",
   "keys",
   "=",
   "[",
   "'chrom'",
   ",",
   "'gene'",
   ",",
   "'transcript'",
   ",",
   "'exon_id'",
   ",",
   "'exon_chrom_start'",
   ",",
   "'exon_chrom_end'",
   ",",
   "'5_utr_start'",
   ",",
   "'5_utr_end'",
   ",",
   "'3_utr_start'",
   ",",
   "'3_utr_end'",
   ",",
   "'strand'",
   ",",
   "'rank'",
   "]",
   "# for res in result.itertuples():",
   "for",
   "res",
   "in",
   "zip",
   "(",
   "result",
   "[",
   "'Chromosome/scaffold name'",
   "]",
   ",",
   "result",
   "[",
   "'Gene stable ID'",
   "]",
   ",",
   "result",
   "[",
   "'Transcript stable ID'",
   "]",
   ",",
   "result",
   "[",
   "'Exon stable ID'",
   "]",
   ",",
   "result",
   "[",
   "'Exon region start (bp)'",
   "]",
   ",",
   "result",
   "[",
   "'Exon region end (bp)'",
   "]",
   ",",
   "result",
   "[",
   "\"5' UTR start\"",
   "]",
   ",",
   "result",
   "[",
   "\"5' UTR end\"",
   "]",
   ",",
   "result",
   "[",
   "\"3' UTR start\"",
   "]",
   ",",
   "result",
   "[",
   "\"3' UTR end\"",
   "]",
   ",",
   "result",
   "[",
   "\"Strand\"",
   "]",
   ",",
   "result",
   "[",
   "\"Exon rank in transcript\"",
   "]",
   ")",
   ":",
   "ensembl_info",
   "=",
   "dict",
   "(",
   "zip",
   "(",
   "keys",
   ",",
   "res",
   ")",
   ")",
   "# Recalculate start and stop (taking UTR regions into account for end exons)",
   "if",
   "ensembl_info",
   "[",
   "'strand'",
   "]",
   "==",
   "1",
   ":",
   "# highest position: start of exon or end of 5' UTR",
   "# If no 5' UTR make sure exon_start is allways choosen",
   "start",
   "=",
   "<mask>",
   "(",
   "ensembl_info",
   "[",
   "'exon_chrom_start'",
   "]",
   ",",
   "ensembl_info",
   "[",
   "'5_utr_end'",
   "]",
   "or",
   "-",
   "1",
   ")",
   "# lowest position: end of exon or start of 3' UTR",
   "end",
   "=",
   "min",
   "(",
   "ensembl_info",
   "[",
   "'exon_chrom_end'",
   "]",
   ",",
   "ensembl_info",
   "[",
   "'3_utr_start'",
   "]",
   "or",
   "float",
   "(",
   "'inf'",
   ")",
   ")",
   "elif",
   "ensembl_info",
   "[",
   "'strand'",
   "]",
   "==",
   "-",
   "1",
   ":",
   "# highest position: start of exon or end of 3' UTR",
   "start",
   "=",
   "max",
   "(",
   "ensembl_info",
   "[",
   "'exon_chrom_start'",
   "]",
   ",",
   "ensembl_info",
   "[",
   "'3_utr_end'",
   "]",
   "or",
   "-",
   "1",
   ")",
   "# lowest position: end of exon or start of 5' UTR",
   "end",
   "=",
   "min",
   "(",
   "ensembl_info",
   "[",
   "'exon_chrom_end'",
   "]",
   ",",
   "ensembl_info",
   "[",
   "'5_utr_start'",
   "]",
   "or",
   "float",
   "(",
   "'inf'",
   ")",
   ")",
   "ensembl_info",
   "[",
   "'start'",
   "]",
   "=",
   "start",
   "ensembl_info",
   "[",
   "'end'",
   "]",
   "=",
   "end",
   "yield",
   "ensembl_info"
  ]
 },
 {
  "idx": "maxmin-1121",
  "nl_tokens": [
   "Merges",
   "derived",
   "parameters",
   "that",
   "have",
   "the",
   "run_ALL",
   "in",
   "a",
   "name",
   "."
  ],
  "pl_tokens": [
   "def",
   "_merge_derived_parameters",
   "(",
   "self",
   ",",
   "other_trajectory",
   ",",
   "used_runs",
   ",",
   "rename_dict",
   ",",
   "allowed_translations",
   ",",
   "ignore_data",
   ")",
   ":",
   "other_derived_parameters",
   "=",
   "other_trajectory",
   ".",
   "_derived_parameters",
   ".",
   "copy",
   "(",
   ")",
   "# get first run_idx",
   "new_first_run_idx",
   "=",
   "<mask>",
   "(",
   "used_runs",
   ".",
   "values",
   "(",
   ")",
   ")",
   "run_name_dummy",
   "=",
   "other_trajectory",
   ".",
   "f_wildcard",
   "(",
   "'$'",
   ",",
   "-",
   "1",
   ")",
   "for",
   "param_name",
   "in",
   "other_derived_parameters",
   ":",
   "if",
   "param_name",
   "in",
   "ignore_data",
   ":",
   "continue",
   "split_name",
   "=",
   "param_name",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   "if",
   "not",
   "any",
   "(",
   "x",
   "in",
   "run_name_dummy",
   "for",
   "x",
   "in",
   "split_name",
   ")",
   ":",
   "continue",
   "ignore_data",
   ".",
   "add",
   "(",
   "param_name",
   ")",
   "param",
   "=",
   "other_derived_parameters",
   "[",
   "param_name",
   "]",
   "new_param_name",
   "=",
   "self",
   ".",
   "_rename_full_name",
   "(",
   "param_name",
   ",",
   "other_trajectory",
   ",",
   "used_runs",
   "=",
   "used_runs",
   ")",
   "if",
   "new_param_name",
   "in",
   "self",
   ":",
   "my_param",
   "=",
   "self",
   ".",
   "f_get",
   "(",
   "new_param_name",
   ",",
   "fast_access",
   "=",
   "False",
   ")",
   "if",
   "(",
   "my_param",
   ".",
   "_equal_values",
   "(",
   "my_param",
   ".",
   "f_get",
   "(",
   ")",
   ",",
   "param",
   ".",
   "f_get",
   "(",
   ")",
   ")",
   "and",
   "not",
   "(",
   "my_param",
   ".",
   "f_has_range",
   "(",
   ")",
   "or",
   "param",
   ".",
   "f_has_range",
   "(",
   ")",
   ")",
   ")",
   ":",
   "continue",
   "first_new_param_name",
   "=",
   "self",
   ".",
   "_rename_full_name",
   "(",
   "param_name",
   ",",
   "other_trajectory",
   ",",
   "new_run_idx",
   "=",
   "new_first_run_idx",
   ")",
   "rename_dict",
   "[",
   "param_name",
   "]",
   "=",
   "first_new_param_name",
   "comment",
   "=",
   "param",
   ".",
   "v_comment",
   "param_type",
   "=",
   "param",
   ".",
   "f_get_class_name",
   "(",
   ")",
   "param_type",
   "=",
   "self",
   ".",
   "_create_class",
   "(",
   "param_type",
   ")",
   "first_param",
   "=",
   "self",
   ".",
   "f_add_leaf",
   "(",
   "param_type",
   ",",
   "first_new_param_name",
   ",",
   "comment",
   "=",
   "comment",
   ")",
   "for",
   "run_idx",
   "in",
   "used_runs",
   ".",
   "values",
   "(",
   ")",
   ":",
   "if",
   "run_idx",
   "==",
   "new_first_run_idx",
   ":",
   "continue",
   "next_name",
   "=",
   "self",
   ".",
   "_rename_full_name",
   "(",
   "param_name",
   ",",
   "other_trajectory",
   ",",
   "new_run_idx",
   "=",
   "run_idx",
   ")",
   "split_name",
   "=",
   "next_name",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   "link_name",
   "=",
   "split_name",
   ".",
   "pop",
   "(",
   ")",
   "location_name",
   "=",
   "'.'",
   ".",
   "join",
   "(",
   "split_name",
   ")",
   "if",
   "not",
   "self",
   ".",
   "f_contains",
   "(",
   "location_name",
   ",",
   "shortcuts",
   "=",
   "False",
   ")",
   ":",
   "the_group",
   "=",
   "self",
   ".",
   "f_add_group",
   "(",
   "location_name",
   ")",
   "else",
   ":",
   "the_group",
   "=",
   "self",
   ".",
   "f_get",
   "(",
   "location_name",
   ")",
   "the_group",
   ".",
   "f_add_link",
   "(",
   "link_name",
   ",",
   "first_param",
   ")",
   "for",
   "param_name",
   "in",
   "other_derived_parameters",
   ":",
   "if",
   "param_name",
   "in",
   "ignore_data",
   ":",
   "continue",
   "split_name",
   "=",
   "param_name",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   "ignore_data",
   ".",
   "add",
   "(",
   "param_name",
   ")",
   "if",
   "any",
   "(",
   "x",
   "in",
   "other_trajectory",
   ".",
   "_reversed_wildcards",
   "and",
   "x",
   "not",
   "in",
   "allowed_translations",
   "for",
   "x",
   "in",
   "split_name",
   ")",
   ":",
   "continue",
   "new_name",
   "=",
   "self",
   ".",
   "_rename_full_name",
   "(",
   "param_name",
   ",",
   "other_trajectory",
   ",",
   "used_runs",
   "=",
   "used_runs",
   ")",
   "if",
   "self",
   ".",
   "f_contains",
   "(",
   "new_name",
   ")",
   ":",
   "my_param",
   "=",
   "self",
   ".",
   "f_get",
   "(",
   "new_name",
   ",",
   "fast_access",
   "=",
   "False",
   ")",
   "param",
   "=",
   "other_derived_parameters",
   "[",
   "param_name",
   "]",
   "if",
   "(",
   "my_param",
   ".",
   "_equal_values",
   "(",
   "my_param",
   ".",
   "f_get",
   "(",
   ")",
   ",",
   "param",
   ".",
   "f_get",
   "(",
   ")",
   ")",
   "and",
   "not",
   "(",
   "my_param",
   ".",
   "f_has_range",
   "(",
   ")",
   "or",
   "param",
   ".",
   "f_has_range",
   "(",
   ")",
   ")",
   ")",
   ":",
   "continue",
   "else",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "error",
   "(",
   "'Could not merge parameter `%s`. '",
   "'I will ignore it!'",
   "%",
   "new_name",
   ")",
   "rename_dict",
   "[",
   "param_name",
   "]",
   "=",
   "new_name"
  ]
 },
 {
  "idx": "maxmin-1122",
  "nl_tokens": [
   "Creates",
   "the",
   "sentence",
   "alignment",
   "of",
   "two",
   "blocks",
   "of",
   "texts",
   "(",
   "usually",
   "paragraphs",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "align_blocks",
   "(",
   "source_sentences",
   ",",
   "target_sentences",
   ",",
   "params",
   "=",
   "LanguageIndependent",
   ")",
   ":",
   "alignment_types",
   "=",
   "list",
   "(",
   "params",
   ".",
   "PRIORS",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "# there are always three rows in the history (with the last of them being filled)",
   "# and the rows are always |target_text| + 2, so that we never have to do",
   "# boundary checks",
   "D",
   "=",
   "[",
   "(",
   "len",
   "(",
   "target_sentences",
   ")",
   "+",
   "2",
   ")",
   "*",
   "[",
   "0",
   "]",
   "for",
   "x",
   "in",
   "range",
   "(",
   "2",
   ")",
   "]",
   "# for the first sentence, only substitution, insertion or deletion are",
   "# allowed, and they are all equally likely ( == 1)",
   "D",
   ".",
   "append",
   "(",
   "[",
   "0",
   ",",
   "1",
   "]",
   ")",
   "try",
   ":",
   "D",
   "[",
   "-",
   "2",
   "]",
   "[",
   "1",
   "]",
   "=",
   "1",
   "D",
   "[",
   "-",
   "2",
   "]",
   "[",
   "2",
   "]",
   "=",
   "1",
   "except",
   ":",
   "pass",
   "backlinks",
   "=",
   "{",
   "}",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "source_sentences",
   ")",
   ")",
   ":",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "target_sentences",
   ")",
   ")",
   ":",
   "m",
   "=",
   "[",
   "]",
   "for",
   "a",
   "in",
   "alignment_types",
   ":",
   "k",
   "=",
   "D",
   "[",
   "-",
   "(",
   "1",
   "+",
   "a",
   "[",
   "0",
   "]",
   ")",
   "]",
   "[",
   "j",
   "+",
   "2",
   "-",
   "a",
   "[",
   "1",
   "]",
   "]",
   "if",
   "k",
   ">",
   "0",
   ":",
   "p",
   "=",
   "k",
   "*",
   "align_probability",
   "(",
   "i",
   ",",
   "j",
   ",",
   "source_sentences",
   ",",
   "target_sentences",
   ",",
   "a",
   ",",
   "params",
   ")",
   "m",
   ".",
   "append",
   "(",
   "(",
   "p",
   ",",
   "a",
   ")",
   ")",
   "if",
   "len",
   "(",
   "m",
   ")",
   ">",
   "0",
   ":",
   "v",
   "=",
   "<mask>",
   "(",
   "m",
   ")",
   "backlinks",
   "[",
   "(",
   "i",
   ",",
   "j",
   ")",
   "]",
   "=",
   "v",
   "[",
   "1",
   "]",
   "D",
   "[",
   "-",
   "1",
   "]",
   ".",
   "append",
   "(",
   "v",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "backlinks",
   "[",
   "(",
   "i",
   ",",
   "j",
   ")",
   "]",
   "=",
   "(",
   "1",
   ",",
   "1",
   ")",
   "D",
   "[",
   "-",
   "1",
   "]",
   ".",
   "append",
   "(",
   "0",
   ")",
   "D",
   ".",
   "pop",
   "(",
   "0",
   ")",
   "D",
   ".",
   "append",
   "(",
   "[",
   "0",
   ",",
   "0",
   "]",
   ")",
   "return",
   "trace",
   "(",
   "backlinks",
   ",",
   "source_sentences",
   ",",
   "target_sentences",
   ")"
  ]
 },
 {
  "idx": "maxmin-1123",
  "nl_tokens": [
   "Plot",
   "root",
   "-",
   "to",
   "-",
   "tip",
   "distance",
   "vs",
   "time",
   "as",
   "a",
   "basic",
   "time",
   "-",
   "tree",
   "diagnostic"
  ],
  "pl_tokens": [
   "def",
   "clock_plot",
   "(",
   "self",
   ",",
   "add_internal",
   "=",
   "False",
   ",",
   "ax",
   "=",
   "None",
   ",",
   "regression",
   "=",
   "None",
   ",",
   "confidence",
   "=",
   "True",
   ",",
   "n_sigma",
   "=",
   "2",
   ",",
   "fs",
   "=",
   "14",
   ")",
   ":",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "if",
   "ax",
   "is",
   "None",
   ":",
   "plt",
   ".",
   "figure",
   "(",
   ")",
   "ax",
   "=",
   "plt",
   ".",
   "subplot",
   "(",
   "111",
   ")",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "_v",
   "=",
   "0",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "get_nonterminals",
   "(",
   "order",
   "=",
   "'preorder'",
   ")",
   ":",
   "for",
   "c",
   "in",
   "n",
   ":",
   "c",
   ".",
   "_v",
   "=",
   "n",
   ".",
   "_v",
   "+",
   "self",
   ".",
   "branch_value",
   "(",
   "c",
   ")",
   "tips",
   "=",
   "self",
   ".",
   "tree",
   ".",
   "get_terminals",
   "(",
   ")",
   "internal",
   "=",
   "self",
   ".",
   "tree",
   ".",
   "get_nonterminals",
   "(",
   ")",
   "# get values of terminals",
   "xi",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "self",
   ".",
   "tip_value",
   "(",
   "n",
   ")",
   "for",
   "n",
   "in",
   "tips",
   "]",
   ")",
   "yi",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "n",
   ".",
   "_v",
   "for",
   "n",
   "in",
   "tips",
   "]",
   ")",
   "ind",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "n",
   ".",
   "bad_branch",
   "if",
   "hasattr",
   "(",
   "n",
   ",",
   "'bad_branch'",
   ")",
   "else",
   "False",
   "for",
   "n",
   "in",
   "tips",
   "]",
   ")",
   "if",
   "add_internal",
   ":",
   "xi_int",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "n",
   ".",
   "numdate",
   "for",
   "n",
   "in",
   "internal",
   "]",
   ")",
   "yi_int",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "n",
   ".",
   "_v",
   "for",
   "n",
   "in",
   "internal",
   "]",
   ")",
   "ind_int",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "n",
   ".",
   "bad_branch",
   "if",
   "hasattr",
   "(",
   "n",
   ",",
   "'bad_branch'",
   ")",
   "else",
   "False",
   "for",
   "n",
   "in",
   "internal",
   "]",
   ")",
   "if",
   "regression",
   ":",
   "# plot regression line",
   "t_mrca",
   "=",
   "-",
   "regression",
   "[",
   "'intercept'",
   "]",
   "/",
   "regression",
   "[",
   "'slope'",
   "]",
   "if",
   "add_internal",
   ":",
   "time_span",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "xi_int",
   "[",
   "~",
   "ind_int",
   "]",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "xi_int",
   "[",
   "~",
   "ind_int",
   "]",
   ")",
   "x_vals",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "max",
   "(",
   "np",
   ".",
   "min",
   "(",
   "xi_int",
   "[",
   "~",
   "ind_int",
   "]",
   ")",
   ",",
   "t_mrca",
   ")",
   "-",
   "0.1",
   "*",
   "time_span",
   ",",
   "np",
   ".",
   "max",
   "(",
   "xi",
   "[",
   "~",
   "ind",
   "]",
   ")",
   "+",
   "0.05",
   "*",
   "time_span",
   "]",
   ")",
   "else",
   ":",
   "time_span",
   "=",
   "np",
   ".",
   "max",
   "(",
   "xi",
   "[",
   "~",
   "ind",
   "]",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "xi",
   "[",
   "~",
   "ind",
   "]",
   ")",
   "x_vals",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "max",
   "(",
   "np",
   ".",
   "min",
   "(",
   "xi",
   "[",
   "~",
   "ind",
   "]",
   ")",
   ",",
   "t_mrca",
   ")",
   "-",
   "0.1",
   "*",
   "time_span",
   ",",
   "np",
   ".",
   "max",
   "(",
   "xi",
   "[",
   "~",
   "ind",
   "]",
   "+",
   "0.05",
   "*",
   "time_span",
   ")",
   "]",
   ")",
   "# plot confidence interval",
   "if",
   "confidence",
   "and",
   "'cov'",
   "in",
   "regression",
   ":",
   "x_vals",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "x_vals",
   "[",
   "0",
   "]",
   ",",
   "x_vals",
   "[",
   "1",
   "]",
   ",",
   "100",
   ")",
   "y_vals",
   "=",
   "regression",
   "[",
   "'slope'",
   "]",
   "*",
   "x_vals",
   "+",
   "regression",
   "[",
   "'intercept'",
   "]",
   "dev",
   "=",
   "n_sigma",
   "*",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "sqrt",
   "(",
   "regression",
   "[",
   "'cov'",
   "]",
   "[",
   ":",
   "2",
   ",",
   ":",
   "2",
   "]",
   ".",
   "dot",
   "(",
   "np",
   ".",
   "array",
   "(",
   "[",
   "x",
   ",",
   "1",
   "]",
   ")",
   ")",
   ".",
   "dot",
   "(",
   "np",
   ".",
   "array",
   "(",
   "[",
   "x",
   ",",
   "1",
   "]",
   ")",
   ")",
   ")",
   "for",
   "x",
   "in",
   "x_vals",
   "]",
   ")",
   "dev_slope",
   "=",
   "n_sigma",
   "*",
   "np",
   ".",
   "sqrt",
   "(",
   "regression",
   "[",
   "'cov'",
   "]",
   "[",
   "0",
   ",",
   "0",
   "]",
   ")",
   "ax",
   ".",
   "fill_between",
   "(",
   "x_vals",
   ",",
   "y_vals",
   "-",
   "dev",
   ",",
   "y_vals",
   "+",
   "dev",
   ",",
   "alpha",
   "=",
   "0.2",
   ")",
   "dp",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "regression",
   "[",
   "'intercept'",
   "]",
   "/",
   "regression",
   "[",
   "'slope'",
   "]",
   "**",
   "2",
   ",",
   "-",
   "1.",
   "/",
   "regression",
   "[",
   "'slope'",
   "]",
   "]",
   ")",
   "dev_rtt",
   "=",
   "n_sigma",
   "*",
   "np",
   ".",
   "sqrt",
   "(",
   "regression",
   "[",
   "'cov'",
   "]",
   "[",
   ":",
   "2",
   ",",
   ":",
   "2",
   "]",
   ".",
   "dot",
   "(",
   "dp",
   ")",
   ".",
   "dot",
   "(",
   "dp",
   ")",
   ")",
   "else",
   ":",
   "dev_rtt",
   "=",
   "None",
   "dev_slope",
   "=",
   "None",
   "ax",
   ".",
   "plot",
   "(",
   "x_vals",
   ",",
   "regression",
   "[",
   "'slope'",
   "]",
   "*",
   "x_vals",
   "+",
   "regression",
   "[",
   "'intercept'",
   "]",
   ",",
   "label",
   "=",
   "r\"$y=\\alpha + \\beta t$\"",
   "+",
   "\"\\n\"",
   "+",
   "r\"$\\beta=$%1.2e\"",
   "%",
   "(",
   "regression",
   "[",
   "\"slope\"",
   "]",
   ")",
   "+",
   "(",
   "\"+/- %1.e\"",
   "%",
   "dev_slope",
   "if",
   "dev_slope",
   "else",
   "\"\"",
   ")",
   "+",
   "\"\\nroot date: %1.1f\"",
   "%",
   "(",
   "-",
   "regression",
   "[",
   "'intercept'",
   "]",
   "/",
   "regression",
   "[",
   "'slope'",
   "]",
   ")",
   "+",
   "(",
   "\"+/- %1.2f\"",
   "%",
   "dev_rtt",
   "if",
   "dev_rtt",
   "else",
   "\"\"",
   ")",
   ")",
   "ax",
   ".",
   "scatter",
   "(",
   "xi",
   "[",
   "~",
   "ind",
   "]",
   ",",
   "yi",
   "[",
   "~",
   "ind",
   "]",
   ",",
   "label",
   "=",
   "(",
   "\"tips\"",
   "if",
   "add_internal",
   "else",
   "None",
   ")",
   ")",
   "if",
   "ind",
   ".",
   "sum",
   "(",
   ")",
   ":",
   "try",
   ":",
   "# note: this is treetime specific",
   "tmp_x",
   "=",
   "np",
   ".",
   "array",
   "(",
   "[",
   "np",
   ".",
   "mean",
   "(",
   "n",
   ".",
   "raw_date_constraint",
   ")",
   "if",
   "n",
   ".",
   "raw_date_constraint",
   "else",
   "None",
   "for",
   "n",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "get_terminals",
   "(",
   ")",
   "]",
   ")",
   "ax",
   ".",
   "scatter",
   "(",
   "tmp_x",
   "[",
   "ind",
   "]",
   ",",
   "yi",
   "[",
   "ind",
   "]",
   ",",
   "label",
   "=",
   "\"ignored tips\"",
   ",",
   "c",
   "=",
   "'r'",
   ")",
   "except",
   ":",
   "pass",
   "if",
   "add_internal",
   ":",
   "ax",
   ".",
   "scatter",
   "(",
   "xi_int",
   "[",
   "~",
   "ind_int",
   "]",
   ",",
   "yi_int",
   "[",
   "~",
   "ind_int",
   "]",
   ",",
   "label",
   "=",
   "\"internal nodes\"",
   ")",
   "ax",
   ".",
   "set_ylabel",
   "(",
   "'root-to-tip distance'",
   ",",
   "fontsize",
   "=",
   "fs",
   ")",
   "ax",
   ".",
   "set_xlabel",
   "(",
   "'date'",
   ",",
   "fontsize",
   "=",
   "fs",
   ")",
   "ax",
   ".",
   "ticklabel_format",
   "(",
   "useOffset",
   "=",
   "False",
   ")",
   "ax",
   ".",
   "tick_params",
   "(",
   "labelsize",
   "=",
   "fs",
   "*",
   "0.8",
   ")",
   "ax",
   ".",
   "set_ylim",
   "(",
   "[",
   "0",
   ",",
   "1.1",
   "*",
   "np",
   ".",
   "max",
   "(",
   "yi",
   ")",
   "]",
   ")",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "legend",
   "(",
   "fontsize",
   "=",
   "fs",
   "*",
   "0.8",
   ")"
  ]
 },
 {
  "idx": "maxmin-1124",
  "nl_tokens": [
   "Basic",
   "onset",
   "detector",
   ".",
   "Locate",
   "note",
   "onset",
   "events",
   "by",
   "picking",
   "peaks",
   "in",
   "an",
   "onset",
   "strength",
   "envelope",
   "."
  ],
  "pl_tokens": [
   "def",
   "onset_detect",
   "(",
   "y",
   "=",
   "None",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "onset_envelope",
   "=",
   "None",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "backtrack",
   "=",
   "False",
   ",",
   "energy",
   "=",
   "None",
   ",",
   "units",
   "=",
   "'frames'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# First, get the frame->beat strength profile if we don't already have one",
   "if",
   "onset_envelope",
   "is",
   "None",
   ":",
   "if",
   "y",
   "is",
   "None",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'y or onset_envelope must be provided'",
   ")",
   "onset_envelope",
   "=",
   "onset_strength",
   "(",
   "y",
   "=",
   "y",
   ",",
   "sr",
   "=",
   "sr",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "# Shift onset envelope up to be non-negative",
   "# (a common normalization step to make the threshold more consistent)",
   "onset_envelope",
   "-=",
   "onset_envelope",
   ".",
   "<mask>",
   "(",
   ")",
   "# Do we have any onsets to grab?",
   "if",
   "not",
   "onset_envelope",
   ".",
   "any",
   "(",
   ")",
   ":",
   "return",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int",
   ")",
   "# Normalize onset strength function to [0, 1] range",
   "onset_envelope",
   "/=",
   "onset_envelope",
   ".",
   "max",
   "(",
   ")",
   "# These parameter settings found by large-scale search",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'pre_max'",
   ",",
   "0.03",
   "*",
   "sr",
   "//",
   "hop_length",
   ")",
   "# 30ms",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'post_max'",
   ",",
   "0.00",
   "*",
   "sr",
   "//",
   "hop_length",
   "+",
   "1",
   ")",
   "# 0ms",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'pre_avg'",
   ",",
   "0.10",
   "*",
   "sr",
   "//",
   "hop_length",
   ")",
   "# 100ms",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'post_avg'",
   ",",
   "0.10",
   "*",
   "sr",
   "//",
   "hop_length",
   "+",
   "1",
   ")",
   "# 100ms",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'wait'",
   ",",
   "0.03",
   "*",
   "sr",
   "//",
   "hop_length",
   ")",
   "# 30ms",
   "kwargs",
   ".",
   "setdefault",
   "(",
   "'delta'",
   ",",
   "0.07",
   ")",
   "# Peak pick the onset envelope",
   "onsets",
   "=",
   "util",
   ".",
   "peak_pick",
   "(",
   "onset_envelope",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "# Optionally backtrack the events",
   "if",
   "backtrack",
   ":",
   "if",
   "energy",
   "is",
   "None",
   ":",
   "energy",
   "=",
   "onset_envelope",
   "onsets",
   "=",
   "onset_backtrack",
   "(",
   "onsets",
   ",",
   "energy",
   ")",
   "if",
   "units",
   "==",
   "'frames'",
   ":",
   "pass",
   "elif",
   "units",
   "==",
   "'samples'",
   ":",
   "onsets",
   "=",
   "core",
   ".",
   "frames_to_samples",
   "(",
   "onsets",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "elif",
   "units",
   "==",
   "'time'",
   ":",
   "onsets",
   "=",
   "core",
   ".",
   "frames_to_time",
   "(",
   "onsets",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ",",
   "sr",
   "=",
   "sr",
   ")",
   "else",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Invalid unit type: {}'",
   ".",
   "format",
   "(",
   "units",
   ")",
   ")",
   "return",
   "onsets"
  ]
 },
 {
  "idx": "maxmin-1125",
  "nl_tokens": [
   "Program",
   "counter",
   "."
  ],
  "pl_tokens": [
   "def",
   "run",
   "(",
   "self",
   ",",
   "args",
   ")",
   ":",
   "mainfile",
   "=",
   "self",
   ".",
   "core",
   ".",
   "filename",
   "(",
   "None",
   ")",
   "if",
   "self",
   ".",
   "core",
   ".",
   "is_running",
   "(",
   ")",
   ":",
   "curframe",
   "=",
   "self",
   ".",
   "proc",
   ".",
   "curframe",
   "if",
   "curframe",
   ":",
   "line_no",
   "=",
   "inspect",
   ".",
   "getlineno",
   "(",
   "curframe",
   ")",
   "offset",
   "=",
   "curframe",
   ".",
   "f_lasti",
   "self",
   ".",
   "msg",
   "(",
   "\"PC offset is %d.\"",
   "%",
   "offset",
   ")",
   "offset",
   "=",
   "<mask>",
   "(",
   "offset",
   ",",
   "0",
   ")",
   "code",
   "=",
   "curframe",
   ".",
   "f_code",
   "co_code",
   "=",
   "code",
   ".",
   "co_code",
   "disassemble_bytes",
   "(",
   "self",
   ".",
   "msg",
   ",",
   "self",
   ".",
   "msg_nocr",
   ",",
   "co_code",
   ",",
   "offset",
   ",",
   "line_no",
   ",",
   "line_no",
   "-",
   "1",
   ",",
   "line_no",
   "+",
   "1",
   ",",
   "constants",
   "=",
   "code",
   ".",
   "co_consts",
   ",",
   "cells",
   "=",
   "code",
   ".",
   "co_cellvars",
   ",",
   "varnames",
   "=",
   "code",
   ".",
   "co_varnames",
   ",",
   "freevars",
   "=",
   "code",
   ".",
   "co_freevars",
   ",",
   "linestarts",
   "=",
   "dict",
   "(",
   "findlinestarts",
   "(",
   "code",
   ")",
   ")",
   ",",
   "end_offset",
   "=",
   "offset",
   "+",
   "10",
   ")",
   "pass",
   "pass",
   "else",
   ":",
   "if",
   "mainfile",
   ":",
   "part1",
   "=",
   "\"Python program '%s'\"",
   "%",
   "mainfile",
   "msg",
   "=",
   "\"is not currently running. \"",
   "self",
   ".",
   "msg",
   "(",
   "Mmisc",
   ".",
   "wrapped_lines",
   "(",
   "part1",
   ",",
   "msg",
   ",",
   "self",
   ".",
   "settings",
   "[",
   "'width'",
   "]",
   ")",
   ")",
   "else",
   ":",
   "self",
   ".",
   "msg",
   "(",
   "'No Python program is currently running.'",
   ")",
   "pass",
   "self",
   ".",
   "msg",
   "(",
   "self",
   ".",
   "core",
   ".",
   "execution_status",
   ")",
   "pass",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-1126",
  "nl_tokens": [
   "generator",
   "that",
   "yields",
   "clean",
   "visible",
   "as",
   "it",
   "transitions",
   "through",
   "states",
   "in",
   "the",
   "raw",
   "html"
  ],
  "pl_tokens": [
   "def",
   "non_tag_chars_from_raw",
   "(",
   "html",
   ")",
   ":",
   "n",
   "=",
   "0",
   "while",
   "n",
   "<",
   "len",
   "(",
   "html",
   ")",
   ":",
   "# find start of tag",
   "angle",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'<'",
   ",",
   "n",
   ")",
   "if",
   "angle",
   "==",
   "-",
   "1",
   ":",
   "yield",
   "html",
   "[",
   "n",
   ":",
   "]",
   "n",
   "=",
   "len",
   "(",
   "html",
   ")",
   "break",
   "yield",
   "html",
   "[",
   "n",
   ":",
   "angle",
   "]",
   "n",
   "=",
   "angle",
   "# find the end of the tag string",
   "space",
   "=",
   "html",
   ".",
   "find",
   "(",
   "' '",
   ",",
   "n",
   ",",
   "n",
   "+",
   "longest_extended_tag",
   "+",
   "2",
   ")",
   "angle",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'>'",
   ",",
   "n",
   ",",
   "n",
   "+",
   "longest_extended_tag",
   "+",
   "2",
   ")",
   "nl",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\\n'",
   ",",
   "n",
   ",",
   "n",
   "+",
   "longest_extended_tag",
   "+",
   "2",
   ")",
   "tab",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\\t'",
   ",",
   "n",
   ",",
   "n",
   "+",
   "longest_extended_tag",
   "+",
   "2",
   ")",
   "ends",
   "=",
   "filter",
   "(",
   "lambda",
   "end",
   ":",
   "end",
   ">",
   "-",
   "1",
   ",",
   "[",
   "tab",
   ",",
   "nl",
   ",",
   "space",
   ",",
   "angle",
   "]",
   ")",
   "if",
   "ends",
   ":",
   "tag",
   "=",
   "html",
   "[",
   "n",
   "+",
   "1",
   ":",
   "<mask>",
   "(",
   "ends",
   ")",
   "]",
   "if",
   "tag",
   "==",
   "'!--'",
   ":",
   "# whiteout comment except newlines",
   "end",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'-->'",
   ",",
   "n",
   ")",
   "while",
   "n",
   "<",
   "end",
   ":",
   "nl",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\\n'",
   ",",
   "n",
   ",",
   "end",
   ")",
   "if",
   "nl",
   "!=",
   "-",
   "1",
   ":",
   "yield",
   "' '",
   "*",
   "(",
   "nl",
   "-",
   "n",
   ")",
   "+",
   "'\\n'",
   "n",
   "=",
   "nl",
   "+",
   "1",
   "else",
   ":",
   "yield",
   "' '",
   "*",
   "(",
   "end",
   "-",
   "n",
   "+",
   "3",
   ")",
   "break",
   "n",
   "=",
   "end",
   "+",
   "3",
   "continue",
   "is_extended",
   "=",
   "tag",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "extended_tags",
   "else",
   ":",
   "is_extended",
   "=",
   "False",
   "# find end of tag even if on a lower line",
   "while",
   "n",
   "<",
   "len",
   "(",
   "html",
   ")",
   ":",
   "squote",
   "=",
   "html",
   ".",
   "find",
   "(",
   "\"'\"",
   ",",
   "n",
   ")",
   "dquote",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\"'",
   ",",
   "n",
   ")",
   "nl",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\\n'",
   ",",
   "n",
   ")",
   "angle",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'>'",
   ",",
   "n",
   ")",
   "if",
   "angle",
   "==",
   "-",
   "1",
   ":",
   "# hits end of doc before end of tag",
   "yield",
   "' '",
   "*",
   "(",
   "len",
   "(",
   "html",
   ")",
   "-",
   "n",
   ")",
   "n",
   "=",
   "len",
   "(",
   "html",
   ")",
   "break",
   "elif",
   "-",
   "1",
   "<",
   "squote",
   "<",
   "angle",
   "or",
   "-",
   "1",
   "<",
   "dquote",
   "<",
   "angle",
   ":",
   "if",
   "squote",
   "!=",
   "-",
   "1",
   "and",
   "dquote",
   "!=",
   "-",
   "1",
   ":",
   "if",
   "squote",
   "<",
   "dquote",
   ":",
   "open_quote",
   "=",
   "squote",
   "quote",
   "=",
   "\"'\"",
   "else",
   ":",
   "open_quote",
   "=",
   "dquote",
   "quote",
   "=",
   "'\"'",
   "elif",
   "dquote",
   "!=",
   "-",
   "1",
   ":",
   "open_quote",
   "=",
   "dquote",
   "quote",
   "=",
   "'\"'",
   "else",
   ":",
   "open_quote",
   "=",
   "squote",
   "quote",
   "=",
   "\"'\"",
   "close_quote",
   "=",
   "html",
   ".",
   "find",
   "(",
   "quote",
   ",",
   "open_quote",
   "+",
   "1",
   ")",
   "while",
   "n",
   "<",
   "close_quote",
   ":",
   "nl",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\\n'",
   ",",
   "n",
   ",",
   "close_quote",
   ")",
   "if",
   "nl",
   "==",
   "-",
   "1",
   ":",
   "break",
   "yield",
   "' '",
   "*",
   "(",
   "nl",
   "-",
   "n",
   ")",
   "+",
   "'\\n'",
   "n",
   "=",
   "nl",
   "+",
   "1",
   "yield",
   "' '",
   "*",
   "(",
   "close_quote",
   "+",
   "1",
   "-",
   "n",
   ")",
   "n",
   "=",
   "close_quote",
   "+",
   "1",
   "continue",
   "elif",
   "nl",
   "==",
   "-",
   "1",
   "or",
   "angle",
   "<",
   "nl",
   ":",
   "# found close before either newline or end of doc",
   "yield",
   "' '",
   "*",
   "(",
   "angle",
   "+",
   "1",
   "-",
   "n",
   ")",
   "n",
   "=",
   "angle",
   "+",
   "1",
   "if",
   "is_extended",
   "and",
   "html",
   "[",
   "angle",
   "-",
   "1",
   "]",
   "!=",
   "'/'",
   ":",
   "# find matching closing tag. JavaScript can",
   "# include HTML *strings* within it, and in",
   "# principle, that HTML could contain a closing",
   "# script tag in it; ignoring for now.",
   "while",
   "n",
   "<",
   "len",
   "(",
   "html",
   ")",
   ":",
   "nl",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'\\n'",
   ",",
   "n",
   ")",
   "close",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'</'",
   ",",
   "n",
   ")",
   "close2",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'</'",
   ",",
   "close",
   "+",
   "2",
   ")",
   "angle",
   "=",
   "html",
   ".",
   "find",
   "(",
   "'>'",
   ",",
   "close",
   "+",
   "2",
   ")",
   "if",
   "nl",
   "!=",
   "-",
   "1",
   "and",
   "nl",
   "<",
   "close",
   ":",
   "yield",
   "' '",
   "*",
   "(",
   "nl",
   "-",
   "n",
   ")",
   "+",
   "'\\n'",
   "n",
   "=",
   "nl",
   "+",
   "1",
   "elif",
   "close",
   "==",
   "-",
   "1",
   "or",
   "angle",
   "==",
   "-",
   "1",
   ":",
   "# end of doc before matching close tag",
   "yield",
   "' '",
   "*",
   "(",
   "len",
   "(",
   "html",
   ")",
   "-",
   "n",
   ")",
   "n",
   "=",
   "len",
   "(",
   "html",
   ")",
   "break",
   "elif",
   "close2",
   "!=",
   "-",
   "1",
   "and",
   "close2",
   "<",
   "angle",
   ":",
   "# broken tag inside current tag",
   "yield",
   "' '",
   "*",
   "(",
   "close",
   "+",
   "2",
   "-",
   "n",
   ")",
   "n",
   "=",
   "close",
   "+",
   "2",
   "elif",
   "html",
   "[",
   "close",
   "+",
   "2",
   ":",
   "angle",
   "]",
   ".",
   "lower",
   "(",
   ")",
   "==",
   "tag",
   ".",
   "lower",
   "(",
   ")",
   ":",
   "yield",
   "' '",
   "*",
   "(",
   "angle",
   "+",
   "1",
   "-",
   "n",
   ")",
   "n",
   "=",
   "angle",
   "+",
   "1",
   "break",
   "else",
   ":",
   "yield",
   "' '",
   "*",
   "(",
   "angle",
   "+",
   "1",
   "-",
   "n",
   ")",
   "n",
   "=",
   "angle",
   "+",
   "1",
   "# do not break",
   "# finished with tag",
   "break",
   "else",
   ":",
   "# found a newline within the current tag",
   "yield",
   "' '",
   "*",
   "(",
   "nl",
   "-",
   "n",
   ")",
   "+",
   "'\\n'",
   "n",
   "=",
   "nl",
   "+",
   "1"
  ]
 },
 {
  "idx": "maxmin-1127",
  "nl_tokens": [
   ":",
   "param",
   "DatasetLocal",
   "dataset",
   ":",
   "dataset",
   "to",
   "export",
   ":",
   "param",
   "str",
   "path",
   ":",
   "path",
   "for",
   "file",
   ":",
   "param",
   "lis",
   "[",
   "str",
   "]",
   "column_names",
   ":",
   "list",
   "of",
   "column",
   "names",
   "to",
   "export",
   "or",
   "None",
   "for",
   "all",
   "columns",
   ":",
   "param",
   "bool",
   "shuffle",
   ":",
   "export",
   "rows",
   "in",
   "random",
   "order",
   ":",
   "param",
   "bool",
   "selection",
   ":",
   "export",
   "selection",
   "or",
   "not",
   ":",
   "param",
   "progress",
   ":",
   "progress",
   "callback",
   "that",
   "gets",
   "a",
   "progress",
   "fraction",
   "as",
   "argument",
   "and",
   "should",
   "return",
   "True",
   "to",
   "continue",
   "or",
   "a",
   "default",
   "progress",
   "bar",
   "when",
   "progress",
   "=",
   "True",
   ":",
   "param",
   ":",
   "bool",
   "virtual",
   ":",
   "When",
   "True",
   "export",
   "virtual",
   "columns",
   ":",
   "return",
   ":"
  ],
  "pl_tokens": [
   "def",
   "export_fits",
   "(",
   "dataset",
   ",",
   "path",
   ",",
   "column_names",
   "=",
   "None",
   ",",
   "shuffle",
   "=",
   "False",
   ",",
   "selection",
   "=",
   "False",
   ",",
   "progress",
   "=",
   "None",
   ",",
   "virtual",
   "=",
   "True",
   ",",
   "sort",
   "=",
   "None",
   ",",
   "ascending",
   "=",
   "True",
   ")",
   ":",
   "if",
   "shuffle",
   ":",
   "random_index_name",
   "=",
   "\"random_index\"",
   "while",
   "random_index_name",
   "in",
   "dataset",
   ".",
   "get_column_names",
   "(",
   ")",
   ":",
   "random_index_name",
   "+=",
   "\"_new\"",
   "column_names",
   "=",
   "column_names",
   "or",
   "dataset",
   ".",
   "get_column_names",
   "(",
   "virtual",
   "=",
   "virtual",
   ",",
   "strings",
   "=",
   "True",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"exporting columns(fits): %r\"",
   "%",
   "column_names",
   ")",
   "N",
   "=",
   "len",
   "(",
   "dataset",
   ")",
   "if",
   "not",
   "selection",
   "else",
   "dataset",
   ".",
   "selected_length",
   "(",
   "selection",
   ")",
   "data_types",
   "=",
   "[",
   "]",
   "data_shapes",
   "=",
   "[",
   "]",
   "ucds",
   "=",
   "[",
   "]",
   "units",
   "=",
   "[",
   "]",
   "for",
   "column_name",
   "in",
   "column_names",
   ":",
   "if",
   "column_name",
   "in",
   "dataset",
   ".",
   "get_column_names",
   "(",
   "strings",
   "=",
   "True",
   ")",
   ":",
   "column",
   "=",
   "dataset",
   ".",
   "columns",
   "[",
   "column_name",
   "]",
   "shape",
   "=",
   "(",
   "N",
   ",",
   ")",
   "+",
   "column",
   ".",
   "shape",
   "[",
   "1",
   ":",
   "]",
   "dtype",
   "=",
   "column",
   ".",
   "dtype",
   "if",
   "dataset",
   ".",
   "dtype",
   "(",
   "column_name",
   ")",
   "==",
   "str_type",
   ":",
   "max_length",
   "=",
   "dataset",
   "[",
   "column_name",
   "]",
   ".",
   "apply",
   "(",
   "lambda",
   "x",
   ":",
   "len",
   "(",
   "x",
   ")",
   ")",
   ".",
   "<mask>",
   "(",
   "selection",
   "=",
   "selection",
   ")",
   "dtype",
   "=",
   "np",
   ".",
   "dtype",
   "(",
   "'S'",
   "+",
   "str",
   "(",
   "int",
   "(",
   "max_length",
   ")",
   ")",
   ")",
   "else",
   ":",
   "dtype",
   "=",
   "np",
   ".",
   "float64",
   "(",
   ")",
   ".",
   "dtype",
   "shape",
   "=",
   "(",
   "N",
   ",",
   ")",
   "ucds",
   ".",
   "append",
   "(",
   "dataset",
   ".",
   "ucds",
   ".",
   "get",
   "(",
   "column_name",
   ")",
   ")",
   "units",
   ".",
   "append",
   "(",
   "dataset",
   ".",
   "units",
   ".",
   "get",
   "(",
   "column_name",
   ")",
   ")",
   "data_types",
   ".",
   "append",
   "(",
   "dtype",
   ")",
   "data_shapes",
   ".",
   "append",
   "(",
   "shape",
   ")",
   "if",
   "shuffle",
   ":",
   "column_names",
   ".",
   "append",
   "(",
   "random_index_name",
   ")",
   "data_types",
   ".",
   "append",
   "(",
   "np",
   ".",
   "int64",
   "(",
   ")",
   ".",
   "dtype",
   ")",
   "data_shapes",
   ".",
   "append",
   "(",
   "(",
   "N",
   ",",
   ")",
   ")",
   "ucds",
   ".",
   "append",
   "(",
   "None",
   ")",
   "units",
   ".",
   "append",
   "(",
   "None",
   ")",
   "else",
   ":",
   "random_index_name",
   "=",
   "None",
   "# TODO: all expressions can have missing values.. how to support that?",
   "null_values",
   "=",
   "{",
   "key",
   ":",
   "dataset",
   ".",
   "columns",
   "[",
   "key",
   "]",
   ".",
   "fill_value",
   "for",
   "key",
   "in",
   "dataset",
   ".",
   "get_column_names",
   "(",
   ")",
   "if",
   "dataset",
   ".",
   "is_masked",
   "(",
   "key",
   ")",
   "and",
   "dataset",
   ".",
   "dtype",
   "(",
   "key",
   ")",
   ".",
   "kind",
   "!=",
   "\"f\"",
   "}",
   "vaex",
   ".",
   "file",
   ".",
   "colfits",
   ".",
   "empty",
   "(",
   "path",
   ",",
   "N",
   ",",
   "column_names",
   ",",
   "data_types",
   ",",
   "data_shapes",
   ",",
   "ucds",
   ",",
   "units",
   ",",
   "null_values",
   "=",
   "null_values",
   ")",
   "if",
   "shuffle",
   ":",
   "del",
   "column_names",
   "[",
   "-",
   "1",
   "]",
   "del",
   "data_types",
   "[",
   "-",
   "1",
   "]",
   "del",
   "data_shapes",
   "[",
   "-",
   "1",
   "]",
   "dataset_output",
   "=",
   "vaex",
   ".",
   "file",
   ".",
   "other",
   ".",
   "FitsBinTable",
   "(",
   "path",
   ",",
   "write",
   "=",
   "True",
   ")",
   "_export",
   "(",
   "dataset_input",
   "=",
   "dataset",
   ",",
   "dataset_output",
   "=",
   "dataset_output",
   ",",
   "path",
   "=",
   "path",
   ",",
   "random_index_column",
   "=",
   "random_index_name",
   ",",
   "column_names",
   "=",
   "column_names",
   ",",
   "selection",
   "=",
   "selection",
   ",",
   "shuffle",
   "=",
   "shuffle",
   ",",
   "progress",
   "=",
   "progress",
   ",",
   "sort",
   "=",
   "sort",
   ",",
   "ascending",
   "=",
   "ascending",
   ")",
   "dataset_output",
   ".",
   "close_files",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1128",
  "nl_tokens": [
   "Perform",
   "connection",
   "state",
   "processing",
   "."
  ],
  "pl_tokens": [
   "def",
   "process",
   "(",
   "self",
   ",",
   "now",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_pn_connection",
   "is",
   "None",
   ":",
   "LOG",
   ".",
   "error",
   "(",
   "\"Connection.process() called on destroyed connection!\"",
   ")",
   "return",
   "0",
   "# do nothing until the connection has been opened",
   "if",
   "self",
   ".",
   "_pn_connection",
   ".",
   "state",
   "&",
   "proton",
   ".",
   "Endpoint",
   ".",
   "LOCAL_UNINIT",
   ":",
   "return",
   "0",
   "if",
   "self",
   ".",
   "_pn_sasl",
   "and",
   "not",
   "self",
   ".",
   "_sasl_done",
   ":",
   "# wait until SASL has authenticated",
   "if",
   "(",
   "_PROTON_VERSION",
   "<",
   "(",
   "0",
   ",",
   "10",
   ")",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_pn_sasl",
   ".",
   "state",
   "not",
   "in",
   "(",
   "proton",
   ".",
   "SASL",
   ".",
   "STATE_PASS",
   ",",
   "proton",
   ".",
   "SASL",
   ".",
   "STATE_FAIL",
   ")",
   ":",
   "LOG",
   ".",
   "debug",
   "(",
   "\"SASL in progress. State=%s\"",
   ",",
   "str",
   "(",
   "self",
   ".",
   "_pn_sasl",
   ".",
   "state",
   ")",
   ")",
   "if",
   "self",
   ".",
   "_handler",
   ":",
   "with",
   "self",
   ".",
   "_callback_lock",
   ":",
   "self",
   ".",
   "_handler",
   ".",
   "sasl_step",
   "(",
   "self",
   ",",
   "self",
   ".",
   "_pn_sasl",
   ")",
   "return",
   "self",
   ".",
   "_next_deadline",
   "self",
   ".",
   "_sasl_done",
   "=",
   "True",
   "if",
   "self",
   ".",
   "_handler",
   ":",
   "with",
   "self",
   ".",
   "_callback_lock",
   ":",
   "self",
   ".",
   "_handler",
   ".",
   "sasl_done",
   "(",
   "self",
   ",",
   "self",
   ".",
   "_pn_sasl",
   ",",
   "self",
   ".",
   "_pn_sasl",
   ".",
   "outcome",
   ")",
   "else",
   ":",
   "if",
   "self",
   ".",
   "_pn_sasl",
   ".",
   "outcome",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "_sasl_done",
   "=",
   "True",
   "if",
   "self",
   ".",
   "_handler",
   ":",
   "with",
   "self",
   ".",
   "_callback_lock",
   ":",
   "self",
   ".",
   "_handler",
   ".",
   "sasl_done",
   "(",
   "self",
   ",",
   "self",
   ".",
   "_pn_sasl",
   ",",
   "self",
   ".",
   "_pn_sasl",
   ".",
   "outcome",
   ")",
   "# process timer events:",
   "timer_deadline",
   "=",
   "self",
   ".",
   "_expire_timers",
   "(",
   "now",
   ")",
   "transport_deadline",
   "=",
   "self",
   ".",
   "_pn_transport",
   ".",
   "tick",
   "(",
   "now",
   ")",
   "if",
   "timer_deadline",
   "and",
   "transport_deadline",
   ":",
   "self",
   ".",
   "_next_deadline",
   "=",
   "<mask>",
   "(",
   "timer_deadline",
   ",",
   "transport_deadline",
   ")",
   "else",
   ":",
   "self",
   ".",
   "_next_deadline",
   "=",
   "timer_deadline",
   "or",
   "transport_deadline",
   "# process events from proton:",
   "pn_event",
   "=",
   "self",
   ".",
   "_pn_collector",
   ".",
   "peek",
   "(",
   ")",
   "while",
   "pn_event",
   ":",
   "# LOG.debug(\"pn_event: %s received\", pn_event.type)",
   "if",
   "_Link",
   ".",
   "_handle_proton_event",
   "(",
   "pn_event",
   ",",
   "self",
   ")",
   ":",
   "pass",
   "elif",
   "self",
   ".",
   "_handle_proton_event",
   "(",
   "pn_event",
   ")",
   ":",
   "pass",
   "elif",
   "_SessionProxy",
   ".",
   "_handle_proton_event",
   "(",
   "pn_event",
   ",",
   "self",
   ")",
   ":",
   "pass",
   "self",
   ".",
   "_pn_collector",
   ".",
   "pop",
   "(",
   ")",
   "pn_event",
   "=",
   "self",
   ".",
   "_pn_collector",
   ".",
   "peek",
   "(",
   ")",
   "# check for connection failure after processing all pending",
   "# engine events:",
   "if",
   "self",
   ".",
   "_error",
   ":",
   "if",
   "self",
   ".",
   "_handler",
   ":",
   "# nag application until connection is destroyed",
   "self",
   ".",
   "_next_deadline",
   "=",
   "now",
   "with",
   "self",
   ".",
   "_callback_lock",
   ":",
   "self",
   ".",
   "_handler",
   ".",
   "connection_failed",
   "(",
   "self",
   ",",
   "self",
   ".",
   "_error",
   ")",
   "elif",
   "(",
   "self",
   ".",
   "_endpoint_state",
   "==",
   "self",
   ".",
   "_CLOSED",
   "and",
   "self",
   ".",
   "_read_done",
   "and",
   "self",
   ".",
   "_write_done",
   ")",
   ":",
   "# invoke closed callback after endpoint has fully closed and",
   "# all pending I/O has completed:",
   "if",
   "self",
   ".",
   "_handler",
   ":",
   "with",
   "self",
   ".",
   "_callback_lock",
   ":",
   "self",
   ".",
   "_handler",
   ".",
   "connection_closed",
   "(",
   "self",
   ")",
   "return",
   "self",
   ".",
   "_next_deadline"
  ]
 },
 {
  "idx": "maxmin-1129",
  "nl_tokens": [
   "Initialization",
   "done",
   "before",
   "entering",
   "the",
   "debugger",
   "-",
   "command",
   "loop",
   ".",
   "In",
   "particular",
   "we",
   "set",
   "up",
   "the",
   "call",
   "stack",
   "used",
   "for",
   "local",
   "variable",
   "lookup",
   "and",
   "frame",
   "/",
   "up",
   "/",
   "down",
   "commands",
   "."
  ],
  "pl_tokens": [
   "def",
   "setup",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "forget",
   "(",
   ")",
   "if",
   "self",
   ".",
   "settings",
   "(",
   "'dbg_trepan'",
   ")",
   ":",
   "self",
   ".",
   "frame",
   "=",
   "inspect",
   ".",
   "currentframe",
   "(",
   ")",
   "pass",
   "if",
   "self",
   ".",
   "event",
   "in",
   "[",
   "'exception'",
   ",",
   "'c_exception'",
   "]",
   ":",
   "exc_type",
   ",",
   "exc_value",
   ",",
   "exc_traceback",
   "=",
   "self",
   ".",
   "event_arg",
   "else",
   ":",
   "_",
   ",",
   "_",
   ",",
   "exc_traceback",
   "=",
   "(",
   "None",
   ",",
   "None",
   ",",
   "None",
   ",",
   ")",
   "# NOQA",
   "pass",
   "if",
   "self",
   ".",
   "frame",
   "or",
   "exc_traceback",
   ":",
   "self",
   ".",
   "stack",
   ",",
   "self",
   ".",
   "curindex",
   "=",
   "get_stack",
   "(",
   "self",
   ".",
   "frame",
   ",",
   "exc_traceback",
   ",",
   "None",
   ",",
   "self",
   ")",
   "self",
   ".",
   "curframe",
   "=",
   "self",
   ".",
   "stack",
   "[",
   "self",
   ".",
   "curindex",
   "]",
   "[",
   "0",
   "]",
   "self",
   ".",
   "thread_name",
   "=",
   "Mthread",
   ".",
   "current_thread_name",
   "(",
   ")",
   "else",
   ":",
   "self",
   ".",
   "stack",
   "=",
   "self",
   ".",
   "curframe",
   "=",
   "self",
   ".",
   "botframe",
   "=",
   "None",
   "pass",
   "if",
   "self",
   ".",
   "curframe",
   ":",
   "self",
   ".",
   "list_lineno",
   "=",
   "<mask>",
   "(",
   "1",
   ",",
   "inspect",
   ".",
   "getlineno",
   "(",
   "self",
   ".",
   "curframe",
   ")",
   ")",
   "else",
   ":",
   "self",
   ".",
   "list_lineno",
   "=",
   "None",
   "pass",
   "# if self.execRcLines()==1: return True",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-1130",
  "nl_tokens": [
   "Merges",
   "parameters",
   "from",
   "the",
   "other",
   "trajectory",
   "into",
   "the",
   "current",
   "one",
   "."
  ],
  "pl_tokens": [
   "def",
   "_merge_parameters",
   "(",
   "self",
   ",",
   "other_trajectory",
   ",",
   "remove_duplicates",
   "=",
   "False",
   ",",
   "trial_parameter_name",
   "=",
   "None",
   ",",
   "ignore_data",
   "=",
   "(",
   ")",
   ")",
   ":",
   "if",
   "trial_parameter_name",
   ":",
   "if",
   "remove_duplicates",
   ":",
   "self",
   ".",
   "_logger",
   ".",
   "warning",
   "(",
   "'You have given a trial parameter and you want to '",
   "'remove_items duplicates. There cannot be any duplicates '",
   "'when adding trials, I will not look for duplicates.'",
   ")",
   "remove_duplicates",
   "=",
   "False",
   "# Dictionary containing full parameter names as keys",
   "# and pairs of parameters from both trajectories as values.",
   "# Parameters kept in this dictionary are marked for merging and will be enlarged",
   "# with ranges and values of corresponding parameters in the other trajectory",
   "params_to_change",
   "=",
   "{",
   "}",
   "if",
   "trial_parameter_name",
   ":",
   "# We want to merge a trial parameter",
   "# First make some sanity checks",
   "my_trial_parameter",
   "=",
   "self",
   ".",
   "f_get",
   "(",
   "trial_parameter_name",
   ")",
   "other_trial_parameter",
   "=",
   "other_trajectory",
   ".",
   "f_get",
   "(",
   "trial_parameter_name",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "my_trial_parameter",
   ",",
   "BaseParameter",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "'Your trial_parameter `%s` does not evaluate to a real parameter'",
   "' in the trajectory'",
   "%",
   "trial_parameter_name",
   ")",
   "# Extract the ranges of both trial parameters",
   "if",
   "my_trial_parameter",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "my_trial_list",
   "=",
   "my_trial_parameter",
   ".",
   "f_get_range",
   "(",
   "copy",
   "=",
   "False",
   ")",
   "else",
   ":",
   "# If we only have a single trial, we need to make a range of length 1",
   "# This is probably a very exceptional case",
   "my_trial_list",
   "=",
   "[",
   "my_trial_parameter",
   ".",
   "f_get",
   "(",
   ")",
   "]",
   "if",
   "other_trial_parameter",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "other_trial_list",
   "=",
   "other_trial_parameter",
   ".",
   "f_get_range",
   "(",
   "copy",
   "=",
   "False",
   ")",
   "else",
   ":",
   "other_trial_list",
   "=",
   "[",
   "other_trial_parameter",
   ".",
   "f_get",
   "(",
   ")",
   "]",
   "# Make sanity checks if both ranges contain all numbers from 0 to T1",
   "# for the current trajectory and 0 to T2 for the other trajectory",
   "mytrialset",
   "=",
   "set",
   "(",
   "my_trial_list",
   ")",
   "mymaxtrial_T1",
   "=",
   "<mask>",
   "(",
   "mytrialset",
   ")",
   "# maximum trial index in current trajectory aka T1",
   "if",
   "mytrialset",
   "!=",
   "set",
   "(",
   "range",
   "(",
   "mymaxtrial_T1",
   "+",
   "1",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "'In order to specify a trial parameter, this parameter must '",
   "'contain integers from 0 to %d, but it in fact it '",
   "'contains `%s`.'",
   "%",
   "(",
   "mymaxtrial_T1",
   ",",
   "str",
   "(",
   "mytrialset",
   ")",
   ")",
   ")",
   "othertrialset",
   "=",
   "set",
   "(",
   "other_trial_list",
   ")",
   "othermaxtrial_T2",
   "=",
   "max",
   "(",
   "othertrialset",
   ")",
   "# maximum trial index in other trajectory aka T2",
   "if",
   "othertrialset",
   "!=",
   "set",
   "(",
   "range",
   "(",
   "othermaxtrial_T2",
   "+",
   "1",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "'In order to specify a trial parameter, this parameter must '",
   "'contain integers from 0 to %d, but it infact it contains `%s` '",
   "'in the other trajectory.'",
   "%",
   "(",
   "othermaxtrial_T2",
   ",",
   "str",
   "(",
   "othertrialset",
   ")",
   ")",
   ")",
   "# If the trial parameter's name was just given in parts we update it here",
   "# to the full name",
   "trial_parameter_name",
   "=",
   "my_trial_parameter",
   ".",
   "v_full_name",
   "# If we had the very exceptional case, that our trial parameter was not explored,",
   "# aka we only had 1 trial, we have to add it to the explored parameters",
   "if",
   "not",
   "trial_parameter_name",
   "in",
   "self",
   ".",
   "_explored_parameters",
   ":",
   "self",
   ".",
   "_explored_parameters",
   "[",
   "trial_parameter_name",
   "]",
   "=",
   "my_trial_parameter",
   "# We need to mark the trial parameter for merging",
   "params_to_change",
   "[",
   "trial_parameter_name",
   "]",
   "=",
   "(",
   "my_trial_parameter",
   ",",
   "other_trial_parameter",
   ")",
   "# Dictionary containing all parameters of the other trajectory, we will iterate through it",
   "# to spot parameters that need to be enlarge or become new explored parameters",
   "params_to_merge",
   "=",
   "other_trajectory",
   ".",
   "_parameters",
   ".",
   "copy",
   "(",
   ")",
   "params_to_merge",
   ".",
   "update",
   "(",
   "other_trajectory",
   ".",
   "_derived_parameters",
   ")",
   "for",
   "ignore",
   "in",
   "ignore_data",
   ":",
   "if",
   "ignore",
   "in",
   "params_to_merge",
   ":",
   "del",
   "params_to_merge",
   "[",
   "ignore",
   "]",
   "run_name_dummys",
   "=",
   "set",
   "(",
   "[",
   "f",
   "(",
   "-",
   "1",
   ")",
   "for",
   "f",
   "in",
   "other_trajectory",
   ".",
   "_wildcard_functions",
   ".",
   "values",
   "(",
   ")",
   "]",
   ")",
   "# Iterate through all parameters of the other trajectory",
   "# and check which differ from the parameters of the current trajectory",
   "for",
   "key",
   "in",
   "params_to_merge",
   ":",
   "other_param",
   "=",
   "params_to_merge",
   "[",
   "key",
   "]",
   "# We don't need to merge anything based on wildcards",
   "split_key",
   "=",
   "key",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   "if",
   "any",
   "(",
   "x",
   "in",
   "other_trajectory",
   ".",
   "_reversed_wildcards",
   "for",
   "x",
   "in",
   "split_key",
   ")",
   ":",
   "continue",
   "my_param",
   "=",
   "self",
   ".",
   "f_get",
   "(",
   "key",
   ")",
   "if",
   "not",
   "my_param",
   ".",
   "_values_of_same_type",
   "(",
   "my_param",
   ".",
   "f_get",
   "(",
   ")",
   ",",
   "other_param",
   ".",
   "f_get",
   "(",
   ")",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "'The parameters with name `%s` are not of the same type, cannot '",
   "'merge trajectory.'",
   "%",
   "key",
   ")",
   "# We have taken care about the trial parameter before, it is already",
   "# marked for merging",
   "if",
   "my_param",
   ".",
   "v_full_name",
   "==",
   "trial_parameter_name",
   ":",
   "continue",
   "# If a parameter was explored in one of the trajectories or two unexplored",
   "# parameters differ, we need to mark them for merge",
   "if",
   "(",
   "my_param",
   ".",
   "f_has_range",
   "(",
   ")",
   "or",
   "other_param",
   ".",
   "f_has_range",
   "(",
   ")",
   "or",
   "not",
   "my_param",
   ".",
   "_equal_values",
   "(",
   "my_param",
   ".",
   "f_get",
   "(",
   ")",
   ",",
   "other_param",
   ".",
   "f_get",
   "(",
   ")",
   ")",
   ")",
   ":",
   "# If two unexplored parameters differ, that means they differ in every run,",
   "# accordingly we do not need to check for duplicate runs anymore",
   "params_to_change",
   "[",
   "key",
   "]",
   "=",
   "(",
   "my_param",
   ",",
   "other_param",
   ")",
   "if",
   "not",
   "my_param",
   ".",
   "f_has_range",
   "(",
   ")",
   "and",
   "not",
   "other_param",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "remove_duplicates",
   "=",
   "False",
   "# Check if we use all runs or remove duplicates:",
   "used_runs",
   "=",
   "{",
   "}",
   "for",
   "idx",
   "in",
   "range",
   "(",
   "len",
   "(",
   "other_trajectory",
   ")",
   ")",
   ":",
   "used_runs",
   "[",
   "idx",
   "]",
   "=",
   "idx",
   "if",
   "remove_duplicates",
   ":",
   "# We need to compare all parameter combinations in the current trajectory",
   "# to all parameter combinations in the other trajectory to spot duplicate points.",
   "# Quadratic Complexity!",
   "for",
   "irun",
   "in",
   "range",
   "(",
   "len",
   "(",
   "other_trajectory",
   ")",
   ")",
   ":",
   "for",
   "jrun",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ")",
   ")",
   ":",
   "change",
   "=",
   "True",
   "# Check all marked parameters",
   "for",
   "my_param",
   ",",
   "other_param",
   "in",
   "params_to_change",
   ".",
   "values",
   "(",
   ")",
   ":",
   "if",
   "other_param",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "other_param",
   ".",
   "_set_parameter_access",
   "(",
   "irun",
   ")",
   "if",
   "my_param",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "my_param",
   ".",
   "_set_parameter_access",
   "(",
   "jrun",
   ")",
   "val1",
   "=",
   "my_param",
   ".",
   "f_get",
   "(",
   ")",
   "val2",
   "=",
   "other_param",
   ".",
   "f_get",
   "(",
   ")",
   "# If only one parameter differs, the parameter space point differs",
   "# and we can skip the rest of the parameters",
   "if",
   "not",
   "my_param",
   ".",
   "_equal_values",
   "(",
   "val1",
   ",",
   "val2",
   ")",
   ":",
   "change",
   "=",
   "False",
   "break",
   "# If we found one parameter space point in the current trajectory",
   "# that matches the ith point in the other, we do not need the ith",
   "# point. We can also skip comparing to the rest of the points in the",
   "# current trajectory",
   "if",
   "change",
   ":",
   "del",
   "used_runs",
   "[",
   "irun",
   "]",
   "break",
   "# Restore changed default values",
   "for",
   "my_param",
   ",",
   "other_param",
   "in",
   "params_to_change",
   ".",
   "values",
   "(",
   ")",
   ":",
   "other_param",
   ".",
   "_restore_default",
   "(",
   ")",
   "my_param",
   ".",
   "_restore_default",
   "(",
   ")",
   "# Merge parameters into the current trajectory",
   "adding_length",
   "=",
   "len",
   "(",
   "used_runs",
   ")",
   "starting_length",
   "=",
   "len",
   "(",
   "self",
   ")",
   "if",
   "adding_length",
   "==",
   "0",
   ":",
   "return",
   "used_runs",
   ",",
   "[",
   "]",
   "count",
   "=",
   "0",
   "for",
   "key",
   "in",
   "sorted",
   "(",
   "used_runs",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ":",
   "used_runs",
   "[",
   "key",
   "]",
   "=",
   "starting_length",
   "+",
   "count",
   "count",
   "+=",
   "1",
   "for",
   "my_param",
   ",",
   "other_param",
   "in",
   "params_to_change",
   ".",
   "values",
   "(",
   ")",
   ":",
   "fullname",
   "=",
   "my_param",
   ".",
   "v_full_name",
   "# We need new ranges to enlarge all parameters marked for merging",
   "if",
   "fullname",
   "==",
   "trial_parameter_name",
   ":",
   "# The trial parameter now has to cover the range 0 to T1+T2+1",
   "other_range",
   "=",
   "[",
   "x",
   "+",
   "mymaxtrial_T1",
   "+",
   "1",
   "for",
   "x",
   "in",
   "other_trial_list",
   "]",
   "else",
   ":",
   "# In case we do not use all runs we need to filter the ranges of the",
   "# parameters of the other trajectory",
   "if",
   "other_param",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "other_range",
   "=",
   "(",
   "x",
   "for",
   "jdx",
   ",",
   "x",
   "in",
   "enumerate",
   "(",
   "other_param",
   ".",
   "f_get_range",
   "(",
   "copy",
   "=",
   "False",
   ")",
   ")",
   "if",
   "jdx",
   "in",
   "used_runs",
   ")",
   "else",
   ":",
   "other_range",
   "=",
   "(",
   "other_param",
   ".",
   "f_get",
   "(",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "adding_length",
   ")",
   ")",
   "# If a parameter in the current trajectory was marked for merging but was not",
   "# explored before, we need to explore it first, simply by creating the range of",
   "# the current trajectory's length containing only it's default value",
   "if",
   "not",
   "my_param",
   ".",
   "f_has_range",
   "(",
   ")",
   ":",
   "my_param",
   ".",
   "f_unlock",
   "(",
   ")",
   "my_param",
   ".",
   "_explore",
   "(",
   "(",
   "my_param",
   ".",
   "f_get",
   "(",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ")",
   ")",
   ")",
   ")",
   "# After determining the new range extension `other_range`,",
   "# expand the parameters",
   "my_param",
   ".",
   "f_unlock",
   "(",
   ")",
   "my_param",
   ".",
   "_expand",
   "(",
   "other_range",
   ")",
   "if",
   "not",
   "fullname",
   "in",
   "self",
   ".",
   "_explored_parameters",
   ":",
   "self",
   ".",
   "_explored_parameters",
   "[",
   "fullname",
   "]",
   "=",
   "my_param",
   "return",
   "used_runs",
   ",",
   "list",
   "(",
   "params_to_change",
   ".",
   "keys",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1131",
  "nl_tokens": [
   "Set",
   "auxilliary",
   "parameters",
   "to",
   "every",
   "node",
   "of",
   "the",
   "tree",
   "."
  ],
  "pl_tokens": [
   "def",
   "_prepare_nodes",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "up",
   "=",
   "None",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "bad_branch",
   "=",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ".",
   "bad_branch",
   "if",
   "hasattr",
   "(",
   "self",
   ".",
   "tree",
   ".",
   "root",
   ",",
   "'bad_branch'",
   ")",
   "else",
   "False",
   "internal_node_count",
   "=",
   "0",
   "for",
   "clade",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "get_nonterminals",
   "(",
   "order",
   "=",
   "'preorder'",
   ")",
   ":",
   "# parents first",
   "internal_node_count",
   "+=",
   "1",
   "if",
   "clade",
   ".",
   "name",
   "is",
   "None",
   ":",
   "clade",
   ".",
   "name",
   "=",
   "\"NODE_\"",
   "+",
   "format",
   "(",
   "self",
   ".",
   "_internal_node_count",
   ",",
   "'07d'",
   ")",
   "self",
   ".",
   "_internal_node_count",
   "+=",
   "1",
   "for",
   "c",
   "in",
   "clade",
   ".",
   "clades",
   ":",
   "if",
   "c",
   ".",
   "is_terminal",
   "(",
   ")",
   ":",
   "c",
   ".",
   "bad_branch",
   "=",
   "c",
   ".",
   "bad_branch",
   "if",
   "hasattr",
   "(",
   "c",
   ",",
   "'bad_branch'",
   ")",
   "else",
   "False",
   "c",
   ".",
   "up",
   "=",
   "clade",
   "for",
   "clade",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "get_nonterminals",
   "(",
   "order",
   "=",
   "'postorder'",
   ")",
   ":",
   "# parents first",
   "clade",
   ".",
   "bad_branch",
   "=",
   "all",
   "(",
   "[",
   "c",
   ".",
   "bad_branch",
   "for",
   "c",
   "in",
   "clade",
   "]",
   ")",
   "self",
   ".",
   "_calc_dist2root",
   "(",
   ")",
   "self",
   ".",
   "_internal_node_count",
   "=",
   "<mask>",
   "(",
   "internal_node_count",
   ",",
   "self",
   ".",
   "_internal_node_count",
   ")"
  ]
 },
 {
  "idx": "maxmin-1132",
  "nl_tokens": [
   "Computes",
   "the",
   "accuracy",
   "over",
   "the",
   "k",
   "top",
   "predictions",
   "for",
   "the",
   "specified",
   "values",
   "of",
   "k"
  ],
  "pl_tokens": [
   "def",
   "accuracy",
   "(",
   "output",
   ",",
   "target",
   ",",
   "topk",
   "=",
   "(",
   "1",
   ",",
   ")",
   ")",
   ":",
   "with",
   "torch",
   ".",
   "no_grad",
   "(",
   ")",
   ":",
   "maxk",
   "=",
   "<mask>",
   "(",
   "topk",
   ")",
   "batch_size",
   "=",
   "target",
   ".",
   "size",
   "(",
   "0",
   ")",
   "_",
   ",",
   "pred",
   "=",
   "output",
   ".",
   "topk",
   "(",
   "maxk",
   ",",
   "1",
   ",",
   "True",
   ",",
   "True",
   ")",
   "pred",
   "=",
   "pred",
   ".",
   "t",
   "(",
   ")",
   "correct",
   "=",
   "pred",
   ".",
   "eq",
   "(",
   "target",
   "[",
   "None",
   "]",
   ")",
   "res",
   "=",
   "[",
   "]",
   "for",
   "k",
   "in",
   "topk",
   ":",
   "correct_k",
   "=",
   "correct",
   "[",
   ":",
   "k",
   "]",
   ".",
   "flatten",
   "(",
   ")",
   ".",
   "sum",
   "(",
   "dtype",
   "=",
   "torch",
   ".",
   "float32",
   ")",
   "res",
   ".",
   "append",
   "(",
   "correct_k",
   "*",
   "(",
   "100.0",
   "/",
   "batch_size",
   ")",
   ")",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-1133",
  "nl_tokens": [
   "Partially",
   "match",
   "a",
   "path",
   "and",
   "a",
   "filter_path",
   "with",
   "wildcards",
   ".",
   "This",
   "function",
   "will",
   "return",
   "True",
   "if",
   "this",
   "path",
   "partially",
   "match",
   "a",
   "filter",
   "path",
   ".",
   "This",
   "is",
   "used",
   "for",
   "walking",
   "through",
   "directories",
   "with",
   "multiple",
   "level",
   "wildcard",
   "."
  ],
  "pl_tokens": [
   "def",
   "partial_match",
   "(",
   "self",
   ",",
   "path",
   ",",
   "filter_path",
   ")",
   ":",
   "if",
   "not",
   "path",
   "or",
   "not",
   "filter_path",
   ":",
   "return",
   "True",
   "# trailing slash normalization",
   "if",
   "path",
   "[",
   "-",
   "1",
   "]",
   "==",
   "PATH_SEP",
   ":",
   "path",
   "=",
   "path",
   "[",
   "0",
   ":",
   "-",
   "1",
   "]",
   "if",
   "filter_path",
   "[",
   "-",
   "1",
   "]",
   "==",
   "PATH_SEP",
   ":",
   "filter_path",
   "+=",
   "'*'",
   "pi",
   "=",
   "path",
   ".",
   "split",
   "(",
   "PATH_SEP",
   ")",
   "fi",
   "=",
   "filter_path",
   ".",
   "split",
   "(",
   "PATH_SEP",
   ")",
   "# Here, if we are in recursive mode, we allow the pi to be longer than fi.",
   "# Otherwise, length of pi should be equal or less than the lenght of fi.",
   "min_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "pi",
   ")",
   ",",
   "len",
   "(",
   "fi",
   ")",
   ")",
   "matched",
   "=",
   "fnmatch",
   ".",
   "fnmatch",
   "(",
   "PATH_SEP",
   ".",
   "join",
   "(",
   "pi",
   "[",
   "0",
   ":",
   "min_len",
   "]",
   ")",
   ",",
   "PATH_SEP",
   ".",
   "join",
   "(",
   "fi",
   "[",
   "0",
   ":",
   "min_len",
   "]",
   ")",
   ")",
   "return",
   "matched",
   "and",
   "(",
   "self",
   ".",
   "opt",
   ".",
   "recursive",
   "or",
   "len",
   "(",
   "pi",
   ")",
   "<=",
   "len",
   "(",
   "fi",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1134",
  "nl_tokens": [
   "Takes",
   "a",
   "list",
   "of",
   "reference",
   "sentences",
   "for",
   "a",
   "single",
   "segment",
   "and",
   "returns",
   "an",
   "object",
   "that",
   "encapsulates",
   "everything",
   "that",
   "BLEU",
   "needs",
   "to",
   "know",
   "about",
   "them",
   "."
  ],
  "pl_tokens": [
   "def",
   "cook_refs",
   "(",
   "refs",
   ",",
   "n",
   "=",
   "4",
   ")",
   ":",
   "refs",
   "=",
   "[",
   "normalize",
   "(",
   "ref",
   ")",
   "for",
   "ref",
   "in",
   "refs",
   "]",
   "maxcounts",
   "=",
   "{",
   "}",
   "for",
   "ref",
   "in",
   "refs",
   ":",
   "counts",
   "=",
   "count_ngrams",
   "(",
   "ref",
   ",",
   "n",
   ")",
   "for",
   "(",
   "ngram",
   ",",
   "count",
   ")",
   "in",
   "list",
   "(",
   "counts",
   ".",
   "items",
   "(",
   ")",
   ")",
   ":",
   "maxcounts",
   "[",
   "ngram",
   "]",
   "=",
   "<mask>",
   "(",
   "maxcounts",
   ".",
   "get",
   "(",
   "ngram",
   ",",
   "0",
   ")",
   ",",
   "count",
   ")",
   "return",
   "(",
   "[",
   "len",
   "(",
   "ref",
   ")",
   "for",
   "ref",
   "in",
   "refs",
   "]",
   ",",
   "maxcounts",
   ")"
  ]
 },
 {
  "idx": "maxmin-1135",
  "nl_tokens": [
   "Similar",
   "to",
   ":",
   "py",
   ":",
   "attr",
   ":",
   "pos",
   "but",
   "for",
   "the",
   "size",
   "instead",
   "."
  ],
  "pl_tokens": [
   "def",
   "size",
   "(",
   "self",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "self",
   ".",
   "_size",
   ",",
   "list",
   ")",
   "or",
   "isinstance",
   "(",
   "self",
   ".",
   "_size",
   ",",
   "tuple",
   ")",
   ":",
   "s",
   "=",
   "self",
   ".",
   "_size",
   "elif",
   "callable",
   "(",
   "self",
   ".",
   "_size",
   ")",
   ":",
   "w",
   ",",
   "h",
   "=",
   "self",
   ".",
   "submenu",
   ".",
   "size",
   "[",
   ":",
   "]",
   "s",
   "=",
   "self",
   ".",
   "_size",
   "(",
   "w",
   ",",
   "h",
   ")",
   "else",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"Invalid size type\"",
   ")",
   "s",
   "=",
   "s",
   "[",
   ":",
   "]",
   "if",
   "s",
   "[",
   "0",
   "]",
   "==",
   "-",
   "1",
   ":",
   "s",
   "[",
   "0",
   "]",
   "=",
   "self",
   ".",
   "getMinSize",
   "(",
   ")",
   "[",
   "0",
   "]",
   "if",
   "s",
   "[",
   "1",
   "]",
   "==",
   "-",
   "1",
   ":",
   "s",
   "[",
   "1",
   "]",
   "=",
   "self",
   ".",
   "getMinSize",
   "(",
   ")",
   "[",
   "1",
   "]",
   "# Prevents crashes with negative size",
   "s",
   "=",
   "[",
   "<mask>",
   "(",
   "s",
   "[",
   "0",
   "]",
   ",",
   "0",
   ")",
   ",",
   "max",
   "(",
   "s",
   "[",
   "1",
   "]",
   ",",
   "0",
   ")",
   "]",
   "return",
   "_WatchingList",
   "(",
   "s",
   ",",
   "self",
   ".",
   "_wlredraw_size",
   ")"
  ]
 },
 {
  "idx": "maxmin-1136",
  "nl_tokens": [
   "recursive",
   "function",
   "doing",
   "the",
   "real",
   "work",
   "for",
   "get_cycles"
  ],
  "pl_tokens": [
   "def",
   "_get_cycles",
   "(",
   "graph_dict",
   ",",
   "path",
   ",",
   "visited",
   ",",
   "result",
   ",",
   "vertice",
   ")",
   ":",
   "if",
   "vertice",
   "in",
   "path",
   ":",
   "cycle",
   "=",
   "[",
   "vertice",
   "]",
   "for",
   "node",
   "in",
   "path",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ":",
   "if",
   "node",
   "==",
   "vertice",
   ":",
   "break",
   "cycle",
   ".",
   "insert",
   "(",
   "0",
   ",",
   "node",
   ")",
   "# make a canonical representation",
   "start_from",
   "=",
   "<mask>",
   "(",
   "cycle",
   ")",
   "index",
   "=",
   "cycle",
   ".",
   "index",
   "(",
   "start_from",
   ")",
   "cycle",
   "=",
   "cycle",
   "[",
   "index",
   ":",
   "]",
   "+",
   "cycle",
   "[",
   "0",
   ":",
   "index",
   "]",
   "# append it to result if not already in",
   "if",
   "cycle",
   "not",
   "in",
   "result",
   ":",
   "result",
   ".",
   "append",
   "(",
   "cycle",
   ")",
   "return",
   "path",
   ".",
   "append",
   "(",
   "vertice",
   ")",
   "try",
   ":",
   "for",
   "node",
   "in",
   "graph_dict",
   "[",
   "vertice",
   "]",
   ":",
   "# don't check already visited nodes again",
   "if",
   "node",
   "not",
   "in",
   "visited",
   ":",
   "_get_cycles",
   "(",
   "graph_dict",
   ",",
   "path",
   ",",
   "visited",
   ",",
   "result",
   ",",
   "node",
   ")",
   "visited",
   ".",
   "add",
   "(",
   "node",
   ")",
   "except",
   "KeyError",
   ":",
   "pass",
   "path",
   ".",
   "pop",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1137",
  "nl_tokens": [
   "Plot",
   "the",
   "qsphere",
   "representation",
   "of",
   "a",
   "quantum",
   "state",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_state_qsphere",
   "(",
   "rho",
   ",",
   "figsize",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "HAS_MATPLOTLIB",
   ":",
   "raise",
   "ImportError",
   "(",
   "'Must have Matplotlib installed.'",
   ")",
   "rho",
   "=",
   "_validate_input_state",
   "(",
   "rho",
   ")",
   "if",
   "figsize",
   "is",
   "None",
   ":",
   "figsize",
   "=",
   "(",
   "7",
   ",",
   "7",
   ")",
   "num",
   "=",
   "int",
   "(",
   "np",
   ".",
   "log2",
   "(",
   "len",
   "(",
   "rho",
   ")",
   ")",
   ")",
   "# get the eigenvectors and eigenvalues",
   "we",
   ",",
   "stateall",
   "=",
   "linalg",
   ".",
   "eigh",
   "(",
   "rho",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   ":",
   "# start with the max",
   "probmix",
   "=",
   "we",
   ".",
   "<mask>",
   "(",
   ")",
   "prob_location",
   "=",
   "we",
   ".",
   "argmax",
   "(",
   ")",
   "if",
   "probmix",
   ">",
   "0.001",
   ":",
   "# get the max eigenvalue",
   "state",
   "=",
   "stateall",
   "[",
   ":",
   ",",
   "prob_location",
   "]",
   "loc",
   "=",
   "np",
   ".",
   "absolute",
   "(",
   "state",
   ")",
   ".",
   "argmax",
   "(",
   ")",
   "# get the element location closes to lowest bin representation.",
   "for",
   "j",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   ":",
   "test",
   "=",
   "np",
   ".",
   "absolute",
   "(",
   "np",
   ".",
   "absolute",
   "(",
   "state",
   "[",
   "j",
   "]",
   ")",
   "-",
   "np",
   ".",
   "absolute",
   "(",
   "state",
   "[",
   "loc",
   "]",
   ")",
   ")",
   "if",
   "test",
   "<",
   "0.001",
   ":",
   "loc",
   "=",
   "j",
   "break",
   "# remove the global phase",
   "angles",
   "=",
   "(",
   "np",
   ".",
   "angle",
   "(",
   "state",
   "[",
   "loc",
   "]",
   ")",
   "+",
   "2",
   "*",
   "np",
   ".",
   "pi",
   ")",
   "%",
   "(",
   "2",
   "*",
   "np",
   ".",
   "pi",
   ")",
   "angleset",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "-",
   "1j",
   "*",
   "angles",
   ")",
   "# print(state)",
   "# print(angles)",
   "state",
   "=",
   "angleset",
   "*",
   "state",
   "# print(state)",
   "state",
   ".",
   "flatten",
   "(",
   ")",
   "# start the plotting",
   "fig",
   "=",
   "plt",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "figsize",
   ")",
   "ax",
   "=",
   "fig",
   ".",
   "add_subplot",
   "(",
   "111",
   ",",
   "projection",
   "=",
   "'3d'",
   ")",
   "ax",
   ".",
   "axes",
   ".",
   "set_xlim3d",
   "(",
   "-",
   "1.0",
   ",",
   "1.0",
   ")",
   "ax",
   ".",
   "axes",
   ".",
   "set_ylim3d",
   "(",
   "-",
   "1.0",
   ",",
   "1.0",
   ")",
   "ax",
   ".",
   "axes",
   ".",
   "set_zlim3d",
   "(",
   "-",
   "1.0",
   ",",
   "1.0",
   ")",
   "ax",
   ".",
   "set_aspect",
   "(",
   "\"equal\"",
   ")",
   "ax",
   ".",
   "axes",
   ".",
   "grid",
   "(",
   "False",
   ")",
   "# Plot semi-transparent sphere",
   "u",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "2",
   "*",
   "np",
   ".",
   "pi",
   ",",
   "25",
   ")",
   "v",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "np",
   ".",
   "pi",
   ",",
   "25",
   ")",
   "x",
   "=",
   "np",
   ".",
   "outer",
   "(",
   "np",
   ".",
   "cos",
   "(",
   "u",
   ")",
   ",",
   "np",
   ".",
   "sin",
   "(",
   "v",
   ")",
   ")",
   "y",
   "=",
   "np",
   ".",
   "outer",
   "(",
   "np",
   ".",
   "sin",
   "(",
   "u",
   ")",
   ",",
   "np",
   ".",
   "sin",
   "(",
   "v",
   ")",
   ")",
   "z",
   "=",
   "np",
   ".",
   "outer",
   "(",
   "np",
   ".",
   "ones",
   "(",
   "np",
   ".",
   "size",
   "(",
   "u",
   ")",
   ")",
   ",",
   "np",
   ".",
   "cos",
   "(",
   "v",
   ")",
   ")",
   "ax",
   ".",
   "plot_surface",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ",",
   "rstride",
   "=",
   "1",
   ",",
   "cstride",
   "=",
   "1",
   ",",
   "color",
   "=",
   "'k'",
   ",",
   "alpha",
   "=",
   "0.05",
   ",",
   "linewidth",
   "=",
   "0",
   ")",
   "# wireframe",
   "# Get rid of the panes",
   "ax",
   ".",
   "w_xaxis",
   ".",
   "set_pane_color",
   "(",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ",",
   "0.0",
   ")",
   ")",
   "ax",
   ".",
   "w_yaxis",
   ".",
   "set_pane_color",
   "(",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ",",
   "0.0",
   ")",
   ")",
   "ax",
   ".",
   "w_zaxis",
   ".",
   "set_pane_color",
   "(",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ",",
   "0.0",
   ")",
   ")",
   "# Get rid of the spines",
   "ax",
   ".",
   "w_xaxis",
   ".",
   "line",
   ".",
   "set_color",
   "(",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ",",
   "0.0",
   ")",
   ")",
   "ax",
   ".",
   "w_yaxis",
   ".",
   "line",
   ".",
   "set_color",
   "(",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ",",
   "0.0",
   ")",
   ")",
   "ax",
   ".",
   "w_zaxis",
   ".",
   "line",
   ".",
   "set_color",
   "(",
   "(",
   "1.0",
   ",",
   "1.0",
   ",",
   "1.0",
   ",",
   "0.0",
   ")",
   ")",
   "# Get rid of the ticks",
   "ax",
   ".",
   "set_xticks",
   "(",
   "[",
   "]",
   ")",
   "ax",
   ".",
   "set_yticks",
   "(",
   "[",
   "]",
   ")",
   "ax",
   ".",
   "set_zticks",
   "(",
   "[",
   "]",
   ")",
   "d",
   "=",
   "num",
   "for",
   "i",
   "in",
   "range",
   "(",
   "2",
   "**",
   "num",
   ")",
   ":",
   "# get x,y,z points",
   "element",
   "=",
   "bin",
   "(",
   "i",
   ")",
   "[",
   "2",
   ":",
   "]",
   ".",
   "zfill",
   "(",
   "num",
   ")",
   "weight",
   "=",
   "element",
   ".",
   "count",
   "(",
   "\"1\"",
   ")",
   "zvalue",
   "=",
   "-",
   "2",
   "*",
   "weight",
   "/",
   "d",
   "+",
   "1",
   "number_of_divisions",
   "=",
   "n_choose_k",
   "(",
   "d",
   ",",
   "weight",
   ")",
   "weight_order",
   "=",
   "bit_string_index",
   "(",
   "element",
   ")",
   "# if weight_order >= number_of_divisions / 2:",
   "#    com_key = compliment(element)",
   "#    weight_order_temp = bit_string_index(com_key)",
   "#    weight_order = np.floor(",
   "#        number_of_divisions / 2) + weight_order_temp + 1",
   "angle",
   "=",
   "weight_order",
   "*",
   "2",
   "*",
   "np",
   ".",
   "pi",
   "/",
   "number_of_divisions",
   "xvalue",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "1",
   "-",
   "zvalue",
   "**",
   "2",
   ")",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "angle",
   ")",
   "yvalue",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "1",
   "-",
   "zvalue",
   "**",
   "2",
   ")",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "angle",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "[",
   "xvalue",
   "]",
   ",",
   "[",
   "yvalue",
   "]",
   ",",
   "[",
   "zvalue",
   "]",
   ",",
   "markerfacecolor",
   "=",
   "(",
   ".5",
   ",",
   ".5",
   ",",
   ".5",
   ")",
   ",",
   "markeredgecolor",
   "=",
   "(",
   ".5",
   ",",
   ".5",
   ",",
   ".5",
   ")",
   ",",
   "marker",
   "=",
   "'o'",
   ",",
   "markersize",
   "=",
   "10",
   ",",
   "alpha",
   "=",
   "1",
   ")",
   "# get prob and angle - prob will be shade and angle color",
   "prob",
   "=",
   "np",
   ".",
   "real",
   "(",
   "np",
   ".",
   "dot",
   "(",
   "state",
   "[",
   "i",
   "]",
   ",",
   "state",
   "[",
   "i",
   "]",
   ".",
   "conj",
   "(",
   ")",
   ")",
   ")",
   "colorstate",
   "=",
   "phase_to_color_wheel",
   "(",
   "state",
   "[",
   "i",
   "]",
   ")",
   "a",
   "=",
   "Arrow3D",
   "(",
   "[",
   "0",
   ",",
   "xvalue",
   "]",
   ",",
   "[",
   "0",
   ",",
   "yvalue",
   "]",
   ",",
   "[",
   "0",
   ",",
   "zvalue",
   "]",
   ",",
   "mutation_scale",
   "=",
   "20",
   ",",
   "alpha",
   "=",
   "prob",
   ",",
   "arrowstyle",
   "=",
   "\"-\"",
   ",",
   "color",
   "=",
   "colorstate",
   ",",
   "lw",
   "=",
   "10",
   ")",
   "ax",
   ".",
   "add_artist",
   "(",
   "a",
   ")",
   "# add weight lines",
   "for",
   "weight",
   "in",
   "range",
   "(",
   "d",
   "+",
   "1",
   ")",
   ":",
   "theta",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "-",
   "2",
   "*",
   "np",
   ".",
   "pi",
   ",",
   "2",
   "*",
   "np",
   ".",
   "pi",
   ",",
   "100",
   ")",
   "z",
   "=",
   "-",
   "2",
   "*",
   "weight",
   "/",
   "d",
   "+",
   "1",
   "r",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "1",
   "-",
   "z",
   "**",
   "2",
   ")",
   "x",
   "=",
   "r",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "theta",
   ")",
   "y",
   "=",
   "r",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "theta",
   ")",
   "ax",
   ".",
   "plot",
   "(",
   "x",
   ",",
   "y",
   ",",
   "z",
   ",",
   "color",
   "=",
   "(",
   ".5",
   ",",
   ".5",
   ",",
   ".5",
   ")",
   ")",
   "# add center point",
   "ax",
   ".",
   "plot",
   "(",
   "[",
   "0",
   "]",
   ",",
   "[",
   "0",
   "]",
   ",",
   "[",
   "0",
   "]",
   ",",
   "markerfacecolor",
   "=",
   "(",
   ".5",
   ",",
   ".5",
   ",",
   ".5",
   ")",
   ",",
   "markeredgecolor",
   "=",
   "(",
   ".5",
   ",",
   ".5",
   ",",
   ".5",
   ")",
   ",",
   "marker",
   "=",
   "'o'",
   ",",
   "markersize",
   "=",
   "10",
   ",",
   "alpha",
   "=",
   "1",
   ")",
   "we",
   "[",
   "prob_location",
   "]",
   "=",
   "0",
   "else",
   ":",
   "break",
   "plt",
   ".",
   "tight_layout",
   "(",
   ")",
   "plt",
   ".",
   "close",
   "(",
   "fig",
   ")",
   "return",
   "fig"
  ]
 },
 {
  "idx": "maxmin-1138",
  "nl_tokens": [
   "Get",
   "depth",
   "information",
   "for",
   "the",
   "circuit",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_image_depth",
   "(",
   "self",
   ")",
   ":",
   "max_column_widths",
   "=",
   "[",
   "]",
   "for",
   "layer",
   "in",
   "self",
   ".",
   "ops",
   ":",
   "# store the max width for the layer",
   "current_max",
   "=",
   "0",
   "for",
   "op",
   "in",
   "layer",
   ":",
   "# update current op width",
   "arg_str_len",
   "=",
   "0",
   "# the wide gates",
   "for",
   "arg",
   "in",
   "op",
   ".",
   "op",
   ".",
   "params",
   ":",
   "arg_str",
   "=",
   "re",
   ".",
   "sub",
   "(",
   "r'[-+]?\\d*\\.\\d{2,}|\\d{2,}'",
   ",",
   "_truncate_float",
   ",",
   "str",
   "(",
   "arg",
   ")",
   ")",
   "arg_str_len",
   "+=",
   "len",
   "(",
   "arg_str",
   ")",
   "# the width of the column is the max of all the gates in the column",
   "current_max",
   "=",
   "<mask>",
   "(",
   "arg_str_len",
   ",",
   "current_max",
   ")",
   "max_column_widths",
   ".",
   "append",
   "(",
   "current_max",
   ")",
   "# wires in the beginning and end",
   "columns",
   "=",
   "2",
   "# each layer is one column",
   "columns",
   "+=",
   "len",
   "(",
   "self",
   ".",
   "ops",
   ")",
   "# every 3 characters is roughly one extra 'unit' of width in the cell",
   "# the gate name is 1 extra 'unit'",
   "# the qubit/cbit labels plus initial states is 2 more",
   "# the wires poking out at the ends is 2 more",
   "sum_column_widths",
   "=",
   "sum",
   "(",
   "1",
   "+",
   "v",
   "/",
   "3",
   "for",
   "v",
   "in",
   "max_column_widths",
   ")",
   "# could be a fraction so ceil",
   "return",
   "columns",
   ",",
   "math",
   ".",
   "ceil",
   "(",
   "sum_column_widths",
   ")",
   "+",
   "4"
  ]
 },
 {
  "idx": "maxmin-1139",
  "nl_tokens": [
   "Plots",
   "a",
   "light",
   "curve",
   "described",
   "by",
   "kwargs",
   ":",
   "param",
   "bool",
   "compact",
   ":",
   "Display",
   "the",
   "compact",
   "version",
   "of",
   "the",
   "plot?",
   "Default",
   "False",
   ":",
   "param",
   "bool",
   "ldplot",
   ":",
   "Displat",
   "the",
   "limb",
   "darkening",
   "inset?",
   "Default",
   "True",
   ":",
   "param",
   "str",
   "plottitle",
   ":",
   "The",
   "title",
   "of",
   "the",
   "plot",
   ".",
   "Default",
   ":",
   "param",
   "float",
   "xlim",
   ":",
   "The",
   "half",
   "-",
   "width",
   "of",
   "the",
   "orbit",
   "plot",
   "in",
   "stellar",
   "radii",
   ".",
   "Default",
   "is",
   "to",
   "\\",
   "auto",
   "adjust",
   "this",
   ":",
   "param",
   "bool",
   "binned",
   ":",
   "Bin",
   "the",
   "light",
   "curve",
   "model",
   "to",
   "the",
   "exposure",
   "time?",
   "Default",
   "True",
   ":",
   "param",
   "kwargs",
   ":",
   "Any",
   "keyword",
   "arguments",
   "to",
   "be",
   "passed",
   "to",
   ":",
   "py",
   ":",
   "func",
   ":",
   "pysyzygy",
   ".",
   "transit",
   ".",
   "Transit",
   ":",
   "returns",
   "fig",
   ":",
   "The",
   ":",
   "py",
   ":",
   "mod",
   ":",
   "matplotlib",
   "figure",
   "object"
  ],
  "pl_tokens": [
   "def",
   "PlotTransit",
   "(",
   "compact",
   "=",
   "False",
   ",",
   "ldplot",
   "=",
   "True",
   ",",
   "plottitle",
   "=",
   "\"\"",
   ",",
   "xlim",
   "=",
   "None",
   ",",
   "binned",
   "=",
   "True",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# Plotting",
   "fig",
   "=",
   "pl",
   ".",
   "figure",
   "(",
   "figsize",
   "=",
   "(",
   "12",
   ",",
   "8",
   ")",
   ")",
   "fig",
   ".",
   "subplots_adjust",
   "(",
   "hspace",
   "=",
   "0.3",
   ")",
   "ax1",
   ",",
   "ax2",
   "=",
   "pl",
   ".",
   "subplot",
   "(",
   "211",
   ")",
   ",",
   "pl",
   ".",
   "subplot",
   "(",
   "212",
   ")",
   "if",
   "not",
   "compact",
   ":",
   "fig",
   ".",
   "subplots_adjust",
   "(",
   "right",
   "=",
   "0.7",
   ")",
   "t0",
   "=",
   "kwargs",
   ".",
   "pop",
   "(",
   "'t0'",
   ",",
   "0.",
   ")",
   "trn",
   "=",
   "Transit",
   "(",
   "*",
   "*",
   "kwargs",
   ")",
   "try",
   ":",
   "trn",
   ".",
   "Compute",
   "(",
   ")",
   "notransit",
   "=",
   "False",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "if",
   "str",
   "(",
   "e",
   ")",
   "==",
   "\"Object does not transit the star.\"",
   ":",
   "notransit",
   "=",
   "True",
   "else",
   ":",
   "raise",
   "Exception",
   "(",
   "e",
   ")",
   "time",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "time",
   "+",
   "t0",
   "if",
   "not",
   "notransit",
   ":",
   "if",
   "binned",
   ":",
   "trn",
   ".",
   "Bin",
   "(",
   ")",
   "flux",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "bflx",
   "else",
   ":",
   "flux",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "flux",
   "time",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "[",
   "-",
   "1.e5",
   "]",
   ",",
   "time",
   ",",
   "[",
   "1.e5",
   "]",
   ")",
   ")",
   "# Add baseline on each side",
   "flux",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "[",
   "1.",
   "]",
   ",",
   "flux",
   ",",
   "[",
   "1.",
   "]",
   ")",
   ")",
   "ax1",
   ".",
   "plot",
   "(",
   "time",
   ",",
   "flux",
   ",",
   "'-'",
   ",",
   "color",
   "=",
   "'DarkBlue'",
   ")",
   "rng",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "flux",
   ")",
   "-",
   "np",
   ".",
   "min",
   "(",
   "flux",
   ")",
   "if",
   "rng",
   ">",
   "0",
   ":",
   "ax1",
   ".",
   "set_ylim",
   "(",
   "np",
   ".",
   "min",
   "(",
   "flux",
   ")",
   "-",
   "0.1",
   "*",
   "rng",
   ",",
   "np",
   ".",
   "max",
   "(",
   "flux",
   ")",
   "+",
   "0.1",
   "*",
   "rng",
   ")",
   "left",
   "=",
   "np",
   ".",
   "argmax",
   "(",
   "flux",
   "<",
   "(",
   "1.",
   "-",
   "1.e-8",
   ")",
   ")",
   "right",
   "=",
   "np",
   ".",
   "argmax",
   "(",
   "flux",
   "[",
   "left",
   ":",
   "]",
   ">",
   "(",
   "1.",
   "-",
   "1.e-8",
   ")",
   ")",
   "+",
   "left",
   "rng",
   "=",
   "time",
   "[",
   "right",
   "]",
   "-",
   "time",
   "[",
   "left",
   "]",
   "ax1",
   ".",
   "set_xlim",
   "(",
   "time",
   "[",
   "left",
   "]",
   "-",
   "rng",
   ",",
   "time",
   "[",
   "right",
   "]",
   "+",
   "rng",
   ")",
   "ax1",
   ".",
   "set_xlabel",
   "(",
   "'Time (Days)'",
   ",",
   "fontweight",
   "=",
   "'bold'",
   ")",
   "ax1",
   ".",
   "set_ylabel",
   "(",
   "'Normalized Flux'",
   ",",
   "fontweight",
   "=",
   "'bold'",
   ")",
   "# Adjust these for full-orbit plotting",
   "maxpts",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'maxpts'",
   ",",
   "10000",
   ")",
   "kwargs",
   ".",
   "update",
   "(",
   "{",
   "'maxpts'",
   ":",
   "maxpts",
   "}",
   ")",
   "per",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'per'",
   ",",
   "10.",
   ")",
   "kwargs",
   ".",
   "update",
   "(",
   "{",
   "'per'",
   ":",
   "per",
   "}",
   ")",
   "kwargs",
   ".",
   "update",
   "(",
   "{",
   "'fullorbit'",
   ":",
   "True",
   "}",
   ")",
   "kwargs",
   ".",
   "update",
   "(",
   "{",
   "'exppts'",
   ":",
   "30",
   "}",
   ")",
   "kwargs",
   ".",
   "update",
   "(",
   "{",
   "'exptime'",
   ":",
   "50",
   "*",
   "per",
   "/",
   "maxpts",
   "}",
   ")",
   "trn",
   "=",
   "Transit",
   "(",
   "*",
   "*",
   "kwargs",
   ")",
   "try",
   ":",
   "trn",
   ".",
   "Compute",
   "(",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "if",
   "str",
   "(",
   "e",
   ")",
   "==",
   "\"Object does not transit the star.\"",
   ":",
   "pass",
   "else",
   ":",
   "raise",
   "Exception",
   "(",
   "e",
   ")",
   "# Sky-projected motion",
   "x",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "x",
   "y",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "y",
   "z",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "z",
   "inc",
   "=",
   "(",
   "np",
   ".",
   "arccos",
   "(",
   "trn",
   ".",
   "transit",
   ".",
   "bcirc",
   "/",
   "trn",
   ".",
   "transit",
   ".",
   "aRs",
   ")",
   "*",
   "180.",
   "/",
   "np",
   ".",
   "pi",
   ")",
   "# Orbital inclination",
   "# Mask the star",
   "for",
   "j",
   "in",
   "range",
   "(",
   "len",
   "(",
   "x",
   ")",
   ")",
   ":",
   "if",
   "(",
   "x",
   "[",
   "j",
   "]",
   "**",
   "2",
   "+",
   "y",
   "[",
   "j",
   "]",
   "**",
   "2",
   ")",
   "<",
   "1.",
   "and",
   "(",
   "z",
   "[",
   "j",
   "]",
   ">",
   "0",
   ")",
   ":",
   "x",
   "[",
   "j",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "y",
   "[",
   "j",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "# The star",
   "r",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "0",
   ",",
   "1",
   ",",
   "100",
   ")",
   "Ir",
   "=",
   "I",
   "(",
   "r",
   ",",
   "trn",
   ".",
   "limbdark",
   ")",
   "/",
   "I",
   "(",
   "0",
   ",",
   "trn",
   ".",
   "limbdark",
   ")",
   "for",
   "ri",
   ",",
   "Iri",
   "in",
   "zip",
   "(",
   "r",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "Ir",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   ":",
   "star",
   "=",
   "pl",
   ".",
   "Circle",
   "(",
   "(",
   "0",
   ",",
   "0",
   ")",
   ",",
   "ri",
   ",",
   "color",
   "=",
   "str",
   "(",
   "0.95",
   "*",
   "Iri",
   ")",
   ",",
   "alpha",
   "=",
   "1.",
   ")",
   "ax2",
   ".",
   "add_artist",
   "(",
   "star",
   ")",
   "# Inset: Limb darkening",
   "if",
   "ldplot",
   ":",
   "if",
   "compact",
   ":",
   "inset1",
   "=",
   "pl",
   ".",
   "axes",
   "(",
   "[",
   "0.145",
   ",",
   "0.32",
   ",",
   ".09",
   ",",
   ".1",
   "]",
   ")",
   "else",
   ":",
   "inset1",
   "=",
   "fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.725",
   ",",
   "0.3",
   ",",
   "0.2",
   ",",
   "0.15",
   "]",
   ")",
   "inset1",
   ".",
   "plot",
   "(",
   "r",
   ",",
   "Ir",
   ",",
   "'k-'",
   ")",
   "pl",
   ".",
   "setp",
   "(",
   "inset1",
   ",",
   "xlim",
   "=",
   "(",
   "-",
   "0.1",
   ",",
   "1.1",
   ")",
   ",",
   "ylim",
   "=",
   "(",
   "-",
   "0.1",
   ",",
   "1.1",
   ")",
   ",",
   "xticks",
   "=",
   "[",
   "0",
   ",",
   "1",
   "]",
   ",",
   "yticks",
   "=",
   "[",
   "0",
   ",",
   "1",
   "]",
   ")",
   "for",
   "tick",
   "in",
   "inset1",
   ".",
   "xaxis",
   ".",
   "get_major_ticks",
   "(",
   ")",
   "+",
   "inset1",
   ".",
   "yaxis",
   ".",
   "get_major_ticks",
   "(",
   ")",
   ":",
   "tick",
   ".",
   "label",
   ".",
   "set_fontsize",
   "(",
   "8",
   ")",
   "inset1",
   ".",
   "set_ylabel",
   "(",
   "r'I/I$_0$'",
   ",",
   "fontsize",
   "=",
   "8",
   ",",
   "labelpad",
   "=",
   "-",
   "8",
   ")",
   "inset1",
   ".",
   "set_xlabel",
   "(",
   "r'r/R$_\\star$'",
   ",",
   "fontsize",
   "=",
   "8",
   ",",
   "labelpad",
   "=",
   "-",
   "8",
   ")",
   "inset1",
   ".",
   "set_title",
   "(",
   "'Limb Darkening'",
   ",",
   "fontweight",
   "=",
   "'bold'",
   ",",
   "fontsize",
   "=",
   "9",
   ")",
   "# Inset: Top view of orbit",
   "if",
   "compact",
   ":",
   "inset2",
   "=",
   "pl",
   ".",
   "axes",
   "(",
   "[",
   "0.135",
   ",",
   "0.115",
   ",",
   ".1",
   ",",
   ".1",
   "]",
   ")",
   "else",
   ":",
   "inset2",
   "=",
   "fig",
   ".",
   "add_axes",
   "(",
   "[",
   "0.725",
   ",",
   "0.1",
   ",",
   "0.2",
   ",",
   "0.15",
   "]",
   ")",
   "pl",
   ".",
   "setp",
   "(",
   "inset2",
   ",",
   "xticks",
   "=",
   "[",
   "]",
   ",",
   "yticks",
   "=",
   "[",
   "]",
   ")",
   "trn",
   ".",
   "transit",
   ".",
   "bcirc",
   "=",
   "trn",
   ".",
   "transit",
   ".",
   "aRs",
   "# This ensures we are face-on",
   "try",
   ":",
   "trn",
   ".",
   "Compute",
   "(",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "if",
   "str",
   "(",
   "e",
   ")",
   "==",
   "\"Object does not transit the star.\"",
   ":",
   "pass",
   "else",
   ":",
   "raise",
   "Exception",
   "(",
   "e",
   ")",
   "xp",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "x",
   "yp",
   "=",
   "trn",
   ".",
   "arrays",
   ".",
   "y",
   "inset2",
   ".",
   "plot",
   "(",
   "xp",
   ",",
   "yp",
   ",",
   "'-'",
   ",",
   "color",
   "=",
   "'DarkBlue'",
   ",",
   "alpha",
   "=",
   "0.5",
   ")",
   "# Draw some invisible dots at the corners to set the window size",
   "xmin",
   ",",
   "xmax",
   ",",
   "ymin",
   ",",
   "ymax",
   "=",
   "np",
   ".",
   "nanmin",
   "(",
   "xp",
   ")",
   ",",
   "np",
   ".",
   "nanmax",
   "(",
   "xp",
   ")",
   ",",
   "np",
   ".",
   "nanmin",
   "(",
   "yp",
   ")",
   ",",
   "np",
   ".",
   "nanmax",
   "(",
   "yp",
   ")",
   "xrng",
   "=",
   "xmax",
   "-",
   "xmin",
   "yrng",
   "=",
   "ymax",
   "-",
   "ymin",
   "xmin",
   "-=",
   "0.1",
   "*",
   "xrng",
   "xmax",
   "+=",
   "0.1",
   "*",
   "xrng",
   "ymin",
   "-=",
   "0.1",
   "*",
   "yrng",
   "ymax",
   "+=",
   "0.1",
   "*",
   "yrng",
   "inset2",
   ".",
   "scatter",
   "(",
   "[",
   "xmin",
   ",",
   "xmin",
   ",",
   "xmax",
   ",",
   "xmax",
   "]",
   ",",
   "[",
   "ymin",
   ",",
   "ymax",
   ",",
   "ymin",
   ",",
   "ymax",
   "]",
   ",",
   "alpha",
   "=",
   "0.",
   ")",
   "# Plot the star",
   "for",
   "ri",
   ",",
   "Iri",
   "in",
   "zip",
   "(",
   "r",
   "[",
   ":",
   ":",
   "-",
   "10",
   "]",
   ",",
   "Ir",
   "[",
   ":",
   ":",
   "-",
   "10",
   "]",
   ")",
   ":",
   "star",
   "=",
   "pl",
   ".",
   "Circle",
   "(",
   "(",
   "0",
   ",",
   "0",
   ")",
   ",",
   "ri",
   ",",
   "color",
   "=",
   "str",
   "(",
   "0.95",
   "*",
   "Iri",
   ")",
   ",",
   "alpha",
   "=",
   "1.",
   ")",
   "inset2",
   ".",
   "add_artist",
   "(",
   "star",
   ")",
   "# Plot the planet",
   "ycenter",
   "=",
   "yp",
   "[",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "xp",
   ")",
   "==",
   "np",
   ".",
   "nanmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "xp",
   ")",
   ")",
   ")",
   "]",
   "[",
   "0",
   "]",
   "while",
   "ycenter",
   ">",
   "0",
   ":",
   "xp",
   "[",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "xp",
   ")",
   "==",
   "np",
   ".",
   "nanmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "xp",
   ")",
   ")",
   ")",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "ycenter",
   "=",
   "yp",
   "[",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "xp",
   ")",
   "==",
   "np",
   ".",
   "nanmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "xp",
   ")",
   ")",
   ")",
   "]",
   "[",
   "0",
   "]",
   "planet",
   "=",
   "pl",
   ".",
   "Circle",
   "(",
   "(",
   "0",
   ",",
   "ycenter",
   ")",
   ",",
   "trn",
   ".",
   "transit",
   ".",
   "RpRs",
   ",",
   "color",
   "=",
   "'DarkBlue'",
   ",",
   "alpha",
   "=",
   "1.",
   ")",
   "inset2",
   ".",
   "add_artist",
   "(",
   "planet",
   ")",
   "inset2",
   ".",
   "set_title",
   "(",
   "'Top View'",
   ",",
   "fontweight",
   "=",
   "'bold'",
   ",",
   "fontsize",
   "=",
   "9",
   ")",
   "inset2",
   ".",
   "set_aspect",
   "(",
   "'equal'",
   ",",
   "'datalim'",
   ")",
   "# The orbit itself",
   "with",
   "np",
   ".",
   "errstate",
   "(",
   "invalid",
   "=",
   "'ignore'",
   ")",
   ":",
   "ax2",
   ".",
   "plot",
   "(",
   "x",
   ",",
   "y",
   ",",
   "'-'",
   ",",
   "color",
   "=",
   "'DarkBlue'",
   ",",
   "lw",
   "=",
   "1.",
   "if",
   "per",
   "<",
   "30.",
   "else",
   "max",
   "(",
   "1.",
   "-",
   "(",
   "per",
   "-",
   "30.",
   ")",
   "/",
   "100.",
   ",",
   "0.3",
   ")",
   ")",
   "# The planet",
   "with",
   "np",
   ".",
   "errstate",
   "(",
   "invalid",
   "=",
   "'ignore'",
   ")",
   ":",
   "ycenter",
   "=",
   "y",
   "[",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   "==",
   "np",
   ".",
   "nanmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   ")",
   ")",
   "]",
   "[",
   "0",
   "]",
   "while",
   "ycenter",
   ">",
   "0",
   ":",
   "x",
   "[",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   "==",
   "np",
   ".",
   "nanmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   ")",
   ")",
   "]",
   "=",
   "np",
   ".",
   "nan",
   "ycenter",
   "=",
   "y",
   "[",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   "==",
   "np",
   ".",
   "nanmin",
   "(",
   "np",
   ".",
   "abs",
   "(",
   "x",
   ")",
   ")",
   ")",
   "]",
   "[",
   "0",
   "]",
   "planet",
   "=",
   "pl",
   ".",
   "Circle",
   "(",
   "(",
   "0",
   ",",
   "ycenter",
   ")",
   ",",
   "trn",
   ".",
   "transit",
   ".",
   "RpRs",
   ",",
   "color",
   "=",
   "'DarkBlue'",
   ",",
   "alpha",
   "=",
   "1.",
   ")",
   "ax2",
   ".",
   "add_artist",
   "(",
   "planet",
   ")",
   "# Force aspect",
   "if",
   "xlim",
   "is",
   "None",
   ":",
   "xlim",
   "=",
   "1.1",
   "*",
   "max",
   "(",
   "np",
   ".",
   "nanmax",
   "(",
   "x",
   ")",
   ",",
   "np",
   ".",
   "nanmax",
   "(",
   "-",
   "x",
   ")",
   ")",
   "ax2",
   ".",
   "set_ylim",
   "(",
   "-",
   "xlim",
   "/",
   "3.2",
   ",",
   "xlim",
   "/",
   "3.2",
   ")",
   "ax2",
   ".",
   "set_xlim",
   "(",
   "-",
   "xlim",
   ",",
   "xlim",
   ")",
   "ax2",
   ".",
   "set_xlabel",
   "(",
   "r'X (R$_\\star$)'",
   ",",
   "fontweight",
   "=",
   "'bold'",
   ")",
   "ax2",
   ".",
   "set_ylabel",
   "(",
   "r'Y (R$_\\star$)'",
   ",",
   "fontweight",
   "=",
   "'bold'",
   ")",
   "ax1",
   ".",
   "set_title",
   "(",
   "plottitle",
   ",",
   "fontsize",
   "=",
   "12",
   ")",
   "if",
   "not",
   "compact",
   ":",
   "rect",
   "=",
   "0.725",
   ",",
   "0.55",
   ",",
   "0.2",
   ",",
   "0.35",
   "ax3",
   "=",
   "fig",
   ".",
   "add_axes",
   "(",
   "rect",
   ")",
   "ax3",
   ".",
   "xaxis",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "ax3",
   ".",
   "yaxis",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "# Table of parameters",
   "ltable",
   "=",
   "[",
   "r'$P:$'",
   ",",
   "r'$e:$'",
   ",",
   "r'$i:$'",
   ",",
   "r'$\\omega:$'",
   ",",
   "r'$\\rho_\\star:$'",
   ",",
   "r'$M_p:$'",
   ",",
   "r'$R_p:$'",
   ",",
   "r'$q_1:$'",
   ",",
   "r'$q_2:$'",
   "]",
   "rtable",
   "=",
   "[",
   "r'$%.4f\\ \\mathrm{days}$'",
   "%",
   "trn",
   ".",
   "transit",
   ".",
   "per",
   ",",
   "r'$%.5f$'",
   "%",
   "trn",
   ".",
   "transit",
   ".",
   "ecc",
   ",",
   "r'$%.4f^\\circ$'",
   "%",
   "inc",
   ",",
   "r'$%.3f^\\circ$'",
   "%",
   "(",
   "trn",
   ".",
   "transit",
   ".",
   "w",
   "*",
   "180.",
   "/",
   "np",
   ".",
   "pi",
   ")",
   ",",
   "r'$%.5f\\ \\mathrm{g/cm^3}$'",
   "%",
   "trn",
   ".",
   "transit",
   ".",
   "rhos",
   ",",
   "r'$%.5f\\ M_\\star$'",
   "%",
   "trn",
   ".",
   "transit",
   ".",
   "MpMs",
   ",",
   "r'$%.5f\\ R_\\star$'",
   "%",
   "trn",
   ".",
   "transit",
   ".",
   "RpRs",
   ",",
   "r'$%.5f$'",
   "%",
   "trn",
   ".",
   "limbdark",
   ".",
   "q1",
   ",",
   "r'$%.5f$'",
   "%",
   "trn",
   ".",
   "limbdark",
   ".",
   "q2",
   "]",
   "yt",
   "=",
   "0.875",
   "for",
   "l",
   ",",
   "r",
   "in",
   "zip",
   "(",
   "ltable",
   ",",
   "rtable",
   ")",
   ":",
   "ax3",
   ".",
   "annotate",
   "(",
   "l",
   ",",
   "xy",
   "=",
   "(",
   "0.25",
   ",",
   "yt",
   ")",
   ",",
   "xycoords",
   "=",
   "\"axes fraction\"",
   ",",
   "ha",
   "=",
   "'right'",
   ",",
   "fontsize",
   "=",
   "16",
   ")",
   "ax3",
   ".",
   "annotate",
   "(",
   "r",
   ",",
   "xy",
   "=",
   "(",
   "0.35",
   ",",
   "yt",
   ")",
   ",",
   "xycoords",
   "=",
   "\"axes fraction\"",
   ",",
   "fontsize",
   "=",
   "16",
   ")",
   "yt",
   "-=",
   "0.1",
   "return",
   "fig"
  ]
 },
 {
  "idx": "maxmin-1140",
  "nl_tokens": [
   "Lists",
   "messages",
   "in",
   "a",
   "room",
   "."
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "roomId",
   ",",
   "mentionedPeople",
   "=",
   "None",
   ",",
   "before",
   "=",
   "None",
   ",",
   "beforeMessage",
   "=",
   "None",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "roomId",
   ",",
   "basestring",
   ",",
   "may_be_none",
   "=",
   "False",
   ")",
   "check_type",
   "(",
   "mentionedPeople",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "before",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "beforeMessage",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "roomId",
   "=",
   "roomId",
   ",",
   "mentionedPeople",
   "=",
   "mentionedPeople",
   ",",
   "before",
   "=",
   "before",
   ",",
   "beforeMessage",
   "=",
   "beforeMessage",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield message objects created from the returned items JSON objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-1141",
  "nl_tokens": [
   "Run",
   "complete",
   "analysis",
   "."
  ],
  "pl_tokens": [
   "def",
   "analyze",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "_CPU",
   ".",
   "analyze",
   "(",
   ")",
   "self",
   ".",
   "_data",
   ".",
   "analyze",
   "(",
   ")",
   "self",
   ".",
   "results",
   "=",
   "copy",
   ".",
   "deepcopy",
   "(",
   "self",
   ".",
   "_CPU",
   ".",
   "results",
   ")",
   "self",
   ".",
   "results",
   ".",
   "update",
   "(",
   "copy",
   ".",
   "deepcopy",
   "(",
   "self",
   ".",
   "_data",
   ".",
   "results",
   ")",
   ")",
   "cores_per_numa_domain",
   "=",
   "self",
   ".",
   "machine",
   "[",
   "'cores per NUMA domain'",
   "]",
   "# Compile total single-core prediction",
   "self",
   ".",
   "results",
   "[",
   "'total cycles'",
   "]",
   "=",
   "self",
   ".",
   "_CPU",
   ".",
   "conv_cy",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'T_OL'",
   "]",
   ",",
   "sum",
   "(",
   "[",
   "self",
   ".",
   "results",
   "[",
   "'T_nOL'",
   "]",
   "]",
   "+",
   "[",
   "i",
   "[",
   "1",
   "]",
   "for",
   "i",
   "in",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "]",
   ")",
   ")",
   ")",
   "T_ECM",
   "=",
   "float",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'total cycles'",
   "]",
   "[",
   "'cy/CL'",
   "]",
   ")",
   "# T_MEM is the cycles accounted to memory transfers",
   "T_MEM",
   "=",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   "# Simple scaling prediction:",
   "# Assumptions are:",
   "#  - bottleneck is always LLC-MEM",
   "#  - all caches scale with number of cores (bw AND size(WRONG!))",
   "# Full caching in higher cache level",
   "self",
   ".",
   "results",
   "[",
   "'scaling cores'",
   "]",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "# Not full caching:",
   "if",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   "!=",
   "0.0",
   ":",
   "# Considering memory bus utilization",
   "utilization",
   "=",
   "[",
   "0",
   "]",
   "self",
   ".",
   "results",
   "[",
   "'scaling cores'",
   "]",
   "=",
   "float",
   "(",
   "'inf'",
   ")",
   "for",
   "c",
   "in",
   "range",
   "(",
   "1",
   ",",
   "cores_per_numa_domain",
   "+",
   "1",
   ")",
   ":",
   "if",
   "c",
   "*",
   "T_MEM",
   ">",
   "(",
   "T_ECM",
   "+",
   "utilization",
   "[",
   "c",
   "-",
   "1",
   "]",
   "*",
   "(",
   "c",
   "-",
   "1",
   ")",
   "*",
   "T_MEM",
   "/",
   "2",
   ")",
   ":",
   "utilization",
   ".",
   "append",
   "(",
   "1.0",
   ")",
   "self",
   ".",
   "results",
   "[",
   "'scaling cores'",
   "]",
   "=",
   "min",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'scaling cores'",
   "]",
   ",",
   "c",
   ")",
   "else",
   ":",
   "utilization",
   ".",
   "append",
   "(",
   "c",
   "*",
   "T_MEM",
   "/",
   "(",
   "T_ECM",
   "+",
   "utilization",
   "[",
   "c",
   "-",
   "1",
   "]",
   "*",
   "(",
   "c",
   "-",
   "1",
   ")",
   "*",
   "T_MEM",
   "/",
   "2",
   ")",
   ")",
   "utilization",
   "=",
   "utilization",
   "[",
   "1",
   ":",
   "]",
   "# Old scaling code",
   "#self.results['scaling cores'] = (",
   "#    max(self.results['T_OL'],",
   "#        self.results['T_nOL'] + sum([c[1] for c in self.results['cycles']])) /",
   "#    self.results['cycles'][-1][1])",
   "scaling_predictions",
   "=",
   "[",
   "]",
   "for",
   "cores",
   "in",
   "range",
   "(",
   "1",
   ",",
   "self",
   ".",
   "machine",
   "[",
   "'cores per socket'",
   "]",
   "+",
   "1",
   ")",
   ":",
   "scaling",
   "=",
   "{",
   "'cores'",
   ":",
   "cores",
   ",",
   "'notes'",
   ":",
   "[",
   "]",
   ",",
   "'performance'",
   ":",
   "None",
   ",",
   "'in-NUMA performance'",
   ":",
   "None",
   "}",
   "# Detailed scaling:",
   "if",
   "cores",
   "<=",
   "self",
   ".",
   "results",
   "[",
   "'scaling cores'",
   "]",
   ":",
   "# Is it purely in-cache?",
   "innuma_rectp",
   "=",
   "PrefixedUnit",
   "(",
   "max",
   "(",
   "sum",
   "(",
   "[",
   "c",
   "[",
   "1",
   "]",
   "for",
   "c",
   "in",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "]",
   ")",
   "+",
   "self",
   ".",
   "results",
   "[",
   "'T_nOL'",
   "]",
   ",",
   "self",
   ".",
   "results",
   "[",
   "'T_OL'",
   "]",
   ")",
   "/",
   "(",
   "T_ECM",
   "/",
   "T_MEM",
   ")",
   ",",
   "\"cy/CL\"",
   ")",
   "scaling",
   "[",
   "'notes'",
   "]",
   ".",
   "append",
   "(",
   "\"memory-interface not saturated\"",
   ")",
   "else",
   ":",
   "innuma_rectp",
   "=",
   "PrefixedUnit",
   "(",
   "self",
   ".",
   "results",
   "[",
   "'cycles'",
   "]",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   ",",
   "'cy/CL'",
   ")",
   "scaling",
   "[",
   "'notes'",
   "]",
   ".",
   "append",
   "(",
   "\"memory-interface saturated on first NUMA domain\"",
   ")",
   "# Include NUMA-local performance in results dict",
   "scaling",
   "[",
   "'in-NUMA performance'",
   "]",
   "=",
   "innuma_rectp",
   "if",
   "0",
   "<",
   "cores",
   "<=",
   "cores_per_numa_domain",
   ":",
   "# only in-numa scaling to consider",
   "scaling",
   "[",
   "'performance'",
   "]",
   "=",
   "self",
   ".",
   "_CPU",
   ".",
   "conv_cy",
   "(",
   "innuma_rectp",
   "/",
   "utilization",
   "[",
   "cores",
   "-",
   "1",
   "]",
   ")",
   "scaling",
   "[",
   "'notes'",
   "]",
   ".",
   "append",
   "(",
   "\"in-NUMA-domain scaling\"",
   ")",
   "elif",
   "cores",
   "<=",
   "self",
   ".",
   "machine",
   "[",
   "'cores per socket'",
   "]",
   "*",
   "self",
   ".",
   "machine",
   "[",
   "'sockets'",
   "]",
   ":",
   "# out-of-numa scaling behavior",
   "scaling",
   "[",
   "'performance'",
   "]",
   "=",
   "self",
   ".",
   "_CPU",
   ".",
   "conv_cy",
   "(",
   "innuma_rectp",
   "*",
   "cores_per_numa_domain",
   "/",
   "cores",
   ")",
   "scaling",
   "[",
   "'notes'",
   "]",
   ".",
   "append",
   "(",
   "\"out-of-NUMA-domain scaling\"",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Number of cores must be greater than zero and upto the max. \"",
   "\"number of cores defined by cores per socket and sockets in\"",
   "\"machine file.\"",
   ")",
   "scaling_predictions",
   ".",
   "append",
   "(",
   "scaling",
   ")",
   "else",
   ":",
   "# pure in-cache performace (perfect scaling)",
   "scaling_predictions",
   "=",
   "[",
   "{",
   "'cores'",
   ":",
   "cores",
   ",",
   "'notes'",
   ":",
   "[",
   "'pure in-cache'",
   "]",
   ",",
   "'performance'",
   ":",
   "self",
   ".",
   "_CPU",
   ".",
   "conv_cy",
   "(",
   "T_ECM",
   "/",
   "cores",
   ")",
   ",",
   "'in-NUMA performance'",
   ":",
   "self",
   ".",
   "_CPU",
   ".",
   "conv_cy",
   "(",
   "T_ECM",
   "/",
   "cores_per_numa_domain",
   ")",
   "}",
   "for",
   "cores",
   "in",
   "range",
   "(",
   "1",
   ",",
   "self",
   ".",
   "machine",
   "[",
   "'cores per socket'",
   "]",
   "+",
   "1",
   ")",
   "]",
   "# Also include prediction for all in-NUMA core counts in results",
   "self",
   ".",
   "results",
   "[",
   "'scaling prediction'",
   "]",
   "=",
   "scaling_predictions",
   "if",
   "self",
   ".",
   "_args",
   ".",
   "cores",
   ":",
   "self",
   ".",
   "results",
   "[",
   "'multi-core'",
   "]",
   "=",
   "scaling_predictions",
   "[",
   "self",
   ".",
   "_args",
   ".",
   "cores",
   "-",
   "1",
   "]",
   "else",
   ":",
   "self",
   ".",
   "results",
   "[",
   "'multi-core'",
   "]",
   "=",
   "None"
  ]
 },
 {
  "idx": "maxmin-1142",
  "nl_tokens": [
   "Calculate",
   "the",
   "[",
   "min",
   "max",
   "]",
   "range",
   "for",
   "expression",
   "containing",
   "approximately",
   "a",
   "percentage",
   "of",
   "the",
   "data",
   "as",
   "defined",
   "by",
   "percentage",
   "."
  ],
  "pl_tokens": [
   "def",
   "limits_percentage",
   "(",
   "self",
   ",",
   "expression",
   ",",
   "percentage",
   "=",
   "99.73",
   ",",
   "square",
   "=",
   "False",
   ",",
   "delay",
   "=",
   "False",
   ")",
   ":",
   "# percentiles = self.percentile(expression, [100-percentage/2, 100-(100-percentage/2.)], delay=True)",
   "# return self._delay(delay, percentiles)",
   "# print(percentage)",
   "import",
   "scipy",
   "logger",
   ".",
   "info",
   "(",
   "\"limits_percentage for %r, with percentage=%r\"",
   ",",
   "expression",
   ",",
   "percentage",
   ")",
   "waslist",
   ",",
   "[",
   "expressions",
   ",",
   "]",
   "=",
   "vaex",
   ".",
   "utils",
   ".",
   "listify",
   "(",
   "expression",
   ")",
   "limits",
   "=",
   "[",
   "]",
   "for",
   "expr",
   "in",
   "expressions",
   ":",
   "subspace",
   "=",
   "self",
   "(",
   "expr",
   ")",
   "limits_minmax",
   "=",
   "subspace",
   ".",
   "minmax",
   "(",
   ")",
   "vmin",
   ",",
   "vmax",
   "=",
   "limits_minmax",
   "[",
   "0",
   "]",
   "size",
   "=",
   "1024",
   "*",
   "16",
   "counts",
   "=",
   "subspace",
   ".",
   "histogram",
   "(",
   "size",
   "=",
   "size",
   ",",
   "limits",
   "=",
   "limits_minmax",
   ")",
   "cumcounts",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "[",
   "0",
   "]",
   ",",
   "np",
   ".",
   "cumsum",
   "(",
   "counts",
   ")",
   "]",
   ")",
   "cumcounts",
   "/=",
   "cumcounts",
   ".",
   "<mask>",
   "(",
   ")",
   "# TODO: this is crude.. see the details!",
   "f",
   "=",
   "(",
   "1",
   "-",
   "percentage",
   "/",
   "100.",
   ")",
   "/",
   "2",
   "x",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "vmin",
   ",",
   "vmax",
   ",",
   "size",
   "+",
   "1",
   ")",
   "l",
   "=",
   "scipy",
   ".",
   "interp",
   "(",
   "[",
   "f",
   ",",
   "1",
   "-",
   "f",
   "]",
   ",",
   "cumcounts",
   ",",
   "x",
   ")",
   "limits",
   ".",
   "append",
   "(",
   "l",
   ")",
   "# return limits",
   "return",
   "vaex",
   ".",
   "utils",
   ".",
   "unlistify",
   "(",
   "waslist",
   ",",
   "limits",
   ")"
  ]
 },
 {
  "idx": "maxmin-1143",
  "nl_tokens": [
   "Calculate",
   "the",
   "minimum",
   "proper",
   "motion",
   "errors",
   "from",
   "G",
   "and",
   "(",
   "V",
   "-",
   "I",
   ")",
   ".",
   "These",
   "correspond",
   "to",
   "the",
   "sky",
   "regions",
   "with",
   "the",
   "smallest",
   "astrometric",
   "errors",
   "."
  ],
  "pl_tokens": [
   "def",
   "properMotionMinError",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "0.0",
   ")",
   ":",
   "factor",
   "=",
   "errorScalingMissionLength",
   "(",
   "extension",
   ",",
   "-",
   "1.5",
   ")",
   "parallaxError",
   "=",
   "parallaxErrorSkyAvg",
   "(",
   "G",
   ",",
   "vmini",
   ")",
   "*",
   "factor",
   "return",
   "_astrometricErrorFactors",
   "[",
   "'muAlphaStar'",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "parallaxError",
   ",",
   "_astrometricErrorFactors",
   "[",
   "'muDelta'",
   "]",
   ".",
   "min",
   "(",
   ")",
   "*",
   "parallaxError"
  ]
 },
 {
  "idx": "maxmin-1144",
  "nl_tokens": [
   "Plotting",
   "but",
   "only",
   "for",
   "tops",
   "(",
   "as",
   "opposed",
   "to",
   "intervals",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_tops",
   "(",
   "self",
   ",",
   "ax",
   ",",
   "legend",
   "=",
   "None",
   ",",
   "field",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "field",
   "is",
   "None",
   ":",
   "raise",
   "StriplogError",
   "(",
   "'You must provide a field to plot.'",
   ")",
   "ys",
   "=",
   "[",
   "iv",
   ".",
   "top",
   ".",
   "z",
   "for",
   "iv",
   "in",
   "self",
   "]",
   "try",
   ":",
   "try",
   ":",
   "ts",
   "=",
   "[",
   "getattr",
   "(",
   "iv",
   ".",
   "primary",
   ",",
   "field",
   ")",
   "for",
   "iv",
   "in",
   "self",
   "]",
   "except",
   ":",
   "ts",
   "=",
   "[",
   "iv",
   ".",
   "data",
   ".",
   "get",
   "(",
   "field",
   ")",
   "for",
   "iv",
   "in",
   "self",
   "]",
   "except",
   ":",
   "raise",
   "StriplogError",
   "(",
   "'Could not retrieve field.'",
   ")",
   "for",
   "y",
   ",",
   "t",
   "in",
   "zip",
   "(",
   "ys",
   ",",
   "ts",
   ")",
   ":",
   "ax",
   ".",
   "axhline",
   "(",
   "y",
   ",",
   "color",
   "=",
   "'lightblue'",
   ",",
   "lw",
   "=",
   "3",
   ",",
   "zorder",
   "=",
   "0",
   ")",
   "ax",
   ".",
   "text",
   "(",
   "0.1",
   ",",
   "y",
   "-",
   "<mask>",
   "(",
   "ys",
   ")",
   "/",
   "200",
   ",",
   "t",
   ",",
   "ha",
   "=",
   "'left'",
   ")",
   "return",
   "ax"
  ]
 },
 {
  "idx": "maxmin-1145",
  "nl_tokens": [
   "Select",
   "an",
   "elliptical",
   "region",
   "centred",
   "on",
   "xc",
   "yc",
   "with",
   "a",
   "certain",
   "width",
   "height",
   "and",
   "angle",
   "."
  ],
  "pl_tokens": [
   "def",
   "select_ellipse",
   "(",
   "self",
   ",",
   "x",
   ",",
   "y",
   ",",
   "xc",
   ",",
   "yc",
   ",",
   "width",
   ",",
   "height",
   ",",
   "angle",
   "=",
   "0",
   ",",
   "mode",
   "=",
   "\"replace\"",
   ",",
   "name",
   "=",
   "\"default\"",
   ",",
   "radians",
   "=",
   "False",
   ",",
   "inclusive",
   "=",
   "True",
   ")",
   ":",
   "# Computing the properties of the ellipse prior to selection",
   "if",
   "radians",
   ":",
   "pass",
   "else",
   ":",
   "alpha",
   "=",
   "np",
   ".",
   "deg2rad",
   "(",
   "angle",
   ")",
   "xr",
   "=",
   "width",
   "/",
   "2",
   "yr",
   "=",
   "height",
   "/",
   "2",
   "r",
   "=",
   "<mask>",
   "(",
   "xr",
   ",",
   "yr",
   ")",
   "a",
   "=",
   "xr",
   "/",
   "r",
   "b",
   "=",
   "yr",
   "/",
   "r",
   "expr",
   "=",
   "\"(({x}-{xc})*cos({alpha})+({y}-{yc})*sin({alpha}))**2/{a}**2 + (({x}-{xc})*sin({alpha})-({y}-{yc})*cos({alpha}))**2/{b}**2 <= {r}**2\"",
   ".",
   "format",
   "(",
   "*",
   "*",
   "locals",
   "(",
   ")",
   ")",
   "if",
   "inclusive",
   ":",
   "expr",
   "=",
   "(",
   "(",
   "self",
   "[",
   "x",
   "]",
   "-",
   "xc",
   ")",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "alpha",
   ")",
   "+",
   "(",
   "self",
   "[",
   "y",
   "]",
   "-",
   "yc",
   ")",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "alpha",
   ")",
   ")",
   "**",
   "2",
   "/",
   "a",
   "**",
   "2",
   "+",
   "(",
   "(",
   "self",
   "[",
   "x",
   "]",
   "-",
   "xc",
   ")",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "alpha",
   ")",
   "-",
   "(",
   "self",
   "[",
   "y",
   "]",
   "-",
   "yc",
   ")",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "alpha",
   ")",
   ")",
   "**",
   "2",
   "/",
   "b",
   "**",
   "2",
   "<=",
   "r",
   "**",
   "2",
   "else",
   ":",
   "expr",
   "=",
   "(",
   "(",
   "self",
   "[",
   "x",
   "]",
   "-",
   "xc",
   ")",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "alpha",
   ")",
   "+",
   "(",
   "self",
   "[",
   "y",
   "]",
   "-",
   "yc",
   ")",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "alpha",
   ")",
   ")",
   "**",
   "2",
   "/",
   "a",
   "**",
   "2",
   "+",
   "(",
   "(",
   "self",
   "[",
   "x",
   "]",
   "-",
   "xc",
   ")",
   "*",
   "np",
   ".",
   "sin",
   "(",
   "alpha",
   ")",
   "-",
   "(",
   "self",
   "[",
   "y",
   "]",
   "-",
   "yc",
   ")",
   "*",
   "np",
   ".",
   "cos",
   "(",
   "alpha",
   ")",
   ")",
   "**",
   "2",
   "/",
   "b",
   "**",
   "2",
   "<",
   "r",
   "**",
   "2",
   "self",
   ".",
   "select",
   "(",
   "boolean_expression",
   "=",
   "expr",
   ",",
   "mode",
   "=",
   "mode",
   ",",
   "name",
   "=",
   "name",
   ")"
  ]
 },
 {
  "idx": "maxmin-1146",
  "nl_tokens": [
   "Compute",
   "the",
   "matrix",
   "rank",
   ";",
   "the",
   "number",
   "of",
   "non",
   "-",
   "zero",
   "SVD",
   "singular",
   "values",
   "."
  ],
  "pl_tokens": [
   "def",
   "matrix_rank",
   "(",
   "a",
   ",",
   "tol",
   "=",
   "None",
   ",",
   "validate_args",
   "=",
   "False",
   ",",
   "name",
   "=",
   "None",
   ")",
   ":",
   "with",
   "tf",
   ".",
   "compat",
   ".",
   "v1",
   ".",
   "name_scope",
   "(",
   "name",
   ",",
   "'matrix_rank'",
   ",",
   "[",
   "a",
   ",",
   "tol",
   "]",
   ")",
   ":",
   "a",
   "=",
   "tf",
   ".",
   "convert_to_tensor",
   "(",
   "value",
   "=",
   "a",
   ",",
   "dtype_hint",
   "=",
   "tf",
   ".",
   "float32",
   ",",
   "name",
   "=",
   "'a'",
   ")",
   "assertions",
   "=",
   "_maybe_validate_matrix",
   "(",
   "a",
   ",",
   "validate_args",
   ")",
   "if",
   "assertions",
   ":",
   "with",
   "tf",
   ".",
   "control_dependencies",
   "(",
   "assertions",
   ")",
   ":",
   "a",
   "=",
   "tf",
   ".",
   "identity",
   "(",
   "a",
   ")",
   "s",
   "=",
   "tf",
   ".",
   "linalg",
   ".",
   "svd",
   "(",
   "a",
   ",",
   "compute_uv",
   "=",
   "False",
   ")",
   "if",
   "tol",
   "is",
   "None",
   ":",
   "if",
   "a",
   ".",
   "shape",
   "[",
   "-",
   "2",
   ":",
   "]",
   ".",
   "is_fully_defined",
   "(",
   ")",
   ":",
   "m",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "a",
   ".",
   "shape",
   "[",
   "-",
   "2",
   ":",
   "]",
   ".",
   "as_list",
   "(",
   ")",
   ")",
   "else",
   ":",
   "m",
   "=",
   "tf",
   ".",
   "reduce_max",
   "(",
   "input_tensor",
   "=",
   "tf",
   ".",
   "shape",
   "(",
   "input",
   "=",
   "a",
   ")",
   "[",
   "-",
   "2",
   ":",
   "]",
   ")",
   "eps",
   "=",
   "np",
   ".",
   "finfo",
   "(",
   "a",
   ".",
   "dtype",
   ".",
   "as_numpy_dtype",
   ")",
   ".",
   "eps",
   "tol",
   "=",
   "(",
   "eps",
   "*",
   "tf",
   ".",
   "cast",
   "(",
   "m",
   ",",
   "a",
   ".",
   "dtype",
   ")",
   "*",
   "tf",
   ".",
   "reduce_max",
   "(",
   "input_tensor",
   "=",
   "s",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ",",
   "keepdims",
   "=",
   "True",
   ")",
   ")",
   "return",
   "tf",
   ".",
   "reduce_sum",
   "(",
   "input_tensor",
   "=",
   "tf",
   ".",
   "cast",
   "(",
   "s",
   ">",
   "tol",
   ",",
   "tf",
   ".",
   "int32",
   ")",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-1147",
  "nl_tokens": [
   "Plots",
   "PDF",
   "and",
   "powerlaw",
   "."
  ],
  "pl_tokens": [
   "def",
   "plotpdf",
   "(",
   "self",
   ",",
   "x",
   "=",
   "None",
   ",",
   "xmin",
   "=",
   "None",
   ",",
   "alpha",
   "=",
   "None",
   ",",
   "nbins",
   "=",
   "50",
   ",",
   "dolog",
   "=",
   "True",
   ",",
   "dnds",
   "=",
   "False",
   ",",
   "drawstyle",
   "=",
   "'steps-post'",
   ",",
   "histcolor",
   "=",
   "'k'",
   ",",
   "plcolor",
   "=",
   "'r'",
   ",",
   "fill",
   "=",
   "False",
   ",",
   "dohist",
   "=",
   "True",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "x",
   "is",
   "None",
   ":",
   "x",
   "=",
   "self",
   ".",
   "data",
   "if",
   "xmin",
   "is",
   "None",
   ":",
   "xmin",
   "=",
   "self",
   ".",
   "_xmin",
   "if",
   "alpha",
   "is",
   "None",
   ":",
   "alpha",
   "=",
   "self",
   ".",
   "_alpha",
   "x",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "x",
   ")",
   "#n=len(x)",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "set_xscale",
   "(",
   "'log'",
   ")",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "set_yscale",
   "(",
   "'log'",
   ")",
   "if",
   "dnds",
   ":",
   "hb",
   "=",
   "pylab",
   ".",
   "histogram",
   "(",
   "x",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "logspace",
   "(",
   "log10",
   "(",
   "<mask>",
   "(",
   "x",
   ")",
   ")",
   ",",
   "log10",
   "(",
   "max",
   "(",
   "x",
   ")",
   ")",
   ",",
   "nbins",
   ")",
   ")",
   "h",
   "=",
   "hb",
   "[",
   "0",
   "]",
   "b",
   "=",
   "hb",
   "[",
   "1",
   "]",
   "db",
   "=",
   "hb",
   "[",
   "1",
   "]",
   "[",
   "1",
   ":",
   "]",
   "-",
   "hb",
   "[",
   "1",
   "]",
   "[",
   ":",
   "-",
   "1",
   "]",
   "h",
   "=",
   "h",
   "/",
   "db",
   "if",
   "dohist",
   ":",
   "pylab",
   ".",
   "plot",
   "(",
   "b",
   "[",
   ":",
   "-",
   "1",
   "]",
   ",",
   "h",
   ",",
   "drawstyle",
   "=",
   "drawstyle",
   ",",
   "color",
   "=",
   "histcolor",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "#alpha -= 1",
   "elif",
   "dolog",
   ":",
   "hb",
   "=",
   "pylab",
   ".",
   "hist",
   "(",
   "x",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "logspace",
   "(",
   "log10",
   "(",
   "min",
   "(",
   "x",
   ")",
   ")",
   ",",
   "log10",
   "(",
   "max",
   "(",
   "x",
   ")",
   ")",
   ",",
   "nbins",
   ")",
   ",",
   "log",
   "=",
   "True",
   ",",
   "fill",
   "=",
   "fill",
   ",",
   "edgecolor",
   "=",
   "histcolor",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "alpha",
   "-=",
   "1",
   "h",
   ",",
   "b",
   "=",
   "hb",
   "[",
   "0",
   "]",
   ",",
   "hb",
   "[",
   "1",
   "]",
   "if",
   "not",
   "dohist",
   ":",
   "for",
   "rect",
   "in",
   "hb",
   "[",
   "2",
   "]",
   ":",
   "rect",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "else",
   ":",
   "hb",
   "=",
   "pylab",
   ".",
   "hist",
   "(",
   "x",
   ",",
   "bins",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "(",
   "min",
   "(",
   "x",
   ")",
   ")",
   ",",
   "(",
   "max",
   "(",
   "x",
   ")",
   ")",
   ",",
   "nbins",
   ")",
   ",",
   "fill",
   "=",
   "fill",
   ",",
   "edgecolor",
   "=",
   "histcolor",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "h",
   ",",
   "b",
   "=",
   "hb",
   "[",
   "0",
   "]",
   ",",
   "hb",
   "[",
   "1",
   "]",
   "if",
   "not",
   "dohist",
   ":",
   "for",
   "rect",
   "in",
   "hb",
   "[",
   "2",
   "]",
   ":",
   "rect",
   ".",
   "set_visible",
   "(",
   "False",
   ")",
   "# plotting points are at the center of each bin",
   "b",
   "=",
   "(",
   "b",
   "[",
   "1",
   ":",
   "]",
   "+",
   "b",
   "[",
   ":",
   "-",
   "1",
   "]",
   ")",
   "/",
   "2.0",
   "q",
   "=",
   "x",
   "[",
   "x",
   ">=",
   "xmin",
   "]",
   "px",
   "=",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   "*",
   "(",
   "q",
   "/",
   "xmin",
   ")",
   "**",
   "(",
   "-",
   "alpha",
   ")",
   "# Normalize by the median ratio between the histogram and the power-law",
   "# The normalization is semi-arbitrary; an average is probably just as valid",
   "plotloc",
   "=",
   "(",
   "b",
   ">",
   "xmin",
   ")",
   "*",
   "(",
   "h",
   ">",
   "0",
   ")",
   "norm",
   "=",
   "np",
   ".",
   "median",
   "(",
   "h",
   "[",
   "plotloc",
   "]",
   "/",
   "(",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   "*",
   "(",
   "b",
   "[",
   "plotloc",
   "]",
   "/",
   "xmin",
   ")",
   "**",
   "(",
   "-",
   "alpha",
   ")",
   ")",
   ")",
   "px",
   "=",
   "px",
   "*",
   "norm",
   "plotx",
   "=",
   "pylab",
   ".",
   "linspace",
   "(",
   "q",
   ".",
   "min",
   "(",
   ")",
   ",",
   "q",
   ".",
   "max",
   "(",
   ")",
   ",",
   "1000",
   ")",
   "ploty",
   "=",
   "(",
   "alpha",
   "-",
   "1",
   ")",
   "/",
   "xmin",
   "*",
   "(",
   "plotx",
   "/",
   "xmin",
   ")",
   "**",
   "(",
   "-",
   "alpha",
   ")",
   "*",
   "norm",
   "#pylab.loglog(q,px,'r',**kwargs)",
   "pylab",
   ".",
   "plot",
   "(",
   "plotx",
   ",",
   "ploty",
   ",",
   "color",
   "=",
   "plcolor",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "axlims",
   "=",
   "pylab",
   ".",
   "axis",
   "(",
   ")",
   "pylab",
   ".",
   "vlines",
   "(",
   "xmin",
   ",",
   "axlims",
   "[",
   "2",
   "]",
   ",",
   "max",
   "(",
   "px",
   ")",
   ",",
   "colors",
   "=",
   "plcolor",
   ",",
   "linestyle",
   "=",
   "'dashed'",
   ")",
   "if",
   "dolog",
   "and",
   "min",
   "(",
   "x",
   ")",
   "<=",
   "0",
   ":",
   "lolim",
   "=",
   "0.1",
   "else",
   ":",
   "lolim",
   "=",
   "min",
   "(",
   "x",
   ")",
   "pylab",
   ".",
   "gca",
   "(",
   ")",
   ".",
   "set_xlim",
   "(",
   "lolim",
   ",",
   "max",
   "(",
   "x",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1148",
  "nl_tokens": [
   "Prepare",
   "Safe",
   "creation",
   ":",
   "param",
   "owners",
   ":",
   "Owners",
   "of",
   "the",
   "Safe",
   ":",
   "param",
   "threshold",
   ":",
   "Minimum",
   "number",
   "of",
   "users",
   "required",
   "to",
   "operate",
   "the",
   "Safe",
   ":",
   "param",
   "salt_nonce",
   ":",
   "Web3",
   "instance",
   ":",
   "param",
   "gas_price",
   ":",
   "Gas",
   "Price",
   ":",
   "param",
   "payment_receiver",
   ":",
   "Address",
   "to",
   "refund",
   "when",
   "the",
   "Safe",
   "is",
   "created",
   ".",
   "Address",
   "(",
   "0",
   ")",
   "if",
   "no",
   "need",
   "to",
   "refund",
   ":",
   "param",
   "payment_token",
   ":",
   "Payment",
   "token",
   "instead",
   "of",
   "paying",
   "the",
   "funder",
   "with",
   "ether",
   ".",
   "If",
   "None",
   "Ether",
   "will",
   "be",
   "used",
   ":",
   "param",
   "payment_token_eth_value",
   ":",
   "Value",
   "of",
   "payment",
   "token",
   "per",
   "1",
   "Ether",
   ":",
   "param",
   "fixed_creation_cost",
   ":",
   "Fixed",
   "creation",
   "cost",
   "of",
   "Safe",
   "(",
   "Wei",
   ")"
  ],
  "pl_tokens": [
   "def",
   "build",
   "(",
   "self",
   ",",
   "owners",
   ":",
   "List",
   "[",
   "str",
   "]",
   ",",
   "threshold",
   ":",
   "int",
   ",",
   "salt_nonce",
   ":",
   "int",
   ",",
   "gas_price",
   ":",
   "int",
   ",",
   "payment_receiver",
   ":",
   "Optional",
   "[",
   "str",
   "]",
   "=",
   "None",
   ",",
   "payment_token",
   ":",
   "Optional",
   "[",
   "str",
   "]",
   "=",
   "None",
   ",",
   "payment_token_eth_value",
   ":",
   "float",
   "=",
   "1.0",
   ",",
   "fixed_creation_cost",
   ":",
   "Optional",
   "[",
   "int",
   "]",
   "=",
   "None",
   ")",
   ":",
   "assert",
   "0",
   "<",
   "threshold",
   "<=",
   "len",
   "(",
   "owners",
   ")",
   "payment_receiver",
   "=",
   "payment_receiver",
   "or",
   "NULL_ADDRESS",
   "payment_token",
   "=",
   "payment_token",
   "or",
   "NULL_ADDRESS",
   "assert",
   "Web3",
   ".",
   "isChecksumAddress",
   "(",
   "payment_receiver",
   ")",
   "assert",
   "Web3",
   ".",
   "isChecksumAddress",
   "(",
   "payment_token",
   ")",
   "# Get bytes for `setup(address[] calldata _owners, uint256 _threshold, address to, bytes calldata data,",
   "# address paymentToken, uint256 payment, address payable paymentReceiver)`",
   "# This initializer will be passed to the ProxyFactory to be called right after proxy is deployed",
   "# We use `payment=0` as safe has no ether yet and estimation will fail",
   "safe_setup_data",
   ":",
   "bytes",
   "=",
   "self",
   ".",
   "_get_initial_setup_safe_data",
   "(",
   "owners",
   ",",
   "threshold",
   ",",
   "payment_token",
   "=",
   "payment_token",
   ",",
   "payment_receiver",
   "=",
   "payment_receiver",
   ")",
   "magic_gas",
   ":",
   "int",
   "=",
   "self",
   ".",
   "_calculate_gas",
   "(",
   "owners",
   ",",
   "safe_setup_data",
   ",",
   "payment_token",
   ")",
   "estimated_gas",
   ":",
   "int",
   "=",
   "self",
   ".",
   "_estimate_gas",
   "(",
   "safe_setup_data",
   ",",
   "salt_nonce",
   ",",
   "payment_token",
   ",",
   "payment_receiver",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "'Magic gas %d - Estimated gas %d'",
   "%",
   "(",
   "magic_gas",
   ",",
   "estimated_gas",
   ")",
   ")",
   "gas",
   "=",
   "<mask>",
   "(",
   "magic_gas",
   ",",
   "estimated_gas",
   ")",
   "# Payment will be safe deploy cost",
   "payment",
   "=",
   "self",
   ".",
   "_calculate_refund_payment",
   "(",
   "gas",
   ",",
   "gas_price",
   ",",
   "fixed_creation_cost",
   ",",
   "payment_token_eth_value",
   ")",
   "# Now we have a estimate for `payment` so we get initialization data again",
   "safe_setup_data",
   ":",
   "bytes",
   "=",
   "self",
   ".",
   "_get_initial_setup_safe_data",
   "(",
   "owners",
   ",",
   "threshold",
   ",",
   "payment_token",
   "=",
   "payment_token",
   ",",
   "payment",
   "=",
   "payment",
   ",",
   "payment_receiver",
   "=",
   "payment_receiver",
   ")",
   "safe_address",
   "=",
   "self",
   ".",
   "calculate_create2_address",
   "(",
   "safe_setup_data",
   ",",
   "salt_nonce",
   ")",
   "assert",
   "int",
   "(",
   "safe_address",
   ",",
   "16",
   ")",
   ",",
   "'Calculated Safe address cannot be the NULL ADDRESS'",
   "return",
   "SafeCreate2Tx",
   "(",
   "salt_nonce",
   ",",
   "owners",
   ",",
   "threshold",
   ",",
   "self",
   ".",
   "master_copy_address",
   ",",
   "self",
   ".",
   "proxy_factory_address",
   ",",
   "payment_receiver",
   ",",
   "payment_token",
   ",",
   "payment",
   ",",
   "gas",
   ",",
   "gas_price",
   ",",
   "payment_token_eth_value",
   ",",
   "fixed_creation_cost",
   ",",
   "safe_address",
   ",",
   "safe_setup_data",
   ")"
  ]
 },
 {
  "idx": "maxmin-1149",
  "nl_tokens": [
   "Get",
   "the",
   "most",
   "generic",
   "data",
   "type",
   "for",
   "iterable",
   "*",
   "column",
   "*",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_column_type",
   "(",
   "self",
   ",",
   "column",
   ")",
   ":",
   "type_values",
   "=",
   "[",
   "TYPES",
   "[",
   "self",
   ".",
   "_get_type",
   "(",
   "v",
   ")",
   "]",
   "for",
   "v",
   "in",
   "column",
   "]",
   "inverse_types",
   "=",
   "{",
   "v",
   ":",
   "k",
   "for",
   "k",
   ",",
   "v",
   "in",
   "TYPES",
   ".",
   "items",
   "(",
   ")",
   "}",
   "return",
   "inverse_types",
   "[",
   "<mask>",
   "(",
   "type_values",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-1150",
  "nl_tokens": [
   "Roll",
   "up",
   "stats",
   "and",
   "log",
   "them",
   "."
  ],
  "pl_tokens": [
   "def",
   "rollup",
   "(",
   "self",
   ")",
   ":",
   "now",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "if",
   "now",
   "<",
   "self",
   ".",
   "next_rollup",
   ":",
   "return",
   "self",
   ".",
   "next_rollup",
   "=",
   "now",
   "+",
   "self",
   ".",
   "flush_interval",
   "for",
   "key",
   ",",
   "values",
   "in",
   "sorted",
   "(",
   "self",
   ".",
   "incr_stats",
   ".",
   "items",
   "(",
   ")",
   ")",
   ":",
   "self",
   ".",
   "logger",
   ".",
   "info",
   "(",
   "'%s INCR %s: count:%d|rate:%d/%d'",
   ",",
   "self",
   ".",
   "leader",
   ",",
   "key",
   ",",
   "len",
   "(",
   "values",
   ")",
   ",",
   "sum",
   "(",
   "values",
   ")",
   ",",
   "self",
   ".",
   "flush_interval",
   ")",
   "self",
   ".",
   "incr_stats",
   "[",
   "key",
   "]",
   "=",
   "[",
   "]",
   "for",
   "key",
   ",",
   "values",
   "in",
   "sorted",
   "(",
   "self",
   ".",
   "gauge_stats",
   ".",
   "items",
   "(",
   ")",
   ")",
   ":",
   "if",
   "values",
   ":",
   "self",
   ".",
   "logger",
   ".",
   "info",
   "(",
   "'%s GAUGE %s: count:%d|current:%s|min:%s|max:%s'",
   ",",
   "self",
   ".",
   "leader",
   ",",
   "key",
   ",",
   "len",
   "(",
   "values",
   ")",
   ",",
   "values",
   "[",
   "-",
   "1",
   "]",
   ",",
   "<mask>",
   "(",
   "values",
   ")",
   ",",
   "max",
   "(",
   "values",
   ")",
   ",",
   ")",
   "else",
   ":",
   "self",
   ".",
   "logger",
   ".",
   "info",
   "(",
   "'%s (gauge) %s: no data'",
   ",",
   "self",
   ".",
   "leader",
   ",",
   "key",
   ")",
   "self",
   ".",
   "gauge_stats",
   "[",
   "key",
   "]",
   "=",
   "[",
   "]",
   "for",
   "key",
   ",",
   "values",
   "in",
   "sorted",
   "(",
   "self",
   ".",
   "histogram_stats",
   ".",
   "items",
   "(",
   ")",
   ")",
   ":",
   "if",
   "values",
   ":",
   "self",
   ".",
   "logger",
   ".",
   "info",
   "(",
   "(",
   "'%s HISTOGRAM %s: '",
   "'count:%d|min:%.2f|avg:%.2f|median:%.2f|ninety-five:%.2f|max:%.2f'",
   ")",
   ",",
   "self",
   ".",
   "leader",
   ",",
   "key",
   ",",
   "len",
   "(",
   "values",
   ")",
   ",",
   "min",
   "(",
   "values",
   ")",
   ",",
   "statistics",
   ".",
   "mean",
   "(",
   "values",
   ")",
   ",",
   "statistics",
   ".",
   "median",
   "(",
   "values",
   ")",
   ",",
   "values",
   "[",
   "int",
   "(",
   "len",
   "(",
   "values",
   ")",
   "*",
   "95",
   "/",
   "100",
   ")",
   "]",
   ",",
   "max",
   "(",
   "values",
   ")",
   ")",
   "else",
   ":",
   "self",
   ".",
   "logger",
   ".",
   "info",
   "(",
   "'%s (histogram) %s: no data'",
   ",",
   "self",
   ".",
   "leader",
   ",",
   "key",
   ")",
   "self",
   ".",
   "histogram_stats",
   "[",
   "key",
   "]",
   "=",
   "[",
   "]"
  ]
 },
 {
  "idx": "maxmin-1151",
  "nl_tokens": [
   "Remove",
   "standard",
   "padding",
   "."
  ],
  "pl_tokens": [
   "def",
   "unpad",
   "(",
   "padded_data",
   ",",
   "block_size",
   ",",
   "style",
   "=",
   "'pkcs7'",
   ")",
   ":",
   "pdata_len",
   "=",
   "len",
   "(",
   "padded_data",
   ")",
   "if",
   "pdata_len",
   "%",
   "block_size",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Input data is not padded\"",
   ")",
   "if",
   "style",
   "in",
   "(",
   "'pkcs7'",
   ",",
   "'x923'",
   ")",
   ":",
   "padding_len",
   "=",
   "bord",
   "(",
   "padded_data",
   "[",
   "-",
   "1",
   "]",
   ")",
   "if",
   "padding_len",
   "<",
   "1",
   "or",
   "padding_len",
   ">",
   "<mask>",
   "(",
   "block_size",
   ",",
   "pdata_len",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Padding is incorrect.\"",
   ")",
   "if",
   "style",
   "==",
   "'pkcs7'",
   ":",
   "if",
   "padded_data",
   "[",
   "-",
   "padding_len",
   ":",
   "]",
   "!=",
   "bchr",
   "(",
   "padding_len",
   ")",
   "*",
   "padding_len",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"PKCS#7 padding is incorrect.\"",
   ")",
   "else",
   ":",
   "if",
   "padded_data",
   "[",
   "-",
   "padding_len",
   ":",
   "-",
   "1",
   "]",
   "!=",
   "bchr",
   "(",
   "0",
   ")",
   "*",
   "(",
   "padding_len",
   "-",
   "1",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"ANSI X.923 padding is incorrect.\"",
   ")",
   "elif",
   "style",
   "==",
   "'iso7816'",
   ":",
   "padding_len",
   "=",
   "pdata_len",
   "-",
   "padded_data",
   ".",
   "rfind",
   "(",
   "bchr",
   "(",
   "128",
   ")",
   ")",
   "if",
   "padding_len",
   "<",
   "1",
   "or",
   "padding_len",
   ">",
   "min",
   "(",
   "block_size",
   ",",
   "pdata_len",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Padding is incorrect.\"",
   ")",
   "if",
   "padding_len",
   ">",
   "1",
   "and",
   "padded_data",
   "[",
   "1",
   "-",
   "padding_len",
   ":",
   "]",
   "!=",
   "bchr",
   "(",
   "0",
   ")",
   "*",
   "(",
   "padding_len",
   "-",
   "1",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"ISO 7816-4 padding is incorrect.\"",
   ")",
   "else",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Unknown padding style\"",
   ")",
   "return",
   "padded_data",
   "[",
   ":",
   "-",
   "padding_len",
   "]"
  ]
 },
 {
  "idx": "maxmin-1152",
  "nl_tokens": [
   "Generates",
   "a",
   "jobs_pending",
   "progress",
   "bar",
   "widget",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_jobs_pending_widget",
   "(",
   ")",
   ":",
   "pbar",
   "=",
   "widgets",
   ".",
   "IntProgress",
   "(",
   "value",
   "=",
   "0",
   ",",
   "<mask>",
   "=",
   "0",
   ",",
   "max",
   "=",
   "50",
   ",",
   "description",
   "=",
   "''",
   ",",
   "orientation",
   "=",
   "'horizontal'",
   ",",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "max_width",
   "=",
   "'180px'",
   ")",
   ")",
   "pbar",
   ".",
   "style",
   ".",
   "bar_color",
   "=",
   "'#71cddd'",
   "pbar_current",
   "=",
   "widgets",
   ".",
   "Label",
   "(",
   "value",
   "=",
   "str",
   "(",
   "pbar",
   ".",
   "value",
   ")",
   ",",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "min_width",
   "=",
   "'auto'",
   ")",
   ")",
   "pbar_max",
   "=",
   "widgets",
   ".",
   "Label",
   "(",
   "value",
   "=",
   "str",
   "(",
   "pbar",
   ".",
   "max",
   ")",
   ",",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "min_width",
   "=",
   "'auto'",
   ")",
   ")",
   "def",
   "_on_max_change",
   "(",
   "change",
   ")",
   ":",
   "pbar_max",
   ".",
   "value",
   "=",
   "str",
   "(",
   "change",
   "[",
   "'new'",
   "]",
   ")",
   "def",
   "_on_val_change",
   "(",
   "change",
   ")",
   ":",
   "pbar_current",
   ".",
   "value",
   "=",
   "str",
   "(",
   "change",
   "[",
   "'new'",
   "]",
   ")",
   "pbar",
   ".",
   "observe",
   "(",
   "_on_max_change",
   ",",
   "names",
   "=",
   "'max'",
   ")",
   "pbar",
   ".",
   "observe",
   "(",
   "_on_val_change",
   ",",
   "names",
   "=",
   "'value'",
   ")",
   "jobs_widget",
   "=",
   "widgets",
   ".",
   "HBox",
   "(",
   "[",
   "pbar_current",
   ",",
   "pbar",
   ",",
   "pbar_max",
   "]",
   ",",
   "layout",
   "=",
   "widgets",
   ".",
   "Layout",
   "(",
   "max_width",
   "=",
   "'250px'",
   ",",
   "min_width",
   "=",
   "'250px'",
   ",",
   "justify_content",
   "=",
   "'center'",
   ")",
   ")",
   "return",
   "jobs_widget"
  ]
 },
 {
  "idx": "maxmin-1153",
  "nl_tokens": [
   "Create",
   "artificial",
   "cutoff",
   "sample",
   "points",
   "from",
   "given",
   "range",
   "of",
   "cutoff",
   "values",
   "in",
   "df",
   "number",
   "of",
   "sample",
   "points",
   "is",
   "num_cut_offs"
  ],
  "pl_tokens": [
   "def",
   "final_err_table",
   "(",
   "df",
   ",",
   "num_cut_offs",
   "=",
   "51",
   ")",
   ":",
   "cutoffs",
   "=",
   "df",
   ".",
   "cutoff",
   ".",
   "values",
   "min_",
   "=",
   "<mask>",
   "(",
   "cutoffs",
   ")",
   "max_",
   "=",
   "max",
   "(",
   "cutoffs",
   ")",
   "# extend max_ and min_ by 5 % of full range",
   "margin",
   "=",
   "(",
   "max_",
   "-",
   "min_",
   ")",
   "*",
   "0.05",
   "sampled_cutoffs",
   "=",
   "np",
   ".",
   "linspace",
   "(",
   "min_",
   "-",
   "margin",
   ",",
   "max_",
   "+",
   "margin",
   ",",
   "num_cut_offs",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float32",
   ")",
   "# find best matching row index for each sampled cut off:",
   "ix",
   "=",
   "find_nearest_matches",
   "(",
   "np",
   ".",
   "float32",
   "(",
   "df",
   ".",
   "cutoff",
   ".",
   "values",
   ")",
   ",",
   "sampled_cutoffs",
   ")",
   "# create sub dataframe:",
   "sampled_df",
   "=",
   "df",
   ".",
   "iloc",
   "[",
   "ix",
   "]",
   ".",
   "copy",
   "(",
   ")",
   "sampled_df",
   ".",
   "cutoff",
   "=",
   "sampled_cutoffs",
   "# remove 'old' index from input df:",
   "sampled_df",
   ".",
   "reset_index",
   "(",
   "inplace",
   "=",
   "True",
   ",",
   "drop",
   "=",
   "True",
   ")",
   "return",
   "sampled_df"
  ]
 },
 {
  "idx": "maxmin-1154",
  "nl_tokens": [
   "Return",
   "the",
   "most",
   "common",
   "item",
   "in",
   "the",
   "list",
   "."
  ],
  "pl_tokens": [
   "def",
   "mode",
   "(",
   "list_",
   ":",
   "List",
   "[",
   "T",
   "]",
   ")",
   "->",
   "T",
   ":",
   "return",
   "<mask>",
   "(",
   "set",
   "(",
   "list_",
   ")",
   ",",
   "key",
   "=",
   "list_",
   ".",
   "count",
   ")"
  ]
 },
 {
  "idx": "maxmin-1155",
  "nl_tokens": [
   "given",
   "a",
   "sorted",
   "data",
   "set",
   "a",
   "minimum",
   "and",
   "an",
   "alpha",
   "returns",
   "the",
   "power",
   "law",
   "ks",
   "-",
   "test",
   "D",
   "value",
   "w",
   "/",
   "data"
  ],
  "pl_tokens": [
   "def",
   "discrete_ksD",
   "(",
   "data",
   ",",
   "xmin",
   ",",
   "alpha",
   ")",
   ":",
   "zz",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "data",
   "[",
   "data",
   ">=",
   "xmin",
   "]",
   ")",
   "nn",
   "=",
   "float",
   "(",
   "len",
   "(",
   "zz",
   ")",
   ")",
   "if",
   "nn",
   "<",
   "2",
   ":",
   "return",
   "np",
   ".",
   "inf",
   "#cx = np.arange(nn,dtype='float')/float(nn)",
   "#cf = 1.0-(zz/xmin)**(1.0-alpha)",
   "model_cdf",
   "=",
   "1.0",
   "-",
   "(",
   "zz",
   ".",
   "astype",
   "(",
   "'float'",
   ")",
   "/",
   "float",
   "(",
   "xmin",
   ")",
   ")",
   "**",
   "(",
   "1.0",
   "-",
   "alpha",
   ")",
   "data_cdf",
   "=",
   "np",
   ".",
   "searchsorted",
   "(",
   "zz",
   ",",
   "zz",
   ",",
   "side",
   "=",
   "'left'",
   ")",
   "/",
   "(",
   "float",
   "(",
   "nn",
   ")",
   ")",
   "ks",
   "=",
   "<mask>",
   "(",
   "abs",
   "(",
   "model_cdf",
   "-",
   "data_cdf",
   ")",
   ")",
   "return",
   "ks"
  ]
 },
 {
  "idx": "maxmin-1156",
  "nl_tokens": [
   "List",
   "people"
  ],
  "pl_tokens": [
   "def",
   "list",
   "(",
   "self",
   ",",
   "email",
   "=",
   "None",
   ",",
   "displayName",
   "=",
   "None",
   ",",
   "id",
   "=",
   "None",
   ",",
   "orgId",
   "=",
   "None",
   ",",
   "<mask>",
   "=",
   "None",
   ",",
   "*",
   "*",
   "request_parameters",
   ")",
   ":",
   "check_type",
   "(",
   "id",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "email",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "displayName",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "orgId",
   ",",
   "basestring",
   ")",
   "check_type",
   "(",
   "max",
   ",",
   "int",
   ")",
   "params",
   "=",
   "dict_from_items_with_values",
   "(",
   "request_parameters",
   ",",
   "id",
   "=",
   "id",
   ",",
   "email",
   "=",
   "email",
   ",",
   "displayName",
   "=",
   "displayName",
   ",",
   "orgId",
   "=",
   "orgId",
   ",",
   "max",
   "=",
   "max",
   ",",
   ")",
   "# API request - get items",
   "items",
   "=",
   "self",
   ".",
   "_session",
   ".",
   "get_items",
   "(",
   "API_ENDPOINT",
   ",",
   "params",
   "=",
   "params",
   ")",
   "# Yield person objects created from the returned items JSON objects",
   "for",
   "item",
   "in",
   "items",
   ":",
   "yield",
   "self",
   ".",
   "_object_factory",
   "(",
   "OBJECT_TYPE",
   ",",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-1157",
  "nl_tokens": [
   "\u041f\u0440\u0435\u0434\u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442",
   "\u0431\u0443\u0434\u0443\u0449\u0438\u0435",
   "\u0441\u0438\u043c\u0432\u043e\u043b\u044b",
   "\u0438",
   "\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0438",
   "\u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439",
   "\u0441",
   "\u043d\u0438\u043c\u0438",
   "\u0434\u043b\u044f",
   "h",
   "-",
   "\u044d\u0432\u0440\u0438\u0441\u0442\u0438\u043a\u0438"
  ],
  "pl_tokens": [
   "def",
   "_precompute_euristics",
   "(",
   "self",
   ")",
   ":",
   "if",
   "self",
   ".",
   "euristics",
   "is",
   "None",
   ":",
   "return",
   "# \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438,",
   "# \u043f\u0440\u0438\u0432\u043e\u0434\u044f\u0449\u0435\u0439 \u043a \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044e ('+') \u0438\u043b\u0438 \u0438\u0441\u0447\u0435\u0437\u043d\u043e\u0432\u0435\u043d\u0438\u044e ('-') \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0430",
   "removal_costs",
   "=",
   "{",
   "a",
   ":",
   "np",
   ".",
   "inf",
   "for",
   "a",
   "in",
   "self",
   ".",
   "alphabet",
   "}",
   "insertion_costs",
   "=",
   "{",
   "a",
   ":",
   "np",
   ".",
   "inf",
   "for",
   "a",
   "in",
   "self",
   ".",
   "alphabet",
   "}",
   "if",
   "self",
   ".",
   "allow_spaces",
   ":",
   "removal_costs",
   "[",
   "' '",
   "]",
   "=",
   "np",
   ".",
   "inf",
   "insertion_costs",
   "[",
   "' '",
   "]",
   "=",
   "np",
   ".",
   "inf",
   "for",
   "up",
   ",",
   "costs",
   "in",
   "self",
   ".",
   "transducer",
   ".",
   "operation_costs",
   ".",
   "items",
   "(",
   ")",
   ":",
   "for",
   "low",
   ",",
   "cost",
   "in",
   "costs",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "up",
   "==",
   "low",
   ":",
   "continue",
   "if",
   "up",
   "!=",
   "''",
   ":",
   "removal_cost",
   "=",
   "cost",
   "/",
   "len",
   "(",
   "up",
   ")",
   "for",
   "a",
   "in",
   "up",
   ":",
   "removal_costs",
   "[",
   "a",
   "]",
   "=",
   "<mask>",
   "(",
   "removal_costs",
   "[",
   "a",
   "]",
   ",",
   "removal_cost",
   ")",
   "if",
   "low",
   "!=",
   "''",
   ":",
   "insertion_cost",
   "=",
   "cost",
   "/",
   "len",
   "(",
   "low",
   ")",
   "for",
   "a",
   "in",
   "low",
   ":",
   "insertion_costs",
   "[",
   "a",
   "]",
   "=",
   "min",
   "(",
   "insertion_costs",
   "[",
   "a",
   "]",
   ",",
   "insertion_cost",
   ")",
   "# \u043f\u0440\u0435\u0434\u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0445 \u0431\u0443\u0434\u0443\u0449\u0438\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0432 \u0443\u0437\u043b\u0430\u0445 \u0434\u0435\u0440\u0435\u0432\u0430",
   "# precompute_future_symbols(self.dictionary, self.euristics, self.allow_spaces)",
   "# \u043f\u0440\u0435\u0434\u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u0435\u0439 \u043f\u043e\u0442\u0435\u0440\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u0432 \u0443\u0437\u043b\u0430\u0445 \u0434\u0435\u0440\u0435\u0432\u0430",
   "self",
   ".",
   "_absense_costs_by_node",
   "=",
   "_precompute_absense_costs",
   "(",
   "self",
   ".",
   "dictionary",
   ",",
   "removal_costs",
   ",",
   "insertion_costs",
   ",",
   "self",
   ".",
   "euristics",
   ",",
   "self",
   ".",
   "allow_spaces",
   ")",
   "# \u043c\u0430\u0441\u0441\u0438\u0432 \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u044d\u0432\u0440\u0438\u0441\u0442\u0438\u043a",
   "self",
   ".",
   "_temporary_euristics",
   "=",
   "[",
   "dict",
   "(",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "self",
   ".",
   "dictionary",
   ")",
   ")",
   "]"
  ]
 },
 {
  "idx": "maxmin-1158",
  "nl_tokens": [
   "Returns",
   "total",
   "length",
   "of",
   "analysis",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_total_time_span",
   "(",
   "d",
   ")",
   ":",
   "tmax",
   "=",
   "0",
   "for",
   "di",
   "in",
   "d",
   ".",
   "values",
   "(",
   ")",
   ":",
   "if",
   "di",
   ".",
   "uTime",
   ".",
   "<mask>",
   "(",
   ")",
   ">",
   "tmax",
   ":",
   "tmax",
   "=",
   "di",
   ".",
   "uTime",
   ".",
   "max",
   "(",
   ")",
   "return",
   "tmax"
  ]
 },
 {
  "idx": "maxmin-1159",
  "nl_tokens": [
   "Squeeze",
   "trits",
   "from",
   "the",
   "sponge",
   "into",
   "a",
   "buffer",
   "."
  ],
  "pl_tokens": [
   "def",
   "squeeze",
   "(",
   "self",
   ",",
   "trits",
   ",",
   "offset",
   "=",
   "0",
   ",",
   "length",
   "=",
   "None",
   ")",
   ":",
   "# type: (MutableSequence[int], int, Optional[int]) -> None",
   "# Pad input if necessary, so that it can be divided evenly into",
   "# hashes.",
   "pad",
   "=",
   "(",
   "(",
   "len",
   "(",
   "trits",
   ")",
   "%",
   "TRIT_HASH_LENGTH",
   ")",
   "or",
   "TRIT_HASH_LENGTH",
   ")",
   "trits",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "(",
   "TRIT_HASH_LENGTH",
   "-",
   "pad",
   ")",
   "if",
   "length",
   "is",
   "None",
   ":",
   "# By default, we will try to squeeze one hash.",
   "# Note that this is different than ``absorb``.",
   "length",
   "=",
   "len",
   "(",
   "trits",
   ")",
   "or",
   "TRIT_HASH_LENGTH",
   "if",
   "length",
   "<",
   "1",
   ":",
   "raise",
   "with_context",
   "(",
   "exc",
   "=",
   "ValueError",
   "(",
   "'Invalid length passed to ``squeeze``.'",
   ")",
   ",",
   "context",
   "=",
   "{",
   "'trits'",
   ":",
   "trits",
   ",",
   "'offset'",
   ":",
   "offset",
   ",",
   "'length'",
   ":",
   "length",
   ",",
   "}",
   ",",
   ")",
   "while",
   "offset",
   "<",
   "length",
   ":",
   "unsigned_hash",
   "=",
   "self",
   ".",
   "k",
   ".",
   "digest",
   "(",
   ")",
   "if",
   "PY2",
   ":",
   "unsigned_hash",
   "=",
   "map",
   "(",
   "ord",
   ",",
   "unsigned_hash",
   ")",
   "# type: ignore",
   "signed_hash",
   "=",
   "[",
   "conv",
   ".",
   "convert_sign",
   "(",
   "b",
   ")",
   "for",
   "b",
   "in",
   "unsigned_hash",
   "]",
   "trits_from_hash",
   "=",
   "conv",
   ".",
   "convertToTrits",
   "(",
   "signed_hash",
   ")",
   "trits_from_hash",
   "[",
   "TRIT_HASH_LENGTH",
   "-",
   "1",
   "]",
   "=",
   "0",
   "stop",
   "=",
   "<mask>",
   "(",
   "TRIT_HASH_LENGTH",
   ",",
   "length",
   "-",
   "offset",
   ")",
   "trits",
   "[",
   "offset",
   ":",
   "offset",
   "+",
   "stop",
   "]",
   "=",
   "trits_from_hash",
   "[",
   "0",
   ":",
   "stop",
   "]",
   "flipped_bytes",
   "=",
   "bytearray",
   "(",
   "conv",
   ".",
   "convert_sign",
   "(",
   "~",
   "b",
   ")",
   "for",
   "b",
   "in",
   "unsigned_hash",
   ")",
   "# Reset internal state before feeding back in.",
   "self",
   ".",
   "reset",
   "(",
   ")",
   "self",
   ".",
   "k",
   ".",
   "update",
   "(",
   "flipped_bytes",
   ")",
   "offset",
   "+=",
   "TRIT_HASH_LENGTH"
  ]
 },
 {
  "idx": "maxmin-1160",
  "nl_tokens": [
   "Return",
   "best",
   "block",
   "selected",
   "based",
   "on",
   "simple",
   "heuristic",
   "."
  ],
  "pl_tokens": [
   "def",
   "select_best_block",
   "(",
   "blocks",
   ")",
   ":",
   "# TODO make this cleverer with more stats",
   "if",
   "not",
   "blocks",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"No suitable blocks were found in assembly.\"",
   ")",
   "best_block",
   "=",
   "<mask>",
   "(",
   "blocks",
   ",",
   "key",
   "=",
   "lambda",
   "b",
   ":",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'packed_instr'",
   "]",
   ")",
   "if",
   "best_block",
   "[",
   "1",
   "]",
   "[",
   "'packed_instr'",
   "]",
   "==",
   "0",
   ":",
   "best_block",
   "=",
   "max",
   "(",
   "blocks",
   ",",
   "key",
   "=",
   "lambda",
   "b",
   ":",
   "(",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'ops'",
   "]",
   "+",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'packed_instr'",
   "]",
   "+",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'avx_instr'",
   "]",
   ",",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'ZMM'",
   "]",
   ",",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'YMM'",
   "]",
   ",",
   "b",
   "[",
   "1",
   "]",
   "[",
   "'XMM'",
   "]",
   ")",
   ")",
   "return",
   "best_block",
   "[",
   "0",
   "]"
  ]
 },
 {
  "idx": "maxmin-1161",
  "nl_tokens": [
   "Executes",
   "a",
   "query",
   ".",
   "Additional",
   "query",
   "parameters",
   "can",
   "be",
   "passed",
   "as",
   "keyword",
   "arguments",
   "."
  ],
  "pl_tokens": [
   "def",
   "execute",
   "(",
   "self",
   ",",
   "offset",
   "=",
   "0",
   ",",
   "*",
   "*",
   "query",
   ")",
   ":",
   "_params",
   "=",
   "self",
   ".",
   "_build_query",
   "(",
   "*",
   "*",
   "query",
   ")",
   "self",
   ".",
   "_page_offset",
   "=",
   "offset",
   "_params",
   ".",
   "update",
   "(",
   "offset",
   "=",
   "self",
   ".",
   "_page_offset",
   ",",
   "limit",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_page_size",
   ",",
   "self",
   ".",
   "_limit",
   ")",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "'executing query. from/limit: %6d/%d'",
   "%",
   "(",
   "_params",
   "[",
   "'offset'",
   "]",
   ",",
   "_params",
   "[",
   "'limit'",
   "]",
   ")",
   ")",
   "# If the request results in a SolveError (ie bad filter) set the error.",
   "try",
   ":",
   "self",
   ".",
   "_response",
   "=",
   "self",
   ".",
   "_client",
   ".",
   "post",
   "(",
   "self",
   ".",
   "_data_url",
   ",",
   "_params",
   ")",
   "except",
   "SolveError",
   "as",
   "e",
   ":",
   "self",
   ".",
   "_error",
   "=",
   "e",
   "raise",
   "logger",
   ".",
   "debug",
   "(",
   "'query response took: %(took)d ms, total: %(total)d'",
   "%",
   "self",
   ".",
   "_response",
   ")",
   "return",
   "_params",
   ",",
   "self",
   ".",
   "_response"
  ]
 },
 {
  "idx": "maxmin-1162",
  "nl_tokens": [
   "Created",
   "to",
   "take",
   "some",
   "of",
   "the",
   "load",
   "off",
   "of",
   "_handle_weekly_repeat_out"
  ],
  "pl_tokens": [
   "def",
   "_biweekly_helper",
   "(",
   "self",
   ")",
   ":",
   "self",
   ".",
   "num",
   "=",
   "14",
   "mycount",
   "=",
   "self",
   ".",
   "repeat_biweekly",
   "(",
   ")",
   "if",
   "mycount",
   ":",
   "if",
   "self",
   ".",
   "event",
   ".",
   "is_chunk",
   "(",
   ")",
   "and",
   "<mask>",
   "(",
   "mycount",
   ")",
   "not",
   "in",
   "xrange",
   "(",
   "1",
   ",",
   "8",
   ")",
   ":",
   "mycount",
   "=",
   "_chunk_fill_out_first_week",
   "(",
   "self",
   ".",
   "year",
   ",",
   "self",
   ".",
   "month",
   ",",
   "mycount",
   ",",
   "self",
   ".",
   "event",
   ",",
   "diff",
   "=",
   "self",
   ".",
   "event",
   ".",
   "start_end_diff",
   ",",
   ")",
   "for",
   "k",
   ",",
   "v",
   "in",
   "mycount",
   ".",
   "items",
   "(",
   ")",
   ":",
   "for",
   "item",
   "in",
   "v",
   ":",
   "self",
   ".",
   "count",
   "[",
   "k",
   "]",
   ".",
   "append",
   "(",
   "item",
   ")"
  ]
 },
 {
  "idx": "maxmin-1163",
  "nl_tokens": [
   "Returns",
   "the",
   "aspect",
   "ratio",
   "of",
   "all",
   "elements",
   "."
  ],
  "pl_tokens": [
   "def",
   "edges",
   "(",
   "self",
   ",",
   "zfill",
   "=",
   "3",
   ")",
   ":",
   "edges",
   "=",
   "self",
   ".",
   "split",
   "(",
   "\"edges\"",
   ",",
   "at",
   "=",
   "\"coords\"",
   ")",
   ".",
   "unstack",
   "(",
   ")",
   "edges",
   "[",
   "\"lx\"",
   "]",
   "=",
   "edges",
   ".",
   "x",
   "[",
   "1",
   "]",
   "-",
   "edges",
   ".",
   "x",
   "[",
   "0",
   "]",
   "edges",
   "[",
   "\"ly\"",
   "]",
   "=",
   "edges",
   ".",
   "y",
   "[",
   "1",
   "]",
   "-",
   "edges",
   ".",
   "y",
   "[",
   "0",
   "]",
   "edges",
   "[",
   "\"lz\"",
   "]",
   "=",
   "edges",
   ".",
   "z",
   "[",
   "1",
   "]",
   "-",
   "edges",
   ".",
   "z",
   "[",
   "0",
   "]",
   "edges",
   "[",
   "\"l\"",
   "]",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "norm",
   "(",
   "edges",
   "[",
   "[",
   "\"lx\"",
   ",",
   "\"ly\"",
   ",",
   "\"lz\"",
   "]",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   "edges",
   "=",
   "(",
   "edges",
   ".",
   "l",
   ")",
   ".",
   "unstack",
   "(",
   ")",
   "edges",
   ".",
   "columns",
   "=",
   "pd",
   ".",
   "MultiIndex",
   ".",
   "from_product",
   "(",
   "[",
   "[",
   "\"length\"",
   "]",
   ",",
   "[",
   "\"e\"",
   "+",
   "\"{0}\"",
   ".",
   "format",
   "(",
   "s",
   ")",
   ".",
   "zfill",
   "(",
   "zfill",
   ")",
   "for",
   "s",
   "in",
   "np",
   ".",
   "arange",
   "(",
   "edges",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "]",
   "]",
   ")",
   "edges",
   "[",
   "(",
   "\"stats\"",
   ",",
   "\"lmax\"",
   ")",
   "]",
   "=",
   "edges",
   ".",
   "length",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "edges",
   "[",
   "(",
   "\"stats\"",
   ",",
   "\"lmin\"",
   ")",
   "]",
   "=",
   "edges",
   ".",
   "length",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "edges",
   "[",
   "(",
   "\"stats\"",
   ",",
   "\"aspect_ratio\"",
   ")",
   "]",
   "=",
   "edges",
   ".",
   "stats",
   ".",
   "lmax",
   "/",
   "edges",
   ".",
   "stats",
   ".",
   "lmin",
   "return",
   "edges",
   ".",
   "sort_index",
   "(",
   "axis",
   "=",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-1164",
  "nl_tokens": [
   "Plot",
   "an",
   "array",
   "of",
   "data",
   "on",
   "a",
   "map",
   "using",
   "matplotlib",
   "and",
   "Basemap",
   "automatically",
   "matching",
   "the",
   "data",
   "to",
   "the",
   "Pandana",
   "network",
   "node",
   "positions",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot",
   "(",
   "self",
   ",",
   "data",
   ",",
   "bbox",
   "=",
   "None",
   ",",
   "plot_type",
   "=",
   "'scatter'",
   ",",
   "fig_kwargs",
   "=",
   "None",
   ",",
   "bmap_kwargs",
   "=",
   "None",
   ",",
   "plot_kwargs",
   "=",
   "None",
   ",",
   "cbar_kwargs",
   "=",
   "None",
   ")",
   ":",
   "from",
   "mpl_toolkits",
   ".",
   "basemap",
   "import",
   "Basemap",
   "fig_kwargs",
   "=",
   "fig_kwargs",
   "or",
   "{",
   "}",
   "bmap_kwargs",
   "=",
   "bmap_kwargs",
   "or",
   "{",
   "}",
   "plot_kwargs",
   "=",
   "plot_kwargs",
   "or",
   "{",
   "}",
   "cbar_kwargs",
   "=",
   "cbar_kwargs",
   "or",
   "{",
   "}",
   "if",
   "not",
   "bbox",
   ":",
   "bbox",
   "=",
   "(",
   "self",
   ".",
   "nodes_df",
   ".",
   "y",
   ".",
   "<mask>",
   "(",
   ")",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "x",
   ".",
   "min",
   "(",
   ")",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "y",
   ".",
   "max",
   "(",
   ")",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "x",
   ".",
   "max",
   "(",
   ")",
   ")",
   "fig",
   ",",
   "ax",
   "=",
   "plt",
   ".",
   "subplots",
   "(",
   "*",
   "*",
   "fig_kwargs",
   ")",
   "bmap",
   "=",
   "Basemap",
   "(",
   "bbox",
   "[",
   "1",
   "]",
   ",",
   "bbox",
   "[",
   "0",
   "]",
   ",",
   "bbox",
   "[",
   "3",
   "]",
   ",",
   "bbox",
   "[",
   "2",
   "]",
   ",",
   "ax",
   "=",
   "ax",
   ",",
   "*",
   "*",
   "bmap_kwargs",
   ")",
   "bmap",
   ".",
   "drawcoastlines",
   "(",
   ")",
   "bmap",
   ".",
   "drawmapboundary",
   "(",
   ")",
   "x",
   ",",
   "y",
   "=",
   "bmap",
   "(",
   "self",
   ".",
   "nodes_df",
   ".",
   "x",
   ".",
   "values",
   ",",
   "self",
   ".",
   "nodes_df",
   ".",
   "y",
   ".",
   "values",
   ")",
   "if",
   "plot_type",
   "==",
   "'scatter'",
   ":",
   "plot",
   "=",
   "bmap",
   ".",
   "scatter",
   "(",
   "x",
   ",",
   "y",
   ",",
   "c",
   "=",
   "data",
   ".",
   "values",
   ",",
   "*",
   "*",
   "plot_kwargs",
   ")",
   "elif",
   "plot_type",
   "==",
   "'hexbin'",
   ":",
   "plot",
   "=",
   "bmap",
   ".",
   "hexbin",
   "(",
   "x",
   ",",
   "y",
   ",",
   "C",
   "=",
   "data",
   ".",
   "values",
   ",",
   "*",
   "*",
   "plot_kwargs",
   ")",
   "bmap",
   ".",
   "colorbar",
   "(",
   "plot",
   ",",
   "*",
   "*",
   "cbar_kwargs",
   ")",
   "return",
   "bmap",
   ",",
   "fig",
   ",",
   "ax"
  ]
 },
 {
  "idx": "maxmin-1165",
  "nl_tokens": [
   "This",
   "function",
   "performs",
   "a",
   "check",
   "for",
   "different",
   "number",
   "of",
   "(",
   "and",
   ")",
   "characters",
   "which",
   "indicates",
   "that",
   "some",
   "forks",
   "are",
   "poorly",
   "constructed",
   "."
  ],
  "pl_tokens": [
   "def",
   "brackets_insanity_check",
   "(",
   "p_string",
   ")",
   ":",
   "if",
   "p_string",
   ".",
   "count",
   "(",
   "FORK_TOKEN",
   ")",
   "!=",
   "p_string",
   ".",
   "count",
   "(",
   "CLOSE_TOKEN",
   ")",
   ":",
   "# get the number of each type of bracket and state the one that has a",
   "# higher value",
   "dict_values",
   "=",
   "{",
   "FORK_TOKEN",
   ":",
   "p_string",
   ".",
   "count",
   "(",
   "FORK_TOKEN",
   ")",
   ",",
   "CLOSE_TOKEN",
   ":",
   "p_string",
   ".",
   "count",
   "(",
   "CLOSE_TOKEN",
   ")",
   "}",
   "max_bracket",
   "=",
   "<mask>",
   "(",
   "dict_values",
   ",",
   "key",
   "=",
   "dict_values",
   ".",
   "get",
   ")",
   "raise",
   "SanityError",
   "(",
   "\"A different number of '(' and ')' was specified. There are \"",
   "\"{} extra '{}'. The number of '(' and ')'should be equal.\"",
   ".",
   "format",
   "(",
   "str",
   "(",
   "abs",
   "(",
   "p_string",
   ".",
   "count",
   "(",
   "FORK_TOKEN",
   ")",
   "-",
   "p_string",
   ".",
   "count",
   "(",
   "CLOSE_TOKEN",
   ")",
   ")",
   ")",
   ",",
   "max_bracket",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1166",
  "nl_tokens": [
   "Apply",
   "layer",
   "condition",
   "model",
   "to",
   "calculate",
   "cache",
   "accesses",
   "."
  ],
  "pl_tokens": [
   "def",
   "calculate_cache_access",
   "(",
   "self",
   ")",
   ":",
   "# FIXME handle multiple datatypes",
   "element_size",
   "=",
   "self",
   ".",
   "kernel",
   ".",
   "datatypes_size",
   "[",
   "self",
   ".",
   "kernel",
   ".",
   "datatype",
   "]",
   "results",
   "=",
   "{",
   "'dimensions'",
   ":",
   "{",
   "}",
   "}",
   "def",
   "sympy_compare",
   "(",
   "a",
   ",",
   "b",
   ")",
   ":",
   "c",
   "=",
   "0",
   "for",
   "i",
   "in",
   "range",
   "(",
   "<mask>",
   "(",
   "len",
   "(",
   "a",
   ")",
   ",",
   "len",
   "(",
   "b",
   ")",
   ")",
   ")",
   ":",
   "s",
   "=",
   "a",
   "[",
   "i",
   "]",
   "-",
   "b",
   "[",
   "i",
   "]",
   "if",
   "sympy",
   ".",
   "simplify",
   "(",
   "s",
   ">",
   "0",
   ")",
   ":",
   "c",
   "=",
   "-",
   "1",
   "elif",
   "sympy",
   ".",
   "simplify",
   "(",
   "s",
   "==",
   "0",
   ")",
   ":",
   "c",
   "=",
   "0",
   "else",
   ":",
   "c",
   "=",
   "1",
   "if",
   "c",
   "!=",
   "0",
   ":",
   "break",
   "return",
   "c",
   "accesses",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "sympy_accesses",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "for",
   "var_name",
   "in",
   "self",
   ".",
   "kernel",
   ".",
   "variables",
   ":",
   "for",
   "r",
   "in",
   "self",
   ".",
   "kernel",
   ".",
   "sources",
   ".",
   "get",
   "(",
   "var_name",
   ",",
   "[",
   "]",
   ")",
   ":",
   "if",
   "r",
   "is",
   "None",
   ":",
   "continue",
   "accesses",
   "[",
   "var_name",
   "]",
   ".",
   "append",
   "(",
   "r",
   ")",
   "sympy_accesses",
   "[",
   "var_name",
   "]",
   ".",
   "append",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "access_to_sympy",
   "(",
   "var_name",
   ",",
   "r",
   ")",
   ")",
   "for",
   "w",
   "in",
   "self",
   ".",
   "kernel",
   ".",
   "destinations",
   ".",
   "get",
   "(",
   "var_name",
   ",",
   "[",
   "]",
   ")",
   ":",
   "if",
   "w",
   "is",
   "None",
   ":",
   "continue",
   "accesses",
   "[",
   "var_name",
   "]",
   ".",
   "append",
   "(",
   "w",
   ")",
   "sympy_accesses",
   "[",
   "var_name",
   "]",
   ".",
   "append",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "access_to_sympy",
   "(",
   "var_name",
   ",",
   "w",
   ")",
   ")",
   "# order accesses by increasing order",
   "accesses",
   "[",
   "var_name",
   "]",
   ".",
   "sort",
   "(",
   "key",
   "=",
   "cmp_to_key",
   "(",
   "sympy_compare",
   ")",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   "results",
   "[",
   "'accesses'",
   "]",
   "=",
   "accesses",
   "results",
   "[",
   "'sympy_accesses'",
   "]",
   "=",
   "sympy_accesses",
   "# For each dimension (1D, 2D, 3D ... nD)",
   "for",
   "dimension",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "list",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "get_loop_stack",
   "(",
   ")",
   ")",
   ")",
   "+",
   "1",
   ")",
   ":",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "=",
   "{",
   "}",
   "slices",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "slices_accesses",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "for",
   "var_name",
   "in",
   "accesses",
   ":",
   "for",
   "a",
   "in",
   "accesses",
   "[",
   "var_name",
   "]",
   ":",
   "# slices are identified by the tuple of indices of higher dimensions",
   "slice_id",
   "=",
   "tuple",
   "(",
   "[",
   "var_name",
   ",",
   "tuple",
   "(",
   "a",
   "[",
   ":",
   "-",
   "dimension",
   "]",
   ")",
   "]",
   ")",
   "slices",
   "[",
   "slice_id",
   "]",
   ".",
   "append",
   "(",
   "a",
   ")",
   "slices_accesses",
   "[",
   "slice_id",
   "]",
   ".",
   "append",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "access_to_sympy",
   "(",
   "var_name",
   ",",
   "a",
   ")",
   ")",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'slices'",
   "]",
   "=",
   "slices",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'slices_accesses'",
   "]",
   "=",
   "slices_accesses",
   "slices_distances",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "for",
   "k",
   ",",
   "v",
   "in",
   "slices_accesses",
   ".",
   "items",
   "(",
   ")",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "len",
   "(",
   "v",
   ")",
   ")",
   ":",
   "slices_distances",
   "[",
   "k",
   "]",
   ".",
   "append",
   "(",
   "(",
   "v",
   "[",
   "i",
   "]",
   "-",
   "v",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   ".",
   "simplify",
   "(",
   ")",
   ")",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'slices_distances'",
   "]",
   "=",
   "slices_distances",
   "# Check that distances contain only free_symbols based on constants",
   "for",
   "dist",
   "in",
   "chain",
   "(",
   "*",
   "slices_distances",
   ".",
   "values",
   "(",
   ")",
   ")",
   ":",
   "if",
   "any",
   "(",
   "[",
   "s",
   "not",
   "in",
   "self",
   ".",
   "kernel",
   ".",
   "constants",
   ".",
   "keys",
   "(",
   ")",
   "for",
   "s",
   "in",
   "dist",
   ".",
   "free_symbols",
   "]",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"Some distances are not based on constants: \"",
   "+",
   "str",
   "(",
   "dist",
   ")",
   ")",
   "# Sum of lengths between relative distances",
   "slices_sum",
   "=",
   "sum",
   "(",
   "[",
   "sum",
   "(",
   "dists",
   ")",
   "for",
   "dists",
   "in",
   "slices_distances",
   ".",
   "values",
   "(",
   ")",
   "]",
   ")",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'slices_sum'",
   "]",
   "=",
   "slices_sum",
   "# Max of lengths between relative distances",
   "# Work-around, the arguments with the most symbols get to stay",
   "# FIXME, may not be correct in all cases. e.g., N+M vs. N*M",
   "def",
   "FuckedUpMax",
   "(",
   "*",
   "args",
   ")",
   ":",
   "if",
   "len",
   "(",
   "args",
   ")",
   "==",
   "1",
   ":",
   "return",
   "args",
   "[",
   "0",
   "]",
   "# expand all expressions:",
   "args",
   "=",
   "[",
   "a",
   ".",
   "expand",
   "(",
   ")",
   "for",
   "a",
   "in",
   "args",
   "]",
   "# Filter expressions with less than the maximum number of symbols",
   "max_symbols",
   "=",
   "max",
   "(",
   "[",
   "len",
   "(",
   "a",
   ".",
   "free_symbols",
   ")",
   "for",
   "a",
   "in",
   "args",
   "]",
   ")",
   "args",
   "=",
   "list",
   "(",
   "filter",
   "(",
   "lambda",
   "a",
   ":",
   "len",
   "(",
   "a",
   ".",
   "free_symbols",
   ")",
   "==",
   "max_symbols",
   ",",
   "args",
   ")",
   ")",
   "if",
   "max_symbols",
   "==",
   "0",
   ":",
   "return",
   "sympy",
   ".",
   "Max",
   "(",
   "*",
   "args",
   ")",
   "# Filter symbols with lower exponent",
   "max_coeffs",
   "=",
   "0",
   "for",
   "a",
   "in",
   "args",
   ":",
   "for",
   "s",
   "in",
   "a",
   ".",
   "free_symbols",
   ":",
   "max_coeffs",
   "=",
   "max",
   "(",
   "max_coeffs",
   ",",
   "len",
   "(",
   "sympy",
   ".",
   "Poly",
   "(",
   "a",
   ",",
   "s",
   ")",
   ".",
   "all_coeffs",
   "(",
   ")",
   ")",
   ")",
   "def",
   "coeff_filter",
   "(",
   "a",
   ")",
   ":",
   "return",
   "max",
   "(",
   "0",
   ",",
   "0",
   ",",
   "*",
   "[",
   "len",
   "(",
   "sympy",
   ".",
   "Poly",
   "(",
   "a",
   ",",
   "s",
   ")",
   ".",
   "all_coeffs",
   "(",
   ")",
   ")",
   "for",
   "s",
   "in",
   "a",
   ".",
   "free_symbols",
   "]",
   ")",
   "==",
   "max_coeffs",
   "args",
   "=",
   "list",
   "(",
   "filter",
   "(",
   "coeff_filter",
   ",",
   "args",
   ")",
   ")",
   "m",
   "=",
   "sympy",
   ".",
   "Max",
   "(",
   "*",
   "args",
   ")",
   "# if m.is_Function:",
   "#     raise ValueError(\"Could not resolve {} to maximum.\".format(m))",
   "return",
   "m",
   "slices_max",
   "=",
   "FuckedUpMax",
   "(",
   "sympy",
   ".",
   "Integer",
   "(",
   "0",
   ")",
   ",",
   "*",
   "[",
   "FuckedUpMax",
   "(",
   "*",
   "dists",
   ")",
   "for",
   "dists",
   "in",
   "slices_distances",
   ".",
   "values",
   "(",
   ")",
   "]",
   ")",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'slices_max'",
   "]",
   "=",
   "slices_max",
   "# Nmber of slices",
   "slices_count",
   "=",
   "len",
   "(",
   "slices_accesses",
   ")",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'slices_count'",
   "]",
   "=",
   "slices_count",
   "# Cache requirement expression",
   "cache_requirement_bytes",
   "=",
   "(",
   "slices_sum",
   "+",
   "slices_max",
   "*",
   "slices_count",
   ")",
   "*",
   "element_size",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'cache_requirement_bytes'",
   "]",
   "=",
   "cache_requirement_bytes",
   "# Apply to all cache sizes",
   "csim",
   "=",
   "self",
   ".",
   "machine",
   ".",
   "get_cachesim",
   "(",
   "self",
   ".",
   "_args",
   ".",
   "cores",
   ")",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'caches'",
   "]",
   "=",
   "{",
   "}",
   "for",
   "cl",
   "in",
   "csim",
   ".",
   "levels",
   "(",
   "with_mem",
   "=",
   "False",
   ")",
   ":",
   "cache_equation",
   "=",
   "sympy",
   ".",
   "Eq",
   "(",
   "cache_requirement_bytes",
   ",",
   "cl",
   ".",
   "size",
   "(",
   ")",
   ")",
   "if",
   "len",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "constants",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "<=",
   "1",
   ":",
   "inequality",
   "=",
   "sympy",
   ".",
   "solve",
   "(",
   "sympy",
   ".",
   "LessThan",
   "(",
   "cache_requirement_bytes",
   ",",
   "cl",
   ".",
   "size",
   "(",
   ")",
   ")",
   ",",
   "*",
   "self",
   ".",
   "kernel",
   ".",
   "constants",
   ".",
   "keys",
   "(",
   ")",
   ")",
   "else",
   ":",
   "# Sympy does not solve for multiple constants",
   "inequality",
   "=",
   "sympy",
   ".",
   "LessThan",
   "(",
   "cache_requirement_bytes",
   ",",
   "cl",
   ".",
   "size",
   "(",
   ")",
   ")",
   "try",
   ":",
   "eq",
   "=",
   "sympy",
   ".",
   "solve",
   "(",
   "inequality",
   ",",
   "*",
   "self",
   ".",
   "kernel",
   ".",
   "constants",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "dict",
   "=",
   "True",
   ")",
   "except",
   "NotImplementedError",
   ":",
   "eq",
   "=",
   "None",
   "results",
   "[",
   "'dimensions'",
   "]",
   "[",
   "dimension",
   "]",
   "[",
   "'caches'",
   "]",
   "[",
   "cl",
   ".",
   "name",
   "]",
   "=",
   "{",
   "'cache_size'",
   ":",
   "cl",
   ".",
   "size",
   "(",
   ")",
   ",",
   "'equation'",
   ":",
   "cache_equation",
   ",",
   "'lt'",
   ":",
   "inequality",
   ",",
   "'eq'",
   ":",
   "eq",
   "}",
   "return",
   "results"
  ]
 },
 {
  "idx": "maxmin-1167",
  "nl_tokens": [
   "Main",
   "function",
   "to",
   "compute",
   "the",
   "segment",
   "similarity",
   "of",
   "file",
   "file_struct",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_similarity",
   "(",
   "F",
   ",",
   "bound_idxs",
   ",",
   "dirichlet",
   "=",
   "False",
   ",",
   "xmeans",
   "=",
   "False",
   ",",
   "k",
   "=",
   "5",
   ",",
   "offset",
   "=",
   "4",
   ")",
   ":",
   "# Get the feature segments",
   "feat_segments",
   "=",
   "get_feat_segments",
   "(",
   "F",
   ",",
   "bound_idxs",
   ")",
   "# Get the 2D-FMCs segments",
   "fmcs",
   "=",
   "feat_segments_to_2dfmc_max",
   "(",
   "feat_segments",
   ",",
   "offset",
   ")",
   "if",
   "len",
   "(",
   "fmcs",
   ")",
   "==",
   "0",
   ":",
   "return",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "bound_idxs",
   ")",
   "-",
   "1",
   ")",
   "# Compute the labels using kmeans",
   "if",
   "dirichlet",
   ":",
   "k_init",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "fmcs",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "k",
   "]",
   ")",
   "# Only compute the dirichlet method if the fmc shape is small enough",
   "if",
   "fmcs",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ">",
   "500",
   ":",
   "labels_est",
   "=",
   "compute_labels_kmeans",
   "(",
   "fmcs",
   ",",
   "k",
   "=",
   "k",
   ")",
   "else",
   ":",
   "dpgmm",
   "=",
   "mixture",
   ".",
   "DPGMM",
   "(",
   "n_components",
   "=",
   "k_init",
   ",",
   "covariance_type",
   "=",
   "'full'",
   ")",
   "# dpgmm = mixture.VBGMM(n_components=k_init, covariance_type='full')",
   "dpgmm",
   ".",
   "fit",
   "(",
   "fmcs",
   ")",
   "k",
   "=",
   "len",
   "(",
   "dpgmm",
   ".",
   "means_",
   ")",
   "labels_est",
   "=",
   "dpgmm",
   ".",
   "predict",
   "(",
   "fmcs",
   ")",
   "# print(\"Estimated with Dirichlet Process:\", k)",
   "if",
   "xmeans",
   ":",
   "xm",
   "=",
   "XMeans",
   "(",
   "fmcs",
   ",",
   "plot",
   "=",
   "False",
   ")",
   "k",
   "=",
   "xm",
   ".",
   "estimate_K_knee",
   "(",
   "th",
   "=",
   "0.01",
   ",",
   "maxK",
   "=",
   "8",
   ")",
   "labels_est",
   "=",
   "compute_labels_kmeans",
   "(",
   "fmcs",
   ",",
   "k",
   "=",
   "k",
   ")",
   "# print(\"Estimated with Xmeans:\", k)",
   "else",
   ":",
   "labels_est",
   "=",
   "compute_labels_kmeans",
   "(",
   "fmcs",
   ",",
   "k",
   "=",
   "k",
   ")",
   "return",
   "labels_est"
  ]
 },
 {
  "idx": "maxmin-1168",
  "nl_tokens": [
   "Receive",
   "data",
   "on",
   "the",
   "connection",
   "and",
   "copy",
   "it",
   "directly",
   "into",
   "the",
   "provided",
   "buffer",
   "rather",
   "than",
   "creating",
   "a",
   "new",
   "string",
   "."
  ],
  "pl_tokens": [
   "def",
   "recv_into",
   "(",
   "self",
   ",",
   "buffer",
   ",",
   "nbytes",
   "=",
   "None",
   ",",
   "flags",
   "=",
   "None",
   ")",
   ":",
   "if",
   "nbytes",
   "is",
   "None",
   ":",
   "nbytes",
   "=",
   "len",
   "(",
   "buffer",
   ")",
   "else",
   ":",
   "nbytes",
   "=",
   "<mask>",
   "(",
   "nbytes",
   ",",
   "len",
   "(",
   "buffer",
   ")",
   ")",
   "# We need to create a temporary buffer. This is annoying, it would be",
   "# better if we could pass memoryviews straight into the SSL_read call,",
   "# but right now we can't. Revisit this if CFFI gets that ability.",
   "buf",
   "=",
   "_no_zero_allocator",
   "(",
   "\"char[]\"",
   ",",
   "nbytes",
   ")",
   "if",
   "flags",
   "is",
   "not",
   "None",
   "and",
   "flags",
   "&",
   "socket",
   ".",
   "MSG_PEEK",
   ":",
   "result",
   "=",
   "_lib",
   ".",
   "SSL_peek",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "buf",
   ",",
   "nbytes",
   ")",
   "else",
   ":",
   "result",
   "=",
   "_lib",
   ".",
   "SSL_read",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "buf",
   ",",
   "nbytes",
   ")",
   "self",
   ".",
   "_raise_ssl_error",
   "(",
   "self",
   ".",
   "_ssl",
   ",",
   "result",
   ")",
   "# This strange line is all to avoid a memory copy. The buffer protocol",
   "# should allow us to assign a CFFI buffer to the LHS of this line, but",
   "# on CPython 3.3+ that segfaults. As a workaround, we can temporarily",
   "# wrap it in a memoryview.",
   "buffer",
   "[",
   ":",
   "result",
   "]",
   "=",
   "memoryview",
   "(",
   "_ffi",
   ".",
   "buffer",
   "(",
   "buf",
   ",",
   "result",
   ")",
   ")",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-1169",
  "nl_tokens": [
   "Run",
   "complete",
   "analysis",
   "and",
   "return",
   "results",
   "."
  ],
  "pl_tokens": [
   "def",
   "analyze",
   "(",
   "self",
   ")",
   ":",
   "try",
   ":",
   "incore_analysis",
   ",",
   "asm_block",
   "=",
   "self",
   ".",
   "kernel",
   ".",
   "iaca_analysis",
   "(",
   "micro_architecture",
   "=",
   "self",
   ".",
   "machine",
   "[",
   "'micro-architecture'",
   "]",
   ",",
   "asm_block",
   "=",
   "self",
   ".",
   "asm_block",
   ",",
   "pointer_increment",
   "=",
   "self",
   ".",
   "pointer_increment",
   ",",
   "verbose",
   "=",
   "self",
   ".",
   "verbose",
   ">",
   "2",
   ")",
   "except",
   "RuntimeError",
   "as",
   "e",
   ":",
   "print",
   "(",
   "\"IACA analysis failed: \"",
   "+",
   "str",
   "(",
   "e",
   ")",
   ")",
   "sys",
   ".",
   "exit",
   "(",
   "1",
   ")",
   "block_throughput",
   "=",
   "incore_analysis",
   "[",
   "'throughput'",
   "]",
   "port_cycles",
   "=",
   "incore_analysis",
   "[",
   "'port cycles'",
   "]",
   "uops",
   "=",
   "incore_analysis",
   "[",
   "'uops'",
   "]",
   "# Normalize to cycles per cacheline",
   "elements_per_block",
   "=",
   "abs",
   "(",
   "asm_block",
   "[",
   "'pointer_increment'",
   "]",
   "//",
   "self",
   ".",
   "kernel",
   ".",
   "datatypes_size",
   "[",
   "self",
   ".",
   "kernel",
   ".",
   "datatype",
   "]",
   ")",
   "block_size",
   "=",
   "elements_per_block",
   "*",
   "self",
   ".",
   "kernel",
   ".",
   "datatypes_size",
   "[",
   "self",
   ".",
   "kernel",
   ".",
   "datatype",
   "]",
   "try",
   ":",
   "block_to_cl_ratio",
   "=",
   "float",
   "(",
   "self",
   ".",
   "machine",
   "[",
   "'cacheline size'",
   "]",
   ")",
   "/",
   "block_size",
   "except",
   "ZeroDivisionError",
   "as",
   "e",
   ":",
   "print",
   "(",
   "\"Too small block_size / pointer_increment:\"",
   ",",
   "e",
   ",",
   "file",
   "=",
   "sys",
   ".",
   "stderr",
   ")",
   "sys",
   ".",
   "exit",
   "(",
   "1",
   ")",
   "port_cycles",
   "=",
   "dict",
   "(",
   "[",
   "(",
   "i",
   "[",
   "0",
   "]",
   ",",
   "i",
   "[",
   "1",
   "]",
   "*",
   "block_to_cl_ratio",
   ")",
   "for",
   "i",
   "in",
   "list",
   "(",
   "port_cycles",
   ".",
   "items",
   "(",
   ")",
   ")",
   "]",
   ")",
   "uops",
   "=",
   "uops",
   "*",
   "block_to_cl_ratio",
   "cl_throughput",
   "=",
   "block_throughput",
   "*",
   "block_to_cl_ratio",
   "# Compile most relevant information",
   "T_OL",
   "=",
   "<mask>",
   "(",
   "[",
   "v",
   "for",
   "k",
   ",",
   "v",
   "in",
   "list",
   "(",
   "port_cycles",
   ".",
   "items",
   "(",
   ")",
   ")",
   "if",
   "k",
   "in",
   "self",
   ".",
   "machine",
   "[",
   "'overlapping model'",
   "]",
   "[",
   "'ports'",
   "]",
   "]",
   ")",
   "T_nOL",
   "=",
   "max",
   "(",
   "[",
   "v",
   "for",
   "k",
   ",",
   "v",
   "in",
   "list",
   "(",
   "port_cycles",
   ".",
   "items",
   "(",
   ")",
   ")",
   "if",
   "k",
   "in",
   "self",
   ".",
   "machine",
   "[",
   "'non-overlapping model'",
   "]",
   "[",
   "'ports'",
   "]",
   "]",
   ")",
   "# Use IACA throughput prediction if it is slower then T_nOL",
   "if",
   "T_nOL",
   "<",
   "cl_throughput",
   ":",
   "T_OL",
   "=",
   "cl_throughput",
   "# Create result dictionary",
   "self",
   ".",
   "results",
   "=",
   "{",
   "'port cycles'",
   ":",
   "port_cycles",
   ",",
   "'cl throughput'",
   ":",
   "self",
   ".",
   "conv_cy",
   "(",
   "cl_throughput",
   ")",
   ",",
   "'uops'",
   ":",
   "uops",
   ",",
   "'T_nOL'",
   ":",
   "T_nOL",
   ",",
   "'T_OL'",
   ":",
   "T_OL",
   ",",
   "'IACA output'",
   ":",
   "incore_analysis",
   "[",
   "'output'",
   "]",
   ",",
   "'elements_per_block'",
   ":",
   "elements_per_block",
   ",",
   "'pointer_increment'",
   ":",
   "asm_block",
   "[",
   "'pointer_increment'",
   "]",
   ",",
   "'flops per iteration'",
   ":",
   "sum",
   "(",
   "self",
   ".",
   "kernel",
   ".",
   "_flops",
   ".",
   "values",
   "(",
   ")",
   ")",
   "}",
   "return",
   "self",
   ".",
   "results"
  ]
 },
 {
  "idx": "maxmin-1170",
  "nl_tokens": [
   "Iterates",
   "over",
   "the",
   "iter_content",
   "and",
   "draws",
   "a",
   "progress",
   "bar",
   "to",
   "stdout",
   "."
  ],
  "pl_tokens": [
   "def",
   "bar",
   "(",
   "iter_content",
   ",",
   "parts",
   ",",
   "title",
   "=",
   "''",
   ")",
   ":",
   "parts",
   "=",
   "<mask>",
   "(",
   "float",
   "(",
   "parts",
   ")",
   ",",
   "1.0",
   ")",
   "cells",
   "=",
   "10",
   "progress",
   "=",
   "0",
   "step",
   "=",
   "cells",
   "/",
   "parts",
   "draw",
   "=",
   "lambda",
   "progress",
   ":",
   "sys",
   ".",
   "stdout",
   ".",
   "write",
   "(",
   "'\\r[{0:10}] {1:.2f}% {2}'",
   ".",
   "format",
   "(",
   "'#'",
   "*",
   "int",
   "(",
   "progress",
   ")",
   ",",
   "progress",
   "*",
   "cells",
   ",",
   "title",
   ")",
   ")",
   "for",
   "chunk",
   "in",
   "iter_content",
   ":",
   "yield",
   "chunk",
   "progress",
   "+=",
   "step",
   "draw",
   "(",
   "progress",
   ")",
   "sys",
   ".",
   "stdout",
   ".",
   "flush",
   "(",
   ")",
   "draw",
   "(",
   "cells",
   ")",
   "print",
   "(",
   "''",
   ")"
  ]
 },
 {
  "idx": "maxmin-1171",
  "nl_tokens": [
   "\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442",
   "\u0432\u0441\u0435",
   "\u0442\u0440\u0430\u043d\u0441\u0434\u0443\u043a\u0446\u0438\u0438",
   "\u0441",
   "\u0432\u0435\u0440\u0445\u043d\u0438\u043c",
   "\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u043c",
   "word",
   "\u0447\u044c\u044f",
   "\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c",
   "\u043d\u0435",
   "\u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0435\u0442",
   "max_cost"
  ],
  "pl_tokens": [
   "def",
   "lower_transductions",
   "(",
   "self",
   ",",
   "word",
   ",",
   "max_cost",
   ",",
   "return_cost",
   "=",
   "True",
   ")",
   ":",
   "prefixes",
   "=",
   "[",
   "[",
   "]",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "word",
   ")",
   "+",
   "1",
   ")",
   "]",
   "prefixes",
   "[",
   "0",
   "]",
   ".",
   "append",
   "(",
   "(",
   "(",
   ")",
   ",",
   "0.0",
   ")",
   ")",
   "for",
   "pos",
   "in",
   "range",
   "(",
   "len",
   "(",
   "prefixes",
   ")",
   ")",
   ":",
   "# \u0432\u0441\u0442\u0430\u0432\u043a\u0438",
   "prefixes",
   "[",
   "pos",
   "]",
   "=",
   "self",
   ".",
   "_perform_insertions",
   "(",
   "prefixes",
   "[",
   "pos",
   "]",
   ",",
   "max_cost",
   ")",
   "max_upperside_length",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "word",
   ")",
   "-",
   "pos",
   ",",
   "self",
   ".",
   "max_up_length",
   ")",
   "for",
   "upperside_length",
   "in",
   "range",
   "(",
   "1",
   ",",
   "max_upperside_length",
   "+",
   "1",
   ")",
   ":",
   "up",
   "=",
   "word",
   "[",
   "pos",
   ":",
   "pos",
   "+",
   "upperside_length",
   "]",
   "for",
   "low",
   ",",
   "low_cost",
   "in",
   "self",
   ".",
   "operation_costs",
   ".",
   "get",
   "(",
   "up",
   ",",
   "dict",
   "(",
   ")",
   ")",
   ".",
   "items",
   "(",
   ")",
   ":",
   "for",
   "transduction",
   ",",
   "cost",
   "in",
   "prefixes",
   "[",
   "pos",
   "]",
   ":",
   "new_cost",
   "=",
   "cost",
   "+",
   "low_cost",
   "if",
   "new_cost",
   "<=",
   "max_cost",
   ":",
   "new_transduction",
   "=",
   "transduction",
   "+",
   "(",
   "up",
   ",",
   "low",
   ")",
   "prefixes",
   "[",
   "pos",
   "+",
   "upperside_length",
   "]",
   ".",
   "append",
   "(",
   "(",
   "new_transduction",
   ",",
   "new_cost",
   ")",
   ")",
   "answer",
   "=",
   "sorted",
   "(",
   "prefixes",
   "[",
   "-",
   "1",
   "]",
   ",",
   "key",
   "=",
   "(",
   "lambda",
   "x",
   ":",
   "x",
   "[",
   "0",
   "]",
   ")",
   ")",
   "if",
   "return_cost",
   ":",
   "return",
   "answer",
   "else",
   ":",
   "return",
   "[",
   "elem",
   "[",
   "0",
   "]",
   "for",
   "elem",
   "in",
   "answer",
   "]"
  ]
 },
 {
  "idx": "maxmin-1172",
  "nl_tokens": [
   "Get",
   "the",
   "last",
   "beat",
   "from",
   "the",
   "cumulative",
   "score",
   "array"
  ],
  "pl_tokens": [
   "def",
   "__last_beat",
   "(",
   "cumscore",
   ")",
   ":",
   "maxes",
   "=",
   "util",
   ".",
   "localmax",
   "(",
   "cumscore",
   ")",
   "med_score",
   "=",
   "np",
   ".",
   "median",
   "(",
   "cumscore",
   "[",
   "np",
   ".",
   "argwhere",
   "(",
   "maxes",
   ")",
   "]",
   ")",
   "# The last of these is the last beat (since score generally increases)",
   "return",
   "np",
   ".",
   "argwhere",
   "(",
   "(",
   "cumscore",
   "*",
   "maxes",
   "*",
   "2",
   ">",
   "med_score",
   ")",
   ")",
   ".",
   "<mask>",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1173",
  "nl_tokens": [
   "Absorb",
   "trits",
   "into",
   "the",
   "sponge",
   "."
  ],
  "pl_tokens": [
   "def",
   "absorb",
   "(",
   "self",
   ",",
   "trits",
   ",",
   "offset",
   "=",
   "0",
   ",",
   "length",
   "=",
   "None",
   ")",
   ":",
   "# type: (Sequence[int], Optional[int], Optional[int]) -> None",
   "pad",
   "=",
   "(",
   "(",
   "len",
   "(",
   "trits",
   ")",
   "%",
   "HASH_LENGTH",
   ")",
   "or",
   "HASH_LENGTH",
   ")",
   "trits",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "(",
   "HASH_LENGTH",
   "-",
   "pad",
   ")",
   "if",
   "length",
   "is",
   "None",
   ":",
   "length",
   "=",
   "len",
   "(",
   "trits",
   ")",
   "if",
   "length",
   "<",
   "1",
   ":",
   "raise",
   "with_context",
   "(",
   "exc",
   "=",
   "ValueError",
   "(",
   "'Invalid length passed to ``absorb``.'",
   ")",
   ",",
   "context",
   "=",
   "{",
   "'trits'",
   ":",
   "trits",
   ",",
   "'offset'",
   ":",
   "offset",
   ",",
   "'length'",
   ":",
   "length",
   ",",
   "}",
   ",",
   ")",
   "# Copy trits from ``trits`` into internal state, one hash at a",
   "# time, transforming internal state in between hashes.",
   "while",
   "offset",
   "<",
   "length",
   ":",
   "start",
   "=",
   "offset",
   "stop",
   "=",
   "<mask>",
   "(",
   "start",
   "+",
   "HASH_LENGTH",
   ",",
   "length",
   ")",
   "# Copy the next hash worth of trits to internal state.",
   "#",
   "# Note that we always copy the trits to the start of the",
   "# state. ``self._state`` is 3 hashes long, but only the",
   "# first hash is \"public\"; the other 2 are only accessible to",
   "# :py:meth:`_transform`.",
   "self",
   ".",
   "_state",
   "[",
   "0",
   ":",
   "stop",
   "-",
   "start",
   "]",
   "=",
   "trits",
   "[",
   "start",
   ":",
   "stop",
   "]",
   "# Transform.",
   "self",
   ".",
   "_transform",
   "(",
   ")",
   "# Move on to the next hash.",
   "offset",
   "+=",
   "HASH_LENGTH"
  ]
 },
 {
  "idx": "maxmin-1174",
  "nl_tokens": [
   "Calculate",
   "the",
   "minimum",
   "parallax",
   "error",
   "from",
   "G",
   "and",
   "(",
   "V",
   "-",
   "I",
   ")",
   ".",
   "This",
   "correspond",
   "to",
   "the",
   "sky",
   "regions",
   "with",
   "the",
   "smallest",
   "astrometric",
   "errors",
   ".",
   "At",
   "the",
   "bright",
   "end",
   "the",
   "parallax",
   "error",
   "is",
   "at",
   "least",
   "14",
   "muas",
   "due",
   "to",
   "the",
   "gating",
   "scheme",
   "."
  ],
  "pl_tokens": [
   "def",
   "parallaxMinError",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "0.0",
   ")",
   ":",
   "return",
   "_astrometricErrorFactors",
   "[",
   "\"parallax\"",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "parallaxErrorSkyAvg",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "extension",
   ")"
  ]
 },
 {
  "idx": "maxmin-1175",
  "nl_tokens": [
   "Return",
   "datetime",
   "object",
   "of",
   "latest",
   "change",
   "in",
   "kerncraft",
   "module",
   "directory",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_last_modified_datetime",
   "(",
   "dir_path",
   "=",
   "os",
   ".",
   "path",
   ".",
   "dirname",
   "(",
   "__file__",
   ")",
   ")",
   ":",
   "max_mtime",
   "=",
   "0",
   "for",
   "root",
   ",",
   "dirs",
   ",",
   "files",
   "in",
   "os",
   ".",
   "walk",
   "(",
   "dir_path",
   ")",
   ":",
   "for",
   "f",
   "in",
   "files",
   ":",
   "p",
   "=",
   "os",
   ".",
   "path",
   ".",
   "join",
   "(",
   "root",
   ",",
   "f",
   ")",
   "try",
   ":",
   "max_mtime",
   "=",
   "<mask>",
   "(",
   "max_mtime",
   ",",
   "os",
   ".",
   "stat",
   "(",
   "p",
   ")",
   ".",
   "st_mtime",
   ")",
   "except",
   "FileNotFoundError",
   ":",
   "pass",
   "return",
   "datetime",
   ".",
   "utcfromtimestamp",
   "(",
   "max_mtime",
   ")"
  ]
 },
 {
  "idx": "maxmin-1176",
  "nl_tokens": [
   "Absorb",
   "trits",
   "into",
   "the",
   "sponge",
   "from",
   "a",
   "buffer",
   "."
  ],
  "pl_tokens": [
   "def",
   "absorb",
   "(",
   "self",
   ",",
   "trits",
   ",",
   "offset",
   "=",
   "0",
   ",",
   "length",
   "=",
   "None",
   ")",
   ":",
   "# type: (MutableSequence[int], int, Optional[int]) -> None",
   "# Pad input if necessary, so that it can be divided evenly into",
   "# hashes.",
   "# Note that this operation creates a COPY of ``trits``; the",
   "# incoming buffer is not modified!",
   "pad",
   "=",
   "(",
   "(",
   "len",
   "(",
   "trits",
   ")",
   "%",
   "TRIT_HASH_LENGTH",
   ")",
   "or",
   "TRIT_HASH_LENGTH",
   ")",
   "trits",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "(",
   "TRIT_HASH_LENGTH",
   "-",
   "pad",
   ")",
   "if",
   "length",
   "is",
   "None",
   ":",
   "length",
   "=",
   "len",
   "(",
   "trits",
   ")",
   "if",
   "length",
   "<",
   "1",
   ":",
   "raise",
   "with_context",
   "(",
   "exc",
   "=",
   "ValueError",
   "(",
   "'Invalid length passed to ``absorb``.'",
   ")",
   ",",
   "context",
   "=",
   "{",
   "'trits'",
   ":",
   "trits",
   ",",
   "'offset'",
   ":",
   "offset",
   ",",
   "'length'",
   ":",
   "length",
   ",",
   "}",
   ",",
   ")",
   "while",
   "offset",
   "<",
   "length",
   ":",
   "stop",
   "=",
   "<mask>",
   "(",
   "offset",
   "+",
   "TRIT_HASH_LENGTH",
   ",",
   "length",
   ")",
   "# If we're copying over a full chunk, zero last trit.",
   "if",
   "stop",
   "-",
   "offset",
   "==",
   "TRIT_HASH_LENGTH",
   ":",
   "trits",
   "[",
   "stop",
   "-",
   "1",
   "]",
   "=",
   "0",
   "signed_nums",
   "=",
   "conv",
   ".",
   "convertToBytes",
   "(",
   "trits",
   "[",
   "offset",
   ":",
   "stop",
   "]",
   ")",
   "# Convert signed bytes into their equivalent unsigned",
   "# representation, in order to use Python's built-in bytes",
   "# type.",
   "unsigned_bytes",
   "=",
   "bytearray",
   "(",
   "conv",
   ".",
   "convert_sign",
   "(",
   "b",
   ")",
   "for",
   "b",
   "in",
   "signed_nums",
   ")",
   "self",
   ".",
   "k",
   ".",
   "update",
   "(",
   "unsigned_bytes",
   ")",
   "offset",
   "+=",
   "TRIT_HASH_LENGTH"
  ]
 },
 {
  "idx": "maxmin-1177",
  "nl_tokens": [
   "Send",
   "information",
   "about",
   "a",
   "single",
   "metric",
   "data",
   "point",
   "that",
   "was",
   "captured",
   "for",
   "the",
   "application",
   ".",
   ":",
   "param",
   "name",
   ":",
   "The",
   "name",
   "of",
   "the",
   "metric",
   "that",
   "was",
   "captured",
   ".",
   ":",
   "param",
   "value",
   ":",
   "The",
   "value",
   "of",
   "the",
   "metric",
   "that",
   "was",
   "captured",
   ".",
   ":",
   "param",
   "type",
   ":",
   "The",
   "type",
   "of",
   "the",
   "metric",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "TelemetryDataPointType",
   ".",
   "aggregation",
   ")",
   ":",
   "param",
   "count",
   ":",
   "the",
   "number",
   "of",
   "metrics",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "min",
   ":",
   "the",
   "minimum",
   "of",
   "all",
   "metrics",
   "collected",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "max",
   ":",
   "the",
   "maximum",
   "of",
   "all",
   "metrics",
   "collected",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "std_dev",
   ":",
   "the",
   "standard",
   "deviation",
   "of",
   "all",
   "metrics",
   "collected",
   "that",
   "were",
   "aggregated",
   "into",
   "this",
   "data",
   "point",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")",
   ":",
   "param",
   "properties",
   ":",
   "the",
   "set",
   "of",
   "custom",
   "properties",
   "the",
   "client",
   "wants",
   "attached",
   "to",
   "this",
   "data",
   "item",
   ".",
   "(",
   "defaults",
   "to",
   ":",
   "None",
   ")"
  ],
  "pl_tokens": [
   "def",
   "track_metric",
   "(",
   "self",
   ",",
   "name",
   ":",
   "str",
   ",",
   "value",
   ":",
   "float",
   ",",
   "type",
   ":",
   "TelemetryDataPointType",
   "=",
   "None",
   ",",
   "count",
   ":",
   "int",
   "=",
   "None",
   ",",
   "<mask>",
   ":",
   "float",
   "=",
   "None",
   ",",
   "max",
   ":",
   "float",
   "=",
   "None",
   ",",
   "std_dev",
   ":",
   "float",
   "=",
   "None",
   ",",
   "properties",
   ":",
   "Dict",
   "[",
   "str",
   ",",
   "object",
   "]",
   "=",
   "None",
   ")",
   "->",
   "NotImplemented",
   ":",
   "self",
   ".",
   "_client",
   ".",
   "track_metric",
   "(",
   "name",
   ",",
   "value",
   ",",
   "type",
   ",",
   "count",
   ",",
   "min",
   ",",
   "max",
   ",",
   "std_dev",
   ",",
   "properties",
   ")"
  ]
 },
 {
  "idx": "maxmin-1178",
  "nl_tokens": [
   "Computes",
   "the",
   "self",
   "-",
   "similarity",
   "matrix",
   "of",
   "X",
   "."
  ],
  "pl_tokens": [
   "def",
   "compute_ssm",
   "(",
   "X",
   ",",
   "metric",
   "=",
   "\"seuclidean\"",
   ")",
   ":",
   "D",
   "=",
   "distance",
   ".",
   "pdist",
   "(",
   "X",
   ",",
   "metric",
   "=",
   "metric",
   ")",
   "D",
   "=",
   "distance",
   ".",
   "squareform",
   "(",
   "D",
   ")",
   "D",
   "/=",
   "D",
   ".",
   "<mask>",
   "(",
   ")",
   "return",
   "1",
   "-",
   "D"
  ]
 },
 {
  "idx": "maxmin-1179",
  "nl_tokens": [
   "Inverse",
   "short",
   "-",
   "time",
   "Fourier",
   "transform",
   "(",
   "ISTFT",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "istft",
   "(",
   "stft_matrix",
   ",",
   "hop_length",
   "=",
   "None",
   ",",
   "win_length",
   "=",
   "None",
   ",",
   "window",
   "=",
   "'hann'",
   ",",
   "center",
   "=",
   "True",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float32",
   ",",
   "length",
   "=",
   "None",
   ")",
   ":",
   "n_fft",
   "=",
   "2",
   "*",
   "(",
   "stft_matrix",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "1",
   ")",
   "# By default, use the entire frame",
   "if",
   "win_length",
   "is",
   "None",
   ":",
   "win_length",
   "=",
   "n_fft",
   "# Set the default hop, if it's not already specified",
   "if",
   "hop_length",
   "is",
   "None",
   ":",
   "hop_length",
   "=",
   "int",
   "(",
   "win_length",
   "//",
   "4",
   ")",
   "ifft_window",
   "=",
   "get_window",
   "(",
   "window",
   ",",
   "win_length",
   ",",
   "fftbins",
   "=",
   "True",
   ")",
   "# Pad out to match n_fft, and add a broadcasting axis",
   "ifft_window",
   "=",
   "util",
   ".",
   "pad_center",
   "(",
   "ifft_window",
   ",",
   "n_fft",
   ")",
   "[",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   "n_frames",
   "=",
   "stft_matrix",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "expected_signal_len",
   "=",
   "n_fft",
   "+",
   "hop_length",
   "*",
   "(",
   "n_frames",
   "-",
   "1",
   ")",
   "y",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "expected_signal_len",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "n_columns",
   "=",
   "int",
   "(",
   "util",
   ".",
   "MAX_MEM_BLOCK",
   "//",
   "(",
   "stft_matrix",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "*",
   "stft_matrix",
   ".",
   "itemsize",
   ")",
   ")",
   "fft",
   "=",
   "get_fftlib",
   "(",
   ")",
   "frame",
   "=",
   "0",
   "for",
   "bl_s",
   "in",
   "range",
   "(",
   "0",
   ",",
   "n_frames",
   ",",
   "n_columns",
   ")",
   ":",
   "bl_t",
   "=",
   "<mask>",
   "(",
   "bl_s",
   "+",
   "n_columns",
   ",",
   "n_frames",
   ")",
   "# invert the block and apply the window function",
   "ytmp",
   "=",
   "ifft_window",
   "*",
   "fft",
   ".",
   "irfft",
   "(",
   "stft_matrix",
   "[",
   ":",
   ",",
   "bl_s",
   ":",
   "bl_t",
   "]",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "# Overlap-add the istft block starting at the i'th frame",
   "__overlap_add",
   "(",
   "y",
   "[",
   "frame",
   "*",
   "hop_length",
   ":",
   "]",
   ",",
   "ytmp",
   ",",
   "hop_length",
   ")",
   "frame",
   "+=",
   "(",
   "bl_t",
   "-",
   "bl_s",
   ")",
   "# Normalize by sum of squared window",
   "ifft_window_sum",
   "=",
   "window_sumsquare",
   "(",
   "window",
   ",",
   "n_frames",
   ",",
   "win_length",
   "=",
   "win_length",
   ",",
   "n_fft",
   "=",
   "n_fft",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ",",
   "dtype",
   "=",
   "dtype",
   ")",
   "approx_nonzero_indices",
   "=",
   "ifft_window_sum",
   ">",
   "util",
   ".",
   "tiny",
   "(",
   "ifft_window_sum",
   ")",
   "y",
   "[",
   "approx_nonzero_indices",
   "]",
   "/=",
   "ifft_window_sum",
   "[",
   "approx_nonzero_indices",
   "]",
   "if",
   "length",
   "is",
   "None",
   ":",
   "# If we don't need to control length, just do the usual center trimming",
   "# to eliminate padded data",
   "if",
   "center",
   ":",
   "y",
   "=",
   "y",
   "[",
   "int",
   "(",
   "n_fft",
   "//",
   "2",
   ")",
   ":",
   "-",
   "int",
   "(",
   "n_fft",
   "//",
   "2",
   ")",
   "]",
   "else",
   ":",
   "if",
   "center",
   ":",
   "# If we're centering, crop off the first n_fft//2 samples",
   "# and then trim/pad to the target length.",
   "# We don't trim the end here, so that if the signal is zero-padded",
   "# to a longer duration, the decay is smooth by windowing",
   "start",
   "=",
   "int",
   "(",
   "n_fft",
   "//",
   "2",
   ")",
   "else",
   ":",
   "# If we're not centering, start at 0 and trim/pad as necessary",
   "start",
   "=",
   "0",
   "y",
   "=",
   "util",
   ".",
   "fix_length",
   "(",
   "y",
   "[",
   "start",
   ":",
   "]",
   ",",
   "length",
   ")",
   "return",
   "y"
  ]
 },
 {
  "idx": "maxmin-1180",
  "nl_tokens": [
   "Resize",
   "image",
   "while",
   "keeping",
   "the",
   "aspect",
   "ratio",
   "."
  ],
  "pl_tokens": [
   "def",
   "imrescale",
   "(",
   "img",
   ",",
   "scale",
   ",",
   "return_scale",
   "=",
   "False",
   ",",
   "interpolation",
   "=",
   "'bilinear'",
   ")",
   ":",
   "h",
   ",",
   "w",
   "=",
   "img",
   ".",
   "shape",
   "[",
   ":",
   "2",
   "]",
   "if",
   "isinstance",
   "(",
   "scale",
   ",",
   "(",
   "float",
   ",",
   "int",
   ")",
   ")",
   ":",
   "if",
   "scale",
   "<=",
   "0",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Invalid scale {}, must be positive.'",
   ".",
   "format",
   "(",
   "scale",
   ")",
   ")",
   "scale_factor",
   "=",
   "scale",
   "elif",
   "isinstance",
   "(",
   "scale",
   ",",
   "tuple",
   ")",
   ":",
   "max_long_edge",
   "=",
   "<mask>",
   "(",
   "scale",
   ")",
   "max_short_edge",
   "=",
   "min",
   "(",
   "scale",
   ")",
   "scale_factor",
   "=",
   "min",
   "(",
   "max_long_edge",
   "/",
   "max",
   "(",
   "h",
   ",",
   "w",
   ")",
   ",",
   "max_short_edge",
   "/",
   "min",
   "(",
   "h",
   ",",
   "w",
   ")",
   ")",
   "else",
   ":",
   "raise",
   "TypeError",
   "(",
   "'Scale must be a number or tuple of int, but got {}'",
   ".",
   "format",
   "(",
   "type",
   "(",
   "scale",
   ")",
   ")",
   ")",
   "new_size",
   "=",
   "_scale_size",
   "(",
   "(",
   "w",
   ",",
   "h",
   ")",
   ",",
   "scale_factor",
   ")",
   "rescaled_img",
   "=",
   "imresize",
   "(",
   "img",
   ",",
   "new_size",
   ",",
   "interpolation",
   "=",
   "interpolation",
   ")",
   "if",
   "return_scale",
   ":",
   "return",
   "rescaled_img",
   ",",
   "scale_factor",
   "else",
   ":",
   "return",
   "rescaled_img"
  ]
 },
 {
  "idx": "maxmin-1181",
  "nl_tokens": [
   "Overrideable",
   "function",
   "that",
   "generates",
   "the",
   "colors",
   "to",
   "be",
   "used",
   "by",
   "various",
   "styles",
   ".",
   "Should",
   "return",
   "a",
   "5",
   "-",
   "tuple",
   "of",
   "(",
   "bg",
   "o",
   "i",
   "s",
   "h",
   ")",
   "\\",
   ".",
   "bg",
   "is",
   "the",
   "base",
   "color",
   "of",
   "the",
   "background",
   ".",
   "o",
   "is",
   "the",
   "outer",
   "color",
   "it",
   "is",
   "usually",
   "the",
   "same",
   "as",
   "the",
   "background",
   "color",
   ".",
   "i",
   "is",
   "the",
   "inner",
   "color",
   "it",
   "is",
   "usually",
   "lighter",
   "than",
   "the",
   "background",
   "color",
   ".",
   "s",
   "is",
   "the",
   "shadow",
   "color",
   "it",
   "is",
   "usually",
   "quite",
   "a",
   "bit",
   "darker",
   "than",
   "the",
   "background",
   ".",
   "h",
   "is",
   "the",
   "highlight",
   "color",
   "it",
   "is",
   "usually",
   "quite",
   "a",
   "bit",
   "lighter",
   "than",
   "the",
   "background",
   ".",
   "The",
   "returned",
   "values",
   "may",
   "also",
   "be",
   "statically",
   "overridden",
   "by",
   "setting",
   "the",
   ":",
   "py",
   ":",
   "attr",
   ":",
   "color_<var",
   ">",
   "attribute",
   "to",
   "anything",
   "but",
   "None",
   "\\",
   "."
  ],
  "pl_tokens": [
   "def",
   "getColors",
   "(",
   "self",
   ")",
   ":",
   "bg",
   "=",
   "self",
   ".",
   "widget",
   ".",
   "submenu",
   ".",
   "bg",
   "[",
   ":",
   "3",
   "]",
   "if",
   "isinstance",
   "(",
   "self",
   ".",
   "widget",
   ".",
   "submenu",
   ".",
   "bg",
   ",",
   "list",
   ")",
   "or",
   "isinstance",
   "(",
   "self",
   ".",
   "widget",
   ".",
   "submenu",
   ".",
   "bg",
   ",",
   "tuple",
   ")",
   "else",
   "[",
   "242",
   ",",
   "241",
   ",",
   "240",
   "]",
   "bg",
   "=",
   "bg",
   "if",
   "self",
   ".",
   "color_bg",
   "is",
   "None",
   "else",
   "self",
   ".",
   "color_bg",
   "o",
   ",",
   "i",
   "=",
   "bg",
   ",",
   "[",
   "<mask>",
   "(",
   "bg",
   "[",
   "0",
   "]",
   "+",
   "8",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "1",
   "]",
   "+",
   "8",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "2",
   "]",
   "+",
   "8",
   ",",
   "255",
   ")",
   "]",
   "s",
   ",",
   "h",
   "=",
   "[",
   "max",
   "(",
   "bg",
   "[",
   "0",
   "]",
   "-",
   "40",
   ",",
   "0",
   ")",
   ",",
   "max",
   "(",
   "bg",
   "[",
   "1",
   "]",
   "-",
   "40",
   ",",
   "0",
   ")",
   ",",
   "max",
   "(",
   "bg",
   "[",
   "2",
   "]",
   "-",
   "40",
   ",",
   "0",
   ")",
   "]",
   ",",
   "[",
   "min",
   "(",
   "bg",
   "[",
   "0",
   "]",
   "+",
   "12",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "1",
   "]",
   "+",
   "12",
   ",",
   "255",
   ")",
   ",",
   "min",
   "(",
   "bg",
   "[",
   "2",
   "]",
   "+",
   "12",
   ",",
   "255",
   ")",
   "]",
   "o",
   "=",
   "o",
   "if",
   "self",
   ".",
   "color_o",
   "is",
   "None",
   "else",
   "self",
   ".",
   "color_o",
   "i",
   "=",
   "i",
   "if",
   "self",
   ".",
   "color_i",
   "is",
   "None",
   "else",
   "self",
   ".",
   "color_i",
   "s",
   "=",
   "s",
   "if",
   "self",
   ".",
   "color_s",
   "is",
   "None",
   "else",
   "self",
   ".",
   "color_s",
   "h",
   "=",
   "h",
   "if",
   "self",
   ".",
   "color_h",
   "is",
   "None",
   "else",
   "self",
   ".",
   "color_h",
   "# Outer,Inner,Shadow,Highlight",
   "return",
   "bg",
   ",",
   "o",
   ",",
   "i",
   ",",
   "s",
   ",",
   "h"
  ]
 },
 {
  "idx": "maxmin-1182",
  "nl_tokens": [
   "Plot",
   "frequency",
   "spectrum",
   "of",
   "a",
   "given",
   "file"
  ],
  "pl_tokens": [
   "def",
   "plot_spectrum_min_max",
   "(",
   "self",
   ",",
   "t",
   "=",
   "0",
   ",",
   "f_start",
   "=",
   "None",
   ",",
   "f_stop",
   "=",
   "None",
   ",",
   "logged",
   "=",
   "False",
   ",",
   "if_id",
   "=",
   "0",
   ",",
   "c",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "ax",
   "=",
   "plt",
   ".",
   "gca",
   "(",
   ")",
   "plot_f",
   ",",
   "plot_data",
   "=",
   "self",
   ".",
   "grab_data",
   "(",
   "f_start",
   ",",
   "f_stop",
   ",",
   "if_id",
   ")",
   "#Using accending frequency for all plots.",
   "if",
   "self",
   ".",
   "header",
   "[",
   "b'foff'",
   "]",
   "<",
   "0",
   ":",
   "plot_data",
   "=",
   "plot_data",
   "[",
   "...",
   ",",
   ":",
   ":",
   "-",
   "1",
   "]",
   "# Reverse data",
   "plot_f",
   "=",
   "plot_f",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "fig_max",
   "=",
   "plot_data",
   "[",
   "0",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "fig_min",
   "=",
   "plot_data",
   "[",
   "0",
   "]",
   ".",
   "min",
   "(",
   ")",
   "print",
   "(",
   "\"averaging along time axis...\"",
   ")",
   "#Since the data has been squeezed, the axis for time goes away if only one bin, causing a bug with axis=1",
   "if",
   "len",
   "(",
   "plot_data",
   ".",
   "shape",
   ")",
   ">",
   "1",
   ":",
   "plot_max",
   "=",
   "plot_data",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "plot_min",
   "=",
   "plot_data",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "plot_data",
   "=",
   "plot_data",
   ".",
   "mean",
   "(",
   "axis",
   "=",
   "0",
   ")",
   "else",
   ":",
   "plot_max",
   "=",
   "plot_data",
   ".",
   "max",
   "(",
   ")",
   "plot_min",
   "=",
   "plot_data",
   ".",
   "min",
   "(",
   ")",
   "plot_data",
   "=",
   "plot_data",
   ".",
   "mean",
   "(",
   ")",
   "# Rebin to max number of points",
   "dec_fac_x",
   "=",
   "1",
   "MAX_PLT_POINTS",
   "=",
   "8",
   "*",
   "64",
   "# Low resoluition to see the difference.",
   "if",
   "plot_data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ">",
   "MAX_PLT_POINTS",
   ":",
   "dec_fac_x",
   "=",
   "int",
   "(",
   "plot_data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "/",
   "MAX_PLT_POINTS",
   ")",
   "plot_data",
   "=",
   "rebin",
   "(",
   "plot_data",
   ",",
   "dec_fac_x",
   ",",
   "1",
   ")",
   "plot_min",
   "=",
   "rebin",
   "(",
   "plot_min",
   ",",
   "dec_fac_x",
   ",",
   "1",
   ")",
   "plot_max",
   "=",
   "rebin",
   "(",
   "plot_max",
   ",",
   "dec_fac_x",
   ",",
   "1",
   ")",
   "plot_f",
   "=",
   "rebin",
   "(",
   "plot_f",
   ",",
   "dec_fac_x",
   ",",
   "1",
   ")",
   "if",
   "logged",
   ":",
   "plt",
   ".",
   "plot",
   "(",
   "plot_f",
   ",",
   "db",
   "(",
   "plot_data",
   ")",
   ",",
   "\"#333333\"",
   ",",
   "label",
   "=",
   "'mean'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "plot_f",
   ",",
   "db",
   "(",
   "plot_max",
   ")",
   ",",
   "\"#e74c3c\"",
   ",",
   "label",
   "=",
   "'max'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "plot_f",
   ",",
   "db",
   "(",
   "plot_min",
   ")",
   ",",
   "'#3b5b92'",
   ",",
   "label",
   "=",
   "'min'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "\"Power [dB]\"",
   ")",
   "else",
   ":",
   "plt",
   ".",
   "plot",
   "(",
   "plot_f",
   ",",
   "plot_data",
   ",",
   "\"#333333\"",
   ",",
   "label",
   "=",
   "'mean'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "plot_f",
   ",",
   "plot_max",
   ",",
   "\"#e74c3c\"",
   ",",
   "label",
   "=",
   "'max'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "plt",
   ".",
   "plot",
   "(",
   "plot_f",
   ",",
   "plot_min",
   ",",
   "'#3b5b92'",
   ",",
   "label",
   "=",
   "'min'",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   "plt",
   ".",
   "ylabel",
   "(",
   "\"Power [counts]\"",
   ")",
   "plt",
   ".",
   "xlabel",
   "(",
   "\"Frequency [MHz]\"",
   ")",
   "plt",
   ".",
   "legend",
   "(",
   ")",
   "try",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "self",
   ".",
   "header",
   "[",
   "b'source_name'",
   "]",
   ")",
   "except",
   "KeyError",
   ":",
   "plt",
   ".",
   "title",
   "(",
   "self",
   ".",
   "filename",
   ")",
   "plt",
   ".",
   "xlim",
   "(",
   "plot_f",
   "[",
   "0",
   "]",
   ",",
   "plot_f",
   "[",
   "-",
   "1",
   "]",
   ")",
   "if",
   "logged",
   ":",
   "plt",
   ".",
   "ylim",
   "(",
   "db",
   "(",
   "fig_min",
   ")",
   ",",
   "db",
   "(",
   "fig_max",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1183",
  "nl_tokens": [
   "Sorts",
   "a",
   "list",
   "of",
   "results",
   "in",
   "O",
   "(",
   "n",
   ")",
   "in",
   "place",
   "(",
   "since",
   "every",
   "run",
   "is",
   "unique",
   ")"
  ],
  "pl_tokens": [
   "def",
   "result_sort",
   "(",
   "result_list",
   ",",
   "start_index",
   "=",
   "0",
   ")",
   ":",
   "if",
   "len",
   "(",
   "result_list",
   ")",
   "<",
   "2",
   ":",
   "return",
   "result_list",
   "to_sort",
   "=",
   "result_list",
   "[",
   "start_index",
   ":",
   "]",
   "minmax",
   "=",
   "[",
   "x",
   "[",
   "0",
   "]",
   "for",
   "x",
   "in",
   "to_sort",
   "]",
   "minimum",
   "=",
   "<mask>",
   "(",
   "minmax",
   ")",
   "maximum",
   "=",
   "max",
   "(",
   "minmax",
   ")",
   "#print minimum, maximum",
   "sorted_list",
   "=",
   "[",
   "None",
   "for",
   "_",
   "in",
   "range",
   "(",
   "minimum",
   ",",
   "maximum",
   "+",
   "1",
   ")",
   "]",
   "for",
   "elem",
   "in",
   "to_sort",
   ":",
   "key",
   "=",
   "elem",
   "[",
   "0",
   "]",
   "-",
   "minimum",
   "sorted_list",
   "[",
   "key",
   "]",
   "=",
   "elem",
   "idx_count",
   "=",
   "start_index",
   "for",
   "elem",
   "in",
   "sorted_list",
   ":",
   "if",
   "elem",
   "is",
   "not",
   "None",
   ":",
   "result_list",
   "[",
   "idx_count",
   "]",
   "=",
   "elem",
   "idx_count",
   "+=",
   "1",
   "return",
   "result_list"
  ]
 },
 {
  "idx": "maxmin-1184",
  "nl_tokens": [
   "calculates",
   "the",
   "capacity",
   "according",
   "to",
   "Appendix",
   "B",
   "verification",
   "method",
   "4",
   "of",
   "the",
   "NZ",
   "building",
   "code"
  ],
  "pl_tokens": [
   "def",
   "capacity_nzs_vm4_2011",
   "(",
   "sl",
   ",",
   "fd",
   ",",
   "h_l",
   "=",
   "0",
   ",",
   "h_b",
   "=",
   "0",
   ",",
   "vertical_load",
   "=",
   "1",
   ",",
   "slope",
   "=",
   "0",
   ",",
   "verbose",
   "=",
   "0",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# Need to make adjustments if sand  has DR<40% or",
   "# clay has liquidity indices greater than 0.7",
   "if",
   "not",
   "kwargs",
   ".",
   "get",
   "(",
   "\"disable_requires\"",
   ",",
   "False",
   ")",
   ":",
   "models",
   ".",
   "check_required",
   "(",
   "sl",
   ",",
   "[",
   "\"phi_r\"",
   ",",
   "\"cohesion\"",
   ",",
   "\"unit_dry_weight\"",
   "]",
   ")",
   "models",
   ".",
   "check_required",
   "(",
   "fd",
   ",",
   "[",
   "\"length\"",
   ",",
   "\"width\"",
   ",",
   "\"depth\"",
   "]",
   ")",
   "horizontal_load",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "h_l",
   "**",
   "2",
   "+",
   "h_b",
   "**",
   "2",
   ")",
   "h_eff_b",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"h_eff_b\"",
   ",",
   "0",
   ")",
   "h_eff_l",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"h_eff_l\"",
   ",",
   "0",
   ")",
   "loc_v_l",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"loc_v_l\"",
   ",",
   "fd",
   ".",
   "length",
   "/",
   "2",
   ")",
   "loc_v_b",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "\"loc_v_b\"",
   ",",
   "fd",
   ".",
   "width",
   "/",
   "2",
   ")",
   "ecc_b",
   "=",
   "h_b",
   "*",
   "h_eff_b",
   "/",
   "vertical_load",
   "ecc_l",
   "=",
   "h_l",
   "*",
   "h_eff_l",
   "/",
   "vertical_load",
   "width_eff",
   "=",
   "<mask>",
   "(",
   "fd",
   ".",
   "width",
   ",",
   "2",
   "*",
   "(",
   "loc_v_b",
   "+",
   "ecc_b",
   ")",
   ",",
   "2",
   "*",
   "(",
   "fd",
   ".",
   "width",
   "-",
   "loc_v_b",
   "-",
   "ecc_b",
   ")",
   ")",
   "length_eff",
   "=",
   "min",
   "(",
   "fd",
   ".",
   "length",
   ",",
   "2",
   "*",
   "(",
   "loc_v_l",
   "+",
   "ecc_l",
   ")",
   ",",
   "2",
   "*",
   "(",
   "fd",
   ".",
   "length",
   "-",
   "loc_v_l",
   "-",
   "ecc_l",
   ")",
   ")",
   "area_foundation",
   "=",
   "length_eff",
   "*",
   "width_eff",
   "# check para 3.4.1",
   "if",
   "width_eff",
   "/",
   "2",
   "<",
   "fd",
   ".",
   "width",
   "/",
   "6",
   ":",
   "raise",
   "DesignError",
   "(",
   "\"failed on eccentricity\"",
   ")",
   "# LOAD FACTORS:",
   "fd",
   ".",
   "nq_factor",
   "=",
   "(",
   "(",
   "np",
   ".",
   "tan",
   "(",
   "np",
   ".",
   "pi",
   "/",
   "4",
   "+",
   "sl",
   ".",
   "phi_r",
   "/",
   "2",
   ")",
   ")",
   "**",
   "2",
   "*",
   "np",
   ".",
   "exp",
   "(",
   "np",
   ".",
   "pi",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   ")",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "fd",
   ".",
   "nc_factor",
   "=",
   "5.14",
   "else",
   ":",
   "fd",
   ".",
   "nc_factor",
   "=",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "fd",
   ".",
   "ng_factor",
   "=",
   "2.0",
   "*",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "# shape factors:",
   "s_c",
   "=",
   "1.0",
   "+",
   "fd",
   ".",
   "nq_factor",
   "/",
   "fd",
   ".",
   "nc_factor",
   "*",
   "width_eff",
   "/",
   "length_eff",
   "s_q",
   "=",
   "1",
   "+",
   "width_eff",
   "/",
   "length_eff",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "s_g",
   "=",
   "max",
   "(",
   "1.0",
   "-",
   "0.4",
   "*",
   "width_eff",
   "/",
   "length_eff",
   ",",
   "0.6",
   ")",
   "# add limit of 0.6 based on Vesics",
   "# depth factors:",
   "if",
   "fd",
   ".",
   "depth",
   "/",
   "width_eff",
   ">",
   "1",
   ":",
   "k",
   "=",
   "np",
   ".",
   "arctan",
   "(",
   "fd",
   ".",
   "depth",
   "/",
   "width_eff",
   ")",
   "else",
   ":",
   "k",
   "=",
   "fd",
   ".",
   "depth",
   "/",
   "width_eff",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "d_c",
   "=",
   "1",
   "+",
   "0.4",
   "*",
   "k",
   "d_q",
   "=",
   "1.0",
   "else",
   ":",
   "d_q",
   "=",
   "(",
   "1",
   "+",
   "2",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   "*",
   "(",
   "1",
   "-",
   "np",
   ".",
   "sin",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "**",
   "2",
   "*",
   "k",
   ")",
   "d_c",
   "=",
   "d_q",
   "-",
   "(",
   "1",
   "-",
   "d_q",
   ")",
   "/",
   "(",
   "fd",
   ".",
   "nq_factor",
   "*",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "d_g",
   "=",
   "1.0",
   "# load inclination factors:",
   "if",
   "sl",
   ".",
   "phi_r",
   "==",
   "0",
   ":",
   "i_c",
   "=",
   "0.5",
   "*",
   "(",
   "1",
   "+",
   "np",
   ".",
   "sqrt",
   "(",
   "1",
   "-",
   "horizontal_load",
   "/",
   "(",
   "area_foundation",
   "*",
   "sl",
   ".",
   "cohesion",
   ")",
   ")",
   ")",
   "i_q",
   "=",
   "1.0",
   "i_g",
   "=",
   "1.0",
   "else",
   ":",
   "if",
   "h_b",
   "==",
   "0",
   ":",
   "i_q",
   "=",
   "1",
   "-",
   "horizontal_load",
   "/",
   "(",
   "vertical_load",
   "+",
   "area_foundation",
   "*",
   "sl",
   ".",
   "cohesion",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   "i_g",
   "=",
   "i_q",
   "elif",
   "h_b",
   ">",
   "0",
   "and",
   "h_l",
   "==",
   "0",
   ":",
   "i_q",
   "=",
   "(",
   "(",
   "1",
   "-",
   "0.7",
   "*",
   "horizontal_load",
   "/",
   "(",
   "vertical_load",
   "+",
   "area_foundation",
   "*",
   "sl",
   ".",
   "cohesion",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   ")",
   "**",
   "3",
   ")",
   "i_g",
   "=",
   "(",
   "(",
   "1",
   "-",
   "horizontal_load",
   "/",
   "(",
   "vertical_load",
   "+",
   "area_foundation",
   "*",
   "sl",
   ".",
   "cohesion",
   "/",
   "np",
   ".",
   "tan",
   "(",
   "sl",
   ".",
   "phi_r",
   ")",
   ")",
   ")",
   "**",
   "3",
   ")",
   "else",
   ":",
   "raise",
   "DesignError",
   "(",
   "\"not setup for bi-directional loading\"",
   ")",
   "i_c",
   "=",
   "(",
   "i_q",
   "*",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "/",
   "(",
   "fd",
   ".",
   "nq_factor",
   "-",
   "1",
   ")",
   "# ground slope factors:",
   "g_c",
   "=",
   "1",
   "-",
   "slope",
   "*",
   "(",
   "1.0",
   "-",
   "fd",
   ".",
   "depth",
   "/",
   "(",
   "2",
   "*",
   "width_eff",
   ")",
   ")",
   "/",
   "150",
   "g_q",
   "=",
   "(",
   "1",
   "-",
   "np",
   ".",
   "tan",
   "(",
   "slope",
   "*",
   "(",
   "1",
   "-",
   "fd",
   ".",
   "depth",
   "/",
   "(",
   "2",
   "*",
   "width_eff",
   ")",
   ")",
   ")",
   ")",
   "**",
   "2",
   "g_g",
   "=",
   "g_q",
   "# stress at footing base:",
   "q_d",
   "=",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "fd",
   ".",
   "depth",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"Nc: \"",
   ",",
   "fd",
   ".",
   "nc_factor",
   ")",
   "log",
   "(",
   "\"Nq: \"",
   ",",
   "fd",
   ".",
   "nq_factor",
   ")",
   "log",
   "(",
   "\"Ng: \"",
   ",",
   "fd",
   ".",
   "ng_factor",
   ")",
   "log",
   "(",
   "\"H: \"",
   ",",
   "horizontal_load",
   ")",
   "log",
   "(",
   "\"s_c: \"",
   ",",
   "s_c",
   ")",
   "log",
   "(",
   "\"s_q: \"",
   ",",
   "s_q",
   ")",
   "log",
   "(",
   "\"s_g: \"",
   ",",
   "s_g",
   ")",
   "log",
   "(",
   "\"d_c: \"",
   ",",
   "d_c",
   ")",
   "log",
   "(",
   "\"d_q: \"",
   ",",
   "d_q",
   ")",
   "log",
   "(",
   "\"d_g: \"",
   ",",
   "d_g",
   ")",
   "log",
   "(",
   "\"i_c: \"",
   ",",
   "i_c",
   ")",
   "log",
   "(",
   "\"i_q: \"",
   ",",
   "i_q",
   ")",
   "log",
   "(",
   "\"i_g: \"",
   ",",
   "i_g",
   ")",
   "log",
   "(",
   "\"g_c: \"",
   ",",
   "g_c",
   ")",
   "log",
   "(",
   "\"g_q: \"",
   ",",
   "g_q",
   ")",
   "log",
   "(",
   "\"g_g: \"",
   ",",
   "g_g",
   ")",
   "# Capacity",
   "fd",
   ".",
   "q_ult",
   "=",
   "(",
   "sl",
   ".",
   "cohesion",
   "*",
   "fd",
   ".",
   "nc_factor",
   "*",
   "s_c",
   "*",
   "d_c",
   "*",
   "i_c",
   "*",
   "g_c",
   "+",
   "q_d",
   "*",
   "fd",
   ".",
   "nq_factor",
   "*",
   "s_q",
   "*",
   "d_q",
   "*",
   "i_q",
   "*",
   "g_q",
   "+",
   "0.5",
   "*",
   "width_eff",
   "*",
   "sl",
   ".",
   "unit_dry_weight",
   "*",
   "fd",
   ".",
   "ng_factor",
   "*",
   "s_g",
   "*",
   "d_g",
   "*",
   "i_g",
   "*",
   "g_g",
   ")",
   "if",
   "verbose",
   ":",
   "log",
   "(",
   "\"q_ult: \"",
   ",",
   "fd",
   ".",
   "q_ult",
   ")",
   "return",
   "fd",
   ".",
   "q_ult"
  ]
 },
 {
  "idx": "maxmin-1185",
  "nl_tokens": [
   "Estimate",
   "pi0",
   "according",
   "to",
   "bioconductor",
   "/",
   "qvalue"
  ],
  "pl_tokens": [
   "def",
   "pi0est",
   "(",
   "p_values",
   ",",
   "lambda_",
   "=",
   "np",
   ".",
   "arange",
   "(",
   "0.05",
   ",",
   "1.0",
   ",",
   "0.05",
   ")",
   ",",
   "pi0_method",
   "=",
   "\"smoother\"",
   ",",
   "smooth_df",
   "=",
   "3",
   ",",
   "smooth_log_pi0",
   "=",
   "False",
   ")",
   ":",
   "# Compare to bioconductor/qvalue reference implementation",
   "# import rpy2",
   "# import rpy2.robjects as robjects",
   "# from rpy2.robjects import pandas2ri",
   "# pandas2ri.activate()",
   "# smoothspline=robjects.r('smooth.spline')",
   "# predict=robjects.r('predict')",
   "p",
   "=",
   "np",
   ".",
   "array",
   "(",
   "p_values",
   ")",
   "rm_na",
   "=",
   "np",
   ".",
   "isfinite",
   "(",
   "p",
   ")",
   "p",
   "=",
   "p",
   "[",
   "rm_na",
   "]",
   "m",
   "=",
   "len",
   "(",
   "p",
   ")",
   "ll",
   "=",
   "1",
   "if",
   "isinstance",
   "(",
   "lambda_",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "ll",
   "=",
   "len",
   "(",
   "lambda_",
   ")",
   "lambda_",
   "=",
   "np",
   ".",
   "sort",
   "(",
   "lambda_",
   ")",
   "if",
   "(",
   "<mask>",
   "(",
   "p",
   ")",
   "<",
   "0",
   "or",
   "max",
   "(",
   "p",
   ")",
   ">",
   "1",
   ")",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"p-values not in valid range [0,1].\"",
   ")",
   "elif",
   "(",
   "ll",
   ">",
   "1",
   "and",
   "ll",
   "<",
   "4",
   ")",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"If lambda_ is not predefined (one value), at least four data points are required.\"",
   ")",
   "elif",
   "(",
   "np",
   ".",
   "min",
   "(",
   "lambda_",
   ")",
   "<",
   "0",
   "or",
   "np",
   ".",
   "max",
   "(",
   "lambda_",
   ")",
   ">=",
   "1",
   ")",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"Lambda must be within [0,1)\"",
   ")",
   "if",
   "(",
   "ll",
   "==",
   "1",
   ")",
   ":",
   "pi0",
   "=",
   "np",
   ".",
   "mean",
   "(",
   "p",
   ">=",
   "lambda_",
   ")",
   "/",
   "(",
   "1",
   "-",
   "lambda_",
   ")",
   "pi0_lambda",
   "=",
   "pi0",
   "pi0",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "pi0",
   ",",
   "1",
   ")",
   "pi0Smooth",
   "=",
   "False",
   "else",
   ":",
   "pi0",
   "=",
   "[",
   "]",
   "for",
   "l",
   "in",
   "lambda_",
   ":",
   "pi0",
   ".",
   "append",
   "(",
   "np",
   ".",
   "mean",
   "(",
   "p",
   ">=",
   "l",
   ")",
   "/",
   "(",
   "1",
   "-",
   "l",
   ")",
   ")",
   "pi0_lambda",
   "=",
   "pi0",
   "if",
   "(",
   "pi0_method",
   "==",
   "\"smoother\"",
   ")",
   ":",
   "if",
   "smooth_log_pi0",
   ":",
   "pi0",
   "=",
   "np",
   ".",
   "log",
   "(",
   "pi0",
   ")",
   "spi0",
   "=",
   "sp",
   ".",
   "interpolate",
   ".",
   "UnivariateSpline",
   "(",
   "lambda_",
   ",",
   "pi0",
   ",",
   "k",
   "=",
   "smooth_df",
   ")",
   "pi0Smooth",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "spi0",
   "(",
   "lambda_",
   ")",
   ")",
   "# spi0 = smoothspline(lambda_, pi0, df = smooth_df) # R reference function",
   "# pi0Smooth = np.exp(predict(spi0, x = lambda_).rx2('y')) # R reference function",
   "else",
   ":",
   "spi0",
   "=",
   "sp",
   ".",
   "interpolate",
   ".",
   "UnivariateSpline",
   "(",
   "lambda_",
   ",",
   "pi0",
   ",",
   "k",
   "=",
   "smooth_df",
   ")",
   "pi0Smooth",
   "=",
   "spi0",
   "(",
   "lambda_",
   ")",
   "# spi0 = smoothspline(lambda_, pi0, df = smooth_df) # R reference function",
   "# pi0Smooth = predict(spi0, x = lambda_).rx2('y')  # R reference function",
   "pi0",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "pi0Smooth",
   "[",
   "ll",
   "-",
   "1",
   "]",
   ",",
   "1",
   ")",
   "elif",
   "(",
   "pi0_method",
   "==",
   "\"bootstrap\"",
   ")",
   ":",
   "minpi0",
   "=",
   "np",
   ".",
   "percentile",
   "(",
   "pi0",
   ",",
   "0.1",
   ")",
   "W",
   "=",
   "[",
   "]",
   "for",
   "l",
   "in",
   "lambda_",
   ":",
   "W",
   ".",
   "append",
   "(",
   "np",
   ".",
   "sum",
   "(",
   "p",
   ">=",
   "l",
   ")",
   ")",
   "mse",
   "=",
   "(",
   "np",
   ".",
   "array",
   "(",
   "W",
   ")",
   "/",
   "(",
   "np",
   ".",
   "power",
   "(",
   "m",
   ",",
   "2",
   ")",
   "*",
   "np",
   ".",
   "power",
   "(",
   "(",
   "1",
   "-",
   "lambda_",
   ")",
   ",",
   "2",
   ")",
   ")",
   ")",
   "*",
   "(",
   "1",
   "-",
   "np",
   ".",
   "array",
   "(",
   "W",
   ")",
   "/",
   "m",
   ")",
   "+",
   "np",
   ".",
   "power",
   "(",
   "(",
   "pi0",
   "-",
   "minpi0",
   ")",
   ",",
   "2",
   ")",
   "pi0",
   "=",
   "np",
   ".",
   "minimum",
   "(",
   "pi0",
   "[",
   "np",
   ".",
   "argmin",
   "(",
   "mse",
   ")",
   "]",
   ",",
   "1",
   ")",
   "pi0Smooth",
   "=",
   "False",
   "else",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"pi0_method must be one of 'smoother' or 'bootstrap'.\"",
   ")",
   "if",
   "(",
   "pi0",
   "<=",
   "0",
   ")",
   ":",
   "raise",
   "click",
   ".",
   "ClickException",
   "(",
   "\"The estimated pi0 <= 0. Check that you have valid p-values or use a different range of lambda.\"",
   ")",
   "return",
   "{",
   "'pi0'",
   ":",
   "pi0",
   ",",
   "'pi0_lambda'",
   ":",
   "pi0_lambda",
   ",",
   "'lambda_'",
   ":",
   "lambda_",
   ",",
   "'pi0_smooth'",
   ":",
   "pi0Smooth",
   "}"
  ]
 },
 {
  "idx": "maxmin-1186",
  "nl_tokens": [
   "Returns",
   "normalized",
   "scientific",
   "notation",
   "components",
   "of",
   "a",
   "value",
   "."
  ],
  "pl_tokens": [
   "def",
   "scientific_notation_elements",
   "(",
   "self",
   ",",
   "value",
   ",",
   "locale",
   ")",
   ":",
   "# Normalize value to only have one lead digit.",
   "exp",
   "=",
   "value",
   ".",
   "adjusted",
   "(",
   ")",
   "value",
   "=",
   "value",
   "*",
   "get_decimal_quantum",
   "(",
   "exp",
   ")",
   "assert",
   "value",
   ".",
   "adjusted",
   "(",
   ")",
   "==",
   "0",
   "# Shift exponent and value by the minimum number of leading digits",
   "# imposed by the rendering pattern. And always make that number",
   "# greater or equal to 1.",
   "lead_shift",
   "=",
   "<mask>",
   "(",
   "[",
   "1",
   ",",
   "min",
   "(",
   "self",
   ".",
   "int_prec",
   ")",
   "]",
   ")",
   "-",
   "1",
   "exp",
   "=",
   "exp",
   "-",
   "lead_shift",
   "value",
   "=",
   "value",
   "*",
   "get_decimal_quantum",
   "(",
   "-",
   "lead_shift",
   ")",
   "# Get exponent sign symbol.",
   "exp_sign",
   "=",
   "''",
   "if",
   "exp",
   "<",
   "0",
   ":",
   "exp_sign",
   "=",
   "babel",
   ".",
   "numbers",
   ".",
   "get_minus_sign_symbol",
   "(",
   "locale",
   ")",
   "elif",
   "self",
   ".",
   "exp_plus",
   ":",
   "exp_sign",
   "=",
   "babel",
   ".",
   "numbers",
   ".",
   "get_plus_sign_symbol",
   "(",
   "locale",
   ")",
   "# Normalize exponent value now that we have the sign.",
   "exp",
   "=",
   "abs",
   "(",
   "exp",
   ")",
   "return",
   "value",
   ",",
   "exp",
   ",",
   "exp_sign"
  ]
 },
 {
  "idx": "maxmin-1187",
  "nl_tokens": [
   "Returns",
   "the",
   "remaining",
   "duration",
   "for",
   "a",
   "recording",
   "."
  ],
  "pl_tokens": [
   "def",
   "remaining_duration",
   "(",
   "self",
   ",",
   "time",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "0",
   ",",
   "self",
   ".",
   "end",
   "-",
   "max",
   "(",
   "self",
   ".",
   "start",
   ",",
   "time",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1188",
  "nl_tokens": [
   "Updates",
   "the",
   "process",
   "stats",
   "with",
   "the",
   "information",
   "from",
   "the",
   "processes"
  ],
  "pl_tokens": [
   "def",
   "_update_process_stats",
   "(",
   "self",
   ")",
   ":",
   "good_status",
   "=",
   "[",
   "\"COMPLETED\"",
   ",",
   "\"CACHED\"",
   "]",
   "for",
   "process",
   ",",
   "vals",
   "in",
   "self",
   ".",
   "trace_info",
   ".",
   "items",
   "(",
   ")",
   ":",
   "# Update submission status of tags for each process",
   "vals",
   "=",
   "self",
   ".",
   "_update_tag_status",
   "(",
   "process",
   ",",
   "vals",
   ")",
   "# Update process resources",
   "self",
   ".",
   "_update_process_resources",
   "(",
   "process",
   ",",
   "vals",
   ")",
   "self",
   ".",
   "process_stats",
   "[",
   "process",
   "]",
   "=",
   "{",
   "}",
   "inst",
   "=",
   "self",
   ".",
   "process_stats",
   "[",
   "process",
   "]",
   "# Get number of completed samples",
   "inst",
   "[",
   "\"completed\"",
   "]",
   "=",
   "\"{}\"",
   ".",
   "format",
   "(",
   "len",
   "(",
   "[",
   "x",
   "for",
   "x",
   "in",
   "vals",
   "if",
   "x",
   "[",
   "\"status\"",
   "]",
   "in",
   "good_status",
   "]",
   ")",
   ")",
   "# Get average time",
   "try",
   ":",
   "time_array",
   "=",
   "[",
   "self",
   ".",
   "_hms",
   "(",
   "x",
   "[",
   "\"realtime\"",
   "]",
   ")",
   "for",
   "x",
   "in",
   "vals",
   "]",
   "mean_time",
   "=",
   "round",
   "(",
   "sum",
   "(",
   "time_array",
   ")",
   "/",
   "len",
   "(",
   "time_array",
   ")",
   ",",
   "1",
   ")",
   "mean_time_str",
   "=",
   "strftime",
   "(",
   "'%H:%M:%S'",
   ",",
   "gmtime",
   "(",
   "mean_time",
   ")",
   ")",
   "inst",
   "[",
   "\"realtime\"",
   "]",
   "=",
   "mean_time_str",
   "# When the realtime column is not present",
   "except",
   "KeyError",
   ":",
   "inst",
   "[",
   "\"realtime\"",
   "]",
   "=",
   "\"-\"",
   "# Get cumulative cpu/hours",
   "try",
   ":",
   "cpu_hours",
   "=",
   "[",
   "self",
   ".",
   "_cpu_load_parser",
   "(",
   "x",
   "[",
   "\"cpus\"",
   "]",
   ",",
   "x",
   "[",
   "\"%cpu\"",
   "]",
   ",",
   "x",
   "[",
   "\"realtime\"",
   "]",
   ")",
   "for",
   "x",
   "in",
   "vals",
   "]",
   "inst",
   "[",
   "\"cpuhour\"",
   "]",
   "=",
   "round",
   "(",
   "sum",
   "(",
   "cpu_hours",
   ")",
   ",",
   "2",
   ")",
   "# When the realtime, cpus or %cpus column are not present",
   "except",
   "KeyError",
   ":",
   "inst",
   "[",
   "\"cpuhour\"",
   "]",
   "=",
   "\"-\"",
   "# Assess resource warnings",
   "inst",
   "[",
   "\"cpu_warnings\"",
   "]",
   ",",
   "inst",
   "[",
   "\"mem_warnings\"",
   "]",
   "=",
   "self",
   ".",
   "_assess_resource_warnings",
   "(",
   "process",
   ",",
   "vals",
   ")",
   "# Get maximum memory",
   "try",
   ":",
   "rss_values",
   "=",
   "[",
   "self",
   ".",
   "_size_coverter",
   "(",
   "x",
   "[",
   "\"rss\"",
   "]",
   ")",
   "for",
   "x",
   "in",
   "vals",
   "if",
   "x",
   "[",
   "\"rss\"",
   "]",
   "!=",
   "\"-\"",
   "]",
   "if",
   "rss_values",
   ":",
   "max_rss",
   "=",
   "round",
   "(",
   "<mask>",
   "(",
   "rss_values",
   ")",
   ")",
   "rss_str",
   "=",
   "self",
   ".",
   "_size_compress",
   "(",
   "max_rss",
   ")",
   "else",
   ":",
   "rss_str",
   "=",
   "\"-\"",
   "inst",
   "[",
   "\"maxmem\"",
   "]",
   "=",
   "rss_str",
   "except",
   "KeyError",
   ":",
   "inst",
   "[",
   "\"maxmem\"",
   "]",
   "=",
   "\"-\"",
   "# Get read size",
   "try",
   ":",
   "rchar_values",
   "=",
   "[",
   "self",
   ".",
   "_size_coverter",
   "(",
   "x",
   "[",
   "\"rchar\"",
   "]",
   ")",
   "for",
   "x",
   "in",
   "vals",
   "if",
   "x",
   "[",
   "\"rchar\"",
   "]",
   "!=",
   "\"-\"",
   "]",
   "if",
   "rchar_values",
   ":",
   "avg_rchar",
   "=",
   "round",
   "(",
   "sum",
   "(",
   "rchar_values",
   ")",
   "/",
   "len",
   "(",
   "rchar_values",
   ")",
   ")",
   "rchar_str",
   "=",
   "self",
   ".",
   "_size_compress",
   "(",
   "avg_rchar",
   ")",
   "else",
   ":",
   "rchar_str",
   "=",
   "\"-\"",
   "except",
   "KeyError",
   ":",
   "rchar_str",
   "=",
   "\"-\"",
   "inst",
   "[",
   "\"avgread\"",
   "]",
   "=",
   "rchar_str",
   "# Get write size",
   "try",
   ":",
   "wchar_values",
   "=",
   "[",
   "self",
   ".",
   "_size_coverter",
   "(",
   "x",
   "[",
   "\"wchar\"",
   "]",
   ")",
   "for",
   "x",
   "in",
   "vals",
   "if",
   "x",
   "[",
   "\"wchar\"",
   "]",
   "!=",
   "\"-\"",
   "]",
   "if",
   "wchar_values",
   ":",
   "avg_wchar",
   "=",
   "round",
   "(",
   "sum",
   "(",
   "wchar_values",
   ")",
   "/",
   "len",
   "(",
   "wchar_values",
   ")",
   ")",
   "wchar_str",
   "=",
   "self",
   ".",
   "_size_compress",
   "(",
   "avg_wchar",
   ")",
   "else",
   ":",
   "wchar_str",
   "=",
   "\"-\"",
   "except",
   "KeyError",
   ":",
   "wchar_str",
   "=",
   "\"-\"",
   "inst",
   "[",
   "\"avgwrite\"",
   "]",
   "=",
   "wchar_str"
  ]
 },
 {
  "idx": "maxmin-1189",
  "nl_tokens": [
   "read",
   "(",
   "[",
   "size",
   "]",
   ")",
   "-",
   ">",
   "read",
   "at",
   "most",
   "size",
   "bytes",
   "returned",
   "as",
   "a",
   "string",
   "."
  ],
  "pl_tokens": [
   "def",
   "read",
   "(",
   "self",
   ",",
   "size",
   "=",
   "-",
   "1",
   ")",
   ":",
   "if",
   "self",
   ".",
   "left",
   "is",
   "not",
   "None",
   ":",
   "size",
   "=",
   "<mask>",
   "(",
   "size",
   ",",
   "self",
   ".",
   "left",
   ")",
   "if",
   "self",
   ".",
   "closed",
   ":",
   "raise",
   "ValueError",
   "(",
   "'I/O operation on closed file'",
   ")",
   "if",
   "size",
   "<",
   "0",
   ":",
   "return",
   "''",
   ".",
   "join",
   "(",
   "self",
   ")",
   "elif",
   "not",
   "size",
   ":",
   "chunk",
   "=",
   "''",
   "elif",
   "self",
   ".",
   "buf",
   ":",
   "chunk",
   "=",
   "self",
   ".",
   "buf",
   "self",
   ".",
   "buf",
   "=",
   "None",
   "else",
   ":",
   "try",
   ":",
   "chunk",
   "=",
   "next",
   "(",
   "self",
   ".",
   "iterator",
   ")",
   "except",
   "StopIteration",
   ":",
   "return",
   "''",
   "if",
   "len",
   "(",
   "chunk",
   ")",
   ">",
   "size",
   ":",
   "self",
   ".",
   "buf",
   "=",
   "chunk",
   "[",
   "size",
   ":",
   "]",
   "chunk",
   "=",
   "chunk",
   "[",
   ":",
   "size",
   "]",
   "if",
   "self",
   ".",
   "left",
   "is",
   "not",
   "None",
   ":",
   "self",
   ".",
   "left",
   "-=",
   "len",
   "(",
   "chunk",
   ")",
   "return",
   "chunk"
  ]
 },
 {
  "idx": "maxmin-1190",
  "nl_tokens": [
   "Writes",
   "a",
   "report",
   "summarizing",
   "coverage",
   "statistics",
   "per",
   "module",
   "."
  ],
  "pl_tokens": [
   "def",
   "report",
   "(",
   "self",
   ",",
   "morfs",
   ",",
   "outfile",
   "=",
   "None",
   ")",
   ":",
   "self",
   ".",
   "find_code_units",
   "(",
   "morfs",
   ")",
   "# Prepare the formatting strings",
   "max_name",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "cu",
   ".",
   "name",
   ")",
   "for",
   "cu",
   "in",
   "self",
   ".",
   "code_units",
   "]",
   "+",
   "[",
   "5",
   "]",
   ")",
   "fmt_name",
   "=",
   "\"%%- %ds  \"",
   "%",
   "max_name",
   "fmt_err",
   "=",
   "\"%s   %s: %s\\n\"",
   "header",
   "=",
   "(",
   "fmt_name",
   "%",
   "\"Name\"",
   ")",
   "+",
   "\" Stmts   Miss\"",
   "fmt_coverage",
   "=",
   "fmt_name",
   "+",
   "\"%6d %6d\"",
   "if",
   "self",
   ".",
   "branches",
   ":",
   "header",
   "+=",
   "\" Branch BrMiss\"",
   "fmt_coverage",
   "+=",
   "\" %6d %6d\"",
   "width100",
   "=",
   "Numbers",
   ".",
   "pc_str_width",
   "(",
   ")",
   "header",
   "+=",
   "\"%*s\"",
   "%",
   "(",
   "width100",
   "+",
   "4",
   ",",
   "\"Cover\"",
   ")",
   "fmt_coverage",
   "+=",
   "\"%%%ds%%%%\"",
   "%",
   "(",
   "width100",
   "+",
   "3",
   ",",
   ")",
   "if",
   "self",
   ".",
   "config",
   ".",
   "show_missing",
   ":",
   "header",
   "+=",
   "\"   Missing\"",
   "fmt_coverage",
   "+=",
   "\"   %s\"",
   "rule",
   "=",
   "\"-\"",
   "*",
   "len",
   "(",
   "header",
   ")",
   "+",
   "\"\\n\"",
   "header",
   "+=",
   "\"\\n\"",
   "fmt_coverage",
   "+=",
   "\"\\n\"",
   "if",
   "not",
   "outfile",
   ":",
   "outfile",
   "=",
   "sys",
   ".",
   "stdout",
   "# Write the header",
   "outfile",
   ".",
   "write",
   "(",
   "header",
   ")",
   "outfile",
   ".",
   "write",
   "(",
   "rule",
   ")",
   "total",
   "=",
   "Numbers",
   "(",
   ")",
   "for",
   "cu",
   "in",
   "self",
   ".",
   "code_units",
   ":",
   "try",
   ":",
   "analysis",
   "=",
   "self",
   ".",
   "coverage",
   ".",
   "_analyze",
   "(",
   "cu",
   ")",
   "nums",
   "=",
   "analysis",
   ".",
   "numbers",
   "args",
   "=",
   "(",
   "cu",
   ".",
   "name",
   ",",
   "nums",
   ".",
   "n_statements",
   ",",
   "nums",
   ".",
   "n_missing",
   ")",
   "if",
   "self",
   ".",
   "branches",
   ":",
   "args",
   "+=",
   "(",
   "nums",
   ".",
   "n_branches",
   ",",
   "nums",
   ".",
   "n_missing_branches",
   ")",
   "args",
   "+=",
   "(",
   "nums",
   ".",
   "pc_covered_str",
   ",",
   ")",
   "if",
   "self",
   ".",
   "config",
   ".",
   "show_missing",
   ":",
   "args",
   "+=",
   "(",
   "analysis",
   ".",
   "missing_formatted",
   "(",
   ")",
   ",",
   ")",
   "outfile",
   ".",
   "write",
   "(",
   "fmt_coverage",
   "%",
   "args",
   ")",
   "total",
   "+=",
   "nums",
   "except",
   "KeyboardInterrupt",
   ":",
   "# pragma: not covered",
   "raise",
   "except",
   ":",
   "report_it",
   "=",
   "not",
   "self",
   ".",
   "config",
   ".",
   "ignore_errors",
   "if",
   "report_it",
   ":",
   "typ",
   ",",
   "msg",
   "=",
   "sys",
   ".",
   "exc_info",
   "(",
   ")",
   "[",
   ":",
   "2",
   "]",
   "if",
   "typ",
   "is",
   "NotPython",
   "and",
   "not",
   "cu",
   ".",
   "should_be_python",
   "(",
   ")",
   ":",
   "report_it",
   "=",
   "False",
   "if",
   "report_it",
   ":",
   "outfile",
   ".",
   "write",
   "(",
   "fmt_err",
   "%",
   "(",
   "cu",
   ".",
   "name",
   ",",
   "typ",
   ".",
   "__name__",
   ",",
   "msg",
   ")",
   ")",
   "if",
   "total",
   ".",
   "n_files",
   ">",
   "1",
   ":",
   "outfile",
   ".",
   "write",
   "(",
   "rule",
   ")",
   "args",
   "=",
   "(",
   "\"TOTAL\"",
   ",",
   "total",
   ".",
   "n_statements",
   ",",
   "total",
   ".",
   "n_missing",
   ")",
   "if",
   "self",
   ".",
   "branches",
   ":",
   "args",
   "+=",
   "(",
   "total",
   ".",
   "n_branches",
   ",",
   "total",
   ".",
   "n_missing_branches",
   ")",
   "args",
   "+=",
   "(",
   "total",
   ".",
   "pc_covered_str",
   ",",
   ")",
   "if",
   "self",
   ".",
   "config",
   ".",
   "show_missing",
   ":",
   "args",
   "+=",
   "(",
   "\"\"",
   ",",
   ")",
   "outfile",
   ".",
   "write",
   "(",
   "fmt_coverage",
   "%",
   "args",
   ")",
   "return",
   "total",
   ".",
   "pc_covered"
  ]
 },
 {
  "idx": "maxmin-1191",
  "nl_tokens": [
   "Compactly",
   "display",
   "the",
   "internal",
   "structure",
   "of",
   "an",
   "H2OFrame",
   "."
  ],
  "pl_tokens": [
   "def",
   "structure",
   "(",
   "self",
   ")",
   ":",
   "df",
   "=",
   "self",
   ".",
   "as_data_frame",
   "(",
   "use_pandas",
   "=",
   "False",
   ")",
   "cn",
   "=",
   "df",
   ".",
   "pop",
   "(",
   "0",
   ")",
   "nr",
   "=",
   "self",
   ".",
   "nrow",
   "nc",
   "=",
   "self",
   ".",
   "ncol",
   "width",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "c",
   ")",
   "for",
   "c",
   "in",
   "cn",
   "]",
   ")",
   "isfactor",
   "=",
   "self",
   ".",
   "isfactor",
   "(",
   ")",
   "numlevels",
   "=",
   "self",
   ".",
   "nlevels",
   "(",
   ")",
   "lvls",
   "=",
   "self",
   ".",
   "levels",
   "(",
   ")",
   "print",
   "(",
   "\"H2OFrame: '{}' \\nDimensions: {} obs. of {} variables\"",
   ".",
   "format",
   "(",
   "self",
   ".",
   "frame_id",
   ",",
   "nr",
   ",",
   "nc",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "nc",
   ")",
   ":",
   "print",
   "(",
   "\"$ {} {}: \"",
   ".",
   "format",
   "(",
   "cn",
   "[",
   "i",
   "]",
   ",",
   "' '",
   "*",
   "(",
   "width",
   "-",
   "max",
   "(",
   "0",
   ",",
   "len",
   "(",
   "cn",
   "[",
   "i",
   "]",
   ")",
   ")",
   ")",
   ")",
   ",",
   "end",
   "=",
   "' '",
   ")",
   "if",
   "isfactor",
   "[",
   "i",
   "]",
   ":",
   "nl",
   "=",
   "numlevels",
   "[",
   "i",
   "]",
   "print",
   "(",
   "\"Factor w/ {} level(s) {} \"",
   ".",
   "format",
   "(",
   "nl",
   ",",
   "'\"'",
   "+",
   "'\",\"'",
   ".",
   "join",
   "(",
   "lvls",
   "[",
   "i",
   "]",
   ")",
   "+",
   "'\"'",
   ")",
   ",",
   "end",
   "=",
   "'\\n'",
   ")",
   "else",
   ":",
   "print",
   "(",
   "\"num {}\"",
   ".",
   "format",
   "(",
   "\" \"",
   ".",
   "join",
   "(",
   "it",
   "[",
   "0",
   "]",
   "if",
   "it",
   "else",
   "\"nan\"",
   "for",
   "it",
   "in",
   "h2o",
   ".",
   "as_list",
   "(",
   "self",
   "[",
   ":",
   "10",
   ",",
   "i",
   "]",
   ",",
   "False",
   ")",
   "[",
   "1",
   ":",
   "]",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1192",
  "nl_tokens": [
   "Create",
   "a",
   "dictionary",
   "of",
   "shortend",
   "UIDs",
   "for",
   "all",
   "contacts",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_short_uid_dict",
   "(",
   "self",
   ",",
   "query",
   "=",
   "None",
   ")",
   ":",
   "if",
   "self",
   ".",
   "_short_uids",
   "is",
   "None",
   ":",
   "if",
   "not",
   "self",
   ".",
   "_loaded",
   ":",
   "self",
   ".",
   "load",
   "(",
   "query",
   ")",
   "if",
   "not",
   "self",
   ".",
   "contacts",
   ":",
   "self",
   ".",
   "_short_uids",
   "=",
   "{",
   "}",
   "elif",
   "len",
   "(",
   "self",
   ".",
   "contacts",
   ")",
   "==",
   "1",
   ":",
   "self",
   ".",
   "_short_uids",
   "=",
   "{",
   "uid",
   "[",
   "0",
   ":",
   "1",
   "]",
   ":",
   "contact",
   "for",
   "uid",
   ",",
   "contact",
   "in",
   "self",
   ".",
   "contacts",
   ".",
   "items",
   "(",
   ")",
   "}",
   "else",
   ":",
   "self",
   ".",
   "_short_uids",
   "=",
   "{",
   "}",
   "sorted_uids",
   "=",
   "sorted",
   "(",
   "self",
   ".",
   "contacts",
   ")",
   "# Prepare for the loop; the first and last items are handled",
   "# seperatly.",
   "item0",
   ",",
   "item1",
   "=",
   "sorted_uids",
   "[",
   ":",
   "2",
   "]",
   "same1",
   "=",
   "self",
   ".",
   "_compare_uids",
   "(",
   "item0",
   ",",
   "item1",
   ")",
   "self",
   ".",
   "_short_uids",
   "[",
   "item0",
   "[",
   ":",
   "same1",
   "+",
   "1",
   "]",
   "]",
   "=",
   "self",
   ".",
   "contacts",
   "[",
   "item0",
   "]",
   "for",
   "item_new",
   "in",
   "sorted_uids",
   "[",
   "2",
   ":",
   "]",
   ":",
   "# shift the items and the common prefix lenght one further",
   "item0",
   ",",
   "item1",
   "=",
   "item1",
   ",",
   "item_new",
   "same0",
   ",",
   "same1",
   "=",
   "same1",
   ",",
   "self",
   ".",
   "_compare_uids",
   "(",
   "item0",
   ",",
   "item1",
   ")",
   "# compute the final prefix length for item1",
   "same",
   "=",
   "<mask>",
   "(",
   "same0",
   ",",
   "same1",
   ")",
   "self",
   ".",
   "_short_uids",
   "[",
   "item0",
   "[",
   ":",
   "same",
   "+",
   "1",
   "]",
   "]",
   "=",
   "self",
   ".",
   "contacts",
   "[",
   "item0",
   "]",
   "# Save the last item.",
   "self",
   ".",
   "_short_uids",
   "[",
   "item1",
   "[",
   ":",
   "same1",
   "+",
   "1",
   "]",
   "]",
   "=",
   "self",
   ".",
   "contacts",
   "[",
   "item1",
   "]",
   "return",
   "self",
   ".",
   "_short_uids"
  ]
 },
 {
  "idx": "maxmin-1193",
  "nl_tokens": [
   "Align",
   "numbers",
   "in",
   "*",
   "data",
   "*",
   "on",
   "their",
   "decimal",
   "points",
   "."
  ],
  "pl_tokens": [
   "def",
   "align_decimals",
   "(",
   "data",
   ",",
   "headers",
   ",",
   "column_types",
   "=",
   "(",
   ")",
   ",",
   "*",
   "*",
   "_",
   ")",
   ":",
   "pointpos",
   "=",
   "len",
   "(",
   "headers",
   ")",
   "*",
   "[",
   "0",
   "]",
   "data",
   "=",
   "list",
   "(",
   "data",
   ")",
   "for",
   "row",
   "in",
   "data",
   ":",
   "for",
   "i",
   ",",
   "v",
   "in",
   "enumerate",
   "(",
   "row",
   ")",
   ":",
   "if",
   "column_types",
   "[",
   "i",
   "]",
   "is",
   "float",
   "and",
   "type",
   "(",
   "v",
   ")",
   "in",
   "float_types",
   ":",
   "v",
   "=",
   "text_type",
   "(",
   "v",
   ")",
   "pointpos",
   "[",
   "i",
   "]",
   "=",
   "<mask>",
   "(",
   "utils",
   ".",
   "intlen",
   "(",
   "v",
   ")",
   ",",
   "pointpos",
   "[",
   "i",
   "]",
   ")",
   "def",
   "results",
   "(",
   "data",
   ")",
   ":",
   "for",
   "row",
   "in",
   "data",
   ":",
   "result",
   "=",
   "[",
   "]",
   "for",
   "i",
   ",",
   "v",
   "in",
   "enumerate",
   "(",
   "row",
   ")",
   ":",
   "if",
   "column_types",
   "[",
   "i",
   "]",
   "is",
   "float",
   "and",
   "type",
   "(",
   "v",
   ")",
   "in",
   "float_types",
   ":",
   "v",
   "=",
   "text_type",
   "(",
   "v",
   ")",
   "result",
   ".",
   "append",
   "(",
   "(",
   "pointpos",
   "[",
   "i",
   "]",
   "-",
   "utils",
   ".",
   "intlen",
   "(",
   "v",
   ")",
   ")",
   "*",
   "\" \"",
   "+",
   "v",
   ")",
   "else",
   ":",
   "result",
   ".",
   "append",
   "(",
   "v",
   ")",
   "yield",
   "result",
   "return",
   "results",
   "(",
   "data",
   ")",
   ",",
   "headers"
  ]
 },
 {
  "idx": "maxmin-1194",
  "nl_tokens": [
   "A",
   "sqrt",
   "function",
   "whose",
   "gradient",
   "at",
   "zero",
   "is",
   "very",
   "large",
   "but",
   "finite",
   "."
  ],
  "pl_tokens": [
   "def",
   "sqrt_with_finite_grads",
   "(",
   "x",
   ",",
   "name",
   "=",
   "None",
   ")",
   ":",
   "with",
   "tf",
   ".",
   "compat",
   ".",
   "v1",
   ".",
   "name_scope",
   "(",
   "name",
   ",",
   "'sqrt_with_finite_grads'",
   ",",
   "[",
   "x",
   "]",
   ")",
   ":",
   "x",
   "=",
   "tf",
   ".",
   "convert_to_tensor",
   "(",
   "value",
   "=",
   "x",
   ",",
   "name",
   "=",
   "'x'",
   ")",
   "if",
   "not",
   "x",
   ".",
   "dtype",
   ".",
   "is_floating",
   ":",
   "raise",
   "TypeError",
   "(",
   "'Input `x` must be floating type.'",
   ")",
   "def",
   "grad",
   "(",
   "grad_ys",
   ")",
   ":",
   "large_float_like_x",
   "=",
   "np",
   ".",
   "sqrt",
   "(",
   "np",
   ".",
   "finfo",
   "(",
   "x",
   ".",
   "dtype",
   ".",
   "as_numpy_dtype",
   "(",
   ")",
   ")",
   ".",
   "<mask>",
   ")",
   "safe_grads",
   "=",
   "tf",
   ".",
   "where",
   "(",
   "tf",
   ".",
   "equal",
   "(",
   "x",
   ",",
   "0",
   ")",
   ",",
   "tf",
   ".",
   "fill",
   "(",
   "tf",
   ".",
   "shape",
   "(",
   "input",
   "=",
   "x",
   ")",
   ",",
   "large_float_like_x",
   ")",
   ",",
   "0.5",
   "*",
   "tf",
   ".",
   "math",
   ".",
   "rsqrt",
   "(",
   "x",
   ")",
   ")",
   "return",
   "grad_ys",
   "*",
   "safe_grads",
   "return",
   "tf",
   ".",
   "sqrt",
   "(",
   "x",
   ")",
   ",",
   "grad"
  ]
 },
 {
  "idx": "maxmin-1195",
  "nl_tokens": [
   "return",
   "a",
   "normalized",
   "version",
   "of",
   "a",
   "profile",
   "matrix"
  ],
  "pl_tokens": [
   "def",
   "normalize_profile",
   "(",
   "in_profile",
   ",",
   "log",
   "=",
   "False",
   ",",
   "return_offset",
   "=",
   "True",
   ")",
   ":",
   "if",
   "log",
   ":",
   "tmp_prefactor",
   "=",
   "in_profile",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "tmp_prof",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "in_profile",
   ".",
   "T",
   "-",
   "tmp_prefactor",
   ")",
   ".",
   "T",
   "else",
   ":",
   "tmp_prefactor",
   "=",
   "0.0",
   "tmp_prof",
   "=",
   "in_profile",
   "norm_vector",
   "=",
   "tmp_prof",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "return",
   "(",
   "np",
   ".",
   "copy",
   "(",
   "np",
   ".",
   "einsum",
   "(",
   "'ai,a->ai'",
   ",",
   "tmp_prof",
   ",",
   "1.0",
   "/",
   "norm_vector",
   ")",
   ")",
   ",",
   "(",
   "np",
   ".",
   "log",
   "(",
   "norm_vector",
   ")",
   "+",
   "tmp_prefactor",
   ")",
   "if",
   "return_offset",
   "else",
   "None",
   ")"
  ]
 },
 {
  "idx": "maxmin-1196",
  "nl_tokens": [
   "r",
   "Return",
   "the",
   "independent",
   "variable",
   "point",
   "associated",
   "with",
   "a",
   "dependent",
   "variable",
   "point",
   "."
  ],
  "pl_tokens": [
   "def",
   "find",
   "(",
   "wave",
   ",",
   "dep_var",
   ",",
   "der",
   "=",
   "None",
   ",",
   "inst",
   "=",
   "1",
   ",",
   "indep_min",
   "=",
   "None",
   ",",
   "indep_max",
   "=",
   "None",
   ")",
   ":",
   "# pylint: disable=C0325,R0914,W0613",
   "ret",
   "=",
   "copy",
   ".",
   "copy",
   "(",
   "wave",
   ")",
   "_bound_waveform",
   "(",
   "ret",
   ",",
   "indep_min",
   ",",
   "indep_max",
   ")",
   "close_min",
   "=",
   "np",
   ".",
   "isclose",
   "(",
   "<mask>",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")",
   ",",
   "dep_var",
   ",",
   "FP_RTOL",
   ",",
   "FP_ATOL",
   ")",
   "close_max",
   "=",
   "np",
   ".",
   "isclose",
   "(",
   "max",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")",
   ",",
   "dep_var",
   ",",
   "FP_RTOL",
   ",",
   "FP_ATOL",
   ")",
   "if",
   "(",
   "(",
   "np",
   ".",
   "amin",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")",
   ">",
   "dep_var",
   ")",
   "and",
   "(",
   "not",
   "close_min",
   ")",
   ")",
   "or",
   "(",
   "(",
   "np",
   ".",
   "amax",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ")",
   "<",
   "dep_var",
   ")",
   "and",
   "(",
   "not",
   "close_max",
   ")",
   ")",
   ":",
   "return",
   "None",
   "cross_wave",
   "=",
   "ret",
   ".",
   "_dep_vector",
   "-",
   "dep_var",
   "sign_wave",
   "=",
   "np",
   ".",
   "sign",
   "(",
   "cross_wave",
   ")",
   "exact_idx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "isclose",
   "(",
   "ret",
   ".",
   "_dep_vector",
   ",",
   "dep_var",
   ",",
   "FP_RTOL",
   ",",
   "FP_ATOL",
   ")",
   ")",
   "[",
   "0",
   "]",
   "# Locations where dep_vector crosses dep_var or it is equal to it",
   "left_idx",
   "=",
   "np",
   ".",
   "where",
   "(",
   "np",
   ".",
   "diff",
   "(",
   "sign_wave",
   ")",
   ")",
   "[",
   "0",
   "]",
   "# Remove elements to the left of exact matches",
   "left_idx",
   "=",
   "np",
   ".",
   "setdiff1d",
   "(",
   "left_idx",
   ",",
   "exact_idx",
   ")",
   "left_idx",
   "=",
   "np",
   ".",
   "setdiff1d",
   "(",
   "left_idx",
   ",",
   "exact_idx",
   "-",
   "1",
   ")",
   "right_idx",
   "=",
   "left_idx",
   "+",
   "1",
   "if",
   "left_idx",
   ".",
   "size",
   "else",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "indep_var",
   "=",
   "ret",
   ".",
   "_indep_vector",
   "[",
   "exact_idx",
   "]",
   "if",
   "exact_idx",
   ".",
   "size",
   "else",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "dvector",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "exact_idx",
   ".",
   "size",
   ")",
   ".",
   "astype",
   "(",
   "int",
   ")",
   "if",
   "exact_idx",
   ".",
   "size",
   "else",
   "np",
   ".",
   "array",
   "(",
   "[",
   "]",
   ")",
   "if",
   "left_idx",
   ".",
   "size",
   "and",
   "(",
   "ret",
   ".",
   "interp",
   "==",
   "\"STAIRCASE\"",
   ")",
   ":",
   "idvector",
   "=",
   "(",
   "2.0",
   "*",
   "(",
   "ret",
   ".",
   "_dep_vector",
   "[",
   "right_idx",
   "]",
   ">",
   "ret",
   ".",
   "_dep_vector",
   "[",
   "left_idx",
   "]",
   ")",
   ".",
   "astype",
   "(",
   "int",
   ")",
   "-",
   "1",
   ")",
   "if",
   "indep_var",
   ".",
   "size",
   ":",
   "indep_var",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "indep_var",
   ",",
   "ret",
   ".",
   "_indep_vector",
   "[",
   "right_idx",
   "]",
   ")",
   ")",
   "dvector",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "dvector",
   ",",
   "idvector",
   ")",
   ")",
   "sidx",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "indep_var",
   ")",
   "indep_var",
   "=",
   "indep_var",
   "[",
   "sidx",
   "]",
   "dvector",
   "=",
   "dvector",
   "[",
   "sidx",
   "]",
   "else",
   ":",
   "indep_var",
   "=",
   "ret",
   ".",
   "_indep_vector",
   "[",
   "right_idx",
   "]",
   "dvector",
   "=",
   "idvector",
   "elif",
   "left_idx",
   ".",
   "size",
   ":",
   "y_left",
   "=",
   "ret",
   ".",
   "_dep_vector",
   "[",
   "left_idx",
   "]",
   "y_right",
   "=",
   "ret",
   ".",
   "_dep_vector",
   "[",
   "right_idx",
   "]",
   "x_left",
   "=",
   "ret",
   ".",
   "_indep_vector",
   "[",
   "left_idx",
   "]",
   "x_right",
   "=",
   "ret",
   ".",
   "_indep_vector",
   "[",
   "right_idx",
   "]",
   "slope",
   "=",
   "(",
   "(",
   "y_left",
   "-",
   "y_right",
   ")",
   "/",
   "(",
   "x_left",
   "-",
   "x_right",
   ")",
   ")",
   ".",
   "astype",
   "(",
   "float",
   ")",
   "# y = y0+slope*(x-x0) => x0+(y-y0)/slope",
   "if",
   "indep_var",
   ".",
   "size",
   ":",
   "indep_var",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "indep_var",
   ",",
   "x_left",
   "+",
   "(",
   "(",
   "dep_var",
   "-",
   "y_left",
   ")",
   "/",
   "slope",
   ")",
   ")",
   ")",
   "dvector",
   "=",
   "np",
   ".",
   "concatenate",
   "(",
   "(",
   "dvector",
   ",",
   "np",
   ".",
   "where",
   "(",
   "slope",
   ">",
   "0",
   ",",
   "1",
   ",",
   "-",
   "1",
   ")",
   ")",
   ")",
   "sidx",
   "=",
   "np",
   ".",
   "argsort",
   "(",
   "indep_var",
   ")",
   "indep_var",
   "=",
   "indep_var",
   "[",
   "sidx",
   "]",
   "dvector",
   "=",
   "dvector",
   "[",
   "sidx",
   "]",
   "else",
   ":",
   "indep_var",
   "=",
   "x_left",
   "+",
   "(",
   "(",
   "dep_var",
   "-",
   "y_left",
   ")",
   "/",
   "slope",
   ")",
   "dvector",
   "=",
   "np",
   ".",
   "where",
   "(",
   "slope",
   ">",
   "0",
   ",",
   "+",
   "1",
   ",",
   "-",
   "1",
   ")",
   "if",
   "der",
   "is",
   "not",
   "None",
   ":",
   "indep_var",
   "=",
   "np",
   ".",
   "extract",
   "(",
   "dvector",
   "==",
   "der",
   ",",
   "indep_var",
   ")",
   "return",
   "indep_var",
   "[",
   "inst",
   "-",
   "1",
   "]",
   "if",
   "inst",
   "<=",
   "indep_var",
   ".",
   "size",
   "else",
   "None"
  ]
 },
 {
  "idx": "maxmin-1197",
  "nl_tokens": [
   "Determine",
   "a",
   "new",
   "random",
   "value",
   "derived",
   "from",
   "the",
   "defined",
   ":",
   "any",
   ":",
   "gramfuzz",
   ".",
   "fields",
   ".",
   "Field",
   ".",
   "odds",
   "value",
   "."
  ],
  "pl_tokens": [
   "def",
   "_odds_val",
   "(",
   "self",
   ")",
   ":",
   "if",
   "len",
   "(",
   "self",
   ".",
   "odds",
   ")",
   "==",
   "0",
   ":",
   "self",
   ".",
   "odds",
   "=",
   "[",
   "(",
   "1.00",
   ",",
   "[",
   "self",
   ".",
   "<mask>",
   ",",
   "self",
   ".",
   "max",
   "]",
   ")",
   "]",
   "rand_val",
   "=",
   "rand",
   ".",
   "random",
   "(",
   ")",
   "total",
   "=",
   "0",
   "for",
   "percent",
   ",",
   "v",
   "in",
   "self",
   ".",
   "odds",
   ":",
   "if",
   "total",
   "<=",
   "rand_val",
   "<",
   "total",
   "+",
   "percent",
   ":",
   "found_v",
   "=",
   "v",
   "break",
   "total",
   "+=",
   "percent",
   "res",
   "=",
   "None",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "(",
   "tuple",
   ",",
   "list",
   ")",
   ")",
   ":",
   "rand_func",
   "=",
   "rand",
   ".",
   "randfloat",
   "if",
   "type",
   "(",
   "v",
   "[",
   "0",
   "]",
   ")",
   "is",
   "float",
   "else",
   "rand",
   ".",
   "randint",
   "if",
   "len",
   "(",
   "v",
   ")",
   "==",
   "2",
   ":",
   "res",
   "=",
   "rand_func",
   "(",
   "v",
   "[",
   "0",
   "]",
   ",",
   "v",
   "[",
   "1",
   "]",
   ")",
   "elif",
   "len",
   "(",
   "v",
   ")",
   "==",
   "1",
   ":",
   "res",
   "=",
   "v",
   "[",
   "0",
   "]",
   "else",
   ":",
   "res",
   "=",
   "v",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-1198",
  "nl_tokens": [
   "Returns",
   "a",
   "4",
   "-",
   "tuple",
   "pixel",
   "window",
   "(",
   "x_offset",
   "y_offset",
   "x_size",
   "y_size",
   ")",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_offset",
   "(",
   "self",
   ",",
   "envelope",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "envelope",
   ",",
   "collections",
   ".",
   "Sequence",
   ")",
   ":",
   "envelope",
   "=",
   "Envelope",
   "(",
   "envelope",
   ")",
   "if",
   "not",
   "(",
   "self",
   ".",
   "envelope",
   ".",
   "contains",
   "(",
   "envelope",
   ")",
   "or",
   "self",
   ".",
   "envelope",
   ".",
   "intersects",
   "(",
   "envelope",
   ")",
   ")",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Envelope does not intersect with this extent'",
   ")",
   "coords",
   "=",
   "self",
   ".",
   "affine",
   ".",
   "transform",
   "(",
   "(",
   "envelope",
   ".",
   "ul",
   ",",
   "envelope",
   ".",
   "lr",
   ")",
   ")",
   "nxy",
   "=",
   "[",
   "(",
   "<mask>",
   "(",
   "dest",
   ",",
   "size",
   ")",
   "-",
   "origin",
   ")",
   "or",
   "1",
   "for",
   "size",
   ",",
   "origin",
   ",",
   "dest",
   "in",
   "zip",
   "(",
   "self",
   ".",
   "size",
   ",",
   "*",
   "coords",
   ")",
   "]",
   "return",
   "coords",
   "[",
   "0",
   "]",
   "+",
   "tuple",
   "(",
   "nxy",
   ")"
  ]
 },
 {
  "idx": "maxmin-1199",
  "nl_tokens": [
   "Input",
   "-",
   "the",
   "list",
   "of",
   "reels",
   "jsons",
   "They",
   "can",
   "be",
   "aquired",
   "by",
   "using",
   "get_users_reel",
   "()",
   "or",
   "get_user_reel",
   "()",
   "methods"
  ],
  "pl_tokens": [
   "def",
   "see_reels",
   "(",
   "self",
   ",",
   "reels",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "reels",
   ",",
   "list",
   ")",
   ":",
   "reels",
   "=",
   "[",
   "reels",
   "]",
   "story_seen",
   "=",
   "{",
   "}",
   "now",
   "=",
   "int",
   "(",
   "time",
   ".",
   "time",
   "(",
   ")",
   ")",
   "for",
   "i",
   ",",
   "story",
   "in",
   "enumerate",
   "(",
   "sorted",
   "(",
   "reels",
   ",",
   "key",
   "=",
   "lambda",
   "m",
   ":",
   "m",
   "[",
   "'taken_at'",
   "]",
   ",",
   "reverse",
   "=",
   "True",
   ")",
   ")",
   ":",
   "story_seen_at",
   "=",
   "now",
   "-",
   "<mask>",
   "(",
   "i",
   "+",
   "1",
   "+",
   "random",
   ".",
   "randint",
   "(",
   "0",
   ",",
   "2",
   ")",
   ",",
   "max",
   "(",
   "0",
   ",",
   "now",
   "-",
   "story",
   "[",
   "'taken_at'",
   "]",
   ")",
   ")",
   "story_seen",
   "[",
   "'{0!s}_{1!s}'",
   ".",
   "format",
   "(",
   "story",
   "[",
   "'id'",
   "]",
   ",",
   "story",
   "[",
   "'user'",
   "]",
   "[",
   "'pk'",
   "]",
   ")",
   "]",
   "=",
   "[",
   "'{0!s}_{1!s}'",
   ".",
   "format",
   "(",
   "story",
   "[",
   "'taken_at'",
   "]",
   ",",
   "story_seen_at",
   ")",
   "]",
   "data",
   "=",
   "self",
   ".",
   "json_data",
   "(",
   "{",
   "'reels'",
   ":",
   "story_seen",
   ",",
   "'_csrftoken'",
   ":",
   "self",
   ".",
   "token",
   ",",
   "'_uuid'",
   ":",
   "self",
   ".",
   "uuid",
   ",",
   "'_uid'",
   ":",
   "self",
   ".",
   "user_id",
   "}",
   ")",
   "data",
   "=",
   "self",
   ".",
   "generate_signature",
   "(",
   "data",
   ")",
   "return",
   "self",
   ".",
   "session",
   ".",
   "post",
   "(",
   "'https://i.instagram.com/api/v2/'",
   "+",
   "'media/seen/'",
   ",",
   "data",
   "=",
   "data",
   ")",
   ".",
   "ok"
  ]
 },
 {
  "idx": "maxmin-1200",
  "nl_tokens": [
   "Generator",
   "that",
   "encrypts",
   "a",
   "content",
   "stream",
   "using",
   "AES",
   "256",
   "in",
   "CBC",
   "mode",
   "."
  ],
  "pl_tokens": [
   "def",
   "aes_encrypt",
   "(",
   "key",
   ",",
   "stdin",
   ",",
   "preamble",
   "=",
   "None",
   ",",
   "chunk_size",
   "=",
   "65536",
   ",",
   "content_length",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "AES256CBC_Support",
   ":",
   "raise",
   "Exception",
   "(",
   "'AES256CBC not supported; likely pycrypto is not installed'",
   ")",
   "if",
   "preamble",
   ":",
   "yield",
   "preamble",
   "# Always use 256-bit key",
   "key",
   "=",
   "hashlib",
   ".",
   "sha256",
   "(",
   "key",
   ")",
   ".",
   "digest",
   "(",
   ")",
   "# At least 16 and a multiple of 16",
   "chunk_size",
   "=",
   "<mask>",
   "(",
   "16",
   ",",
   "chunk_size",
   ">>",
   "4",
   "<<",
   "4",
   ")",
   "iv",
   "=",
   "Crypto",
   ".",
   "Random",
   ".",
   "new",
   "(",
   ")",
   ".",
   "read",
   "(",
   "16",
   ")",
   "yield",
   "iv",
   "encryptor",
   "=",
   "Crypto",
   ".",
   "Cipher",
   ".",
   "AES",
   ".",
   "new",
   "(",
   "key",
   ",",
   "Crypto",
   ".",
   "Cipher",
   ".",
   "AES",
   ".",
   "MODE_CBC",
   ",",
   "iv",
   ")",
   "reading",
   "=",
   "True",
   "left",
   "=",
   "None",
   "if",
   "content_length",
   "is",
   "not",
   "None",
   "and",
   "content_length",
   ">=",
   "0",
   ":",
   "left",
   "=",
   "content_length",
   "while",
   "reading",
   ":",
   "size",
   "=",
   "chunk_size",
   "if",
   "left",
   "is",
   "not",
   "None",
   "and",
   "size",
   ">",
   "left",
   ":",
   "size",
   "=",
   "left",
   "chunk",
   "=",
   "stdin",
   ".",
   "read",
   "(",
   "size",
   ")",
   "if",
   "not",
   "chunk",
   ":",
   "if",
   "left",
   "is",
   "not",
   "None",
   "and",
   "left",
   ">",
   "0",
   ":",
   "raise",
   "IOError",
   "(",
   "'Early EOF from input'",
   ")",
   "# Indicates how many usable bytes in last block",
   "yield",
   "encryptor",
   ".",
   "encrypt",
   "(",
   "'\\x00'",
   "*",
   "16",
   ")",
   "break",
   "if",
   "left",
   "is",
   "not",
   "None",
   ":",
   "left",
   "-=",
   "len",
   "(",
   "chunk",
   ")",
   "if",
   "left",
   "<=",
   "0",
   ":",
   "reading",
   "=",
   "False",
   "block",
   "=",
   "chunk",
   "trailing",
   "=",
   "len",
   "(",
   "block",
   ")",
   "%",
   "16",
   "while",
   "trailing",
   ":",
   "size",
   "=",
   "16",
   "-",
   "trailing",
   "if",
   "left",
   "is",
   "not",
   "None",
   "and",
   "size",
   ">",
   "left",
   ":",
   "size",
   "=",
   "left",
   "chunk",
   "=",
   "stdin",
   ".",
   "read",
   "(",
   "size",
   ")",
   "if",
   "not",
   "chunk",
   ":",
   "if",
   "left",
   "is",
   "not",
   "None",
   "and",
   "left",
   ">",
   "0",
   ":",
   "raise",
   "IOError",
   "(",
   "'Early EOF from input'",
   ")",
   "reading",
   "=",
   "False",
   "# Indicates how many usable bytes in last block",
   "chunk",
   "=",
   "chr",
   "(",
   "trailing",
   ")",
   "*",
   "(",
   "16",
   "-",
   "trailing",
   ")",
   "elif",
   "left",
   "is",
   "not",
   "None",
   ":",
   "left",
   "-=",
   "len",
   "(",
   "chunk",
   ")",
   "if",
   "left",
   "<=",
   "0",
   ":",
   "reading",
   "=",
   "False",
   "block",
   "+=",
   "chunk",
   "trailing",
   "=",
   "len",
   "(",
   "block",
   ")",
   "%",
   "16",
   "yield",
   "encryptor",
   ".",
   "encrypt",
   "(",
   "block",
   ")"
  ]
 },
 {
  "idx": "maxmin-1201",
  "nl_tokens": [
   "Handles",
   "parsing",
   "Xdot",
   "drawing",
   "directives",
   "."
  ],
  "pl_tokens": [
   "def",
   "_parse_xdot_directive",
   "(",
   "self",
   ",",
   "name",
   ",",
   "new",
   ")",
   ":",
   "parser",
   "=",
   "XdotAttrParser",
   "(",
   ")",
   "components",
   "=",
   "parser",
   ".",
   "parse_xdot_data",
   "(",
   "new",
   ")",
   "# The absolute coordinate of the drawing container wrt graph origin.",
   "x1",
   "=",
   "<mask>",
   "(",
   "[",
   "c",
   ".",
   "x",
   "for",
   "c",
   "in",
   "components",
   "]",
   ")",
   "y1",
   "=",
   "min",
   "(",
   "[",
   "c",
   ".",
   "y",
   "for",
   "c",
   "in",
   "components",
   "]",
   ")",
   "print",
   "\"X1/Y1:\"",
   ",",
   "name",
   ",",
   "x1",
   ",",
   "y1",
   "# Components are positioned relative to their container. This",
   "# function positions the bottom-left corner of the components at",
   "# their origin rather than relative to the graph.",
   "#        move_to_origin( components )",
   "for",
   "c",
   "in",
   "components",
   ":",
   "if",
   "isinstance",
   "(",
   "c",
   ",",
   "Ellipse",
   ")",
   ":",
   "component",
   ".",
   "x_origin",
   "-=",
   "x1",
   "component",
   ".",
   "y_origin",
   "-=",
   "y1",
   "#                c.position = [ c.x - x1, c.y - y1 ]",
   "elif",
   "isinstance",
   "(",
   "c",
   ",",
   "(",
   "Polygon",
   ",",
   "BSpline",
   ")",
   ")",
   ":",
   "print",
   "\"Points:\"",
   ",",
   "c",
   ".",
   "points",
   "c",
   ".",
   "points",
   "=",
   "[",
   "(",
   "t",
   "[",
   "0",
   "]",
   "-",
   "x1",
   ",",
   "t",
   "[",
   "1",
   "]",
   "-",
   "y1",
   ")",
   "for",
   "t",
   "in",
   "c",
   ".",
   "points",
   "]",
   "print",
   "\"Points:\"",
   ",",
   "c",
   ".",
   "points",
   "elif",
   "isinstance",
   "(",
   "c",
   ",",
   "Text",
   ")",
   ":",
   "#                font = str_to_font( str(c.pen.font) )",
   "c",
   ".",
   "text_x",
   ",",
   "c",
   ".",
   "text_y",
   "=",
   "c",
   ".",
   "x",
   "-",
   "x1",
   ",",
   "c",
   ".",
   "y",
   "-",
   "y1",
   "container",
   "=",
   "Container",
   "(",
   "auto_size",
   "=",
   "True",
   ",",
   "position",
   "=",
   "[",
   "x1",
   ",",
   "y1",
   "]",
   ",",
   "bgcolor",
   "=",
   "\"yellow\"",
   ")",
   "container",
   ".",
   "add",
   "(",
   "*",
   "components",
   ")",
   "if",
   "name",
   "==",
   "\"_draw_\"",
   ":",
   "self",
   ".",
   "drawing",
   "=",
   "container",
   "elif",
   "name",
   "==",
   "\"_hdraw_\"",
   ":",
   "self",
   ".",
   "arrowhead_drawing",
   "=",
   "container",
   "else",
   ":",
   "raise"
  ]
 },
 {
  "idx": "maxmin-1202",
  "nl_tokens": [
   "Gets",
   "the",
   "maximum",
   "length",
   "of",
   "each",
   "column",
   "in",
   "the",
   "field",
   "table"
  ],
  "pl_tokens": [
   "def",
   "getFieldsColumnLengths",
   "(",
   "self",
   ")",
   ":",
   "nameLen",
   "=",
   "0",
   "descLen",
   "=",
   "0",
   "for",
   "f",
   "in",
   "self",
   ".",
   "fields",
   ":",
   "nameLen",
   "=",
   "<mask>",
   "(",
   "nameLen",
   ",",
   "len",
   "(",
   "f",
   "[",
   "'title'",
   "]",
   ")",
   ")",
   "descLen",
   "=",
   "max",
   "(",
   "descLen",
   ",",
   "len",
   "(",
   "f",
   "[",
   "'description'",
   "]",
   ")",
   ")",
   "return",
   "(",
   "nameLen",
   ",",
   "descLen",
   ")"
  ]
 },
 {
  "idx": "maxmin-1203",
  "nl_tokens": [
   "Generate",
   "the",
   "next",
   "annotation",
   "id",
   "this",
   "function",
   "is",
   "mainly",
   "used",
   "internally",
   "."
  ],
  "pl_tokens": [
   "def",
   "generate_annotation_id",
   "(",
   "self",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "maxaid",
   ":",
   "valid_anns",
   "=",
   "[",
   "int",
   "(",
   "''",
   ".",
   "join",
   "(",
   "filter",
   "(",
   "str",
   ".",
   "isdigit",
   ",",
   "a",
   ")",
   ")",
   ")",
   "for",
   "a",
   "in",
   "self",
   ".",
   "timeslots",
   "]",
   "self",
   ".",
   "maxaid",
   "=",
   "<mask>",
   "(",
   "valid_anns",
   "+",
   "[",
   "1",
   "]",
   ")",
   "+",
   "1",
   "else",
   ":",
   "self",
   ".",
   "maxaid",
   "+=",
   "1",
   "return",
   "'a{:d}'",
   ".",
   "format",
   "(",
   "self",
   ".",
   "maxaid",
   ")"
  ]
 },
 {
  "idx": "maxmin-1204",
  "nl_tokens": [
   "Find",
   "the",
   "global",
   "minimum",
   "of",
   "a",
   "function",
   "represented",
   "as",
   "an",
   "interpolation",
   "object",
   "."
  ],
  "pl_tokens": [
   "def",
   "min_interp",
   "(",
   "interp_object",
   ")",
   ":",
   "try",
   ":",
   "return",
   "interp_object",
   ".",
   "x",
   "[",
   "interp_object",
   "(",
   "interp_object",
   ".",
   "x",
   ")",
   ".",
   "argmin",
   "(",
   ")",
   "]",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "s",
   "=",
   "\"Cannot find minimum of the interpolation object\"",
   "+",
   "str",
   "(",
   "interp_object",
   ".",
   "x",
   ")",
   "+",
   "\"Minimal x: \"",
   "+",
   "str",
   "(",
   "interp_object",
   ".",
   "x",
   ".",
   "<mask>",
   "(",
   ")",
   ")",
   "+",
   "\"Maximal x: \"",
   "+",
   "str",
   "(",
   "interp_object",
   ".",
   "x",
   ".",
   "max",
   "(",
   ")",
   ")",
   "raise",
   "e"
  ]
 },
 {
  "idx": "maxmin-1205",
  "nl_tokens": [
   "Walk",
   "enumerated",
   "words",
   "in",
   "this",
   "frame"
  ],
  "pl_tokens": [
   "def",
   "walkWords",
   "(",
   "self",
   ",",
   "showPadding",
   ":",
   "bool",
   "=",
   "False",
   ")",
   ":",
   "wIndex",
   "=",
   "0",
   "lastEnd",
   "=",
   "self",
   ".",
   "startBitAddr",
   "parts",
   "=",
   "[",
   "]",
   "for",
   "p",
   "in",
   "self",
   ".",
   "parts",
   ":",
   "end",
   "=",
   "p",
   ".",
   "startOfPart",
   "if",
   "showPadding",
   "and",
   "end",
   "!=",
   "lastEnd",
   ":",
   "# insert padding",
   "while",
   "end",
   "!=",
   "lastEnd",
   ":",
   "assert",
   "end",
   ">=",
   "lastEnd",
   ",",
   "(",
   "end",
   ",",
   "lastEnd",
   ")",
   "endOfWord",
   "=",
   "ceil",
   "(",
   "(",
   "lastEnd",
   "+",
   "1",
   ")",
   "/",
   "self",
   ".",
   "wordWidth",
   ")",
   "*",
   "self",
   ".",
   "wordWidth",
   "endOfPadding",
   "=",
   "<mask>",
   "(",
   "endOfWord",
   ",",
   "end",
   ")",
   "_p",
   "=",
   "TransPart",
   "(",
   "self",
   ",",
   "None",
   ",",
   "lastEnd",
   ",",
   "endOfPadding",
   ",",
   "0",
   ")",
   "parts",
   ".",
   "append",
   "(",
   "_p",
   ")",
   "if",
   "endOfPadding",
   ">=",
   "endOfWord",
   ":",
   "yield",
   "(",
   "wIndex",
   ",",
   "parts",
   ")",
   "wIndex",
   "+=",
   "1",
   "parts",
   "=",
   "[",
   "]",
   "lastEnd",
   "=",
   "endOfPadding",
   "if",
   "self",
   ".",
   "_wordIndx",
   "(",
   "lastEnd",
   ")",
   "!=",
   "self",
   ".",
   "_wordIndx",
   "(",
   "p",
   ".",
   "startOfPart",
   ")",
   ":",
   "yield",
   "(",
   "wIndex",
   ",",
   "parts",
   ")",
   "wIndex",
   "+=",
   "1",
   "parts",
   "=",
   "[",
   "]",
   "lastEnd",
   "=",
   "p",
   ".",
   "endOfPart",
   "parts",
   ".",
   "append",
   "(",
   "p",
   ")",
   "lastEnd",
   "=",
   "p",
   ".",
   "endOfPart",
   "if",
   "lastEnd",
   "%",
   "self",
   ".",
   "wordWidth",
   "==",
   "0",
   ":",
   "yield",
   "(",
   "wIndex",
   ",",
   "parts",
   ")",
   "wIndex",
   "+=",
   "1",
   "parts",
   "=",
   "[",
   "]",
   "if",
   "showPadding",
   "and",
   "(",
   "parts",
   "or",
   "lastEnd",
   "!=",
   "self",
   ".",
   "endBitAddr",
   "or",
   "lastEnd",
   "%",
   "self",
   ".",
   "wordWidth",
   "!=",
   "0",
   ")",
   ":",
   "# align end to end of last word",
   "end",
   "=",
   "ceil",
   "(",
   "self",
   ".",
   "endBitAddr",
   "/",
   "self",
   ".",
   "wordWidth",
   ")",
   "*",
   "self",
   ".",
   "wordWidth",
   "while",
   "end",
   "!=",
   "lastEnd",
   ":",
   "assert",
   "end",
   ">=",
   "lastEnd",
   ",",
   "(",
   "end",
   ",",
   "lastEnd",
   ")",
   "endOfWord",
   "=",
   "(",
   "(",
   "lastEnd",
   "//",
   "self",
   ".",
   "wordWidth",
   ")",
   "+",
   "1",
   ")",
   "*",
   "self",
   ".",
   "wordWidth",
   "endOfPadding",
   "=",
   "min",
   "(",
   "endOfWord",
   ",",
   "end",
   ")",
   "_p",
   "=",
   "TransPart",
   "(",
   "self",
   ",",
   "None",
   ",",
   "lastEnd",
   ",",
   "endOfPadding",
   ",",
   "0",
   ")",
   "_p",
   ".",
   "parent",
   "=",
   "self",
   "parts",
   ".",
   "append",
   "(",
   "_p",
   ")",
   "if",
   "endOfPadding",
   ">=",
   "endOfWord",
   ":",
   "yield",
   "(",
   "wIndex",
   ",",
   "parts",
   ")",
   "wIndex",
   "+=",
   "1",
   "parts",
   "=",
   "[",
   "]",
   "lastEnd",
   "=",
   "endOfPadding",
   "if",
   "parts",
   ":",
   "# in the case end of frame is not aligned to end of word",
   "yield",
   "(",
   "wIndex",
   ",",
   "parts",
   ")"
  ]
 },
 {
  "idx": "maxmin-1206",
  "nl_tokens": [
   "Return",
   "circuit",
   "depth",
   "(",
   "i",
   ".",
   "e",
   ".",
   "length",
   "of",
   "critical",
   "path",
   ")",
   ".",
   "This",
   "does",
   "not",
   "include",
   "compiler",
   "or",
   "simulator",
   "directives",
   "such",
   "as",
   "barrier",
   "or",
   "snapshot",
   "."
  ],
  "pl_tokens": [
   "def",
   "depth",
   "(",
   "self",
   ")",
   ":",
   "# Labels the registers by ints",
   "# and then the qubit position in",
   "# a register is given by reg_int+qubit_num",
   "reg_offset",
   "=",
   "0",
   "reg_map",
   "=",
   "{",
   "}",
   "for",
   "reg",
   "in",
   "self",
   ".",
   "qregs",
   "+",
   "self",
   ".",
   "cregs",
   ":",
   "reg_map",
   "[",
   "reg",
   ".",
   "name",
   "]",
   "=",
   "reg_offset",
   "reg_offset",
   "+=",
   "reg",
   ".",
   "size",
   "# A list that holds the height of each qubit",
   "# and classical bit.",
   "op_stack",
   "=",
   "[",
   "0",
   "]",
   "*",
   "reg_offset",
   "# Here we are playing a modified version of",
   "# Tetris where we stack gates, but multi-qubit",
   "# gates, or measurements have a block for each",
   "# qubit or cbit that are connected by a virtual",
   "# line so that they all stacked at the same depth.",
   "# Conditional gates act on all cbits in the register",
   "# they are conditioned on.",
   "# We do not consider barriers or snapshots as",
   "# They are transpiler and simulator directives.",
   "# The max stack height is the circuit depth.",
   "for",
   "instr",
   ",",
   "qargs",
   ",",
   "cargs",
   "in",
   "self",
   ".",
   "data",
   ":",
   "if",
   "instr",
   ".",
   "name",
   "not",
   "in",
   "[",
   "'barrier'",
   ",",
   "'snapshot'",
   "]",
   ":",
   "levels",
   "=",
   "[",
   "]",
   "reg_ints",
   "=",
   "[",
   "]",
   "for",
   "ind",
   ",",
   "reg",
   "in",
   "enumerate",
   "(",
   "qargs",
   "+",
   "cargs",
   ")",
   ":",
   "# Add to the stacks of the qubits and",
   "# cbits used in the gate.",
   "reg_ints",
   ".",
   "append",
   "(",
   "reg_map",
   "[",
   "reg",
   "[",
   "0",
   "]",
   ".",
   "name",
   "]",
   "+",
   "reg",
   "[",
   "1",
   "]",
   ")",
   "levels",
   ".",
   "append",
   "(",
   "op_stack",
   "[",
   "reg_ints",
   "[",
   "ind",
   "]",
   "]",
   "+",
   "1",
   ")",
   "if",
   "instr",
   ".",
   "control",
   ":",
   "# Controls operate over all bits in the",
   "# classical register they use.",
   "cint",
   "=",
   "reg_map",
   "[",
   "instr",
   ".",
   "control",
   "[",
   "0",
   "]",
   ".",
   "name",
   "]",
   "for",
   "off",
   "in",
   "range",
   "(",
   "instr",
   ".",
   "control",
   "[",
   "0",
   "]",
   ".",
   "size",
   ")",
   ":",
   "if",
   "cint",
   "+",
   "off",
   "not",
   "in",
   "reg_ints",
   ":",
   "reg_ints",
   ".",
   "append",
   "(",
   "cint",
   "+",
   "off",
   ")",
   "levels",
   ".",
   "append",
   "(",
   "op_stack",
   "[",
   "cint",
   "+",
   "off",
   "]",
   "+",
   "1",
   ")",
   "max_level",
   "=",
   "<mask>",
   "(",
   "levels",
   ")",
   "for",
   "ind",
   "in",
   "reg_ints",
   ":",
   "op_stack",
   "[",
   "ind",
   "]",
   "=",
   "max_level",
   "return",
   "max",
   "(",
   "op_stack",
   ")"
  ]
 },
 {
  "idx": "maxmin-1207",
  "nl_tokens": [
   "Parse",
   "number",
   "format",
   "patterns"
  ],
  "pl_tokens": [
   "def",
   "parse_pattern",
   "(",
   "pattern",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "pattern",
   ",",
   "NumberPattern",
   ")",
   ":",
   "return",
   "pattern",
   "def",
   "_match_number",
   "(",
   "pattern",
   ")",
   ":",
   "rv",
   "=",
   "number_re",
   ".",
   "search",
   "(",
   "pattern",
   ")",
   "if",
   "rv",
   "is",
   "None",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Invalid number pattern %r'",
   "%",
   "pattern",
   ")",
   "return",
   "rv",
   ".",
   "groups",
   "(",
   ")",
   "pos_pattern",
   "=",
   "pattern",
   "# Do we have a negative subpattern?",
   "if",
   "';'",
   "in",
   "pattern",
   ":",
   "pos_pattern",
   ",",
   "neg_pattern",
   "=",
   "pattern",
   ".",
   "split",
   "(",
   "';'",
   ",",
   "1",
   ")",
   "pos_prefix",
   ",",
   "number",
   ",",
   "pos_suffix",
   "=",
   "_match_number",
   "(",
   "pos_pattern",
   ")",
   "neg_prefix",
   ",",
   "_",
   ",",
   "neg_suffix",
   "=",
   "_match_number",
   "(",
   "neg_pattern",
   ")",
   "else",
   ":",
   "pos_prefix",
   ",",
   "number",
   ",",
   "pos_suffix",
   "=",
   "_match_number",
   "(",
   "pos_pattern",
   ")",
   "neg_prefix",
   "=",
   "'-'",
   "+",
   "pos_prefix",
   "neg_suffix",
   "=",
   "pos_suffix",
   "if",
   "'E'",
   "in",
   "number",
   ":",
   "number",
   ",",
   "exp",
   "=",
   "number",
   ".",
   "split",
   "(",
   "'E'",
   ",",
   "1",
   ")",
   "else",
   ":",
   "exp",
   "=",
   "None",
   "if",
   "'@'",
   "in",
   "number",
   ":",
   "if",
   "'.'",
   "in",
   "number",
   "and",
   "'0'",
   "in",
   "number",
   ":",
   "raise",
   "ValueError",
   "(",
   "'Significant digit patterns can not contain '",
   "'\"@\" or \"0\"'",
   ")",
   "if",
   "'.'",
   "in",
   "number",
   ":",
   "integer",
   ",",
   "fraction",
   "=",
   "number",
   ".",
   "rsplit",
   "(",
   "'.'",
   ",",
   "1",
   ")",
   "else",
   ":",
   "integer",
   "=",
   "number",
   "fraction",
   "=",
   "''",
   "def",
   "parse_precision",
   "(",
   "p",
   ")",
   ":",
   "\"\"\"Calculate the min and max allowed digits\"\"\"",
   "<mask>",
   "=",
   "max",
   "=",
   "0",
   "for",
   "c",
   "in",
   "p",
   ":",
   "if",
   "c",
   "in",
   "'@0'",
   ":",
   "min",
   "+=",
   "1",
   "max",
   "+=",
   "1",
   "elif",
   "c",
   "==",
   "'#'",
   ":",
   "max",
   "+=",
   "1",
   "elif",
   "c",
   "==",
   "','",
   ":",
   "continue",
   "else",
   ":",
   "break",
   "return",
   "min",
   ",",
   "max",
   "int_prec",
   "=",
   "parse_precision",
   "(",
   "integer",
   ")",
   "frac_prec",
   "=",
   "parse_precision",
   "(",
   "fraction",
   ")",
   "if",
   "exp",
   ":",
   "exp_plus",
   "=",
   "exp",
   ".",
   "startswith",
   "(",
   "'+'",
   ")",
   "exp",
   "=",
   "exp",
   ".",
   "lstrip",
   "(",
   "'+'",
   ")",
   "exp_prec",
   "=",
   "parse_precision",
   "(",
   "exp",
   ")",
   "else",
   ":",
   "exp_plus",
   "=",
   "None",
   "exp_prec",
   "=",
   "None",
   "grouping",
   "=",
   "babel",
   ".",
   "numbers",
   ".",
   "parse_grouping",
   "(",
   "integer",
   ")",
   "return",
   "NumberPattern",
   "(",
   "pattern",
   ",",
   "(",
   "pos_prefix",
   ",",
   "neg_prefix",
   ")",
   ",",
   "(",
   "pos_suffix",
   ",",
   "neg_suffix",
   ")",
   ",",
   "grouping",
   ",",
   "int_prec",
   ",",
   "frac_prec",
   ",",
   "exp_prec",
   ",",
   "exp_plus",
   ")"
  ]
 },
 {
  "idx": "maxmin-1208",
  "nl_tokens": [
   "0",
   "-",
   ">",
   "no",
   "terms",
   "idd",
   "1",
   "-",
   ">",
   "most",
   "term",
   "idd",
   "are",
   "shared",
   "in",
   "root",
   "morphem",
   "2",
   "-",
   ">",
   "most",
   "term",
   "idd",
   "are",
   "shared",
   "in",
   "flexing",
   "morphem",
   "3",
   "-",
   ">",
   "most",
   "term",
   "idd",
   "are",
   "shared",
   "root",
   "<",
   "-",
   ">",
   "flexing",
   "(",
   "crossed",
   ")",
   ":",
   "param",
   "w0",
   ":",
   ":",
   "param",
   "w1",
   ":",
   ":",
   "return",
   ":"
  ],
  "pl_tokens": [
   "def",
   "count_relations",
   "(",
   "w0",
   ")",
   ":",
   "root_w0_relations",
   "=",
   "set",
   "(",
   "chain",
   ".",
   "from_iterable",
   "(",
   "relations",
   "[",
   "t",
   ".",
   "index",
   ",",
   ":",
   "]",
   ".",
   "indices",
   "for",
   "t",
   "in",
   "w0",
   ".",
   "root",
   ")",
   ")",
   "flexing_w0_relations",
   "=",
   "set",
   "(",
   "chain",
   ".",
   "from_iterable",
   "(",
   "relations",
   "[",
   "t",
   ".",
   "index",
   ",",
   ":",
   "]",
   ".",
   "indices",
   "for",
   "t",
   "in",
   "w0",
   ".",
   "flexing",
   ")",
   ")",
   "def",
   "f",
   "(",
   "w1",
   ")",
   ":",
   "root_w1",
   "=",
   "set",
   "(",
   "t",
   ".",
   "index",
   "for",
   "t",
   "in",
   "w1",
   ".",
   "root",
   ")",
   "flexing_w1",
   "=",
   "set",
   "(",
   "t",
   ".",
   "index",
   "for",
   "t",
   "in",
   "w1",
   ".",
   "flexing",
   ")",
   "count",
   "=",
   "[",
   "root_w0_relations",
   ".",
   "intersection",
   "(",
   "root_w1",
   ")",
   ",",
   "flexing_w0_relations",
   ".",
   "intersection",
   "(",
   "flexing_w1",
   ")",
   ",",
   "root_w0_relations",
   ".",
   "intersection",
   "(",
   "flexing_w1",
   ")",
   "|",
   "flexing_w0_relations",
   ".",
   "intersection",
   "(",
   "root_w1",
   ")",
   "]",
   "if",
   "any",
   "(",
   "count",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "(",
   "1",
   ",",
   "2",
   ",",
   "3",
   ")",
   ",",
   "key",
   "=",
   "lambda",
   "i",
   ":",
   "len",
   "(",
   "count",
   "[",
   "i",
   "-",
   "1",
   "]",
   ")",
   ")",
   "else",
   ":",
   "return",
   "0",
   "return",
   "f"
  ]
 },
 {
  "idx": "maxmin-1209",
  "nl_tokens": [
   "This",
   "function",
   "converts",
   "the",
   "estimated",
   "time_before_present",
   "properties",
   "of",
   "all",
   "nodes",
   "to",
   "numerical",
   "dates",
   "stored",
   "in",
   "the",
   "numdate",
   "attribute",
   ".",
   "This",
   "date",
   "is",
   "further",
   "converted",
   "into",
   "a",
   "human",
   "readable",
   "date",
   "string",
   "in",
   "format",
   "%Y",
   "-",
   "%m",
   "-",
   "%d",
   "assuming",
   "the",
   "usual",
   "calendar",
   "."
  ],
  "pl_tokens": [
   "def",
   "convert_dates",
   "(",
   "self",
   ")",
   ":",
   "from",
   "datetime",
   "import",
   "datetime",
   ",",
   "timedelta",
   "now",
   "=",
   "numeric_date",
   "(",
   ")",
   "for",
   "node",
   "in",
   "self",
   ".",
   "tree",
   ".",
   "find_clades",
   "(",
   ")",
   ":",
   "years_bp",
   "=",
   "self",
   ".",
   "date2dist",
   ".",
   "to_years",
   "(",
   "node",
   ".",
   "time_before_present",
   ")",
   "if",
   "years_bp",
   "<",
   "0",
   "and",
   "self",
   ".",
   "real_dates",
   ":",
   "if",
   "not",
   "hasattr",
   "(",
   "node",
   ",",
   "\"bad_branch\"",
   ")",
   "or",
   "node",
   ".",
   "bad_branch",
   "is",
   "False",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"ClockTree.convert_dates -- WARNING: The node is later than today, but it is not \"",
   "\"marked as \\\"BAD\\\", which indicates the error in the \"",
   "\"likelihood optimization.\"",
   ",",
   "4",
   ",",
   "warn",
   "=",
   "True",
   ")",
   "else",
   ":",
   "self",
   ".",
   "logger",
   "(",
   "\"ClockTree.convert_dates -- WARNING: node which is marked as \\\"BAD\\\" optimized \"",
   "\"later than present day\"",
   ",",
   "4",
   ",",
   "warn",
   "=",
   "True",
   ")",
   "node",
   ".",
   "numdate",
   "=",
   "now",
   "-",
   "years_bp",
   "# set the human-readable date",
   "year",
   "=",
   "np",
   ".",
   "floor",
   "(",
   "node",
   ".",
   "numdate",
   ")",
   "days",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "365.25",
   "*",
   "(",
   "node",
   ".",
   "numdate",
   "-",
   "year",
   ")",
   "-",
   "1",
   ")",
   "try",
   ":",
   "# datetime will only operate on dates after 1900",
   "n_date",
   "=",
   "datetime",
   "(",
   "year",
   ",",
   "1",
   ",",
   "1",
   ")",
   "+",
   "timedelta",
   "(",
   "days",
   "=",
   "days",
   ")",
   "node",
   ".",
   "date",
   "=",
   "datetime",
   ".",
   "strftime",
   "(",
   "n_date",
   ",",
   "\"%Y-%m-%d\"",
   ")",
   "except",
   ":",
   "# this is the approximation not accounting for gap years etc",
   "n_date",
   "=",
   "datetime",
   "(",
   "1900",
   ",",
   "1",
   ",",
   "1",
   ")",
   "+",
   "timedelta",
   "(",
   "days",
   "=",
   "days",
   ")",
   "node",
   ".",
   "date",
   "=",
   "\"%04d-%02d-%02d\"",
   "%",
   "(",
   "year",
   ",",
   "n_date",
   ".",
   "month",
   ",",
   "n_date",
   ".",
   "day",
   ")"
  ]
 },
 {
  "idx": "maxmin-1210",
  "nl_tokens": [
   "Store",
   "decodeTable",
   "and",
   "compute",
   "lengthTable",
   "minLength",
   "maxLength",
   "from",
   "encodings",
   "."
  ],
  "pl_tokens": [
   "def",
   "setDecode",
   "(",
   "self",
   ",",
   "decodeTable",
   ")",
   ":",
   "self",
   ".",
   "decodeTable",
   "=",
   "decodeTable",
   "#set of symbols with unknown length",
   "todo",
   "=",
   "set",
   "(",
   "decodeTable",
   ")",
   "#bit size under investigation",
   "maskLength",
   "=",
   "0",
   "lengthTable",
   "=",
   "{",
   "}",
   "while",
   "todo",
   ":",
   "mask",
   "=",
   "(",
   "1",
   "<<",
   "maskLength",
   ")",
   "-",
   "1",
   "#split the encodings that we didn't find yet using b bits",
   "splitSymbols",
   "=",
   "defaultdict",
   "(",
   "list",
   ")",
   "for",
   "s",
   "in",
   "todo",
   ":",
   "splitSymbols",
   "[",
   "s",
   "&",
   "mask",
   "]",
   ".",
   "append",
   "(",
   "s",
   ")",
   "#unique encodings have a length of maskLength bits",
   "#set length, and remove from todo list",
   "for",
   "s",
   ",",
   "subset",
   "in",
   "splitSymbols",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "len",
   "(",
   "subset",
   ")",
   "==",
   "1",
   ":",
   "lengthTable",
   "[",
   "self",
   ".",
   "decodeTable",
   "[",
   "s",
   "]",
   "]",
   "=",
   "maskLength",
   "todo",
   ".",
   "remove",
   "(",
   "s",
   ")",
   "#now investigate with longer mask",
   "maskLength",
   "+=",
   "1",
   "#save result",
   "self",
   ".",
   "lengthTable",
   "=",
   "lengthTable",
   "self",
   ".",
   "minLength",
   "=",
   "<mask>",
   "(",
   "lengthTable",
   ".",
   "values",
   "(",
   ")",
   ")",
   "self",
   ".",
   "maxLength",
   "=",
   "max",
   "(",
   "lengthTable",
   ".",
   "values",
   "(",
   ")",
   ")",
   "self",
   ".",
   "switchToPrefix",
   "(",
   ")"
  ]
 },
 {
  "idx": "maxmin-1211",
  "nl_tokens": [
   "This",
   "utility",
   "function",
   "will",
   "clean",
   "out",
   "old",
   "index",
   "data",
   "that",
   "was",
   "accidentally",
   "left",
   "during",
   "item",
   "deletion",
   "in",
   "rom",
   "versions",
   "<",
   "=",
   "0",
   ".",
   "27",
   ".",
   "0",
   ".",
   "You",
   "should",
   "run",
   "this",
   "after",
   "you",
   "have",
   "upgraded",
   "all",
   "of",
   "your",
   "clients",
   "to",
   "version",
   "0",
   ".",
   "28",
   ".",
   "0",
   "or",
   "later",
   "."
  ],
  "pl_tokens": [
   "def",
   "clean_old_index",
   "(",
   "model",
   ",",
   "block_size",
   "=",
   "100",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "conn",
   "=",
   "_connect",
   "(",
   "model",
   ")",
   "version",
   "=",
   "list",
   "(",
   "map",
   "(",
   "int",
   ",",
   "conn",
   ".",
   "info",
   "(",
   ")",
   "[",
   "'redis_version'",
   "]",
   ".",
   "split",
   "(",
   "'.'",
   ")",
   "[",
   ":",
   "2",
   "]",
   ")",
   ")",
   "has_hscan",
   "=",
   "version",
   ">=",
   "[",
   "2",
   ",",
   "8",
   "]",
   "pipe",
   "=",
   "conn",
   ".",
   "pipeline",
   "(",
   "True",
   ")",
   "prefix",
   "=",
   "'%s:'",
   "%",
   "model",
   ".",
   "_namespace",
   "index",
   "=",
   "prefix",
   "+",
   "':'",
   "block_size",
   "=",
   "<mask>",
   "(",
   "block_size",
   ",",
   "10",
   ")",
   "force_hscan",
   "=",
   "kwargs",
   ".",
   "get",
   "(",
   "'force_hscan'",
   ",",
   "False",
   ")",
   "if",
   "(",
   "has_hscan",
   "or",
   "force_hscan",
   ")",
   "and",
   "force_hscan",
   "is",
   "not",
   "None",
   ":",
   "max_id",
   "=",
   "conn",
   ".",
   "hlen",
   "(",
   "index",
   ")",
   "cursor",
   "=",
   "None",
   "scanned",
   "=",
   "0",
   "while",
   "cursor",
   "!=",
   "b'0'",
   ":",
   "cursor",
   ",",
   "remove",
   "=",
   "_scan_index_lua",
   "(",
   "conn",
   ",",
   "[",
   "index",
   ",",
   "prefix",
   "]",
   ",",
   "[",
   "cursor",
   "or",
   "'0'",
   ",",
   "block_size",
   ",",
   "0",
   ",",
   "0",
   "]",
   ")",
   "if",
   "remove",
   ":",
   "_clean_index_lua",
   "(",
   "conn",
   ",",
   "[",
   "model",
   ".",
   "_namespace",
   "]",
   ",",
   "remove",
   ")",
   "scanned",
   "+=",
   "block_size",
   "if",
   "scanned",
   ">",
   "max_id",
   ":",
   "max_id",
   "=",
   "scanned",
   "+",
   "1",
   "yield",
   "scanned",
   ",",
   "max_id",
   "# need to scan over unique indexes :/",
   "for",
   "uniq",
   "in",
   "chain",
   "(",
   "model",
   ".",
   "_unique",
   ",",
   "model",
   ".",
   "_cunique",
   ")",
   ":",
   "name",
   "=",
   "uniq",
   "if",
   "isinstance",
   "(",
   "uniq",
   ",",
   "six",
   ".",
   "string_types",
   ")",
   "else",
   "':'",
   ".",
   "join",
   "(",
   "uniq",
   ")",
   "idx",
   "=",
   "prefix",
   "+",
   "name",
   "+",
   "':uidx'",
   "cursor",
   "=",
   "None",
   "while",
   "cursor",
   "!=",
   "b'0'",
   ":",
   "cursor",
   ",",
   "remove",
   "=",
   "_scan_index_lua",
   "(",
   "conn",
   ",",
   "[",
   "idx",
   ",",
   "prefix",
   "]",
   ",",
   "[",
   "cursor",
   "or",
   "'0'",
   ",",
   "block_size",
   ",",
   "1",
   ",",
   "0",
   "]",
   ")",
   "if",
   "remove",
   ":",
   "conn",
   ".",
   "hdel",
   "(",
   "idx",
   ",",
   "*",
   "remove",
   ")",
   "scanned",
   "+=",
   "block_size",
   "if",
   "scanned",
   ">",
   "max_id",
   ":",
   "max_id",
   "=",
   "scanned",
   "+",
   "1",
   "yield",
   "scanned",
   ",",
   "max_id",
   "else",
   ":",
   "if",
   "model",
   ".",
   "_unique",
   "or",
   "model",
   ".",
   "_cunique",
   ":",
   "if",
   "has_hscan",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"You have disabled the use of HSCAN to clean up indexes, this will prevent unique index cleanup\"",
   ",",
   "stacklevel",
   "=",
   "2",
   ")",
   "else",
   ":",
   "warnings",
   ".",
   "warn",
   "(",
   "\"Unique indexes cannot be cleaned up in Redis versions prior to 2.8\"",
   ",",
   "stacklevel",
   "=",
   "2",
   ")",
   "max_id",
   "=",
   "int",
   "(",
   "conn",
   ".",
   "get",
   "(",
   "'%s%s:'",
   "%",
   "(",
   "prefix",
   ",",
   "model",
   ".",
   "_pkey",
   ")",
   ")",
   "or",
   "'0'",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "max_id",
   "+",
   "1",
   ",",
   "block_size",
   ")",
   ":",
   "ids",
   "=",
   "list",
   "(",
   "range",
   "(",
   "i",
   ",",
   "min",
   "(",
   "i",
   "+",
   "block_size",
   ",",
   "max_id",
   "+",
   "1",
   ")",
   ")",
   ")",
   "for",
   "id",
   "in",
   "ids",
   ":",
   "pipe",
   ".",
   "exists",
   "(",
   "prefix",
   "+",
   "str",
   "(",
   "id",
   ")",
   ")",
   "pipe",
   ".",
   "hexists",
   "(",
   "index",
   ",",
   "id",
   ")",
   "result",
   "=",
   "iter",
   "(",
   "pipe",
   ".",
   "execute",
   "(",
   ")",
   ")",
   "remove",
   "=",
   "[",
   "id",
   "for",
   "id",
   ",",
   "ent",
   ",",
   "ind",
   "in",
   "zip",
   "(",
   "ids",
   ",",
   "result",
   ",",
   "result",
   ")",
   "if",
   "ind",
   "and",
   "not",
   "ent",
   "]",
   "if",
   "remove",
   ":",
   "_clean_index_lua",
   "(",
   "conn",
   ",",
   "[",
   "model",
   ".",
   "_namespace",
   "]",
   ",",
   "remove",
   ")",
   "yield",
   "min",
   "(",
   "i",
   "+",
   "block_size",
   ",",
   "max_id",
   "-",
   "1",
   ")",
   ",",
   "max_id",
   "yield",
   "max_id",
   ",",
   "max_id"
  ]
 },
 {
  "idx": "maxmin-1212",
  "nl_tokens": [
   "Reverse",
   "byteorder",
   "(",
   "littleendian",
   "/",
   "bigendian",
   ")",
   "of",
   "signal",
   "or",
   "value"
  ],
  "pl_tokens": [
   "def",
   "reverseByteOrder",
   "(",
   "signalOrVal",
   ")",
   ":",
   "w",
   "=",
   "signalOrVal",
   ".",
   "_dtype",
   ".",
   "bit_length",
   "(",
   ")",
   "i",
   "=",
   "w",
   "items",
   "=",
   "[",
   "]",
   "while",
   "i",
   ">",
   "0",
   ":",
   "# take last 8 bytes or rest",
   "lower",
   "=",
   "<mask>",
   "(",
   "i",
   "-",
   "8",
   ",",
   "0",
   ")",
   "items",
   ".",
   "append",
   "(",
   "signalOrVal",
   "[",
   "i",
   ":",
   "lower",
   "]",
   ")",
   "i",
   "-=",
   "8",
   "return",
   "Concat",
   "(",
   "*",
   "items",
   ")"
  ]
 },
 {
  "idx": "maxmin-1213",
  "nl_tokens": [
   "multiplies",
   "a",
   "list",
   "of",
   "Distribution",
   "objects"
  ],
  "pl_tokens": [
   "def",
   "multiply",
   "(",
   "dists",
   ")",
   ":",
   "if",
   "not",
   "all",
   "(",
   "[",
   "isinstance",
   "(",
   "k",
   ",",
   "Distribution",
   ")",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   ":",
   "raise",
   "NotImplementedError",
   "(",
   "\"Can only multiply Distribution objects\"",
   ")",
   "n_delta",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "[",
   "k",
   ".",
   "is_delta",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   "min_width",
   "=",
   "np",
   ".",
   "<mask>",
   "(",
   "[",
   "k",
   ".",
   "min_width",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   "if",
   "n_delta",
   ">",
   "1",
   ":",
   "raise",
   "ArithmeticError",
   "(",
   "\"Cannot multiply more than one delta functions!\"",
   ")",
   "elif",
   "n_delta",
   "==",
   "1",
   ":",
   "delta_dist_ii",
   "=",
   "np",
   ".",
   "where",
   "(",
   "[",
   "k",
   ".",
   "is_delta",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "delta_dist",
   "=",
   "dists",
   "[",
   "delta_dist_ii",
   "]",
   "new_xpos",
   "=",
   "delta_dist",
   ".",
   "peak_pos",
   "new_weight",
   "=",
   "np",
   ".",
   "prod",
   "(",
   "[",
   "k",
   ".",
   "prob",
   "(",
   "new_xpos",
   ")",
   "for",
   "k",
   "in",
   "dists",
   "if",
   "k",
   "!=",
   "delta_dist_ii",
   "]",
   ")",
   "*",
   "delta_dist",
   ".",
   "weight",
   "res",
   "=",
   "Distribution",
   ".",
   "delta_function",
   "(",
   "new_xpos",
   ",",
   "weight",
   "=",
   "new_weight",
   ",",
   "min_width",
   "=",
   "min_width",
   ")",
   "else",
   ":",
   "new_xmin",
   "=",
   "np",
   ".",
   "max",
   "(",
   "[",
   "k",
   ".",
   "xmin",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   "new_xmax",
   "=",
   "np",
   ".",
   "min",
   "(",
   "[",
   "k",
   ".",
   "xmax",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   "x_vals",
   "=",
   "np",
   ".",
   "unique",
   "(",
   "np",
   ".",
   "concatenate",
   "(",
   "[",
   "k",
   ".",
   "x",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ")",
   ")",
   "x_vals",
   "=",
   "x_vals",
   "[",
   "(",
   "x_vals",
   ">",
   "new_xmin",
   "-",
   "TINY_NUMBER",
   ")",
   "&",
   "(",
   "x_vals",
   "<",
   "new_xmax",
   "+",
   "TINY_NUMBER",
   ")",
   "]",
   "y_vals",
   "=",
   "np",
   ".",
   "sum",
   "(",
   "[",
   "k",
   ".",
   "__call__",
   "(",
   "x_vals",
   ")",
   "for",
   "k",
   "in",
   "dists",
   "]",
   ",",
   "axis",
   "=",
   "0",
   ")",
   "peak",
   "=",
   "y_vals",
   ".",
   "min",
   "(",
   ")",
   "ind",
   "=",
   "(",
   "y_vals",
   "-",
   "peak",
   ")",
   "<",
   "BIG_NUMBER",
   "/",
   "1000",
   "n_points",
   "=",
   "ind",
   ".",
   "sum",
   "(",
   ")",
   "if",
   "n_points",
   "==",
   "0",
   ":",
   "print",
   "(",
   "\"ERROR in distribution multiplication: Distributions do not overlap\"",
   ")",
   "x_vals",
   "=",
   "[",
   "0",
   ",",
   "1",
   "]",
   "y_vals",
   "=",
   "[",
   "BIG_NUMBER",
   ",",
   "BIG_NUMBER",
   "]",
   "res",
   "=",
   "Distribution",
   "(",
   "x_vals",
   ",",
   "y_vals",
   ",",
   "is_log",
   "=",
   "True",
   ",",
   "min_width",
   "=",
   "min_width",
   ",",
   "kind",
   "=",
   "'linear'",
   ")",
   "elif",
   "n_points",
   "==",
   "1",
   ":",
   "res",
   "=",
   "Distribution",
   ".",
   "delta_function",
   "(",
   "x_vals",
   "[",
   "0",
   "]",
   ")",
   "else",
   ":",
   "res",
   "=",
   "Distribution",
   "(",
   "x_vals",
   "[",
   "ind",
   "]",
   ",",
   "y_vals",
   "[",
   "ind",
   "]",
   ",",
   "is_log",
   "=",
   "True",
   ",",
   "min_width",
   "=",
   "min_width",
   ",",
   "kind",
   "=",
   "'linear'",
   ",",
   "assume_sorted",
   "=",
   "True",
   ")",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-1214",
  "nl_tokens": [
   "Get",
   "common",
   "prefix",
   "for",
   "completions"
  ],
  "pl_tokens": [
   "def",
   "commonprefix",
   "(",
   "items",
   ")",
   ":",
   "# the last item will always have the least leading % symbol",
   "# min / max are first/last in alphabetical order",
   "first_match",
   "=",
   "ESCAPE_RE",
   ".",
   "match",
   "(",
   "<mask>",
   "(",
   "items",
   ")",
   ")",
   "last_match",
   "=",
   "ESCAPE_RE",
   ".",
   "match",
   "(",
   "max",
   "(",
   "items",
   ")",
   ")",
   "# common suffix is (common prefix of reversed items) reversed",
   "if",
   "first_match",
   "and",
   "last_match",
   ":",
   "prefix",
   "=",
   "os",
   ".",
   "path",
   ".",
   "commonprefix",
   "(",
   "(",
   "first_match",
   ".",
   "group",
   "(",
   "0",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ",",
   "last_match",
   ".",
   "group",
   "(",
   "0",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   ")",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   "else",
   ":",
   "prefix",
   "=",
   "''",
   "items",
   "=",
   "[",
   "s",
   ".",
   "lstrip",
   "(",
   "ESCAPE_CHARS",
   ")",
   "for",
   "s",
   "in",
   "items",
   "]",
   "return",
   "prefix",
   "+",
   "os",
   ".",
   "path",
   ".",
   "commonprefix",
   "(",
   "items",
   ")"
  ]
 },
 {
  "idx": "maxmin-1215",
  "nl_tokens": [
   "Helper",
   "method",
   "to",
   "get",
   "max",
   "partition",
   "of",
   "partitions",
   "with",
   "partition_key",
   "from",
   "part",
   "specs",
   ".",
   "key",
   ":",
   "value",
   "pair",
   "in",
   "filter_map",
   "will",
   "be",
   "used",
   "to",
   "filter",
   "out",
   "partitions",
   "."
  ],
  "pl_tokens": [
   "def",
   "_get_max_partition_from_part_specs",
   "(",
   "part_specs",
   ",",
   "partition_key",
   ",",
   "filter_map",
   ")",
   ":",
   "if",
   "not",
   "part_specs",
   ":",
   "return",
   "None",
   "# Assuming all specs have the same keys.",
   "if",
   "partition_key",
   "not",
   "in",
   "part_specs",
   "[",
   "0",
   "]",
   ".",
   "keys",
   "(",
   ")",
   ":",
   "raise",
   "AirflowException",
   "(",
   "\"Provided partition_key {} \"",
   "\"is not in part_specs.\"",
   ".",
   "format",
   "(",
   "partition_key",
   ")",
   ")",
   "if",
   "filter_map",
   ":",
   "is_subset",
   "=",
   "set",
   "(",
   "filter_map",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ".",
   "issubset",
   "(",
   "set",
   "(",
   "part_specs",
   "[",
   "0",
   "]",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ")",
   "if",
   "filter_map",
   "and",
   "not",
   "is_subset",
   ":",
   "raise",
   "AirflowException",
   "(",
   "\"Keys in provided filter_map {} \"",
   "\"are not subset of part_spec keys: {}\"",
   ".",
   "format",
   "(",
   "', '",
   ".",
   "join",
   "(",
   "filter_map",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ",",
   "', '",
   ".",
   "join",
   "(",
   "part_specs",
   "[",
   "0",
   "]",
   ".",
   "keys",
   "(",
   ")",
   ")",
   ")",
   ")",
   "candidates",
   "=",
   "[",
   "p_dict",
   "[",
   "partition_key",
   "]",
   "for",
   "p_dict",
   "in",
   "part_specs",
   "if",
   "filter_map",
   "is",
   "None",
   "or",
   "all",
   "(",
   "item",
   "in",
   "p_dict",
   ".",
   "items",
   "(",
   ")",
   "for",
   "item",
   "in",
   "filter_map",
   ".",
   "items",
   "(",
   ")",
   ")",
   "]",
   "if",
   "not",
   "candidates",
   ":",
   "return",
   "None",
   "else",
   ":",
   "return",
   "<mask>",
   "(",
   "candidates",
   ")",
   ".",
   "encode",
   "(",
   "'utf-8'",
   ")"
  ]
 },
 {
  "idx": "maxmin-1216",
  "nl_tokens": [
   "Returns",
   "the",
   "internal",
   "angles",
   "of",
   "all",
   "elements",
   "and",
   "the",
   "associated",
   "statistics"
  ],
  "pl_tokens": [
   "def",
   "angles",
   "(",
   "self",
   ",",
   "zfill",
   "=",
   "3",
   ")",
   ":",
   "elements",
   "=",
   "self",
   ".",
   "elements",
   ".",
   "sort_index",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "etypes",
   "=",
   "elements",
   "[",
   "(",
   "\"type\"",
   ",",
   "\"argiope\"",
   ")",
   "]",
   ".",
   "unique",
   "(",
   ")",
   "out",
   "=",
   "[",
   "]",
   "for",
   "etype",
   "in",
   "etypes",
   ":",
   "etype_info",
   "=",
   "ELEMENTS",
   "[",
   "etype",
   "]",
   "angles_info",
   "=",
   "etype_info",
   ".",
   "angles",
   "loc",
   "=",
   "elements",
   "[",
   "(",
   "\"type\"",
   ",",
   "\"argiope\"",
   ",",
   "\"\"",
   ")",
   "]",
   "==",
   "etype",
   "index",
   "=",
   "elements",
   ".",
   "loc",
   "[",
   "loc",
   "]",
   ".",
   "index",
   "angles_data",
   "=",
   "self",
   ".",
   "split",
   "(",
   "into",
   "=",
   "\"angles\"",
   ",",
   "loc",
   "=",
   "loc",
   ",",
   "at",
   "=",
   "\"coords\"",
   ")",
   "data",
   "=",
   "angles_data",
   ".",
   "values",
   ".",
   "reshape",
   "(",
   "index",
   ".",
   "size",
   ",",
   "angles_info",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "angles_info",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "3",
   ")",
   "edges",
   "=",
   "data",
   "[",
   ":",
   ",",
   ":",
   ",",
   "[",
   "0",
   ",",
   "2",
   "]",
   ",",
   ":",
   "]",
   "-",
   "data",
   "[",
   ":",
   ",",
   ":",
   ",",
   "1",
   ":",
   "2",
   ",",
   ":",
   "]",
   "edges",
   "/=",
   "np",
   ".",
   "linalg",
   ".",
   "norm",
   "(",
   "edges",
   ",",
   "axis",
   "=",
   "3",
   ")",
   ".",
   "reshape",
   "(",
   "index",
   ".",
   "size",
   ",",
   "angles_info",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ",",
   "2",
   ",",
   "1",
   ")",
   "angles",
   "=",
   "np",
   ".",
   "degrees",
   "(",
   "np",
   ".",
   "arccos",
   "(",
   "(",
   "edges",
   "[",
   ":",
   ",",
   ":",
   ",",
   "0",
   "]",
   "*",
   "edges",
   "[",
   ":",
   ",",
   ":",
   ",",
   "1",
   "]",
   ")",
   ".",
   "sum",
   "(",
   "axis",
   "=",
   "2",
   ")",
   ")",
   ")",
   "deviation",
   "=",
   "angles",
   "-",
   "etype_info",
   ".",
   "optimal_angles",
   "angles_df",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "index",
   "=",
   "index",
   ",",
   "data",
   "=",
   "angles",
   ",",
   "columns",
   "=",
   "pd",
   ".",
   "MultiIndex",
   ".",
   "from_product",
   "(",
   "[",
   "[",
   "\"angles\"",
   "]",
   ",",
   "[",
   "\"a\"",
   "+",
   "\"{0}\"",
   ".",
   "format",
   "(",
   "s",
   ")",
   ".",
   "zfill",
   "(",
   "zfill",
   ")",
   "for",
   "s",
   "in",
   "range",
   "(",
   "angles_info",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "]",
   "]",
   ")",
   ")",
   "deviation_df",
   "=",
   "pd",
   ".",
   "DataFrame",
   "(",
   "index",
   "=",
   "index",
   ",",
   "data",
   "=",
   "deviation",
   ",",
   "columns",
   "=",
   "pd",
   ".",
   "MultiIndex",
   ".",
   "from_product",
   "(",
   "[",
   "[",
   "\"deviation\"",
   "]",
   ",",
   "[",
   "\"d\"",
   "+",
   "\"{0}\"",
   ".",
   "format",
   "(",
   "s",
   ")",
   ".",
   "zfill",
   "(",
   "zfill",
   ")",
   "for",
   "s",
   "in",
   "range",
   "(",
   "angles_info",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "]",
   "]",
   ")",
   ")",
   "df",
   "=",
   "pd",
   ".",
   "concat",
   "(",
   "[",
   "angles_df",
   ",",
   "deviation_df",
   "]",
   ",",
   "axis",
   "=",
   "1",
   ")",
   ".",
   "sort_index",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df",
   "[",
   "\"stats\"",
   ",",
   "\"max_angle\"",
   "]",
   "=",
   "df",
   ".",
   "angles",
   ".",
   "<mask>",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df",
   "[",
   "\"stats\"",
   ",",
   "\"min_angle\"",
   "]",
   "=",
   "df",
   ".",
   "angles",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df",
   "[",
   "\"stats\"",
   ",",
   "\"max_angular_deviation\"",
   "]",
   "=",
   "df",
   ".",
   "deviation",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df",
   "[",
   "\"stats\"",
   ",",
   "\"min_angular_deviation\"",
   "]",
   "=",
   "df",
   ".",
   "deviation",
   ".",
   "min",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df",
   "[",
   "\"stats\"",
   ",",
   "\"max_abs_angular_deviation\"",
   "]",
   "=",
   "abs",
   "(",
   "df",
   ".",
   "deviation",
   ")",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "df",
   "=",
   "df",
   ".",
   "sort_index",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "out",
   ".",
   "append",
   "(",
   "df",
   ")",
   "out",
   "=",
   "pd",
   ".",
   "concat",
   "(",
   "out",
   ")",
   ".",
   "sort_index",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "return",
   "out"
  ]
 },
 {
  "idx": "maxmin-1217",
  "nl_tokens": [
   "r",
   "Continuous",
   "gaussian",
   "square",
   "pulse",
   "."
  ],
  "pl_tokens": [
   "def",
   "gaussian_square",
   "(",
   "times",
   ":",
   "np",
   ".",
   "ndarray",
   ",",
   "amp",
   ":",
   "complex",
   ",",
   "center",
   ":",
   "float",
   ",",
   "width",
   ":",
   "float",
   ",",
   "sigma",
   ":",
   "float",
   ",",
   "zeroed_width",
   ":",
   "Union",
   "[",
   "None",
   ",",
   "float",
   "]",
   "=",
   "None",
   ")",
   "->",
   "np",
   ".",
   "ndarray",
   ":",
   "square_start",
   "=",
   "center",
   "-",
   "width",
   "/",
   "2",
   "square_stop",
   "=",
   "center",
   "+",
   "width",
   "/",
   "2",
   "if",
   "zeroed_width",
   ":",
   "zeroed_width",
   "=",
   "<mask>",
   "(",
   "width",
   ",",
   "zeroed_width",
   ")",
   "gauss_zeroed_width",
   "=",
   "zeroed_width",
   "-",
   "width",
   "else",
   ":",
   "gauss_zeroed_width",
   "=",
   "None",
   "funclist",
   "=",
   "[",
   "functools",
   ".",
   "partial",
   "(",
   "gaussian",
   ",",
   "amp",
   "=",
   "amp",
   ",",
   "center",
   "=",
   "square_start",
   ",",
   "sigma",
   "=",
   "sigma",
   ",",
   "zeroed_width",
   "=",
   "gauss_zeroed_width",
   ",",
   "rescale_amp",
   "=",
   "True",
   ")",
   ",",
   "functools",
   ".",
   "partial",
   "(",
   "gaussian",
   ",",
   "amp",
   "=",
   "amp",
   ",",
   "center",
   "=",
   "square_stop",
   ",",
   "sigma",
   "=",
   "sigma",
   ",",
   "zeroed_width",
   "=",
   "gauss_zeroed_width",
   ",",
   "rescale_amp",
   "=",
   "True",
   ")",
   ",",
   "functools",
   ".",
   "partial",
   "(",
   "constant",
   ",",
   "amp",
   "=",
   "amp",
   ")",
   "]",
   "condlist",
   "=",
   "[",
   "times",
   "<=",
   "square_start",
   ",",
   "times",
   ">=",
   "square_stop",
   "]",
   "return",
   "np",
   ".",
   "piecewise",
   "(",
   "times",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "complex_",
   ")",
   ",",
   "condlist",
   ",",
   "funclist",
   ")"
  ]
 },
 {
  "idx": "maxmin-1218",
  "nl_tokens": [
   "Give",
   "gaps",
   "and",
   "overlaps",
   ".",
   "The",
   "return",
   "types",
   "are",
   "shown",
   "in",
   "the",
   "table",
   "below",
   ".",
   "The",
   "string",
   "will",
   "be",
   "of",
   "the",
   "format",
   ":",
   "id_tiername_tiername",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_gaps_and_overlaps",
   "(",
   "self",
   ",",
   "tier1",
   ",",
   "tier2",
   ",",
   "maxlen",
   "=",
   "-",
   "1",
   ")",
   ":",
   "spkr1anns",
   "=",
   "sorted",
   "(",
   "(",
   "self",
   ".",
   "timeslots",
   "[",
   "a",
   "[",
   "0",
   "]",
   "]",
   ",",
   "self",
   ".",
   "timeslots",
   "[",
   "a",
   "[",
   "1",
   "]",
   "]",
   ")",
   "for",
   "a",
   "in",
   "self",
   ".",
   "tiers",
   "[",
   "tier1",
   "]",
   "[",
   "0",
   "]",
   ".",
   "values",
   "(",
   ")",
   ")",
   "spkr2anns",
   "=",
   "sorted",
   "(",
   "(",
   "self",
   ".",
   "timeslots",
   "[",
   "a",
   "[",
   "0",
   "]",
   "]",
   ",",
   "self",
   ".",
   "timeslots",
   "[",
   "a",
   "[",
   "1",
   "]",
   "]",
   ")",
   "for",
   "a",
   "in",
   "self",
   ".",
   "tiers",
   "[",
   "tier2",
   "]",
   "[",
   "0",
   "]",
   ".",
   "values",
   "(",
   ")",
   ")",
   "line1",
   "=",
   "[",
   "]",
   "def",
   "isin",
   "(",
   "x",
   ",",
   "lst",
   ")",
   ":",
   "return",
   "False",
   "if",
   "len",
   "(",
   "[",
   "i",
   "for",
   "i",
   "in",
   "lst",
   "if",
   "i",
   "[",
   "0",
   "]",
   "<=",
   "x",
   "and",
   "i",
   "[",
   "1",
   "]",
   ">=",
   "x",
   "]",
   ")",
   "==",
   "0",
   "else",
   "True",
   "minmax",
   "=",
   "(",
   "<mask>",
   "(",
   "spkr1anns",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ",",
   "spkr2anns",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   ")",
   ",",
   "max",
   "(",
   "spkr1anns",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   ",",
   "spkr2anns",
   "[",
   "-",
   "1",
   "]",
   "[",
   "1",
   "]",
   ")",
   ")",
   "last",
   "=",
   "(",
   "1",
   ",",
   "minmax",
   "[",
   "0",
   "]",
   ")",
   "for",
   "ts",
   "in",
   "range",
   "(",
   "*",
   "minmax",
   ")",
   ":",
   "in1",
   ",",
   "in2",
   "=",
   "isin",
   "(",
   "ts",
   ",",
   "spkr1anns",
   ")",
   ",",
   "isin",
   "(",
   "ts",
   ",",
   "spkr2anns",
   ")",
   "if",
   "in1",
   "and",
   "in2",
   ":",
   "# Both speaking",
   "if",
   "last",
   "[",
   "0",
   "]",
   "==",
   "'B'",
   ":",
   "continue",
   "ty",
   "=",
   "'B'",
   "elif",
   "in1",
   ":",
   "# Only 1 speaking",
   "if",
   "last",
   "[",
   "0",
   "]",
   "==",
   "'1'",
   ":",
   "continue",
   "ty",
   "=",
   "'1'",
   "elif",
   "in2",
   ":",
   "# Only 2 speaking",
   "if",
   "last",
   "[",
   "0",
   "]",
   "==",
   "'2'",
   ":",
   "continue",
   "ty",
   "=",
   "'2'",
   "else",
   ":",
   "# None speaking",
   "if",
   "last",
   "[",
   "0",
   "]",
   "==",
   "'N'",
   ":",
   "continue",
   "ty",
   "=",
   "'N'",
   "line1",
   ".",
   "append",
   "(",
   "(",
   "last",
   "[",
   "0",
   "]",
   ",",
   "last",
   "[",
   "1",
   "]",
   ",",
   "ts",
   ")",
   ")",
   "last",
   "=",
   "(",
   "ty",
   ",",
   "ts",
   ")",
   "line1",
   ".",
   "append",
   "(",
   "(",
   "last",
   "[",
   "0",
   "]",
   ",",
   "last",
   "[",
   "1",
   "]",
   ",",
   "minmax",
   "[",
   "1",
   "]",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "line1",
   ")",
   ")",
   ":",
   "if",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'N'",
   ":",
   "if",
   "i",
   "!=",
   "0",
   "and",
   "i",
   "<",
   "len",
   "(",
   "line1",
   ")",
   "-",
   "1",
   "and",
   "line1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "!=",
   "line1",
   "[",
   "i",
   "+",
   "1",
   "]",
   "[",
   "0",
   "]",
   ":",
   "t",
   "=",
   "(",
   "'G12'",
   ",",
   "tier1",
   ",",
   "tier2",
   ")",
   "if",
   "line1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'1'",
   "else",
   "(",
   "'G21'",
   ",",
   "tier2",
   ",",
   "tier1",
   ")",
   "if",
   "maxlen",
   "==",
   "-",
   "1",
   "or",
   "abs",
   "(",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   "-",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "2",
   "]",
   ")",
   "<",
   "maxlen",
   ":",
   "yield",
   "(",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   ",",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "2",
   "]",
   "-",
   "1",
   ",",
   "'_'",
   ".",
   "join",
   "(",
   "t",
   ")",
   ")",
   "else",
   ":",
   "t",
   "=",
   "(",
   "'P1'",
   ",",
   "tier1",
   ")",
   "if",
   "line1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'1'",
   "else",
   "(",
   "'P2'",
   ",",
   "tier2",
   ")",
   "if",
   "maxlen",
   "==",
   "-",
   "1",
   "or",
   "abs",
   "(",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   "-",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "2",
   "]",
   ")",
   "<",
   "maxlen",
   ":",
   "yield",
   "(",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   ",",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "2",
   "]",
   "-",
   "1",
   ",",
   "'_'",
   ".",
   "join",
   "(",
   "t",
   ")",
   ")",
   "elif",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'B'",
   ":",
   "if",
   "i",
   "!=",
   "0",
   "and",
   "i",
   "<",
   "len",
   "(",
   "line1",
   ")",
   "-",
   "1",
   "and",
   "line1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "!=",
   "line1",
   "[",
   "i",
   "+",
   "1",
   "]",
   "[",
   "0",
   "]",
   ":",
   "t",
   "=",
   "(",
   "'O12'",
   ",",
   "tier1",
   ",",
   "tier2",
   ")",
   "if",
   "line1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'1'",
   "else",
   "(",
   "'O21'",
   ",",
   "tier2",
   ",",
   "tier1",
   ")",
   "yield",
   "(",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   ",",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "2",
   "]",
   "-",
   "1",
   ",",
   "'_'",
   ".",
   "join",
   "(",
   "t",
   ")",
   ")",
   "else",
   ":",
   "t",
   "=",
   "(",
   "'W12'",
   ",",
   "tier1",
   ",",
   "tier2",
   ")",
   "if",
   "line1",
   "[",
   "i",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "==",
   "'1'",
   "else",
   "(",
   "'W21'",
   ",",
   "tier2",
   ",",
   "tier1",
   ")",
   "yield",
   "(",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "1",
   "]",
   ",",
   "line1",
   "[",
   "i",
   "]",
   "[",
   "2",
   "]",
   "-",
   "1",
   ",",
   "'_'",
   ".",
   "join",
   "(",
   "t",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1219",
  "nl_tokens": [
   "get",
   "label",
   "and",
   "shape",
   "for",
   "classes",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_values",
   "(",
   "self",
   ",",
   "obj",
   ")",
   ":",
   "if",
   "is_exception",
   "(",
   "obj",
   ".",
   "node",
   ")",
   ":",
   "label",
   "=",
   "r\"\\fb\\f09%s\\fn\"",
   "%",
   "obj",
   ".",
   "title",
   "else",
   ":",
   "label",
   "=",
   "r\"\\fb%s\\fn\"",
   "%",
   "obj",
   ".",
   "title",
   "if",
   "obj",
   ".",
   "shape",
   "==",
   "\"interface\"",
   ":",
   "shape",
   "=",
   "\"ellipse\"",
   "else",
   ":",
   "shape",
   "=",
   "\"box\"",
   "if",
   "not",
   "self",
   ".",
   "config",
   ".",
   "only_classnames",
   ":",
   "attrs",
   "=",
   "obj",
   ".",
   "attrs",
   "methods",
   "=",
   "[",
   "func",
   ".",
   "name",
   "for",
   "func",
   "in",
   "obj",
   ".",
   "methods",
   "]",
   "# box width for UML like diagram",
   "maxlen",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "name",
   ")",
   "for",
   "name",
   "in",
   "[",
   "obj",
   ".",
   "title",
   "]",
   "+",
   "methods",
   "+",
   "attrs",
   ")",
   "line",
   "=",
   "\"_\"",
   "*",
   "(",
   "maxlen",
   "+",
   "2",
   ")",
   "label",
   "=",
   "r\"%s\\n\\f%s\"",
   "%",
   "(",
   "label",
   ",",
   "line",
   ")",
   "for",
   "attr",
   "in",
   "attrs",
   ":",
   "label",
   "=",
   "r\"%s\\n\\f08%s\"",
   "%",
   "(",
   "label",
   ",",
   "attr",
   ")",
   "if",
   "attrs",
   ":",
   "label",
   "=",
   "r\"%s\\n\\f%s\"",
   "%",
   "(",
   "label",
   ",",
   "line",
   ")",
   "for",
   "func",
   "in",
   "methods",
   ":",
   "label",
   "=",
   "r\"%s\\n\\f10%s()\"",
   "%",
   "(",
   "label",
   ",",
   "func",
   ")",
   "return",
   "dict",
   "(",
   "label",
   "=",
   "label",
   ",",
   "shape",
   "=",
   "shape",
   ")"
  ]
 },
 {
  "idx": "maxmin-1220",
  "nl_tokens": [
   "Returns",
   "a",
   "signal",
   "with",
   "the",
   "signal",
   "click",
   "placed",
   "at",
   "each",
   "specified",
   "time"
  ],
  "pl_tokens": [
   "def",
   "clicks",
   "(",
   "times",
   "=",
   "None",
   ",",
   "frames",
   "=",
   "None",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "click_freq",
   "=",
   "1000.0",
   ",",
   "click_duration",
   "=",
   "0.1",
   ",",
   "click",
   "=",
   "None",
   ",",
   "length",
   "=",
   "None",
   ")",
   ":",
   "# Compute sample positions from time or frames",
   "if",
   "times",
   "is",
   "None",
   ":",
   "if",
   "frames",
   "is",
   "None",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'either \"times\" or \"frames\" must be provided'",
   ")",
   "positions",
   "=",
   "frames_to_samples",
   "(",
   "frames",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "else",
   ":",
   "# Convert times to positions",
   "positions",
   "=",
   "time_to_samples",
   "(",
   "times",
   ",",
   "sr",
   "=",
   "sr",
   ")",
   "if",
   "click",
   "is",
   "not",
   "None",
   ":",
   "# Check that we have a well-formed audio buffer",
   "util",
   ".",
   "valid_audio",
   "(",
   "click",
   ",",
   "mono",
   "=",
   "True",
   ")",
   "else",
   ":",
   "# Create default click signal",
   "if",
   "click_duration",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'click_duration must be strictly positive'",
   ")",
   "if",
   "click_freq",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'click_freq must be strictly positive'",
   ")",
   "angular_freq",
   "=",
   "2",
   "*",
   "np",
   ".",
   "pi",
   "*",
   "click_freq",
   "/",
   "float",
   "(",
   "sr",
   ")",
   "click",
   "=",
   "np",
   ".",
   "logspace",
   "(",
   "0",
   ",",
   "-",
   "10",
   ",",
   "num",
   "=",
   "int",
   "(",
   "np",
   ".",
   "round",
   "(",
   "sr",
   "*",
   "click_duration",
   ")",
   ")",
   ",",
   "base",
   "=",
   "2.0",
   ")",
   "click",
   "*=",
   "np",
   ".",
   "sin",
   "(",
   "angular_freq",
   "*",
   "np",
   ".",
   "arange",
   "(",
   "len",
   "(",
   "click",
   ")",
   ")",
   ")",
   "# Set default length",
   "if",
   "length",
   "is",
   "None",
   ":",
   "length",
   "=",
   "positions",
   ".",
   "<mask>",
   "(",
   ")",
   "+",
   "click",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "else",
   ":",
   "if",
   "length",
   "<",
   "1",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'length must be a positive integer'",
   ")",
   "# Filter out any positions past the length boundary",
   "positions",
   "=",
   "positions",
   "[",
   "positions",
   "<",
   "length",
   "]",
   "# Pre-allocate click signal",
   "click_signal",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "length",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "float32",
   ")",
   "# Place clicks",
   "for",
   "start",
   "in",
   "positions",
   ":",
   "# Compute the end-point of this click",
   "end",
   "=",
   "start",
   "+",
   "click",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "if",
   "end",
   ">=",
   "length",
   ":",
   "click_signal",
   "[",
   "start",
   ":",
   "]",
   "+=",
   "click",
   "[",
   ":",
   "length",
   "-",
   "start",
   "]",
   "else",
   ":",
   "# Normally, just add a click here",
   "click_signal",
   "[",
   "start",
   ":",
   "end",
   "]",
   "+=",
   "click",
   "return",
   "click_signal"
  ]
 },
 {
  "idx": "maxmin-1221",
  "nl_tokens": [
   "Compute",
   "a",
   "recurrence",
   "matrix",
   "from",
   "a",
   "data",
   "matrix",
   "."
  ],
  "pl_tokens": [
   "def",
   "recurrence_matrix",
   "(",
   "data",
   ",",
   "k",
   "=",
   "None",
   ",",
   "width",
   "=",
   "1",
   ",",
   "metric",
   "=",
   "'euclidean'",
   ",",
   "sym",
   "=",
   "False",
   ",",
   "sparse",
   "=",
   "False",
   ",",
   "mode",
   "=",
   "'connectivity'",
   ",",
   "bandwidth",
   "=",
   "None",
   ",",
   "self",
   "=",
   "False",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   ":",
   "data",
   "=",
   "np",
   ".",
   "atleast_2d",
   "(",
   "data",
   ")",
   "# Swap observations to the first dimension and flatten the rest",
   "data",
   "=",
   "np",
   ".",
   "swapaxes",
   "(",
   "data",
   ",",
   "axis",
   ",",
   "0",
   ")",
   "t",
   "=",
   "data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "data",
   "=",
   "data",
   ".",
   "reshape",
   "(",
   "(",
   "t",
   ",",
   "-",
   "1",
   ")",
   ")",
   "if",
   "width",
   "<",
   "1",
   "or",
   "width",
   ">",
   "t",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'width={} must be at least 1 and at most data.shape[{}]={}'",
   ".",
   "format",
   "(",
   "width",
   ",",
   "axis",
   ",",
   "t",
   ")",
   ")",
   "if",
   "mode",
   "not",
   "in",
   "[",
   "'connectivity'",
   ",",
   "'distance'",
   ",",
   "'affinity'",
   "]",
   ":",
   "raise",
   "ParameterError",
   "(",
   "(",
   "\"Invalid mode='{}'. Must be one of \"",
   "\"['connectivity', 'distance', \"",
   "\"'affinity']\"",
   ")",
   ".",
   "format",
   "(",
   "mode",
   ")",
   ")",
   "if",
   "k",
   "is",
   "None",
   ":",
   "if",
   "t",
   ">",
   "2",
   "*",
   "width",
   "+",
   "1",
   ":",
   "k",
   "=",
   "2",
   "*",
   "np",
   ".",
   "ceil",
   "(",
   "np",
   ".",
   "sqrt",
   "(",
   "t",
   "-",
   "2",
   "*",
   "width",
   "+",
   "1",
   ")",
   ")",
   "else",
   ":",
   "k",
   "=",
   "2",
   "if",
   "bandwidth",
   "is",
   "not",
   "None",
   ":",
   "if",
   "bandwidth",
   "<=",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Invalid bandwidth={}. '",
   "'Must be strictly positive.'",
   ".",
   "format",
   "(",
   "bandwidth",
   ")",
   ")",
   "k",
   "=",
   "int",
   "(",
   "k",
   ")",
   "# Build the neighbor search object",
   "try",
   ":",
   "knn",
   "=",
   "sklearn",
   ".",
   "neighbors",
   ".",
   "NearestNeighbors",
   "(",
   "n_neighbors",
   "=",
   "<mask>",
   "(",
   "t",
   "-",
   "1",
   ",",
   "k",
   "+",
   "2",
   "*",
   "width",
   ")",
   ",",
   "metric",
   "=",
   "metric",
   ",",
   "algorithm",
   "=",
   "'auto'",
   ")",
   "except",
   "ValueError",
   ":",
   "knn",
   "=",
   "sklearn",
   ".",
   "neighbors",
   ".",
   "NearestNeighbors",
   "(",
   "n_neighbors",
   "=",
   "min",
   "(",
   "t",
   "-",
   "1",
   ",",
   "k",
   "+",
   "2",
   "*",
   "width",
   ")",
   ",",
   "metric",
   "=",
   "metric",
   ",",
   "algorithm",
   "=",
   "'brute'",
   ")",
   "knn",
   ".",
   "fit",
   "(",
   "data",
   ")",
   "# Get the knn graph",
   "if",
   "mode",
   "==",
   "'affinity'",
   ":",
   "kng_mode",
   "=",
   "'distance'",
   "else",
   ":",
   "kng_mode",
   "=",
   "mode",
   "rec",
   "=",
   "knn",
   ".",
   "kneighbors_graph",
   "(",
   "mode",
   "=",
   "kng_mode",
   ")",
   ".",
   "tolil",
   "(",
   ")",
   "# Remove connections within width",
   "for",
   "diag",
   "in",
   "range",
   "(",
   "-",
   "width",
   "+",
   "1",
   ",",
   "width",
   ")",
   ":",
   "rec",
   ".",
   "setdiag",
   "(",
   "0",
   ",",
   "diag",
   ")",
   "# Retain only the top-k links per point",
   "for",
   "i",
   "in",
   "range",
   "(",
   "t",
   ")",
   ":",
   "# Get the links from point i",
   "links",
   "=",
   "rec",
   "[",
   "i",
   "]",
   ".",
   "nonzero",
   "(",
   ")",
   "[",
   "1",
   "]",
   "# Order them ascending",
   "idx",
   "=",
   "links",
   "[",
   "np",
   ".",
   "argsort",
   "(",
   "rec",
   "[",
   "i",
   ",",
   "links",
   "]",
   ".",
   "toarray",
   "(",
   ")",
   ")",
   "]",
   "[",
   "0",
   "]",
   "# Everything past the kth closest gets squashed",
   "rec",
   "[",
   "i",
   ",",
   "idx",
   "[",
   "k",
   ":",
   "]",
   "]",
   "=",
   "0",
   "if",
   "self",
   ":",
   "if",
   "mode",
   "==",
   "'connectivity'",
   ":",
   "rec",
   ".",
   "setdiag",
   "(",
   "1",
   ")",
   "elif",
   "mode",
   "==",
   "'affinity'",
   ":",
   "# we need to keep the self-loop in here, but not mess up the",
   "# bandwidth estimation",
   "#",
   "# using negative distances here preserves the structure without changing",
   "# the statistics of the data",
   "rec",
   ".",
   "setdiag",
   "(",
   "-",
   "1",
   ")",
   "# symmetrize",
   "if",
   "sym",
   ":",
   "# Note: this operation produces a CSR (compressed sparse row) matrix!",
   "# This is why we have to do it after filling the diagonal in self-mode",
   "rec",
   "=",
   "rec",
   ".",
   "minimum",
   "(",
   "rec",
   ".",
   "T",
   ")",
   "rec",
   "=",
   "rec",
   ".",
   "tocsr",
   "(",
   ")",
   "rec",
   ".",
   "eliminate_zeros",
   "(",
   ")",
   "if",
   "mode",
   "==",
   "'connectivity'",
   ":",
   "rec",
   "=",
   "rec",
   ".",
   "astype",
   "(",
   "np",
   ".",
   "bool",
   ")",
   "elif",
   "mode",
   "==",
   "'affinity'",
   ":",
   "if",
   "bandwidth",
   "is",
   "None",
   ":",
   "bandwidth",
   "=",
   "np",
   ".",
   "nanmedian",
   "(",
   "rec",
   ".",
   "max",
   "(",
   "axis",
   "=",
   "1",
   ")",
   ".",
   "data",
   ")",
   "# Set all the negatives back to 0",
   "# Negatives are temporarily inserted above to preserve the sparsity structure",
   "# of the matrix without corrupting the bandwidth calculations",
   "rec",
   ".",
   "data",
   "[",
   "rec",
   ".",
   "data",
   "<",
   "0",
   "]",
   "=",
   "0.0",
   "rec",
   ".",
   "data",
   "[",
   ":",
   "]",
   "=",
   "np",
   ".",
   "exp",
   "(",
   "rec",
   ".",
   "data",
   "/",
   "(",
   "-",
   "1",
   "*",
   "bandwidth",
   ")",
   ")",
   "if",
   "not",
   "sparse",
   ":",
   "rec",
   "=",
   "rec",
   ".",
   "toarray",
   "(",
   ")",
   "return",
   "rec"
  ]
 },
 {
  "idx": "maxmin-1222",
  "nl_tokens": [
   "Converts",
   "kwargs",
   "given",
   "to",
   "PSF",
   "to",
   "a",
   "querystring",
   "."
  ],
  "pl_tokens": [
   "def",
   "_kwargs_to_qs",
   "(",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "# start with defaults",
   "inpOptDef",
   "=",
   "inputs_options_defaults",
   "(",
   ")",
   "opts",
   "=",
   "{",
   "name",
   ":",
   "dct",
   "[",
   "'value'",
   "]",
   "for",
   "name",
   ",",
   "dct",
   "in",
   "inpOptDef",
   ".",
   "items",
   "(",
   ")",
   "}",
   "# clean up keys and values",
   "for",
   "k",
   ",",
   "v",
   "in",
   "kwargs",
   ".",
   "items",
   "(",
   ")",
   ":",
   "del",
   "kwargs",
   "[",
   "k",
   "]",
   "# bool => 'Y'|'N'",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "bool",
   ")",
   ":",
   "kwargs",
   "[",
   "k",
   "]",
   "=",
   "'Y'",
   "if",
   "v",
   "else",
   "'N'",
   "# tm, team => team_id",
   "elif",
   "k",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "(",
   "'tm'",
   ",",
   "'team'",
   ")",
   ":",
   "kwargs",
   "[",
   "'team_id'",
   "]",
   "=",
   "v",
   "# yr, year, yrs, years => year_min, year_max",
   "elif",
   "k",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "(",
   "'yr'",
   ",",
   "'year'",
   ",",
   "'yrs'",
   ",",
   "'years'",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "collections",
   ".",
   "Iterable",
   ")",
   ":",
   "lst",
   "=",
   "list",
   "(",
   "v",
   ")",
   "kwargs",
   "[",
   "'year_min'",
   "]",
   "=",
   "<mask>",
   "(",
   "lst",
   ")",
   "kwargs",
   "[",
   "'year_max'",
   "]",
   "=",
   "max",
   "(",
   "lst",
   ")",
   "elif",
   "isinstance",
   "(",
   "v",
   ",",
   "basestring",
   ")",
   ":",
   "v",
   "=",
   "list",
   "(",
   "map",
   "(",
   "int",
   ",",
   "v",
   ".",
   "split",
   "(",
   "','",
   ")",
   ")",
   ")",
   "kwargs",
   "[",
   "'year_min'",
   "]",
   "=",
   "min",
   "(",
   "v",
   ")",
   "kwargs",
   "[",
   "'year_max'",
   "]",
   "=",
   "max",
   "(",
   "v",
   ")",
   "else",
   ":",
   "kwargs",
   "[",
   "'year_min'",
   "]",
   "=",
   "v",
   "kwargs",
   "[",
   "'year_max'",
   "]",
   "=",
   "v",
   "# pos, position, positions => pos[]",
   "elif",
   "k",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "(",
   "'pos'",
   ",",
   "'position'",
   ",",
   "'positions'",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "basestring",
   ")",
   ":",
   "v",
   "=",
   "v",
   ".",
   "split",
   "(",
   "','",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "v",
   ",",
   "collections",
   ".",
   "Iterable",
   ")",
   ":",
   "v",
   "=",
   "[",
   "v",
   "]",
   "kwargs",
   "[",
   "'pos[]'",
   "]",
   "=",
   "v",
   "# draft_pos, ... => draft_pos[]",
   "elif",
   "k",
   ".",
   "lower",
   "(",
   ")",
   "in",
   "(",
   "'draft_pos'",
   ",",
   "'draftpos'",
   ",",
   "'draftposition'",
   ",",
   "'draftpositions'",
   ",",
   "'draft_position'",
   ",",
   "'draft_positions'",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "basestring",
   ")",
   ":",
   "v",
   "=",
   "v",
   ".",
   "split",
   "(",
   "','",
   ")",
   "elif",
   "not",
   "isinstance",
   "(",
   "v",
   ",",
   "collections",
   ".",
   "Iterable",
   ")",
   ":",
   "v",
   "=",
   "[",
   "v",
   "]",
   "kwargs",
   "[",
   "'draft_pos[]'",
   "]",
   "=",
   "v",
   "# if not one of these cases, put it back in kwargs",
   "else",
   ":",
   "kwargs",
   "[",
   "k",
   "]",
   "=",
   "v",
   "# update based on kwargs",
   "for",
   "k",
   ",",
   "v",
   "in",
   "kwargs",
   ".",
   "items",
   "(",
   ")",
   ":",
   "# if overwriting a default, overwrite it (with a list so the",
   "# opts -> querystring list comp works)",
   "if",
   "k",
   "in",
   "opts",
   "or",
   "k",
   "in",
   "(",
   "'pos[]'",
   ",",
   "'draft_pos[]'",
   ")",
   ":",
   "# if multiple values separated by commas, split em",
   "if",
   "isinstance",
   "(",
   "v",
   ",",
   "basestring",
   ")",
   ":",
   "v",
   "=",
   "v",
   ".",
   "split",
   "(",
   "','",
   ")",
   "# otherwise, make sure it's a list",
   "elif",
   "not",
   "isinstance",
   "(",
   "v",
   ",",
   "collections",
   ".",
   "Iterable",
   ")",
   ":",
   "v",
   "=",
   "[",
   "v",
   "]",
   "# then, add list of values to the querystring dict *opts*",
   "opts",
   "[",
   "k",
   "]",
   "=",
   "v",
   "if",
   "'draft'",
   "in",
   "k",
   ":",
   "opts",
   "[",
   "'draft'",
   "]",
   "=",
   "[",
   "1",
   "]",
   "opts",
   "[",
   "'request'",
   "]",
   "=",
   "[",
   "1",
   "]",
   "opts",
   "[",
   "'offset'",
   "]",
   "=",
   "[",
   "kwargs",
   ".",
   "get",
   "(",
   "'offset'",
   ",",
   "0",
   ")",
   "]",
   "qs",
   "=",
   "'&'",
   ".",
   "join",
   "(",
   "'{}={}'",
   ".",
   "format",
   "(",
   "urllib",
   ".",
   "parse",
   ".",
   "quote_plus",
   "(",
   "name",
   ")",
   ",",
   "val",
   ")",
   "for",
   "name",
   ",",
   "vals",
   "in",
   "sorted",
   "(",
   "opts",
   ".",
   "items",
   "(",
   ")",
   ")",
   "for",
   "val",
   "in",
   "vals",
   ")",
   "return",
   "qs"
  ]
 },
 {
  "idx": "maxmin-1223",
  "nl_tokens": [
   "Create",
   "a",
   "matrix",
   "of",
   "randomly",
   "-",
   "initialized",
   "weights",
   "."
  ],
  "pl_tokens": [
   "def",
   "random_matrix",
   "(",
   "rows",
   ",",
   "cols",
   ",",
   "mean",
   "=",
   "0",
   ",",
   "std",
   "=",
   "1",
   ",",
   "sparsity",
   "=",
   "0",
   ",",
   "radius",
   "=",
   "0",
   ",",
   "diagonal",
   "=",
   "0",
   ",",
   "rng",
   "=",
   "None",
   ")",
   ":",
   "if",
   "rng",
   "is",
   "None",
   "or",
   "isinstance",
   "(",
   "rng",
   ",",
   "int",
   ")",
   ":",
   "rng",
   "=",
   "np",
   ".",
   "random",
   ".",
   "RandomState",
   "(",
   "rng",
   ")",
   "arr",
   "=",
   "mean",
   "+",
   "std",
   "*",
   "rng",
   ".",
   "randn",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   "if",
   "1",
   ">",
   "sparsity",
   ">",
   "0",
   ":",
   "k",
   "=",
   "<mask>",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   "mask",
   "=",
   "rng",
   ".",
   "binomial",
   "(",
   "n",
   "=",
   "1",
   ",",
   "p",
   "=",
   "1",
   "-",
   "sparsity",
   ",",
   "size",
   "=",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   ")",
   ".",
   "astype",
   "(",
   "bool",
   ")",
   "mask",
   "[",
   ":",
   "k",
   ",",
   ":",
   "k",
   "]",
   "|=",
   "np",
   ".",
   "eye",
   "(",
   "k",
   ")",
   ".",
   "astype",
   "(",
   "bool",
   ")",
   "arr",
   "*=",
   "mask",
   "if",
   "radius",
   ">",
   "0",
   ":",
   "# rescale weights to have the appropriate spectral radius.",
   "u",
   ",",
   "s",
   ",",
   "vT",
   "=",
   "np",
   ".",
   "linalg",
   ".",
   "svd",
   "(",
   "arr",
   ",",
   "full_matrices",
   "=",
   "False",
   ")",
   "arr",
   "=",
   "np",
   ".",
   "dot",
   "(",
   "np",
   ".",
   "dot",
   "(",
   "u",
   ",",
   "np",
   ".",
   "diag",
   "(",
   "radius",
   "*",
   "s",
   "/",
   "abs",
   "(",
   "s",
   "[",
   "0",
   "]",
   ")",
   ")",
   ")",
   ",",
   "vT",
   ")",
   "if",
   "diagonal",
   "!=",
   "0",
   ":",
   "# generate a diagonal weight matrix. ignore other options.",
   "arr",
   "=",
   "diagonal",
   "*",
   "np",
   ".",
   "eye",
   "(",
   "max",
   "(",
   "rows",
   ",",
   "cols",
   ")",
   ")",
   "[",
   ":",
   "rows",
   ",",
   ":",
   "cols",
   "]",
   "return",
   "arr",
   ".",
   "astype",
   "(",
   "FLOAT",
   ")"
  ]
 },
 {
  "idx": "maxmin-1224",
  "nl_tokens": [
   "TODO",
   ":",
   "update",
   "docs"
  ],
  "pl_tokens": [
   "def",
   "fit",
   "(",
   "self",
   ",",
   "data",
   ":",
   "List",
   "[",
   "str",
   "]",
   ",",
   "return_tokenized_data",
   ":",
   "bool",
   "=",
   "False",
   ")",
   "->",
   "Union",
   "[",
   "None",
   ",",
   "List",
   "[",
   "List",
   "[",
   "str",
   "]",
   "]",
   "]",
   ":",
   "self",
   ".",
   "__clear_data",
   "(",
   ")",
   "now",
   "=",
   "get_time",
   "(",
   ")",
   "logging",
   ".",
   "warning",
   "(",
   "f'....tokenizing data'",
   ")",
   "tokenized_data",
   "=",
   "self",
   ".",
   "parallel_process_text",
   "(",
   "data",
   ")",
   "if",
   "not",
   "self",
   ".",
   "padding_maxlen",
   ":",
   "# its not worth the overhead to parallelize document length counts",
   "length_counts",
   "=",
   "map",
   "(",
   "count_len",
   ",",
   "tokenized_data",
   ")",
   "self",
   ".",
   "document_length_histogram",
   "=",
   "Counter",
   "(",
   "length_counts",
   ")",
   "self",
   ".",
   "generate_doc_length_stats",
   "(",
   ")",
   "# Learn corpus on single thread",
   "logging",
   ".",
   "warning",
   "(",
   "f'(1/2) done. {time_diff(now)} sec'",
   ")",
   "logging",
   ".",
   "warning",
   "(",
   "f'....building corpus'",
   ")",
   "now",
   "=",
   "get_time",
   "(",
   ")",
   "self",
   ".",
   "indexer",
   "=",
   "custom_Indexer",
   "(",
   "num_words",
   "=",
   "self",
   ".",
   "keep_n",
   ")",
   "self",
   ".",
   "indexer",
   ".",
   "fit_on_tokenized_texts",
   "(",
   "tokenized_data",
   ")",
   "# Build Dictionary accounting For 0 padding, and reserve 1 for unknown and rare Words",
   "self",
   ".",
   "token2id",
   "=",
   "self",
   ".",
   "indexer",
   ".",
   "word_index",
   "self",
   ".",
   "id2token",
   "=",
   "{",
   "v",
   ":",
   "k",
   "for",
   "k",
   ",",
   "v",
   "in",
   "self",
   ".",
   "token2id",
   ".",
   "items",
   "(",
   ")",
   "}",
   "self",
   ".",
   "n_tokens",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "indexer",
   ".",
   "word_index",
   ".",
   "values",
   "(",
   ")",
   ")",
   "# logging",
   "logging",
   ".",
   "warning",
   "(",
   "f'(2/2) done. {time_diff(now)} sec'",
   ")",
   "logging",
   ".",
   "warning",
   "(",
   "f'Finished parsing {self.indexer.document_count:,} documents.'",
   ")",
   "if",
   "return_tokenized_data",
   ":",
   "return",
   "tokenized_data"
  ]
 },
 {
  "idx": "maxmin-1225",
  "nl_tokens": [
   "Computes",
   "the",
   "precision"
  ],
  "pl_tokens": [
   "def",
   "accuracy",
   "(",
   "output",
   ",",
   "target",
   ",",
   "topk",
   "=",
   "(",
   "1",
   ",",
   ")",
   ")",
   ":",
   "with",
   "torch",
   ".",
   "no_grad",
   "(",
   ")",
   ":",
   "maxk",
   "=",
   "<mask>",
   "(",
   "topk",
   ")",
   "batch_size",
   "=",
   "target",
   ".",
   "size",
   "(",
   "0",
   ")",
   "_",
   ",",
   "pred",
   "=",
   "output",
   ".",
   "topk",
   "(",
   "maxk",
   ",",
   "1",
   ",",
   "True",
   ",",
   "True",
   ")",
   "pred",
   "=",
   "pred",
   ".",
   "t",
   "(",
   ")",
   "correct",
   "=",
   "pred",
   ".",
   "eq",
   "(",
   "target",
   ".",
   "view",
   "(",
   "1",
   ",",
   "-",
   "1",
   ")",
   ".",
   "expand_as",
   "(",
   "pred",
   ")",
   ")",
   "res",
   "=",
   "[",
   "]",
   "for",
   "k",
   "in",
   "topk",
   ":",
   "correct_k",
   "=",
   "correct",
   "[",
   ":",
   "k",
   "]",
   ".",
   "view",
   "(",
   "-",
   "1",
   ")",
   ".",
   "float",
   "(",
   ")",
   ".",
   "sum",
   "(",
   "0",
   ",",
   "keepdim",
   "=",
   "True",
   ")",
   "res",
   ".",
   "append",
   "(",
   "correct_k",
   ".",
   "mul_",
   "(",
   "100.0",
   "/",
   "batch_size",
   ")",
   ")",
   "return",
   "res"
  ]
 },
 {
  "idx": "maxmin-1226",
  "nl_tokens": [
   "Guesses",
   "the",
   "compression",
   "of",
   "an",
   "input",
   "file",
   "."
  ],
  "pl_tokens": [
   "def",
   "guess_file_compression",
   "(",
   "file_path",
   ",",
   "magic_dict",
   "=",
   "None",
   ")",
   ":",
   "if",
   "not",
   "magic_dict",
   ":",
   "magic_dict",
   "=",
   "MAGIC_DICT",
   "max_len",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "x",
   ")",
   "for",
   "x",
   "in",
   "magic_dict",
   ")",
   "with",
   "open",
   "(",
   "file_path",
   ",",
   "\"rb\"",
   ")",
   "as",
   "f",
   ":",
   "file_start",
   "=",
   "f",
   ".",
   "read",
   "(",
   "max_len",
   ")",
   "logger",
   ".",
   "debug",
   "(",
   "\"Binary signature start: {}\"",
   ".",
   "format",
   "(",
   "file_start",
   ")",
   ")",
   "for",
   "magic",
   ",",
   "file_type",
   "in",
   "magic_dict",
   ".",
   "items",
   "(",
   ")",
   ":",
   "if",
   "file_start",
   ".",
   "startswith",
   "(",
   "magic",
   ")",
   ":",
   "return",
   "file_type",
   "return",
   "None"
  ]
 },
 {
  "idx": "maxmin-1227",
  "nl_tokens": [
   "Plots",
   "the",
   "results",
   "of",
   "one",
   "track",
   "with",
   "ground",
   "truth",
   "if",
   "it",
   "exists",
   "."
  ],
  "pl_tokens": [
   "def",
   "plot_one_track",
   "(",
   "file_struct",
   ",",
   "est_times",
   ",",
   "est_labels",
   ",",
   "boundaries_id",
   ",",
   "labels_id",
   ",",
   "title",
   "=",
   "None",
   ")",
   ":",
   "import",
   "matplotlib",
   ".",
   "pyplot",
   "as",
   "plt",
   "# Set up the boundaries id",
   "bid_lid",
   "=",
   "boundaries_id",
   "if",
   "labels_id",
   "is",
   "not",
   "None",
   ":",
   "bid_lid",
   "+=",
   "\" + \"",
   "+",
   "labels_id",
   "try",
   ":",
   "# Read file",
   "jam",
   "=",
   "jams",
   ".",
   "load",
   "(",
   "file_struct",
   ".",
   "ref_file",
   ")",
   "ann",
   "=",
   "jam",
   ".",
   "search",
   "(",
   "namespace",
   "=",
   "'segment_.*'",
   ")",
   "[",
   "0",
   "]",
   "ref_inters",
   ",",
   "ref_labels",
   "=",
   "ann",
   ".",
   "to_interval_values",
   "(",
   ")",
   "# To times",
   "ref_times",
   "=",
   "utils",
   ".",
   "intervals_to_times",
   "(",
   "ref_inters",
   ")",
   "all_boundaries",
   "=",
   "[",
   "ref_times",
   ",",
   "est_times",
   "]",
   "all_labels",
   "=",
   "[",
   "ref_labels",
   ",",
   "est_labels",
   "]",
   "algo_ids",
   "=",
   "[",
   "\"GT\"",
   ",",
   "bid_lid",
   "]",
   "except",
   ":",
   "logging",
   ".",
   "warning",
   "(",
   "\"No references found in %s. Not plotting groundtruth\"",
   "%",
   "file_struct",
   ".",
   "ref_file",
   ")",
   "all_boundaries",
   "=",
   "[",
   "est_times",
   "]",
   "all_labels",
   "=",
   "[",
   "est_labels",
   "]",
   "algo_ids",
   "=",
   "[",
   "bid_lid",
   "]",
   "N",
   "=",
   "len",
   "(",
   "all_boundaries",
   ")",
   "# Index the labels to normalize them",
   "for",
   "i",
   ",",
   "labels",
   "in",
   "enumerate",
   "(",
   "all_labels",
   ")",
   ":",
   "all_labels",
   "[",
   "i",
   "]",
   "=",
   "mir_eval",
   ".",
   "util",
   ".",
   "index_labels",
   "(",
   "labels",
   ")",
   "[",
   "0",
   "]",
   "# Get color map",
   "cm",
   "=",
   "plt",
   ".",
   "get_cmap",
   "(",
   "'gist_rainbow'",
   ")",
   "max_label",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "labels",
   ")",
   "for",
   "labels",
   "in",
   "all_labels",
   ")",
   "figsize",
   "=",
   "(",
   "8",
   ",",
   "4",
   ")",
   "plt",
   ".",
   "figure",
   "(",
   "1",
   ",",
   "figsize",
   "=",
   "figsize",
   ",",
   "dpi",
   "=",
   "120",
   ",",
   "facecolor",
   "=",
   "'w'",
   ",",
   "edgecolor",
   "=",
   "'k'",
   ")",
   "for",
   "i",
   ",",
   "boundaries",
   "in",
   "enumerate",
   "(",
   "all_boundaries",
   ")",
   ":",
   "color",
   "=",
   "\"b\"",
   "if",
   "i",
   "==",
   "0",
   ":",
   "color",
   "=",
   "\"g\"",
   "for",
   "b",
   "in",
   "boundaries",
   ":",
   "plt",
   ".",
   "axvline",
   "(",
   "b",
   ",",
   "i",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "(",
   "i",
   "+",
   "1",
   ")",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "color",
   "=",
   "color",
   ")",
   "if",
   "labels_id",
   "is",
   "not",
   "None",
   ":",
   "labels",
   "=",
   "all_labels",
   "[",
   "i",
   "]",
   "inters",
   "=",
   "utils",
   ".",
   "times_to_intervals",
   "(",
   "boundaries",
   ")",
   "for",
   "label",
   ",",
   "inter",
   "in",
   "zip",
   "(",
   "labels",
   ",",
   "inters",
   ")",
   ":",
   "plt",
   ".",
   "axvspan",
   "(",
   "inter",
   "[",
   "0",
   "]",
   ",",
   "inter",
   "[",
   "1",
   "]",
   ",",
   "ymin",
   "=",
   "i",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "ymax",
   "=",
   "(",
   "i",
   "+",
   "1",
   ")",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "alpha",
   "=",
   "0.6",
   ",",
   "color",
   "=",
   "cm",
   "(",
   "label",
   "/",
   "float",
   "(",
   "max_label",
   ")",
   ")",
   ")",
   "plt",
   ".",
   "axhline",
   "(",
   "i",
   "/",
   "float",
   "(",
   "N",
   ")",
   ",",
   "color",
   "=",
   "\"k\"",
   ",",
   "linewidth",
   "=",
   "1",
   ")",
   "# Format plot",
   "_plot_formatting",
   "(",
   "title",
   ",",
   "os",
   ".",
   "path",
   ".",
   "basename",
   "(",
   "file_struct",
   ".",
   "audio_file",
   ")",
   ",",
   "algo_ids",
   ",",
   "all_boundaries",
   "[",
   "0",
   "]",
   "[",
   "-",
   "1",
   "]",
   ",",
   "N",
   ",",
   "None",
   ")"
  ]
 },
 {
  "idx": "maxmin-1228",
  "nl_tokens": [
   "Puts",
   "each",
   "data",
   "field",
   "into",
   "a",
   "tensor",
   "/",
   "DataContainer",
   "with",
   "outer",
   "dimension",
   "batch",
   "size",
   "."
  ],
  "pl_tokens": [
   "def",
   "collate",
   "(",
   "batch",
   ",",
   "samples_per_gpu",
   "=",
   "1",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "batch",
   ",",
   "collections",
   ".",
   "Sequence",
   ")",
   ":",
   "raise",
   "TypeError",
   "(",
   "\"{} is not supported.\"",
   ".",
   "format",
   "(",
   "batch",
   ".",
   "dtype",
   ")",
   ")",
   "if",
   "isinstance",
   "(",
   "batch",
   "[",
   "0",
   "]",
   ",",
   "DataContainer",
   ")",
   ":",
   "assert",
   "len",
   "(",
   "batch",
   ")",
   "%",
   "samples_per_gpu",
   "==",
   "0",
   "stacked",
   "=",
   "[",
   "]",
   "if",
   "batch",
   "[",
   "0",
   "]",
   ".",
   "cpu_only",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "batch",
   ")",
   ",",
   "samples_per_gpu",
   ")",
   ":",
   "stacked",
   ".",
   "append",
   "(",
   "[",
   "sample",
   ".",
   "data",
   "for",
   "sample",
   "in",
   "batch",
   "[",
   "i",
   ":",
   "i",
   "+",
   "samples_per_gpu",
   "]",
   "]",
   ")",
   "return",
   "DataContainer",
   "(",
   "stacked",
   ",",
   "batch",
   "[",
   "0",
   "]",
   ".",
   "stack",
   ",",
   "batch",
   "[",
   "0",
   "]",
   ".",
   "padding_value",
   ",",
   "cpu_only",
   "=",
   "True",
   ")",
   "elif",
   "batch",
   "[",
   "0",
   "]",
   ".",
   "stack",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "batch",
   ")",
   ",",
   "samples_per_gpu",
   ")",
   ":",
   "assert",
   "isinstance",
   "(",
   "batch",
   "[",
   "i",
   "]",
   ".",
   "data",
   ",",
   "torch",
   ".",
   "Tensor",
   ")",
   "# TODO: handle tensors other than 3d",
   "assert",
   "batch",
   "[",
   "i",
   "]",
   ".",
   "dim",
   "(",
   ")",
   "==",
   "3",
   "c",
   ",",
   "h",
   ",",
   "w",
   "=",
   "batch",
   "[",
   "i",
   "]",
   ".",
   "size",
   "(",
   ")",
   "for",
   "sample",
   "in",
   "batch",
   "[",
   "i",
   ":",
   "i",
   "+",
   "samples_per_gpu",
   "]",
   ":",
   "assert",
   "c",
   "==",
   "sample",
   ".",
   "size",
   "(",
   "0",
   ")",
   "h",
   "=",
   "<mask>",
   "(",
   "h",
   ",",
   "sample",
   ".",
   "size",
   "(",
   "1",
   ")",
   ")",
   "w",
   "=",
   "max",
   "(",
   "w",
   ",",
   "sample",
   ".",
   "size",
   "(",
   "2",
   ")",
   ")",
   "padded_samples",
   "=",
   "[",
   "F",
   ".",
   "pad",
   "(",
   "sample",
   ".",
   "data",
   ",",
   "(",
   "0",
   ",",
   "w",
   "-",
   "sample",
   ".",
   "size",
   "(",
   "2",
   ")",
   ",",
   "0",
   ",",
   "h",
   "-",
   "sample",
   ".",
   "size",
   "(",
   "1",
   ")",
   ")",
   ",",
   "value",
   "=",
   "sample",
   ".",
   "padding_value",
   ")",
   "for",
   "sample",
   "in",
   "batch",
   "[",
   "i",
   ":",
   "i",
   "+",
   "samples_per_gpu",
   "]",
   "]",
   "stacked",
   ".",
   "append",
   "(",
   "default_collate",
   "(",
   "padded_samples",
   ")",
   ")",
   "else",
   ":",
   "for",
   "i",
   "in",
   "range",
   "(",
   "0",
   ",",
   "len",
   "(",
   "batch",
   ")",
   ",",
   "samples_per_gpu",
   ")",
   ":",
   "stacked",
   ".",
   "append",
   "(",
   "[",
   "sample",
   ".",
   "data",
   "for",
   "sample",
   "in",
   "batch",
   "[",
   "i",
   ":",
   "i",
   "+",
   "samples_per_gpu",
   "]",
   "]",
   ")",
   "return",
   "DataContainer",
   "(",
   "stacked",
   ",",
   "batch",
   "[",
   "0",
   "]",
   ".",
   "stack",
   ",",
   "batch",
   "[",
   "0",
   "]",
   ".",
   "padding_value",
   ")",
   "elif",
   "isinstance",
   "(",
   "batch",
   "[",
   "0",
   "]",
   ",",
   "collections",
   ".",
   "Sequence",
   ")",
   ":",
   "transposed",
   "=",
   "zip",
   "(",
   "*",
   "batch",
   ")",
   "return",
   "[",
   "collate",
   "(",
   "samples",
   ",",
   "samples_per_gpu",
   ")",
   "for",
   "samples",
   "in",
   "transposed",
   "]",
   "elif",
   "isinstance",
   "(",
   "batch",
   "[",
   "0",
   "]",
   ",",
   "collections",
   ".",
   "Mapping",
   ")",
   ":",
   "return",
   "{",
   "key",
   ":",
   "collate",
   "(",
   "[",
   "d",
   "[",
   "key",
   "]",
   "for",
   "d",
   "in",
   "batch",
   "]",
   ",",
   "samples_per_gpu",
   ")",
   "for",
   "key",
   "in",
   "batch",
   "[",
   "0",
   "]",
   "}",
   "else",
   ":",
   "return",
   "default_collate",
   "(",
   "batch",
   ")"
  ]
 },
 {
  "idx": "maxmin-1229",
  "nl_tokens": [
   "convert",
   "python",
   "slice",
   "to",
   "value",
   "of",
   "SLICE",
   "hdl",
   "type"
  ],
  "pl_tokens": [
   "def",
   "slice_to_SLICE",
   "(",
   "sliceVals",
   ",",
   "width",
   ")",
   ":",
   "if",
   "sliceVals",
   ".",
   "step",
   "is",
   "not",
   "None",
   ":",
   "raise",
   "NotImplementedError",
   "(",
   ")",
   "start",
   "=",
   "sliceVals",
   ".",
   "start",
   "stop",
   "=",
   "sliceVals",
   ".",
   "stop",
   "if",
   "sliceVals",
   ".",
   "start",
   "is",
   "None",
   ":",
   "start",
   "=",
   "INT",
   ".",
   "fromPy",
   "(",
   "width",
   ")",
   "else",
   ":",
   "start",
   "=",
   "toHVal",
   "(",
   "sliceVals",
   ".",
   "start",
   ")",
   "if",
   "sliceVals",
   ".",
   "stop",
   "is",
   "None",
   ":",
   "stop",
   "=",
   "INT",
   ".",
   "fromPy",
   "(",
   "0",
   ")",
   "else",
   ":",
   "stop",
   "=",
   "toHVal",
   "(",
   "sliceVals",
   ".",
   "stop",
   ")",
   "startIsVal",
   "=",
   "isinstance",
   "(",
   "start",
   ",",
   "Value",
   ")",
   "stopIsVal",
   "=",
   "isinstance",
   "(",
   "stop",
   ",",
   "Value",
   ")",
   "indexesAreValues",
   "=",
   "startIsVal",
   "and",
   "stopIsVal",
   "if",
   "indexesAreValues",
   ":",
   "updateTime",
   "=",
   "<mask>",
   "(",
   "start",
   ".",
   "updateTime",
   ",",
   "stop",
   ".",
   "updateTime",
   ")",
   "else",
   ":",
   "updateTime",
   "=",
   "-",
   "1",
   "return",
   "Slice",
   ".",
   "getValueCls",
   "(",
   ")",
   "(",
   "(",
   "start",
   ",",
   "stop",
   ")",
   ",",
   "SLICE",
   ",",
   "1",
   ",",
   "updateTime",
   ")"
  ]
 },
 {
  "idx": "maxmin-1230",
  "nl_tokens": [
   ":",
   "return",
   ":",
   "generator",
   "of",
   "TransPart",
   "instance"
  ],
  "pl_tokens": [
   "def",
   "splitOnWords",
   "(",
   "self",
   ",",
   "transaction",
   ",",
   "addrOffset",
   "=",
   "0",
   ")",
   ":",
   "wordWidth",
   "=",
   "self",
   ".",
   "wordWidth",
   "end",
   "=",
   "addrOffset",
   "for",
   "tmp",
   "in",
   "transaction",
   ".",
   "walkFlatten",
   "(",
   "offset",
   "=",
   "addrOffset",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "tmp",
   ",",
   "OneOfTransaction",
   ")",
   ":",
   "split",
   "=",
   "[",
   "self",
   ".",
   "splitOnWords",
   "(",
   "ch",
   ",",
   "end",
   ")",
   "for",
   "ch",
   "in",
   "tmp",
   ".",
   "possibleTransactions",
   "]",
   "yield",
   "from",
   "groupIntoChoices",
   "(",
   "split",
   ",",
   "wordWidth",
   ",",
   "tmp",
   ")",
   "end",
   "=",
   "addrOffset",
   "+",
   "tmp",
   ".",
   "possibleTransactions",
   "[",
   "0",
   "]",
   ".",
   "bitAddrEnd",
   "elif",
   "isinstance",
   "(",
   "tmp",
   ",",
   "StreamTransaction",
   ")",
   ":",
   "ch_len",
   "=",
   "tmp",
   ".",
   "child",
   ".",
   "bit_length",
   "(",
   ")",
   "if",
   "end",
   "%",
   "self",
   ".",
   "wordWidth",
   "!=",
   "0",
   "or",
   "ch_len",
   "!=",
   "self",
   ".",
   "wordWidth",
   ":",
   "# assert start, end is aligned",
   "raise",
   "NotImplementedError",
   "(",
   "tmp",
   ")",
   "else",
   ":",
   "s",
   "=",
   "StreamOfFramePars",
   "(",
   "end",
   ",",
   "tmp",
   ")",
   "s",
   ".",
   "extend",
   "(",
   "self",
   ".",
   "splitOnWords",
   "(",
   "tmp",
   ".",
   "child",
   ",",
   "end",
   ")",
   ")",
   "s",
   ".",
   "setIsLast",
   "(",
   "True",
   ")",
   "s",
   ".",
   "resolveEnd",
   "(",
   ")",
   "yield",
   "s",
   "end",
   "=",
   "addrOffset",
   "+",
   "tmp",
   ".",
   "child",
   ".",
   "bitAddrEnd",
   "else",
   ":",
   "(",
   "base",
   ",",
   "end",
   ")",
   ",",
   "tmpl",
   "=",
   "tmp",
   "startOfPart",
   "=",
   "base",
   "while",
   "startOfPart",
   "!=",
   "end",
   ":",
   "wordIndex",
   "=",
   "startOfPart",
   "//",
   "wordWidth",
   "endOfWord",
   "=",
   "(",
   "wordIndex",
   "+",
   "1",
   ")",
   "*",
   "wordWidth",
   "endOfPart",
   "=",
   "<mask>",
   "(",
   "endOfWord",
   ",",
   "end",
   ")",
   "inFieldOffset",
   "=",
   "startOfPart",
   "-",
   "base",
   "yield",
   "TransPart",
   "(",
   "self",
   ",",
   "tmpl",
   ",",
   "startOfPart",
   ",",
   "endOfPart",
   ",",
   "inFieldOffset",
   ")",
   "startOfPart",
   "=",
   "endOfPart"
  ]
 },
 {
  "idx": "maxmin-1231",
  "nl_tokens": [
   "Roundtrip",
   "all",
   "Xpath",
   "offsets",
   "in",
   "the",
   "given",
   "stream",
   "item",
   "."
  ],
  "pl_tokens": [
   "def",
   "stream_item_roundtrip_xpaths",
   "(",
   "si",
   ",",
   "quick",
   "=",
   "False",
   ")",
   ":",
   "def",
   "debug",
   "(",
   "s",
   ")",
   ":",
   "logger",
   ".",
   "warning",
   "(",
   "s",
   ")",
   "def",
   "print_window",
   "(",
   "token",
   ",",
   "size",
   "=",
   "200",
   ")",
   ":",
   "coffset",
   "=",
   "token",
   ".",
   "offsets",
   "[",
   "OffsetType",
   ".",
   "CHARS",
   "]",
   "start",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "coffset",
   ".",
   "first",
   "-",
   "size",
   ")",
   "end",
   "=",
   "min",
   "(",
   "len",
   "(",
   "html",
   ")",
   ",",
   "coffset",
   ".",
   "first",
   "+",
   "coffset",
   ".",
   "length",
   "+",
   "size",
   ")",
   "debug",
   "(",
   "'-'",
   "*",
   "49",
   ")",
   "debug",
   "(",
   "coffset",
   ")",
   "debug",
   "(",
   "'window size: %d'",
   "%",
   "size",
   ")",
   "debug",
   "(",
   "html",
   "[",
   "start",
   ":",
   "end",
   "]",
   ")",
   "debug",
   "(",
   "'-'",
   "*",
   "49",
   ")",
   "def",
   "debug_all",
   "(",
   "token",
   ",",
   "xprange",
   ",",
   "expected",
   ",",
   "err",
   "=",
   "None",
   ",",
   "got",
   "=",
   "None",
   ")",
   ":",
   "debug",
   "(",
   "'-'",
   "*",
   "79",
   ")",
   "if",
   "err",
   "is",
   "not",
   "None",
   ":",
   "debug",
   "(",
   "err",
   ")",
   "debug",
   "(",
   "xprange",
   ")",
   "debug",
   "(",
   "'expected: \"%s\"'",
   "%",
   "expected",
   ")",
   "if",
   "got",
   "is",
   "not",
   "None",
   ":",
   "debug",
   "(",
   "'got: \"%s\"'",
   "%",
   "got",
   ")",
   "debug",
   "(",
   "'token value: \"%s\"'",
   "%",
   "unicode",
   "(",
   "token",
   ".",
   "token",
   ",",
   "'utf-8'",
   ")",
   ")",
   "print_window",
   "(",
   "token",
   ",",
   "size",
   "=",
   "10",
   ")",
   "print_window",
   "(",
   "token",
   ",",
   "size",
   "=",
   "30",
   ")",
   "print_window",
   "(",
   "token",
   ",",
   "size",
   "=",
   "100",
   ")",
   "print_window",
   "(",
   "token",
   ",",
   "size",
   "=",
   "200",
   ")",
   "debug",
   "(",
   "'-'",
   "*",
   "79",
   ")",
   "def",
   "slice_clean_visible",
   "(",
   "token",
   ")",
   ":",
   "coffset",
   "=",
   "token",
   ".",
   "offsets",
   "[",
   "OffsetType",
   ".",
   "CHARS",
   "]",
   "return",
   "cleanvis",
   "[",
   "coffset",
   ".",
   "first",
   ":",
   "coffset",
   ".",
   "first",
   "+",
   "coffset",
   ".",
   "length",
   "]",
   "def",
   "test_token",
   "(",
   "token",
   ")",
   ":",
   "coffset",
   "=",
   "token",
   ".",
   "offsets",
   ".",
   "get",
   "(",
   "OffsetType",
   ".",
   "CHARS",
   ")",
   "if",
   "coffset",
   "is",
   "None",
   ":",
   "return",
   "False",
   "xoffset",
   "=",
   "token",
   ".",
   "offsets",
   ".",
   "get",
   "(",
   "OffsetType",
   ".",
   "XPATH_CHARS",
   ")",
   "if",
   "xoffset",
   "is",
   "None",
   ":",
   "return",
   "False",
   "crange",
   "=",
   "(",
   "coffset",
   ".",
   "first",
   ",",
   "coffset",
   ".",
   "first",
   "+",
   "coffset",
   ".",
   "length",
   ")",
   "xprange",
   "=",
   "XpathRange",
   ".",
   "from_offset",
   "(",
   "xoffset",
   ")",
   "expected",
   "=",
   "slice_clean_visible",
   "(",
   "token",
   ")",
   "if",
   "expected",
   "!=",
   "unicode",
   "(",
   "token",
   ".",
   "token",
   ",",
   "'utf-8'",
   ")",
   ":",
   "# Yeah, apparently this can happen. Maybe it's a bug",
   "# in Basis? I'm trying to hustle, and this only happens",
   "# in two instances for the `random` document, so I'm not",
   "# going to try to reproduce a minimal counter-example.",
   "# ---AG",
   "return",
   "False",
   "try",
   ":",
   "got",
   "=",
   "xprange",
   ".",
   "slice_node",
   "(",
   "html_root",
   ")",
   "except",
   "InvalidXpathError",
   "as",
   "err",
   ":",
   "debug_all",
   "(",
   "token",
   ",",
   "xprange",
   ",",
   "expected",
   ",",
   "err",
   "=",
   "err",
   ")",
   "raise",
   "XpathMismatchError",
   "(",
   "html",
   ",",
   "cleanvis",
   ",",
   "xprange",
   ",",
   "crange",
   ")",
   "if",
   "expected",
   "!=",
   "got",
   ":",
   "debug_all",
   "(",
   "token",
   ",",
   "xprange",
   ",",
   "expected",
   ",",
   "got",
   "=",
   "got",
   ")",
   "raise",
   "XpathMismatchError",
   "(",
   "html",
   ",",
   "cleanvis",
   ",",
   "xprange",
   ",",
   "crange",
   ")",
   "return",
   "True",
   "cleanvis",
   "=",
   "unicode",
   "(",
   "si",
   ".",
   "body",
   ".",
   "clean_visible",
   ",",
   "'utf-8'",
   ")",
   "html",
   "=",
   "unicode",
   "(",
   "si",
   ".",
   "body",
   ".",
   "clean_html",
   ",",
   "'utf-8'",
   ")",
   "html_root",
   "=",
   "XpathRange",
   ".",
   "html_node",
   "(",
   "html",
   ")",
   "total",
   ",",
   "has_valid_xpath",
   "=",
   "0",
   ",",
   "0",
   "for",
   "sentences",
   "in",
   "si",
   ".",
   "body",
   ".",
   "sentences",
   ".",
   "itervalues",
   "(",
   ")",
   ":",
   "for",
   "sentence",
   "in",
   "sentences",
   ":",
   "if",
   "quick",
   ":",
   "for",
   "i",
   "in",
   "xrange",
   "(",
   "len",
   "(",
   "sentence",
   ".",
   "tokens",
   ")",
   "-",
   "1",
   ",",
   "-",
   "1",
   ",",
   "-",
   "1",
   ")",
   ":",
   "if",
   "test_token",
   "(",
   "sentence",
   ".",
   "tokens",
   "[",
   "i",
   "]",
   ")",
   ":",
   "break",
   "else",
   ":",
   "# Exhaustive test.",
   "for",
   "token",
   "in",
   "sentence",
   ".",
   "tokens",
   ":",
   "total",
   "+=",
   "1",
   "if",
   "test_token",
   "(",
   "token",
   ")",
   ":",
   "has_valid_xpath",
   "+=",
   "1",
   "if",
   "not",
   "quick",
   ":",
   "# This is nonsense if we have quick checking enabled.",
   "logger",
   ".",
   "info",
   "(",
   "'stream item %s: %d/%d tokens with valid xpaths'",
   ",",
   "si",
   ".",
   "stream_id",
   ",",
   "has_valid_xpath",
   ",",
   "total",
   ")"
  ]
 },
 {
  "idx": "maxmin-1232",
  "nl_tokens": [
   "Return",
   "a",
   "cached",
   "response",
   "if",
   "it",
   "exists",
   "in",
   "the",
   "cache",
   "otherwise",
   "return",
   "False",
   "."
  ],
  "pl_tokens": [
   "def",
   "cached_request",
   "(",
   "self",
   ",",
   "request",
   ")",
   ":",
   "cache_url",
   "=",
   "self",
   ".",
   "cache_url",
   "(",
   "request",
   ".",
   "url",
   ")",
   "cc",
   "=",
   "self",
   ".",
   "parse_cache_control",
   "(",
   "request",
   ".",
   "headers",
   ")",
   "# non-caching states",
   "no_cache",
   "=",
   "True",
   "if",
   "'no-cache'",
   "in",
   "cc",
   "else",
   "False",
   "if",
   "'max-age'",
   "in",
   "cc",
   "and",
   "cc",
   "[",
   "'max-age'",
   "]",
   "==",
   "0",
   ":",
   "no_cache",
   "=",
   "True",
   "# Bail out if no-cache was set",
   "if",
   "no_cache",
   ":",
   "return",
   "False",
   "# It is in the cache, so lets see if it is going to be",
   "# fresh enough",
   "resp",
   "=",
   "self",
   ".",
   "serializer",
   ".",
   "loads",
   "(",
   "request",
   ",",
   "self",
   ".",
   "cache",
   ".",
   "get",
   "(",
   "cache_url",
   ")",
   ")",
   "# Check to see if we have a cached object",
   "if",
   "not",
   "resp",
   ":",
   "return",
   "False",
   "# If we have a cached 301, return it immediately. We don't",
   "# need to test our response for other headers b/c it is",
   "# intrinsically \"cacheable\" as it is Permanent.",
   "# See:",
   "#   https://tools.ietf.org/html/rfc7231#section-6.4.2",
   "#",
   "# Client can try to refresh the value by repeating the request",
   "# with cache busting headers as usual (ie no-cache).",
   "if",
   "resp",
   ".",
   "status",
   "==",
   "301",
   ":",
   "return",
   "resp",
   "headers",
   "=",
   "CaseInsensitiveDict",
   "(",
   "resp",
   ".",
   "headers",
   ")",
   "if",
   "not",
   "headers",
   "or",
   "'date'",
   "not",
   "in",
   "headers",
   ":",
   "# With date or etag, the cached response can never be used",
   "# and should be deleted.",
   "if",
   "'etag'",
   "not",
   "in",
   "headers",
   ":",
   "self",
   ".",
   "cache",
   ".",
   "delete",
   "(",
   "cache_url",
   ")",
   "return",
   "False",
   "now",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "date",
   "=",
   "calendar",
   ".",
   "timegm",
   "(",
   "parsedate_tz",
   "(",
   "headers",
   "[",
   "'date'",
   "]",
   ")",
   ")",
   "current_age",
   "=",
   "<mask>",
   "(",
   "0",
   ",",
   "now",
   "-",
   "date",
   ")",
   "# TODO: There is an assumption that the result will be a",
   "#       urllib3 response object. This may not be best since we",
   "#       could probably avoid instantiating or constructing the",
   "#       response until we know we need it.",
   "resp_cc",
   "=",
   "self",
   ".",
   "parse_cache_control",
   "(",
   "headers",
   ")",
   "# determine freshness",
   "freshness_lifetime",
   "=",
   "0",
   "# Check the max-age pragma in the cache control header",
   "if",
   "'max-age'",
   "in",
   "resp_cc",
   "and",
   "resp_cc",
   "[",
   "'max-age'",
   "]",
   ".",
   "isdigit",
   "(",
   ")",
   ":",
   "freshness_lifetime",
   "=",
   "int",
   "(",
   "resp_cc",
   "[",
   "'max-age'",
   "]",
   ")",
   "# If there isn't a max-age, check for an expires header",
   "elif",
   "'expires'",
   "in",
   "headers",
   ":",
   "expires",
   "=",
   "parsedate_tz",
   "(",
   "headers",
   "[",
   "'expires'",
   "]",
   ")",
   "if",
   "expires",
   "is",
   "not",
   "None",
   ":",
   "expire_time",
   "=",
   "calendar",
   ".",
   "timegm",
   "(",
   "expires",
   ")",
   "-",
   "date",
   "freshness_lifetime",
   "=",
   "max",
   "(",
   "0",
   ",",
   "expire_time",
   ")",
   "# determine if we are setting freshness limit in the req",
   "if",
   "'max-age'",
   "in",
   "cc",
   ":",
   "try",
   ":",
   "freshness_lifetime",
   "=",
   "int",
   "(",
   "cc",
   "[",
   "'max-age'",
   "]",
   ")",
   "except",
   "ValueError",
   ":",
   "freshness_lifetime",
   "=",
   "0",
   "if",
   "'min-fresh'",
   "in",
   "cc",
   ":",
   "try",
   ":",
   "min_fresh",
   "=",
   "int",
   "(",
   "cc",
   "[",
   "'min-fresh'",
   "]",
   ")",
   "except",
   "ValueError",
   ":",
   "min_fresh",
   "=",
   "0",
   "# adjust our current age by our min fresh",
   "current_age",
   "+=",
   "min_fresh",
   "# see how fresh we actually are",
   "fresh",
   "=",
   "(",
   "freshness_lifetime",
   ">",
   "current_age",
   ")",
   "if",
   "fresh",
   ":",
   "return",
   "resp",
   "# we're not fresh. If we don't have an Etag, clear it out",
   "if",
   "'etag'",
   "not",
   "in",
   "headers",
   ":",
   "self",
   ".",
   "cache",
   ".",
   "delete",
   "(",
   "cache_url",
   ")",
   "# return the original handler",
   "return",
   "False"
  ]
 },
 {
  "idx": "maxmin-1233",
  "nl_tokens": [
   "Calculate",
   "the",
   "minimum",
   "position",
   "errors",
   "from",
   "G",
   "and",
   "(",
   "V",
   "-",
   "I",
   ")",
   ".",
   "These",
   "correspond",
   "to",
   "the",
   "sky",
   "regions",
   "with",
   "the",
   "smallest",
   "astrometric",
   "errors",
   "."
  ],
  "pl_tokens": [
   "def",
   "positionMinError",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "0.0",
   ")",
   ":",
   "parallaxError",
   "=",
   "parallaxErrorSkyAvg",
   "(",
   "G",
   ",",
   "vmini",
   ",",
   "extension",
   "=",
   "extension",
   ")",
   "return",
   "_astrometricErrorFactors",
   "[",
   "'alphaStar'",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   "*",
   "parallaxError",
   ",",
   "_astrometricErrorFactors",
   "[",
   "'delta'",
   "]",
   ".",
   "min",
   "(",
   ")",
   "*",
   "parallaxError"
  ]
 },
 {
  "idx": "maxmin-1234",
  "nl_tokens": [
   "Return",
   "maximum",
   "time",
   "of",
   "timeslots",
   "over",
   "all",
   "channels",
   "."
  ],
  "pl_tokens": [
   "def",
   "ch_stop_time",
   "(",
   "self",
   ",",
   "*",
   "channels",
   ":",
   "List",
   "[",
   "Channel",
   "]",
   ")",
   "->",
   "int",
   ":",
   "intervals",
   "=",
   "list",
   "(",
   "itertools",
   ".",
   "chain",
   "(",
   "*",
   "(",
   "self",
   ".",
   "_table",
   "[",
   "chan",
   "]",
   "for",
   "chan",
   "in",
   "channels",
   "if",
   "chan",
   "in",
   "self",
   ".",
   "_table",
   ")",
   ")",
   ")",
   "if",
   "intervals",
   ":",
   "return",
   "<mask>",
   "(",
   "(",
   "interval",
   ".",
   "end",
   "for",
   "interval",
   "in",
   "intervals",
   ")",
   ")",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-1235",
  "nl_tokens": [
   "Helper",
   "function",
   "to",
   "trim",
   "and",
   "stack",
   "a",
   "collection",
   "of",
   "CQT",
   "responses"
  ],
  "pl_tokens": [
   "def",
   "__trim_stack",
   "(",
   "cqt_resp",
   ",",
   "n_bins",
   ")",
   ":",
   "# cleanup any framing errors at the boundaries",
   "max_col",
   "=",
   "<mask>",
   "(",
   "x",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "for",
   "x",
   "in",
   "cqt_resp",
   ")",
   "cqt_resp",
   "=",
   "np",
   ".",
   "vstack",
   "(",
   "[",
   "x",
   "[",
   ":",
   ",",
   ":",
   "max_col",
   "]",
   "for",
   "x",
   "in",
   "cqt_resp",
   "]",
   "[",
   ":",
   ":",
   "-",
   "1",
   "]",
   ")",
   "# Finally, clip out any bottom frequencies that we don't really want",
   "# Transpose magic here to ensure column-contiguity",
   "return",
   "np",
   ".",
   "ascontiguousarray",
   "(",
   "cqt_resp",
   "[",
   "-",
   "n_bins",
   ":",
   "]",
   ".",
   "T",
   ")",
   ".",
   "T"
  ]
 },
 {
  "idx": "maxmin-1236",
  "nl_tokens": [
   "Frame",
   "-",
   "wise",
   "non",
   "-",
   "silent",
   "indicator",
   "for",
   "audio",
   "input",
   "."
  ],
  "pl_tokens": [
   "def",
   "_signal_to_frame_nonsilent",
   "(",
   "y",
   ",",
   "frame_length",
   "=",
   "2048",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "top_db",
   "=",
   "60",
   ",",
   "ref",
   "=",
   "np",
   ".",
   "<mask>",
   ")",
   ":",
   "# Convert to mono",
   "y_mono",
   "=",
   "core",
   ".",
   "to_mono",
   "(",
   "y",
   ")",
   "# Compute the MSE for the signal",
   "mse",
   "=",
   "feature",
   ".",
   "rms",
   "(",
   "y",
   "=",
   "y_mono",
   ",",
   "frame_length",
   "=",
   "frame_length",
   ",",
   "hop_length",
   "=",
   "hop_length",
   ")",
   "**",
   "2",
   "return",
   "(",
   "core",
   ".",
   "power_to_db",
   "(",
   "mse",
   ".",
   "squeeze",
   "(",
   ")",
   ",",
   "ref",
   "=",
   "ref",
   ",",
   "top_db",
   "=",
   "None",
   ")",
   ">",
   "-",
   "top_db",
   ")"
  ]
 },
 {
  "idx": "maxmin-1237",
  "nl_tokens": [
   "set",
   "current",
   "cursor",
   "position"
  ],
  "pl_tokens": [
   "def",
   "current",
   "(",
   "self",
   ",",
   "value",
   ")",
   ":",
   "current",
   "=",
   "<mask>",
   "(",
   "max",
   "(",
   "self",
   ".",
   "_min",
   ",",
   "value",
   ")",
   ",",
   "self",
   ".",
   "_max",
   ")",
   "self",
   ".",
   "_current",
   "=",
   "current",
   "if",
   "current",
   ">",
   "self",
   ".",
   "_stop",
   ":",
   "self",
   ".",
   "_stop",
   "=",
   "current",
   "self",
   ".",
   "_start",
   "=",
   "current",
   "-",
   "self",
   ".",
   "_width",
   "elif",
   "current",
   "<",
   "self",
   ".",
   "_start",
   ":",
   "self",
   ".",
   "_start",
   "=",
   "current",
   "self",
   ".",
   "_stop",
   "=",
   "current",
   "+",
   "self",
   ".",
   "_width",
   "if",
   "abs",
   "(",
   "self",
   ".",
   "_start",
   "-",
   "self",
   ".",
   "_min",
   ")",
   "<=",
   "self",
   ".",
   "_sticky_lenght",
   ":",
   "self",
   ".",
   "_start",
   "=",
   "self",
   ".",
   "_min",
   "if",
   "abs",
   "(",
   "self",
   ".",
   "_stop",
   "-",
   "self",
   ".",
   "_max",
   ")",
   "<=",
   "self",
   ".",
   "_sticky_lenght",
   ":",
   "self",
   ".",
   "_stop",
   "=",
   "self",
   ".",
   "_max"
  ]
 },
 {
  "idx": "maxmin-1238",
  "nl_tokens": [
   "Match",
   "one",
   "set",
   "of",
   "events",
   "to",
   "another",
   "."
  ],
  "pl_tokens": [
   "def",
   "match_events",
   "(",
   "events_from",
   ",",
   "events_to",
   ",",
   "left",
   "=",
   "True",
   ",",
   "right",
   "=",
   "True",
   ")",
   ":",
   "if",
   "len",
   "(",
   "events_from",
   ")",
   "==",
   "0",
   "or",
   "len",
   "(",
   "events_to",
   ")",
   "==",
   "0",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Attempting to match empty event list'",
   ")",
   "# If we can't match left or right, then only strict equivalence",
   "# counts as a match.",
   "if",
   "not",
   "(",
   "left",
   "or",
   "right",
   ")",
   "and",
   "not",
   "np",
   ".",
   "all",
   "(",
   "np",
   ".",
   "in1d",
   "(",
   "events_from",
   ",",
   "events_to",
   ")",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Cannot match events with left=right=False '",
   "'and events_from is not contained '",
   "'in events_to'",
   ")",
   "# If we can't match to the left, then there should be at least one",
   "# target event greater-equal to every source event",
   "if",
   "(",
   "not",
   "left",
   ")",
   "and",
   "<mask>",
   "(",
   "events_to",
   ")",
   "<",
   "max",
   "(",
   "events_from",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Cannot match events with left=False '",
   "'and max(events_to) < max(events_from)'",
   ")",
   "# If we can't match to the right, then there should be at least one",
   "# target event less-equal to every source event",
   "if",
   "(",
   "not",
   "right",
   ")",
   "and",
   "min",
   "(",
   "events_to",
   ")",
   ">",
   "min",
   "(",
   "events_from",
   ")",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Cannot match events with right=False '",
   "'and min(events_to) > min(events_from)'",
   ")",
   "# array of matched items",
   "output",
   "=",
   "np",
   ".",
   "empty_like",
   "(",
   "events_from",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int",
   ")",
   "return",
   "__match_events_helper",
   "(",
   "output",
   ",",
   "events_from",
   ",",
   "events_to",
   ",",
   "left",
   ",",
   "right",
   ")"
  ]
 },
 {
  "idx": "maxmin-1239",
  "nl_tokens": [
   "Processes",
   "a",
   "collection",
   "in",
   "parallel",
   "."
  ],
  "pl_tokens": [
   "def",
   "parallel",
   "(",
   "collection",
   ",",
   "method",
   ",",
   "processes",
   "=",
   "None",
   ",",
   "args",
   "=",
   "None",
   ",",
   "*",
   "*",
   "kwargs",
   ")",
   ":",
   "if",
   "processes",
   "is",
   "None",
   ":",
   "# default to the number of cores, not exceeding 20",
   "processes",
   "=",
   "<mask>",
   "(",
   "mp",
   ".",
   "cpu_count",
   "(",
   ")",
   ",",
   "20",
   ")",
   "print",
   "\"Running parallel process on \"",
   "+",
   "str",
   "(",
   "processes",
   ")",
   "+",
   "\" cores. :-)\"",
   "pool",
   "=",
   "mp",
   ".",
   "Pool",
   "(",
   "processes",
   "=",
   "processes",
   ")",
   "PROC",
   "=",
   "[",
   "]",
   "tic",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "for",
   "main_arg",
   "in",
   "collection",
   ":",
   "if",
   "args",
   "is",
   "None",
   ":",
   "ARGS",
   "=",
   "(",
   "main_arg",
   ",",
   ")",
   "else",
   ":",
   "if",
   "isinstance",
   "(",
   "args",
   ",",
   "tuple",
   ")",
   "==",
   "False",
   ":",
   "args",
   "=",
   "(",
   "args",
   ",",
   ")",
   "ARGS",
   "=",
   "(",
   "main_arg",
   ",",
   ")",
   "+",
   "args",
   "PROC",
   ".",
   "append",
   "(",
   "pool",
   ".",
   "apply_async",
   "(",
   "method",
   ",",
   "args",
   "=",
   "ARGS",
   ",",
   "kwds",
   "=",
   "kwargs",
   ")",
   ")",
   "#RES = [p.get() for p in PROC]",
   "RES",
   "=",
   "[",
   "]",
   "for",
   "p",
   "in",
   "PROC",
   ":",
   "try",
   ":",
   "RES",
   ".",
   "append",
   "(",
   "p",
   ".",
   "get",
   "(",
   ")",
   ")",
   "except",
   "Exception",
   "as",
   "e",
   ":",
   "print",
   "\"shit happens...\"",
   "print",
   "e",
   "RES",
   ".",
   "append",
   "(",
   "None",
   ")",
   "pool",
   ".",
   "close",
   "(",
   ")",
   "pool",
   ".",
   "join",
   "(",
   ")",
   "toc",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "elapsed",
   "=",
   "toc",
   "-",
   "tic",
   "print",
   "\"Elapsed time: %s  on %s processes :-)\\n\"",
   "%",
   "(",
   "str",
   "(",
   "elapsed",
   ")",
   ",",
   "str",
   "(",
   "processes",
   ")",
   ")",
   "return",
   "RES"
  ]
 },
 {
  "idx": "maxmin-1240",
  "nl_tokens": [
   "Sets",
   "all",
   "cells",
   "of",
   "a",
   "matrix",
   "to",
   "a",
   "given",
   "value",
   "if",
   "they",
   "lie",
   "outside",
   "a",
   "constraint",
   "region",
   ".",
   "In",
   "this",
   "case",
   "the",
   "constraint",
   "region",
   "is",
   "the",
   "Sakoe",
   "-",
   "Chiba",
   "band",
   "which",
   "runs",
   "with",
   "a",
   "fixed",
   "radius",
   "along",
   "the",
   "main",
   "diagonal",
   ".",
   "When",
   "x",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "!",
   "=",
   "x",
   ".",
   "shape",
   "[",
   "1",
   "]",
   "the",
   "radius",
   "will",
   "be",
   "expanded",
   "so",
   "that",
   "x",
   "[",
   "-",
   "1",
   "-",
   "1",
   "]",
   "=",
   "1",
   "always",
   "."
  ],
  "pl_tokens": [
   "def",
   "fill_off_diagonal",
   "(",
   "x",
   ",",
   "radius",
   ",",
   "value",
   "=",
   "0",
   ")",
   ":",
   "nx",
   ",",
   "ny",
   "=",
   "x",
   ".",
   "shape",
   "# Calculate the radius in indices, rather than proportion",
   "radius",
   "=",
   "np",
   ".",
   "round",
   "(",
   "radius",
   "*",
   "np",
   ".",
   "<mask>",
   "(",
   "x",
   ".",
   "shape",
   ")",
   ")",
   "nx",
   ",",
   "ny",
   "=",
   "x",
   ".",
   "shape",
   "offset",
   "=",
   "np",
   ".",
   "abs",
   "(",
   "(",
   "x",
   ".",
   "shape",
   "[",
   "0",
   "]",
   "-",
   "x",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ")",
   "if",
   "nx",
   "<",
   "ny",
   ":",
   "idx_u",
   "=",
   "np",
   ".",
   "triu_indices_from",
   "(",
   "x",
   ",",
   "k",
   "=",
   "radius",
   "+",
   "offset",
   ")",
   "idx_l",
   "=",
   "np",
   ".",
   "tril_indices_from",
   "(",
   "x",
   ",",
   "k",
   "=",
   "-",
   "radius",
   ")",
   "else",
   ":",
   "idx_u",
   "=",
   "np",
   ".",
   "triu_indices_from",
   "(",
   "x",
   ",",
   "k",
   "=",
   "radius",
   ")",
   "idx_l",
   "=",
   "np",
   ".",
   "tril_indices_from",
   "(",
   "x",
   ",",
   "k",
   "=",
   "-",
   "radius",
   "-",
   "offset",
   ")",
   "# modify input matrix",
   "x",
   "[",
   "idx_u",
   "]",
   "=",
   "value",
   "x",
   "[",
   "idx_l",
   "]",
   "=",
   "value"
  ]
 },
 {
  "idx": "maxmin-1241",
  "nl_tokens": [
   "Determine",
   "when",
   "to",
   "query",
   "the",
   "progress",
   "status",
   "next",
   "."
  ],
  "pl_tokens": [
   "def",
   "_guess_next_poll_interval",
   "(",
   "self",
   ")",
   ":",
   "time_elapsed",
   "=",
   "self",
   ".",
   "_progress_data",
   "[",
   "-",
   "1",
   "]",
   "[",
   "0",
   "]",
   "-",
   "self",
   ".",
   "_progress_data",
   "[",
   "0",
   "]",
   "[",
   "0",
   "]",
   "real_progress",
   "=",
   "self",
   ".",
   "_get_real_progress",
   "(",
   ")",
   "return",
   "<mask>",
   "(",
   "0.2",
   "*",
   "time_elapsed",
   ",",
   "0.5",
   "+",
   "(",
   "1",
   "-",
   "real_progress",
   ")",
   "**",
   "0.5",
   ")"
  ]
 },
 {
  "idx": "maxmin-1242",
  "nl_tokens": [
   "Function",
   "for",
   "command",
   "line",
   "execution"
  ],
  "pl_tokens": [
   "def",
   "main",
   "(",
   ")",
   ":",
   "parser",
   "=",
   "ArgumentParser",
   "(",
   "description",
   "=",
   "\"search files using n-grams\"",
   ")",
   "parser",
   ".",
   "add_argument",
   "(",
   "'--path'",
   ",",
   "dest",
   "=",
   "'path'",
   ",",
   "help",
   "=",
   "\"where to search\"",
   ",",
   "nargs",
   "=",
   "1",
   ",",
   "action",
   "=",
   "\"store\"",
   ",",
   "default",
   "=",
   "getcwd",
   "(",
   ")",
   ")",
   "parser",
   ".",
   "add_argument",
   "(",
   "'--update'",
   ",",
   "dest",
   "=",
   "'update'",
   ",",
   "help",
   "=",
   "\"update the index\"",
   ",",
   "action",
   "=",
   "'store_true'",
   ",",
   "default",
   "=",
   "True",
   ")",
   "parser",
   ".",
   "add_argument",
   "(",
   "'--filetype'",
   ",",
   "dest",
   "=",
   "'filetype'",
   ",",
   "help",
   "=",
   "\"any, images, documents, code, audio, video\"",
   ",",
   "nargs",
   "=",
   "1",
   ",",
   "action",
   "=",
   "\"store\"",
   ",",
   "default",
   "=",
   "[",
   "\"any\"",
   "]",
   ")",
   "parser",
   ".",
   "add_argument",
   "(",
   "'--verbose'",
   ",",
   "dest",
   "=",
   "'verbose'",
   ",",
   "help",
   "=",
   "\"extended output\"",
   ",",
   "action",
   "=",
   "'store_true'",
   ",",
   "default",
   "=",
   "False",
   ")",
   "parser",
   ".",
   "add_argument",
   "(",
   "'--results'",
   ",",
   "dest",
   "=",
   "'results'",
   ",",
   "help",
   "=",
   "\"number of results to display\"",
   ",",
   "action",
   "=",
   "\"store\"",
   ",",
   "default",
   "=",
   "10",
   ")",
   "parser",
   ".",
   "add_argument",
   "(",
   "'query'",
   ",",
   "nargs",
   "=",
   "'+'",
   ",",
   "help",
   "=",
   "\"what to search\"",
   ",",
   "action",
   "=",
   "\"store\"",
   ")",
   "args",
   "=",
   "parser",
   ".",
   "parse_args",
   "(",
   ")",
   "if",
   "args",
   ".",
   "verbose",
   ":",
   "verbose",
   "=",
   "2",
   "pprint",
   "(",
   "args",
   ")",
   "else",
   ":",
   "verbose",
   "=",
   "0",
   "query",
   "=",
   "args",
   ".",
   "query",
   "[",
   "0",
   "]",
   "for",
   "arg",
   "in",
   "args",
   ".",
   "query",
   "[",
   "1",
   ":",
   "]",
   ":",
   "query",
   "=",
   "query",
   "+",
   "\" \"",
   "+",
   "arg",
   "slb",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "w",
   ")",
   "for",
   "w",
   "in",
   "query",
   ".",
   "split",
   "(",
   "\" \"",
   ")",
   "]",
   ")",
   "files",
   "=",
   "Files",
   "(",
   "path",
   "=",
   "args",
   ".",
   "path",
   ",",
   "filetype",
   "=",
   "args",
   ".",
   "filetype",
   "[",
   "0",
   "]",
   ",",
   "exclude",
   "=",
   "[",
   "]",
   ",",
   "update",
   "=",
   "args",
   ".",
   "update",
   ",",
   "verbose",
   "=",
   "verbose",
   ")",
   "index",
   "=",
   "Index",
   "(",
   "files",
   ",",
   "slb",
   "=",
   "slb",
   ",",
   "verbose",
   "=",
   "verbose",
   ")",
   "results",
   "=",
   "index",
   ".",
   "search",
   "(",
   "query",
   ",",
   "verbose",
   "=",
   "verbose",
   ")",
   "Handler",
   "(",
   "results",
   ",",
   "results_number",
   "=",
   "int",
   "(",
   "args",
   ".",
   "results",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1243",
  "nl_tokens": [
   "Retrieve",
   "all",
   "the",
   "items",
   "from",
   "a",
   "given",
   "date",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_items",
   "(",
   "self",
   ",",
   "from_date",
   ",",
   "url",
   ",",
   "expand_fields",
   "=",
   "True",
   ")",
   ":",
   "start_at",
   "=",
   "0",
   "req",
   "=",
   "self",
   ".",
   "fetch",
   "(",
   "url",
   ",",
   "payload",
   "=",
   "self",
   ".",
   "__build_payload",
   "(",
   "start_at",
   ",",
   "from_date",
   ",",
   "expand_fields",
   ")",
   ")",
   "issues",
   "=",
   "req",
   ".",
   "text",
   "data",
   "=",
   "req",
   ".",
   "json",
   "(",
   ")",
   "titems",
   "=",
   "data",
   "[",
   "'total'",
   "]",
   "nitems",
   "=",
   "data",
   "[",
   "'maxResults'",
   "]",
   "start_at",
   "+=",
   "<mask>",
   "(",
   "nitems",
   ",",
   "titems",
   ")",
   "self",
   ".",
   "__log_status",
   "(",
   "start_at",
   ",",
   "titems",
   ",",
   "url",
   ")",
   "while",
   "issues",
   ":",
   "yield",
   "issues",
   "issues",
   "=",
   "None",
   "if",
   "data",
   "[",
   "'startAt'",
   "]",
   "+",
   "nitems",
   "<",
   "titems",
   ":",
   "req",
   "=",
   "self",
   ".",
   "fetch",
   "(",
   "url",
   ",",
   "payload",
   "=",
   "self",
   ".",
   "__build_payload",
   "(",
   "start_at",
   ",",
   "from_date",
   ",",
   "expand_fields",
   ")",
   ")",
   "data",
   "=",
   "req",
   ".",
   "json",
   "(",
   ")",
   "start_at",
   "+=",
   "nitems",
   "issues",
   "=",
   "req",
   ".",
   "text",
   "self",
   ".",
   "__log_status",
   "(",
   "start_at",
   ",",
   "titems",
   ",",
   "url",
   ")"
  ]
 },
 {
  "idx": "maxmin-1244",
  "nl_tokens": [
   "Helper",
   "property",
   "containing",
   "the",
   "percentage",
   "this",
   "slider",
   "is",
   "filled",
   ".",
   "This",
   "property",
   "is",
   "read",
   "-",
   "only",
   "."
  ],
  "pl_tokens": [
   "def",
   "p",
   "(",
   "self",
   ")",
   ":",
   "return",
   "(",
   "self",
   ".",
   "n",
   "-",
   "self",
   ".",
   "nmin",
   ")",
   "/",
   "<mask>",
   "(",
   "(",
   "self",
   ".",
   "nmax",
   "-",
   "self",
   ".",
   "nmin",
   ")",
   ",",
   "1",
   ")"
  ]
 },
 {
  "idx": "maxmin-1245",
  "nl_tokens": [
   "Converts",
   "an",
   "RGB",
   "color",
   "value",
   "to",
   "HSL",
   ".",
   ":",
   "param",
   "r",
   ":",
   "The",
   "red",
   "color",
   "value",
   ":",
   "param",
   "g",
   ":",
   "The",
   "green",
   "color",
   "value",
   ":",
   "param",
   "b",
   ":",
   "The",
   "blue",
   "color",
   "value",
   ":",
   "return",
   ":",
   "The",
   "HSL",
   "representation"
  ],
  "pl_tokens": [
   "def",
   "rgb_to_hsl",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   ":",
   "r",
   "=",
   "float",
   "(",
   "r",
   ")",
   "/",
   "255.0",
   "g",
   "=",
   "float",
   "(",
   "g",
   ")",
   "/",
   "255.0",
   "b",
   "=",
   "float",
   "(",
   "b",
   ")",
   "/",
   "255.0",
   "max_value",
   "=",
   "<mask>",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   "min_value",
   "=",
   "min",
   "(",
   "r",
   ",",
   "g",
   ",",
   "b",
   ")",
   "h",
   "=",
   "None",
   "s",
   "=",
   "None",
   "l",
   "=",
   "(",
   "max_value",
   "+",
   "min_value",
   ")",
   "/",
   "2",
   "d",
   "=",
   "max_value",
   "-",
   "min_value",
   "if",
   "d",
   "==",
   "0",
   ":",
   "# achromatic",
   "h",
   "=",
   "0",
   "s",
   "=",
   "0",
   "else",
   ":",
   "s",
   "=",
   "d",
   "/",
   "(",
   "1",
   "-",
   "abs",
   "(",
   "2",
   "*",
   "l",
   "-",
   "1",
   ")",
   ")",
   "if",
   "r",
   "==",
   "max_value",
   ":",
   "h",
   "=",
   "60",
   "*",
   "(",
   "(",
   "g",
   "-",
   "b",
   ")",
   "%",
   "6",
   ")",
   "if",
   "b",
   ">",
   "g",
   ":",
   "h",
   "+=",
   "360",
   "if",
   "g",
   "==",
   "max_value",
   ":",
   "h",
   "=",
   "60",
   "*",
   "(",
   "(",
   "b",
   "-",
   "r",
   ")",
   "/",
   "d",
   "+",
   "2",
   ")",
   "if",
   "b",
   "==",
   "max_value",
   ":",
   "h",
   "=",
   "60",
   "*",
   "(",
   "(",
   "r",
   "-",
   "g",
   ")",
   "/",
   "d",
   "+",
   "4",
   ")",
   "return",
   "round",
   "(",
   "h",
   ",",
   "2",
   ")",
   ",",
   "round",
   "(",
   "s",
   ",",
   "2",
   ")",
   ",",
   "round",
   "(",
   "l",
   ",",
   "2",
   ")"
  ]
 },
 {
  "idx": "maxmin-1246",
  "nl_tokens": [
   "Renders",
   "into",
   "a",
   "string",
   "a",
   "number",
   "following",
   "the",
   "defined",
   "pattern",
   ".",
   "Forced",
   "decimal",
   "quantization",
   "is",
   "active",
   "by",
   "default",
   "so",
   "we",
   "ll",
   "produce",
   "a",
   "number",
   "string",
   "that",
   "is",
   "strictly",
   "following",
   "CLDR",
   "pattern",
   "definitions",
   "."
  ],
  "pl_tokens": [
   "def",
   "apply",
   "(",
   "self",
   ",",
   "value",
   ",",
   "locale",
   ",",
   "currency",
   "=",
   "None",
   ",",
   "currency_digits",
   "=",
   "True",
   ",",
   "decimal_quantization",
   "=",
   "True",
   ")",
   ":",
   "if",
   "not",
   "isinstance",
   "(",
   "value",
   ",",
   "decimal",
   ".",
   "Decimal",
   ")",
   ":",
   "value",
   "=",
   "decimal",
   ".",
   "Decimal",
   "(",
   "str",
   "(",
   "value",
   ")",
   ")",
   "value",
   "=",
   "value",
   ".",
   "scaleb",
   "(",
   "self",
   ".",
   "scale",
   ")",
   "# Separate the absolute value from its sign.",
   "is_negative",
   "=",
   "int",
   "(",
   "value",
   ".",
   "is_signed",
   "(",
   ")",
   ")",
   "value",
   "=",
   "abs",
   "(",
   "value",
   ")",
   ".",
   "normalize",
   "(",
   ")",
   "# Prepare scientific notation metadata.",
   "if",
   "self",
   ".",
   "exp_prec",
   ":",
   "value",
   ",",
   "exp",
   ",",
   "exp_sign",
   "=",
   "self",
   ".",
   "scientific_notation_elements",
   "(",
   "value",
   ",",
   "locale",
   ")",
   "# Adjust the precision of the fractionnal part and force it to the",
   "# currency's if neccessary.",
   "frac_prec",
   "=",
   "self",
   ".",
   "frac_prec",
   "if",
   "currency",
   "and",
   "currency_digits",
   ":",
   "frac_prec",
   "=",
   "(",
   "babel",
   ".",
   "numbers",
   ".",
   "get_currency_precision",
   "(",
   "currency",
   ")",
   ",",
   ")",
   "*",
   "2",
   "# Bump decimal precision to the natural precision of the number if it",
   "# exceeds the one we're about to use. This adaptative precision is only",
   "# triggered if the decimal quantization is disabled or if a scientific",
   "# notation pattern has a missing mandatory fractional part (as in the",
   "# default '#E0' pattern). This special case has been extensively",
   "# discussed at",
   "# https://github.com/python-babel/babel/pull/494#issuecomment-307649969",
   "if",
   "not",
   "decimal_quantization",
   "or",
   "(",
   "self",
   ".",
   "exp_prec",
   "and",
   "frac_prec",
   "==",
   "(",
   "0",
   ",",
   "0",
   ")",
   ")",
   ":",
   "frac_prec",
   "=",
   "(",
   "frac_prec",
   "[",
   "0",
   "]",
   ",",
   "<mask>",
   "(",
   "[",
   "frac_prec",
   "[",
   "1",
   "]",
   ",",
   "get_decimal_precision",
   "(",
   "value",
   ")",
   "]",
   ")",
   ")",
   "# Render scientific notation.",
   "if",
   "self",
   ".",
   "exp_prec",
   ":",
   "number",
   "=",
   "''",
   ".",
   "join",
   "(",
   "[",
   "self",
   ".",
   "_quantize_value",
   "(",
   "value",
   ",",
   "locale",
   ",",
   "frac_prec",
   ")",
   ",",
   "babel",
   ".",
   "numbers",
   ".",
   "get_exponential_symbol",
   "(",
   "locale",
   ")",
   ",",
   "exp_sign",
   ",",
   "self",
   ".",
   "_format_int",
   "(",
   "str",
   "(",
   "exp",
   ")",
   ",",
   "self",
   ".",
   "exp_prec",
   "[",
   "0",
   "]",
   ",",
   "self",
   ".",
   "exp_prec",
   "[",
   "1",
   "]",
   ",",
   "locale",
   ")",
   "]",
   ")",
   "# Is it a siginificant digits pattern?",
   "elif",
   "'@'",
   "in",
   "self",
   ".",
   "pattern",
   ":",
   "text",
   "=",
   "self",
   ".",
   "_format_significant",
   "(",
   "value",
   ",",
   "self",
   ".",
   "int_prec",
   "[",
   "0",
   "]",
   ",",
   "self",
   ".",
   "int_prec",
   "[",
   "1",
   "]",
   ")",
   "a",
   ",",
   "sep",
   ",",
   "b",
   "=",
   "text",
   ".",
   "partition",
   "(",
   "\".\"",
   ")",
   "number",
   "=",
   "self",
   ".",
   "_format_int",
   "(",
   "a",
   ",",
   "0",
   ",",
   "1000",
   ",",
   "locale",
   ")",
   "if",
   "sep",
   ":",
   "number",
   "+=",
   "babel",
   ".",
   "numbers",
   ".",
   "get_decimal_symbol",
   "(",
   "locale",
   ")",
   "+",
   "b",
   "# A normal number pattern.",
   "else",
   ":",
   "number",
   "=",
   "self",
   ".",
   "_quantize_value",
   "(",
   "value",
   ",",
   "locale",
   ",",
   "frac_prec",
   ")",
   "retval",
   "=",
   "''",
   ".",
   "join",
   "(",
   "[",
   "self",
   ".",
   "prefix",
   "[",
   "is_negative",
   "]",
   ",",
   "number",
   ",",
   "self",
   ".",
   "suffix",
   "[",
   "is_negative",
   "]",
   "]",
   ")",
   "if",
   "u'\u00a4' ",
   "n ",
   "etval:",
   "",
   "retval",
   "=",
   "retval",
   ".",
   "replace",
   "(",
   "u'\u00a4\u00a4\u00a4',",
   "",
   "babel",
   ".",
   "numbers",
   ".",
   "get_currency_name",
   "(",
   "currency",
   ",",
   "value",
   ",",
   "locale",
   ")",
   ")",
   "retval",
   "=",
   "retval",
   ".",
   "replace",
   "(",
   "u'\u00a4\u00a4', ",
   "c",
   "rrency.u",
   "p",
   "per()",
   ")",
   "",
   "",
   "retval",
   "=",
   "retval",
   ".",
   "replace",
   "(",
   "u'\u00a4',",
   " ",
   "abel.",
   "n",
   "umbers.",
   "g",
   "et_currency_symbol(",
   "",
   "currency",
   ",",
   "locale",
   ")",
   ")",
   "return",
   "retval"
  ]
 },
 {
  "idx": "maxmin-1247",
  "nl_tokens": [
   "Handles",
   "mouse",
   "motion",
   "and",
   "rotates",
   "the",
   "attached",
   "camera",
   "accordingly",
   ".",
   "For",
   "more",
   "information",
   "about",
   "how",
   "to",
   "customize",
   "mouse",
   "movement",
   "see",
   "the",
   "class",
   "documentation",
   "here",
   ":",
   "py",
   ":",
   "class",
   ":",
   "WorldViewMouseRotatable",
   "()",
   "\\",
   "."
  ],
  "pl_tokens": [
   "def",
   "on_mouse_motion",
   "(",
   "self",
   ",",
   "x",
   ",",
   "y",
   ",",
   "dx",
   ",",
   "dy",
   ")",
   ":",
   "if",
   "not",
   "self",
   ".",
   "world",
   ".",
   "peng",
   ".",
   "window",
   ".",
   "exclusive",
   ":",
   "return",
   "m",
   "=",
   "self",
   ".",
   "world",
   ".",
   "peng",
   ".",
   "cfg",
   "[",
   "\"controls.mouse.sensitivity\"",
   "]",
   "x",
   ",",
   "y",
   "=",
   "self",
   ".",
   "rot",
   "x",
   ",",
   "y",
   "=",
   "x",
   "+",
   "dx",
   "*",
   "m",
   ",",
   "y",
   "+",
   "dy",
   "*",
   "m",
   "y",
   "=",
   "<mask>",
   "(",
   "-",
   "90",
   ",",
   "min",
   "(",
   "90",
   ",",
   "y",
   ")",
   ")",
   "x",
   "%=",
   "360",
   "newrot",
   "=",
   "(",
   "x",
   ",",
   "y",
   ")",
   "self",
   ".",
   "rot",
   "=",
   "newrot"
  ]
 },
 {
  "idx": "maxmin-1248",
  "nl_tokens": [
   "Build",
   "a",
   "log",
   "message",
   "and",
   "reset",
   "the",
   "stats"
  ],
  "pl_tokens": [
   "def",
   "log_message",
   "(",
   "self",
   ")",
   ":",
   "time_delta",
   "=",
   "deepcopy",
   "(",
   "self",
   ".",
   "time_delta",
   ")",
   "total_work_time",
   "=",
   "self",
   ".",
   "worker_count",
   "*",
   "time_delta",
   "time_worked",
   "=",
   "sum",
   "(",
   "self",
   ".",
   "exec_times",
   ")",
   "pct_busy",
   "=",
   "time_worked",
   "/",
   "total_work_time",
   "*",
   "100.0",
   "min_task_time",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "exec_times",
   ")",
   "avg_task_time",
   "=",
   "sum",
   "(",
   "self",
   ".",
   "exec_times",
   ")",
   "/",
   "len",
   "(",
   "self",
   ".",
   "exec_times",
   ")",
   "max_task_time",
   "=",
   "max",
   "(",
   "self",
   ".",
   "exec_times",
   ")",
   "min_queue_time",
   "=",
   "min",
   "(",
   "self",
   ".",
   "queue_times",
   ")",
   "avg_queue_time",
   "=",
   "sum",
   "(",
   "self",
   ".",
   "queue_times",
   ")",
   "/",
   "len",
   "(",
   "self",
   ".",
   "queue_times",
   ")",
   "max_queue_time",
   "=",
   "max",
   "(",
   "self",
   ".",
   "queue_times",
   ")",
   "time_delta",
   "=",
   "self",
   ".",
   "time_delta",
   "total_tasks",
   "=",
   "len",
   "(",
   "self",
   ".",
   "exec_times",
   ")",
   "avg_task_rate",
   "=",
   "total_tasks",
   "/",
   "time_delta",
   "self",
   ".",
   "reset",
   "(",
   ")",
   "task_msg",
   "=",
   "\"\"\"Ran {0} tasks, {1} tasks/s; {2} workers {3}% busy\"\"\"",
   ".",
   "format",
   "(",
   "total_tasks",
   ",",
   "round",
   "(",
   "avg_task_rate",
   ",",
   "1",
   ")",
   ",",
   "self",
   ".",
   "worker_count",
   ",",
   "round",
   "(",
   "pct_busy",
   ",",
   "1",
   ")",
   ")",
   "task_mam",
   "=",
   "\"\"\"     Task run times: {0}/{1}/{2} (min/avg/max)\"\"\"",
   ".",
   "format",
   "(",
   "round",
   "(",
   "min_task_time",
   ",",
   "3",
   ")",
   ",",
   "round",
   "(",
   "avg_task_time",
   ",",
   "3",
   ")",
   ",",
   "round",
   "(",
   "max_task_time",
   ",",
   "3",
   ")",
   ")",
   "queue_mam",
   "=",
   "\"\"\"     Time in queue: {0}/{1}/{2} (min/avg/max)\"\"\"",
   ".",
   "format",
   "(",
   "round",
   "(",
   "min_queue_time",
   ",",
   "6",
   ")",
   ",",
   "round",
   "(",
   "avg_queue_time",
   ",",
   "6",
   ")",
   ",",
   "round",
   "(",
   "max_queue_time",
   ",",
   "6",
   ")",
   ")",
   "return",
   "\"\"\"{0}\\n{1}\\n{2}\"\"\"",
   ".",
   "format",
   "(",
   "task_msg",
   ",",
   "task_mam",
   ",",
   "queue_mam",
   ")"
  ]
 },
 {
  "idx": "maxmin-1249",
  "nl_tokens": [
   "Show",
   "all",
   "words",
   "of",
   "the",
   "code",
   "in",
   "a",
   "nice",
   "format",
   "."
  ],
  "pl_tokens": [
   "def",
   "showCode",
   "(",
   "self",
   ",",
   "width",
   "=",
   "80",
   ")",
   ":",
   "#make table of all symbols with binary strings",
   "symbolStrings",
   "=",
   "[",
   "(",
   "self",
   ".",
   "bitPattern",
   "(",
   "s",
   ".",
   "index",
   ")",
   ",",
   "self",
   ".",
   "mnemonic",
   "(",
   "s",
   ".",
   "index",
   ")",
   ")",
   "for",
   "s",
   "in",
   "self",
   "]",
   "#determine column widths the way Lisp programmers do it",
   "leftColWidth",
   ",",
   "rightColWidth",
   "=",
   "map",
   "(",
   "<mask>",
   ",",
   "map",
   "(",
   "map",
   ",",
   "repeat",
   "(",
   "len",
   ")",
   ",",
   "zip",
   "(",
   "*",
   "symbolStrings",
   ")",
   ")",
   ")",
   "colwidth",
   "=",
   "leftColWidth",
   "+",
   "rightColWidth",
   "columns",
   "=",
   "81",
   "//",
   "(",
   "colwidth",
   "+",
   "2",
   ")",
   "rows",
   "=",
   "-",
   "(",
   "-",
   "len",
   "(",
   "symbolStrings",
   ")",
   "//",
   "columns",
   ")",
   "def",
   "justify",
   "(",
   "bs",
   ")",
   ":",
   "b",
   ",",
   "s",
   "=",
   "bs",
   "return",
   "b",
   ".",
   "rjust",
   "(",
   "leftColWidth",
   ")",
   "+",
   "':'",
   "+",
   "s",
   ".",
   "ljust",
   "(",
   "rightColWidth",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "rows",
   ")",
   ":",
   "print",
   "(",
   "' '",
   ".",
   "join",
   "(",
   "map",
   "(",
   "justify",
   ",",
   "symbolStrings",
   "[",
   "i",
   ":",
   ":",
   "rows",
   "]",
   ")",
   ")",
   ".",
   "rstrip",
   "(",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1250",
  "nl_tokens": [
   "#",
   "Return",
   "all",
   "points",
   "within",
   "r",
   "mm",
   "of",
   "coordinates",
   ".",
   "Generates",
   "a",
   "cube",
   "and",
   "then",
   "discards",
   "all",
   "points",
   "outside",
   "sphere",
   ".",
   "Only",
   "returns",
   "values",
   "that",
   "fall",
   "within",
   "the",
   "dimensions",
   "of",
   "the",
   "image",
   "."
  ],
  "pl_tokens": [
   "def",
   "get_sphere",
   "(",
   "coords",
   ",",
   "r",
   "=",
   "4",
   ",",
   "vox_dims",
   "=",
   "(",
   "2",
   ",",
   "2",
   ",",
   "2",
   ")",
   ",",
   "dims",
   "=",
   "(",
   "91",
   ",",
   "109",
   ",",
   "91",
   ")",
   ")",
   ":",
   "r",
   "=",
   "float",
   "(",
   "r",
   ")",
   "xx",
   ",",
   "yy",
   ",",
   "zz",
   "=",
   "[",
   "slice",
   "(",
   "-",
   "r",
   "/",
   "vox_dims",
   "[",
   "i",
   "]",
   ",",
   "r",
   "/",
   "vox_dims",
   "[",
   "i",
   "]",
   "+",
   "0.01",
   ",",
   "1",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "len",
   "(",
   "coords",
   ")",
   ")",
   "]",
   "cube",
   "=",
   "np",
   ".",
   "vstack",
   "(",
   "[",
   "row",
   ".",
   "ravel",
   "(",
   ")",
   "for",
   "row",
   "in",
   "np",
   ".",
   "mgrid",
   "[",
   "xx",
   ",",
   "yy",
   ",",
   "zz",
   "]",
   "]",
   ")",
   "sphere",
   "=",
   "cube",
   "[",
   ":",
   ",",
   "np",
   ".",
   "sum",
   "(",
   "np",
   ".",
   "dot",
   "(",
   "np",
   ".",
   "diag",
   "(",
   "vox_dims",
   ")",
   ",",
   "cube",
   ")",
   "**",
   "2",
   ",",
   "0",
   ")",
   "**",
   ".5",
   "<=",
   "r",
   "]",
   "sphere",
   "=",
   "np",
   ".",
   "round",
   "(",
   "sphere",
   ".",
   "T",
   "+",
   "coords",
   ")",
   "return",
   "sphere",
   "[",
   "(",
   "np",
   ".",
   "<mask>",
   "(",
   "sphere",
   ",",
   "1",
   ")",
   ">=",
   "0",
   ")",
   "&",
   "(",
   "np",
   ".",
   "max",
   "(",
   "np",
   ".",
   "subtract",
   "(",
   "sphere",
   ",",
   "dims",
   ")",
   ",",
   "1",
   ")",
   "<=",
   "-",
   "1",
   ")",
   ",",
   ":",
   "]",
   ".",
   "astype",
   "(",
   "int",
   ")"
  ]
 },
 {
  "idx": "maxmin-1251",
  "nl_tokens": [
   "Start",
   "the",
   "progress",
   "bar",
   "and",
   "return",
   "only",
   "when",
   "the",
   "progress",
   "reaches",
   "100%",
   "."
  ],
  "pl_tokens": [
   "def",
   "execute",
   "(",
   "self",
   ",",
   "progress_fn",
   ",",
   "print_verbose_info",
   "=",
   "None",
   ")",
   ":",
   "assert_is_type",
   "(",
   "progress_fn",
   ",",
   "FunctionType",
   ",",
   "GeneratorType",
   ",",
   "MethodType",
   ")",
   "if",
   "isinstance",
   "(",
   "progress_fn",
   ",",
   "GeneratorType",
   ")",
   ":",
   "# Convert generator to a regular function",
   "progress_fn",
   "=",
   "(",
   "lambda",
   "g",
   ":",
   "lambda",
   ":",
   "next",
   "(",
   "g",
   ")",
   ")",
   "(",
   "progress_fn",
   ")",
   "# Initialize the execution context",
   "self",
   ".",
   "_next_poll_time",
   "=",
   "0",
   "self",
   ".",
   "_t0",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "self",
   ".",
   "_x0",
   "=",
   "0",
   "self",
   ".",
   "_v0",
   "=",
   "0.01",
   "# corresponds to 100s completion time",
   "self",
   ".",
   "_ve",
   "=",
   "0.01",
   "progress",
   "=",
   "0",
   "status",
   "=",
   "None",
   "# Status message in case the job gets interrupted.",
   "try",
   ":",
   "while",
   "True",
   ":",
   "# We attempt to synchronize all helper functions, ensuring that each of them has the same idea",
   "# for what the current time moment is. Otherwise we could have some corner cases when one method",
   "# says that something must happen right now, while the other already sees that moment in the past.",
   "now",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "# Query the progress level, but only if it's time already",
   "if",
   "self",
   ".",
   "_next_poll_time",
   "<=",
   "now",
   ":",
   "res",
   "=",
   "progress_fn",
   "(",
   ")",
   "# may raise StopIteration",
   "assert_is_type",
   "(",
   "res",
   ",",
   "(",
   "numeric",
   ",",
   "numeric",
   ")",
   ",",
   "numeric",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "res",
   ",",
   "tuple",
   ")",
   ":",
   "res",
   "=",
   "(",
   "res",
   ",",
   "-",
   "1",
   ")",
   "# Progress querying could have taken some time, so update the current time moment",
   "now",
   "=",
   "time",
   ".",
   "time",
   "(",
   ")",
   "self",
   ".",
   "_store_model_progress",
   "(",
   "res",
   ",",
   "now",
   ")",
   "self",
   ".",
   "_recalculate_model_parameters",
   "(",
   "now",
   ")",
   "# Render the widget regardless of whether it's too early or not",
   "progress",
   "=",
   "<mask>",
   "(",
   "self",
   ".",
   "_compute_progress_at_time",
   "(",
   "now",
   ")",
   "[",
   "0",
   "]",
   ",",
   "1",
   ")",
   "if",
   "progress",
   "==",
   "1",
   "and",
   "self",
   ".",
   "_get_real_progress",
   "(",
   ")",
   ">=",
   "1",
   ":",
   "# Do not exit until both the model and the actual progress reach 100% mark.",
   "break",
   "result",
   "=",
   "self",
   ".",
   "_widget",
   ".",
   "render",
   "(",
   "progress",
   ")",
   "assert_is_type",
   "(",
   "result",
   ",",
   "RenderResult",
   ")",
   "time0",
   "=",
   "result",
   ".",
   "next_time",
   "time1",
   "=",
   "self",
   ".",
   "_get_time_at_progress",
   "(",
   "result",
   ".",
   "next_progress",
   ")",
   "next_render_time",
   "=",
   "min",
   "(",
   "time0",
   ",",
   "time1",
   ")",
   "self",
   ".",
   "_draw",
   "(",
   "result",
   ".",
   "rendered",
   ")",
   "# Wait until the next rendering/querying cycle",
   "wait_time",
   "=",
   "min",
   "(",
   "next_render_time",
   ",",
   "self",
   ".",
   "_next_poll_time",
   ")",
   "-",
   "now",
   "if",
   "wait_time",
   ">",
   "0",
   ":",
   "time",
   ".",
   "sleep",
   "(",
   "wait_time",
   ")",
   "if",
   "print_verbose_info",
   "is",
   "not",
   "None",
   ":",
   "print_verbose_info",
   "(",
   "progress",
   ")",
   "except",
   "KeyboardInterrupt",
   ":",
   "# If the user presses Ctrl+C, we interrupt the progress bar.",
   "status",
   "=",
   "\"cancelled\"",
   "except",
   "StopIteration",
   "as",
   "e",
   ":",
   "# If the generator raises StopIteration before reaching 100%, then the progress display will",
   "# reamin incomplete.",
   "status",
   "=",
   "str",
   "(",
   "e",
   ")",
   "# Do one final rendering before we exit",
   "result",
   "=",
   "self",
   ".",
   "_widget",
   ".",
   "render",
   "(",
   "progress",
   "=",
   "progress",
   ",",
   "status",
   "=",
   "status",
   ")",
   "self",
   ".",
   "_draw",
   "(",
   "result",
   ".",
   "rendered",
   ",",
   "final",
   "=",
   "True",
   ")",
   "if",
   "status",
   "==",
   "\"cancelled\"",
   ":",
   "# Re-raise the exception, to inform the upstream caller that something unexpected happened.",
   "raise",
   "StopIteration",
   "(",
   "status",
   ")"
  ]
 },
 {
  "idx": "maxmin-1252",
  "nl_tokens": [
   "Write",
   "numpy",
   "data",
   "to",
   "an",
   ".",
   "fcs",
   "file",
   "(",
   "FCS3",
   ".",
   "0",
   "file",
   "format",
   ")"
  ],
  "pl_tokens": [
   "def",
   "write_fcs",
   "(",
   "filename",
   ",",
   "chn_names",
   ",",
   "data",
   ",",
   "endianness",
   "=",
   "\"big\"",
   ",",
   "compat_chn_names",
   "=",
   "True",
   ",",
   "compat_copy",
   "=",
   "True",
   ",",
   "compat_negative",
   "=",
   "True",
   ",",
   "compat_percent",
   "=",
   "True",
   ",",
   "compat_max_int16",
   "=",
   "10000",
   ")",
   ":",
   "filename",
   "=",
   "pathlib",
   ".",
   "Path",
   "(",
   "filename",
   ")",
   "if",
   "not",
   "isinstance",
   "(",
   "data",
   ",",
   "np",
   ".",
   "ndarray",
   ")",
   ":",
   "data",
   "=",
   "np",
   ".",
   "array",
   "(",
   "data",
   ",",
   "dtype",
   "=",
   "float",
   ")",
   "# remove rows with nan values",
   "nanrows",
   "=",
   "np",
   ".",
   "isnan",
   "(",
   "data",
   ")",
   ".",
   "any",
   "(",
   "axis",
   "=",
   "1",
   ")",
   "if",
   "np",
   ".",
   "sum",
   "(",
   "nanrows",
   ")",
   ":",
   "msg",
   "=",
   "\"Rows containing NaNs are not written to {}!\"",
   ".",
   "format",
   "(",
   "filename",
   ")",
   "warnings",
   ".",
   "warn",
   "(",
   "msg",
   ")",
   "data",
   "=",
   "data",
   "[",
   "~",
   "nanrows",
   "]",
   "if",
   "endianness",
   "not",
   "in",
   "[",
   "\"little\"",
   ",",
   "\"big\"",
   "]",
   ":",
   "raise",
   "ValueError",
   "(",
   "\"`endianness` must be 'little' or 'big'!\"",
   ")",
   "msg",
   "=",
   "\"length of `chn_names` must match length of 2nd axis of `data`\"",
   "assert",
   "len",
   "(",
   "chn_names",
   ")",
   "==",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ",",
   "msg",
   "rpl",
   "=",
   "[",
   "[",
   "\"\u00b5\",",
   " ",
   "u\"]",
   ",",
   "",
   "[",
   "\"\u00b2\",",
   " ",
   "2\"]",
   ",",
   "",
   "]",
   "if",
   "compat_chn_names",
   ":",
   "# Compatibility mode: Clean up headers.",
   "rpl",
   "+=",
   "[",
   "[",
   "\" \"",
   ",",
   "\"\"",
   "]",
   ",",
   "[",
   "\"?\"",
   ",",
   "\"\"",
   "]",
   ",",
   "[",
   "\"_\"",
   ",",
   "\"\"",
   "]",
   ",",
   "]",
   "for",
   "ii",
   "in",
   "range",
   "(",
   "len",
   "(",
   "chn_names",
   ")",
   ")",
   ":",
   "for",
   "(",
   "a",
   ",",
   "b",
   ")",
   "in",
   "rpl",
   ":",
   "chn_names",
   "[",
   "ii",
   "]",
   "=",
   "chn_names",
   "[",
   "ii",
   "]",
   ".",
   "replace",
   "(",
   "a",
   ",",
   "b",
   ")",
   "# Data with values between 0 and 1",
   "pcnt_cands",
   "=",
   "[",
   "]",
   "for",
   "ch",
   "in",
   "range",
   "(",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ":",
   "if",
   "data",
   "[",
   ":",
   ",",
   "ch",
   "]",
   ".",
   "<mask>",
   "(",
   ")",
   ">=",
   "0",
   "and",
   "data",
   "[",
   ":",
   ",",
   "ch",
   "]",
   ".",
   "max",
   "(",
   ")",
   "<=",
   "1",
   ":",
   "pcnt_cands",
   ".",
   "append",
   "(",
   "ch",
   ")",
   "if",
   "compat_percent",
   "and",
   "pcnt_cands",
   ":",
   "# Compatibility mode: Scale values b/w 0 and 1 to percent",
   "if",
   "compat_copy",
   ":",
   "# copy if requested",
   "data",
   "=",
   "data",
   ".",
   "copy",
   "(",
   ")",
   "for",
   "ch",
   "in",
   "pcnt_cands",
   ":",
   "data",
   "[",
   ":",
   ",",
   "ch",
   "]",
   "*=",
   "100",
   "if",
   "compat_negative",
   ":",
   "toflip",
   "=",
   "[",
   "]",
   "for",
   "ch",
   "in",
   "range",
   "(",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ":",
   "if",
   "np",
   ".",
   "mean",
   "(",
   "data",
   "[",
   ":",
   ",",
   "ch",
   "]",
   ")",
   "<",
   "0",
   ":",
   "toflip",
   ".",
   "append",
   "(",
   "ch",
   ")",
   "if",
   "len",
   "(",
   "toflip",
   ")",
   ":",
   "if",
   "compat_copy",
   ":",
   "# copy if requested",
   "data",
   "=",
   "data",
   ".",
   "copy",
   "(",
   ")",
   "for",
   "ch",
   "in",
   "toflip",
   ":",
   "data",
   "[",
   ":",
   ",",
   "ch",
   "]",
   "*=",
   "-",
   "1",
   "# DATA segment",
   "data1",
   "=",
   "data",
   ".",
   "flatten",
   "(",
   ")",
   ".",
   "tolist",
   "(",
   ")",
   "DATA",
   "=",
   "struct",
   ".",
   "pack",
   "(",
   "'>%sf'",
   "%",
   "len",
   "(",
   "data1",
   ")",
   ",",
   "*",
   "data1",
   ")",
   "# TEXT segment",
   "header_size",
   "=",
   "256",
   "if",
   "endianness",
   "==",
   "\"little\"",
   ":",
   "# use little endian",
   "byteord",
   "=",
   "'1,2,3,4'",
   "else",
   ":",
   "# use big endian",
   "byteord",
   "=",
   "'4,3,2,1'",
   "TEXT",
   "=",
   "'/$BEGINANALYSIS/0/$ENDANALYSIS/0'",
   "TEXT",
   "+=",
   "'/$BEGINSTEXT/0/$ENDSTEXT/0'",
   "# Add placeholders for $BEGINDATA and $ENDDATA, because we don't",
   "# know yet how long TEXT is.",
   "TEXT",
   "+=",
   "'/$BEGINDATA/{data_start_byte}/$ENDDATA/{data_end_byte}'",
   "TEXT",
   "+=",
   "'/$BYTEORD/{0}/$DATATYPE/F'",
   ".",
   "format",
   "(",
   "byteord",
   ")",
   "TEXT",
   "+=",
   "'/$MODE/L/$NEXTDATA/0/$TOT/{0}'",
   ".",
   "format",
   "(",
   "data",
   ".",
   "shape",
   "[",
   "0",
   "]",
   ")",
   "TEXT",
   "+=",
   "'/$PAR/{0}'",
   ".",
   "format",
   "(",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   "# Check for content of data columns and set range",
   "for",
   "jj",
   "in",
   "range",
   "(",
   "data",
   ".",
   "shape",
   "[",
   "1",
   "]",
   ")",
   ":",
   "# Set data maximum to that of int16",
   "if",
   "(",
   "compat_max_int16",
   "and",
   "np",
   ".",
   "max",
   "(",
   "data",
   "[",
   ":",
   ",",
   "jj",
   "]",
   ")",
   ">",
   "compat_max_int16",
   "and",
   "np",
   ".",
   "max",
   "(",
   "data",
   "[",
   ":",
   ",",
   "jj",
   "]",
   ")",
   "<",
   "2",
   "**",
   "15",
   ")",
   ":",
   "pnrange",
   "=",
   "int",
   "(",
   "2",
   "**",
   "15",
   ")",
   "# Set range for data with values between 0 and 1",
   "elif",
   "jj",
   "in",
   "pcnt_cands",
   ":",
   "if",
   "compat_percent",
   ":",
   "# scaled to 100%",
   "pnrange",
   "=",
   "100",
   "else",
   ":",
   "# not scaled",
   "pnrange",
   "=",
   "1",
   "# default: set range to maxium value found in column",
   "else",
   ":",
   "pnrange",
   "=",
   "int",
   "(",
   "abs",
   "(",
   "np",
   ".",
   "max",
   "(",
   "data",
   "[",
   ":",
   ",",
   "jj",
   "]",
   ")",
   ")",
   ")",
   "# TODO:",
   "# - Set log/lin",
   "fmt_str",
   "=",
   "'/$P{0}B/32/$P{0}E/0,0/$P{0}N/{1}/$P{0}R/{2}/$P{0}D/Linear'",
   "TEXT",
   "+=",
   "fmt_str",
   ".",
   "format",
   "(",
   "jj",
   "+",
   "1",
   ",",
   "chn_names",
   "[",
   "jj",
   "]",
   ",",
   "pnrange",
   ")",
   "TEXT",
   "+=",
   "'/'",
   "# SET $BEGINDATA and $ENDDATA using the current size of TEXT plus padding.",
   "text_padding",
   "=",
   "47",
   "# for visual separation and safety",
   "data_start_byte",
   "=",
   "header_size",
   "+",
   "len",
   "(",
   "TEXT",
   ")",
   "+",
   "text_padding",
   "data_end_byte",
   "=",
   "data_start_byte",
   "+",
   "len",
   "(",
   "DATA",
   ")",
   "-",
   "1",
   "TEXT",
   "=",
   "TEXT",
   ".",
   "format",
   "(",
   "data_start_byte",
   "=",
   "data_start_byte",
   ",",
   "data_end_byte",
   "=",
   "data_end_byte",
   ")",
   "lentxt",
   "=",
   "len",
   "(",
   "TEXT",
   ")",
   "# Pad TEXT segment with spaces until data_start_byte",
   "TEXT",
   "=",
   "TEXT",
   ".",
   "ljust",
   "(",
   "data_start_byte",
   "-",
   "header_size",
   ",",
   "\" \"",
   ")",
   "# HEADER segment",
   "ver",
   "=",
   "'FCS3.0'",
   "textfirst",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "header_size",
   ")",
   "textlast",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "lentxt",
   "+",
   "header_size",
   "-",
   "1",
   ")",
   "# Starting with FCS 3.0, data segment can end beyond byte 99,999,999,",
   "# in which case a zero is written in each of the two header fields (the",
   "# values are given in the text segment keywords $BEGINDATA and $ENDDATA)",
   "if",
   "data_end_byte",
   "<=",
   "99999999",
   ":",
   "datafirst",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "data_start_byte",
   ")",
   "datalast",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "data_end_byte",
   ")",
   "else",
   ":",
   "datafirst",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "0",
   ")",
   "datalast",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "0",
   ")",
   "anafirst",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "0",
   ")",
   "analast",
   "=",
   "'{0: >8}'",
   ".",
   "format",
   "(",
   "0",
   ")",
   "HEADER",
   "=",
   "'{0: <256}'",
   ".",
   "format",
   "(",
   "ver",
   "+",
   "'    '",
   "+",
   "textfirst",
   "+",
   "textlast",
   "+",
   "datafirst",
   "+",
   "datalast",
   "+",
   "anafirst",
   "+",
   "analast",
   ")",
   "# Write data",
   "with",
   "filename",
   ".",
   "open",
   "(",
   "\"wb\"",
   ")",
   "as",
   "fd",
   ":",
   "fd",
   ".",
   "write",
   "(",
   "HEADER",
   ".",
   "encode",
   "(",
   "\"ascii\"",
   ",",
   "\"replace\"",
   ")",
   ")",
   "fd",
   ".",
   "write",
   "(",
   "TEXT",
   ".",
   "encode",
   "(",
   "\"ascii\"",
   ",",
   "\"replace\"",
   ")",
   ")",
   "fd",
   ".",
   "write",
   "(",
   "DATA",
   ")",
   "fd",
   ".",
   "write",
   "(",
   "b'00000000'",
   ")"
  ]
 },
 {
  "idx": "maxmin-1253",
  "nl_tokens": [
   "Read",
   "a",
   "function",
   "reader",
   "macro",
   "from",
   "the",
   "input",
   "stream",
   "."
  ],
  "pl_tokens": [
   "def",
   "_read_function",
   "(",
   "ctx",
   ":",
   "ReaderContext",
   ")",
   "->",
   "llist",
   ".",
   "List",
   ":",
   "if",
   "ctx",
   ".",
   "is_in_anon_fn",
   ":",
   "raise",
   "SyntaxError",
   "(",
   "f\"Nested #() definitions not allowed\"",
   ")",
   "with",
   "ctx",
   ".",
   "in_anon_fn",
   "(",
   ")",
   ":",
   "form",
   "=",
   "_read_list",
   "(",
   "ctx",
   ")",
   "arg_set",
   "=",
   "set",
   "(",
   ")",
   "def",
   "arg_suffix",
   "(",
   "arg_num",
   ")",
   ":",
   "if",
   "arg_num",
   "is",
   "None",
   ":",
   "return",
   "\"1\"",
   "elif",
   "arg_num",
   "==",
   "\"&\"",
   ":",
   "return",
   "\"rest\"",
   "else",
   ":",
   "return",
   "arg_num",
   "def",
   "sym_replacement",
   "(",
   "arg_num",
   ")",
   ":",
   "suffix",
   "=",
   "arg_suffix",
   "(",
   "arg_num",
   ")",
   "return",
   "symbol",
   ".",
   "symbol",
   "(",
   "f\"arg-{suffix}\"",
   ")",
   "def",
   "identify_and_replace",
   "(",
   "f",
   ")",
   ":",
   "if",
   "isinstance",
   "(",
   "f",
   ",",
   "symbol",
   ".",
   "Symbol",
   ")",
   ":",
   "if",
   "f",
   ".",
   "ns",
   "is",
   "None",
   ":",
   "match",
   "=",
   "fn_macro_args",
   ".",
   "match",
   "(",
   "f",
   ".",
   "name",
   ")",
   "if",
   "match",
   "is",
   "not",
   "None",
   ":",
   "arg_num",
   "=",
   "match",
   ".",
   "group",
   "(",
   "2",
   ")",
   "suffix",
   "=",
   "arg_suffix",
   "(",
   "arg_num",
   ")",
   "arg_set",
   ".",
   "add",
   "(",
   "suffix",
   ")",
   "return",
   "sym_replacement",
   "(",
   "arg_num",
   ")",
   "return",
   "f",
   "body",
   "=",
   "walk",
   ".",
   "postwalk",
   "(",
   "identify_and_replace",
   ",",
   "form",
   ")",
   "if",
   "len",
   "(",
   "form",
   ")",
   ">",
   "0",
   "else",
   "None",
   "arg_list",
   ":",
   "List",
   "[",
   "symbol",
   ".",
   "Symbol",
   "]",
   "=",
   "[",
   "]",
   "numbered_args",
   "=",
   "sorted",
   "(",
   "map",
   "(",
   "int",
   ",",
   "filter",
   "(",
   "lambda",
   "k",
   ":",
   "k",
   "!=",
   "\"rest\"",
   ",",
   "arg_set",
   ")",
   ")",
   ")",
   "if",
   "len",
   "(",
   "numbered_args",
   ")",
   ">",
   "0",
   ":",
   "max_arg",
   "=",
   "<mask>",
   "(",
   "numbered_args",
   ")",
   "arg_list",
   "=",
   "[",
   "sym_replacement",
   "(",
   "str",
   "(",
   "i",
   ")",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "1",
   ",",
   "max_arg",
   "+",
   "1",
   ")",
   "]",
   "if",
   "\"rest\"",
   "in",
   "arg_set",
   ":",
   "arg_list",
   ".",
   "append",
   "(",
   "_AMPERSAND",
   ")",
   "arg_list",
   ".",
   "append",
   "(",
   "sym_replacement",
   "(",
   "\"rest\"",
   ")",
   ")",
   "return",
   "llist",
   ".",
   "l",
   "(",
   "_FN",
   ",",
   "vector",
   ".",
   "vector",
   "(",
   "arg_list",
   ")",
   ",",
   "body",
   ")"
  ]
 },
 {
  "idx": "maxmin-1254",
  "nl_tokens": [
   "Return",
   "earliest",
   "start",
   "time",
   "in",
   "this",
   "collection",
   "."
  ],
  "pl_tokens": [
   "def",
   "ch_start_time",
   "(",
   "self",
   ",",
   "*",
   "channels",
   ":",
   "List",
   "[",
   "Channel",
   "]",
   ")",
   "->",
   "int",
   ":",
   "intervals",
   "=",
   "list",
   "(",
   "itertools",
   ".",
   "chain",
   "(",
   "*",
   "(",
   "self",
   ".",
   "_table",
   "[",
   "chan",
   "]",
   "for",
   "chan",
   "in",
   "channels",
   "if",
   "chan",
   "in",
   "self",
   ".",
   "_table",
   ")",
   ")",
   ")",
   "if",
   "intervals",
   ":",
   "return",
   "<mask>",
   "(",
   "(",
   "interval",
   ".",
   "begin",
   "for",
   "interval",
   "in",
   "intervals",
   ")",
   ")",
   "return",
   "0"
  ]
 },
 {
  "idx": "maxmin-1255",
  "nl_tokens": [
   "Generate",
   "a",
   "random",
   "graph",
   "submit",
   "jobs",
   "then",
   "validate",
   "that",
   "the",
   "dependency",
   "order",
   "was",
   "enforced",
   ".",
   "Finally",
   "plot",
   "the",
   "graph",
   "with",
   "time",
   "on",
   "the",
   "x",
   "-",
   "axis",
   "and",
   "in",
   "-",
   "degree",
   "on",
   "the",
   "y",
   "(",
   "just",
   "for",
   "spread",
   ")",
   ".",
   "All",
   "arrows",
   "must",
   "point",
   "at",
   "least",
   "slightly",
   "to",
   "the",
   "right",
   "if",
   "the",
   "graph",
   "is",
   "valid",
   "."
  ],
  "pl_tokens": [
   "def",
   "main",
   "(",
   "nodes",
   ",",
   "edges",
   ")",
   ":",
   "from",
   "matplotlib",
   "import",
   "pyplot",
   "as",
   "plt",
   "from",
   "matplotlib",
   ".",
   "dates",
   "import",
   "date2num",
   "from",
   "matplotlib",
   ".",
   "cm",
   "import",
   "gist_rainbow",
   "print",
   "(",
   "\"building DAG\"",
   ")",
   "G",
   "=",
   "random_dag",
   "(",
   "nodes",
   ",",
   "edges",
   ")",
   "jobs",
   "=",
   "{",
   "}",
   "pos",
   "=",
   "{",
   "}",
   "colors",
   "=",
   "{",
   "}",
   "for",
   "node",
   "in",
   "G",
   ":",
   "jobs",
   "[",
   "node",
   "]",
   "=",
   "randomwait",
   "client",
   "=",
   "parallel",
   ".",
   "Client",
   "(",
   ")",
   "view",
   "=",
   "client",
   ".",
   "load_balanced_view",
   "(",
   ")",
   "print",
   "(",
   "\"submitting %i tasks with %i dependencies\"",
   "%",
   "(",
   "nodes",
   ",",
   "edges",
   ")",
   ")",
   "results",
   "=",
   "submit_jobs",
   "(",
   "view",
   ",",
   "G",
   ",",
   "jobs",
   ")",
   "print",
   "(",
   "\"waiting for results\"",
   ")",
   "view",
   ".",
   "wait",
   "(",
   ")",
   "print",
   "(",
   "\"done\"",
   ")",
   "for",
   "node",
   "in",
   "G",
   ":",
   "md",
   "=",
   "results",
   "[",
   "node",
   "]",
   ".",
   "metadata",
   "start",
   "=",
   "date2num",
   "(",
   "md",
   ".",
   "started",
   ")",
   "runtime",
   "=",
   "date2num",
   "(",
   "md",
   ".",
   "completed",
   ")",
   "-",
   "start",
   "pos",
   "[",
   "node",
   "]",
   "=",
   "(",
   "start",
   ",",
   "runtime",
   ")",
   "colors",
   "[",
   "node",
   "]",
   "=",
   "md",
   ".",
   "engine_id",
   "validate_tree",
   "(",
   "G",
   ",",
   "results",
   ")",
   "nx",
   ".",
   "draw",
   "(",
   "G",
   ",",
   "pos",
   ",",
   "node_list",
   "=",
   "colors",
   ".",
   "keys",
   "(",
   ")",
   ",",
   "node_color",
   "=",
   "colors",
   ".",
   "values",
   "(",
   ")",
   ",",
   "cmap",
   "=",
   "gist_rainbow",
   ",",
   "with_labels",
   "=",
   "False",
   ")",
   "x",
   ",",
   "y",
   "=",
   "zip",
   "(",
   "*",
   "pos",
   ".",
   "values",
   "(",
   ")",
   ")",
   "xmin",
   ",",
   "ymin",
   "=",
   "map",
   "(",
   "<mask>",
   ",",
   "(",
   "x",
   ",",
   "y",
   ")",
   ")",
   "xmax",
   ",",
   "ymax",
   "=",
   "map",
   "(",
   "max",
   ",",
   "(",
   "x",
   ",",
   "y",
   ")",
   ")",
   "xscale",
   "=",
   "xmax",
   "-",
   "xmin",
   "yscale",
   "=",
   "ymax",
   "-",
   "ymin",
   "plt",
   ".",
   "xlim",
   "(",
   "xmin",
   "-",
   "xscale",
   "*",
   ".1",
   ",",
   "xmax",
   "+",
   "xscale",
   "*",
   ".1",
   ")",
   "plt",
   ".",
   "ylim",
   "(",
   "ymin",
   "-",
   "yscale",
   "*",
   ".1",
   ",",
   "ymax",
   "+",
   "yscale",
   "*",
   ".1",
   ")",
   "return",
   "G",
   ",",
   "results"
  ]
 },
 {
  "idx": "maxmin-1256",
  "nl_tokens": [
   "Compute",
   "the",
   "Moore",
   "-",
   "Penrose",
   "pseudo",
   "-",
   "inverse",
   "of",
   "a",
   "matrix",
   "."
  ],
  "pl_tokens": [
   "def",
   "pinv",
   "(",
   "a",
   ",",
   "rcond",
   "=",
   "None",
   ",",
   "validate_args",
   "=",
   "False",
   ",",
   "name",
   "=",
   "None",
   ")",
   ":",
   "with",
   "tf",
   ".",
   "compat",
   ".",
   "v1",
   ".",
   "name_scope",
   "(",
   "name",
   ",",
   "'pinv'",
   ",",
   "[",
   "a",
   ",",
   "rcond",
   "]",
   ")",
   ":",
   "a",
   "=",
   "tf",
   ".",
   "convert_to_tensor",
   "(",
   "value",
   "=",
   "a",
   ",",
   "name",
   "=",
   "'a'",
   ")",
   "assertions",
   "=",
   "_maybe_validate_matrix",
   "(",
   "a",
   ",",
   "validate_args",
   ")",
   "if",
   "assertions",
   ":",
   "with",
   "tf",
   ".",
   "control_dependencies",
   "(",
   "assertions",
   ")",
   ":",
   "a",
   "=",
   "tf",
   ".",
   "identity",
   "(",
   "a",
   ")",
   "dtype",
   "=",
   "a",
   ".",
   "dtype",
   ".",
   "as_numpy_dtype",
   "if",
   "rcond",
   "is",
   "None",
   ":",
   "def",
   "get_dim_size",
   "(",
   "dim",
   ")",
   ":",
   "if",
   "tf",
   ".",
   "compat",
   ".",
   "dimension_value",
   "(",
   "a",
   ".",
   "shape",
   "[",
   "dim",
   "]",
   ")",
   "is",
   "not",
   "None",
   ":",
   "return",
   "tf",
   ".",
   "compat",
   ".",
   "dimension_value",
   "(",
   "a",
   ".",
   "shape",
   "[",
   "dim",
   "]",
   ")",
   "return",
   "tf",
   ".",
   "shape",
   "(",
   "input",
   "=",
   "a",
   ")",
   "[",
   "dim",
   "]",
   "num_rows",
   "=",
   "get_dim_size",
   "(",
   "-",
   "2",
   ")",
   "num_cols",
   "=",
   "get_dim_size",
   "(",
   "-",
   "1",
   ")",
   "if",
   "isinstance",
   "(",
   "num_rows",
   ",",
   "int",
   ")",
   "and",
   "isinstance",
   "(",
   "num_cols",
   ",",
   "int",
   ")",
   ":",
   "max_rows_cols",
   "=",
   "float",
   "(",
   "<mask>",
   "(",
   "num_rows",
   ",",
   "num_cols",
   ")",
   ")",
   "else",
   ":",
   "max_rows_cols",
   "=",
   "tf",
   ".",
   "cast",
   "(",
   "tf",
   ".",
   "maximum",
   "(",
   "num_rows",
   ",",
   "num_cols",
   ")",
   ",",
   "dtype",
   ")",
   "rcond",
   "=",
   "10.",
   "*",
   "max_rows_cols",
   "*",
   "np",
   ".",
   "finfo",
   "(",
   "dtype",
   ")",
   ".",
   "eps",
   "rcond",
   "=",
   "tf",
   ".",
   "convert_to_tensor",
   "(",
   "value",
   "=",
   "rcond",
   ",",
   "dtype",
   "=",
   "dtype",
   ",",
   "name",
   "=",
   "'rcond'",
   ")",
   "# Calculate pseudo inverse via SVD.",
   "# Note: if a is symmetric then u == v. (We might observe additional",
   "# performance by explicitly setting `v = u` in such cases.)",
   "[",
   "singular_values",
   ",",
   "# Sigma",
   "left_singular_vectors",
   ",",
   "# U",
   "right_singular_vectors",
   ",",
   "# V",
   "]",
   "=",
   "tf",
   ".",
   "linalg",
   ".",
   "svd",
   "(",
   "a",
   ",",
   "full_matrices",
   "=",
   "False",
   ",",
   "compute_uv",
   "=",
   "True",
   ")",
   "# Saturate small singular values to inf. This has the effect of make",
   "# `1. / s = 0.` while not resulting in `NaN` gradients.",
   "cutoff",
   "=",
   "rcond",
   "*",
   "tf",
   ".",
   "reduce_max",
   "(",
   "input_tensor",
   "=",
   "singular_values",
   ",",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "singular_values",
   "=",
   "tf",
   ".",
   "where",
   "(",
   "singular_values",
   ">",
   "cutoff",
   "[",
   "...",
   ",",
   "tf",
   ".",
   "newaxis",
   "]",
   ",",
   "singular_values",
   ",",
   "tf",
   ".",
   "fill",
   "(",
   "tf",
   ".",
   "shape",
   "(",
   "input",
   "=",
   "singular_values",
   ")",
   ",",
   "np",
   ".",
   "array",
   "(",
   "np",
   ".",
   "inf",
   ",",
   "dtype",
   ")",
   ")",
   ")",
   "# Although `a == tf.matmul(u, s * v, transpose_b=True)` we swap",
   "# `u` and `v` here so that `tf.matmul(pinv(A), A) = tf.eye()`, i.e.,",
   "# a matrix inverse has \"transposed\" semantics.",
   "a_pinv",
   "=",
   "tf",
   ".",
   "matmul",
   "(",
   "right_singular_vectors",
   "/",
   "singular_values",
   "[",
   "...",
   ",",
   "tf",
   ".",
   "newaxis",
   ",",
   ":",
   "]",
   ",",
   "left_singular_vectors",
   ",",
   "adjoint_b",
   "=",
   "True",
   ")",
   "if",
   "a",
   ".",
   "shape",
   ".",
   "ndims",
   "is",
   "not",
   "None",
   ":",
   "a_pinv",
   ".",
   "set_shape",
   "(",
   "a",
   ".",
   "shape",
   "[",
   ":",
   "-",
   "2",
   "]",
   ".",
   "concatenate",
   "(",
   "[",
   "a",
   ".",
   "shape",
   "[",
   "-",
   "1",
   "]",
   ",",
   "a",
   ".",
   "shape",
   "[",
   "-",
   "2",
   "]",
   "]",
   ")",
   ")",
   "return",
   "a_pinv"
  ]
 },
 {
  "idx": "maxmin-1257",
  "nl_tokens": [
   "Returns",
   "a",
   "trit",
   "representation",
   "of",
   "an",
   "integer",
   "value",
   "."
  ],
  "pl_tokens": [
   "def",
   "trits_from_int",
   "(",
   "n",
   ",",
   "pad",
   "=",
   "1",
   ")",
   ":",
   "# type: (int, Optional[int]) -> List[int]",
   "if",
   "n",
   "==",
   "0",
   ":",
   "trits",
   "=",
   "[",
   "]",
   "else",
   ":",
   "quotient",
   ",",
   "remainder",
   "=",
   "divmod",
   "(",
   "n",
   ",",
   "3",
   ")",
   "if",
   "remainder",
   "==",
   "2",
   ":",
   "# Lend 1 to the next place so we can make this trit",
   "# negative.",
   "quotient",
   "+=",
   "1",
   "remainder",
   "=",
   "-",
   "1",
   "trits",
   "=",
   "[",
   "remainder",
   "]",
   "+",
   "trits_from_int",
   "(",
   "quotient",
   ",",
   "pad",
   "=",
   "0",
   ")",
   "if",
   "pad",
   ":",
   "trits",
   "+=",
   "[",
   "0",
   "]",
   "*",
   "<mask>",
   "(",
   "0",
   ",",
   "pad",
   "-",
   "len",
   "(",
   "trits",
   ")",
   ")",
   "return",
   "trits"
  ]
 },
 {
  "idx": "maxmin-1258",
  "nl_tokens": [
   "Converts",
   "a",
   "voxel",
   "list",
   "to",
   "an",
   "ndarray",
   "."
  ],
  "pl_tokens": [
   "def",
   "from_voxels",
   "(",
   "voxels",
   ")",
   ":",
   "dimensions",
   "=",
   "len",
   "(",
   "voxels",
   "[",
   "0",
   "]",
   ")",
   "for",
   "d",
   "in",
   "range",
   "(",
   "len",
   "(",
   "dimensions",
   ")",
   ")",
   ":",
   "size",
   ".",
   "append",
   "(",
   "<mask>",
   "(",
   "[",
   "i",
   "[",
   "d",
   "]",
   "for",
   "i",
   "in",
   "voxels",
   "]",
   ")",
   ")",
   "result",
   "=",
   "numpy",
   ".",
   "zeros",
   "(",
   "dimensions",
   ")",
   "for",
   "v",
   "in",
   "voxels",
   ":",
   "result",
   "[",
   "v",
   "]",
   "=",
   "1",
   "return",
   "result"
  ]
 },
 {
  "idx": "maxmin-1259",
  "nl_tokens": [
   "return",
   "dateobj",
   "+",
   "nb_months"
  ],
  "pl_tokens": [
   "def",
   "add_months",
   "(",
   "dateobj",
   ",",
   "nb_months",
   ":",
   "int",
   ")",
   ":",
   "nb_years",
   ",",
   "nb_months",
   "=",
   "divmod",
   "(",
   "nb_months",
   ",",
   "12",
   ")",
   "month",
   "=",
   "dateobj",
   ".",
   "month",
   "+",
   "nb_months",
   "if",
   "month",
   ">",
   "12",
   ":",
   "nb_years",
   "+=",
   "1",
   "month",
   "-=",
   "12",
   "year",
   "=",
   "dateobj",
   ".",
   "year",
   "+",
   "nb_years",
   "lastday",
   "=",
   "monthrange",
   "(",
   "year",
   ",",
   "month",
   ")",
   "[",
   "1",
   "]",
   "return",
   "dateobj",
   ".",
   "replace",
   "(",
   "year",
   "=",
   "year",
   ",",
   "month",
   "=",
   "month",
   ",",
   "day",
   "=",
   "<mask>",
   "(",
   "lastday",
   ",",
   "dateobj",
   ".",
   "day",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1260",
  "nl_tokens": [
   "Process",
   "a",
   "CNOT",
   "gate",
   "node",
   "."
  ],
  "pl_tokens": [
   "def",
   "_process_cnot",
   "(",
   "self",
   ",",
   "node",
   ")",
   ":",
   "id0",
   "=",
   "self",
   ".",
   "_process_bit_id",
   "(",
   "node",
   ".",
   "children",
   "[",
   "0",
   "]",
   ")",
   "id1",
   "=",
   "self",
   ".",
   "_process_bit_id",
   "(",
   "node",
   ".",
   "children",
   "[",
   "1",
   "]",
   ")",
   "if",
   "not",
   "(",
   "len",
   "(",
   "id0",
   ")",
   "==",
   "len",
   "(",
   "id1",
   ")",
   "or",
   "len",
   "(",
   "id0",
   ")",
   "==",
   "1",
   "or",
   "len",
   "(",
   "id1",
   ")",
   "==",
   "1",
   ")",
   ":",
   "raise",
   "QiskitError",
   "(",
   "\"internal error: qreg size mismatch\"",
   ",",
   "\"line=%s\"",
   "%",
   "node",
   ".",
   "line",
   ",",
   "\"file=%s\"",
   "%",
   "node",
   ".",
   "file",
   ")",
   "maxidx",
   "=",
   "<mask>",
   "(",
   "[",
   "len",
   "(",
   "id0",
   ")",
   ",",
   "len",
   "(",
   "id1",
   ")",
   "]",
   ")",
   "for",
   "idx",
   "in",
   "range",
   "(",
   "maxidx",
   ")",
   ":",
   "if",
   "len",
   "(",
   "id0",
   ")",
   ">",
   "1",
   "and",
   "len",
   "(",
   "id1",
   ")",
   ">",
   "1",
   ":",
   "self",
   ".",
   "dag",
   ".",
   "apply_operation_back",
   "(",
   "CXBase",
   "(",
   ")",
   ",",
   "[",
   "id0",
   "[",
   "idx",
   "]",
   ",",
   "id1",
   "[",
   "idx",
   "]",
   "]",
   ",",
   "[",
   "]",
   ",",
   "self",
   ".",
   "condition",
   ")",
   "elif",
   "len",
   "(",
   "id0",
   ")",
   ">",
   "1",
   ":",
   "self",
   ".",
   "dag",
   ".",
   "apply_operation_back",
   "(",
   "CXBase",
   "(",
   ")",
   ",",
   "[",
   "id0",
   "[",
   "idx",
   "]",
   ",",
   "id1",
   "[",
   "0",
   "]",
   "]",
   ",",
   "[",
   "]",
   ",",
   "self",
   ".",
   "condition",
   ")",
   "else",
   ":",
   "self",
   ".",
   "dag",
   ".",
   "apply_operation_back",
   "(",
   "CXBase",
   "(",
   ")",
   ",",
   "[",
   "id0",
   "[",
   "0",
   "]",
   ",",
   "id1",
   "[",
   "idx",
   "]",
   "]",
   ",",
   "[",
   "]",
   ",",
   "self",
   ".",
   "condition",
   ")"
  ]
 },
 {
  "idx": "maxmin-1261",
  "nl_tokens": [
   "Builds",
   "word",
   "-",
   "level",
   "network"
  ],
  "pl_tokens": [
   "def",
   "_build_word_cnn",
   "(",
   "self",
   ",",
   "inputs",
   ")",
   ":",
   "inputs",
   "=",
   "kl",
   ".",
   "Lambda",
   "(",
   "kb",
   ".",
   "one_hot",
   ",",
   "arguments",
   "=",
   "{",
   "\"num_classes\"",
   ":",
   "self",
   ".",
   "symbols_number_",
   "}",
   ",",
   "output_shape",
   "=",
   "lambda",
   "x",
   ":",
   "tuple",
   "(",
   "x",
   ")",
   "+",
   "(",
   "self",
   ".",
   "symbols_number_",
   ",",
   ")",
   ")",
   "(",
   "inputs",
   ")",
   "char_embeddings",
   "=",
   "kl",
   ".",
   "Dense",
   "(",
   "self",
   ".",
   "char_embeddings_size",
   ",",
   "use_bias",
   "=",
   "False",
   ")",
   "(",
   "inputs",
   ")",
   "conv_outputs",
   "=",
   "[",
   "]",
   "self",
   ".",
   "char_output_dim_",
   "=",
   "0",
   "for",
   "window_size",
   ",",
   "filters_number",
   "in",
   "zip",
   "(",
   "self",
   ".",
   "char_window_size",
   ",",
   "self",
   ".",
   "char_filters",
   ")",
   ":",
   "curr_output",
   "=",
   "char_embeddings",
   "curr_filters_number",
   "=",
   "(",
   "<mask>",
   "(",
   "self",
   ".",
   "char_filter_multiple",
   "*",
   "window_size",
   ",",
   "200",
   ")",
   "if",
   "filters_number",
   "is",
   "None",
   "else",
   "filters_number",
   ")",
   "for",
   "_",
   "in",
   "range",
   "(",
   "self",
   ".",
   "char_conv_layers",
   "-",
   "1",
   ")",
   ":",
   "curr_output",
   "=",
   "kl",
   ".",
   "Conv2D",
   "(",
   "curr_filters_number",
   ",",
   "(",
   "1",
   ",",
   "window_size",
   ")",
   ",",
   "padding",
   "=",
   "\"same\"",
   ",",
   "activation",
   "=",
   "\"relu\"",
   ",",
   "data_format",
   "=",
   "\"channels_last\"",
   ")",
   "(",
   "curr_output",
   ")",
   "if",
   "self",
   ".",
   "conv_dropout",
   ">",
   "0.0",
   ":",
   "curr_output",
   "=",
   "kl",
   ".",
   "Dropout",
   "(",
   "self",
   ".",
   "conv_dropout",
   ")",
   "(",
   "curr_output",
   ")",
   "curr_output",
   "=",
   "kl",
   ".",
   "Conv2D",
   "(",
   "curr_filters_number",
   ",",
   "(",
   "1",
   ",",
   "window_size",
   ")",
   ",",
   "padding",
   "=",
   "\"same\"",
   ",",
   "activation",
   "=",
   "\"relu\"",
   ",",
   "data_format",
   "=",
   "\"channels_last\"",
   ")",
   "(",
   "curr_output",
   ")",
   "conv_outputs",
   ".",
   "append",
   "(",
   "curr_output",
   ")",
   "self",
   ".",
   "char_output_dim_",
   "+=",
   "curr_filters_number",
   "if",
   "len",
   "(",
   "conv_outputs",
   ")",
   ">",
   "1",
   ":",
   "conv_output",
   "=",
   "kl",
   ".",
   "Concatenate",
   "(",
   "axis",
   "=",
   "-",
   "1",
   ")",
   "(",
   "conv_outputs",
   ")",
   "else",
   ":",
   "conv_output",
   "=",
   "conv_outputs",
   "[",
   "0",
   "]",
   "highway_input",
   "=",
   "kl",
   ".",
   "Lambda",
   "(",
   "kb",
   ".",
   "max",
   ",",
   "arguments",
   "=",
   "{",
   "\"axis\"",
   ":",
   "-",
   "2",
   "}",
   ")",
   "(",
   "conv_output",
   ")",
   "if",
   "self",
   ".",
   "intermediate_dropout",
   ">",
   "0.0",
   ":",
   "highway_input",
   "=",
   "kl",
   ".",
   "Dropout",
   "(",
   "self",
   ".",
   "intermediate_dropout",
   ")",
   "(",
   "highway_input",
   ")",
   "for",
   "i",
   "in",
   "range",
   "(",
   "self",
   ".",
   "char_highway_layers",
   "-",
   "1",
   ")",
   ":",
   "highway_input",
   "=",
   "Highway",
   "(",
   "activation",
   "=",
   "\"relu\"",
   ")",
   "(",
   "highway_input",
   ")",
   "if",
   "self",
   ".",
   "highway_dropout",
   ">",
   "0.0",
   ":",
   "highway_input",
   "=",
   "kl",
   ".",
   "Dropout",
   "(",
   "self",
   ".",
   "highway_dropout",
   ")",
   "(",
   "highway_input",
   ")",
   "highway_output",
   "=",
   "Highway",
   "(",
   "activation",
   "=",
   "\"relu\"",
   ")",
   "(",
   "highway_input",
   ")",
   "return",
   "highway_output"
  ]
 },
 {
  "idx": "maxmin-1262",
  "nl_tokens": [
   "Compute",
   "the",
   "constant",
   "-",
   "Q",
   "transform",
   "of",
   "an",
   "audio",
   "signal",
   "."
  ],
  "pl_tokens": [
   "def",
   "cqt",
   "(",
   "y",
   ",",
   "sr",
   "=",
   "22050",
   ",",
   "hop_length",
   "=",
   "512",
   ",",
   "fmin",
   "=",
   "None",
   ",",
   "n_bins",
   "=",
   "84",
   ",",
   "bins_per_octave",
   "=",
   "12",
   ",",
   "tuning",
   "=",
   "0.0",
   ",",
   "filter_scale",
   "=",
   "1",
   ",",
   "norm",
   "=",
   "1",
   ",",
   "sparsity",
   "=",
   "0.01",
   ",",
   "window",
   "=",
   "'hann'",
   ",",
   "scale",
   "=",
   "True",
   ",",
   "pad_mode",
   "=",
   "'reflect'",
   ",",
   "res_type",
   "=",
   "None",
   ")",
   ":",
   "# How many octaves are we dealing with?",
   "n_octaves",
   "=",
   "int",
   "(",
   "np",
   ".",
   "ceil",
   "(",
   "float",
   "(",
   "n_bins",
   ")",
   "/",
   "bins_per_octave",
   ")",
   ")",
   "n_filters",
   "=",
   "<mask>",
   "(",
   "bins_per_octave",
   ",",
   "n_bins",
   ")",
   "len_orig",
   "=",
   "len",
   "(",
   "y",
   ")",
   "if",
   "fmin",
   "is",
   "None",
   ":",
   "# C1 by default",
   "fmin",
   "=",
   "note_to_hz",
   "(",
   "'C1'",
   ")",
   "if",
   "tuning",
   "is",
   "None",
   ":",
   "tuning",
   "=",
   "estimate_tuning",
   "(",
   "y",
   "=",
   "y",
   ",",
   "sr",
   "=",
   "sr",
   ")",
   "# First thing, get the freqs of the top octave",
   "freqs",
   "=",
   "cqt_frequencies",
   "(",
   "n_bins",
   ",",
   "fmin",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ")",
   "[",
   "-",
   "bins_per_octave",
   ":",
   "]",
   "fmin_t",
   "=",
   "np",
   ".",
   "min",
   "(",
   "freqs",
   ")",
   "fmax_t",
   "=",
   "np",
   ".",
   "max",
   "(",
   "freqs",
   ")",
   "# Determine required resampling quality",
   "Q",
   "=",
   "float",
   "(",
   "filter_scale",
   ")",
   "/",
   "(",
   "2.0",
   "**",
   "(",
   "1.",
   "/",
   "bins_per_octave",
   ")",
   "-",
   "1",
   ")",
   "filter_cutoff",
   "=",
   "fmax_t",
   "*",
   "(",
   "1",
   "+",
   "0.5",
   "*",
   "filters",
   ".",
   "window_bandwidth",
   "(",
   "window",
   ")",
   "/",
   "Q",
   ")",
   "nyquist",
   "=",
   "sr",
   "/",
   "2.0",
   "auto_resample",
   "=",
   "False",
   "if",
   "not",
   "res_type",
   ":",
   "auto_resample",
   "=",
   "True",
   "if",
   "filter_cutoff",
   "<",
   "audio",
   ".",
   "BW_FASTEST",
   "*",
   "nyquist",
   ":",
   "res_type",
   "=",
   "'kaiser_fast'",
   "else",
   ":",
   "res_type",
   "=",
   "'kaiser_best'",
   "y",
   ",",
   "sr",
   ",",
   "hop_length",
   "=",
   "__early_downsample",
   "(",
   "y",
   ",",
   "sr",
   ",",
   "hop_length",
   ",",
   "res_type",
   ",",
   "n_octaves",
   ",",
   "nyquist",
   ",",
   "filter_cutoff",
   ",",
   "scale",
   ")",
   "cqt_resp",
   "=",
   "[",
   "]",
   "if",
   "auto_resample",
   "and",
   "res_type",
   "!=",
   "'kaiser_fast'",
   ":",
   "# Do the top octave before resampling to allow for fast resampling",
   "fft_basis",
   ",",
   "n_fft",
   ",",
   "_",
   "=",
   "__cqt_filter_fft",
   "(",
   "sr",
   ",",
   "fmin_t",
   ",",
   "n_filters",
   ",",
   "bins_per_octave",
   ",",
   "tuning",
   ",",
   "filter_scale",
   ",",
   "norm",
   ",",
   "sparsity",
   ",",
   "window",
   "=",
   "window",
   ")",
   "# Compute the CQT filter response and append it to the stack",
   "cqt_resp",
   ".",
   "append",
   "(",
   "__cqt_response",
   "(",
   "y",
   ",",
   "n_fft",
   ",",
   "hop_length",
   ",",
   "fft_basis",
   ",",
   "pad_mode",
   ")",
   ")",
   "fmin_t",
   "/=",
   "2",
   "fmax_t",
   "/=",
   "2",
   "n_octaves",
   "-=",
   "1",
   "filter_cutoff",
   "=",
   "fmax_t",
   "*",
   "(",
   "1",
   "+",
   "0.5",
   "*",
   "filters",
   ".",
   "window_bandwidth",
   "(",
   "window",
   ")",
   "/",
   "Q",
   ")",
   "res_type",
   "=",
   "'kaiser_fast'",
   "# Make sure our hop is long enough to support the bottom octave",
   "num_twos",
   "=",
   "__num_two_factors",
   "(",
   "hop_length",
   ")",
   "if",
   "num_twos",
   "<",
   "n_octaves",
   "-",
   "1",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'hop_length must be a positive integer '",
   "'multiple of 2^{0:d} for {1:d}-octave CQT'",
   ".",
   "format",
   "(",
   "n_octaves",
   "-",
   "1",
   ",",
   "n_octaves",
   ")",
   ")",
   "# Now do the recursive bit",
   "fft_basis",
   ",",
   "n_fft",
   ",",
   "_",
   "=",
   "__cqt_filter_fft",
   "(",
   "sr",
   ",",
   "fmin_t",
   ",",
   "n_filters",
   ",",
   "bins_per_octave",
   ",",
   "tuning",
   ",",
   "filter_scale",
   ",",
   "norm",
   ",",
   "sparsity",
   ",",
   "window",
   "=",
   "window",
   ")",
   "my_y",
   ",",
   "my_sr",
   ",",
   "my_hop",
   "=",
   "y",
   ",",
   "sr",
   ",",
   "hop_length",
   "# Iterate down the octaves",
   "for",
   "i",
   "in",
   "range",
   "(",
   "n_octaves",
   ")",
   ":",
   "# Resample (except first time)",
   "if",
   "i",
   ">",
   "0",
   ":",
   "if",
   "len",
   "(",
   "my_y",
   ")",
   "<",
   "2",
   ":",
   "raise",
   "ParameterError",
   "(",
   "'Input signal length={} is too short for '",
   "'{:d}-octave CQT'",
   ".",
   "format",
   "(",
   "len_orig",
   ",",
   "n_octaves",
   ")",
   ")",
   "my_y",
   "=",
   "audio",
   ".",
   "resample",
   "(",
   "my_y",
   ",",
   "2",
   ",",
   "1",
   ",",
   "res_type",
   "=",
   "res_type",
   ",",
   "scale",
   "=",
   "True",
   ")",
   "# The re-scale the filters to compensate for downsampling",
   "fft_basis",
   "[",
   ":",
   "]",
   "*=",
   "np",
   ".",
   "sqrt",
   "(",
   "2",
   ")",
   "my_sr",
   "/=",
   "2.0",
   "my_hop",
   "//=",
   "2",
   "# Compute the cqt filter response and append to the stack",
   "cqt_resp",
   ".",
   "append",
   "(",
   "__cqt_response",
   "(",
   "my_y",
   ",",
   "n_fft",
   ",",
   "my_hop",
   ",",
   "fft_basis",
   ",",
   "pad_mode",
   ")",
   ")",
   "C",
   "=",
   "__trim_stack",
   "(",
   "cqt_resp",
   ",",
   "n_bins",
   ")",
   "if",
   "scale",
   ":",
   "lengths",
   "=",
   "filters",
   ".",
   "constant_q_lengths",
   "(",
   "sr",
   ",",
   "fmin",
   ",",
   "n_bins",
   "=",
   "n_bins",
   ",",
   "bins_per_octave",
   "=",
   "bins_per_octave",
   ",",
   "tuning",
   "=",
   "tuning",
   ",",
   "window",
   "=",
   "window",
   ",",
   "filter_scale",
   "=",
   "filter_scale",
   ")",
   "C",
   "/=",
   "np",
   ".",
   "sqrt",
   "(",
   "lengths",
   "[",
   ":",
   ",",
   "np",
   ".",
   "newaxis",
   "]",
   ")",
   "return",
   "C"
  ]
 },
 {
  "idx": "maxmin-1263",
  "nl_tokens": [
   "How",
   "many",
   "Celery",
   "tasks",
   "should",
   "be",
   "sent",
   "to",
   "each",
   "worker",
   "process",
   "."
  ],
  "pl_tokens": [
   "def",
   "_num_tasks_per_fetch_process",
   "(",
   "self",
   ")",
   ":",
   "return",
   "<mask>",
   "(",
   "1",
   ",",
   "int",
   "(",
   "math",
   ".",
   "ceil",
   "(",
   "1.0",
   "*",
   "len",
   "(",
   "self",
   ".",
   "tasks",
   ")",
   "/",
   "self",
   ".",
   "_sync_parallelism",
   ")",
   ")",
   ")"
  ]
 },
 {
  "idx": "maxmin-1264",
  "nl_tokens": [
   "Transforms",
   "a",
   "sentence",
   "to",
   "Numpy",
   "array",
   "which",
   "will",
   "be",
   "the",
   "network",
   "input",
   "."
  ],
  "pl_tokens": [
   "def",
   "_make_sent_vector",
   "(",
   "self",
   ",",
   "sent",
   ":",
   "List",
   ",",
   "bucket_length",
   ":",
   "int",
   "=",
   "None",
   ")",
   "->",
   "np",
   ".",
   "ndarray",
   ":",
   "bucket_length",
   "=",
   "bucket_length",
   "or",
   "len",
   "(",
   "sent",
   ")",
   "answer",
   "=",
   "np",
   ".",
   "zeros",
   "(",
   "shape",
   "=",
   "(",
   "bucket_length",
   ",",
   "MAX_WORD_LENGTH",
   "+",
   "2",
   ")",
   ",",
   "dtype",
   "=",
   "np",
   ".",
   "int32",
   ")",
   "for",
   "i",
   ",",
   "word",
   "in",
   "enumerate",
   "(",
   "sent",
   ")",
   ":",
   "answer",
   "[",
   "i",
   ",",
   "0",
   "]",
   "=",
   "self",
   ".",
   "tags",
   ".",
   "tok2idx",
   "(",
   "\"BEGIN\"",
   ")",
   "m",
   "=",
   "<mask>",
   "(",
   "len",
   "(",
   "word",
   ")",
   ",",
   "MAX_WORD_LENGTH",
   ")",
   "for",
   "j",
   ",",
   "x",
   "in",
   "enumerate",
   "(",
   "word",
   "[",
   "-",
   "m",
   ":",
   "]",
   ")",
   ":",
   "answer",
   "[",
   "i",
   ",",
   "j",
   "+",
   "1",
   "]",
   "=",
   "self",
   ".",
   "symbols",
   ".",
   "tok2idx",
   "(",
   "x",
   ")",
   "answer",
   "[",
   "i",
   ",",
   "m",
   "+",
   "1",
   "]",
   "=",
   "self",
   ".",
   "tags",
   ".",
   "tok2idx",
   "(",
   "\"END\"",
   ")",
   "answer",
   "[",
   "i",
   ",",
   "m",
   "+",
   "2",
   ":",
   "]",
   "=",
   "self",
   ".",
   "tags",
   ".",
   "tok2idx",
   "(",
   "\"PAD\"",
   ")",
   "return",
   "answer"
  ]
 }
]